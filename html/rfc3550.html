<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 3550 - RTP: A Transport Protocol for Real-Time Applications 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3550</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc3550">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 3550 - RTP: A Transport Protocol for Real-Time Applications 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc3550">
              https://tools.ietf.org/html/rfc3550
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 3550 - RTP：リアルタイムアプリケーションのためのトランスポートプロトコル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                     H. Schulzrinne
Request for Comments: 3550                           Columbia University
Obsoletes: 1889                                               S.  Casner
Category: Standards Track                                  Packet Design
                                                            R. Frederick
                                                  Blue Coat Systems Inc.
                                                             V. Jacobson
                                                           Packet Design
                                                               July 2003
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          RTP: A Transport Protocol for Real-Time Applications
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memorandum describes RTP, the real-time transport protocol. RTP provides end-to-end network transport functions suitable for applications transmitting real-time data, such as audio, video or simulation data, over multicast or unicast network services. RTP does not address resource reservation and does not guarantee quality-of-service for real-time services. The data transport is augmented by a control protocol (RTCP) to allow monitoring of the data delivery in a manner scalable to large multicast networks, and to provide minimal control and identification functionality. RTP and RTCP are designed to be independent of the underlying transport and network layers. The protocol supports the use of RTP-level translators and mixers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモはRTP、リアルタイムトランスポートプロトコルを記述します。 RTPは、マルチキャストまたはユニキャストネットワークサービス上、そのようなオーディオ、ビデオ又はシミュレーションデータなどのリアルタイムデータを送信するアプリケーションに適したエンドツーエンドのネットワークトランスポート機能を提供します。 RTPは、リソース予約には対応していませんし、サービス品質のリアルタイムサービスのためを保証するものではありません。データ転送は、大規模なマルチキャストネットワークに対してスケーラブルな様式でデータ配信の監視を可能にするために、最小限の制御および識別機能を提供する制御プロトコル（RTCP）によって増強されます。 RTPとRTCPは、基盤となるトランスポート層およびネットワーク層から独立して設計されています。プロトコルは、RTPレベルの翻訳者とミキサーの使用をサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most of the text in this memorandum is identical to RFC 1889 which it obsoletes. There are no changes in the packet formats on the wire, only changes to the rules and algorithms governing how the protocol is used. The biggest change is an enhancement to the scalable timer algorithm for calculating when to send RTCP packets in order to minimize transmission in excess of the intended rate when many participants join a session simultaneously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この覚書のテキストのほとんどは、それが廃止RFC 1889と同じです。ワイヤ上のパケットフォーマットに変化、プロトコルが使用されている方法に関する規則及びアルゴリズムへの唯一の変更はありません。最大の変化は、多くの参加者が同時にセッションに参加するときに意図率を超える伝送を最小限にするために、RTCPパケットを送信する際に計算するためのスケーラブルなタイマーアルゴリズムの拡張機能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction ................................................   4
       1.1  Terminology ............................................   5
   2.  RTP Use Scenarios ...........................................   5
       2.1  Simple Multicast Audio Conference ......................   6
       2.2  Audio and Video Conference .............................   7
       2.3  Mixers and Translators .................................   7
       2.4  Layered Encodings ......................................   8
   3.  Definitions .................................................   8
   4.  Byte Order, Alignment, and Time Format ......................  12
   5.  RTP Data Transfer Protocol ..................................  13
       5.1  RTP Fixed Header Fields ................................  13
       5.2  Multiplexing RTP Sessions ..............................  16
       5.3  Profile-Specific Modifications to the RTP Header .......  18
            5.3.1  RTP Header Extension ............................  18
   6.  RTP Control Protocol -- RTCP ................................  19
       6.1  RTCP Packet Format .....................................  21
       6.2  RTCP Transmission Interval .............................  24
            6.2.1  Maintaining the Number of Session Members .......  28
       6.3  RTCP Packet Send and Receive Rules .....................  28
            6.3.1  Computing the RTCP Transmission Interval ........  29
            6.3.2  Initialization ..................................  30
            6.3.3  Receiving an RTP or Non-BYE RTCP Packet .........  31
            6.3.4  Receiving an RTCP BYE Packet ....................  31
            6.3.5  Timing Out an SSRC ..............................  32
            6.3.6  Expiration of Transmission Timer ................  32
            6.3.7  Transmitting a BYE Packet .......................  33
            6.3.8  Updating we_sent ................................  34
            6.3.9  Allocation of Source Description Bandwidth ......  34
       6.4  Sender and Receiver Reports ............................  35
            6.4.1  SR: Sender Report RTCP Packet ...................  36
            6.4.2  RR: Receiver Report RTCP Packet .................  42
            6.4.3  Extending the Sender and Receiver Reports .......  42
            6.4.4  Analyzing Sender and Receiver Reports ...........  43
       6.5  SDES: Source Description RTCP Packet ...................  45
            6.5.1  CNAME: Canonical End-Point Identifier SDES Item .  46
            6.5.2  NAME: User Name SDES Item .......................  48
            6.5.3  EMAIL: Electronic Mail Address SDES Item ........  48
            6.5.4  PHONE: Phone Number SDES Item ...................  49
            6.5.5  LOC: Geographic User Location SDES Item .........  49
            6.5.6  TOOL: Application or Tool Name SDES Item ........  49
            6.5.7  NOTE: Notice/Status SDES Item ...................  50
            6.5.8  PRIV: Private Extensions SDES Item ..............  50
       6.6  BYE: Goodbye RTCP Packet ...............................  51
       6.7  APP: Application-Defined RTCP Packet ...................  52
   7.  RTP Translators and Mixers ..................................  53
       7.1  General Description ....................................  53
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       7.2  RTCP Processing in Translators .........................  55
       7.3  RTCP Processing in Mixers ..............................  57
       7.4  Cascaded Mixers ........................................  58
   8.  SSRC Identifier Allocation and Use ..........................  59
       8.1  Probability of Collision ...............................  59
       8.2  Collision Resolution and Loop Detection ................  60
       8.3  Use with Layered Encodings .............................  64
   9.  Security ....................................................  65
       9.1  Confidentiality ........................................  65
       9.2  Authentication and Message Integrity ...................  67
   10. Congestion Control ..........................................  67
   11. RTP over Network and Transport Protocols ....................  68
   12. Summary of Protocol Constants ...............................  69
       12.1 RTCP Packet Types ......................................  70
       12.2 SDES Types .............................................  70
   13. RTP Profiles and Payload Format Specifications ..............  71
   14. Security Considerations .....................................  73
   15. IANA Considerations .........................................  73
   16. Intellectual Property Rights Statement ......................  74
   17. Acknowledgments .............................................  74
   Appendix A.   Algorithms ........................................  75
   Appendix A.1  RTP Data Header Validity Checks ...................  78
   Appendix A.2  RTCP Header Validity Checks .......................  82
   Appendix A.3  Determining Number of Packets Expected and Lost ...  83
   Appendix A.4  Generating RTCP SDES Packets ......................  84
   Appendix A.5  Parsing RTCP SDES Packets .........................  85
   Appendix A.6  Generating a Random 32-bit Identifier .............  85
   Appendix A.7  Computing the RTCP Transmission Interval ..........  87
   Appendix A.8  Estimating the Interarrival Jitter ................  94
   Appendix B.   Changes from RFC 1889 .............................  95
   References ...................................................... 100
   Normative References ............................................ 100
   Informative References .......................................... 100
   Authors&#39; Addresses .............................................. 103
   Full Copyright Statement ........................................ 104
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memorandum specifies the real-time transport protocol (RTP), which provides end-to-end delivery services for data with real-time characteristics, such as interactive audio and video. Those services include payload type identification, sequence numbering, timestamping and delivery monitoring. Applications typically run RTP on top of UDP to make use of its multiplexing and checksum services; both protocols contribute parts of the transport protocol functionality. However, RTP may be used with other suitable underlying network or transport protocols (see Section 11). RTP supports data transfer to multiple destinations using multicast distribution if provided by the underlying network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インタラクティブオーディオやビデオなどのリアルタイム特性を有するデータのエンドツーエンド配信サービスを提供するリアルタイム転送プロトコル（RTP）を、指定します。これらのサービスは、ペイロードタイプ識別、シーケンス番号付け、タイムスタンプ及び配信監視を含みます。アプリケーションは通常、その多重化とチェックサムのサービスを利用するためにUDPの上でRTPを実行します。両方のプロトコルは、トランスポートプロトコル機能の一部を寄付します。ただし、RTPは他の適切な基礎となるネットワークまたはトランスポートプロトコルと共に使用することができる（セクション11を参照）。 RTPは、基盤となるネットワークによって提供されている場合、マルチキャスト配信を使用して複数の宛先へのデータ転送をサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that RTP itself does not provide any mechanism to ensure timely delivery or provide other quality-of-service guarantees, but relies on lower-layer services to do so. It does not guarantee delivery or prevent out-of-order delivery, nor does it assume that the underlying network is reliable and delivers packets in sequence. The sequence numbers included in RTP allow the receiver to reconstruct the sender&#39;s packet sequence, but sequence numbers might also be used to determine the proper location of a packet, for example in video decoding, without necessarily decoding packets in sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP自体は、タイムリーな配送を確保するか、他のサービス品質保証を提供するために、任意のメカニズムを提供しますが、そうするために下位層のサービスに依存しないことに注意してください。これは、配信を保証またはアウトオブオーダー配信を防止するため、またそれは、基盤となるネットワークが信頼性が高く、順番にパケットを提供することを前提としないものではありません。 RTPに含まれるシーケンス番号は、受信機が送信側のパケットシーケンスを再構築することを可能にするが、シーケンス番号はまた、必ずしもシーケンス内のパケットを復号することなく、ビデオ復号、例えば、パケットの適切な位置を決定するために使用されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While RTP is primarily designed to satisfy the needs of multi-participant multimedia conferences, it is not limited to that particular application. Storage of continuous data, interactive distributed simulation, active badge, and control and measurement applications may also find RTP applicable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは主にマルチ参加者のマルチメディア会議のニーズを満たすように設計されていますが、それはその特定の用途に限定されるものではありません。連続データ、対話型の分散シミュレーション、アクティブバッジ、および制御・計測アプリケーションのストレージもRTPが適用見つけることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines RTP, consisting of two closely-linked parts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、二つの密接に結合部からなる、RTPを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the real-time transport protocol (RTP), to carry data that has real-time properties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リアルタイムトランスポートプロトコル（RTP）O、リアルタイム特性を有するデータを搬送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the RTP control protocol (RTCP), to monitor the quality of service and to convey information about the participants in an on-going session. The latter aspect of RTCP may be sufficient for &#34;loosely controlled&#34; sessions, i.e., where there is no explicit membership control and set-up, but it is not necessarily intended to support all of an application&#39;s control communication requirements. This functionality may be fully or partially subsumed by a separate session control protocol, which is beyond the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP制御プロトコル（RTCP）O、サービスの品質を監視すると、進行中のセッションでは、参加者についての情報を伝達します。 RTCPの後者の態様は、明示的なメンバーシップ制御及びセットアップが存在しない、すなわち、「緩く制御」セッションのために十分であり得るが、必ずしも、アプリケーションの制御通信の要件の全てをサポートすることを意図していません。この機能は、完全にまたは部分的に、この文書の範囲を超えて別のセッション制御プロトコルによって包含されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP represents a new style of protocol following the principles of application level framing and integrated layer processing proposed by Clark and Tennenhouse [10]. That is, RTP is intended to be malleable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは、クラークとTennenhouse [10]によって提案されたアプリケーションレベルのフレーミングと統合されたレイヤ処理の原理を以下のプロトコルの新しいスタイルを表します。つまり、RTPは、可鍛性であることを意図しています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
to provide the information required by a particular application and will often be integrated into the application processing rather than being implemented as a separate layer. RTP is a protocol framework that is deliberately not complete. This document specifies those functions expected to be common across all the applications for which RTP would be appropriate. Unlike conventional protocols in which additional functions might be accommodated by making the protocol more general or by adding an option mechanism that would require parsing, RTP is intended to be tailored through modifications and/or additions to the headers as needed. Examples are given in Sections 5.3 and 6.4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のアプリケーションが必要とする情報を提供し、多くの場合、むしろ別個の層として実現されるよりも、アプリケーション処理に統合されます。 RTPは故意に完了していないプロトコルのフレームワークです。このドキュメントは、RTPが適切であろうそのためにすべてのアプリケーションで一般的であると予想される関数を指定します。追加機能は、プロトコルは、より一般的なことによって、または解析を必要とするオプションの機構を追加することによって収容することが可能性のある従来のプロトコルとは異なり、RTPは、必要に応じて、ヘッダの変更および/または付加を介して調整されることを意図しています。例は、セクション5.3および6.4.3に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, in addition to this document, a complete specification of RTP for a particular application will require one or more companion documents (see Section 13):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、このドキュメントに加えて、特定のアプリケーションのためのRTPの完全な仕様は、一つ以上のコンパニオン書類が必要になります（セクション13を参照してください）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a profile specification document, which defines a set of payload type codes and their mapping to payload formats (e.g., media encodings). A profile may also define extensions or modifications to RTP that are specific to a particular class of applications. Typically an application will operate under only one profile. A profile for audio and video data may be found in the companion RFC 3551 [1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oペイロードタイプコードのセットと、ペイロード・フォーマット（例えば、メディアエンコーディング）へのマッピングを定義するプロファイル仕様書、。プロファイルは、アプリケーションの特定のクラスに固有のRTPの拡張または変更を定義することができます。通常、アプリケーションは、唯一つのプロファイルの下で動作します。オーディオ及びビデオデータのプロファイルは、コンパニオンRFC 3551に見出すことができる[1]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o payload format specification documents, which define how a particular payload, such as an audio or video encoding, is to be carried in RTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなオーディオまたはビデオ符号化などの特定のペイロードは、RTPで運ばれるべき方法を定義Oペイロードフォーマット仕様書、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A discussion of real-time services and algorithms for their implementation as well as background discussion on some of the RTP design decisions can be found in [11].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPデザイン決定のいくつかの彼らの実装のためのリアルタイムサービスとアルゴリズムの議論だけでなく、背景の説明は、[11]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1 Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14, RFC 2119 [2] and indicate requirement levels for compliant RTP implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますBCP 14に記載されるように解釈されるべきで、RFC 2119 [2]及び対応RTP実装の要求レベルを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. RTP Use Scenarios
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. RTP利用シナリオ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe some aspects of the use of RTP. The examples were chosen to illustrate the basic operation of applications using RTP, not to limit what RTP may be used for. In these examples, RTP is carried on top of IP and UDP, and follows the conventions established by the profile for audio and video specified in the companion RFC 3551.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、RTPの使用のいくつかの側面を説明します。例には、RTPのために使用することができるものを制限するものではないRTPを使用してアプリケーションの基本的な動作を説明するために選択しました。これらの例では、RTPは、IPやUDPの上に運ばれ、コンパニオンRFC 3551で指定されたオーディオおよびビデオ用のプロファイルによって確立された慣習に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1 Simple Multicast Audio Conference
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1シンプルなマルチキャストオーディオ会議
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A working group of the IETF meets to discuss the latest protocol document, using the IP multicast services of the Internet for voice communications. Through some allocation mechanism the working group chair obtains a multicast group address and pair of ports. One port is used for audio data, and the other is used for control (RTCP) packets. This address and port information is distributed to the intended participants. If privacy is desired, the data and control packets may be encrypted as specified in Section 9.1, in which case an encryption key must also be generated and distributed. The exact details of these allocation and distribution mechanisms are beyond the scope of RTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFのワーキンググループは、音声通信のためのインターネットのIPマルチキャストサービスを利用して、最新のプロトコル文書を議論するために満たしています。いくつかの割り当て機構を介してワーキンググループの議長は、ポートのマルチキャストグループアドレスとのペアを取得します。一方のポートは、オーディオデータのために使用され、他方は制御（RTCP）パケットのために使用されます。このアドレスとポートの情報が意図した参加者に配布されます。プライバシーが望まれる場合、データおよび制御パケットはセクション9.1で指定されるように、暗号化することができる場合には、暗号鍵も生成および分配されなければなりません。これらの割り当てと分配メカニズムの正確な詳細は、RTPの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The audio conferencing application used by each conference participant sends audio data in small chunks of, say, 20 ms duration. Each chunk of audio data is preceded by an RTP header; RTP header and data are in turn contained in a UDP packet. The RTP header indicates what type of audio encoding (such as PCM, ADPCM or LPC) is contained in each packet so that senders can change the encoding during a conference, for example, to accommodate a new participant that is connected through a low-bandwidth link or react to indications of network congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各会議参加者が使用する音声会議アプリケーションは、20ミリ秒の期間、たとえば、の小さな塊にオーディオデータを送信します。オーディオデータの各チャンクは、RTPヘッダが先行します。 RTPヘッダとデータが順番にUDPパケットに含まれています。 RTPヘッダは、送信者が、例えば、会議中に符号化を変更することができ、低帯域幅を介して接続されている新たな参加者を収容するように、各パケットに含まれるオーディオ符号化（例えば、PCM、ADPCMやLPCなど）のタイプを示しリンクまたはネットワークの輻輳の兆候に反応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Internet, like other packet networks, occasionally loses and reorders packets and delays them by variable amounts of time. To cope with these impairments, the RTP header contains timing information and a sequence number that allow the receivers to reconstruct the timing produced by the source, so that in this example, chunks of audio are contiguously played out the speaker every 20 ms. This timing reconstruction is performed separately for each source of RTP packets in the conference. The sequence number can also be used by the receiver to estimate how many packets are being lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネットは、他のパケットネットワークのように、時折失い、パケットの順序を変更し、時間の可変量によってそれらを遅らせます。これらの障害に対処するために、RTPヘッダはタイミング情報と、この例では、オーディオのチャンクがスピーカを20msごとに連続して再生されるように、受信機がソースによって生成されるタイミングを再構築することを可能にするシーケンス番号を含みます。このタイミング再構成は、会議におけるRTPパケットの各ソースについて別々に行われます。シーケンス番号も失われているどのように多くのパケット推定するために受信機で使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since members of the working group join and leave during the conference, it is useful to know who is participating at any moment and how well they are receiving the audio data. For that purpose, each instance of the audio application in the conference periodically multicasts a reception report plus the name of its user on the RTCP (control) port. The reception report indicates how well the current speaker is being received and may be used to control adaptive encodings. In addition to the user name, other identifying information may also be included subject to control bandwidth limits. A site sends the RTCP BYE packet (Section 6.6) when it leaves the conference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ワーキンググループのメンバーが参加し、会議中に残しているので、いつでも参加しているとどれだけ彼らは、音声データを受けている人を知っておくと便利です。そのために、会議のオーディオアプリケーションの各インスタンスは、定期的に受信報告プラスRTCP（コントロール）ポート上でそのユーザーの名前をマルチキャスト。受信レポートは、現在の話者が受信されている適応符号化を制御するために使用することができる方法も示します。ユーザ名に加えて、他の識別情報は、帯域幅制限を制御する被写体が含まれてもよいです。このサイトはRTCP BYEパケットそれが会議を離れた（6.6節）を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2 Audio and Video Conference
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2オーディオとビデオ会議
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If both audio and video media are used in a conference, they are transmitted as separate RTP sessions. That is, separate RTP and RTCP packets are transmitted for each medium using two different UDP port pairs and/or multicast addresses. There is no direct coupling at the RTP level between the audio and video sessions, except that a user participating in both sessions should use the same distinguished (canonical) name in the RTCP packets for both so that the sessions can be associated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーディオおよびビデオメディアの両方が会議で使用されている場合、それらは別々のRTPセッションとして送信されます。すなわち、別々のRTPおよびRTCPパケットは、二つの異なるUDPポートのペアおよび/またはマルチキャストアドレスを使用して各媒体に対して送信されます。セッションが関連することができるように、両方のセッションに参加しているユーザは両方のためのRTCPパケットで同一の識別（カノニカル）名を使用することを除いて、オーディオとビデオセッションの間にRTPレベルでの直接的な結合は、存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One motivation for this separation is to allow some participants in the conference to receive only one medium if they choose. Further explanation is given in Section 5.2. Despite the separation, synchronized playback of a source&#39;s audio and video can be achieved using timing information carried in the RTCP packets for both sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この分離のための一つの動機は、彼らが選択した場合の会議で、いくつかの参加者は一つだけメディアを受信できるようにすることです。さらなる説明は、セクション5.2で与えられています。分離にもかかわらず、元のオーディオとビデオの同期再生は、両方のセッションのためのRTCPパケットで運ばれたタイミング情報を用いて達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3 Mixers and Translators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3ミキサーと翻訳者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So far, we have assumed that all sites want to receive media data in the same format. However, this may not always be appropriate. Consider the case where participants in one area are connected through a low-speed link to the majority of the conference participants who enjoy high-speed network access. Instead of forcing everyone to use a lower-bandwidth, reduced-quality audio encoding, an RTP-level relay called a mixer may be placed near the low-bandwidth area. This mixer resynchronizes incoming audio packets to reconstruct the constant 20 ms spacing generated by the sender, mixes these reconstructed audio streams into a single stream, translates the audio encoding to a lower-bandwidth one and forwards the lower-bandwidth packet stream across the low-speed link. These packets might be unicast to a single recipient or multicast on a different address to multiple recipients. The RTP header includes a means for mixers to identify the sources that contributed to a mixed packet so that correct talker indication can be provided at the receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのところ、我々はすべてのサイトが同じ形式でメディアデータを受信したいことを想定しています。しかし、これは必ずしも適切ではないかもしれません。 1つのエリア内の参加者は、高速ネットワークアクセスを楽しむ会議参加者の大多数に低速リンクを介して接続されている場合を考えてみましょう。代わりに、低帯域幅、低減品質のオーディオ符号化を使用するすべての人に強制する、RTPレベルのリレーは、ミキサーは、低帯域幅領域の近くに配置することができると呼ばれます。このミキサは、送信者によって生成された間隔定数は20msを再構成するために、着信オーディオパケットを再同期、単一ストリームにこれらの再構成されたオーディオストリームをミキシングし、低帯域幅のいずれかにオーディオエンコーディングを変換し、低横切っ低帯域幅パケットストリームを転送します高速リンク。これらのパケットは、複数の受信者に異なるアドレス上の単一の受信者またはマルチキャストにユニキャストされる可能性があります。 RTPヘッダは、ミキサーは正しい話者の指示が受信機に提供することができるように混合したパケットに貢献ソースを識別するための手段を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the intended participants in the audio conference may be connected with high bandwidth links but might not be directly reachable via IP multicast. For example, they might be behind an application-level firewall that will not let any IP packets pass. For these sites, mixing may not be necessary, in which case another type of RTP-level relay called a translator may be used. Two translators are installed, one on either side of the firewall, with the outside one funneling all multicast packets received through a secure connection to the translator inside the firewall. The translator inside the firewall sends them again as multicast packets to a multicast group restricted to the site&#39;s internal network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
音声会議中に意図参加者の一部は、高帯域幅のリンクに接続することができるが、IPマルチキャストを経由して直接到達可能ではないかもしれません。例えば、彼らは、任意のIPパケットを通過させませんアプリケーションレベルのファイアウォールの背後にあるかもしれません。これらの部位のために、混合は、必要ではないかもしれない、その場合、RTPレベルのリレーの別のタイプは、翻訳者が使用することができると呼ばれます。二つの翻訳は、ファイアウォールの内側の翻訳への安全な接続を介して受信したすべてのマルチキャストパケットをファネリング外側のいずれかで、ファイアウォールの両側に設置されています。ファイアウォールの内側の翻訳者は、サイトの内部ネットワークに制限マルチキャストグループにマルチキャストパケットとして再度送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mixers and translators may be designed for a variety of purposes. An example is a video mixer that scales the images of individual people in separate video streams and composites them into one video stream to simulate a group scene. Other examples of translation include the connection of a group of hosts speaking only IP/UDP to a group of hosts that understand only ST-II, or the packet-by-packet encoding translation of video streams from individual sources without resynchronization or mixing. Details of the operation of mixers and translators are given in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミキサーと翻訳者は、様々な目的のために設計されてもよいです。例では、別々のビデオストリーム内の個々の人々の画像を拡大縮小し、グループのシーンをシミュレートするために、一つのビデオストリームにそれらを合成するビデオミキサーです。翻訳の他の例は、ST-II、または再同期または混合せずに個々のソースからのビデオストリームのパケット・バイ・パケット符号化変換を理解するホストのグループにのみIP / UDPを話すホストのグループの接続を含みます。ミキサーと翻訳者の動作の詳細については、セクション7に与えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4 Layered Encodings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4階層エンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multimedia applications should be able to adjust the transmission rate to match the capacity of the receiver or to adapt to network congestion. Many implementations place the responsibility of rate-adaptivity at the source. This does not work well with multicast transmission because of the conflicting bandwidth requirements of heterogeneous receivers. The result is often a least-common denominator scenario, where the smallest pipe in the network mesh dictates the quality and fidelity of the overall live multimedia &#34;broadcast&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチメディアアプリケーションは、受信機の能力に適合するように、またはネットワーク輻輳に適応するために伝送レートを調整することができなければなりません。多くの実装では、元のレート適応の責任を置きます。これは、異種の受信機の矛盾する帯域幅要件のマルチキャスト送信でうまく動作しません。結果は、多くの場合、ネットワークのメッシュの中で最も小さいパイプが全体的にライブマルチメディア「ブロードキャスト」の品質と忠実度を決定づけるA最小公分母のシナリオ、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead, responsibility for rate-adaptation can be placed at the receivers by combining a layered encoding with a layered transmission system. In the context of RTP over IP multicast, the source can stripe the progressive layers of a hierarchically represented signal across multiple RTP sessions each carried on its own multicast group. Receivers can then adapt to network heterogeneity and control their reception bandwidth by joining only the appropriate subset of the multicast groups.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その代わりに、レート適応のための責任は、階層化伝送システムで階層符号化を組み合わせることにより、受信機に配置することができます。 IPマルチキャストオーバーRTPの文脈では、ソースは、それぞれが独自のマルチキャストグループに担持複数のRTPセッションで階層的に表現された信号のプログレッシブ層をストライプすることができます。受信機は、次に不均一性をネットワークとマルチキャストグループの唯一の適切なサブセットを接合することにより、その受信帯域幅を制御するために適応させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Details of the use of RTP with layered encodings are given in Sections 6.3.9, 8.3 and 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイヤード符号化とRTPの使用の詳細については、セクション6.3.9、8.3および11に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP payload: The data transported by RTP in a packet, for example audio samples or compressed video data. The payload format and interpretation are beyond the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPペイロード：例えばパケット内のRTPによって輸送データ、音声サンプル又は圧縮されたビデオデータ。ペイロード形式および解釈は、このドキュメントの範囲を超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP packet: A data packet consisting of the fixed RTP header, a possibly empty list of contributing sources (see below), and the payload data. Some underlying protocols may require an encapsulation of the RTP packet to be defined. Typically one packet of the underlying protocol contains a single RTP packet, but several RTP packets MAY be contained if permitted by the encapsulation method (see Section 11).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPパケット：固定RTPヘッダから構成されるデータパケット、寄与ソースの可能性が空のリスト（下記参照）、およびペイロードデータ。いくつかの基本的なプロトコルは、RTPパケットのカプセル化を定義する必要があります。典型的には、基礎となるプロトコルの一つのパケットは、単一のRTPパケットを含んでいるが、いくつかのRTPパケットがカプセル化法により許可されている場合（セクション11を参照）を含有させてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP packet: A control packet consisting of a fixed header part similar to that of RTP data packets, followed by structured elements that vary depending upon the RTCP packet type. The formats are defined in Section 6. Typically, multiple RTCP packets are sent together as a compound RTCP packet in a single packet of the underlying protocol; this is enabled by the length field in the fixed header of each RTCP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケット：RTPデータパケットと同様の固定ヘッダー部分からなる制御パケット、RTCPパケットタイプに依存して変化する構造化要素が続きます。フォーマットは、典型的には、セクション6で定義され、複数のRTCPパケットは、基礎となるプロトコルの単一パケット中の化合物RTCPパケットとして一緒に送信されます。これは、各RTCPパケットの固定ヘッダの長さフィールドによってイネーブルされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Port: The &#34;abstraction that transport protocols use to distinguish among multiple destinations within a given host computer. TCP/IP protocols identify ports using small positive integers.&#34; [12] The transport selectors (TSEL) used by the OSI transport layer are equivalent to ports. RTP depends upon the lower-layer protocol to provide some mechanism such as ports to multiplex the RTP and RTCP packets of a session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポート：「トランスポートプロトコルが指定されたホストコンピュータ内の複数の宛先を区別するために使用することを抽象化TCP / IPプロトコルは小さな正の整数を使用してポートを識別します。」 OSIトランスポート層で使用される[12]トランスポートセレクタ（TSEL）はポートと同等です。 RTPは、セッションのRTP及びRTCPパケットを多重化するポートとして、いくつかのメカニズムを提供するために、下位層のプロトコルに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport address: The combination of a network address and port that identifies a transport-level endpoint, for example an IP address and a UDP port. Packets are transmitted from a source transport address to a destination transport address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポートアドレス：例えば、IPアドレスとUDPポートをトランスポートレベルのエンドポイントを識別するネットワークアドレスとポートの組み合わせ。パケットは、送信先トランスポートアドレスを送信元トランスポート・アドレスから送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP media type: An RTP media type is the collection of payload types which can be carried within a single RTP session. The RTP Profile assigns RTP media types to RTP payload types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPメディアタイプ：RTPメディアタイプは、単一のRTPセッション内で実施することができるペイロードタイプのコレクションです。 RTPプロファイルはRTPペイロードタイプにRTPメディアタイプを割り当てます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multimedia session: A set of concurrent RTP sessions among a common group of participants. For example, a videoconference (which is a multimedia session) may contain an audio RTP session and a video RTP session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチメディアセッション：参加者の共通のグループの間で同時RTPセッションのセット。例えば、（マルチメディアセッションである）、ビデオ会議、オーディオRTPセッション及びビデオRTPセッションを含んでいてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP session: An association among a set of participants communicating with RTP. A participant may be involved in multiple RTP sessions at the same time. In a multimedia session, each medium is typically carried in a separate RTP session with its own RTCP packets unless the the encoding itself multiplexes multiple media into a single data stream. A participant distinguishes multiple RTP sessions by reception of different sessions using different pairs of destination transport addresses, where a pair of transport addresses comprises one network address plus a pair of ports for RTP and RTCP. All participants in an RTP session may share a common destination transport address pair, as in the case of IP multicast, or the pairs may be different for each participant, as in the case of individual unicast network addresses and port pairs. In the unicast case, a participant may receive from all other participants in the session using the same pair of ports, or may use a distinct pair of ports for each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPセッション：RTPと通信し、参加者の集合間の関連。参加者は同時に複数のRTPセッションに関与することができます。符号化自体は、単一のデータ・ストリームに複数のメディアを多重化しない限り、マルチメディアセッションでは、各メディアは、典型的には、独自のRTCPパケットで別々のRTPセッションで行われます。参加者は、トランスポート・アドレスのペアが一つのネットワークアドレスとRTPとRTCPのためのポートの組を含む送信先トランスポート・アドレスの異なる対を用いて、異なるセッションの受信により、複数のRTPセッションを区別する。 RTPセッションのすべての参加者は、IPマルチキャストの場合のように、共通の宛先のトランスポート・アドレスのペアを共有することができる、またはペアは、個々のユニキャストネットワークアドレスとポートのペアの場合のように、各参加者のために異なっていてもよいです。ユニキャストの場合に、参加者は、ポートの同じ組を使用して、セッション内の他のすべての参加者から受信することができ、またはそれぞれのためのポートの別個のペアを使用してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The distinguishing feature of an RTP session is that each maintains a full, separate space of SSRC identifiers (defined next). The set of participants included in one RTP session consists of those that can receive an SSRC identifier transmitted by any one of the participants either in RTP as the SSRC or a CSRC (also defined below) or in RTCP. For example, consider a three-party conference implemented using unicast UDP with each participant receiving from the other two on separate port pairs. If each participant sends RTCP feedback about data received from one other participant only back to that participant, then the conference is composed of three separate point-to-point RTP sessions. If each participant provides RTCP feedback about its reception of one other participant to both of the other participants, then the conference is composed of one multi-party RTP session. The latter case simulates the behavior that would occur with IP multicast communication among the three participants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RTPセッションの際立った特徴は、それぞれがSSRC識別子（次の定義された）の完全な、別個の空間を維持することです。参加者のセットは、1つのRTPセッションに含まれるSSRCまたはCSRCとしてRTP（下記に定義）またはRTCPのいずれかで、参加者のいずれかによって送信されるSSRC識別子を受信することができるものから成ります。例えば、三者会議は、各参加者が別のポートのペアで、他の2から受信して、ユニキャストUDPを使用して実装を検討してください。各参加者のみバックその参加者に一つの他の参加者から受信したデータについてのRTCPフィードバックを送信する場合、会議は、3つの別々のポイントツーポイントRTPセッションから構成されています。各参加者が他の参加者の両方に一つの他の参加者のその受信についてのRTCPフィードバックを提供する場合、その会議は1マルチパーティRTPセッションで構成されています。後者の場合は、3人の参加者の間でIPマルチキャスト通信で生じる挙動をシミュレートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The RTP framework allows the variations defined here, but a particular control protocol or application design will usually impose constraints on these variations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RTPフレームワークは、ここで定義されたバリエーションを可能にするが、特定の制御プロトコルまたはアプリケーションの設計は、通常、これらの変化に制約を課します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Synchronization source (SSRC): The source of a stream of RTP packets, identified by a 32-bit numeric SSRC identifier carried in the RTP header so as not to be dependent upon the network address. All packets from a synchronization source form part of the same timing and sequence number space, so a receiver groups packets by synchronization source for playback. Examples of synchronization sources include the sender of a stream of packets derived from a signal source such as a microphone or a camera, or an RTP mixer (see below). A synchronization source may change its data format, e.g., audio encoding, over time. The SSRC identifier is a randomly chosen value meant to be globally unique within a particular RTP session (see Section 8). A participant need not use the same SSRC identifier for all the RTP sessions in a multimedia session; the binding of the SSRC identifiers is provided through RTCP (see Section 6.5.1). If a participant generates multiple streams in one RTP session, for example from separate video cameras, each MUST be identified as a different SSRC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同期ソース（SSRC）：RTPパケットのストリームのソース、ネットワークアドレスに依存しないように、RTPヘッダで運ばれた32ビットの数値SSRC識別子によって識別されます。同じタイミングの同期ソースの一部を形成すると、シーケンス番号空間からのすべてのパケットので、レシーバ基パケット再生のための同期ソースによって。同期源としては、例えば、マイクやカメラ、またはRTPミキサ（下記参照）のような信号源から誘導されたパケットのストリームの送信者を含みます。同期ソースは、時間の経過とともに、そのデータのフォーマット、例えば、オーディオ符号化を変更することができます。 SSRC識別子は、特定のRTPセッション内でグローバルに一意であることを意味し、ランダムに選択された値である（セクション8を参照）。参加者は、マルチメディアセッション内のすべてのRTPセッションのために同じSSRC識別子を使用する必要はありません。 SSRC識別子の結合は、RTCPを介して提供されます（セクション6.5.1を参照してください）。参加者が1つのRTPセッションで複数のストリームを生成した場合、別のビデオカメラから、例えば、各々が異なるSSRCとして識別されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contributing source (CSRC): A source of a stream of RTP packets that has contributed to the combined stream produced by an RTP mixer (see below). The mixer inserts a list of the SSRC identifiers of the sources that contributed to the generation of a particular packet into the RTP header of that packet. This list is called the CSRC list. An example application is audio conferencing where a mixer indicates all the talkers whose speech was combined to produce the outgoing packet, allowing the receiver to indicate the current talker, even though all the audio packets contain the same SSRC identifier (that of the mixer).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
貢献ソース（CSRC）：RTPミキサによって生成合成ストリームに貢献してきたRTPパケットのストリームのソース（下記参照）。ミキサは、そのパケットのRTPヘッダに特定のパケットの生成に寄与ソースのSSRC識別子のリストを挿入します。このリストはCSRCリストと呼ばれています。例えば、アプリケーションは、すべてのオーディオパケットが同じSSRC識別子（ミキサーのもの）を含有するにもかかわらず、ミキサーは、音声受信機は現在の話者を示すためにできるように、発信パケットを生成するために結合されたすべての話し手を示す音声会議です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
End system: An application that generates the content to be sent in RTP packets and/or consumes the content of received RTP packets. An end system can act as one or more synchronization sources in a particular RTP session, but typically only one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンド・システム：コンテンツを生成するアプリケーションは、RTPパケットで送信および/または受信したRTPパケットの内容を消費します。エンドシステムは、特定のRTPセッション内の1つまたは複数の同期ソースとして作用するが、典型的には一つだけができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mixer: An intermediate system that receives RTP packets from one or more sources, possibly changes the data format, combines the packets in some manner and then forwards a new RTP packet. Since the timing among multiple input sources will not generally be synchronized, the mixer will make timing adjustments among the streams and generate its own timing for the combined stream. Thus, all data packets originating from a mixer will be identified as having the mixer as their synchronization source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミキサー：1つ以上のソースからのRTPパケットを受信する中間システムは、おそらく、データのフォーマットを変更するいくつかの方法でパケットを結合して、新しいRTPパケットを転送します。複数の入力ソースのうちのタイミングは一般に同期されないので、ミキサーは、ストリーム間のタイミング調整を行い、合わせたストリームに対して独自のタイミングを生成します。したがって、ミキサ由来するすべてのデータパケットは、それらの同期ソースとしてミキサーを有すると同定されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Translator: An intermediate system that forwards RTP packets with their synchronization source identifier intact. Examples of translators include devices that convert encodings without mixing, replicators from multicast to unicast, and application-level filters in firewalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
翻訳：そのまま彼らの同期ソース識別子をRTPパケットを転送する中間システム。翻訳の例は、ファイアウォールで混合することなくエンコーディングを変換する装置、マルチキャストからユニキャストへリプリケータ、およびアプリケーションレベルのフィルタを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Monitor: An application that receives RTCP packets sent by participants in an RTP session, in particular the reception reports, and estimates the current quality of service for distribution monitoring, fault diagnosis and long-term statistics. The monitor function is likely to be built into the application(s) participating in the session, but may also be a separate application that does not otherwise participate and does not send or receive the RTP data packets (since they are on a separate port). These are called third-party monitors. It is also acceptable for a third-party monitor to receive the RTP data packets but not send RTCP packets or otherwise be counted in the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モニター：RTPセッションの参加者によって送信されたRTCPパケット、特定の受信報告書、および流通の監視、故障診断や長期統計のためのサービスの現在の品質を推定する受信アプリケーション。モニタ機能は、セッションに参加したアプリケーション（複数可）に組み込まれる可能性が高いですが、また、それ以外の場合は参加せず、（彼らは別々のポート上にあるので）RTPデータパケットを送信または受信していない別のアプリケーションであってもよいです。これらは、サードパーティ製のモニターと呼ばれています。サードパーティは、RTPデータパケットを受信するモニターが、RTCPパケットを送信しないか、そうでない場合は、セッション中に数えられることも可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-RTP means: Protocols and mechanisms that may be needed in addition to RTP to provide a usable service. In particular, for multimedia conferences, a control protocol may distribute multicast addresses and keys for encryption, negotiate the encryption algorithm to be used, and define dynamic mappings between RTP payload type values and the payload formats they represent for formats that do not have a predefined payload type value. Examples of such protocols include the Session Initiation Protocol (SIP) (RFC 3261 [13]), ITU Recommendation H.323 [14] and applications using SDP (RFC 2327 [15]), such as RTSP (RFC 2326 [16]). For simple
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非RTP手段：RTPに加えて必要とされ得るプロトコル及びメカニズムが使用可能なサービスを提供します。具体的には、マルチメディア会議のために、制御プロトコルは、暗号化のためのマルチキャストアドレスとキーを配布に使用される暗号化アルゴリズムをネゴシエーションし、RTPペイロードタイプ値と、それらが所定のを持っていない形式の表現ペイロードフォーマット間の動的マッピングを定義することができますペイロードタイプの値。そのようなプロトコルの例は、RTSP（RFC 2326 [16]）としてSDP（RFC 2327 [15]）を用いてセッション開始プロトコル（SIP）（RFC 3261 [13]）、ITU勧告H.323 [14]、およびアプリケーションを含みます。シンプルなため
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
applications, electronic mail or a conference database may also be used. The specification of such protocols and mechanisms is outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
アプリケーション、電子メールや会議のデータベースを使用することもできます。そのようなプロトコル及びメカニズムの仕様は、この文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Byte Order, Alignment, and Time Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.バイト順序、配置、および時刻の形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All integer fields are carried in network byte order, that is, most significant byte (octet) first. This byte order is commonly known as big-endian. The transmission order is described in detail in [3]. Unless otherwise noted, numeric constants are in decimal (base 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての整数フィールドは、最上位バイト（オクテット）最初、つまり、ネットワークバイト順に搬送されます。このバイト順は、一般的にビッグエンディアンとして知られています。送信順序は、[3]に詳細に記載されています。特に断りのない限り、数値定数は、小数点（基数10）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All header data is aligned to its natural length, i.e., 16-bit fields are aligned on even offsets, 32-bit fields are aligned at offsets divisible by four, etc. Octets designated as padding have the value zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのヘッダデータは、その自然長に整合され、すなわち、16ビットのフィールドがあってもオフセットに整列され、32ビットのフィールドは、4で割り切れるオフセットで整列され、パディングとして指定等オクテットは、値ゼロを有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wallclock time (absolute date and time) is represented using the timestamp format of the Network Time Protocol (NTP), which is in seconds relative to 0h UTC on 1 January 1900 [4]. The full resolution NTP timestamp is a 64-bit unsigned fixed-point number with the integer part in the first 32 bits and the fractional part in the last 32 bits. In some fields where a more compact representation is appropriate, only the middle 32 bits are used; that is, the low 16 bits of the integer part and the high 16 bits of the fractional part. The high 16 bits of the integer part must be determined independently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウォールクロック時間（絶対日時）[4] 1900年1月1日に0HのUTCに対する相対秒であるネットワークタイムプロトコル（NTP）のタイムスタンプ形式を使用して表されています。フル解像度NTPタイムスタンプは、最初の32ビットの整数部と最後の32ビットに小数部分を有する64ビットの符号なしの固定小数点数です。よりコンパクトな表現が適切であるいくつかのフィールドでは、唯一の中間の32ビットが使用されています。すなわち、整数部の下位16ビットと分数部分の上位16ビットです。整数部の上位16ビットは、独立して決定されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation is not required to run the Network Time Protocol in order to use RTP. Other time sources, or none at all, may be used (see the description of the NTP timestamp field in Section 6.4.1). However, running NTP may be useful for synchronizing streams transmitted from separate hosts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、RTPを使用するために、ネットワーク・タイム・プロトコルを実行する必要はありません。他のタイムソース、またはまったくなしは、（セクション6.4.1でNTPタイムスタンプのフィールドの説明を参照）を使用することができます。しかし、NTPを実行すると、別のホストから送信されたストリームを同期させるために有用であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NTP timestamp will wrap around to zero some time in the year 2036, but for RTP purposes, only differences between pairs of NTP timestamps are used. So long as the pairs of timestamps can be assumed to be within 68 years of each other, using modular arithmetic for subtractions and comparisons makes the wraparound irrelevant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NTPタイムスタンプは、2036年にいくつかの時間をゼロにラップアラウンドしますが、RTPのために、NTPタイムスタンプのペア間の唯一の違いは使用されています。タイムスタンプの対は、減算及び比較のためにモジュラー演算を使用して、互いの68年以内であると仮定することができる限り、ラップアラウンドが無関係となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. RTP Data Transfer Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. RTPデータ転送プロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 RTP Fixed Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 RTPの固定ヘッダフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP header has the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPヘッダは、次の形式を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P|X| CC |M| PT | sequence number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | synchronization source (SSRC) identifier | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | contributing source (CSRC) identifiers | | .... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + | V = 2 | P | X | CC | M | PT |シーケンス番号| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |タイムスタンプ| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |同期ソース（SSRC）識別子| + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + |貢献ソース（CSRC）識別子| | .... | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first twelve octets are present in every RTP packet, while the list of CSRC identifiers is present only when inserted by a mixer. The fields have the following meaning:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミキサーによって挿入場合にのみ、CSRC識別子のリストが存在する間最初の12個のオクテットは、すべてのRTPパケット内に存在します。各フィールドの意味は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version (V): 2 bits This field identifies the version of RTP. The version defined by this specification is two (2). (The value 1 is used by the first draft version of RTP and the value 0 is used by the protocol initially implemented in the &#34;vat&#34; audio tool.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョン（V）：2ビットこのフィールドは、RTPのバージョンを識別する。この仕様で定義されたバージョンは、2つ（2）です。 （値1は、RTPの最初の草案バージョンによって使用され、値0は、最初に「バット」オーディオツールに実装されたプロトコルによって使用されます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding (P): 1 bit If the padding bit is set, the packet contains one or more additional padding octets at the end which are not part of the payload. The last octet of the padding contains a count of how many padding octets should be ignored, including itself. Padding may be needed by some encryption algorithms with fixed block sizes or for carrying several RTP packets in a lower-layer protocol data unit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディング（P）：1ビットのパディングビットがセットされている場合、パケットはペイロードの一部ではない端部に1つ以上の追加のパディングオクテットを含んでいます。パディングの最後のオクテットは、オクテットは自身を含め、無視されるべきであるどのように多くのパディングの数が含まれています。パディングは、固定ブロックサイズまたは下位層プロトコル・データ・ユニットにいくつかのRTPパケットを搬送するためのいくつかの暗号化アルゴリズムによって必要とされるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extension (X): 1 bit If the extension bit is set, the fixed header MUST be followed by exactly one header extension, with a format defined in Section 5.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張（X）：拡張ビットが設定されている場合は1ビット、固定ヘッダは、セクション5.3.1で定義されたフォーマットで、正確に1つのヘッダ拡張が続かなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CSRC count (CC): 4 bits The CSRC count contains the number of CSRC identifiers that follow the fixed header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CSRCカウント（CC）：4ビットCSRCカウントは固定ヘッダに従っCSRC識別子の数を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
marker (M): 1 bit The interpretation of the marker is defined by a profile. It is intended to allow significant events such as frame boundaries to be marked in the packet stream. A profile MAY define additional marker bits or specify that there is no marker bit by changing the number of bits in the payload type field (see Section 5.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マーカー（M）：1マーカーの解釈は、プロファイルによって定義されているビット。このようなフレーム境界などの重要なイベントは、パケットストリームにマークすることを可能にすることを意図しています。プロファイルは、追加のマーカビットを定義するか、ペイロードタイプフィールドのビット数を変更することにより何らマーカビットが存在しないことを指定することができる（5.3節を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
payload type (PT): 7 bits This field identifies the format of the RTP payload and determines its interpretation by the application. A profile MAY specify a default static mapping of payload type codes to payload formats. Additional payload type codes MAY be defined dynamically through non-RTP means (see Section 3). A set of default mappings for audio and video is specified in the companion RFC 3551 [1]. An RTP source MAY change the payload type during a session, but this field SHOULD NOT be used for multiplexing separate media streams (see Section 5.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ペイロードタイプ（PT）：7ビットこのフィールドは、RTPペイロードのフォーマットを識別し、アプリケーションによってその解釈を決定します。プロファイルは、ペイロードフォーマットにペイロードタイプコードのデフォルトの静的マッピングを指定するかもしれません。追加のペイロードタイプコードは非RTP手段（セクション3参照）を介して動的に定義されるかもしれません。オーディオとビデオのためのデフォルトマッピングのセットは、コンパニオンRFC 3551で指定された[1]。 RTPソースは、セッション中にペイロードタイプを変更する場合がありますが、このフィールドには、多重別々のメディアストリーム（5.2節を参照）には使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A receiver MUST ignore packets with payload types that it does not understand.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
受信機は、それが理解していないペイロードタイプを持つパケットを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequence number: 16 bits The sequence number increments by one for each RTP data packet sent, and may be used by the receiver to detect packet loss and to restore packet sequence. The initial value of the sequence number SHOULD be random (unpredictable) to make known-plaintext attacks on encryption more difficult, even if the source itself does not encrypt according to the method in Section 9.1, because the packets may flow through a translator that does. Techniques for choosing unpredictable numbers are discussed in [17].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配列番号：16は、送信される各RTPデータパケットのための一つのビットシーケンス番号をインクリメントし、パケット損失を検出し、パケットシーケンスを復元するために受信機によって使用されてもよいです。シーケンス番号の初期値は、パケットがないトランスレータを通って流れることができるので、ソース自体は、セクション9.1に記載の方法にしたがって、暗号化しない場合であっても、暗号化の既知平文攻撃をより困難にするために（予測不可能な）ランダムであるべきです。予測不可能な数字を選択するための技術は、[17]で議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestamp: 32 bits The timestamp reflects the sampling instant of the first octet in the RTP data packet. The sampling instant MUST be derived from a clock that increments monotonically and linearly in time to allow synchronization and jitter calculations (see Section 6.4.1). The resolution of the clock MUST be sufficient for the desired synchronization accuracy and for measuring packet arrival jitter (one tick per video frame is typically not sufficient). The clock frequency is dependent on the format of data carried as payload and is specified statically in the profile or payload format specification that defines the format, or MAY be specified dynamically for payload formats defined through non-RTP means. If RTP packets are generated periodically, the nominal sampling instant as determined from the sampling clock is to be used, not a reading of the system clock. As an example, for fixed-rate audio the timestamp clock would likely increment by one for each sampling period. If an audio application reads blocks covering
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムスタンプ：32ビットのタイムスタンプはRTPデータパケットの最初のオクテットのサンプリングインスタントを反映しています。サンプリングの瞬間は、（6.4.1項を参照）、同期とジッタの計算を可能にするために、時間に単調かつ直線的に増加させたクロックから導出されなければなりません。クロックの分解能が所望の同期精度およびパケット到着ジッタを測定するために十分なものでなければならない（ビデオのフレームごとにティックは、典型的には十分ではありません）。クロック周波数は、ペイロードとして運ばれたデータのフォーマットに依存し、フォーマットを定義プロファイルまたはペイロードフォーマット仕様で静的に指定された、または非RTP手段を介して定義されたペイロード形式の動的指定することができます。 RTPパケットが定期的に発生している場合は、サンプリングクロックから決定された公称サンプリング時点は、使用されるシステム・クロックの読み出しはありません。一例として、固定レートのオーディオのタイムスタンプのクロックは、おそらく各サンプリング期間に対して1つずつ増加であろう。オーディオアプリケーションがカバーするブロックを読み取る場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
160 sampling periods from the input device, the timestamp would be increased by 160 for each such block, regardless of whether the block is transmitted in a packet or dropped as silent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
入力装置から160回のサンプリング期間は、タイムスタンプは関係なく、ブロックがパケットで送信またはサイレントとしてドロップされたかどうかの、そのような各ブロック160によって増大されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The initial value of the timestamp SHOULD be random, as for the sequence number. Several consecutive RTP packets will have equal timestamps if they are (logically) generated at once, e.g., belong to the same video frame. Consecutive RTP packets MAY contain timestamps that are not monotonic if the data is not transmitted in the order it was sampled, as in the case of MPEG interpolated video frames. (The sequence numbers of the packets as transmitted will still be monotonic.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
タイムスタンプの初期値は、シーケンス番号のためとして、ランダムであるべきです。彼らは（論理的に）例えば、同じビデオフレームに属し、一度に生成されている場合、いくつかの連続したRTPパケットは、同じタイムスタンプを持つことになります。連続したRTPパケットは、データがMPEG補間ビデオ・フレームの場合のように、それがサンプリングされた順序で送信されていない場合、単調ではないタイムスタンプを含むかもしれません。 （送信されたようにパケットのシーケンス番号はまだ単調であろう。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RTP timestamps from different media streams may advance at different rates and usually have independent, random offsets. Therefore, although these timestamps are sufficient to reconstruct the timing of a single stream, directly comparing RTP timestamps from different media is not effective for synchronization. Instead, for each medium the RTP timestamp is related to the sampling instant by pairing it with a timestamp from a reference clock (wallclock) that represents the time when the data corresponding to the RTP timestamp was sampled. The reference clock is shared by all media to be synchronized. The timestamp pairs are not transmitted in every data packet, but at a lower rate in RTCP SR packets as described in Section 6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
異なるメディアストリームからRTPタイムスタンプは、異なる速度で前進させ、通常は独立した、ランダムオフセットを有することができます。これらのタイムスタンプは、直接異なるメディアからRTPのタイムスタンプを比較する単一のストリームのタイミングを再構成するのに十分であるが故に、同期のために有効ではありません。代わりに、各メディアのためのRTPタイムスタンプは、RTPタイムスタンプに対応するデータがサンプリングされた時間を表す基準クロック（ウォールクロック）からのタイムスタンプでそれをペアリングすることによってサンプリング時点に関連しています。すべてのメディアで共有されている基準クロックを同期します。 6.4節で説明したようにタイムスタンプのペアは、すべてのデータパケットに送信さが、RTCP SRパケットで、より低いレートではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The sampling instant is chosen as the point of reference for the RTP timestamp because it is known to the transmitting endpoint and has a common definition for all media, independent of encoding delays or other processing. The purpose is to allow synchronized presentation of all media sampled at the same time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
それは送信エンドポイントに知られており、符号化遅延または他の処理とは独立して、すべてのメディアのための共通の定義を有しているため、サンプリング時点は、RTPタイムスタンプのための基準点として選択されます。目的は、同時にサンプリングすべてのメディアの同期プレゼンテーションを可能にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Applications transmitting stored data rather than data sampled in real time typically use a virtual presentation timeline derived from wallclock time to determine when the next frame or other unit of each medium in the stored data should be presented. In this case, the RTP timestamp would reflect the presentation time for each unit. That is, the RTP timestamp for each unit would be related to the wallclock time at which the unit becomes current on the virtual presentation timeline. Actual presentation occurs some time later as determined by the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
格納されたデータではなく、リアルタイムにサンプリングされたデータを送信するアプリケーションは、典型的には、格納されたデータ内の各メディアの次のフレームまたは他のユニットが提示されるべきかを決定するためにウォールクロック時間に由来する仮想プレゼンテーションタイムラインを使用します。この場合、RTPタイムスタンプは、各ユニットのプレゼンテーション時間を反映することになります。すなわち、各ユニットのRTPタイムスタンプユニットは、仮想プレゼンテーションタイムライン上の電流となるようにウォールクロック時間に関連される、です。実際のプレゼンテーションでは、受信機によって決定された後にいくつかの時間を発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An example describing live audio narration of prerecorded video illustrates the significance of choosing the sampling instant as the reference point. In this scenario, the video would be presented locally for the narrator to view and would be simultaneously transmitted using RTP. The &#34;sampling instant&#34; of a video frame transmitted in RTP would be established by referencing its timestamp to the wallclock time when that video frame was presented to the narrator. The sampling instant for the audio RTP packets containing the narrator&#39;s speech would be established by referencing the same wallclock time when the audio was sampled. The audio and video may even be transmitted by different hosts if the reference clocks on the two hosts are synchronized by some means such as NTP. A receiver can then synchronize presentation of the audio and video packets by relating their RTP timestamps using the timestamp pairs in RTCP SR packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
あらかじめ記録された映像のライブ音声ナレーションを記述した例では、基準点としてサンプリング時点を選択の重要性を示しています。このシナリオでは、ビデオを表示するために、語り手のために局所的に提示されると同時に、RTPを使用して送信されます。 RTPで送信されたビデオフレームの「サンプリングの瞬間」は、そのビデオフレームがナレーターに提示されたとき、壁時計の時刻にタイムスタンプを参照することによって確立されるだろう。ナレーターの音声を含むオーディオRTPパケットのサンプリングの瞬間は、オーディオがサンプリングされたのと同じ壁時計の時間を参照することによって確立されるだろう。二つのホスト上の基準クロックがNTPなど、いくつかの手段によって同期されている場合、オーディオとビデオは、異なるホストによって送信されても​​よいです。受信機は、RTCP SRパケットにタイムスタンプのペアを使用して、それらのRTPタイムスタンプを関連付けることにより、オーディオおよびビデオパケットのプレゼンテーションを同期させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSRC: 32 bits The SSRC field identifies the synchronization source. This identifier SHOULD be chosen randomly, with the intent that no two synchronization sources within the same RTP session will have the same SSRC identifier. An example algorithm for generating a random identifier is presented in Appendix A.6. Although the probability of multiple sources choosing the same identifier is low, all RTP implementations must be prepared to detect and resolve collisions. Section 8 describes the probability of collision along with a mechanism for resolving collisions and detecting RTP-level forwarding loops based on the uniqueness of the SSRC identifier. If a source changes its source transport address, it must also choose a new SSRC identifier to avoid being interpreted as a looped source (see Section 8.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSRC：SSRCフィールドは、同期ソースを識別する32ビット。この識別子は、同じRTPセッション内には2つの同期ソースが同じSSRC識別子を持たないことを意図して、ランダムに選択されるべきです。ランダムな識別子を生成するためのアルゴリズム例は、付録A.6に提示されています。同じ識別子を選択する複数のソースの確率は低いですが、すべてのRTPの実装は、衝突を検出し、解決するために準備する必要があります。セクション8は、衝突を解決し、SSRC識別子の一意性に基づいて、RTPレベルの転送ループを検出する機構と一緒に衝突の確率を記述する。ソースは、そのソーストランスポートアドレスを変更した場合、それはまた、ループ状のソース（8.2節を参照）として解釈されるのを避けるために新しいSSRC識別子を選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CSRC list: 0 to 15 items, 32 bits each The CSRC list identifies the contributing sources for the payload contained in this packet. The number of identifiers is given by the CC field. If there are more than 15 contributing sources, only 15 can be identified. CSRC identifiers are inserted by mixers (see Section 7.1), using the SSRC identifiers of contributing sources. For example, for audio packets the SSRC identifiers of all sources that were mixed together to create a packet are listed, allowing correct talker indication at the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CSRCリスト：0〜15項目、32ビット各CSRCリストは、このパケットに含まれるペイロードの貢献ソースを識別する。識別子の数は、CCフィールドで与えられます。 15の以上の貢献ソースがある場合、唯一の15を識別することができます。 CSRC識別子は、寄与ソースのSSRC識別子を用いて、ミキサー（7.1節を参照）によって挿入されます。例えば、オーディオパケットのためのパケットを作成するために一緒に混合し、すべてのソースのSSRC識別子が受信機で正しい話者表示を可能に列挙されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Multiplexing RTP Sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2多重化RTPセッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For efficient protocol processing, the number of multiplexing points should be minimized, as described in the integrated layer processing design principle [10]. In RTP, multiplexing is provided by the destination transport address (network address and port number) which is different for each RTP session. For example, in a teleconference composed of audio and video media encoded separately, each medium SHOULD be carried in a separate RTP session with its own destination transport address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
統合されたレイヤ処理設計原理で説明したように、効率的なプロトコル処理のために、多重点の数は、最小にすべきである[10]。 RTPにおいては、多重化は、各RTPセッションの異なる宛先トランスポートアドレス（ネットワークアドレス及びポート番号）によって提供されます。例えば、メディアは別々にエンコードされたオーディオおよびビデオからなる会議で、各メディアは、独自の宛先トランスポートアドレスを別個のRTPセッションで実施すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Separate audio and video streams SHOULD NOT be carried in a single RTP session and demultiplexed based on the payload type or SSRC fields. Interleaving packets with different RTP media types but using the same SSRC would introduce several problems:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別々のオーディオおよびビデオストリームは、単一のRTPセッションで運ばれ、ペイロードタイプやSSRCフィールドに基づいて逆多重化されるべきではありません。別のRTPメディアタイプのパケットをインターリーブするが、いくつかの問題を導入するのと同じSSRCを使用しました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If, say, two audio streams shared the same RTP session and the same SSRC value, and one were to change encodings and thus acquire a different RTP payload type, there would be no general way of identifying which stream had changed encodings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.たとえば、もし、2つのオーディオストリームは、同じRTPセッションと同じSSRC値を共有し、及び一方が存在することになるストリームがエンコードを変更した識別のない一般的な方法をエンコードを変更せず、したがって、異なるRTPペイロードタイプを取得しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. An SSRC is defined to identify a single timing and sequence number space. Interleaving multiple payload types would require different timing spaces if the media clock rates differ and would require different sequence number spaces to tell which payload type suffered packet loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.アンSSRCは、単一のタイミングとシーケンス番号スペースを識別するために定義されています。メディアクロックレートが異なり、パケット損失を被ったペイロードタイプ伝えるために、異なるシーケンス番号のスペースを必要とする場合はインタリーブ複数のペイロードタイプは異なるタイミングスペースを必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The RTCP sender and receiver reports (see Section 6.4) can only describe one timing and sequence number space per SSRC and do not carry a payload type field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. RTCPの送信者と受信者の報告は（6.4節を参照）のみSSRCにつき1つのタイミングとシーケンス番号空間を記述することができ、ペイロードタイプフィールドを運ぶことはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. An RTP mixer would not be able to combine interleaved streams of incompatible media into one stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【請求項4】RTPミキサーは、1つのストリームに互換性のないメディアのインターリーブされたストリームを結合することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Carrying multiple media in one RTP session precludes: the use of different network paths or network resource allocations if appropriate; reception of a subset of the media if desired, for example just audio if video would exceed the available bandwidth; and receiver implementations that use separate processes for the different media, whereas using separate RTP sessions permits either single- or multiple-process implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つのRTPセッションで複数のメディアを運ぶ5.排除：適切であれば、異なるネットワーク経路またはネットワークリソース割り当てを使用します。ビデオが利用可能な帯域幅を超える場合だけオーディオ例えば、所望であれば、メディアのサブセットを受信します。別々のRTPセッションを使用すると、単一または複数のいずれかのプロセスの実装を可能にする一方で、異なるメディアの別個のプロセスを使用して、受信機の実装。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using a different SSRC for each medium but sending them in the same RTP session would avoid the first three problems but not the last two.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各メディアに異なるSSRCを使用したが、同じRTPセッションでそれらを送信する最初の三つの問題ではなく、最後の二つを避けるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, multiplexing multiple related sources of the same medium in one RTP session using different SSRC values is the norm for multicast sessions. The problems listed above don&#39;t apply: an RTP mixer can combine multiple audio sources, for example, and the same treatment is applicable for all of them. It may also be appropriate to multiplex streams of the same medium using different SSRC values in other scenarios where the last two problems do not apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、異なるSSRC値を使用して、1つのRTPセッションにおいて同じ培地の多重化関連する複数のソースは、マルチキャストセッションのノルムです。上記の問題は適用されません：RTPミキサーは、例えば、複数のオーディオソースを組み合わせることができ、そして同じ治療はそれらのすべてに適用されます。また、最後の二つの問題が適用されない他のシナリオで異なるSSRC値を使用して、同じメディアのストリームを多重化することが適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 Profile-Specific Modifications to the RTP Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
RTPヘッダーに5.3プロファイル固有の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The existing RTP data packet header is believed to be complete for the set of functions required in common across all the application classes that RTP might support. However, in keeping with the ALF design principle, the header MAY be tailored through modifications or additions defined in a profile specification while still allowing profile-independent monitoring and recording tools to function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のRTPデータパケットヘッダは、RTPがサポートする可能性のあるすべてのアプリケーションクラスで共通に必要な機能のセットのために完全であると考えられています。しかしながら、ALF設計原理と一致して、ヘッダが依然としてプロファイル独立した監視及び記録ツールが機能することを可能にしながら、プロファイル仕様で定義された変更や追加を介して調整することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The marker bit and payload type field carry profile-specific information, but they are allocated in the fixed header since many applications are expected to need them and might otherwise have to add another 32-bit word just to hold them. The octet containing these fields MAY be redefined by a profile to suit different requirements, for example with more or fewer marker bits. If there are any marker bits, one SHOULD be located in the most significant bit of the octet since profile-independent monitors may be able to observe a correlation between packet loss patterns and the marker bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oマーカービットとペイロードタイプフィールドは、プロファイル固有の情報を運ぶが、多くのアプリケーションは、それらを必要とすると予想され、それ以外の場合だけ、それらを保持するために別の32ビットワードを追加する必要がある場合がありますので、それらが固定されたヘッダに割り当てられます。これらのフィールドを含むオクテットは、より多くのまたはより少ないマーカービットで、たとえば、さまざまな要件に合わせて、プロファイルによって再定義されるかもしれません。任意のマーカービットがある場合、プロファイルに依存しないモニタはパケット損失パターンとマーカビット間の相関を観察することができるかもしれないので、一つのオクテットの最上位ビットに配置されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Additional information that is required for a particular payload format, such as a video encoding, SHOULD be carried in the payload section of the packet. This might be in a header that is always present at the start of the payload section, or might be indicated by a reserved value in the data pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O、ビデオ符号化として、特定のペイロード・フォーマットに必要とされる追加情報は、パケットのペイロード部に実施すべきです。これは、ペイロード部の開始時に常に存在している、またはデータパターンの予約値によって示されるかもしれないヘッダにあるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a particular class of applications needs additional functionality independent of payload format, the profile under which those applications operate SHOULD define additional fixed fields to follow immediately after the SSRC field of the existing fixed header. Those applications will be able to quickly and directly access the additional fields while profile-independent monitors or recorders can still process the RTP packets by interpreting only the first twelve octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの特定のクラスは、ペイロードフォーマットの追加機能の独立を必要とする場合、O、それらのアプリケーションは、追加の固定フィールドを定義する必要が動作する下プロファイルは、既存の固定ヘッダのSSRCフィールドの直後にします。これらのアプリケーションは、プロファイルに依存しないモニターやレコーダーはまだ最初の12個のオクテットを解釈することによってRTPパケットを処理することができますしながら、迅速かつ直接追加フィールドにアクセスすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If it turns out that additional functionality is needed in common across all profiles, then a new version of RTP should be defined to make a permanent change to the fixed header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは付加的な機能がすべてのプロファイルに共通で必要とされていることが判明した場合、その後、RTPの新しいバージョンでは、固定ヘッダに恒久的な変更を行うために定義する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1 RTP Header Extension
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1 RTPヘッダー拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extension mechanism is provided to allow individual implementations to experiment with new payload-format-independent functions that require additional information to be carried in the RTP data packet header. This mechanism is designed so that the header extension may be ignored by other interoperating implementations that have not been extended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張機構は、個々の実装がRTPデータパケットヘッダで運ばれる追加情報を必要とする新しいペイロードフォーマットに依存しない機能を試すことができるように設けられています。ヘッダ拡張が拡張されていない他の相互運用の実装では無視することができるように、この機構が設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this header extension is intended only for limited use. Most potential uses of this mechanism would be better done another way, using the methods described in the previous section. For example, a profile-specific extension to the fixed header is less expensive to process because it is not conditional nor in a variable location. Additional information required for a particular payload format SHOULD NOT use this header extension, but SHOULD be carried in the payload section of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヘッダー拡張のみ限定使用のために意図されていることに留意されたいです。このメカニズムのほとんどの潜在的な用途は、より良い、前のセクションで説明した方法を使用して、別の方法で行われます。それは条件も可変位置ではないので、例えば、固定されたヘッダのプロファイル固有の拡張子がプロセスに安価です。特定のペイロードフォーマットに必要な追加情報は、このヘッダ拡張を使用しませんが、パケットのペイロード部に実施すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | defined by profile | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | header extension | | .... |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + |プロファイルで定義されました|長さ| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |ヘッダ拡張| | .... |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the X bit in the RTP header is one, a variable-length header extension MUST be appended to the RTP header, following the CSRC list if present. The header extension contains a 16-bit length field that counts the number of 32-bit words in the extension, excluding the four-octet extension header (therefore zero is a valid length). Only a single extension can be appended to the RTP data header. To allow multiple interoperating implementations to each experiment independently with different header extensions, or to allow a particular implementation to experiment with more than one type of header extension, the first 16 bits of the header extension are left open for distinguishing identifiers or parameters. The format of these 16 bits is to be defined by the profile specification under which the implementations are operating. This RTP specification does not define any header extensions itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPヘッダ内のXビットが1である場合、可変長ヘッダ拡張が存在する場合CSRCリストを以下、RTPヘッダに付加されなければなりません。ヘッダ拡張が4オクテット拡張ヘッダを除いた、拡張の32ビット・ワードの数をカウントする16ビットの長さフィールドを含む（したがって、ゼロは、有効な長さです）。単一の拡張は、RTPデータヘッダに付加することができます。異なるヘッダ拡張でそれぞれ独立して実験に実装を相互運用する複数可能にするために、又はヘッダ拡張の複数のタイプを試すために、特定の実装を可能にするために、ヘッダ拡張の最初の16ビットは識別子またはパラメータを識別するための開いたままにされています。これら16ビットのフォーマットは実装が動作してその下のプロファイル仕様によって定義されるべきです。このRTP仕様は、任意のヘッダ拡張自体を定義していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. RTP Control Protocol -- RTCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. RTP制御プロトコル -  RTCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP control protocol (RTCP) is based on the periodic transmission of control packets to all participants in the session, using the same distribution mechanism as the data packets. The underlying protocol MUST provide multiplexing of the data and control packets, for example using separate port numbers with UDP. RTCP performs four functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP制御プロトコル（RTCP）は、データパケットと同じ配信メカニズムを使用して、セッションのすべての参加者に制御パケットの周期的な送信に基づいています。基本的なプロトコルはUDPで別のポート番号を使用して、例えば、データ及び制御パケットの多重化を提供しなければなりません。 RTCPは、4つの機能を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The primary function is to provide feedback on the quality of the data distribution. This is an integral part of the RTP&#39;s role as a transport protocol and is related to the flow and congestion control functions of other transport protocols (see Section 10 on the requirement for congestion control). The feedback may be directly useful for control of adaptive encodings [18,19], but experiments with IP multicasting have shown that it is also critical to get feedback from the receivers to diagnose faults in the distribution. Sending reception feedback reports to all participants allows one who is observing problems to evaluate whether those problems are local or global. With a distribution mechanism like IP multicast, it is also possible for an entity such as a network service provider who is not otherwise involved in the session to receive the feedback information and act as a third-party monitor to diagnose network problems. This feedback function is performed by the RTCP sender and receiver reports, described below in Section 6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.主な機能は、データ配信の品質に関するフィードバックを提供することです。これは、トランスポートプロトコルとしてのRTPの役割の不可欠な部分であり、他のトランスポートプロトコル（輻輳制御のための要件のセクション10を参照）の流れと輻輳制御機能に関連しています。フィードバックは、適応符号化方式[18,19]の制御に直接役に立つかもしれないが、IPマルチキャストを用いた実験は、分布の障害を診断するために、受信機からのフィードバックを得ることも重要であることを示しています。すべての参加者に受信フィードバックレポートを送信すると、それらの問題は、ローカルまたはグローバルであるかどうかを評価するために、問題を観察しているものを可能にします。 IPマルチキャストなどの配信メカニズムでは、そのようなそうでない場合は、ネットワークの問題を診断するには、サードパーティ製のモニターとしてフィードバック情報と行動を受け取るためにセッションに含まれていないネットワーク・サービス・プロバイダとしてもエンティティの可能です。このフィードバック機能は、6.4節に説明RTCPの送信者と受信者のレポート、によって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. RTCP carries a persistent transport-level identifier for an RTP source called the canonical name or CNAME, Section 6.5.1. Since the SSRC identifier may change if a conflict is discovered or a program is restarted, receivers require the CNAME to keep track of each participant. Receivers may also require the CNAME to associate multiple data streams from a given participant in a set of related RTP sessions, for example to synchronize audio and video. Inter-media synchronization also requires the NTP and RTP timestamps included in RTCP packets by data senders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. RTCPは正規名またはCNAME、セクション6.5.1と呼ばれるRTPソースの永続的なトランスポートレベル識別子を搬送します。競合が発見されたり、プログラムが再起動された場合SSRC識別子は変更されることがありますので、受信機は、各参加者を追跡するために、CNAMEを必要としています。受信機は、オーディオとビデオを同期させるために、例えば、関連するRTPセッションのセット内の所与の参加者からの複数のデータストリームを関連付けるためのCNAMEを必要とするかもしれません。インターメディア同期はまた、NTPおよびRTPタイムスタンプは、データの送信者によってRTCPパケットに含まが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The first two functions require that all participants send RTCP packets, therefore the rate must be controlled in order for RTP to scale up to a large number of participants. By having each participant send its control packets to all the others, each can independently observe the number of participants. This number is used to calculate the rate at which the packets are sent, as explained in Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.最初の二つの機能は、したがって、レートはRTPが参加者の大多数にスケールアップするために制御しなければならない、すべての参加者がRTCPパケットを送信することを必要とします。各参加者は、すべての人にその制御パケットを送信したことで、それぞれが独立して、参加者の数を観察することができます。この番号は、セクション6.2で説明したように、パケットが送信されるレートを計算するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. A fourth, OPTIONAL function is to convey minimal session control information, for example participant identification to be displayed in the user interface. This is most likely to be useful in &#34;loosely controlled&#34; sessions where participants enter and leave without membership control or parameter negotiation. RTCP serves as a convenient channel to reach all the participants, but it is not necessarily expected to support all the control communication requirements of an application. A higher-level session control protocol, which is beyond the scope of this document, may be needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4、オプション機能は、例えば、参加者の識別は、ユーザインタフェースに表示されるため、最小のセッション制御情報を伝達することです。これは、参加者が入るとメンバーシップの制御やパラメータのネゴシエーションなしのままに「緩やかに制御された」セッションに有用である可能性が最も高いです。 RTCPは、すべての参加者に到達するための便利なチャンネルとして機能するが、必ずしも、アプリケーションのすべての制御通信要件をサポートすることが期待されていません。この文書の範囲を超えて、より高いレベルのセッション制御プロトコルは、必要とされるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Functions 1-3 SHOULD be used in all environments, but particularly in the IP multicast environment. RTP application designers SHOULD avoid mechanisms that can only work in unicast mode and will not scale to larger numbers. Transmission of RTCP MAY be controlled separately for senders and receivers, as described in Section 6.2, for cases such as unidirectional links where feedback from receivers is not possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機能1-3は、すべての環境ではなく、特にIPマルチキャスト環境で使用されるべきです。 RTPアプリケーションの設計者は、ユニキャストモードで動作することができますし、より大きな数字に拡張しませんメカニズムを避ける必要があります。そのような受信機からのフィードバックが不可能である一方向リンクなどの場合のために、6.2節で説明したようにRTCPの送信は、送信者と受信者に対して個別に制御することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-normative note: In the multicast routing approach called Source-Specific Multicast (SSM), there is only one sender per &#34;channel&#34; (a source address, group address pair), and receivers (except for the channel source) cannot use multicast to communicate directly with other channel members. The recommendations here accommodate SSM only through Section 6.2&#39;s option of turning off receivers&#39; RTCP entirely. Future work will specify adaptation of RTCP for SSM so that feedback from receivers can be maintained.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非規範的注意：ソース固有マルチキャスト（SSM）と呼ばれるマルチキャストルーティングアプローチでは、そこに「チャネル」ごとに1つだけの送信者（送信元アドレス、グループ・アドレスのペア）であり、（チャネルソースを除く）受信機がマルチキャストを使用することはできません他のチャネルのメンバーと直接通信します。ここでの推奨事項は唯一の完全に受信者RTCPをオフにするのセクション6.2のオプションを使用してSSMを収容します。受信機からのフィードバックを維持できるように、今後の作業は、SSMのためのRTCPの適応を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 RTCP Packet Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 RTCPパケットフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines several RTCP packet types to carry a variety of control information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、様々な制御情報を運ぶために、いくつかのRTCPパケットタイプを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR: Sender report, for transmission and reception statistics from participants that are active senders
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR：送信者レポート、アクティブな送信者です参加者からの送信と受信のための統計
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RR: Receiver report, for reception statistics from participants that are not active senders and in combination with SR for active senders reporting on more than 31 sources
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RR：受信レポート、アクティブな送信者と活発な送信者のためのSRとの組み合わせではない参加者からの受信統計は31の以上のソースを上報告します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES: Source description items, including CNAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES：CNAMEを含むソース記述項目、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYE: Indicates end of participation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYE：参加の終わりを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
APP: Application-specific functions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
APP：アプリケーション固有の機能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each RTCP packet begins with a fixed part similar to that of RTP data packets, followed by structured elements that MAY be of variable length according to the packet type but MUST end on a 32-bit boundary. The alignment requirement and a length field in the fixed part of each packet are included to make RTCP packets &#34;stackable&#34;. Multiple RTCP packets can be concatenated without any intervening separators to form a compound RTCP packet that is sent in a single packet of the lower layer protocol, for example UDP. There is no explicit count of individual RTCP packets in the compound packet since the lower layer protocols are expected to provide an overall length to determine the end of the compound packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各RTCPパケットは、パケットタイプに従って可変長のものであってもよいが、32ビット境界で終了する必要があり、構造化要素に続くRTPデータパケットと同様の固定部、始まります。各パケットの固定部のアライメント要件と長さフィールドは、RTCPパケット「積み重ね可能」を作るために含まれます。複数のRTCPパケットは、例えば、下位層プロトコル、UDPの単一パケットで送信された化合物のRTCPパケットを形成するために、任意の介在なしにセパレータ連結することができます。下位層プロトコルは化合物パケットの終了を決定するための全体的な長さを提供することが期待されているので、複合パケット内の個々のRTCPパケットの明示的な数が存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each individual RTCP packet in the compound packet may be processed independently with no requirements upon the order or combination of packets. However, in order to perform the functions of the protocol, the following constraints are imposed: o Reception statistics (in SR or RR) should be sent as often as bandwidth constraints will allow to maximize the resolution of the statistics, therefore each periodically transmitted compound RTCP packet MUST include a report packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
合成パケットの個々のRTCPパケットは、パケットの順序または組合せにない要件を独立に処理することができます。しかしながら、プロトコルの機能を実行するために、以下の制約が課せられる：（SRまたはRRで）O受信統計ができるだけ頻繁帯域幅制約が統計の解像度を最大化することを可能にするように送信されるべきで、従って各周期的に送信化合物RTCPパケットはレポートパケットを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o New receivers need to receive the CNAME for a source as soon as possible to identify the source and to begin associating media for purposes such as lip-sync, so each compound RTCP packet MUST also include the SDES CNAME except when the compound RTCP packet is split for partial encryption as described in Section 9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい受信機はまた、複合RTCPパケットである場合を除いてSDES CNAMEを含まなければなりませんソースを識別し、そのようなリップシンクのような目的のためにメディアを関連付ける開始するために、できるだけ早くソースのCNAMEを受信する必要があるので、各化合物のRTCPパケットoを9.1節で説明したように部分的に暗号化のために分割します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The number of packet types that may appear first in the compound packet needs to be limited to increase the number of constant bits in the first word and the probability of successfully validating RTCP packets against misaddressed RTP data packets or other unrelated packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O化合物パケットの最初に表示されてもよいパケットタイプの数は、第1のワードと正常misaddressed RTPデータパケットまたは他の無関係のパケットに対するRTCPパケットを検証する確率に一定のビット数を増加させるために制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, all RTCP packets MUST be sent in a compound packet of at least two individual packets, with the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、すべてのRTCPパケットは、次の形式で、少なくとも二つの個々のパケットの化合物パケットで送信されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encryption prefix: If and only if the compound packet is to be encrypted according to the method in Section 9.1, it MUST be prefixed by a random 32-bit quantity redrawn for every compound packet transmitted. If padding is required for the encryption, it MUST be added to the last packet of the compound packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化プレフィックス：化合物パケットは、セクション9.1に記載の方法にしたがって暗号化する場合のみなら、それは、送信されたすべての化合物パケットの再描画ランダムな32ビットの値が前置されなければなりません。パディングが暗号化のために必要な場合は、複合パケットの最後のパケットに追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR or RR: The first RTCP packet in the compound packet MUST always be a report packet to facilitate header validation as described in Appendix A.2. This is true even if no data has been sent or received, in which case an empty RR MUST be sent, and even if the only other RTCP packet in the compound packet is a BYE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRまたはRR：化合物パケットにおける最初のRTCPパケットは常に付録A.2に記載したように、ヘッダの検証を容易にするレポートパケットでなければなりません。これは、データが送信されないまたは受信、空のRRが送信されなければならない場合には、化合物パケットにのみ他のRTCPパケットがBYEであってもされている場合も同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional RRs: If the number of sources for which reception statistics are being reported exceeds 31, the number that will fit into one SR or RR packet, then additional RR packets SHOULD follow the initial report packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加のRR：受信統計が報告されているソースの数が31を超える場合は、1つのSRまたはRRパケットに収まる数は、その後、追加のRRパケットが最初の報告パケットに従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES: An SDES packet containing a CNAME item MUST be included in each compound RTCP packet, except as noted in Section 9.1. Other source description items MAY optionally be included if required by a particular application, subject to bandwidth constraints (see Section 6.3.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES：CNAME項目を含むSDESパケットは、セクション9.1で述べたように除き、各化合物のRTCPパケットに含まれなければなりません。帯域幅の制約を受ける特定のアプリケーション、（セクション6.3.9を参照）で必要に応じて他のソース記述項目は、任意に含まれるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYE or APP: Other RTCP packet types, including those yet to be defined, MAY follow in any order, except that BYE SHOULD be the last packet sent with a given SSRC/CSRC. Packet types MAY appear more than once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYEまたはAPP：そのBYEが与えられたSSRC / CSRCで送信された最後のパケットであるべきである以外はまだ定義されてものを含む他のRTCPパケットタイプは、任意の順序で従うことができます。パケットタイプが複数回表示されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An individual RTP participant SHOULD send only one compound RTCP packet per report interval in order for the RTCP bandwidth per participant to be estimated correctly (see Section 6.2), except when the compound RTCP packet is split for partial encryption as described in Section 9.1. If there are too many sources to fit all the necessary RR packets into one compound RTCP packet without exceeding the maximum transmission unit (MTU) of the network path, then only the subset that will fit into one MTU SHOULD be included in each interval. The subsets SHOULD be selected round-robin across multiple intervals so that all sources are reported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個々のRTPの参加者は、9.1節に記載の化合物RTCPパケットを部分暗号化のために分割されている場合を除いて正確に推定することが参加者ごとのRTCP帯域幅（6.2節を参照）ためにレポート間隔ごとに1つだけ化合物RTCPパケットを送るべきです。ネットワークパスの最大伝送単位（MTU）を超えることなく、1つの化合物のRTCPパケットに必要なすべてのRRパケットに合うように、あまりにも多くのソースがある場合、1 MTUに収まるだけのサブセットは各区間に含まれるべきです。すべてのソースが報告されているように、サブセットは、複数の間隔を横切ってラウンドロビン方式を選択すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that translators and mixers combine individual RTCP packets from the multiple sources they are forwarding into one compound packet whenever feasible in order to amortize the packet overhead (see Section 7). An example RTCP compound packet as might be produced by a mixer is shown in Fig. 1. If the overall length of a compound packet would exceed the MTU of the network path, it SHOULD be segmented into multiple shorter compound packets to be transmitted in separate packets of the underlying protocol. This does not impair the RTCP bandwidth estimation because each compound packet represents at least one distinct participant. Note that each of the compound packets MUST begin with an SR or RR packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットのオーバーヘッドを償却するために（セクション7参照）ときはいつでも可能翻訳者とミキサーは、それらが一つの化合物パケットに転送している複数のソースから個々のRTCPパケットを結合することが推奨されます。ミキサによって生成されるかもしれない例としてRTCP化合物パケットは、図2に示されている。1.ネットワーク経路のMTUを超える化合物パケットの全体の長さは、別々に送信される複数の短い化合物パケットに分割する必要がある場合基本的なプロトコルのパケット。各化合物のパケットは、少なくとも1人の異なる参加者を表すので、これはRTCP帯域幅推定を損ないません。化合物パケットの各々は、SRまたはRRパケットで開始しなければならないことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation SHOULD ignore incoming RTCP packets with types unknown to it. Additional RTCP packet types may be registered with the Internet Assigned Numbers Authority (IANA) as described in Section 15.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、それまで未知の種類の着信RTCPパケットを無視する必要があります。セクション15で説明したように、追加のRTCPパケットタイプは、Internet Assigned Numbers Authority（IANA）に登録されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   if encrypted: random 32-bit integer
   |
   |[--------- packet --------][---------- packet ----------][-packet-]
   |
   |                receiver            chunk        chunk
   V                reports           item  item   item  item
   --------------------------------------------------------------------
   R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why]
   --------------------------------------------------------------------
   |                                                                  |
   |&lt;-----------------------  compound packet -----------------------&gt;|
   |&lt;--------------------------  UDP packet -------------------------&gt;|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#: SSRC/CSRC identifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
＃：SSRC / CSRC識別
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Figure 1: Example of an RTCP compound packet
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
図1：RTCP化合物パケットの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 RTCP Transmission Interval
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 RTCP送信間隔
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP is designed to allow an application to scale automatically over session sizes ranging from a few participants to thousands. For example, in an audio conference the data traffic is inherently self-limiting because only one or two people will speak at a time, so with multicast distribution the data rate on any given link remains relatively constant independent of the number of participants. However, the control traffic is not self-limiting. If the reception reports from each participant were sent at a constant rate, the control traffic would grow linearly with the number of participants. Therefore, the rate must be scaled down by dynamically calculating the interval between RTCP packet transmissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは、アプリケーションがいくつかの参加者から何千人に及ぶセッションサイズの上に自動的に拡張できるように設計されています。任意のリンク上のデータ速度は参加者の数の比較的一定の独立したまま、マルチキャスト配信を持つように、1つまたは2つだけの人が、一度に話しますので、例えば、音声会議でのデータトラフィックは、本質的に自己限定的です。しかし、制御トラフィックは自己制限ではありません。各参加者からの受信レポートは一定の速度で送られた場合、制御トラフィックは、参加者の数に比例し成長します。したがって、レートを動的RTCPパケット送信間隔を算出することにより縮小されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each session, it is assumed that the data traffic is subject to an aggregate limit called the &#34;session bandwidth&#34; to be divided among the participants. This bandwidth might be reserved and the limit enforced by the network. If there is no reservation, there may be other constraints, depending on the environment, that establish the &#34;reasonable&#34; maximum for the session to use, and that would be the session bandwidth. The session bandwidth may be chosen based on some cost or a priori knowledge of the available network bandwidth for the session. It is somewhat independent of the media encoding, but the encoding choice may be limited by the session bandwidth. Often, the session bandwidth is the sum of the nominal bandwidths of the senders expected to be concurrently active. For teleconference audio, this number would typically be one sender&#39;s bandwidth. For layered encodings, each layer is a separate RTP session with its own session bandwidth parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各セッションのために、データトラフィックは、参加者間で分割される「セッション帯域幅」と呼ばれる凝集制限を受けるものとします。この帯域幅は、予約と制限は、ネットワークによって強制される可能性があります。何の予約がない場合は、そのセッションが使用するための「合理的な」最大を確立し、それがセッション帯域幅となり、環境に応じて、他の制約があるかもしれません。セッション帯域幅は、いくつかのコストやセッションのために利用可能なネットワーク帯域幅の先験的な知識に基づいて選択することができます。これは、メディアエンコーディングのある程度独立しているが、エンコードの選択は、セッション帯域幅によって制限される場合があります。多くの場合、セッション帯域幅は、同時にアクティブになることが予想送信者の公称帯域幅の合計です。会議のオーディオの場合、この数は典型的には、1つの送信者の帯域幅になります。レイヤード符号化のために、それぞれの層が独自のセッションの帯域幅パラメータを有する別個のRTPセッションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The session bandwidth parameter is expected to be supplied by a session management application when it invokes a media application, but media applications MAY set a default based on the single-sender data bandwidth for the encoding selected for the session. The application MAY also enforce bandwidth limits based on multicast scope rules or other criteria. All participants MUST use the same value for the session bandwidth so that the same RTCP interval will be calculated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの帯域幅パラメータは、それがメディアアプリケーションを起動すると、セッション管理アプリケーションによって供給されることが予想されますが、メディアアプリケーションは、セッションのために選択したエンコードのための単一の送信者のデータ帯域幅に基づいてデフォルトを設定できます。アプリケーションは、マルチキャストスコープ規則または他の基準に基づいて帯域制限を実施してもよい（MAY）。同じRTCP間隔が計算されるように、すべての参加者がセッション帯域幅のために同じ値を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bandwidth calculations for control and data traffic include lower-layer transport and network protocols (e.g., UDP and IP) since that is what the resource reservation system would need to know. The application can also be expected to know which of these protocols are in use. Link level headers are not included in the calculation since the packet will be encapsulated with different link level headers as it travels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御およびデータ・トラフィックの帯域幅の計算は、下層のトランスポート及びネットワークプロトコル（例えば、UDPおよびIP）は、リソース予約システムが知る必要があるであろうものであるので、が挙げられます。また、アプリケーションは使用されているこれらのプロトコルのかを知ることが期待できます。それが移動するパケットが異なるリンクレベルヘッダでカプセル化されるので、リンクレベルヘッダは計算に含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The control traffic should be limited to a small and known fraction of the session bandwidth: small so that the primary function of the transport protocol to carry data is not impaired; known so that the control traffic can be included in the bandwidth specification given to a resource reservation protocol, and so that each participant can independently calculate its share. The control traffic bandwidth is in addition to the session bandwidth for the data traffic. It is RECOMMENDED that the fraction of the session bandwidth added for RTCP be fixed at 5%. It is also RECOMMENDED that 1/4 of the RTCP bandwidth be dedicated to participants that are sending data so that in sessions with a large number of receivers but a small number of senders, newly joining participants will more quickly receive the CNAME for the sending sites. When the proportion of senders is greater than 1/4 of the participants, the senders get their proportion of the full RTCP bandwidth. While the values of these and other constants in the interval calculation are not critical, all participants in the session MUST use the same values so the same interval will be calculated. Therefore, these constants SHOULD be fixed for a particular profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御トラフィックは、セッション帯域幅の小さなと既知の画分に限定されるべきである：小データを搬送するトランスポートプロトコルの主要機能が損なわれないように。制御トラフィックは、リソース予約プロトコルに与えられた帯域幅の仕様に含めることができるように、各参加者が独立してシェアを計算することができるように知られています。制御トラフィックの帯域幅は、データトラフィックのためのセッション帯域幅に加えています。 RTCPのために追加セッション帯域幅の割合が5％に固定されることが推奨されます。また、RTCP帯域幅の1/4は、多数の受信機が、送信者の数が少ないとのセッションになるようにデータを送信している参加者に専用とすることが推奨され、新たに参加する参加者は、より迅速に送るのサイトのCNAMEを受け取ることになります。送信者の割合は、参加者の1/4よりも大きい場合、送信者は、完全なRTCP帯域幅の彼らの割合を取得します。間隔計算におけるこれらおよび他の定数の値は重要ではないですが、同じ間隔が計算されますので、セッション内のすべての参加者が同じ値を使用する必要があります。したがって、これらの定数は、特定のプロファイルに固定してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A profile MAY specify that the control traffic bandwidth may be a separate parameter of the session rather than a strict percentage of the session bandwidth. Using a separate parameter allows rate-adaptive applications to set an RTCP bandwidth consistent with a &#34;typical&#34; data bandwidth that is lower than the maximum bandwidth specified by the session bandwidth parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルは、制御トラフィックの帯域幅がセッションの別のパラメータではなく、セッション帯域幅の厳密な割合であってもよいことを指定することができます。別のパラメータを使用すると、セッション帯域幅パラメータで指定された最大帯域幅よりも低い「典型的な」データの帯域幅と一致するRTCP帯域幅を設定するためのレート適応型アプリケーションを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The profile MAY further specify that the control traffic bandwidth may be divided into two separate session parameters for those participants which are active data senders and those which are not; let us call the parameters S and R. Following the recommendation that 1/4 of the RTCP bandwidth be dedicated to data senders, the RECOMMENDED default values for these two parameters would be 1.25% and 3.75%, respectively. When the proportion of senders is greater than S/(S+R) of the participants, the senders get their proportion of the sum of these parameters. Using two parameters allows RTCP reception reports to be turned off entirely for a particular session by setting the RTCP bandwidth for non-data-senders to zero while keeping the RTCP bandwidth for data senders non-zero so that sender reports can still be sent for inter-media synchronization. Turning off RTCP reception reports is NOT RECOMMENDED because they are needed for the functions listed at the beginning of Section 6, particularly reception quality feedback and congestion control. However, doing so may be appropriate for systems operating on unidirectional links or for sessions that don&#39;t require feedback on the quality of reception or liveness of receivers and that have other means to avoid congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルは、さらに、制御トラフィック帯域幅は、アクティブなデータ送信者とされていないものであり、これらの参加者のための2つの別々のセッションパラメータに分割することができることを指定してもよいです。私たちは、RTCP帯域幅の1/4がデータの送信者専用にすることを勧告に従いパラメータSとRを呼ぶことにしましょう、これら2つのパラメータのために推奨されるデフォルト値は、それぞれ1.25％と3.75パーセントになります。送信者の割合は、参加者のS /（S + R）よりも大きい場合、送信者は、これらのパラメータの和の彼らの割合を取得します。 2つのパラメータを使用すると、RTCP受信レポートが送信者レポートは、まだ相互のために送信することができるように、データの送信者の非ゼロのためのRTCP帯域幅を維持しながら、ゼロに非データ送信者のためのRTCP帯域幅を設定することにより、特定のセッションのために完全にオフにすることを可能にします-media同期。それらは第6節の冒頭に記載されている機能のために必要とされるため、RTCP受信レポートをオフにすると、特に受信品質のフィードバックや輻輳制御をお勧めしません。しかし、そうすることは、単方向リンク上でのオペレーティングシステム用または受信や受信機の生存性の品質に関するフィードバックを必要としているが、混雑を避けるために他の手段を持っていないセッションのために適切かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The calculated interval between transmissions of compound RTCP packets SHOULD also have a lower bound to avoid having bursts of packets exceed the allowed bandwidth when the number of participants is small and the traffic isn&#39;t smoothed according to the law of large numbers. It also keeps the report interval from becoming too small during transient outages like a network partition such that adaptation is delayed when the partition heals. At application startup, a delay SHOULD be imposed before the first compound RTCP packet is sent to allow time for RTCP packets to be received from other participants so the report interval will converge to the correct value more quickly. This delay MAY be set to half the minimum interval to allow quicker notification that the new participant is present. The RECOMMENDED value for a fixed minimum interval is 5 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複合RTCPパケットの送信の間の計算間隔も参加者の数が少なく、トラフィックが大数の法則に従って平滑化されていない場合、パケットのバーストが許可された帯域幅を超えることを避けるために下限を持つべきである（SHOULD）。また、時にパーティションが回復適応が遅れているようなネットワークパーティションなどの過渡的な停電時に小さくなりすぎるからレポート間隔を保持します。最初の複合RTCPパケットはレポート間隔がより迅速に正しい値に収束するように、RTCPパケットは、他の参加者から受信するための時間を許可するように送られる前に、アプリケーションの起動時に、遅延が課されるべきです。この遅延は、新規参加者が存在していることを迅速に通知を許可するように半分の最小間隔に設定されるかもしれません。固定された最小間隔の推奨値は5秒です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation MAY scale the minimum RTCP interval to a smaller value inversely proportional to the session bandwidth parameter with the following limitations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装には、以下の制限とのセッションの帯域幅パラメータに反比例小さい値に最小RTCP間隔をスケーリングすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For multicast sessions, only active data senders MAY use the reduced minimum value to calculate the interval for transmission of compound RTCP packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oマルチキャストセッションのために、唯一のアクティブなデータ送信者は、複合RTCPパケットの送信間隔を算出する縮小最小値を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For unicast sessions, the reduced value MAY be used by participants that are not active data senders as well, and the delay before sending the initial compound RTCP packet MAY be zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oユニキャストセッションでは、換算値は、同様にアクティブなデータの送信者ではない者によって使用されてもよく、初期の複合RTCPパケットを送信する前に遅延が0であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For all sessions, the fixed minimum SHOULD be used when calculating the participant timeout interval (see Section 6.3.5) so that implementations which do not use the reduced value for transmitting RTCP packets are not timed out by other participants prematurely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケットを送信するための換算値を使用しない実装が早まって他の参加者によってタイムアウトされないように参加者のタイムアウト間隔を計算する際Oすべてのセッションについて、一定の最小を使用しなければならない（6.3.5を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The RECOMMENDED value for the reduced minimum in seconds is 360 divided by the session bandwidth in kilobits/second. This minimum is smaller than 5 seconds for bandwidths greater than 72 kb/s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
秒で低下最小の推奨値はキロビット/秒のセッション帯域360に分割される、O。この最小値は72キロバイト/秒よりも大きい帯域幅のために5秒よりも小さくなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm described in Section 6.3 and Appendix A.7 was designed to meet the goals outlined in this section. It calculates the interval between sending compound RTCP packets to divide the allowed control traffic bandwidth among the participants. This allows an application to provide fast response for small sessions where, for example, identification of all participants is important, yet automatically adapt to large sessions. The algorithm incorporates the following characteristics: o The calculated interval between RTCP packets scales linearly with the number of members in the group. It is this linear factor which allows for a constant amount of control traffic when summed across all members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション6.3および付録A.7に記載されたアルゴリズムは、このセクションで概説目標を達成するために設計されました。これは、参加者間で許容される制御トラフィック帯域幅を分割する複合RTCPパケットの送信間隔を算出します。これは、アプリケーションが、たとえば、すべての参加者の識別が重要であり、まだ自動的に大きなセッションに適応し、小さなセッションのための高速応答を提供することができます。このアルゴリズムは、以下の特徴を組み込んだ：RTCPパケット間の計算された間隔は、グループ内のメンバーの数と共に直線的にスケーリングoを。これは、すべてのメンバーにわたって合計するとき、制御トラフィックの一定量を可能にし、この直線的な要因です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The interval between RTCP packets is varied randomly over the range [0.5,1.5] times the calculated interval to avoid unintended synchronization of all participants [20]. The first RTCP packet sent after joining a session is also delayed by a random variation of half the minimum RTCP interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RTCPパケット間の間隔は、すべての参加者[20]の意図しない同期を回避するために、範囲[0.5,1.5]回にわたってランダムに計算間隔を変化させます。セッションに参加した後に送信された最初のRTCPパケットも半分最小RTCP間隔のランダム変動によって遅延されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A dynamic estimate of the average compound RTCP packet size is calculated, including all those packets received and sent, to automatically adapt to changes in the amount of control information carried.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O、平均化合物RTCPパケットサイズの動的推定値は、自動的に実施される制御情報の量の変化に適応するために、受信および送信されたすべてのそれらのパケットを含め、計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Since the calculated interval is dependent on the number of observed group members, there may be undesirable startup effects when a new user joins an existing session, or many users simultaneously join a new session. These new users will initially have incorrect estimates of the group membership, and thus their RTCP transmission interval will be too short. This problem can be significant if many users join the session simultaneously. To deal with this, an algorithm called &#34;timer reconsideration&#34; is employed. This algorithm implements a simple back-off mechanism which causes users to hold back RTCP packet transmission if the group sizes are increasing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
計算された間隔が観測され、グループメンバーの数に依存しているので、新しいユーザーが既存のセッションに参加するか、多くのユーザーが同時に新しいセッションに参加するとき、O、望ましくないスタートアップの影響があるかもしれません。これらの新しいユーザーは、最初にグループメンバーシップの不正確な推定値を持つことになりますので、そのRTCP送信間隔が短すぎるとなります。多くのユーザーが同時にセッションに参加する場合、この問題が重要になります。これに対処するには、「タイマー再考」と呼ばれるアルゴリズムが採用されています。このアルゴリズムは、グループのサイズが増加している場合、ユーザーがRTCPパケット送信を我慢する原因となるシンプルなバックオフメカニズムを実装しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When users leave a session, either with a BYE or by timeout, the group membership decreases, and thus the calculated interval should decrease. A &#34;reverse reconsideration&#34; algorithm is used to allow members to more quickly reduce their intervals in response to group membership decreases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーがBYEまたはタイムアウトのいずれかによって、セッションを終了する場合、O、グループメンバーシップが減少し、従って計算された間隔が減少するはずです。 「逆再考」アルゴリズムは、メンバーはより迅速にグループメンバーシップの減少に応じて、その間隔を短縮できるようにするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BYE packets are given different treatment than other RTCP packets. When a user leaves a group, and wishes to send a BYE packet, it may do so before its next scheduled RTCP packet. However, transmission of BYEs follows a back-off algorithm which avoids floods of BYE packets should a large number of members simultaneously leave the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYE Oパケットは他のRTCPパケットとは異なる治療を与えられています。ユーザーがグループを離脱し、BYEパケットを送信したい場合は、その次のスケジュールされたRTCPパケットの前にそれを行うことがあります。しかしながら、不戦勝の送信は、BYEパケットの洪水は、多数のメンバーが同時にセッションを残すべき回避バックオフアルゴリズムに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm may be used for sessions in which all participants are allowed to send. In that case, the session bandwidth parameter is the product of the individual sender&#39;s bandwidth times the number of participants, and the RTCP bandwidth is 5% of that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、すべての参加者が送信することが許可されているセッションのために使用することができます。その場合には、セッションの帯域幅パラメータは、参加者の数の個々の送信者の帯域幅の積であり、RTCP帯域幅は、その5％です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Details of the algorithm&#39;s operation are given in the sections that follow. Appendix A.7 gives an example implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズムの動作の詳細については、以下のセクションに記載されています。付録A.7は、実装例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1 Maintaining the Number of Session Members
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1セッションメンバーの数を維持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Calculation of the RTCP packet interval depends upon an estimate of the number of sites participating in the session. New sites are added to the count when they are heard, and an entry for each SHOULD be created in a table indexed by the SSRC or CSRC identifier (see Section 8.2) to keep track of them. New entries MAY be considered not valid until multiple packets carrying the new SSRC have been received (see Appendix A.1), or until an SDES RTCP packet containing a CNAME for that SSRC has been received. Entries MAY be deleted from the table when an RTCP BYE packet with the corresponding SSRC identifier is received, except that some straggler data packets might arrive after the BYE and cause the entry to be recreated. Instead, the entry SHOULD be marked as having received a BYE and then deleted after an appropriate delay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケット間隔の計算は、セッションに参加するサイトの数の推定値に依存します。彼らは聞いているときに、新しいサイトは、カウントに追加され、それぞれのエントリはSSRCかCSRC識別子でインデックス付けテーブルに作成する必要があり、それらを追跡するために（8.2節を参照してください）。新しいSSRCを運ぶ複数のパケットが（付録A.1を参照）を受信するまで、またはそのSSRCのためのCNAMEを含むSDES RTCPパケットが受信されるまで新しいエントリは有効ではないと考えることができます。対応するSSRC識別子にRTCP BYEパケットは、いくつかの落伍者のデータパケットがBYE後に到着すると、エントリが再作成させる可能性があることを除いて、受信されたときにエントリがテーブルから削除することができます。その代わりに、エントリは、BYEを受信し、適切な遅延の後に削除したとしてマークされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A participant MAY mark another site inactive, or delete it if not yet valid, if no RTP or RTCP packet has been received for a small number of RTCP report intervals (5 is RECOMMENDED). This provides some robustness against packet loss. All sites must have the same value for this multiplier and must calculate roughly the same value for the RTCP report interval in order for this timeout to work properly. Therefore, this multiplier SHOULD be fixed for a particular profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何のRTPまたはRTCPパケットがRTCPレポート間隔（5が推奨される）の数が少ないために受信されなかった場合、参加者は、非アクティブな別のサイトをマーク、またはまだ有効でない場合、それを削除することができます。これは、パケット損失に対するいくつかの堅牢性を提供します。すべてのサイトが、この乗数のために同じ値を持つ必要がありますし、このタイムアウトが正しく動作するためにはおおよそRTCPのレポート間隔に同じ値を計算する必要があります。したがって、この乗算器は、特定のプロファイルに固定してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For sessions with a very large number of participants, it may be impractical to maintain a table to store the SSRC identifier and state information for all of them. An implementation MAY use SSRC sampling, as described in [21], to reduce the storage requirements. An implementation MAY use any other algorithm with similar performance. A key requirement is that any algorithm considered SHOULD NOT substantially underestimate the group size, although it MAY overestimate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者の非常に大きな数のセッションでは、それらのすべてのためにSSRC識別子と状態情報を格納するテーブルを維持することは非現実的です。 [21]に記載されているように実装では、ストレージ要件を低減するために、SSRCサンプリングを使用するかもしれません。実装では、同様の性能を持つ他のアルゴリズムを使用するかもしれません。重要な要件は、それが過大評価かもしれないと考える任意のアルゴリズムは、実質的に、グループの大きさを過小評価してはならないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 RTCP Packet Send and Receive Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 RTCPパケットルールを送受信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules for how to send, and what to do when receiving an RTCP packet are outlined here. An implementation that allows operation in a multicast environment or a multipoint unicast environment MUST meet the requirements in Section 6.2. Such an implementation MAY use the algorithm defined in this section to meet those requirements, or MAY use some other algorithm so long as it provides equivalent or better performance. An implementation which is constrained to two-party unicast operation SHOULD still use randomization of the RTCP transmission interval to avoid unintended synchronization of multiple instances operating in the same environment, but MAY omit the &#34;timer reconsideration&#34; and &#34;reverse reconsideration&#34; algorithms in Sections 6.3.3, 6.3.6 and 6.3.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どのように送信するには、どのようなRTCPパケットを受信したときに実行するためのルールがここに概説されています。マルチキャスト環境またはマルチユニキャスト環境での動作を可能にする実装は、6.2節での要件を満たす必要があります。このような実装では、これらの要件を満たすために、このセクションで定義されたアルゴリズムを使用したり、それが同等以上の性能を提供する限り、他のいくつかのアルゴリズムを使用するかもしれません。二大政党のユニキャスト動作に制約されている実装はまだ同じ環境で動作する複数のインスタンスの意図しない同期を避けるために、RTCP送信間隔のランダム化を使用する必要がありますが、セクション6.3の「タイマーの見直し」と「逆再考」のアルゴリズムを省略してもよい（MAY） 0.3、6.3.6および6.3.7。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To execute these rules, a session participant must maintain several pieces of state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのルールを実行するには、セッション参加者は状態のいくつかの部分を維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tp: the last time an RTCP packet was transmitted;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TP：RTCPパケットが送信された最後の時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tc: the current time;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TC：現在の時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tn: the next scheduled transmission time of an RTCP packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TN：RTCPパケットの次の送信予定時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pmembers: the estimated number of session members at the time tn was last recomputed;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pmembers：最後に再計算された時刻tnでのセッションメンバーの推定数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
members: the most current estimate for the number of session members;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メンバー：セッションメンバーの数の最も現在の推定値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
senders: the most current estimate for the number of senders in the session;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者：セッション内の送信者数の最も現在の推定値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rtcp_bw: The target RTCP bandwidth, i.e., the total bandwidth that will be used for RTCP packets by all members of this session, in octets per second. This will be a specified fraction of the &#34;session bandwidth&#34; parameter supplied to the application at startup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rtcp_bw：ターゲットRTCP帯域幅、すなわち、毎秒のオクテットで、このセッションのすべてのメンバーによってRTCPパケットのために使用される総帯域幅。これは、起動時にアプリケーションに供給された「セッション帯域幅」パラメータの指定された割合になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
we_sent: Flag that is true if the application has sent data since the 2nd previous RTCP report was transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
we_sent：第2回前のRTCPレポートを送信してから、アプリケーションがデータを送信した場合にtrueとなるフラグです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
avg_rtcp_size: The average compound RTCP packet size, in octets, over all RTCP packets sent and received by this participant. The size includes lower-layer transport and network protocol headers (e.g., UDP and IP) as explained in Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
avg_rtcp_size：平均複合RTCPパケットサイズ、オクテットでは、すべてのRTCPパケットの上にこの参加者によって送受信されます。セクション6.2で説明したように大きさが下層のトランスポート及びネットワークプロトコルヘッダ（例えば、UDPおよびIP）を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initial: Flag that is true if the application has not yet sent an RTCP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期：アプリケーションがまだRTCPパケットを送信していない場合にtrueとなるフラグです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many of these rules make use of the &#34;calculated interval&#34; between packet transmissions. This interval is described in the following section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのルールの多くは、パケットの送信間の「計算期間」を利用します。この間隔は、次のセクションで説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1 Computing the RTCP Transmission Interval
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
RTCP送信間隔を計算6.3.1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To maintain scalability, the average interval between packets from a session participant should scale with the group size. This interval is called the calculated interval. It is obtained by combining a number of the pieces of state described above. The calculated interval T is then determined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スケーラビリティを維持するために、セッションの参加者からのパケット間の平均間隔は、グループサイズでスケーリングすべきです。この間隔は、計算間隔と呼ばれています。なお、上述した状態の個数を組み合わせることによって得られます。以下のように計算間隔Tが決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the number of senders is less than or equal to 25% of the membership (members), the interval depends on whether the participant is a sender or not (based on the value of we_sent). If the participant is a sender (we_sent true), the constant C is set to the average RTCP packet size (avg_rtcp_size) divided by 25% of the RTCP bandwidth (rtcp_bw), and the constant n is set to the number of senders. If we_sent is not true, the constant C is set to the average RTCP packet size divided by 75% of the RTCP bandwidth. The constant n is set to the number of receivers (members - senders). If the number of senders is greater than 25%, senders and receivers are treated together. The constant C is set to the average RTCP packet size divided by the total RTCP bandwidth and n is set to the total number of members. As stated in Section 6.2, an RTP profile MAY specify that the RTCP bandwidth may be explicitly defined by two separate parameters (call them S and R) for those participants which are senders and those which are not. In that case, the 25% fraction becomes S/(S+R) and the 75% fraction becomes R/(S+R). Note that if R is zero, the percentage of senders is never greater than S/(S+R), and the implementation must avoid division by zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.送信者の数がより少ないまたはメンバーシップ（メンバー）の25％に等しい場合、間隔は、参加者が（we_sentの値に基づいて）、送信者であるか否かに依存します。参加者は、送信者（真we_sent）である場合、定数Cは、RTCP帯域幅（rtcp_bw）の25％で割った平均RTCPパケットサイズ（avg_rtcp_size）に設定され、定数Nが送信者の数に設定されています。 we_sentが真でない場合、定数Cは、RTCP帯域幅の75％で割った平均RTCPパケットサイズに設定されています。 （ - 送信者メンバー）定数nは、受信機の数に設定されています。送信者の数が25％より大きい場合、送信側と受信側が一緒に処理されます。定数Cは、総RTCP帯域幅で割った平均RTCPパケットサイズに設定され、nはメンバーの合計数に設定されています。セクション6.2で述べたように、RTPプロファイルは、RTCP帯域幅が明示的に送信者とされていないものであり、これらの参加者のための2つの別々のパラメータ（S及びRそれらを呼び出す）によって定義されることを指定してもよいです。その場合、25％の画分は、S /（S + R）になり、75％フラクションはR /（S + R）となります。 Rがゼロである場合、送信者の割合は、S /（S + R）よりも大きくなることはありません、そして、実装は、ゼロによる除算を回避しなければならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the participant has not yet sent an RTCP packet (the variable initial is true), the constant Tmin is set to 2.5 seconds, else it is set to 5 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.参加者がまだ（変数の初期が真である）RTCPパケットを送信していない場合は、定数Tminのは、それが5秒に設定されている他の2.5秒に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The deterministic calculated interval Td is set to max(Tmin, n*C).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.決定論的計算された間隔Tdが最大値（Tminを、N * C）に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The calculated interval T is set to a number uniformly distributed between 0.5 and 1.5 times the deterministic calculated interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.計算間隔Tを均一に0.5および1.5倍の決定的計算さインターバルの間に分布数に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The resulting value of T is divided by e-3/2=1.21828 to compensate for the fact that the timer reconsideration algorithm converges to a value of the RTCP bandwidth below the intended average.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Tの得られた値は、タイマ再考アルゴリズムは意図平均以下RTCP帯域幅の値に収束するという事実を補償するために、E-3/2 = 1.21828で除算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This procedure results in an interval which is random, but which, on average, gives at least 25% of the RTCP bandwidth to senders and the rest to receivers. If the senders constitute more than one quarter of the membership, this procedure splits the bandwidth equally among all participants, on average.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロシージャは、ランダムである区間での結果が、これは、平均して、送信側と受信側の残りの部分にRTCP帯域幅の少なくとも25％を与えます。送信者は、会員の4分の1以上を構成する場合は、この手順は、平均して、すべての参加者間で均等に帯域幅を分割します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2 Initialization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2初期化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon joining the session, the participant initializes tp to 0, tc to 0, senders to 0, pmembers to 1, members to 1, we_sent to false, rtcp_bw to the specified fraction of the session bandwidth, initial to true, and avg_rtcp_size to the probable size of the first RTCP packet that the application will later construct. The calculated interval T is then computed, and the first packet is scheduled for time tn = T. This means that a transmission timer is set which expires at time T. Note that an application MAY use any desired approach for implementing this timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションに参加すると、参加者が0にtcを、0にTPを初期化し、0に送信者、1にpmembers、1人のメンバー、falseにwe_sent、セッション帯域幅の指定された画分にrtcp_bw、trueに初期、およびにavg_rtcp_sizeアプリケーションは、後に構築する最初のRTCPパケットの予想サイズ。計算間隔Tが計算され、第1のパケットは、これは、送信タイマは、アプリケーションがこのタイマーを実装するための任意のアプローチを使用できること時間T注に期限切れになる設定されていることを意味する時刻tn = T.に予定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The participant adds its own SSRC to the member table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者はメンバー表に、自身のSSRCを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3 Receiving an RTP or Non-BYE RTCP Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
RTPまたは非BYE RTCPパケットを受信した6.3.3
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an RTP or RTCP packet is received from a participant whose SSRC is not in the member table, the SSRC is added to the table, and the value for members is updated once the participant has been validated as described in Section 6.2.1. The same processing occurs for each CSRC in a validated RTP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPまたはRTCPパケットがそのSSRCメンバテーブルにない参加者から受信した場合、SSRCは、テーブルに追加され、セクション6.2.1に記載のように参加者が検証された後のメンバーの値が更新されます。同様の処理が検証RTPパケットに各CSRCのために起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an RTP packet is received from a participant whose SSRC is not in the sender table, the SSRC is added to the table, and the value for senders is updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPパケットは、その送信者SSRCテーブルにない参加者から受信した場合、SSRCは、テーブルに追加され、送信者の値が更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each compound RTCP packet received, the value of avg_rtcp_size is updated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケットを受信した各化合物について、avg_rtcp_sizeの値が更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
avg_rtcp_size = (1/16) * packet_size + (15/16) * avg_rtcp_size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
avg_rtcp_size =（1/16）* PACKET_SIZE +（15/16）* avg_rtcp_size
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where packet_size is the size of the RTCP packet just received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PACKET_SIZEは、RTCPパケットのサイズは、ちょうど受信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4 Receiving an RTCP BYE Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
RTCP BYEパケットを受信した6.3.4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except as described in Section 6.3.7 for the case when an RTCP BYE is to be transmitted, if the received packet is an RTCP BYE packet, the SSRC is checked against the member table. If present, the entry is removed from the table, and the value for members is updated. The SSRC is then checked against the sender table. If present, the entry is removed from the table, and the value for senders is updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したパケットがRTCP BYEパケットである場合にRTCP BYEが送信される場合については、セクション6.3.7に記載されている場合を除き、SSRCは、メンバテーブルに対してチェックされます。存在する場合、エントリはテーブルから削除され、メンバーの値が更新されます。 SSRCは、送信元テーブルに対してチェックされます。存在する場合、エントリはテーブルから削除され、送信者の値が更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, to make the transmission rate of RTCP packets more adaptive to changes in group membership, the following &#34;reverse reconsideration&#34; algorithm SHOULD be executed when a BYE packet is received that reduces members to a value less than pmembers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYEパケットを受信した場合、さらに、グループメンバーシップの変化に、より適応RTCPパケットの伝送レートを製造するために、以下の「逆再考」アルゴリズムはpmembersよりも小さい値にメンバーを減少させることを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value for tn is updated according to the following formula:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TNの値は、次の式に従って更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
tn = tc + (members/pmembers) * (tn - tc)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
TN = TC +（メンバー/ pmembers）*（TN  -  TC）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value for tp is updated according the following formula:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TPの値は、次の式に従って更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
tp = tc - (members/pmembers) * (tc - tp).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
TP = TC  - （メンバー/ pmembers）*（TC  -  TP）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The next RTCP packet is rescheduled for transmission at time tn, which is now earlier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O次のRTCPパケットについて早い時刻tn、での送信のために再スケジュールされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value of pmembers is set equal to members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O pmembersの値がメンバーに等しく設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm does not prevent the group size estimate from incorrectly dropping to zero for a short time due to premature timeouts when most participants of a large session leave at once but some remain. The algorithm does make the estimate return to the correct value more rapidly. This situation is unusual enough and the consequences are sufficiently harmless that this problem is deemed only a secondary concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、大規模なセッションのほとんどの参加者が一度に残すが、一部が残っている時に誤っによる早すぎるタイムアウトに短時間ゼロに落下からグループサイズの見積もりを防ぐことはできません。このアルゴリズムは、より迅速に正しい値に推定リターンを作りません。この状況は十分に珍しいと結果は、この問題は二の次とみなされることを十分に無害です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.5 Timing Out an SSRC
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.5タイムアウトSSRC
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At occasional intervals, the participant MUST check to see if any of the other participants time out. To do this, the participant computes the deterministic (without the randomization factor) calculated interval Td for a receiver, that is, with we_sent false. Any other session member who has not sent an RTP or RTCP packet since time tc - MTd (M is the timeout multiplier, and defaults to 5) is timed out. This means that its SSRC is removed from the member list, and members is updated. A similar check is performed on the sender list. Any member on the sender list who has not sent an RTP packet since time tc - 2T (within the last two RTCP report intervals) is removed from the sender list, and senders is updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時折間隔で、参加者は他の参加者のいずれかがタイムアウトするかどうかを確認するためにチェックしなければなりません。これを行うには、参加者が受信する間隔Tdの計算（ランダム係数なしで）決定論を計算し、それがwe_sent偽で、です。時刻tc以降RTPまたはRTCPパケットを送信していない他のセッションメンバー -  MTdに（Mはタイムアウト乗数であり、そして5デフォルト）タイムアウトします。これは、そのSSRCは、メンバーリストから削除され、メンバーは更新されていることを意味します。同様のチェックが送信者リスト上で行われます。時間tcので、RTPパケットを送信していない送信者リスト上の任意のメンバー -  2T（最後の二つのRTCPレポート間隔内）は、送信者リストから削除され、送信者が更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If any members time out, the reverse reconsideration algorithm described in Section 6.3.4 SHOULD be performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どんなメンバーがタイムアウトする場合は、6.3.4項で説明した逆再考アルゴリズムを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The participant MUST perform this check at least once per RTCP transmission interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者は、RTCP送信間隔ごとに少なくとも一度は、このチェックを実行しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.6 Expiration of Transmission Timer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
送信タイマーの有効期限6.3.6
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the packet transmission timer expires, the participant performs the following operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット送信タイマーが満了すると、参加者は、次の操作を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The transmission interval T is computed as described in Section 6.3.1, including the randomization factor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダム化因子を含む、セクション6.3.1に記載したように、O送信間隔Tが計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If tp + T is less than or equal to tc, an RTCP packet is transmitted. tp is set to tc, then another value for T is calculated as in the previous step and tn is set to tc + T. The transmission timer is set to expire again at time tn. If tp + T is greater than tc, tn is set to tp + T. No RTCP packet is transmitted. The transmission timer is set to expire at time tn.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TP + Tが以下TCに等しい場合、O、RTCPパケットが送信されます。 TPは、TCに設定され、次いで、Tのための別の値は、前のステップとテネシー州のように計算される送信タイマが時間tnで再び有効期限が切れるように設定されたTC + Tに設定されています。 TP + TがTcよりも大きい場合、TNは、TPに設定されている+ T.なしRTCPパケットが送信されます。送信タイマは、時間tnで期限が切れるように設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o pmembers is set to members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O pmembersはメンバーに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an RTCP packet is transmitted, the value of initial is set to FALSE. Furthermore, the value of avg_rtcp_size is updated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケットが送信されている場合は、初期の値がFALSEに設定されています。さらに、avg_rtcp_sizeの値が更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
avg_rtcp_size = (1/16) * packet_size + (15/16) * avg_rtcp_size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
avg_rtcp_size =（1/16）* PACKET_SIZE +（15/16）* avg_rtcp_size
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where packet_size is the size of the RTCP packet just transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PACKET_SIZEは、RTCPパケットのサイズは、単に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.7 Transmitting a BYE Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
BYEパケットを送信する6.3.7
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a participant wishes to leave a session, a BYE packet is transmitted to inform the other participants of the event. In order to avoid a flood of BYE packets when many participants leave the system, a participant MUST execute the following algorithm if the number of members is more than 50 when the participant chooses to leave. This algorithm usurps the normal role of the members variable to count BYE packets instead:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者がセッションを終了したい場合、BYEパケットは、イベントの他の参加者に通知するために送信されます。参加者が残すことを選択したときにメンバーの数が50以上であれば、多くの参加者がシステムを離れる際にBYEパケットの洪水を避けるために、参加者は次のアルゴリズムを実行する必要があります。このアルゴリズムは、代わりにBYEパケットをカウントする変数メンバーの正常な役割を横取り：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the participant decides to leave the system, tp is reset to tc, the current time, members and pmembers are initialized to 1, initial is set to 1, we_sent is set to false, senders is set to 0, and avg_rtcp_size is set to the size of the compound BYE packet. The calculated interval T is computed. The BYE packet is then scheduled for time tn = tc + T.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者がシステムを残すことを決定した場合、O、TPは、現在の時刻をTCにリセットされ、メンバーとpmembersが1に初期化され、初期は1に設定されている、we_sentがfalseに設定されているが、送信者は0に設定され、avg_rtcp_sizeが設定されています複合BYEパケットのサイズに。計算間隔Tが計算されます。 BYEパケットは、その後、時間tn = TC + T.に予定されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Every time a BYE packet from another participant is received, members is incremented by 1 regardless of whether that participant exists in the member table or not, and when SSRC sampling is in use, regardless of whether or not the BYE SSRC would be included in the sample. members is NOT incremented when other RTCP packets or RTP packets are received, but only for BYE packets. Similarly, avg_rtcp_size is updated only for received BYE packets. senders is NOT updated when RTP packets arrive; it remains 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O別の参加者からBYEパケットを受信するたびに、メンバーにかかわらず、その参加者が会員テーブルに存在するか否かの1だけインクリメントされ、及びSSRCサンプリングに関係なくBYE SSRCはで含まれることになるか否かを、使用時標本、見本。メンバーは他のRTCPパケットまたはRTPパケットを受信したときにインクリメントが、唯一のBYEパケットのためではありません。同様に、avg_rtcp_sizeは受信BYEパケットに対してのみ更新されます。 RTPパケットが到着したとき、送信者は更新されません。それは0のまま。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Transmission of the BYE packet then follows the rules for transmitting a regular RTCP packet, as above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O BYEパケットの送信は、次に、上記のように、定期的なRTCPパケットを送信するためのルールに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This allows BYE packets to be sent right away, yet controls their total bandwidth usage. In the worst case, this could cause RTCP control packets to use twice the bandwidth as normal (10%) -- 5% for non-BYE RTCP packets and 5% for BYE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、BYEパケットをすぐに送信することを可能にする、まだ彼らの総帯域幅の使用を制御します。非BYE RTCPパケットのための5％とBYE 5％を - 最悪の場合、これは、RTCP制御パケットが（10％）、通常の倍の帯域幅を使用する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A participant that does not want to wait for the above mechanism to allow transmission of a BYE packet MAY leave the group without sending a BYE at all. That participant will eventually be timed out by the other group members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてでBYEを送信せずにグループを離れることができるBYEパケットの伝送を可能にするために、上記のメカニズムを待ちたくない参加者。その参加者は最終的に他のグループメンバーによってタイムアウトされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the group size estimate members is less than 50 when the participant decides to leave, the participant MAY send a BYE packet immediately. Alternatively, the participant MAY choose to execute the above BYE backoff algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者が残すことを決定したときに、グループサイズの見積もりの​​メンバーが50未満の場合、参加者はすぐにBYEパケットを送信することができます。また、参加者は、上記BYEのバックオフアルゴリズムを実行することを選択するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In either case, a participant which never sent an RTP or RTCP packet MUST NOT send a BYE packet when they leave the group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らはグループを離れる際にいずれの場合も、RTPまたはRTCPパケットを送信されることはありません参加者はBYEパケットを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.8 Updating we_sent
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.8更新we_sent
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The variable we_sent contains true if the participant has sent an RTP packet recently, false otherwise. This determination is made by using the same mechanisms as for managing the set of other participants listed in the senders table. If the participant sends an RTP packet when we_sent is false, it adds itself to the sender table and sets we_sent to true. The reverse reconsideration algorithm described in Section 6.3.4 SHOULD be performed to possibly reduce the delay before sending an SR packet. Every time another RTP packet is sent, the time of transmission of that packet is maintained in the table. The normal sender timeout algorithm is then applied to the participant -- if an RTP packet has not been transmitted since time tc - 2T, the participant removes itself from the sender table, decrements the sender count, and sets we_sent to false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者は、そうでない場合はfalse、最近RTPパケットを送信した場合、変数we_sentは本当含まれています。この決意は、送信者テーブルにリストされている他の参加者の集合を管理するのと同じメカニズムを使用して行われます。 we_sentがfalseの場合、参加者は、RTPパケットを送信する場合は、送信者テーブルに自分自身を追加し、trueにwe_sentを設定します。セクション6.3.4に記載の逆再考アルゴリズムはおそらくSRパケットを送信する前に遅延を減少させるために行われるべきです。別のRTPパケットが送信されるたびに、そのパケットの送信時は表に維持されています。通常、送信者のタイムアウトアルゴリズムはその後、参加者に適用される -  RTPパケットが時刻tc以降に送信されていない場合 -  2T、参加者は、送信者テーブルから自身を削除し、送信者のカウントを減少し、falseにwe_sentを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.9 Allocation of Source Description Bandwidth
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ソース説明帯域幅の割り当て6.3.9
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines several source description (SDES) items in addition to the mandatory CNAME item, such as NAME (personal name) and EMAIL (email address). It also provides a means to define new application-specific RTCP packet types. Applications should exercise caution in allocating control bandwidth to this additional information because it will slow down the rate at which reception reports and CNAME are sent, thus impairing the performance of the protocol. It is RECOMMENDED that no more than 20% of the RTCP bandwidth allocated to a single participant be used to carry the additional information. Furthermore, it is not intended that all SDES items will be included in every application. Those that are included SHOULD be assigned a fraction of the bandwidth according to their utility. Rather than estimate these fractions dynamically, it is recommended that the percentages be translated statically into report interval counts based on the typical length of an item.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、名前（個人名）と電子メール（Eメールアドレス）などの必須のCNAME項目に加えて、いくつかのソース記述（SDES）アイテムを、定義します。また、新しいアプリケーション固有のRTCPパケットタイプを定義するための手段を提供します。それは、このように、プロトコルのパフォーマンスを損なう、受信レポートとCNAMEが送信される速度が遅くなりますので、アプリケーションはこの追加情報に制御帯域幅を割り当てるには注意が必要です。単一の参加者に割り当てられたRTCP帯域幅の20％以下は、追加情報を搬送するために使用することを推奨されています。さらに、すべてのSDES項目がすべてのアプリケーションに含まれることを意図していません。含まれているものは、その有用性に応じた帯域幅の一部を割り当てる必要があります。動的これらの画分を推定するのではなく、そのパーセンテージはアイテムの典型的な長さに基づいて、レポート間隔カウントに静的に翻訳されることが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, an application may be designed to send only CNAME, NAME and EMAIL and not any others. NAME might be given much higher priority than EMAIL because the NAME would be displayed continuously in the application&#39;s user interface, whereas EMAIL would be displayed only when requested. At every RTCP interval, an RR packet and an SDES packet with the CNAME item would be sent. For a small session operating at the minimum interval, that would be every 5 seconds on the average. Every third interval (15 seconds), one extra item would be included in the SDES packet. Seven out of eight times this would be the NAME item, and every eighth time (2 minutes) it would be the EMAIL item.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、アプリケーションは、CNAME、名前と電子メールとしない任意の他のものを送信するように設計されてもよいです。要求された場合にのみ電子メールが表示されるのに対し、NAMEは、アプリケーションのユーザーインターフェイスに連続して表示されるため、NAMEはEMAILよりもはるかに高い優先順位を与えている可能性があります。すべてのRTCP間隔で、CNAMEアイテムとRRパケットとSDESパケットが送信されます。最小間隔で動作する小型のセッションの場合、それが平均で5秒毎になります。すべての第3区間（15秒）、1つの余分のアイテムはSDESパケットに含まれることになります。七8回のうち、これはNAME項目、および8番目ごとの時間（2分）、それは電子メールアイテムになりますでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple applications operate in concert using cross-application binding through a common CNAME for each participant, for example in a multimedia conference composed of an RTP session for each medium, the additional SDES information MAY be sent in only one RTP session. The other sessions would carry only the CNAME item. In particular, this approach should be applied to the multiple sessions of a layered encoding scheme (see Section 2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のアプリケーションは、各参加者のために共通のCNAMEを介して結合クロスアプリケーションを使用して、協調して動作する場合、各メディアのためのRTPセッションからなるマルチメディア会議において、例えば、追加のSDES情報は、ただ1つのRTPセッションで送られてもよいです。他のセッションはCNAMEアイテムを運ぶでしょう。特に、このアプローチは、層状符号化方式の複数のセッションに適用すべきである（2.4節を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4 Sender and Receiver Reports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4 SenderとReceiverレポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP receivers provide reception quality feedback using RTCP report packets which may take one of two forms depending upon whether or not the receiver is also a sender. The only difference between the sender report (SR) and receiver report (RR) forms, besides the packet type code, is that the sender report includes a 20-byte sender information section for use by active senders. The SR is issued if a site has sent any data packets during the interval since issuing the last report or the previous one, otherwise the RR is issued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP受信機は、受信機も、送信者であるか否かに応じて2つの形式のいずれかをとることができるRTCPレポートパケットを用いて受信品質のフィードバックを提供します。送信者レポート（SR）とレシーバレポート（RR）の形態​​の唯一の違いは、パケット種別コードの他に、送信者レポートは、アクティブ送信者が使用するための20バイトの送信者情報部を含むことです。サイトには、それ以外のRRが発行され、最後のレポートまたは前のものを発行するので、期間中に任意のデータパケットを送信した場合SRが発行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the SR and RR forms include zero or more reception report blocks, one for each of the synchronization sources from which this receiver has received RTP data packets since the last report. Reports are not issued for contributing sources listed in the CSRC list. Each reception report block provides statistics about the data received from the particular source indicated in that block. Since a maximum of 31 reception report blocks will fit in an SR or RR packet, additional RR packets SHOULD be stacked after the initial SR or RR packet as needed to contain the reception reports for all sources heard during the interval since the last report. If there are too many sources to fit all the necessary RR packets into one compound RTCP packet without exceeding the MTU of the network path, then only the subset that will fit into one MTU SHOULD be included in each interval. The subsets SHOULD be selected round-robin across multiple intervals so that all sources are reported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方SRとRRの形態は、ゼロ以上の受信レポートブロック、この受信機は、最後のレポート以来、RTPデータパケットを受信し、そこから同期ソースごとに1つを含みます。レポートは、CSRCリストに記載されているソースを貢献するために発行されていません。各受信レポートブロックは、そのブロックに示されている特定のソースから受信したデータに関する統計情報を提供します。 31個の受信レポートブロックの最大値は、SRまたはRRパケットに収まるので、最後のレポート以降の期間中に聞いたすべてのソースの受信レポートが含まれているために、必要に応じて、追加のRRパケットは、最初のSRやRRパケットの後に積層されるべきです。ネットワーク経路のMTUを超えることなく、一つの化合物のRTCPパケットに必要なすべてのRRパケットに合うように、あまりにも多くのソースがある場合、1 MTUに収まるだけのサブセットは各区間に含まれるべきです。すべてのソースが報告されているように、サブセットは、複数の間隔を横切ってラウンドロビン方式を選択すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next sections define the formats of the two reports, how they may be extended in a profile-specific manner if an application requires additional feedback information, and how the reports may be used. Details of reception reporting by translators and mixers is given in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、アプリケーションが追加のフィードバック情報を必要とし、どのようにレポートを使用することができる場合、彼らは、プロファイル固有の方法で拡張することができる方法を、2つのレポートのフォーマットを定義します。翻訳者とミキサーで報告受信の詳細については、セクション7に与えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1 SR: Sender Report RTCP Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1 SR：送信者レポートRTCPパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ header |V=2|P| RC | PT=SR=200 | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SSRC of sender | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ sender | NTP timestamp, most significant word | info +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | NTP timestamp, least significant word | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | RTP timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | sender&#39;s packet count | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | sender&#39;s octet count | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ report | SSRC_1 (SSRC of first source) | block +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 1 | fraction lost | cumulative number of packets lost | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | extended highest sequence number received | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | interarrival jitter | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | last SR (LSR) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | delay since last SR (DLSR) | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ report | SSRC_2 (SSRC of second source) | block +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 2 : ... : +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | profile-specific extensions | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +ヘッダ| V = 2 | P | RC | PT = SR = 200 |長さ| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |送信者のSSRC | + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +差出人| NTPタイムスタンプ、最上位ワード|情報+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | NTPタイムスタンプ、最下位ワード| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | RTPタイムスタンプ| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |送信者のパケット数| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |送信者のオクテット数| + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +レポート| SSRC_1（最初のソースのSSRC）|ブロック+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + 1 |喪失分|失われたパケットの累積数| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | |拡張シーケンス番号が最大受信+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | interarrivalジッタ| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |最後のSR（LSR）| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |最後のSR（DLSR）以来の遅延| + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +レポート| SSRC_2（第2のソースのSSRC）|ブロック+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + 2：...：+ = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + |プロファイル固有の拡張機能| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sender report packet consists of three sections, possibly followed by a fourth profile-specific extension section if defined. The first section, the header, is 8 octets long. The fields have the following meaning:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者レポートパケットは、定義されている場合、おそらく第プロファイル固有の拡張部に続く3つのセクションから構成されています。最初のセクション、ヘッダは、8つのオクテットの長さです。各フィールドの意味は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version (V): 2 bits Identifies the version of RTP, which is the same in RTCP packets as in RTP data packets. The version defined by this specification is two (2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョン（V）：2ビットは、RTPデータパケットとRTCPパケットで同じであるRTPのバージョンを識別します。この仕様で定義されたバージョンは、2つ（2）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding (P): 1 bit If the padding bit is set, this individual RTCP packet contains some additional padding octets at the end which are not part of the control information but are included in the length field. The last octet of the padding is a count of how many padding octets should be ignored, including itself (it will be a multiple of four). Padding may be needed by some encryption algorithms with fixed block sizes. In a compound RTCP packet, padding is only required on one individual packet because the compound packet is encrypted as a whole for the method in Section 9.1. Thus, padding MUST only be added to the last individual packet, and if padding is added to that packet, the padding bit MUST be set only on that packet. This convention aids the header validity checks described in Appendix A.2 and allows detection of packets from some early implementations that incorrectly set the padding bit on the first individual packet and add padding to the last individual packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディング（P）：パディングビットがセットされている場合は1ビットは、この個々のRTCPパケットは、制御情報の一部ではなく、長さフィールドに含まれている端部にいくつかの追加のパディングオクテットを含んでいます。パディングの最後のオクテットは、オクテットが（それは4の倍数になります）自体を含め、無視されるべきであるどのように多くのパディングの数です。パディングは、固定ブロックサイズでいくつかの暗号化アルゴリズムによって必要とすることができます。複合パケットは、セクション9.1での方法のため、全体として暗号化されるため、複合RTCPパケットでは、パディングが唯一の個々のパケットに必要とされます。従って、パディングは最後の個々のパケットに追加する必要があり、パディングがそのパケットに付加されている場合、パディングビットは、そのパケットに設定されなければなりません。この規則は、付録A.2に記載ヘッダ妥当性確認を助け、誤って第一の個別のパケットにパディングビットを設定し、最後に個々のパケットにパディングを追加し、いくつかの初期の実装からのパケットの検出を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
reception report count (RC): 5 bits The number of reception report blocks contained in this packet. A value of zero is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信レポートカウント（RC）：このパケットに含まれる受信レポートブロックの5ビット数。ゼロの値が有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packet type (PT): 8 bits Contains the constant 200 to identify this as an RTCP SR packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットタイプ（PT）：8ビットのRTCP SRパケットとしてこれを識別するための定数200を含み。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length: 16 bits The length of this RTCP packet in 32-bit words minus one, including the header and any padding. (The offset of one makes zero a valid length and avoids a possible infinite loop in scanning a compound RTCP packet, while counting 32-bit words avoids a validity check for a multiple of 4.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ：ヘッダおよびパディングを含む、16ビット、32ビット・ワードで、このRTCPパケットの長さから1を引きました。 （一方のオフセットはゼロで有効な長さになると、化合物RTCPパケットをスキャンで可能無限ループを回避する32ビット・ワードをカウントしながら4の倍数のための妥当性チェックを回避します）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSRC: 32 bits The synchronization source identifier for the originator of this SR packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSRC：このSRパケットの発信のために32ビットの同期ソース識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second section, the sender information, is 20 octets long and is present in every sender report packet. It summarizes the data transmissions from this sender. The fields have the following meaning:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二節、送信者情報は、20オクテット長であり、すべての送信者レポートパケットに存在しています。これは、この送信者からのデータ送信をまとめました。各フィールドの意味は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NTP timestamp: 64 bits Indicates the wallclock time (see Section 4) when this report was sent so that it may be used in combination with timestamps returned in reception reports from other receivers to measure round-trip propagation to those receivers. Receivers should expect that the measurement accuracy of the timestamp may be limited to far less than the resolution of the NTP timestamp. The measurement uncertainty of the timestamp is not indicated as it may not be known. On a system that has no notion of wallclock time but does have some system-specific clock such as &#34;system uptime&#34;, a sender MAY use that clock as a reference to calculate relative NTP timestamps. It is important to choose a commonly used clock so that if separate implementations are used to produce the individual streams of a multimedia session, all implementations will use the same clock. Until the year 2036, relative and absolute timestamps will differ in the high bit so (invalid) comparisons will show a large difference; by then one hopes relative timestamps will no longer be needed. A sender that has no notion of wallclock or elapsed time MAY set the NTP timestamp to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NTPタイムスタンプ：64ビットは、それがそれらの受信機への往復伝搬を測定するために、他の受信機からの受信レポートに返されたタイムスタンプと組み合わせて使用​​することができるように、この報告書が送信された壁時計の時間を（セクション4を参照）を示します。レシーバは、タイムスタンプの測定精度は、NTPタイムスタンプの解像度よりもはるかに少ないに制限することができることを期待してください。それは知られていないかもしれないように、タイムスタンプの測定の不確かさが示されていません。壁時計時間の概念を持っていないが、このような「システムの稼働時間」など、いくつかのシステム固有のクロックを持っているシステムでは、送信者は相対NTPタイムスタンプを計算するための基準として、そのクロックを使用するかもしれません。別の実装は、マルチメディアセッションの個々のストリームを生成するために使用されている場合は、すべての実装が同じクロックを使用するように一般的に使用されるクロックを選択することが重要です。 2036年までは、相対および絶対タイムスタンプは、非常に高いビットに異なることになる（無効）の比較は、大きな違いを示すであろう。それまでに1は、相対的なタイムスタンプがもはや必要ないことを期待しています。壁時計や経過時間の概念を持っていない送信者はゼロにNTPタイムスタンプを設定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP timestamp: 32 bits Corresponds to the same time as the NTP timestamp (above), but in the same units and with the same random offset as the RTP timestamps in data packets. This correspondence may be used for intra- and inter-media synchronization for sources whose NTP timestamps are synchronized, and may be used by media-independent receivers to estimate the nominal RTP clock frequency. Note that in most cases this timestamp will not be equal to the RTP timestamp in any adjacent data packet. Rather, it MUST be calculated from the corresponding NTP timestamp using the relationship between the RTP timestamp counter and real time as maintained by periodically checking the wallclock time at a sampling instant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPタイムスタンプ：32ビットのNTPタイムスタンプ（上記）として、同じ単位で、データパケット内のRTPタイムスタンプとしてオフセット同じランダムと同じ時間に対応します。この対応は、NTPタイムスタンプ同期化され、公称RTPクロック周波数を推定するためにメディア独立型受信機によって使用され得るソースのイントラおよびインターメディア同期のために使用することができます。ほとんどの場合、このタイムスタンプは、任意の隣接するデータパケット内のRTPタイムスタンプに等しいことはないことに注意してください。定期的にサンプリング時点でのウォールクロック時間をチェックすることによって維持されるようむしろ、RTPタイムスタンプカウンタと実時間との関係を用いて、対応するNTPタイムスタンプから計算されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sender&#39;s packet count: 32 bits The total number of RTP data packets transmitted by the sender since starting transmission up until the time this SR packet was generated. The count SHOULD be reset if the sender changes its SSRC identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信側のパケットカウント：このSRパケットが生成された時刻まで送信を開始してから、送信者によって送信されたRTPデータパケットの32ビットの合計数。送信者がそのSSRC識別子を変更した場合、カウントをリセットする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sender&#39;s octet count: 32 bits The total number of payload octets (i.e., not including header or padding) transmitted in RTP data packets by the sender since starting transmission up until the time this SR packet was generated. The count SHOULD be reset if the sender changes its SSRC identifier. This field can be used to estimate the average payload data rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者のオクテット数（すなわち、ヘッダやパディングを含まない）ペイロードのオクテットの32ビット総数このSRパケットが生成された時刻まで送信を起動するため、送信者によってRTPデータパケットで送信されます。送信者がそのSSRC識別子を変更した場合、カウントをリセットする必要があります。このフィールドは、平均的なペイロードデータレートを推定するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third section contains zero or more reception report blocks depending on the number of other sources heard by this sender since the last report. Each reception report block conveys statistics on the reception of RTP packets from a single synchronization source. Receivers SHOULD NOT carry over statistics when a source changes its SSRC identifier due to a collision. These statistics are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第3のセクションは、最後の報告以降、この送信者が聞いた他の情報源の数に応じて、ゼロまたはそれ以上の受信レポートブロックを含みます。各受信レポートブロックは、単一の同期ソースからのRTPパケットの受信に関する統計情報を伝えます。ソースが衝突によりそのSSRC識別子を変更したときに受信機は、統計上で実行すべきではありません。これらの統計は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSRC_n (source identifier): 32 bits The SSRC identifier of the source to which the information in this reception report block pertains.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSRC_n（ソース識別子）：32ビットこの受信レポートブロックが関連の情報ソースのSSRC識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fraction lost: 8 bits The fraction of RTP data packets from source SSRC_n lost since the previous SR or RR packet was sent, expressed as a fixed point number with the binary point at the left edge of the field. (That is equivalent to taking the integer part after multiplying the loss fraction by 256.) This fraction is defined to be the number of packets lost divided by the number of packets expected, as defined in the next paragraph. An implementation is shown in Appendix A.3. If the loss is negative due to duplicates, the fraction lost is set to zero. Note that a receiver cannot tell whether any packets were lost after the last one received, and that there will be no reception report block issued for a source if all packets from that source sent during the last reporting interval have been lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
画分失わ：ソースSSRC_nからRTPデータパケットの8ビットの画分は、前SRまたはRRパケットが送信されてから失われたフィールドの左端にバイナリ点を有する固定小数点数として表されます。次の段落で定義されるようにこの画分は、予想されるパケットの数で割った失われたパケットの数であると定義される（すなわち256により損失割合を乗算した後に整数部分をとることと等価です）。実装は、付録A.3に示されています。損失が原因重複する負の場合は、失われた割合はゼロに設定されています。受信機は、最後の1を受け取った後、すべてのパケットが失われたかどうかを伝えることができないこと、そして最後のレポート期間中に送信され、そのソースからのすべてのパケットが失われた場合は、ソースのために発行した全く受信レポートブロックがないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cumulative number of packets lost: 24 bits The total number of RTP data packets from source SSRC_n that have been lost since the beginning of reception. This number is defined to be the number of packets expected less the number of packets actually received, where the number of packets received includes any which are late or duplicates. Thus, packets that arrive late are not counted as lost, and the loss may be negative if there are duplicates. The number of packets expected is defined to be the extended last sequence number received, as defined next, less the initial sequence number received. This may be calculated as shown in Appendix A.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットの累積数は、失われた24ビットの受信の開始以来、失われたソースSSRC_nからRTPデータパケットの総数。この数は、パケットの数が遅いまたは重複であるいずれかを含む受信実際に受信したパケットのより少ない数を、予想されるパケットの数であると定義されます。このように、遅れて到着パケットが失われたとしてカウントされず、重複がある場合の損失は負であってもよいです。予想されるパケットの数が拡張最後のシーケンス番号であると定義される次の定義として、受信した、より少ない初期シーケンス番号は、受信されました。付録A.3に示すように、これは、計算することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extended highest sequence number received: 32 bits The low 16 bits contain the highest sequence number received in an RTP data packet from source SSRC_n, and the most significant 16 bits extend that sequence number with the corresponding count of sequence number cycles, which may be maintained according to the algorithm in Appendix A.1. Note that different receivers within the same session will generate different extensions to the sequence number if their start times differ significantly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビット下位16ビットは、ソースSSRC_nからRTPデータパケットで受信された最も高いシーケンス番号を含む、最上位16ビットを維持することができるシーケンス番号サイクルの対応するカウントとそのシーケンス番号を拡張：拡張最高シーケンス番号が受信します付録A.1でのアルゴリズムに従って。その開始時間が大幅に異なる場合、同一セッション内の異なる受信機は、シーケンス番号に異なる拡張子を生成することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
interarrival jitter: 32 bits An estimate of the statistical variance of the RTP data packet interarrival time, measured in timestamp units and expressed as an unsigned integer. The interarrival jitter J is defined to be the mean deviation (smoothed absolute value) of the difference D in packet spacing at the receiver compared to the sender for a pair of packets. As shown in the equation below, this is equivalent to the difference in the &#34;relative transit time&#34; for the two packets; the relative transit time is the difference between a packet&#39;s RTP timestamp and the receiver&#39;s clock at the time of arrival, measured in the same units.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
到着間ジッタ：32ビットRTPデータパケット到着間隔時間の統計的分散の推定値は、タイムスタンプ単位で測定され、符号なし整数として表さ。到着間ジッタJはパケットの一対の送信者と比較して、受信機におけるパケット間隔の差Dの平均偏差（平滑化された絶対値）であると定義されます。以下の式に示すように、これは、二つのパケットの「相対通過時間」の差に相当します。相対通過時間はパケットのRTPタイムスタンプと同じ単位で測定された到着時に受信機のクロックとの間の差です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If Si is the RTP timestamp from packet i, and Ri is the time of arrival in RTP timestamp units for packet i, then for two packets i and j, D may be expressed as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SiはiはパケットからRTPタイムスタンプであり、Riは、パケットのためのRTPタイムスタンプ単位で到着時刻である場合、私は、2つのパケットi及びjについて、Dは、のように表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
D(i,j) = (Rj - Ri) - (Sj - Si) = (Rj - Sj) - (Ri - Si)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
D（i、j）は=（RJ  -  RI） - （SJ  - シリコン）=（RJ  -  SJ） - （RI  -  Si）の
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The interarrival jitter SHOULD be calculated continuously as each data packet i is received from source SSRC_n, using this difference D for that packet and the previous packet i-1 in order of arrival (not necessarily in sequence), according to the formula
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
到着間ジッタは、式に従って、そのパケットのためにこの差Dと到着の順序で前のパケットI-1（必ずしも配列中）を用いて、私はソースSSRC_nから受信される各データ・パケットとして連続的に計算されるべきです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
J(i) = J(i-1) + (|D(i-1,i)| - J(i-1))/16
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
J（I）= J（I-1）+（| D（I-1、I）|  -  J（I-1））/ 16
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Whenever a reception report is issued, the current value of J is sampled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
受信レポートが発行されるたび、Jの電流値がサンプリングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The jitter calculation MUST conform to the formula specified here in order to allow profile-independent monitors to make valid interpretations of reports coming from different implementations. This algorithm is the optimal first-order estimator and the gain parameter 1/16 gives a good noise reduction ratio while maintaining a reasonable rate of convergence [22]. A sample implementation is shown in Appendix A.8. See Section 6.4.4 for a discussion of the effects of varying packet duration and delay before transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ジッタ計算が異なる実装からのレポートの有効な解釈をするために、プロファイルに依存しないのモニターを可能にするために、ここで指定した式に従わなければなりません。このアルゴリズムは、最適な一次推定であり、収束[22]の合理的な速度を維持しつつ、ゲインパラメータ1/16は、良好なノイズ低減率を与えます。サンプル実装は、付録A.8に示されています。送信前にパケット持続時間と遅延の変化の影響についての議論については、セクション6.4.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
last SR timestamp (LSR): 32 bits The middle 32 bits out of 64 in the NTP timestamp (as explained in Section 4) received as part of the most recent RTCP sender report (SR) packet from source SSRC_n. If no SR has been received yet, the field is set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後SRタイムスタンプ（LSR）：（セクション4で説明したように）NTPタイムスタンプで64のうち32ビットの中間の32ビットは、ソースSSRC_nから最も最近のRTCP送信者レポート（SR）パケットの一部として受信しました。何のSRはまだ受信されていない場合、このフィールドはゼロに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
delay since last SR (DLSR): 32 bits The delay, expressed in units of 1/65536 seconds, between receiving the last SR packet from source SSRC_n and sending this reception report block. If no SR packet has been received yet from SSRC_n, the DLSR field is set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後のSR（DLSR）以来遅延：32ビット遅延は、ソースSSRC_nから最後のSRパケットを受信し、この受信レポートブロックを送信する間、1/65536秒の単位で表さ。何のSRパケットがSSRC_nからまだ受信されていない場合、DLSRフィールドはゼロに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Let SSRC_r denote the receiver issuing this receiver report. Source SSRC_n can compute the round-trip propagation delay to SSRC_r by recording the time A when this reception report block is received. It calculates the total round-trip time A-LSR using the last SR timestamp (LSR) field, and then subtracting this field to leave the round-trip propagation delay as (A - LSR - DLSR). This is illustrated in Fig. 2. Times are shown in both a hexadecimal representation of the 32-bit fields and the equivalent floating-point decimal representation. Colons indicate a 32-bit field divided into a 16-bit integer part and 16-bit fraction part.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SSRC_rは、この受信報告書を発行する受信機を表してみましょう。ソースSSRC_nは、この受信レポートブロックを受信したときに、時間Aを記録することによって、SSRC_rへの往復伝搬遅延時間を計算することができます。 （ -  LSR  -  DLSR A）には、最後のSRタイムスタンプ（LSR）フィールドを使用して、その後のような往復伝搬遅延を残すために、このフィールドを減算総往復時間A-LSRを算出します。これは、図2に示されている。2.時間は、32ビットフィールドの16進表現と等価な浮動小数点表現の両方に示されています。コロンは、16ビットの整数部と16ビットの小数部に分け、32ビットのフィールドを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This may be used as an approximate measure of distance to cluster receivers, although some links have very asymmetric delays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
一部のリンクは非常に非対称の遅れを持っているが、これは、クラスタの受信機までの距離の概算尺度として使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [10 Nov 1995 11:33:25.125 UTC]       [10 Nov 1995 11:33:36.5 UTC]
   n                 SR(n)              A=b710:8000 (46864.500 s)
   ----------------------------------------------------------------&gt;
                      v                 ^
   ntp_sec =0xb44db705 v               ^ dlsr=0x0005:4000 (    5.250s)
   ntp_frac=0x20000000  v             ^  lsr =0xb705:2000 (46853.125s)
     (3024992005.125 s)  v           ^
   r                      v         ^ RR(n)
   ----------------------------------------------------------------&gt;
                          |&lt;-DLSR-&gt;|
                           (5.250 s)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   A     0xb710:8000 (46864.500 s)
   DLSR -0x0005:4000 (    5.250 s)
   LSR  -0xb705:2000 (46853.125 s)
   -------------------------------
   delay 0x0006:2000 (    6.125 s)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Figure 2: Example for round-trip time computation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
図2：往復時間計算のための例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2 RR: Receiver Report RTCP Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2 RR：受信レポートRTCPパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ header |V=2|P| RC | PT=RR=201 | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SSRC of packet sender | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ report | SSRC_1 (SSRC of first source) | block +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 1 | fraction lost | cumulative number of packets lost | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | extended highest sequence number received | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | interarrival jitter | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | last SR (LSR) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | delay since last SR (DLSR) | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ report | SSRC_2 (SSRC of second source) | block +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 2 : ... : +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | profile-specific extensions | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +ヘッダ| V = 2 | P | RC | PT = RR = 201 |長さ| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |パケット送信者のSSRC | + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +レポート| SSRC_1（最初のソースのSSRC）|ブロック+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + 1 |喪失分|失われたパケットの累積数| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | |拡張シーケンス番号が最大受信+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | interarrivalジッタ| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |最後のSR（LSR）| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |最後のSR（DLSR）以来の遅延| + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +レポート| SSRC_2（第2のソースのSSRC）|ブロック+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + 2：...：+ = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + |プロファイル固有の拡張機能| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The format of the receiver report (RR) packet is the same as that of the SR packet except that the packet type field contains the constant 201 and the five words of sender information are omitted (these are the NTP and RTP timestamps and sender&#39;s packet and octet counts). The remaining fields have the same meaning as for the SR packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レシーバレポート（RR）パケットのフォーマットは、パケットタイプフィールドは、定数201と省略する発信者情報の5ワードが含まれていることを除いてSRパケット（これらはNTPおよびRTPタイムスタンプと送信者のパケットとのと同じですオクテット数）。残りのフィールドは、SRパケットの場合と同じ意味を持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An empty RR packet (RC = 0) MUST be put at the head of a compound RTCP packet when there is no data transmission or reception to report.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
報告するデータの送受信がない場合、空のRRパケット（RC = 0）は、化合物のRTCPパケットの先頭に置かれなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3 Extending the Sender and Receiver Reports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SenderとReceiverレポートの拡張6.4.3
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A profile SHOULD define profile-specific extensions to the sender report and receiver report if there is additional information that needs to be reported regularly about the sender or receivers. This method SHOULD be used in preference to defining another RTCP packet type because it requires less overhead:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者または受信機について定期的に報告する必要があり、追加情報がある場合、プロファイルは、送信者レポートおよび受信機レポートにプロファイル固有の拡張機能を定義する必要があります。それはより少ないオーバーヘッドを必要とするので、この方法は、別のRTCPパケットタイプを定義に優先して使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o fewer octets in the packet (no RTCP header or SSRC field); o simpler and faster parsing because applications running under that profile would be programmed to always expect the extension fields in the directly accessible location after the reception reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット（NO RTCPヘッダまたはSSRCフィールド）における少ないオクテットO。 Oそのプロファイルの下で実行しているアプリケーションは、常に受信レポートの後に直接アクセス可能な場所での拡張フィールドを期待するようにプログラムされるために簡単かつ迅速に解析。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The extension is a fourth section in the sender- or receiver-report packet which comes at the end after the reception report blocks, if any. If additional sender information is required, then for sender reports it would be included first in the extension section, but for receiver reports it would not be present. If information about receivers is to be included, that data SHOULD be structured as an array of blocks parallel to the existing array of reception report blocks; that is, the number of blocks would be indicated by the RC field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エクステンションがあれば、受信レポートブロック後の終わりに来るセンダまたはレシーバレポートパケット内の4番目のセクションです。追加の送信者情報が必要な場合は、送信者の報告のためには、最初の拡張セクションに含まれることになるが、受信レポートのためにそれは存在しないでしょう。受信機に関する情報が含まれる場合、ブロックのアレイは、受信レポートブロックの既存のアレイに平行に、そのデータが構造化されるべきです。つまり、ブロックの数はRCフィールドで示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.4 Analyzing Sender and Receiver Reports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.4分析SenderとReceiverレポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is expected that reception quality feedback will be useful not only for the sender but also for other receivers and third-party monitors. The sender may modify its transmissions based on the feedback; receivers can determine whether problems are local, regional or global; network managers may use profile-independent monitors that receive only the RTCP packets and not the corresponding RTP data packets to evaluate the performance of their networks for multicast distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信品質のフィードバックが送信者のためにだけでなく、他のレシーバとサードパーティのモニターのためだけでなく、有用であることが期待されます。送信者は、フィードバックに基づいてその送信を修正することができ、レシーバは問題は、地方、地域またはグローバルであるかどうかを判断することができます。ネットワーク管理者は、マルチキャスト配信のためにそれらのネットワークの性能を評価するだけRTCPパケットではなく、対応するRTPデータパケットを受信し、プロファイルに依存しないモニタを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cumulative counts are used in both the sender information and receiver report blocks so that differences may be calculated between any two reports to make measurements over both short and long time periods, and to provide resilience against the loss of a report. The difference between the last two reports received can be used to estimate the recent quality of the distribution. The NTP timestamp is included so that rates may be calculated from these differences over the interval between two reports. Since that timestamp is independent of the clock rate for the data encoding, it is possible to implement encoding- and profile-independent quality monitors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
違いは、両方の短期および長期の期間にわたって測定を行うために、任意の2つのレポートの間で計算することができる、と報告書の損失に対する回復力を提供するように、累積カウントは、送信者情報及び受信レポートブロックの両方で使用されています。受信した最後の2つのレポートの違いは、分布の最近の品質を推定するために使用することができます。料金は、2つのレポート間の間隔にわたるこれらの違いから計算することができるように、NTPタイムスタンプが含まれています。そのタイムスタンプは、データ符号化のためのクロックレートとは無関係であるので、encoding-プロファイルに依存しない品質の監視を実現することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example calculation is the packet loss rate over the interval between two reception reports. The difference in the cumulative number of packets lost gives the number lost during that interval. The difference in the extended last sequence numbers received gives the number of packets expected during the interval. The ratio of these two is the packet loss fraction over the interval. This ratio should equal the fraction lost field if the two reports are consecutive, but otherwise it may not. The loss rate per second can be obtained by dividing the loss fraction by the difference in NTP timestamps, expressed in seconds. The number of packets received is the number of packets expected minus the number lost. The number of packets expected may also be used to judge the statistical validity of any loss estimates. For example, 1 out of 5 packets lost has a lower significance than 200 out of 1000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
計算例は、2つの受信レポート間隔にわたるパケット損失率です。失われたパケットの累積数の差は、その期間中に失われた番号を与えます。受信された拡張最後のシーケンス番号の差がインターバル中に予想されるパケットの数を与えます。これら二つの比率は、間隔を超えるパケット損失割合です。 2つのレポートが連続している場合は、この比率は、小数失われたフィールドを等しくする必要がありますが、それ以外の場合はないかもしれません。秒あたりの損失率は、秒で表さNTPタイムスタンプの差によって損失割合を分割することにより得ることができます。受信したパケットの数は、予想されるパケットの数を引い失われた番号です。予想されるパケットの数はまた、任意の損失推定値の統計的妥当性を判断するために使用することができます。例えば、失われた5つのパケットのうち1 1000のうち200より低い重要性を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the sender information, a third-party monitor can calculate the average payload data rate and the average packet rate over an interval without receiving the data. Taking the ratio of the two gives the average payload size. If it can be assumed that packet loss is independent of packet size, then the number of packets received by a particular receiver times the average payload size (or the corresponding packet size) gives the apparent throughput available to that receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信元情報から、サードパーティのモニタはデータを受信せずに間隔にわたる平均ペイロードデータレートと平均パケットレートを算出することができます。両者の比をとると、平均ペイロードサイズを与えます。それはパケットロスがパケットサイズとは無関係であると仮定することができる場合には、特定の受信機時間平均ペイロードサイズ（または対応するパケットサイズ）によって受信されたパケットの数は、その受信機に利用可能な見かけのスループットを与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the cumulative counts which allow long-term packet loss measurements using differences between reports, the fraction lost field provides a short-term measurement from a single report. This becomes more important as the size of a session scales up enough that reception state information might not be kept for all receivers or the interval between reports becomes long enough that only one report might have been received from a particular receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レポートの違いを使用して、長期パケット損失測定を可能累積数に加えて、喪失分フィールドは、単一のレポートから、短期的な測定を提供します。セッションのサイズが十分にその受信状態情報は、すべての受信機のために保管されていないか、またはレポート間の間隔は、1つのレポートだけが、特定の受信機から受信された可能性があることを十分に長くなるスケールアップとして、これは、より重要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The interarrival jitter field provides a second short-term measure of network congestion. Packet loss tracks persistent congestion while the jitter measure tracks transient congestion. The jitter measure may indicate congestion before it leads to packet loss. The interarrival jitter field is only a snapshot of the jitter at the time of a report and is not intended to be taken quantitatively. Rather, it is intended for comparison across a number of reports from one receiver over time or from multiple receivers, e.g., within a single network, at the same time. To allow comparison across receivers, it is important the the jitter be calculated according to the same formula by all receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
到着間ジッタフィールドは、ネットワークの輻輳の第二の短期的尺度を提供します。ジッタ測定が一時混雑を追跡しながら、パケット損失は永続的な輻輳を追跡します。それはパケット損失につながる前に、ジッタ測定値は、輻輳を示すかもしれません。 interarrivalジッタフィールドは、レポートの時点でのジッタのスナップショットのみで、定量的に取られることを意図していません。むしろ、それは、例えば、単一ネットワーク内で、同時に、経時的な一つの受信機からのレポートの数を横切る比較のために、または複数の受信機から意図されています。受信機の両端の比較を可能にするためには、ジッタがすべての受信機によって同一の式に従って計算することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the jitter calculation is based on the RTP timestamp which represents the instant when the first data in the packet was sampled, any variation in the delay between that sampling instant and the time the packet is transmitted will affect the resulting jitter that is calculated. Such a variation in delay would occur for audio packets of varying duration. It will also occur for video encodings because the timestamp is the same for all the packets of one frame but those packets are not all transmitted at the same time. The variation in delay until transmission does reduce the accuracy of the jitter calculation as a measure of the behavior of the network by itself, but it is appropriate to include considering that the receiver buffer must accommodate it. When the jitter calculation is used as a comparative measure, the (constant) component due to variation in delay until transmission subtracts out so that a change in the network jitter component can then be observed unless it is relatively small. If the change is small, then it is likely to be inconsequential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジッタ計算がパケットの最初のデータがサンプリングされた瞬間を表しているRTPタイムスタンプに基づいているため、そのサンプリング時点とパケットが送信される時間との間の遅延の変動を算出し、得られたジッタに影響を与えます。遅延におけるそのような変化は、様々な持続時間のオーディオパケットのために発生します。タイムスタンプが一つのフレームのすべてのパケットに対して同じであるが、これらのパケットはすべて同じ時刻に送信されていないので、それはまた、ビデオエンコーディングのために発生します。送信までの遅延の変化は、それ自体によって、ネットワークの挙動の尺度としてジッタ計算の精度が低下し、受信バッファがそれを収容しなければならないことを考慮含めることが適切です。ジッタ計算を伴う遅延の変化に比較尺度、（定数）成分として使用する場合、送信は、それが比較的小さい場合を除き、ネットワークジッタ成分の変化は、その後に観察することができるように、アウト減算まで。変化が小さい場合、重要ではない可能性が高いです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5 SDES: Source Description RTCP Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5 SDES：ソース説明RTCPパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ header |V=2|P| SC | PT=SDES=202 | length | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ chunk | SSRC/CSRC_1 | 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SDES items | | ... | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ chunk | SSRC/CSRC_2 | 2 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SDES items | | ... | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +ヘッダ| V = 2 | P | SC | PT = SDES = 202 |長さ| + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +チャンク| SSRC / CSRC_1 | 1 +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | SDESアイテム| | ... | + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +チャンク| SSRC / CSRC_2 | 2 +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | SDESアイテム| | ... | + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SDES packet is a three-level structure composed of a header and zero or more chunks, each of which is composed of items describing the source identified in that chunk. The items are described individually in subsequent sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDESパケットは、そのチャンク内の識別されたソースを記述する項目で構成され、それぞれがヘッダと0個以上のチャンクから構成される3レベルの構造です。項目は、後続のセクションで個別に説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version (V), padding (P), length: As described for the SR packet (see Section 6.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョン（V）、パディング（P）、長さ：SRパケットに関して記載したように（セクション6.4.1参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packet type (PT): 8 bits Contains the constant 202 to identify this as an RTCP SDES packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットタイプ（PT）：8ビットは、RTCP SDESパケットとしてこれを識別するための定数202を含み。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
source count (SC): 5 bits The number of SSRC/CSRC chunks contained in this SDES packet. A value of zero is valid but useless.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソース・カウント（SC）：このSDESパケットに含まれるSSRC / CSRCチャンクの5ビット数。ゼロの値が有効ですが、無用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each chunk consists of an SSRC/CSRC identifier followed by a list of zero or more items, which carry information about the SSRC/CSRC. Each chunk starts on a 32-bit boundary. Each item consists of an 8- bit type field, an 8-bit octet count describing the length of the text (thus, not including this two-octet header), and the text itself. Note that the text can be no longer than 255 octets, but this is consistent with the need to limit RTCP bandwidth consumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各チャンクはSSRC / CSRC情報を運ぶ0個以上の項目のリストが続くSSRC / CSRC識別子から成ります。各チャンクは、32ビット境界で開始します。各項目は、8ビットのタイプ・フィールド（したがって、この2オクテットのヘッダを含まない）テキストの長さを記述し、8ビットオクテットカウント、およびテキスト自体から成ります。テキストが255オクテットより長くすることはできませんが、これはRTCP帯域幅の消費を制限する必要と一致していることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The text is encoded according to the UTF-8 encoding specified in RFC 2279 [5]. US-ASCII is a subset of this encoding and requires no additional encoding. The presence of multi-octet encodings is indicated by setting the most significant bit of a character to a value of one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テキストは、RFC 2279で指定されたUTF-8符号化に従って符号化されている[5]。 US-ASCIIはこのエンコーディングのサブセットであり、追加のエンコーディングを必要としません。マルチオクテット符号化の存在は、1の値に文字の最上位ビットをセットすることによって示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Items are contiguous, i.e., items are not individually padded to a 32-bit boundary. Text is not null terminated because some multi-octet encodings include null octets. The list of items in each chunk MUST be terminated by one or more null octets, the first of which is interpreted as an item type of zero to denote the end of the list. No length octet follows the null item type octet, but additional null octets MUST be included if needed to pad until the next 32-bit boundary. Note that this padding is separate from that indicated by the P bit in the RTCP header. A chunk with zero items (four null octets) is valid but useless.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アイテム、すなわち、アイテムを個別に32ビット境界に埋め込まれていない、連続しています。一部のマルチオクテットエンコーディングがヌルオクテットが含まれているため、テキストはnullで終了されていません。各チャンク内のアイテムのリストは、リストの終わりを示すためにゼロのアイテムタイプとして解釈される最初のうち1つまたは複数のヌルオクテットで終了する必要があります。いいえ長さオクテットはヌル項目タイプオクテットに続くないが、次の32ビット境界までパッドに必要に応じて追加のヌルオクテットを含まなければなりません。このパディングは、RTCPヘッダ内のPビットによって示されるものとは別であることに留意されたいです。ゼロのアイテム（4つのヌルオクテット）とのチャンクは有効ですが、無用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
End systems send one SDES packet containing their own source identifier (the same as the SSRC in the fixed RTP header). A mixer sends one SDES packet containing a chunk for each contributing source from which it is receiving SDES information, or multiple complete SDES packets in the format above if there are more than 31 such sources (see Section 7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドシステムは、独自のソース識別子（固定RTPヘッダーのSSRCと同じ）を含むものSDESパケットを送信します。ミキサーは31の以上、このようなソースは（セクション7を参照）がある場合、それは上記の形式でSDES情報、又は複数の完全SDESパケットを受信された各寄与ソースのチャンクを含むものSDESパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SDES items currently defined are described in the next sections. Only the CNAME item is mandatory. Some items shown here may be useful only for particular profiles, but the item types are all assigned from one common space to promote shared use and to simplify profile-independent applications. Additional items may be defined in a profile by registering the type numbers with IANA as described in Section 15.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在定義されているSDESアイテムは、次のセクションで説明されています。唯一のCNAME項目は必須です。ここに示されているいくつかの項目は、特定のプロファイルのために有用であるかもしれないが、アイテムの種類は、すべての共有利用を促進し、プロファイルに依存しないアプリケーションを簡素化するために一つの共通の空間から割り当てられます。追加項目は、セクション15で説明したようにIANAとタイプ番号を登録することで、プロファイルに定義されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1 CNAME: Canonical End-Point Identifier SDES Item
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1 CNAME：正規エンドポイント識別子SDESアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | CNAME=1 | length | user and domain name ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + | CNAME = 1 |長さ|ユーザー名とドメイン名... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CNAME identifier has the following properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CNAME識別子は、次のプロパティがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Because the randomly allocated SSRC identifier may change if a conflict is discovered or if a program is restarted, the CNAME item MUST be included to provide the binding from the SSRC identifier to an identifier for the source (sender or receiver) that remains constant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
競合が発見されるか、またはプログラムが再起動された場合、CNAMEアイテムが一定のままであるソース（送信者または受信者）の識別子にSSRC識別子からバインディングを提供するために含まなければならない場合、ランダムに割り当てられたSSRC識別子が変更される可能性がありますので、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Like the SSRC identifier, the CNAME identifier SHOULD also be unique among all participants within one RTP session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SSRC識別子と同様に、CNAME識別子はまた、1つのRTPセッション内のすべての参加者の間で一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To provide a binding across multiple media tools used by one participant in a set of related RTP sessions, the CNAME SHOULD be fixed for that participant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oは、関連するRTPセッションのセット内の1人の参加者によって使用される複数のメディアツール間の結合を提供するために、CNAMEは、その参加者のために固定されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To facilitate third-party monitoring, the CNAME SHOULD be suitable for either a program or a person to locate the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サードパーティの監視を容易にするためoは、CNAMEは、プログラム又はソースを検索する人のいずれかに適しているべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the CNAME SHOULD be derived algorithmically and not entered manually, when possible. To meet these requirements, the following format SHOULD be used unless a profile specifies an alternate syntax or semantics. The CNAME item SHOULD have the format &#34;user@host&#34;, or &#34;host&#34; if a user name is not available as on single-user systems. For both formats, &#34;host&#34; is either the fully qualified domain name of the host from which the real-time data originates, formatted according to the rules specified in RFC 1034 [6], RFC 1035 [7] and Section 2.1 of RFC 1123 [8]; or the standard ASCII representation of the host&#39;s numeric address on the interface used for the RTP communication. For example, the standard ASCII representation of an IP Version 4 address is &#34;dotted decimal&#34;, also known as dotted quad, and for IP Version 6, addresses are textually represented as groups of hexadecimal digits separated by colons (with variations as detailed in RFC 3513 [23]). Other address types are expected to have ASCII representations that are mutually unique. The fully qualified domain name is more convenient for a human observer and may avoid the need to send a NAME item in addition, but it may be difficult or impossible to obtain reliably in some operating environments. Applications that may be run in such environments SHOULD use the ASCII representation of the address instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、CNAMEのアルゴリズム導出されるべきであり、可能な場合、手動で入力されていません。プロファイルは、別の構文や意味論を指定しない限り、これらの要件を満たすために、次の形式を使用する必要があります。ユーザー名は、シングルユーザーシステム上として利用できない場合、CNAME項目がフォーマット「ユーザー@ホスト」、または「ホスト」を持っているべきです。両方の形式は、「ホスト」は、[6] RFC 1034で指定された規則に従ってフォーマットからリアルタイムデータ発信、ホストの完全修飾ドメイン名のいずれかである、RFC 1035 [7]及びRFC 1123の2.1節[8]。またはインターフェイス上のホストの数値アドレスの標準ASCII表現は、RTPの通信に使用されます。例えば、IPバージョンの標準ASCII表現は、4つのアドレスも点線クワッドとしても知られている「ドット十進」であり、IPバージョン6のために、アドレスがテキストでRFCに詳述するように変形して（コロンで区切られた16進数のグループとして表され3513 [23]）。他のアドレスタイプが相互に一意であるASCII表現を有することが期待されます。完全修飾ドメイン名は、人間の観察者にとってより便利で、加えて、NAME項目を送信する必要性を回避することができるが、いくつかの操作環境で確実に得ることが困難または不可能かもしれません。そのような環境で実行することができるアプリケーションは、代わりにアドレスのASCII表現を使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Examples are &#34;doe@sleepy.example.com&#34;, &#34;doe@192.0.2.89&#34; or &#34;doe@2201:056D::112E:144A:1E24&#34; for a multi-user system. On a system with no user name, examples would be &#34;sleepy.example.com&#34;, &#34;192.0.2.89&#34; or &#34;2201:056D::112E:144A:1E24&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;：056D :: 112E：144A：1E24 DOE 2201 @&#34; マルチユーザシステムの例は、 &#34;doe@sleepy.example.com&#34;、 &#34;doe@192.0.2.89&#34; またはです。いいえユーザー名を持つシステムでは、例として、 &#34;sleepy.example.com&#34;、 &#34;192.0.2.89&#34; または &#34;：056D :: 112E：144A：1E24 2201&#34; になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user name SHOULD be in a form that a program such as &#34;finger&#34; or &#34;talk&#34; could use, i.e., it typically is the login name rather than the personal name. The host name is not necessarily identical to the one in the participant&#39;s electronic mail address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザー名は、このような「指」や「トーク」などのプログラムが使用できることを形、すなわちにする必要があり、それは通常、ログイン名ではなく個人名です。ホスト名は、参加者の電子メールアドレスのものと必ずしも同一ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This syntax will not provide unique identifiers for each source if an application permits a user to generate multiple sources from one host. Such an application would have to rely on the SSRC to further identify the source, or the profile for that application would have to specify additional syntax for the CNAME identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーション1つのホストから複数のソースを生成するために、ユーザーを許可する場合は、この構文は、ソースごとに一意の識別子を提供することはありません。そのようなアプリケーションは、さらに、ソースを識別するためにSSRCに頼らなければならない、またはそのアプリケーションのプロファイルは、CNAME識別子の追加の構文を指定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If each application creates its CNAME independently, the resulting CNAMEs may not be identical as would be required to provide a binding across multiple media tools belonging to one participant in a set of related RTP sessions. If cross-media binding is required, it may be necessary for the CNAME of each tool to be externally configured with the same value by a coordination tool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各アプリケーションは、独立して、そのCNAMEを作成した場合、関連するRTPセッションのセット内の1人の参加者に属する複数のメディアツール間の結合を提供するために必要とされるように、結果として得られるのCNAMEは同一でなくてもよいです。クロスメディアの結合が必要な場合、それは、外部連携ツールで同じ値で設定される各ツールのCNAMEのために必要であるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application writers should be aware that private network address assignments such as the Net-10 assignment proposed in RFC 1918 [24] may create network addresses that are not globally unique. This would lead to non-unique CNAMEs if hosts with private addresses and no direct IP connectivity to the public Internet have their RTP packets forwarded to the public Internet through an RTP-level translator. (See also RFC 1627 [25].) To handle this case, applications MAY provide a means to configure a unique CNAME, but the burden is on the translator to translate CNAMEs from private addresses to public addresses if necessary to keep private addresses from being exposed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの作成者は、このようなネット-10の割り当てなどのプライベートネットワークアドレスの割り当ては、RFC 1918で提案されていることに注意する必要があります[24]グローバルに一意でないネットワークアドレスを作成することができます。プライベートアドレスとパブリックインターネットへの直接IP接続を持つホストがRTPレベルトランスレータを通じて公衆インターネットに転送彼らのRTPパケットを持っている場合、これは非ユニークのCNAMEにつながります。 （また、RFC 1627 [25]を参照してください。）このケースを処理するために、アプリケーションは独自のCNAMEを設定するための手段を提供することができるが、負担が必要な場合であることからプライベートアドレスを維持するために、パブリックアドレスにプライベートアドレスからのCNAMEを変換する翻訳者であります暴露。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2 NAME: User Name SDES Item
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2 NAME：ユーザー名SDESアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | NAME=2 | length | common name of source ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + | NAME = 2 |長さ|ソースの共通名... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is the real name used to describe the source, e.g., &#34;John Doe, Bit Recycler&#34;. It may be in any form desired by the user. For applications such as conferencing, this form of name may be the most desirable for display in participant lists, and therefore might be sent most frequently of those items other than CNAME. Profiles MAY establish such priorities. The NAME value is expected to remain constant at least for the duration of a session. It SHOULD NOT be relied upon to be unique among all participants in the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、例えば、「ジョン・ドウ、ビットリサイクラー」、ソースを記述するために使用される実際の名前です。これは、ユーザが所望する任意の形態であってもよいです。会議などのアプリケーションでは、名前のこの形式は、参加者リストの表示のために最も望ましいとすることができ、したがって、CNAME以外の項目で最も頻繁に送信される可能性があります。プロファイルは、このような優先順位を確立することができます。 NAME値は、少なくともセッションの期間中一定に維持することが期待されます。セッション内のすべての参加者の間で一意にするに依存すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3 EMAIL: Electronic Mail Address SDES Item
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3 EMAIL：電子メールアドレスSDESアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | EMAIL=3 | length | email address of source ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + | EMAIL = 3 |長さ|ソースの電子メールアドレス... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The email address is formatted according to RFC 2822 [9], for example, &#34;John.Doe@example.com&#34;. The EMAIL value is expected to remain constant for the duration of a session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電子メールアドレスは、RFC 2822に従ってフォーマットされている[9]、例えば、「John.Doe@example.com」。 EMAIL値は、セッションの間に一定のままと予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4 PHONE: Phone Number SDES Item
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4 PHONE：電話番号SDESアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | PHONE=4 | length | phone number of source ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + | PHONE = 4 |長さ|元の電話番号... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The phone number SHOULD be formatted with the plus sign replacing the international access code. For example, &#34;+1 908 555 1212&#34; for a number in the United States.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話番号は、国際アクセスコードを置き換えるプラス記号でフォーマットする必要があります。例えば、米国では数の「908 555 1212 +1」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.5 LOC: Geographic User Location SDES Item
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.5 LOC：地理的ユーザ場所SDESアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | LOC=5 | length | geographic location of site ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + | LOC = 5 |長さ|サイトの地理的な場所... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the application, different degrees of detail are appropriate for this item. For conference applications, a string like &#34;Murray Hill, New Jersey&#34; may be sufficient, while, for an active badge system, strings like &#34;Room 2A244, AT&amp;T BL MH&#34; might be appropriate. The degree of detail is left to the implementation and/or user, but format and content MAY be prescribed by a profile. The LOC value is expected to remain constant for the duration of a session, except for mobile hosts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションに応じて、異なる詳細度は、この項目のために適切です。会議アプリケーションでは、「マレー・ヒル、ニュージャージー州」のような文字列が十分であってもよいし、一方では、アクティブバッジシステムのために、「ルーム2A244、AT＆T BL MH」のような文字列が適切かもしれません。詳細度は、実装および/またはユーザに任されているが、形式と内容は、プロファイルによって規定されるかもしれません。 LOC値は、移動ホストを除いて、セッションの間、一定のままであることが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.6 TOOL: Application or Tool Name SDES Item
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.6ツール：アプリケーションやツール名SDESアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | TOOL=6 | length |name/version of source appl. ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + |ツール= 6 |長さ|ソースAPPLの名前/バージョン。 ... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A string giving the name and possibly version of the application generating the stream, e.g., &#34;videotool 1.2&#34;. This information may be useful for debugging purposes and is similar to the Mailer or Mail-System-Version SMTP headers. The TOOL value is expected to remain constant for the duration of the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前とストリームを生成するアプリケーションの可能性のバージョンを示す文字列、例えば、「videotool 1.2」。この情報は、デバッグ目的のために有用であるとメーラーやメール・システム・バージョンSMTPヘッダに類似していることがあります。 TOOL値は、セッションの間に一定のままと予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.7 NOTE: Notice/Status SDES Item
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.7注：お知らせ/ステータスSDESアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | NOTE=7 | length | note about the source ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + | NOTE = 7 |長さ|ソースについての注意... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following semantics are suggested for this item, but these or other semantics MAY be explicitly defined by a profile. The NOTE item is intended for transient messages describing the current state of the source, e.g., &#34;on the phone, can&#39;t talk&#34;. Or, during a seminar, this item might be used to convey the title of the talk. It should be used only to carry exceptional information and SHOULD NOT be included routinely by all participants because this would slow down the rate at which reception reports and CNAME are sent, thus impairing the performance of the protocol. In particular, it SHOULD NOT be included as an item in a user&#39;s configuration file nor automatically generated as in a quote-of-the-day.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のセマンティクスは、この項目のために提案されているが、これらまたは他のセマンティクスは、明示的に、プロファイルによって定義されてもよいです。 NOTE項目は、例えば、「電話で、話すことはできない」、ソースの現在の状態を表す一時的なメッセージのために意図されます。または、セミナーの際に、この項目は話のタイトルを伝えるために使用される可能性があります。例外的な情報を伝えるためにのみ使用する必要があり、これは、受信レポートやCNAMEは、このように、プロトコルのパフォーマンスを損なう、送信される速度が遅くなるので、全ての参加者により日常的に含まれるべきではありません。特に、それは、ユーザーの設定ファイル内の項目として含めるべきではないにも自動的に引用の-日のように生成されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the NOTE item may be important to display while it is active, the rate at which other non-CNAME items such as NAME are transmitted might be reduced so that the NOTE item can take that part of the RTCP bandwidth. When the transient message becomes inactive, the NOTE item SHOULD continue to be transmitted a few times at the same repetition rate but with a string of length zero to signal the receivers. However, receivers SHOULD also consider the NOTE item inactive if it is not received for a small multiple of the repetition rate, or perhaps 20-30 RTCP intervals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE項目は、それがアクティブなときに表示することが重要であり得るので注意項目がRTCP帯域幅の一部を取ることができるように、そのようなNAMEのような他の非CNAMEアイテムが送信されるレートを低減するかもしれません。過渡メッセージが非アクティブになると、NOTE項目は同じ繰り返しレートでなく、受信機に信号を送る長さゼロの文字列で数回送信することを継続する必要があります。それは小さな繰り返し率の倍数、または多分20-30 RTCP間隔で受信されない場合は、受信機はまたNOTEアイテムが非アクティブに考慮すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.8 PRIV: Private Extensions SDES Item
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.8 PRIV：プライベート拡張SDESアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     PRIV=8    |     length    | prefix length |prefix string...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ...             |                  value string               ...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This item is used to define experimental or application-specific SDES extensions. The item contains a prefix consisting of a length-string pair, followed by the value string filling the remainder of the item and carrying the desired information. The prefix length field is 8 bits long. The prefix string is a name chosen by the person defining the PRIV item to be unique with respect to other PRIV items this application might receive. The application creator might choose to use the application name plus an additional subtype identification if needed. Alternatively, it is RECOMMENDED that others choose a name based on the entity they represent, then coordinate the use of the name within that entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この項目は、実験やアプリケーション固有のSDES拡張を定義するために使用されます。アイテムは、アイテムの残りの部分を充填し、所望の情報を搬送する値文字列が続く長さの文字列の対からなるプレフィックスを含んでいます。プレフィックス長フィールドは8ビット長です。プレフィックス文字列は、このアプリケーションが受け取る可能性のある他のPRIVアイテムに対して一意であることをPRIV項目を定義する人によって選ばれた名前です。アプリケーションの作成者は、必要に応じて、アプリケーション名に加えて追加のサブタイプの識別を使用することを選択するかもしれません。また、それは他の人はそれが表すエンティティに基づいて名前を選択することをお勧めし、そのエンティティ内の名前の使用を調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the prefix consumes some space within the item&#39;s total length of 255 octets, so the prefix should be kept as short as possible. This facility and the constrained RTCP bandwidth SHOULD NOT be overloaded; it is not intended to satisfy all the control communication requirements of all applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プレフィックスが255オクテットの項目の合計の長さの中にいくつかのスペースを消費するので、プレフィックスはできるだけ短くする必要があることに注意してください。この機能と制約のRTCP帯域幅が過負荷にすべきではありません。すべてのアプリケーションのすべての制御通信の要件を満たすために意図されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES PRIV prefixes will not be registered by IANA. If some form of the PRIV item proves to be of general utility, it SHOULD instead be assigned a regular SDES item type registered with IANA so that no prefix is required. This simplifies use and increases transmission efficiency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES PRIVプレフィックスはIANAによって登録されることはありません。 PRIVアイテムのいくつかのフォームは、一般的に有用であることが判明した場合、それは代わりに接頭辞が必要とされないように、IANAに登録正規SDESアイテムタイプを割り当てられるべきです。これは、使用を簡素化し、伝送効率を増加させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6 BYE: Goodbye RTCP Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6 BYE：さようならRTCPパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P| SC | PT=BYE=203 | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SSRC/CSRC | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ : ... : +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ (opt) | length | reason for leaving ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + | V = 2 | P | SC | PT = BYE = 203 |長さ| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | SSRC / CSRC | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +：...：+ = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +（OPT）|長さ|残すための理由... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The BYE packet indicates that one or more sources are no longer active.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYEパケットは、1つまたは複数のソースは、もは​​や有効であることを示していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version (V), padding (P), length: As described for the SR packet (see Section 6.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョン（V）、パディング（P）、長さ：SRパケットに関して記載したように（セクション6.4.1参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packet type (PT): 8 bits Contains the constant 203 to identify this as an RTCP BYE packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットタイプ（PT）：8ビットは、RTCP BYEパケットとしてこれを識別するための定数203を含み。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
source count (SC): 5 bits The number of SSRC/CSRC identifiers included in this BYE packet. A count value of zero is valid, but useless.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソース・カウント（SC）：5ビットSSRC / CSRC識別子の数は、このBYEパケットに含まれます。ゼロのカウント値は、有効な、しかし無用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules for when a BYE packet should be sent are specified in Sections 6.3.7 and 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYEパケットが送られるべきときの規則は、セクション6.3.7と8.2で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a BYE packet is received by a mixer, the mixer SHOULD forward the BYE packet with the SSRC/CSRC identifier(s) unchanged. If a mixer shuts down, it SHOULD send a BYE packet listing all contributing sources it handles, as well as its own SSRC identifier. Optionally, the BYE packet MAY include an 8-bit octet count followed by that many octets of text indicating the reason for leaving, e.g., &#34;camera malfunction&#34; or &#34;RTP loop detected&#34;. The string has the same encoding as that described for SDES. If the string fills the packet to the next 32-bit boundary, the string is not null terminated. If not, the BYE packet MUST be padded with null octets to the next 32- bit boundary. This padding is separate from that indicated by the P bit in the RTCP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYEパケットをミキサーで受信された場合、ミキサは不変SSRC / CSRC識別子（複数）とBYEパケットを転送すべきです。ミキサーがシャットダウンした場合、それが取り扱うすべての貢献のソースをリストBYEパケットだけでなく、自身のSSRC識別子を送るべきです。必要に応じて、BYEパケットは、8ビットのオクテットは、例えば、「カメラ異常」または「検出されたRTPループ」を残すための理由を示すテキストの多くのオクテットが続くカウント含むかもしれません。文字列は、SDESについて説明したのと同様の符号を有しています。文字列は、次の32ビット境界にパケットを満たす場合は、文字列がnullで終了していません。ない場合は、BYEパケットは、次の32ビット境界にヌルオクテットで埋めなければなりません。このパディングは、RTCPヘッダ内のPビットによって示されるものとは別です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7 APP: Application-Defined RTCP Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7 APP：アプリケーション定義RTCPパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P| subtype | PT=APP=204 | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | SSRC/CSRC | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | name (ASCII) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | application-dependent data ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + | V = 2 | P |サブタイプ| PT = APP = 204 |長さ| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | SSRC / CSRC | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |名前（ASCII）| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |アプリケーション依存データ... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The APP packet is intended for experimental use as new applications and new features are developed, without requiring packet type value registration. APP packets with unrecognized names SHOULD be ignored. After testing and if wider use is justified, it is RECOMMENDED that each APP packet be redefined without the subtype and name fields and registered with IANA using an RTCP packet type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいアプリケーションや新機能は、パケットタイプ値の登録を必要とせずに、開発されるAPPパケットは、実験的な使用のために意図されます。認識されない名前を持つAPPパケットは無視されるべきです。テストした後、より広い使用が正当化されるならば、各APPパケットはサブタイプと名前のフィールドなしで再定義し、RTCPパケットタイプを使用して、IANAに登録されていることが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version (V), padding (P), length: As described for the SR packet (see Section 6.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョン（V）、パディング（P）、長さ：SRパケットに関して記載したように（セクション6.4.1参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
subtype: 5 bits May be used as a subtype to allow a set of APP packets to be defined under one unique name, or for any application-dependent data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブタイプ：5ビットは、APPパケットのセットはつの固有名称で、または任意のアプリケーションに依存するデータのために定義されるように、サブタイプとして使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packet type (PT): 8 bits Contains the constant 204 to identify this as an RTCP APP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットタイプ（PT）：8ビットは、RTCP APPパケットとしてこれを識別するための定数204を含み。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
name: 4 octets A name chosen by the person defining the set of APP packets to be unique with respect to other APP packets this application might receive. The application creator might choose to use the application name, and then coordinate the allocation of subtype values to others who want to define new packet types for the application. Alternatively, it is RECOMMENDED that others choose a name based on the entity they represent, then coordinate the use of the name within that entity. The name is interpreted as a sequence of four ASCII characters, with uppercase and lowercase characters treated as distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前：4つのオクテット、このアプリケーションが受け取る可能性のある他のAPPパケットに対して一意であることをAPPパケットの集合を定義する人によって選ばれた名前。アプリケーションの作成者は、アプリケーション名を使用することを選択し、アプリケーションのための新しいパケットタイプを定義したい他の人にサブタイプ値の配分を調整することがあります。また、それは他の人はそれが表すエンティティに基づいて名前を選択することをお勧めし、そのエンティティ内の名前の使用を調整します。名前は、別個のものとして扱わ大文字と小文字では、4つのASCII文字のシーケンスとして解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
application-dependent data: variable length Application-dependent data may or may not appear in an APP packet. It is interpreted by the application and not RTP itself. It MUST be a multiple of 32 bits long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーション依存データ：可変長アプリケーション依存データ又はAPPパケットに表示されなくてもよいです。これは、アプリケーションではなくRTP自体によって解釈されます。これは、32ビット長の倍数でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. RTP Translators and Mixers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. RTP翻訳者とミキサー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to end systems, RTP supports the notion of &#34;translators&#34; and &#34;mixers&#34;, which could be considered as &#34;intermediate systems&#34; at the RTP level. Although this support adds some complexity to the protocol, the need for these functions has been clearly established by experiments with multicast audio and video applications in the Internet. Example uses of translators and mixers given in Section 2.3 stem from the presence of firewalls and low bandwidth connections, both of which are likely to remain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドシステムに加えて、RTPは、RTPレベルの「中間システム」とみなすことができる「翻訳」と「ミキサー」の概念をサポートします。このサポートは、プロトコルにいくつかの複雑さを追加しますが、これらの機能の必要性は明らかに、インターネットでのマルチキャストオーディオおよびビデオアプリケーションを用いた実験によって確立されています。例には、残っている可能性が高いどちらもファイアウォールや低帯域幅の接続、の存在から2.3ステムに与えられた翻訳者とミキサーの使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 General Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1一般的な説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RTP translator/mixer connects two or more transport-level &#34;clouds&#34;. Typically, each cloud is defined by a common network and transport protocol (e.g., IP/UDP) plus a multicast address and transport level destination port or a pair of unicast addresses and ports. (Network-level protocol translators, such as IP version 4 to IP version 6, may be present within a cloud invisibly to RTP.) One system may serve as a translator or mixer for a number of RTP sessions, but each is considered a logically separate entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPトランスレータ/ミキサーは、二つ以上のトランスポートレベルの「雲」を接続します。典型的には、各クラウドは、共通ネットワークおよびトランスポートプロトコル（例えば、IP / UDP）を加えたマルチキャストアドレスおよびトランスポートレベルの宛先ポートまたはユニキャストアドレスとポートのペアによって定義されます。 （例えば、IPバージョン6のIPバージョン4のようなネットワーク・レベルのプロトコルトランスレータは、不可視RTPにクラウド内に存在してもよい。）1つのシステムは、RTPセッション数のトランスレータやミキサーとして機能することができるが、それぞれが論理的に考えられています別のエンティティ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid creating a loop when a translator or mixer is installed, the following rules MUST be observed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスレータやミキサーがインストールされてループを作成しないようにするために、以下の規則が守らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each of the clouds connected by translators and mixers participating in one RTP session either MUST be distinct from all the others in at least one of these parameters (protocol, address, port), or MUST be isolated at the network level from the others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oのいずれか1つのRTPセッションに参加する翻訳者とミキサーによって接続された雲の各々は、これらのパラメータ（プロトコル、アドレス、ポート）の少なくとも一方で他のすべてとは別個であるか、または他のネットワークレベルで分離されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A derivative of the first rule is that there MUST NOT be multiple translators or mixers connected in parallel unless by some arrangement they partition the set of sources to be forwarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O最初のルールの誘導体がない限り、それらがソースのセットを転送するパーティション一部配置することにより、並列に接続された複数の翻訳者やミキサーがあってはならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, all RTP end systems that can communicate through one or more RTP translators or mixers share the same SSRC space, that is, the SSRC identifiers MUST be unique among all these end systems. Section 8.2 describes the collision resolution algorithm by which SSRC identifiers are kept unique and loops are detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、一つ以上のRTPトランスレータやミキサーを介して通信することができるすべてのRTPエンドシステムは、同じSSRC空間を共有する、つまり、SSRC識別子は、これら全てのエンドシステム間で一意である必要があり。 8.2節は、SSRC識別子が一意で保持され、ループが検出されたことにより、衝突解決アルゴリズムを記述しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There may be many varieties of translators and mixers designed for different purposes and applications. Some examples are to add or remove encryption, change the encoding of the data or the underlying protocols, or replicate between a multicast address and one or more unicast addresses. The distinction between translators and mixers is that a translator passes through the data streams from different sources separately, whereas a mixer combines them to form one new stream:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なる目的や用途のために設計された翻訳者とミキサーの多くの品種があるかもしれません。いくつかの例には、追加または暗号化を削除し、データの符号化や基本的なプロトコルを変更、またはマルチキャストアドレスと1つ以上のユニキャストアドレスの間で複製することです。翻訳者とミキサーとの間の区別は、ミキサーは一つの新たなストリームを形成するためにそれらを結合し、一方トランスレータが、別々に異なるソースからのデータストリームを通過することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Translator: Forwards RTP packets with their SSRC identifier intact; this makes it possible for receivers to identify individual sources even though packets from all the sources pass through the same translator and carry the translator&#39;s network source address. Some kinds of translators will pass through the data untouched, but others MAY change the encoding of the data and thus the RTP data payload type and timestamp. If multiple data packets are re-encoded into one, or vice versa, a translator MUST assign new sequence numbers to the outgoing packets. Losses in the incoming packet stream may induce corresponding gaps in the outgoing sequence numbers. Receivers cannot detect the presence of a translator unless they know by some other means what payload type or transport address was used by the original source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
翻訳：そのSSRC識別子と転送したRTPパケットをそのまま。これにより、受信機がすべてのソースからのパケットが同じ翻訳者を通過し、翻訳者のネットワーク送信元アドレスを運ぶにもかかわらず、個々のソースを識別できるようになります。翻訳の種類によっては、そのままデータを通過するが、他のものは、データの符号化、従ってRTPデータペイロードタイプとタイムスタンプを変更することができます。複数のデータパケットが一つまたはその逆に再エンコードされている場合、翻訳者は、発信パケットに新しいシーケンス番号を割り当てる必要があります。着信パケットストリームの損失は、送信シーケンス番号に対応するギャップを誘発することができます。彼らはペイロードタイプやトランスポートアドレスは、元のソースで使用されたものをいくつかの他の手段で知っている限りレシーバは、翻訳者の存在を検出することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mixer: Receives streams of RTP data packets from one or more sources, possibly changes the data format, combines the streams in some manner and then forwards the combined stream. Since the timing among multiple input sources will not generally be synchronized, the mixer will make timing adjustments among the streams and generate its own timing for the combined stream, so it is the synchronization source. Thus, all data packets forwarded by a mixer MUST be marked with the mixer&#39;s own SSRC identifier. In order to preserve the identity of the original sources contributing to the mixed packet, the mixer SHOULD insert their SSRC identifiers into the CSRC identifier list following the fixed RTP header of the packet. A mixer that is also itself a contributing source for some packet SHOULD explicitly include its own SSRC identifier in the CSRC list for that packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミキサー：おそらくは、データ形式を変更するいくつかの方法でストリームを結合し、次いで合わせたストリームを転送する、1つまたは複数のソースからのRTPデータパケットのストリームを受信。複数の入力ソースのうちのタイミングは、一般的に同期されないので、ミキサーは、ストリーム間のタイミング調整を行い、合わせたストリームのための独自のタイミングを生成するので、同期ソースであろう。このように、ミキサーで転送され、すべてのデータパケットは、ミキサー自身のSSRC識別子でマークする必要があります。混合パケットに寄与するオリジナルソースの識別を維持するために、ミキサは、パケットの固定されたRTPヘッダに続くCSRC識別子のリストにそれらのSSRC識別子を挿入する必要があります。また、いくつかのパケットのために貢献してソース自体であるミキサーは、明示的にそのパケットのCSRCリストに、自身のSSRC識別子を含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For some applications, it MAY be acceptable for a mixer not to identify sources in the CSRC list. However, this introduces the danger that loops involving those sources could not be detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ミキサーがCSRCリストに源を特定しないため、一部のアプリケーションでは、それが許容可能です。しかし、これは、これらのソースを含むループは検出されなかったという危険を紹介します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The advantage of a mixer over a translator for applications like audio is that the output bandwidth is limited to that of one source even when multiple sources are active on the input side. This may be important for low-bandwidth links. The disadvantage is that receivers on the output side don&#39;t have any control over which sources are passed through or muted, unless some mechanism is implemented for remote control of the mixer. The regeneration of synchronization information by mixers also means that receivers can&#39;t do inter-media synchronization of the original streams. A multi-media mixer could do it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーディオのような用途のためのトランスレータを超えるミキサーの利点は、出力帯域幅が複数のソースは、入力側でアクティブであっても、一方のソースのものに限定されることです。これは、低帯域幅リンクのために重要であり得ます。欠点は、いくつかの機構がミキサのリモートコントロールのために実施されていない限り、出力側の受信機は、ソースが通過し又はミュートされ、その上の任意のコントロールを持っていないということです。ミキサーによって同期情報の再生はまた、受信機は、元のストリームのメディア間の同期を行うことができないことを意味します。マルチメディア・ミキサーはそれを行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         [E1]                                    [E6]
          |                                       |
    E1:17 |                                 E6:15 |
          |                                       |   E6:15
          V  M1:48 (1,17)         M1:48 (1,17)    V   M1:48 (1,17)
         (M1)-------------&gt;&lt;T1&gt;-----------------&gt;&lt;T2&gt;--------------&gt;[E7]
          ^                 ^     E4:47           ^   E4:47
     E2:1 |           E4:47 |                     |   M3:89 (64,45)
          |                 |                     |
         [E2]              [E4]     M3:89 (64,45) |
                                                  |        legend:
   [E3] ---------&gt;(M2)-----------&gt;(M3)------------|        [End system]
          E3:64        M2:12 (64)  ^                       (Mixer)
                                   | E5:45                 &lt;Translator&gt;
                                   |
                                  [E5]          source: SSRC (CSRCs)
                                                -------------------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3: Sample RTP network with end systems, mixers and translators
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3：エンドシステム、ミキサーと翻訳者とサンプルRTPネットワーク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A collection of mixers and translators is shown in Fig. 3 to illustrate their effect on SSRC and CSRC identifiers. In the figure, end systems are shown as rectangles (named E), translators as triangles (named T) and mixers as ovals (named M). The notation &#34;M1: 48(1,17)&#34; designates a packet originating a mixer M1, identified by M1&#39;s (random) SSRC value of 48 and two CSRC identifiers, 1 and 17, copied from the SSRC identifiers of packets from E1 and E2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミキサおよびトランスレータのコレクションはSSRCとCSRC識別子に対するそれらの効果を説明するために図3に示されています。図では、エンドシステムは、（Eと命名）矩形、翻訳者として示されているような楕円として三角形（Tと命名）とミキサー（Mと命名します）。表記「M1：48（1,17）」M1の48の（ランダム）SSRC値とE1およびE2からのパケットのSSRC識別子からコピーされた2つのCSRC識別子、1および17によって識別、ミキサM1を発信パケットを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 RTCP Processing in Translators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
翻訳者で7.2 RTCP処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to forwarding data packets, perhaps modified, translators and mixers MUST also process RTCP packets. In many cases, they will take apart the compound RTCP packets received from end systems to aggregate SDES information and to modify the SR or RR packets. Retransmission of this information may be triggered by the packet arrival or by the RTCP interval timer of the translator or mixer itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データパケットを転送することに加えて、おそらく修飾、翻訳者とミキサーはRTCPパケットも処理しなければなりません。多くの場合、彼らは離れてSDES情報を集約し、SRやRRパケットを変更するためにエンドシステムから受信した複合RTCPパケットがかかります。この情報の再送信は、パケット到着によって、またはトランスレータやミキサー自体のRTCPインターバルタイマによってトリガされてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A translator that does not modify the data packets, for example one that just replicates between a multicast address and a unicast address, MAY simply forward RTCP packets unmodified as well. A translator that transforms the payload in some way MUST make corresponding transformations in the SR and RR information so that it still reflects the characteristics of the data and the reception quality. These translators MUST NOT simply forward RTCP packets. In general, a translator SHOULD NOT aggregate SR and RR packets from different sources into one packet since that would reduce the accuracy of the propagation delay measurements based on the LSR and DLSR fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データパケットを変更しない翻訳者は、単にマルチキャストアドレスとユニキャストアドレスとの間にレプリケート例えばいずれかの、単に前方RTCPパケットが同様に修飾されていないかもしれません。それはまだデータの特性や受信品質を反映するように、いくつかの方法でペイロードを変換するトランスレータは、SRとRR情報に対応する変換を行う必要があります。これらの翻訳者は、単に前方RTCPパケットはいけません。すなわちLSRとDLSRフィールドに基づいて、伝搬遅延測定の精度を低下させることになるので、一般的に、翻訳者は、異なるソースから集約SRとRRパケットは、1つのパケットにはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR sender information: A translator does not generate its own sender information, but forwards the SR packets received from one cloud to the others. The SSRC is left intact but the sender information MUST be modified if required by the translation. If a translator changes the data encoding, it MUST change the &#34;sender&#39;s byte count&#34; field. If it also combines several data packets into one output packet, it MUST change the &#34;sender&#39;s packet count&#34; field. If it changes the timestamp frequency, it MUST change the &#34;RTP timestamp&#34; field in the SR packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRの送信者情報：翻訳者は、自身の送信者情報を生成しますが、パケットは他の人に1つのクラウドから受け取ったSRを転送しません。 SSRCはそのまま残されているが、翻訳で必要な場合は、送信者情報を変更する必要があります。翻訳者は、データのエンコーディングを変更した場合、それは「送信者のバイト数」フィールドを変更する必要があります。それは、1つの出力パケットにいくつかのデータパケットを組み合わせた場合は、「送信者のパケット数」フィールドを変更する必要があります。それは、タイムスタンプの周波数を変更した場合、それはSRパケットで「RTPタイムスタンプ」フィールドを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR/RR reception report blocks: A translator forwards reception reports received from one cloud to the others. Note that these flow in the direction opposite to the data. The SSRC is left intact. If a translator combines several data packets into one output packet, and therefore changes the sequence numbers, it MUST make the inverse manipulation for the packet loss fields and the &#34;extended last sequence number&#34; field. This may be complex. In the extreme case, there may be no meaningful way to translate the reception reports, so the translator MAY pass on no reception report at all or a synthetic report based on its own reception. The general rule is to do what makes sense for a particular translation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR / RRレセプションレポートブロック：翻訳者は、受信レポートは他の人に1つのクラウドから受信した転送します。データとは逆方向に、これらのフローに留意されたいです。 SSRCはそのまま残されています。翻訳者が一つの出力パケットにいくつかのデータパケットを結合し、そのためのシーケンス番号を変更する場合は、パケット損失フィールドと「拡張最後のシーケンス番号」フィールドの逆の操作を行う必要があります。これは複雑です。極端な場合には、翻訳者が全く受信報告や独自の受信に基づいて合成レポートに渡してもよいので、受信報告書を翻訳する全く意味のある方法が存在しない場合があります。一般的なルールは、特定の翻訳のために理にかなって何をすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A translator does not require an SSRC identifier of its own, but MAY choose to allocate one for the purpose of sending reports about what it has received. These would be sent to all the connected clouds, each corresponding to the translation of the data stream as sent to that cloud, since reception reports are normally multicast to all participants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
翻訳者は、自身のSSRC識別子を必要としない、それが受信したかについてのレポートを送信する目的のために1を割り当てることを選ぶかもしれません。受信レポートは、通常、すべての参加者にマルチキャストされているため、これらは、そのクラウドに送信され、各データストリームの翻訳に対応し、接続されたすべての雲に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES: Translators typically forward without change the SDES information they receive from one cloud to the others, but MAY, for example, decide to filter non-CNAME SDES information if bandwidth is limited. The CNAMEs MUST be forwarded to allow SSRC identifier collision detection to work. A translator that generates its own RR packets MUST send SDES CNAME information about itself to the same clouds that it sends those RR packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES：帯域幅が制限されている場合は変更せず、通常前方翻訳者、彼らは他の人に1つのクラウドから受け取るSDES情報が、MAYは、例えば、非CNAME SDES情報をフィルタリングすることを決定しました。 CNAMEは、SSRC識別子の衝突検出が機能するように転送されなければなりません。独自のRRパケットを生成し、翻訳者は、それがこれらのRRパケットを送信し、同じ雲に自分自身についてのSDES CNAME情報を送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYE: Translators forward BYE packets unchanged. A translator that is about to cease forwarding packets SHOULD send a BYE packet to each connected cloud containing all the SSRC identifiers that were previously being forwarded to that cloud, including the translator&#39;s own SSRC identifier if it sent reports of its own.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYE：翻訳者前方BYEパケット変わりません。それは、独自のレポートを送信した場合、以前に翻訳者自身のSSRC識別子を含む、そのクラウドに転送されていたすべてのSSRC識別子を含む各接続クラウドにBYEパケットを送るべきパケットの転送を停止しようとしている翻訳者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
APP: Translators forward APP packets unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
APP：翻訳者前方APPパケット変わりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3 RTCP Processing in Mixers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ミキサーで7.3 RTCP処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since a mixer generates a new data stream of its own, it does not pass through SR or RR packets at all and instead generates new information for both sides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミキサーは、独自の新たなデータストリームを生成するので、それは全てのSRまたはRRパケットを通過し、代わりに両側のための新たな情報を生成しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR sender information: A mixer does not pass through sender information from the sources it mixes because the characteristics of the source streams are lost in the mix. As a synchronization source, the mixer SHOULD generate its own SR packets with sender information about the mixed data stream and send them in the same direction as the mixed stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR送信者情報：ミキサーは、ソースストリームの特性が混在して失われているので、それはミックスソースからの送信者情報を通過しません。同期ソースとして、ミキサは、混合データストリームに関する送信者情報と、自身のSRパケットを生成すべきであり、混合流と同じ方向にそれらを送ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR/RR reception report blocks: A mixer generates its own reception reports for sources in each cloud and sends them out only to the same cloud. It MUST NOT send these reception reports to the other clouds and MUST NOT forward reception reports from one cloud to the others because the sources would not be SSRCs there (only CSRCs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR / RRレセプションレポートブロック：ミキサーは、各クラウド内のソースのために独自の受信レポートを生成し、同じクラウドに送出します。ソースがSSRCs（のみCSRCs）ではないので、それは他の人に1つの雲から他の雲と転送しませMUST受信報告書にこれらの受信報告を送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES: Mixers typically forward without change the SDES information they receive from one cloud to the others, but MAY, for example, decide to filter non-CNAME SDES information if bandwidth is limited. The CNAMEs MUST be forwarded to allow SSRC identifier collision detection to work. (An identifier in a CSRC list generated by a mixer might collide with an SSRC identifier generated by an end system.) A mixer MUST send SDES CNAME information about itself to the same clouds that it sends SR or RR packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES：一般的に前方そのままミキサー、彼らは他の人に1つのクラウドから受け取るSDES情報が、帯域幅が制限されている場合MAYは、例えば、非CNAME SDES情報をフィルタリングすることを決定しました。 CNAMEは、SSRC識別子の衝突検出が機能するように転送されなければなりません。 （ミキサーによって生成されたCSRCリストの識別子は、エンドシステムによって生成されたSSRC識別子と衝突する可能性があります。）ミキサは、SRまたはRRパケットを送信同じ雲に自身約SDES CNAME情報を送信しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Since mixers do not forward SR or RR packets, they will typically be extracting SDES packets from a compound RTCP packet. To minimize overhead, chunks from the SDES packets MAY be aggregated into a single SDES packet which is then stacked on an SR or RR packet originating from the mixer. A mixer which aggregates SDES packets will use more RTCP bandwidth than an individual source because the compound packets will be longer, but that is appropriate since the mixer represents multiple sources. Similarly, a mixer which passes through SDES packets as they are received will be transmitting RTCP packets at higher than the single source rate, but again that is correct since the packets come from multiple sources. The RTCP packet rate may be different on each side of the mixer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ミキサーは、前方SRやRRパケットをしないので、彼らは通常、複合RTCPパケットからSDESパケットを抽出します。オーバーヘッドを最小限に抑えるために、SDESパケットからのチャンクは、次にミキサーに由来SRまたはRRパケット上に積層された単一のSDESパケットに集計されるかもしれません。化合物パケットが長くなるので、SDESパケットを集約ミキサは、個々のソースよりも多くのRTCP帯域幅を使用するが、ミキサは複数のソースを表すので、それが適切です。同様に、それらが受信されるとSDESパケットを通過ミキサは、単一のソースレートよりも高いでRTCPパケットを送信するが、パケットは複数のソースから来るので、再び、それは正しいです。 RTCPパケットレートは、ミキサーの各側に異なっていてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A mixer that does not insert CSRC identifiers MAY also refrain from forwarding SDES CNAMEs. In this case, the SSRC identifier spaces in the two clouds are independent. As mentioned earlier, this mode of operation creates a danger that loops can&#39;t be detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CSRC識別子を挿入しないミキサーもSDESのCNAMEを転送することを控えることができます。この場合、2つの雲にSSRC識別子空間は独立しています。前述したように、この動作モードを検出することができないループ危険を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYE: Mixers MUST forward BYE packets. A mixer that is about to cease forwarding packets SHOULD send a BYE packet to each connected cloud containing all the SSRC identifiers that were previously being forwarded to that cloud, including the mixer&#39;s own SSRC identifier if it sent reports of its own.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYE：ミキサーはBYEパケットを転送する必要があります。それは、独自のレポートを送信した場合、以前にミキサー自身のSSRC識別子を含む、そのクラウドに転送されていたすべてのSSRC識別子を含む各接続クラウドにBYEパケットを送るべきパケットの転送を停止しようとしているミキサー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
APP: The treatment of APP packets by mixers is application-specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
APP：ミキサーによるAPPパケットの治療は、アプリケーション固有です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4 Cascaded Mixers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4カスケード接続ミキサー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RTP session may involve a collection of mixers and translators as shown in Fig. 3. If two mixers are cascaded, such as M2 and M3 in the figure, packets received by a mixer may already have been mixed and may include a CSRC list with multiple identifiers. The second mixer SHOULD build the CSRC list for the outgoing packet using the CSRC identifiers from already-mixed input packets and the SSRC identifiers from unmixed input packets. This is shown in the output arc from mixer M3 labeled M3:89(64,45) in the figure. As in the case of mixers that are not cascaded, if the resulting CSRC list has more than 15 identifiers, the remainder cannot be included.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPセッションは、図に示すように、2つのミキサは、例えば図中のM2及びM3のように、カスケード接続されている3.場合、ミキサによって受信されたパケットが既に混合されていてもよい。ミキサおよびトランスレータのコレクションを含むことができるととCSRCリストを含むことができ複数の識別子。第2のミキサは、混合されていない入力パケットから既に混合入力パケットからCSRC識別子とSSRC識別子を用いて送信パケットのCSRCリストを構築する必要があります。これはミキサーM3標識M3から出力アークに示されている：89（64,45）の図です。得られたCSRCリストは15の以上の識別子を有する場合に、縦続接続されていないミキサーの場合のように、残りを含めることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. SSRC Identifier Allocation and Use
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. SSRC識別子の割り当ておよび使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SSRC identifier carried in the RTP header and in various fields of RTCP packets is a random 32-bit number that is required to be globally unique within an RTP session. It is crucial that the number be chosen with care in order that participants on the same network or starting at the same time are not likely to choose the same number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPヘッダ及びRTCPパケットの様々なフィールドで運ばSSRC識別子は、RTPセッション内でグローバルに一意であることが要求されるランダムな32ビット数です。番号が同じネットワークまたは同時に起動の参加者が同じ番号を選択する可能性がないようにするために、注意して選択することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is not sufficient to use the local network address (such as an IPv4 address) for the identifier because the address may not be unique. Since RTP translators and mixers enable interoperation among multiple networks with different address spaces, the allocation patterns for addresses within two spaces might result in a much higher rate of collision than would occur with random allocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アドレスは一意ではないかもしれないので、識別子のために（例えば、IPv4アドレスのような）ローカルネットワークアドレスを使用するには不十分です。 RTPトランスレータおよびミキサは、異なるアドレス空間を有する複数のネットワーク間の相互運用を可能にするので、二つの空間内のアドレスの割り当てパターンがランダム割当てで生じるよりも衝突のはるかに高い割合をもたらすかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple sources running on one host would also conflict.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つのホスト上で実行されている複数のソースにも反します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also not sufficient to obtain an SSRC identifier simply by calling random() without carefully initializing the state. An example of how to generate a random identifier is presented in Appendix A.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、単に慎重に状態を初期化せずに（）を呼び出すことによってランダムSSRC識別子を取得するのに十分ではありません。ランダムな識別子を生成する方法の例は、付録A.6に提示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 Probability of Collision
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
衝突の確率8.1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the identifiers are chosen randomly, it is possible that two or more sources will choose the same number. Collision occurs with the highest probability when all sources are started simultaneously, for example when triggered automatically by some session management event. If N is the number of sources and L the length of the identifier (here, 32 bits), the probability that two sources independently pick the same value can be approximated for large N [26] as 1 - exp(-N**2 / 2**(L+1)). For N=1000, the probability is roughly 10**-4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別子がランダムに選択されているので、2つの以上のソースは同じ番号を選択することが可能です。衝突は、いくつかのセッション管理イベントによって自動的にトリガされたときにすべてのソースは、例えば、同時に開始され、最も高い確率で発生します。 Nは、ソースの数、Lは識別子（ここでは32ビット）の長さである場合、二つのソースは、独立して同じ値を選ぶ確率が大きいNのために近似することができる[26] 1として -  EXP（-N ** 2 / 2 **（L + 1））。 4  -  N = 1000の場合、確率は約10 **です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The typical collision probability is much lower than the worst-case above. When one new source joins an RTP session in which all the other sources already have unique identifiers, the probability of collision is just the fraction of numbers used out of the space. Again, if N is the number of sources and L the length of the identifier, the probability of collision is N / 2**L. For N=1000, the probability is roughly 2*10**-7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的な衝突確率は、上記最悪の場合よりもはるかに低いです。 1つの新しいソースは、他のすべてのソースが既に一意の識別子を持っているRTPセッションに参加すると、衝突の確率は、スペースの外に使用される数字のほんの一部です。 Nは、ソースおよびLの数識別子の長さである場合に再度、衝突の確率は、L ** N / 2です。 7  -  N = 1000の場合、確率は約2 * 10 **です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probability of collision is further reduced by the opportunity for a new source to receive packets from other participants before sending its first packet (either data or control). If the new source keeps track of the other participants (by SSRC identifier), then before transmitting its first packet the new source can verify that its identifier does not conflict with any that have been received, or else choose again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
衝突の確率はさらにその最初のパケット（データまたは制御のいずれか）を送信する前に他の参加者からのパケットを受信するための新しいソース機会によって低減されます。新しいソースが（SSRC識別子によって）他の参加者を追跡した場合は、その最初のパケットを送信する前に、新しいソースは、その識別子が受信されたことをいずれかと競合するか、さもなければ再び選択しないことを確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 Collision Resolution and Loop Detection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2衝突解決とループ検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the probability of SSRC identifier collision is low, all RTP implementations MUST be prepared to detect collisions and take the appropriate actions to resolve them. If a source discovers at any time that another source is using the same SSRC identifier as its own, it MUST send an RTCP BYE packet for the old identifier and choose another random one. (As explained below, this step is taken only once in case of a loop.) If a receiver discovers that two other sources are colliding, it MAY keep the packets from one and discard the packets from the other when this can be detected by different source transport addresses or CNAMEs. The two sources are expected to resolve the collision so that the situation doesn&#39;t last.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSRC識別子衝突の確率は低いですが、すべてのRTPの実装は、衝突を検出し、それらを解決するために、適切な行動を取るために準備しなければなりません。ソースは別のソースは、独自のものと同じSSRC識別子を使用している任意の時点で検出された場合、それは昔の識別子のためにRTCP BYEパケットを送信し、別のランダムなものを選択する必要があります。 （以下に説明するように、このステップをループの場合には一度だけ行われる。）受信機は、2つの他のソースが衝突していることを発見した場合、これは、1つからパケットを保持することができる、これは、異なるによって検出することができる場合、他からのパケットを破棄しますソーストランスポートアドレスやのCNAME。 2つのソースは状況が続かないように、衝突を解決することが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the random SSRC identifiers are kept globally unique for each RTP session, they can also be used to detect loops that may be introduced by mixers or translators. A loop causes duplication of data and control information, either unmodified or possibly mixed, as in the following examples:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダムSSRC識別子は、各RTPセッションのグローバル一意保たれているので、彼らはまた、ミキサーや翻訳者によって導入することができるループを検出するために使用することができます。ループは、次の例のように、データの重複が発生し、制御情報を、非修飾またはおそらくは混合のいずれか：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A translator may incorrectly forward a packet to the same multicast group from which it has received the packet, either directly or through a chain of translators. In that case, the same packet appears several times, originating from different network sources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O翻訳者が誤って直接または翻訳者のチェーンを介して、それがパケットを受信したのと同じマルチキャストグループにパケットを転送することができます。その場合には、同じパケットが異なるネットワークソースから発信、複数回表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Two translators incorrectly set up in parallel, i.e., with the same multicast groups on both sides, would both forward packets from one multicast group to the other. Unidirectional translators would produce two copies; bidirectional translators would form a loop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両側で同じマルチキャストグループと誤って平行に設定O二つの翻訳、すなわち、他に1つのマルチキャストグループからの順方向パケットの両方になります。単方向の翻訳者は、2つのコピーを生成することになります。双方向の翻訳者は、ループを形成することになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A mixer can close a loop by sending to the same transport destination upon which it receives packets, either directly or through another mixer or translator. In this case a source might show up both as an SSRC on a data packet and a CSRC in a mixed data packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oミキサーは、直接または他のミキサーやトランスレータを介して、パケットを受信する際に同一の搬送先へ送信することによって、ループを閉じることができます。この場合、ソースは、混合データパケット内のデータパケットとCSRCにSSRC両方として現れるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A source may discover that its own packets are being looped, or that packets from another source are being looped (a third-party loop). Both loops and collisions in the random selection of a source identifier result in packets arriving with the same SSRC identifier but a different source transport address, which may be that of the end system originating the packet or an intermediate system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースは、独自のパケットがループ、または他のソースからのパケットが（サードパーティのループ）ループされていることをされていることを発見することができます。同じSSRC識別子が、パケット又は中間システムを発信エンドシステムのものとすることができる別のソーストランスポートアドレスで到着したパケットの送信元識別子結果のランダム選択で両方のループと衝突。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, if a source changes its source transport address, it MAY also choose a new SSRC identifier to avoid being interpreted as a looped source. (This is not MUST because in some applications of RTP sources may be expected to change addresses during a session.) Note that if a translator restarts and consequently changes the source transport address (e.g., changes the UDP source port number) on which it forwards packets, then all those packets will appear to receivers to be looped because the SSRC identifiers are applied by the original source and will not change. This problem can be avoided by keeping the source transport address fixed across restarts, but in any case will be resolved after a timeout at the receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースは、そのソーストランスポートアドレスを変更した場合ので、それはまた、ループされたソースとして解釈されるのを避けるために新しいSSRC識別子を選択することができます。 （これは、RTPソースのいくつかのアプリケーションでは、セッション中にアドレスを変更することが予想される必要がありますされていません。）翻訳者が再起動した場合、その結果は、ソーストランスポートアドレスを変更することに注意してください（例えば、UDPの送信元ポート番号を変更する）、その上にそれを転送パケットは、それらすべてのパケットがSSRC識別子は、元のソースによって適用されるため、ループさせるために受信機に表示され、変更されません。この問題は、再起動しても、固定ソーストランスポートアドレスを保つことによって回避することができますが、どのような場合には受信機でのタイムアウト後に解決されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Loops or collisions occurring on the far side of a translator or mixer cannot be detected using the source transport address if all copies of the packets go through the translator or mixer, however, collisions may still be detected when chunks from two RTCP SDES packets contain the same SSRC identifier but different CNAMEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
翻訳者やミキサーの向こう側で発生したループや衝突は、ソーストランスポートアドレスを使用して検出することができないパケットのすべてのコピーは、翻訳者やミキサーを通過する場合は2つのRTCP SDESパケットからのチャンクが含まれている場合、しかし、衝突がまだ検出されてもよいです同じSSRC識別子が異なるのCNAME。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To detect and resolve these conflicts, an RTP implementation MUST include an algorithm similar to the one described below, though the implementation MAY choose a different policy for which packets from colliding third-party sources are kept. The algorithm described below ignores packets from a new source or loop that collide with an established source. It resolves collisions with the participant&#39;s own SSRC identifier by sending an RTCP BYE for the old identifier and choosing a new one. However, when the collision was induced by a loop of the participant&#39;s own packets, the algorithm will choose a new identifier only once and thereafter ignore packets from the looping source transport address. This is required to avoid a flood of BYE packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、サードパーティのソースを衝突からのパケットが保持されている別のポリシーを選択するかもしれませんが、これらの競合を検出し、解決するには、RTPの実装は、以下で説明するのと同様のアルゴリズムを含まなければなりません。以下に説明するアルゴリズムは、確立されたソースと衝突新しいソースまたはループからのパケットを無視します。それは昔の識別子のためにRTCP BYEを送信し、新しいものを選択することによって、参加者自身のSSRC識別子との衝突を解決します。衝突が参加者自身のパケットのループによって誘発されたときしかし、このアルゴリズムは一度だけ新しい識別子を選択すると、その後、ループソース輸送アドレスからのパケットを無視します。これは、BYEパケットの洪水を防ぐために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm requires keeping a table indexed by the source identifier and containing the source transport addresses from the first RTP packet and first RTCP packet received with that identifier, along with other state for that source. Two source transport addresses are required since, for example, the UDP source port numbers may be different on RTP and RTCP packets. However, it may be assumed that the network address is the same in both source transport addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、そのソースの他の状態とともに、ソース識別子によって索引付けテーブルを維持し、第一のRTPパケットとその識別子と受信した最初のRTCPパケットから送信元トランスポート・アドレスを含む必要があります。例えば、UDP送信元ポート番号がRTPおよびRTCPパケットに異なる場合があり、以降二つのソーストランスポートアドレスが要求されています。しかし、ネットワークアドレスが両方のソーストランスポートアドレスで同じであると仮定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each SSRC or CSRC identifier received in an RTP or RTCP packet is looked up in the source identifier table in order to process that data or control information. The source transport address from the packet is compared to the corresponding source transport address in the table to detect a loop or collision if they don&#39;t match. For control packets, each element with its own SSRC identifier, for example an SDES chunk, requires a separate lookup. (The SSRC identifier in a reception report block is an exception because it identifies a source heard by the reporter, and that SSRC identifier is unrelated to the source transport address of the RTCP packet sent by the reporter.) If the SSRC or CSRC is not found, a new entry is created. These table entries are removed when an RTCP BYE packet is received with the corresponding SSRC identifier and validated by a matching source transport address, or after no packets have arrived for a relatively long time (see Section 6.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPまたはRTCPパケットで受信された各SSRCまたはCSRC識別子は、そのデータを処理したり、情報を制御するために、ソース識別子テーブル内で検索されます。パケットからのソーストランスポートアドレスが一致しない場合、ループ又は衝突を検出するために、テーブル内の対応するソーストランスポートアドレスと比較されます。制御パケットは、例えば、自身のSSRC識別子を持つ各要素、SDESチャンクは、別々のルックアップを必要とします。 （それはレポーターによって聞かソースを識別するための受信レポートブロックのSSRC識別子は例外で、そのSSRC識別子は、レポーターによって送信されたRTCPパケットのソーストランスポートアドレスとは無関係である。）SSRCまたはCSRCでない場合見つかった、新しいエントリが作成されます。パケットが比較的に長い時間のために到着しなかった後にRTCP BYEパケットは、対応するSSRC識別子を用いて受信され、一致するソーストランスポートアドレスによって検証されたときに、これらのテーブルエントリが削除される、または（セクション6.2.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if two sources on the same host are transmitting with the same source identifier at the time a receiver begins operation, it would be possible that the first RTP packet received came from one of the sources while the first RTCP packet received came from the other. This would cause the wrong RTCP information to be associated with the RTP data, but this situation should be sufficiently rare and harmless that it may be disregarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信された最初のRTCPパケットが他から来ている間、同じホスト上の2つのソースは、受信機が動作を開始する時点で同じソース識別子と送信している場合、最初のRTPパケットを受信することを可能であることに注意してくださいのいずれかのソースから来。これは間違ったRTCP情報は、RTPデータと関連していることが原因だろうが、この状況では、それは無視することができることを十分に稀で、無害でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to track loops of the participant&#39;s own data packets, the implementation MUST also keep a separate list of source transport addresses (not identifiers) that have been found to be conflicting. As in the source identifier table, two source transport addresses MUST be kept to separately track conflicting RTP and RTCP packets. Note that the conflicting address list should be short, usually empty. Each element in this list stores the source addresses plus the time when the most recent conflicting packet was received. An element MAY be removed from the list when no conflicting packet has arrived from that source for a time on the order of 10 RTCP report intervals (see Section 6.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者自身のデータパケットのループを追跡するためには、実装は、矛盾していることが分かっているソーストランスポートアドレス（ない識別子）の別のリストを維持しなければなりません。ソース識別子テーブルのように、二つのソーストランスポートアドレスは別々に矛盾RTP及びRTCPパケットを追跡するために維持されなければなりません。通常、空、競合アドレスリストを短くする必要があることに注意してください。このリストの各要素には、送信元アドレスに加えて、最新の競合パケットを受信した時刻を格納します。要素が競合するパケットは10のRTCPレポート間隔（6.2節を参照）のオーダーの時間のためにそのソースから到着していないリストから除去することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the algorithm as shown, it is assumed that the participant&#39;s own source identifier and state are included in the source identifier table. The algorithm could be restructured to first make a separate comparison against the participant&#39;s own source identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
示されているようなアルゴリズムのためには、参加者自身のソース識別子と状態がソース識別子テーブルに含まれているものとします。このアルゴリズムは、最初の参加者自身のソース識別子に対して別の比較を行うために再構築することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
if (SSRC or CSRC identifier is not found in the source identifier table) { create a new entry storing the data or control source transport address, the SSRC or CSRC and other state; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（SSRCまたはCSRC識別子は、ソース識別子テーブルで発見されていない）{データまたは制御ソーストランスポートアドレス、SSRCまたはCSRCおよび他の状態を格納する新規エントリを作成する場合、 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Identifier is found in the table */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
else if (table entry was created on receipt of a control packet and this is the first data packet or vice versa) { store the source transport address from this packet; } else if (source transport address from the packet does not match the one saved in the table entry for this identifier) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
そうでなければ（テーブルエントリは、制御パケットの受信時に作成され、この第1のデータパケット又はその逆であるした）{このパケットからのソーストランスポートアドレスを格納する場合、 } {（パケットからのソーストランスポートアドレスは、識別子のテーブルエントリに保存されたものと一致しない）他の場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* An identifier collision or a loop is indicated */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          if (source identifier is not the participant&#39;s own) {
              /* OPTIONAL error counter step */
              if (source identifier is from an RTCP SDES chunk
                  containing a CNAME item that differs from the CNAME
                  in the table entry) {
                  count a third-party collision;
              } else {
                  count a third-party loop;
              }
              abort processing of data packet or control element;
              /* MAY choose a different policy to keep new source */
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* A collision or loop of the participant&#39;s own packets */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          else if (source transport address is found in the list of
                   conflicting data or control source transport
                   addresses) {
              /* OPTIONAL error counter step */
              if (source identifier is not from an RTCP SDES chunk
                  containing a CNAME item or CNAME is the
                  participant&#39;s own) {
                  count occurrence of own traffic looped;
              }
              mark current time in conflicting address list entry;
              abort processing of data packet or control element;
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* New collision, change SSRC identifier */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          else {
              log occurrence of a collision;
              create a new entry in the conflicting data or control
                  source transport address list and mark current time;
              send an RTCP BYE packet with the old SSRC identifier;
              choose a new SSRC identifier;
              create a new entry in the source identifier table with
                  the old SSRC plus the source transport address from
                  the data or control packet being processed;
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this algorithm, packets from a newly conflicting source address will be ignored and packets from the original source address will be kept. If no packets arrive from the original source for an extended period, the table entry will be timed out and the new source will be able to take over. This might occur if the original source detects the collision and moves to a new source identifier, but in the usual case an RTCP BYE packet will be received from the original source to delete the state without having to wait for a timeout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムでは、新たに矛盾する送信元アドレスからのパケットは無視され、元のソースアドレスからのパケットが保持されます。パケットが長期間にわたって元のソースから到着しない場合は、テーブルエントリがタイムアウトになり、新しいソースを引き継ぐことができるようになります。オリジナルのソースが衝突を検出し、新しいソース識別子に移動した場合に発生する可能性がありますが、通常の場合にはRTCP BYEパケットがタイムアウトを待たずに状態を削除するには、元のソースから受信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the original source address was received through a mixer (i.e., learned as a CSRC) and later the same source is received directly, the receiver may be well advised to switch to the new source address unless other sources in the mix would be lost. Furthermore, for applications such as telephony in which some sources such as mobile entities may change addresses during the course of an RTP session, the RTP implementation SHOULD modify the collision detection algorithm to accept packets from the new source transport address. To guard against flip-flopping between addresses if a genuine collision does occur, the algorithm SHOULD include some means to detect this case and avoid switching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
元のソースアドレスがミキサーを介して受信した（すなわち、CSRCとして学習）と後で同じソースを直接受信された場合、受信機は、よく混合物中の他のソースが失われない限り、新たな送信元アドレスに切り替えることをお勧めしてもよいです。また、このようなモバイルエンティティとしていくつかのソースがRTPセッションの途中でアドレスを変更する可能性がある中で、このようなテレフォニーなどのアプリケーションのために、RTPの実装は、新しいソース輸送アドレスからのパケットを受け入れるように衝突検出アルゴリズムを変更する必要があります。本物の衝突が発生した場合のアドレス間のフリップばたつきを防ぐために、アルゴリズムは、このケースを検出してスイッチングを回避するために、いくつかの手段を含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a new SSRC identifier is chosen due to a collision, the candidate identifier SHOULD first be looked up in the source identifier table to see if it was already in use by some other source. If so, another candidate MUST be generated and the process repeated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいSSRC識別子が衝突により選択された場合、候補識別子は最初、それは他のソースによってすでに使用されていたかどうかを確認するためにソース識別子テーブルで検索されるべきである（SHOULD）。その場合は、別の候補を生成しなければならないとプロセスが繰り返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A loop of data packets to a multicast destination can cause severe network flooding. All mixers and translators MUST implement a loop detection algorithm like the one here so that they can break loops. This should limit the excess traffic to no more than one duplicate copy of the original traffic, which may allow the session to continue so that the cause of the loop can be found and fixed. However, in extreme cases where a mixer or translator does not properly break the loop and high traffic levels result, it may be necessary for end systems to cease transmitting data or control packets entirely. This decision may depend upon the application. An error condition SHOULD be indicated as appropriate. Transmission MAY be attempted again periodically after a long, random time (on the order of minutes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストの宛先へのデータパケットのループが深刻なネットワークの氾濫を引き起こす可能性があります。彼らはループを切断できるように、すべてのミキサーと翻訳者はここのようなループ検出アルゴリズムを実装しなければなりません。これは、ループの原因が見つかると固定することができるようにセッションを継続することを可能にする、元のトラフィックの1個以下の重複コピーへの過剰なトラフィックを制限する必要があります。エンドシステムが完全に送信データや制御パケットを停止するためしかし、ミキサーまたは翻訳が正しくループを破壊せず、高いトラフィックレベル、結果極端な場合には、それが必要であってもよいです。この決定は、アプリケーションに依存してもよいです。エラー条件を適宜表示すべきです。トランスミッションは、定期的に（数分程度）長い、ランダムな時間後に再試行されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3 Use with Layered Encodings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3レイヤードエンコーディングを使用します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For layered encodings transmitted on separate RTP sessions (see Section 2.4), a single SSRC identifier space SHOULD be used across the sessions of all layers and the core (base) layer SHOULD be used for SSRC identifier allocation and collision resolution. When a source discovers that it has collided, it transmits an RTCP BYE packet on only the base layer but changes the SSRC identifier to the new value in all layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別々のRTPセッション（セクション2.4を参照）上で送信レイヤード符号化のために、単一のSSRC識別子空間は、すべての層のセッションで使用されるべきであり、コア（ベース）層は、SSRC識別子の割り当てと衝突解決のために使用されるべきです。ソースは、それが衝突したことを検出すると、それだけ、ベース層の上にRTCP BYEパケットを送信するが、全ての層で新しい値にSSRC識別子を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.セキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lower layer protocols may eventually provide all the security services that may be desired for applications of RTP, including authentication, integrity, and confidentiality. These services have been specified for IP in [27]. Since the initial audio and video applications using RTP needed a confidentiality service before such services were available for the IP layer, the confidentiality service described in the next section was defined for use with RTP and RTCP. That description is included here to codify existing practice. New applications of RTP MAY implement this RTP-specific confidentiality service for backward compatibility, and/or they MAY implement alternative security services. The overhead on the RTP protocol for this confidentiality service is low, so the penalty will be minimal if this service is obsoleted by other services in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下位層プロトコルは、最終的には、認証、完全性、機密性など、RTPの用途のために所望され得るすべてのセキュリティサービスを提供することができます。これらのサービスは、[27]にIPのために指定されています。このようなサービスは、IP層のために利用可能であったの前にRTPを使用して、初期のオーディオおよびビデオアプリケーションは、機密性のサービスを必要とするので、次のセクションで説明する機密性サービスは、RTPとRTCPで使用するために定義されました。その説明は、既存の慣行を成文化するためにここに含まれています。 RTPの新しいアプリケーションは、下位互換性のために、このRTP特有の機密性サービスを実装してもよい（MAY）、および/または、それらは、代替セキュリティサービスを実施することができます。この機密性サービスのためのRTPプロトコルのオーバーヘッドが低いため、このサービスは、将来的に他のサービスによって廃止された場合にペナルティが最小限になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternatively, other services, other implementations of services and other algorithms may be defined for RTP in the future. In particular, an RTP profile called Secure Real-time Transport Protocol (SRTP) [28] is being developed to provide confidentiality of the RTP payload while leaving the RTP header in the clear so that link-level header compression algorithms can still operate. It is expected that SRTP will be the correct choice for many applications. SRTP is based on the Advanced Encryption Standard (AES) and provides stronger security than the service described here. No claim is made that the methods presented here are appropriate for a particular security need. A profile may specify which services and algorithms should be offered by applications, and may provide guidance as to their appropriate use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代替的に、他のサービス、サービス及び他のアルゴリズムの他の実装は、将来的にRTPのために定義されてもよいです。そのリンクレベルヘッダ圧縮アルゴリズムが依然として動作することができるようにクリアでRTPヘッダを残しながら、特に、セキュアリアルタイムトランスポートプロトコル（SRTP）と呼ばれるRTPプロファイル[28] RTPペイロードの機密性を提供するために開発されています。 SRTPは、多くのアプリケーションのための正しい選択であることが期待されます。 SRTPは、AES（Advanced Encryption Standard）に基づいており、ここで説明するサービスよりも強力なセキュリティを提供しています。ノークレーム、ここで提示した方法は、特定のセキュリティニーズに適切であると判断されていません。プロファイルには、アプリケーションによって提供されるべきサービスとアルゴリズムを指定することができ、その適切な使用についてのガイダンスを提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key distribution and certificates are outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鍵の配布および証明書は、この文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1 Confidentiality
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1機密性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Confidentiality means that only the intended receiver(s) can decode the received packets; for others, the packet contains no useful information. Confidentiality of the content is achieved by encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機密性は、意図された受信機（単数または複数）は、受信したパケットを復号することができることを意味します。他人のために、パケットは、有用な情報が含まれていません。コンテンツの機密性は、暗号化によって達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When it is desired to encrypt RTP or RTCP according to the method specified in this section, all the octets that will be encapsulated for transmission in a single lower-layer packet are encrypted as a unit. For RTCP, a 32-bit random number redrawn for each unit MUST be prepended to the unit before encryption. For RTP, no prefix is prepended; instead, the sequence number and timestamp fields are initialized with random offsets. This is considered to be a weak initialization vector (IV) because of poor randomness properties. In addition, if the subsequent field, the SSRC, can be manipulated by an enemy, there is further weakness of the encryption method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、このセクションで指定された方法に従って、RTPまたはRTCPを暗号化することが所望される場合、単一の下位層パケットに送信するためにカプセル化されるすべてのオクテットを単位として暗号化されます。 RTCPのために、各ユニットについて再描画32ビットの乱数を暗号化する前に、ユニットの先頭に付加されなければなりません。 RTPの場合は、接頭辞が付加されません。代わりに、シーケンス番号とタイムスタンプフィールドは、ランダムオフセットで初期化されています。これは悪いためランダム特性の弱い初期化ベクトル（IV）であると考えられます。また、後続のフィールド場合、SSRCは、敵によって操作することができ、暗号化方法の更なる弱点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For RTCP, an implementation MAY segregate the individual RTCP packets in a compound RTCP packet into two separate compound RTCP packets, one to be encrypted and one to be sent in the clear. For example, SDES information might be encrypted while reception reports were sent in the clear to accommodate third-party monitors that are not privy to the encryption key. In this example, depicted in Fig. 4, the SDES information MUST be appended to an RR packet with no reports (and the random number) to satisfy the requirement that all compound RTCP packets begin with an SR or RR packet. The SDES CNAME item is required in either the encrypted or unencrypted packet, but not both. The same SDES information SHOULD NOT be carried in both packets as this may compromise the encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPのために、実装は1つが暗号化される、1つは平文で送信される2つの別個の化合物のRTCPパケットに複合RTCPパケット内の個々のRTCPパケットを分離してもよい（MAY）。受信レポートは暗号化キーに関与していないサードパーティ製のモニターに対応するために平文で送信している間例えば、SDES情報は暗号化される可能性があります。この例では、図4に示し、SDES情報は、すべての複合RTCPパケットがSRまたはRRパケットで始まる要件を満たすためにないレポート（乱数）とRRパケットに添付しなければなりません。 SDES CNAME項目は両方ではなく、どちらかの暗号化または暗号化されていないパケットで必要とされます。これは、暗号化を損なうことと同じSDES情報は、両方のパケットで運ばれるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             UDP packet                     UDP packet
   -----------------------------  ------------------------------
   [random][RR][SDES #CNAME ...]  [SR #senderinfo #site1 #site2]
   -----------------------------  ------------------------------
             encrypted                     not encrypted
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#: SSRC identifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
＃：SSRCを特定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Figure 4: Encrypted and non-encrypted RTCP packets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
図4：暗号化と非暗号化されたRTCPパケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The presence of encryption and the use of the correct key are confirmed by the receiver through header or payload validity checks. Examples of such validity checks for RTP and RTCP headers are given in Appendices A.1 and A.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化の存在および正しいキーの使用は、ヘッダやペイロードの妥当性チェックを介して受信することによって確認されます。 RTPとRTCPヘッダのような有効性チェックの例は、付録A.1およびA.2に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To be consistent with existing implementations of the initial specification of RTP in RFC 1889, the default encryption algorithm is the Data Encryption Standard (DES) algorithm in cipher block chaining (CBC) mode, as described in Section 1.1 of RFC 1423 [29], except that padding to a multiple of 8 octets is indicated as described for the P bit in Section 5.1. The initialization vector is zero because random values are supplied in the RTP header or by the random prefix for compound RTCP packets. For details on the use of CBC initialization vectors, see [30].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 1889年RTPの初期仕様の既存の実装と一致するように、デフォルトの暗号化アルゴリズムは、暗号ブロック連鎖（CBC）モードでのデータ暗号化規格（DES）アルゴリズムは、RFC 1423 [29]のセクション1.1に記載されているように、セクション5.1でPビットについて記載したように8つのオクテットの倍数へのパディングを除いて示されています。ランダム値はRTPヘッダ内または複合RTCPパケットのランダム接頭辞によって供給されるので、初期化ベクトルはゼロです。 CBC初期化ベクトルの使用の詳細については、[30]参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations that support the encryption method specified here SHOULD always support the DES algorithm in CBC mode as the default cipher for this method to maximize interoperability. This method was chosen because it has been demonstrated to be easy and practical to use in experimental audio and video tools in operation on the Internet. However, DES has since been found to be too easily broken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで指定された暗号化方式をサポートする実装は、常に相互運用性を最大化するために、このメソッドのデフォルトの暗号としてCBCモードのDESアルゴリズムをサポートする必要があります。インターネット上での操作で実験的なオーディオおよびビデオツールで使いやすく、実用的であることが実証されているので、この方法を選択しました。しかし、DESは、以来、あまりにも簡単に壊れたことが判明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that stronger encryption algorithms such as Triple-DES be used in place of the default algorithm. Furthermore, secure CBC mode requires that the first block of each packet be XORed with a random, independent IV of the same size as the cipher&#39;s block size. For RTCP, this is (partially) achieved by prepending each packet with a 32-bit random number, independently chosen for each packet. For RTP, the timestamp and sequence number start from random values, but consecutive packets will not be independently randomized. It should be noted that the randomness in both cases (RTP and RTCP) is limited. High-security applications SHOULD consider other, more conventional, protection means. Other encryption algorithms MAY be specified dynamically for a session by non-RTP means. In particular, the SRTP profile [28] based on AES is being developed to take into account known plaintext and CBC plaintext manipulation concerns, and will be the correct choice in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなトリプルDESなどの強力な暗号化アルゴリズムがデフォルトのアルゴリズムの代わりに使用することが推奨されます。また、セキュアCBCモードは、各パケットの最初のブロックが暗号のブロックサイズと同じサイズのランダム、独立IVとXORされることが必要です。 RTCPのために、これは、（部分的に）独立して各パケットのために選択された32ビットの乱数、各パケットを付加することによって達成されます。 RTPの場合は、タイムスタンプとシーケンス番号はランダムな値から開始しますが、連続したパケットは、独立して、ランダム化されることはありません。両方の場合（RTPおよびRTCP）におけるランダム性が制限されることに留意すべきです。高セキュリティアプリケーションは、他の、より従来、保護手段を検討すべきです。その他の暗号化アルゴリズムは、非RTP手段によってセッションのために動的に指定することができます。具体的には、AESに基づいてSRTPプロフィール[28]は平文とCBC平文操作の懸念知ら考慮に入れるために開発されている、そして将来的には正しい選択となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an alternative to encryption at the IP level or at the RTP level as described above, profiles MAY define additional payload types for encrypted encodings. Those encodings MUST specify how padding and other aspects of the encryption are to be handled. This method allows encrypting only the data while leaving the headers in the clear for applications where that is desired. It may be particularly useful for hardware devices that will handle both decryption and decoding. It is also valuable for applications where link-level compression of RTP and lower-layer headers is desired and confidentiality of the payload (but not addresses) is sufficient since encryption of the headers precludes compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPレベルで、または上記のようにRTPレベルの暗号化の代替として、プロファイルは、暗号化された符号化のための追加のペイロードタイプを定義することができます。これらのエンコーディングは、パディングと暗号化の他の側面がどのように扱われるかを指定しなければなりません。この方法は、それが望まれる用途に明確にヘッダを残してデータのみを暗号化することができます。これは、復号化及び復号化の両方を処理するハードウェアデバイスのために特に有用であり得ます。それはまた、RTPと下層ヘッダーのリンクレベルの圧縮が望まれる用途のために貴重であり、ヘッダの暗号化、圧縮を妨げるので、ペイロード（ただしアドレス）の機密性は十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2 Authentication and Message Integrity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2認証とメッセージ整合性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authentication and message integrity services are not defined at the RTP level since these services would not be directly feasible without a key management infrastructure. It is expected that authentication and integrity services will be provided by lower layer protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのサービスは、鍵管理インフラストラクチャなしで直接実行可能ではないため、認証とメッセージの完全性サービスは、RTPレベルで定義されていません。認証と整合性サービスが下位層プロトコルによって提供されることが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All transport protocols used on the Internet need to address congestion control in some way [31]. RTP is not an exception, but because the data transported over RTP is often inelastic (generated at a fixed or controlled rate), the means to control congestion in RTP may be quite different from those for other transport protocols such as TCP. In one sense, inelasticity reduces the risk of congestion because the RTP stream will not expand to consume all available bandwidth as a TCP stream can. However, inelasticity also means that the RTP stream cannot arbitrarily reduce its load on the network to eliminate congestion when it occurs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネット上で使用されるすべてのトランスポートプロトコルは、いくつかの方法[31]における輻輳制御に対処する必要があります。 RTPは、例外ではなく、RTPを介して転送データ（固定または制御された速度で生成された）は、多くの場合、非弾性であるため、RTPの輻輳を制御するための手段は、TCPなどの他のトランスポートプロトコルのためのものとは全く異なっていてもよいです。 RTPストリームは、TCPストリームの缶など、すべての利用可能な帯域幅を消費するために拡張しないので、ある意味では、非弾性は、輻輳のリスクを低減します。しかし、非弾性もRTPストリームが任意にそれが発生したときに渋滞を解消するために、ネットワーク上の負荷を軽減することができないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since RTP may be used for a wide variety of applications in many different contexts, there is no single congestion control mechanism that will work for all. Therefore, congestion control SHOULD be defined in each RTP profile as appropriate. For some profiles, it may be sufficient to include an applicability statement restricting the use of that profile to environments where congestion is avoided by engineering. For other profiles, specific methods such as data rate adaptation based on RTCP feedback may be required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは、多くの異なる状況で、広範囲の用途に使用することができるので、すべてのために働くだろう単一の輻輳制御機構はありません。したがって、輻輳制御は、必要に応じて、各RTPプロファイルで定義されるべきです。いくつかのプロファイルでは、混雑が工学によって回避された環境にそのプロファイルの使用を制限適用性ステートメントを含めるのに十分であり得ます。他のプロファイルの場合、このようなRTCPフィードバックに基づいてデータレート適応のような特定の方法が必要とされ得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. RTP over Network and Transport Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ネットワークおよびトランスポートプロトコルの上に11 RTP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes issues specific to carrying RTP packets within particular network and transport protocols. The following rules apply unless superseded by protocol-specific definitions outside this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、特定のネットワークとトランスポートプロトコル内のRTPパケットを運ぶに固有の問題について説明します。本明細書外部プロトコル固有の定義に取って代わらない限り、以下の規則が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP relies on the underlying protocol(s) to provide demultiplexing of RTP data and RTCP control streams. For UDP and similar protocols, RTP SHOULD use an even destination port number and the corresponding RTCP stream SHOULD use the next higher (odd) destination port number. For applications that take a single port number as a parameter and derive the RTP and RTCP port pair from that number, if an odd number is supplied then the application SHOULD replace that number with the next lower (even) number to use as the base of the port pair. For applications in which the RTP and RTCP destination port numbers are specified via explicit, separate parameters (using a signaling protocol or other means), the application MAY disregard the restrictions that the port numbers be even/odd and consecutive although the use of an even/odd port pair is still encouraged. The RTP and RTCP port numbers MUST NOT be the same since RTP relies on the port numbers to demultiplex the RTP data and RTCP control streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは、RTPデータとRTCP制御ストリームの逆多重化を提供するために、基本的なプロトコル（単数または複数）に依存しています。 UDPと同様のプロトコルのために、RTPも宛先ポート番号を使用する必要があり、対応するRTCPストリームが次に高い（奇数）の宛先ポート番号を使用すべきです。パラメータとして1つのポート番号を取得し、奇数のベースとして使用する、アプリケーションは、次の下位（偶数）数とその数を置き換える必要が供給されると、その番号からRTPとRTCPポートのペアを導出するためのアプリケーションポートのペア。 RTPとRTCPの宛先ポート番号は、明示的、別々のパラメータで指定されたアプリケーションのために（シグナリングプロトコルまたはその他の手段を使用して）、制限を無視可能性のあるアプリケーションは、ポート番号は偶数/奇数と連続していることが偶数の使用ものの/奇数ポートのペアはまだ奨励されています。 RTPは、RTPデータとRTCP制御ストリームを分離するためのポート番号に依存しているので、RTPとRTCPポート番号が同じであってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a unicast session, both participants need to identify a port pair for receiving RTP and RTCP packets. Both participants MAY use the same port pair. A participant MUST NOT assume that the source port of the incoming RTP or RTCP packet can be used as the destination port for outgoing RTP or RTCP packets. When RTP data packets are being sent in both directions, each participant&#39;s RTCP SR packets MUST be sent to the port that the other participant has specified for reception of RTCP. The RTCP SR packets combine sender information for the outgoing data plus reception report information for the incoming data. If a side is not actively sending data (see Section 6.4), an RTCP RR packet is sent instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユニキャストセッションでは、両方の参加者は、RTP及びRTCPパケットを受信するためのポートのペアを特定する必要があります。両方の参加者は、同じポートのペアを使用するかもしれません。参加者は、着信RTPまたはRTCPパケットの送信元ポートが送信RTPまたはRTCPパケットの宛先ポートとして使用することができると仮定してはいけません。 RTPデータパケットが両方向に送信されている場合、各参加者のRTCP SRパケットは、他の参加者がRTCPの受信のために指定されたポートに送信されなければなりません。 RTCPのSRパケットは、着信データの発信データと受信報告情報の送信者情報を組み合わせます。側が積極的にデータを送信していない場合、RTCPのRRパケットが代わりに送信されます（セクション6.4を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that layered encoding applications (see Section 2.4) use a set of contiguous port numbers. The port numbers MUST be distinct because of a widespread deficiency in existing operating systems that prevents use of the same port with multiple multicast addresses, and for unicast, there is only one permissible address. Thus for layer n, the data port is P + 2n, and the control port is P + 2n + 1. When IP multicast is used, the addresses MUST also be distinct because multicast routing and group membership are managed on an address granularity. However, allocation of contiguous IP multicast addresses cannot be assumed because some groups may require different scopes and may therefore be allocated from different address ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
階層符号化アプリケーションは（2.4節を参照）連続したポート番号のセットを使用することをお勧めします。ポート番号があるため、複数のマルチキャストアドレスと同じポートを使用することを防止する既存のオペレーティングシステムで広く欠乏の別個でなければなりません、そして、ユニキャストのために、唯一の許容アドレスです。従って層のnについて、データポートは、P + 2Nであり、制御ポートは、P + 2N + 1 IPマルチキャストを使用する場合、マルチキャストルーティング及びグループメンバーシップは、アドレス粒状度で管理されているため、アドレスも明確でなければなりません。いくつかのグループは、異なるスコープを必要とするかもしれないのでしかし、連続したIPマルチキャストアドレスの割り当てを想定することができず、したがって、異なるアドレス範囲から割り当てられてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The previous paragraph conflicts with the SDP specification, RFC 2327 [15], which says that it is illegal for both multiple addresses and multiple ports to be specified in the same session description because the association of addresses with ports could be ambiguous. It is intended that this restriction will be relaxed in a revision of RFC 2327 to allow an equal number of addresses and ports to be specified with a one-to-one mapping implied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポートとアドレスの関連付けがあいまいである可能性があるため、複数のアドレスと複数のポートの両方が同一のセッション記述で指定することが違法であることを述べているSDP仕様、RFC 2327 [15]と前の段落の競合。なお、この制限は、暗黙の1対1のマッピングを用いて指定するアドレスとポートの同じ数を可能にするために、RFC 2327の改定に緩和されることが意図されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP data packets contain no length field or other delineation, therefore RTP relies on the underlying protocol(s) to provide a length indication. The maximum length of RTP packets is limited only by the underlying protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPデータパケットは、したがって、RTPは、長さ指標を提供する基本的なプロトコル（単数または複数）に依存して、何の長さフィールドまたは他の描写を含みません。 RTPパケットの最大長さは、基本的なプロトコルのみによって制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If RTP packets are to be carried in an underlying protocol that provides the abstraction of a continuous octet stream rather than messages (packets), an encapsulation of the RTP packets MUST be defined to provide a framing mechanism. Framing is also needed if the underlying protocol may contain padding so that the extent of the RTP payload cannot be determined. The framing mechanism is not defined here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPパケットが連続的なオクテットストリームではなく、メッセージ（パケット）の抽象化を提供しているプロトコルで実施される場合、RTPパケットのカプセル化は、フレーミング機構を提供するために定義されなければなりません。 RTPペイロードの程度を決定することができないように、基礎となるプロトコルはパディングを含んでいてもよい場合フレーミングも必要とされています。フレーミング機構は、ここで定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A profile MAY specify a framing method to be used even when RTP is carried in protocols that do provide framing in order to allow carrying several RTP packets in one lower-layer protocol data unit, such as a UDP packet. Carrying several RTP packets in one network or transport packet reduces header overhead and may simplify synchronization between different streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルは、RTPは、例えばUDPパケットなどの1つ下位層プロトコル・データ・ユニットにいくつかのRTPパケットを運ぶことを可能にするためにフレーミングを提供しないプロトコルで運ばれている場合でも使用されるフレーミング方法を指定するかもしれません。一つのネットワーク又はトランスポートパケット内にいくつかのRTPパケットを搬送するオーバーヘッドヘッダを減らし、異なるストリーム間の同期を単純化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Summary of Protocol Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
プロトコル定数の12まとめ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a summary listing of the constants defined in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、この仕様で定義された定数の要約リストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP payload type (PT) constants are defined in profiles rather than this document. However, the octet of the RTP header which contains the marker bit(s) and payload type MUST avoid the reserved values 200 and 201 (decimal) to distinguish RTP packets from the RTCP SR and RR packet types for the header validation procedure described in Appendix A.1. For the standard definition of one marker bit and a 7-bit payload type field as shown in this specification, this restriction means that payload types 72 and 73 are reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPペイロードタイプ（PT）定数は、プロファイルではなく、本文書で定義されています。しかし、マーカービット（単数または複数）およびペイロードタイプを含むRTPヘッダのオクテットは、付録に記載のヘッダの検証手順のためのRTCP SRとRRパケットタイプからRTPパケットを区別するために予約値200及び201（10進数）を避けなければなりませんA.1。本明細書に示すように、1つのマーカービットと7ビットのペイロードタイプフィールドの標準的な定義のために、この制限は、ペイロードタイプ72及び73は予約されていることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1 RTCP Packet Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1 RTCPパケットタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
abbrev. name value SR sender report 200 RR receiver report 201 SDES source description 202 BYE goodbye 203 APP application-defined 204
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
略語。名前値SR送信者レポート200 RRレシーバレポート201 SDES源説明202 BYEさようなら203 APPのアプリケーション定義204
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These type values were chosen in the range 200-204 for improved header validity checking of RTCP packets compared to RTP packets or other unrelated packets. When the RTCP packet type field is compared to the corresponding octet of the RTP header, this range corresponds to the marker bit being 1 (which it usually is not in data packets) and to the high bit of the standard payload type field being 1 (since the static payload types are typically defined in the low half). This range was also chosen to be some distance numerically from 0 and 255 since all-zeros and all-ones are common data patterns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの型の値は、RTPパケットまたは他の無関係のパケットと比較RTCPパケットの改良されたヘッダの妥当性検査のための範囲200~204内に選択しました。 RTCPパケットタイプフィールドは、RTPヘッダの対応するオクテットを比較すると、この範囲は（マーカービット（それは通常データパケットではない）1であることにし、標準ペイロードタイプフィールドの上位ビットが1であることに相当します静的ペイロードタイプは、典型的には）低い半分で定義されているからです。この範囲はまた、すべてゼロとすべてのものが共通のデータパターンであるので、数値0と255からある程度の距離になるように選択しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since all compound RTCP packets MUST begin with SR or RR, these codes were chosen as an even/odd pair to allow the RTCP validity check to test the maximum number of bits with mask and value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての化合物のRTCPパケットがSRまたはRRで始まらなければならないので、これらのコードは、マスク値を持つビットの最大数をテストするRTCPの有効性チェックを可能にするために偶数/奇数の対として選択しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional RTCP packet types may be registered through IANA (see Section 15).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加RTCPパケットタイプは、IANAによって登録されている場合があります（セクション15を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2 SDES Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2 SDESタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
abbrev. name value END end of SDES list 0 CNAME canonical name 1 NAME user name 2 EMAIL user&#39;s electronic mail address 3 PHONE user&#39;s phone number 4 LOC geographic user location 5 TOOL name of application or tool 6 NOTE notice about the source 7 PRIV private extensions 8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
略語。 SDESリストの名前と値のENDエンド0 CNAME正規名1 NAMEユーザ名2 EMAILユーザの電子メールアドレス3 PHONE源7 PRIVプライベート拡張約8アプリケーションまたはツール6メモ通知のユーザの電話番号4 LOC地理的ユーザ位置5ツール名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional SDES types may be registered through IANA (see Section 15).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加SDESタイプがIANAによって登録されている場合があります（セクション15を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. RTP Profiles and Payload Format Specifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. RTPプロファイルとペイロードフォーマットの仕様
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A complete specification of RTP for a particular application will require one or more companion documents of two types described here: profiles, and payload format specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイル、およびペイロードフォーマットの仕様：特定のアプリケーションのためのRTPの完全な仕様は、一つ以上のコンパニオンここで説明する2種類の書類が必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP may be used for a variety of applications with somewhat differing requirements. The flexibility to adapt to those requirements is provided by allowing multiple choices in the main protocol specification, then selecting the appropriate choices or defining extensions for a particular environment and class of applications in a separate profile document. Typically an application will operate under only one profile in a particular RTP session, so there is no explicit indication within the RTP protocol itself as to which profile is in use. A profile for audio and video applications may be found in the companion RFC 3551. Profiles are typically titled &#34;RTP Profile for ...&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは多少異なる要件を持つ様々な用途に使用することができます。これらの要件に適応する柔軟性を、次いで、主プロトコル仕様で複数の選択肢を可能にする適切な選択肢を選択するか、別のプロファイルドキュメント内のアプリケーションの特定の環境およびクラスの拡張を定義することによって提供されます。典型的には、アプリケーションは、特定のRTPセッションにおいてのみつのプロファイルの下で動作するので、使用中のプロファイルであるようにRTPプロトコル自体内の明示的な指示が存在しません。オーディオおよびビデオアプリケーションのプロファイルは3551.プロファイルは、典型的には、「用... RTPプロファイル」と題しているコンパニオンRFCに見いだすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second type of companion document is a payload format specification, which defines how a particular kind of payload data, such as H.261 encoded video, should be carried in RTP. These documents are typically titled &#34;RTP Payload Format for XYZ Audio/Video Encoding&#34;. Payload formats may be useful under multiple profiles and may therefore be defined independently of any particular profile. The profile documents are then responsible for assigning a default mapping of that format to a payload type value if needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仲間ドキュメントの第二のタイプは、H.261符号化されたビデオのようなペイロードデータの特定の種類は、RTPで運ばれるべき方法を定義するペイロードフォーマット仕様です。これらの文書は、一般的に「XYZオーディオ/ビデオエンコーディングのためのRTPペイロードフォーマット」と題しています。ペイロード・フォーマットは、複数のプロファイルの下で有用であるかもしれない、したがって、任意の特定のプロファイルとは独立して定義されてもよいです。プロフィール文書は、その後、必要に応じて、ペイロードタイプの値にその形式のデフォルトのマッピングを割り当てるための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Within this specification, the following items have been identified for possible definition within a profile, but this list is not meant to be exhaustive:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様書の中で、以下の項目は、プロファイル内で可能な定義のために同定されているが、このリストは網羅的であることを意味するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP data header: The octet in the RTP data header that contains the marker bit and payload type field MAY be redefined by a profile to suit different requirements, for example with more or fewer marker bits (Section 5.3, p. 18).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPデータヘッダ：マーカービットとペイロードタイプフィールドを含むRTPデータヘッダーのオクテットは、より多くのまたはより少ないマーカービット（セクション5.3、P 18）を有する、例えば、異なる要件に合うようにプロファイルによって再定義されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Payload types: Assuming that a payload type field is included, the profile will usually define a set of payload formats (e.g., media encodings) and a default static mapping of those formats to payload type values. Some of the payload formats may be defined by reference to separate payload format specifications. For each payload type defined, the profile MUST specify the RTP timestamp clock rate to be used (Section 5.1, p. 14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ペイロードタイプ：プロファイルは、通常、ペイロードタイプ値にペイロードフォーマット（例えば、メディアエンコーディング）およびそれらのフォーマットのデフォルトの静的マッピングのセットを定義する、ペイロードタイプフィールドが含まれていると仮定します。ペイロードフォーマットのいくつかは、別個のペイロードフォーマット仕様を参照することによって定義することができます。定義された各ペイロードタイプは、RTPタイムスタンプクロックレートを指定しなければならないプロファイル（セクション5.1、P。14）を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP data header additions: Additional fields MAY be appended to the fixed RTP data header if some additional functionality is required across the profile&#39;s class of applications independent of payload type (Section 5.3, p. 18).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPデータヘッダの追加：いくつかの追加機能は、ペイロードタイプ（5.3節、P 18）の独立したアプリケーションのプロファイルのクラスを横切って必要とされる場合、追加のフィールドは、固定されたRTPデータヘッダに付加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP data header extensions: The contents of the first 16 bits of the RTP data header extension structure MUST be defined if use of that mechanism is to be allowed under the profile for implementation-specific extensions (Section 5.3.1, p. 18).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPデータヘッダ拡張子：そのメカニズムの使用は実装固有の拡張（5.3.1節、P 18）のプロファイルの下で許可される場合RTPデータヘッダ拡張構造の最初の16ビットの内容が定義されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP packet types: New application-class-specific RTCP packet types MAY be defined and registered with IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケットタイプ：新しいアプリケーション・クラス固有のRTCPパケットタイプが定義され、IANAに登録されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP report interval: A profile SHOULD specify that the values suggested in Section 6.2 for the constants employed in the calculation of the RTCP report interval will be used. Those are the RTCP fraction of session bandwidth, the minimum report interval, and the bandwidth split between senders and receivers. A profile MAY specify alternate values if they have been demonstrated to work in a scalable manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPのレポート間隔：プロファイルは、RTCPのレポート間隔の計算に使用される定数のセクション6.2で推奨値が使用されることを指定する必要があります。これらは、セッション帯域幅、最小レポート間隔、および送信者と受信者間の帯域幅の分割のRTCPの割合です。彼らはスケーラブルな方法で作業することが実証されている場合、プロファイルは、代替値を指定するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR/RR extension: An extension section MAY be defined for the RTCP SR and RR packets if there is additional information that should be reported regularly about the sender or receivers (Section 6.4.3, p. 42 and 43).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SR / RR延長：延長部、送信者または受信機（セクション6.4.3、P 42及び43）について定期的に報告しなければならない追加情報がある場合RTCP SRとRRパケットのために定義されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES use: The profile MAY specify the relative priorities for RTCP SDES items to be transmitted or excluded entirely (Section 6.3.9); an alternate syntax or semantics for the CNAME item (Section 6.5.1); the format of the LOC item (Section 6.5.5); the semantics and use of the NOTE item (Section 6.5.7); or new SDES item types to be registered with IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDES使用：RTCP SDESアイテムが送信されるか、または完全に排除するためにプロファイルが相対的な優先度を指定は、（セクション6.3.9）。 CNAME項目（セクション6.5.1）のための代替構文または意味論。 LOC項目（セクション6.5.5）の形式。 NOTE項目（6.5.7）の意味と使用。または新しいSDES項目タイプはIANAに登録されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security: A profile MAY specify which security services and algorithms should be offered by applications, and MAY provide guidance as to their appropriate use (Section 9, p. 65).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ：プロファイルは、アプリケーションによって提供されるべきセキュリティサービスとアルゴリズムを指定することができ、その適切な使用（セクション9、P 65）のようなガイダンスを提供するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
String-to-key mapping: A profile MAY specify how a user-provided password or pass phrase is mapped into an encryption key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文字列からキーへのマッピング：プロファイルは、ユーザが提供するパスワードまたはパスフレーズは、暗号化キーにマップされる方法を指定するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion: A profile SHOULD specify the congestion control behavior appropriate for that profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳：プロファイルは、そのプロファイルのための適切な輻輳制御動作を指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Underlying protocol: Use of a particular underlying network or transport layer protocol to carry RTP packets MAY be required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基礎となるプロトコル：RTPパケットを運ぶために、特定の基礎となるネットワークまたはトランスポート層プロトコルの使用が必要とされ得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport mapping: A mapping of RTP and RTCP to transport-level addresses, e.g., UDP ports, other than the standard mapping defined in Section 11, p. 68 may be specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート・マッピング：RTPとRTCPのマッピングはセクション11で定義された標準マッピング、P以外のアドレス、例えば、UDPポート、レベル搬送します。 68を指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encapsulation: An encapsulation of RTP packets may be defined to allow multiple RTP data packets to be carried in one lower-layer packet or to provide framing over underlying protocols that do not already do so (Section 11, p. 69).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カプセル化：RTPパケットのカプセル化は、複数のRTPデータパケット一下位層パケットで搬送されることを可能にするために、またはすでにそうしていない基本的なプロトコル（セクション11、P 69）上フレーミング提供するために定義されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is not expected that a new profile will be required for every application. Within one application class, it would be better to extend an existing profile rather than make a new one in order to facilitate interoperation among the applications since each will typically run under only one profile. Simple extensions such as the definition of additional payload type values or RTCP packet types may be accomplished by registering them through IANA and publishing their descriptions in an addendum to the profile or in a payload format specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいプロファイルがすべてのアプリケーションのために必要とされることが期待されていません。 1つのアプリケーション・クラス内では、既存のプロファイルを拡張するのではなく、それぞれが一般的に一つだけのプロファイルの下で実行されますので、アプリケーション間の相互運用を容易にするために、新しいものを作るために良いだろう。このような追加のペイロードタイプ値またはRTCPパケットタイプの定義のような単純な拡張機能がIANAを介してそれらを登録し、プロファイルまたはペイロードフォーマット仕様で補遺にその説明を公開することによって達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP suffers from the same security liabilities as the underlying protocols. For example, an impostor can fake source or destination network addresses, or change the header or payload. Within RTCP, the CNAME and NAME information may be used to impersonate another participant. In addition, RTP may be sent via IP multicast, which provides no direct means for a sender to know all the receivers of the data sent and therefore no measure of privacy. Rightly or not, users may be more sensitive to privacy concerns with audio and video communication than they have been with more traditional forms of network communication [33]. Therefore, the use of security mechanisms with RTP is important. These mechanisms are discussed in Section 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPは、基礎となるプロトコルと同じセキュリティ負債に苦しんでいます。たとえば、詐欺師が偽のソースまたは宛先ネットワークアドレス、または、ヘッダまたはペイロードを変更することができます。 RTCP内、CNAMEとNAME情報は、他の参加者になりすますために使用されてもよいです。また、RTPは、全ての送信データの受信及びプライバシーの故に何ら対策を知る送信者のための直接的な手段を提供しないIPマルチキャストを介して送信されても​​よいです。当然かどうか、ユーザーが[33]、彼らはネットワーク通信のより伝統的な形式とされているよりも、オーディオおよびビデオ通信とプライバシーの問題に対してより敏感です。したがって、RTPとセキュリティメカニズムの使用が重要です。これらのメカニズムは、セクション9に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP-level translators or mixers may be used to allow RTP traffic to reach hosts behind firewalls. Appropriate firewall security principles and practices, which are beyond the scope of this document, should be followed in the design and installation of these devices and in the admission of RTP applications for use behind the firewall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPレベルのトランスレータやミキサーは、RTPトラフィックがファイアウォールの背後にあるホストに到達させるために使用されてもよいです。このドキュメントの範囲を超えて、適切なファイアウォールセキュリティの原則と慣行は、これらのデバイスの設計と設置で、ファイアウォールの背後に使用するためのRTPアプリケーションの入場に従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional RTCP packet types and SDES item types may be registered through the Internet Assigned Numbers Authority (IANA). Since these number spaces are small, allowing unconstrained registration of new values would not be prudent. To facilitate review of requests and to promote shared use of new types among multiple applications, requests for registration of new values must be documented in an RFC or other permanent and readily available reference such as the product of another cooperative standards body (e.g., ITU-T). Other requests may also be accepted, under the advice of a &#34;designated expert.&#34; (Contact the IANA for the contact information of the current expert.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加RTCPパケットタイプとSDES項目の種類は、Internet Assigned Numbers Authority（IANA）によって登録することができます。これらの数のスペースが小さいので、新しい値の制約のない登録を許可することは賢明ではないでしょう。要求の見直しを容易にするために、複数のアプリケーション間で、新しいタイプの共有利用を促進するために、新しい値を登録するための要求は、そのような別の協同標準化団体の製品としてRFCまたはその他の永久的かつ容易に利用可能な基準に文書化されなければならない（例えば、ITU- T）。その他の要求もの助言の下、受け入れられる「指定の専門家。」 （現在の専門家の連絡先情報については、IANAにお問い合わせください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP profile specifications SHOULD register with IANA a name for the profile in the form &#34;RTP/xxx&#34;, where xxx is a short abbreviation of the profile title. These names are for use by higher-level control protocols, such as the Session Description Protocol (SDP), RFC 2327 [15], to refer to transport methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPプロファイル仕様は、IANAでxxxは、プロファイルのタイトルの短い略称でフォーム「RTP / XXX」、でプロファイルの名前を登録する必要があります。これらの名前は、トランスポート方法を参照するために、そのようなセッション記述プロトコル（SDP）のような、より高いレベルの制御プロトコルによって使用、RFC 2327 [15]のためのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. Intellectual Property Rights Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.知的財産権に関する声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on the IETF&#39;s procedures with respect to rights in standards-track and standards-related documentation can be found in BCP-11. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementors or users of this specification can be obtained from the IETF Secretariat.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、そのような権限下で、ライセンスがたりないかもしれない可能性があるためにどの本書または程度に記載されている技術の実装や使用に関係すると主張される可能性があります任意の知的財産やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能。また、そうした権利を特定するために取り組んできたことを表していないん。スタンダードトラックおよび標準関連文書における権利に関するIETFの手続きの情報は、BCP-11に記載されています。権利の主張のコピーは、出版のために利用可能とライセンスの保証が利用できるようにする、または本仕様の実装者または利用者が、そのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますIETF事務局から。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to practice this standard. Please address the information to the IETF Executive Director.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、その注意にこの標準を実践するために必要な場合があり技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 IETF専務に情​​報を扱ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memorandum is based on discussions within the IETF Audio/Video Transport working group chaired by Stephen Casner and Colin Perkins. The current protocol has its origins in the Network Voice Protocol and the Packet Video Protocol (Danny Cohen and Randy Cole) and the protocol implemented by the vat application (Van Jacobson and Steve McCanne). Christian Huitema provided ideas for the random identifier generator. Extensive analysis and simulation of the timer reconsideration algorithm was done by Jonathan Rosenberg. The additions for layered encodings were specified by Michael Speer and Steve McCanne.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この覚書は、スティーブンCasnerとコリンパーキンスが議長を務めるIETFオーディオ/ビデオ輸送ワーキンググループ内での議論に基づいています。現在のプロトコルは、ネットワーク音声プロトコルとパケットビデオプロトコル（ダニー・コーエンとランディ・コール）とバットアプリケーション（バン・ジェイコブソンとスティーブMcCanne）によって実装されたプロトコルで、その起源を持っています。クリスチャンのHuitemaはランダム識別子生成のためのアイデアを提供しました。タイマー再考アルゴリズムの広範な分析とシミュレーションは、ジョナサン・ローゼンバーグで行われました。層状のエンコーディングの追加はマイケル・シュペーアとスティーブMcCanneによって指定されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A - Algorithms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録A  - アルゴリズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We provide examples of C code for aspects of RTP sender and receiver algorithms. There may be other implementation methods that are faster in particular operating environments or have other advantages. These implementation notes are for informational purposes only and are meant to clarify the RTP specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、RTP送信機と受信機のアルゴリズムの態様のためのCコードの例を提供します。特定の操作環境で高速化され、または他の利点を持っている他の実装方法があるかもしれません。これらのインプリメンテーション・ノートは、情報提供のみを目的としたものであり、RTPの仕様を明確にするために意図されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following definitions are used for all examples; for clarity and brevity, the structure definitions are only valid for 32-bit big-endian (most significant octet first) architectures. Bit fields are assumed to be packed tightly in big-endian bit order, with no additional padding. Modifications would be required to construct a portable implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の定義は、すべての例に使用されます。明快かつ簡潔にするために、構造の定義は、32ビットのビッグエンディアン（最上位オクテット）アーキテクチャでのみ有効です。ビットフィールドを追加せず、パディングと、ビッグエンディアンのビット順に密に充填されているものとします。修正は、ポータブルな実装を構築するために必要とされるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * rtp.h  --  RTP header file
    */
   #include &lt;sys/types.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * The type definitions below are valid for 32-bit architectures and
    * may have to be adjusted for 16- or 64-bit architectures.
    */
   typedef unsigned char  u_int8;
   typedef unsigned short u_int16;
   typedef unsigned int   u_int32;
   typedef          short int16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Current protocol version.
    */
   #define RTP_VERSION    2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define RTP_SEQ_MOD (1&lt;&lt;16)
   #define RTP_MAX_SDES 255      /* maximum text length for SDES */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef enum { RTCP_SR = 200, RTCP_RR = 201, RTCP_SDES = 202, RTCP_BYE = 203, RTCP_APP = 204 } rtcp_type_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedefを列挙{RTCP_SR = 200、RTCP_RR = 201、RTCP_SDES = 202、RTCP_BYE = 203、RTCP_APP = 204} rtcp_type_t。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef enum { RTCP_SDES_END = 0, RTCP_SDES_CNAME = 1,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedefを列挙{RTCP_SDES_END = 0、RTCP_SDES_CNAME = 1、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 RTCP_SDES_NAME = 2, RTCP_SDES_EMAIL = 3, RTCP_SDES_PHONE = 4, RTCP_SDES_LOC = 5, RTCP_SDES_TOOL = 6, RTCP_SDES_NOTE = 7, RTCP_SDES_PRIV = 8 } rtcp_sdes_type_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GTKP_SDES_NAME = 2 GTKP_SDES_EMAYL = 3 GTKP_SDES_FONE = 4 GTKP_SDES_LOS = 5、GTKP_SDES_TOOL = 6 GTKP_SDES_NOTE = 7、8} = GTKP_SDES_PRIV gtkp_sdes_tipe_t。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * RTP data header
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int x:1;         /* header extension flag */
       unsigned int cc:4;        /* CSRC count */
       unsigned int m:1;         /* marker bit */
       unsigned int pt:7;        /* payload type */
       unsigned int seq:16;      /* sequence number */
       u_int32 ts;               /* timestamp */
       u_int32 ssrc;             /* synchronization source */
       u_int32 csrc[1];          /* optional CSRC list */
   } rtp_hdr_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * RTCP common header word
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int count:5;     /* varies by packet type */
       unsigned int pt:8;        /* RTCP packet type */
       u_int16 length;           /* pkt len in words, w/o this word */
   } rtcp_common_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Big-endian mask for version, padding bit and packet type pair
    */
   #define RTCP_VALID_MASK (0xc000 | 0x2000 | 0xfe)
   #define RTCP_VALID_VALUE ((RTP_VERSION &lt;&lt; 14) | RTCP_SR)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Reception report block
    */
   typedef struct {
       u_int32 ssrc;             /* data source being reported */
       unsigned int fraction:8;  /* fraction lost since last SR/RR */ int lost:24;              /* cumul. no. pkts lost (signed!) */
       u_int32 last_seq;         /* extended last seq. no. received */
       u_int32 jitter;           /* interarrival jitter */
       u_int32 lsr;              /* last SR packet from this source */
       u_int32 dlsr;             /* delay since last SR packet */
   } rtcp_rr_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * SDES item
    */
   typedef struct {
       u_int8 type;              /* type of item (rtcp_sdes_type_t) */
       u_int8 length;            /* length of item (in octets) */
       char data[1];             /* text, not null-terminated */
   } rtcp_sdes_item_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * One RTCP packet
    */
   typedef struct {
       rtcp_common_t common;     /* common header */
       union {
           /* sender report (SR) */
           struct {
               u_int32 ssrc;     /* sender generating this report */
               u_int32 ntp_sec;  /* NTP timestamp */
               u_int32 ntp_frac;
               u_int32 rtp_ts;   /* RTP timestamp */
               u_int32 psent;    /* packets sent */
               u_int32 osent;    /* octets sent */
               rtcp_rr_t rr[1];  /* variable-length list */
           } sr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* reception report (RR) */
           struct {
               u_int32 ssrc;     /* receiver generating this report */
               rtcp_rr_t rr[1];  /* variable-length list */
           } rr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* source description (SDES) */
           struct rtcp_sdes {
               u_int32 src;      /* first SSRC/CSRC */
               rtcp_sdes_item_t item[1]; /* list of SDES items */
           } sdes;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* BYE */
           struct {
               u_int32 src[1];   /* list of sources */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* can&#39;t express trailing text for reason */
           } bye;
       } r;
   } rtcp_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef struct rtcp_sdes rtcp_sdes_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedefは構造体rtcp_sdes rtcp_sdes_t。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Per-source state information
    */
   typedef struct {
       u_int16 max_seq;        /* highest seq. number seen */
       u_int32 cycles;         /* shifted count of seq. number cycles */
       u_int32 base_seq;       /* base seq number */
       u_int32 bad_seq;        /* last &#39;bad&#39; seq number + 1 */
       u_int32 probation;      /* sequ. packets till source is valid */
       u_int32 received;       /* packets received */
       u_int32 expected_prior; /* packet expected at last interval */
       u_int32 received_prior; /* packet received at last interval */
       u_int32 transit;        /* relative trans time for prev pkt */
       u_int32 jitter;         /* estimated jitter */
       /* ... */
   } source;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1 RTP Data Header Validity Checks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1 RTPデータヘッダの妥当性チェック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RTP receiver should check the validity of the RTP header on incoming packets since they might be encrypted or might be from a different application that happens to be misaddressed. Similarly, if encryption according to the method described in Section 9 is enabled, the header validity check is needed to verify that incoming packets have been correctly decrypted, although a failure of the header validity check (e.g., unknown payload type) may not necessarily indicate decryption failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP受信機は、それらが暗号化されるかもしれないので、着信パケットにRTPヘッダの妥当性を確認する必要があり、またはmisaddressedするたまたま異なるアプリケーションからかもしれません。項9に記載の方法に従って暗号化が有効になっている場合、ヘッダ妥当性チェック（例えば、未知のペイロードタイプ）の故障は、必ずしも示していないかもしれないが、同様に、ヘッダの妥当性チェックは、着信パケットが正しく復号されていることを確認するために必要とされます復号化に失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Only weak validity checks are possible on an RTP data packet from a source that has not been heard before:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
唯一の弱い妥当性チェックが前に聞いたされていないソースからのRTPデータパケットに可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RTP version field must equal 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RTPバージョンフィールドが2に等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The payload type must be known, and in particular it must not be equal to SR or RR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oペイロードタイプを知る必要があり、特にそれがSRまたはRRに等しくあってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the P bit is set, then the last octet of the packet must contain a valid octet count, in particular, less than the total packet length minus the header size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pビットがセットされている場合、O、パケットの最後のオクテットは、全パケット長マイナスヘッダーサイズ未満の特に有効なオクテット数を、含んでいなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The X bit must be zero if the profile does not specify that the header extension mechanism may be used. Otherwise, the extension length field must be less than the total packet size minus the fixed header length and padding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルはヘッダ拡張メカニズムを使用してもよいことが指定されていない場合はO Xビットはゼロでなければなりません。そうでない場合には、拡張長フィールドは、全パケットサイズマイナス固定ヘッダ長とパディング未満でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The length of the packet must be consistent with CC and payload type (if payloads have a known length).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ペイロードは、既知の長さを持っている場合）Oパケットの長さは、CCおよびペイロードタイプと一致しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last three checks are somewhat complex and not always possible, leaving only the first two which total just a few bits. If the SSRC identifier in the packet is one that has been received before, then the packet is probably valid and checking if the sequence number is in the expected range provides further validation. If the SSRC identifier has not been seen before, then data packets carrying that identifier may be considered invalid until a small number of them arrive with consecutive sequence numbers. Those invalid packets MAY be discarded or they MAY be stored and delivered once validation has been achieved if the resulting delay is acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の三つのチェックはほんの数ビットを合計最初の2つだけを残して、やや複雑ではないことは常に可能です。パケット内のSSRC識別子が以前に受信されたものである場合にはシーケンス番号が予想される範囲さらなる検証を提供している場合、そのパケットはおそらく有効と確認しています。 SSRC識別子が前に見ていない場合は、それらの数が少ない連続したシーケンス番号に到着するまで、その識別子を運ぶデータパケットは無効とみなすことができます。これらの無効なパケットは廃棄され得るか、または得られた遅延が許容可能である場合に検証が達成されると、それらは保存され、送達されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The routine update_seq shown below ensures that a source is declared valid only after MIN_SEQUENTIAL packets have been received in sequence. It also validates the sequence number seq of a newly received packet and updates the sequence state for the packet&#39;s source in the structure to which s points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下記に示すルーチンUPDATE_SEQは、ソースがMIN_SEQUENTIALパケットが順番に受信された後にのみ有効と宣言されていることを保証します。また、新たに受信したパケットのシーケンス番号の配列を検証し、ポイントをSに構造におけるパケットのソースの配列状態を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a new source is heard for the first time, that is, its SSRC identifier is not in the table (see Section 8.2), and the per-source state is allocated for it, s-&gt;probation is set to the number of sequential packets required before declaring a source valid (parameter MIN_SEQUENTIAL) and other variables are initialized:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいソースを初めて聞いているとき、つまり、そのSSRC識別子がテーブルにない（8.2節を参照）、およびごとのソースの状態はS-&gt;保護観察は、シーケンシャルの数に設定され、それに割り当てられています有効なソース（パラメータMIN_SEQUENTIAL）および他の変数を宣言する前に必要なパケットが初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      init_seq(s, seq);
      s-&gt;max_seq = seq - 1;
      s-&gt;probation = MIN_SEQUENTIAL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A non-zero s-&gt;probation marks the source as not yet valid so the state may be discarded after a short timeout rather than a long one, as discussed in Section 6.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非ゼロS-&gt;は保護観察は、セクション6.2.1で説明したような状態は、短いタイムアウトではなく長いもの後に廃棄することができるように、まだ有効ではないソースをマークします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a source is considered valid, the sequence number is considered valid if it is no more than MAX_DROPOUT ahead of s-&gt;max_seq nor more than MAX_MISORDER behind. If the new sequence number is ahead of max_seq modulo the RTP sequence number range (16 bits), but is smaller than max_seq, it has wrapped around and the (shifted) count of sequence number cycles is incremented. A value of one is returned to indicate a valid sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースが有効と見なされた後、それは先にS-&gt; max_seqも背後MAX_MISORDER以上のMAX_DROPOUT以下である場合、シーケンス番号が有効であるとみなされます。新しいシーケンス番号が先max_seqを法のRTPシーケンス番号の範囲（16ビット）ですが、max_seqよりも小さい場合、それは周りに包まれており、シーケンス番号サイクルの（シフト）カウントがインクリメントされます。 1の値は、有効なシーケンス番号を示すために返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, the value zero is returned to indicate that the validation failed, and the bad sequence number plus 1 is stored. If the next packet received carries the next higher sequence number, it is considered the valid start of a new packet sequence presumably caused by an extended dropout or a source restart. Since multiple complete sequence number cycles may have been missed, the packet loss statistics are reset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そうでない場合、値ゼロは、検証が失敗したことを示すために戻され、そして1プラス不良シーケンス番号が格納されます。受け取った次のパケットが次に高いシーケンス番号を運ぶ場合、それはおそらく、拡張ドロップアウトやソースの再起動によって引き起こされる、新たなパケットシーケンスの有効なスタートと考えられています。複数の完全なシーケンス番号サイクルが見落とされている可能性がありますので、パケット損失の統計がリセットされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typical values for the parameters are shown, based on a maximum misordering time of 2 seconds at 50 packets/second and a maximum dropout of 1 minute. The dropout parameter MAX_DROPOUT should be a small fraction of the 16-bit sequence number space to give a reasonable probability that new sequence numbers after a restart will not fall in the acceptable range for sequence numbers from before the restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメータの典型的な値は50個のパケット/秒と1分の最大ドロップアウトで2秒の最大誤った順序の時間に基づいて、示されています。ドロップアウトパラメータMAX_DROPOUTは、再起動後に新しいシーケンス番号が再起動する前からシーケンス番号の許容範囲内に該当しないという合理的な可能性を与えるために16ビットのシーケンス番号空間のごく一部でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void init_seq(source *s, u_int16 seq)
   {
       s-&gt;base_seq = seq;
       s-&gt;max_seq = seq;
       s-&gt;bad_seq = RTP_SEQ_MOD + 1;   /* so seq == bad_seq is false */
       s-&gt;cycles = 0;
       s-&gt;received = 0;
       s-&gt;received_prior = 0;
       s-&gt;expected_prior = 0;
       /* other initialization */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   int update_seq(source *s, u_int16 seq)
   {
       u_int16 udelta = seq - s-&gt;max_seq;
       const int MAX_DROPOUT = 3000;
       const int MAX_MISORDER = 100;
       const int MIN_SEQUENTIAL = 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*
        * Source is not valid until MIN_SEQUENTIAL packets with
        * sequential sequence numbers have been received.
        */
       if (s-&gt;probation) {
           /* packet is in sequence */
           if (seq == s-&gt;max_seq + 1) {
               s-&gt;probation--;
               s-&gt;max_seq = seq;
               if (s-&gt;probation == 0) {
                   init_seq(s, seq);
                   s-&gt;received++;
                   return 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               }
           } else {
               s-&gt;probation = MIN_SEQUENTIAL - 1;
               s-&gt;max_seq = seq;
           }
           return 0;
       } else if (udelta &lt; MAX_DROPOUT) {
           /* in order, with permissible gap */
           if (seq &lt; s-&gt;max_seq) {
               /*
                * Sequence number wrapped - count another 64K cycle.
                */
               s-&gt;cycles += RTP_SEQ_MOD;
           }
           s-&gt;max_seq = seq;
       } else if (udelta &lt;= RTP_SEQ_MOD - MAX_MISORDER) {
           /* the sequence number made a very large jump */
           if (seq == s-&gt;bad_seq) {
               /*
                * Two sequential packets -- assume that the other side
                * restarted without telling us so just re-sync
                * (i.e., pretend this was the first packet).
                */
               init_seq(s, seq);
           }
           else {
               s-&gt;bad_seq = (seq + 1) &amp; (RTP_SEQ_MOD-1);
               return 0;
           }
       } else {
           /* duplicate or reordered packet */
       }
       s-&gt;received++;
       return 1;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The validity check can be made stronger requiring more than two packets in sequence. The disadvantages are that a larger number of initial packets will be discarded (or delayed in a queue) and that high packet loss rates could prevent validation. However, because the RTCP header validation is relatively strong, if an RTCP packet is received from a source before the data packets, the count could be adjusted so that only two packets are required in sequence. If initial data loss for a few seconds can be tolerated, an application MAY choose to discard all data packets from a source until a valid RTCP packet has been received from that source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
妥当性チェックは、シーケンス内の二つ以上のパケットを必要強くすることができます。欠点は、最初のパケットの数が多いほど、廃棄（またはキューに遅れ）と高いパケット損失率が検証を防ぐことができるとされることがあります。 RTCPパケットは、データパケットの前にソースから受信された場合RTCPヘッダ検証は、比較的強いためにのみ2つのパケットがシーケンスにおいて必要とされるように、しかし、カウントを調整することができました。数秒のための初期データの損失を許容できる場合は、アプリケーションが有効なRTCPパケットがそのソースから受信されるまでのソースからすべてのデータパケットを破棄するように選ぶかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the application and encoding, algorithms may exploit additional knowledge about the payload format for further validation. For payload types where the timestamp increment is the same for all packets, the timestamp values can be predicted from the previous packet received from the same source using the sequence number difference (assuming no change in payload type).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーション及び符号化に応じて、アルゴリズムは、さらなる検証のためにペイロードフォーマットに関する追加の知識を利用してもよいです。タイムスタンプインクリメントは、全てのパケットについて同じであるペイロードタイプのため、タイムスタンプの値は、シーケンス番号の差（ペイロードタイプに変化がないと仮定）を用いて、同じソースから受信した前のパケットから予測することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A strong &#34;fast-path&#34; check is possible since with high probability the first four octets in the header of a newly received RTP data packet will be just the same as that of the previous packet from the same SSRC except that the sequence number will have increased by one. Similarly, a single-entry cache may be used for faster SSRC lookups in applications where data is typically received from one source at a time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高い確率で、新たに受信したRTPデータパケットのヘッダの最初の4つのオクテットは、シーケンス番号がなければならないこと以外は同じSSRCからの前のパケットのそれと全く同じであるので、強い「高速パス」チェックが可能です1つずつ増加。同様に、単一のエントリ・キャッシュは、データは、典型的には、一度に一つのソースから受信されたアプリケーションに速いSSRCルックアップのために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2 RTCP Header Validity Checks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2 RTCPヘッダーの妥当性チェック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following checks should be applied to RTCP packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のチェックは、RTCPパケットに適用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RTP version field must equal 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RTPバージョンフィールドが2に等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The payload type field of the first RTCP packet in a compound packet must be equal to SR or RR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O化合物パケットにおける最初のRTCPパケットのペイロードタイプフィールドは、SRまたはRRに等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The padding bit (P) should be zero for the first packet of a compound RTCP packet because padding should only be applied, if it is needed, to the last packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが必要な場合、パディングは最後のパケットに、適用されなければならないため、パディングビット（P）O複合RTCPパケットの最初のパケットに対してゼロであるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The length fields of the individual RTCP packets must add up to the overall length of the compound RTCP packet as received. This is a fairly strong check.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受け取ったままO個々のRTCPパケットの長さフィールドは、化合物RTCPパケットの全体の長さにならなければなりません。これはかなり強力なチェックです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The code fragment below performs all of these checks. The packet type is not checked for subsequent packets since unknown packet types may be present and should be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のコード断片は、これらのチェックのすべてを行います。未知のパケットタイプが存在してもよく、無視されなければならないので、パケットタイプは、後続のパケットがチェックされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      u_int32 len;        /* length of compound RTCP packet in words */
      rtcp_t *r;          /* RTCP header */
      rtcp_t *end;        /* end of compound RTCP packet */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if ((*(u_int16 *)r &amp; RTCP_VALID_MASK) != RTCP_VALID_VALUE) {
          /* something wrong with packet format */
      }
      end = (rtcp_t *)((u_int32 *)r + len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      do r = (rtcp_t *)((u_int32 *)r + r-&gt;common.length + 1);
      while (r &lt; end &amp;&amp; r-&gt;common.version == 2); if (r != end) {
          /* something wrong with packet format */
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.3 Determining Number of Packets Expected and Lost
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
予想されるパケット数とロストの決定A.3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to compute packet loss rates, the number of RTP packets expected and actually received from each source needs to be known, using per-source state information defined in struct source referenced via pointer s in the code below. The number of packets received is simply the count of packets as they arrive, including any late or duplicate packets. The number of packets expected can be computed by the receiver as the difference between the highest sequence number received (s-&gt;max_seq) and the first sequence number received (s-&gt;base_seq). Since the sequence number is only 16 bits and will wrap around, it is necessary to extend the highest sequence number with the (shifted) count of sequence number wraparounds (s-&gt;cycles). Both the received packet count and the count of cycles are maintained the RTP header validity check routine in Appendix A.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット損失率を計算するために、各ソースから期待されると、実際に受信したRTPパケットの数は、以下のコードでポインタSを介して参照される構造体のソースで定義された単位のソース状態情報を使用して、知られている必要があります。彼らは任意の後半または重複パケットを含め、到着すると、受信したパケットの数は、単にパケットの数です。最高のシーケンス番号との間の差として受信機によって計算することができる予想されるパケットの数は、（S-&gt; max_seq）と第1のシーケンス番号が受信された（S-&gt; base_seq）を与えました。シーケンス番号は16ビットのみであり、ラップアラウンドするので、シーケンス番号ラップアラウンド（S-&gt;サイクル）の（シフト）数と最も高いシーケンス番号を拡張する必要があります。受信したパケット数とサイクル数の両方が付録A.1でRTPヘッダの妥当性チェックルーチンを維持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      extended_max = s-&gt;cycles + s-&gt;max_seq;
      expected = extended_max - s-&gt;base_seq + 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The number of packets lost is defined to be the number of packets expected less the number of packets actually received:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
失われたパケットの数は、実際に受信したパケットの数より少ない予想パケットの数であると定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
lost = expected - s-&gt;received;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
失われた=期待 -  S-&gt;受けました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since this signed number is carried in 24 bits, it should be clamped at 0x7fffff for positive loss or 0x800000 for negative loss rather than wrapping around.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この署名された数は24ビットで搬送されるので、負の損失なく、折り返し用正損失または0x800000ため0x7fffffにクランプされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fraction of packets lost during the last reporting interval (since the previous SR or RR packet was sent) is calculated from differences in the expected and received packet counts across the interval, where expected_prior and received_prior are the values saved when the previous reception report was generated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（前回のSRまたはRRパケットが送信されたので）最後のレポート期間中に失われたパケットの割合は、の違いから計算される予想と前回の受信報告書だったときexpected_priorとreceived_priorは値が保存されている区間、全体でパケットカウントを受け取りました生成されました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      expected_interval = expected - s-&gt;expected_prior;
      s-&gt;expected_prior = expected;
      received_interval = s-&gt;received - s-&gt;received_prior;
      s-&gt;received_prior = s-&gt;received;
      lost_interval = expected_interval - received_interval;
      if (expected_interval == 0 || lost_interval &lt;= 0) fraction = 0;
      else fraction = (lost_interval &lt;&lt; 8) / expected_interval;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting fraction is an 8-bit fixed point number with the binary point at the left edge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
得られた画分は、左端にバイナリポイントと8ビット固定小数点数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4 Generating RTCP SDES Packets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4生成RTCP SDESパケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function builds one SDES chunk into buffer b composed of argc items supplied in arrays type, value and length. It returns a pointer to the next available location within b.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アレイタイプ、値、および長さで供給ARGC項目から構成されるBこの関数は、バッファに1つのSDESチャンクを構築します。それは、B内の次の利用可能な場所へのポインタを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   char *rtp_write_sdes(char *b, u_int32 src, int argc,
                        rtcp_sdes_type_t type[], char *value[],
                        int length[])
   {
       rtcp_sdes_t *s = (rtcp_sdes_t *)b;
       rtcp_sdes_item_t *rsp;
       int i;
       int len;
       int pad;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* SSRC header */
       s-&gt;src = src;
       rsp = &amp;s-&gt;item[0];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* SDES items */
       for (i = 0; i &lt; argc; i++) {
           rsp-&gt;type = type[i];
           len = length[i];
           if (len &gt; RTP_MAX_SDES) {
               /* invalid length, may want to take other action */
               len = RTP_MAX_SDES;
           }
           rsp-&gt;length = len;
           memcpy(rsp-&gt;data, value[i], len);
           rsp = (rtcp_sdes_item_t *)&amp;rsp-&gt;data[len];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* terminate with end marker and pad to next 4-octet boundary */
       len = ((char *) rsp) - b;
       pad = 4 - (len &amp; 0x3);
       b = (char *) rsp;
       while (pad--) *b++ = RTCP_SDES_END;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 return b; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bを返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.5 Parsing RTCP SDES Packets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.5解析RTCP SDESパケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function parses an SDES packet, calling functions find_member() to find a pointer to the information for a session member given the SSRC identifier and member_sdes() to store the new SDES information for that member. This function expects a pointer to the header of the RTCP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、そのメンバーのための新しいSDES情報を格納するために）（SSRC識別子とmember_sdes所与のセッションメンバーのための情報へのポインタを見つけるために）（find_member関数を呼び出す、SDESパケットを解析します。この機能は、RTCPパケットのヘッダへのポインタを受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void rtp_read_sdes(rtcp_t *r)
   {
       int count = r-&gt;common.count;
       rtcp_sdes_t *sd = &amp;r-&gt;r.sdes;
       rtcp_sdes_item_t *rsp, *rspn;
       rtcp_sdes_item_t *end = (rtcp_sdes_item_t *)
                               ((u_int32 *)r + r-&gt;common.length + 1);
       source *s;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       while (--count &gt;= 0) {
           rsp = &amp;sd-&gt;item[0];
           if (rsp &gt;= end) break;
           s = find_member(sd-&gt;src);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           for (; rsp-&gt;type; rsp = rspn ) {
               rspn = (rtcp_sdes_item_t *)((char*)rsp+rsp-&gt;length+2);
               if (rspn &gt;= end) {
                   rsp = rspn;
                   break;
               }
               member_sdes(s, rsp-&gt;type, rsp-&gt;data, rsp-&gt;length);
           }
           sd = (rtcp_sdes_t *)
                ((u_int32 *)sd + (((char *)rsp - (char *)sd) &gt;&gt; 2)+1);
       }
       if (count &gt;= 0) {
           /* invalid packet format */
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.6 Generating a Random 32-bit Identifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ランダムな32ビットの識別子を生成A.6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subroutine generates a random 32-bit identifier using the MD5 routines published in RFC 1321 [32]. The system routines may not be present on all operating systems, but they should serve as hints as to what kinds of information may be used. Other system calls that may be appropriate include o getdomainname(),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のサブルーチンは、RFC 1321 [32]に掲載されたMD5ルーチンを使用してランダムな32ビットの識別子を生成します。システム・ルーチンは、すべてのオペレーティングシステム上に存在しないかもしれませんが、どのような情報の種類を使用することができるよう、彼らはヒントとして役立つはずです。適切であり得る他のシステムコールは、）（Oとのgetdomainnameを含みます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o getwd(), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O getwd（）、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o getrusage().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O GETRUSAGEから（）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Live&#34; video or audio samples are also a good source of random numbers, but care must be taken to avoid using a turned-off microphone or blinded camera as a source [17].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17]「ライブ」の映像や音声のサンプルはまた、乱数の良い情報源ですが、注意がソースとしてオフマイクや盲目のカメラを使用しないように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of this or a similar routine is recommended to generate the initial seed for the random number generator producing the RTCP period (as shown in Appendix A.7), to generate the initial values for the sequence number and timestamp, and to generate SSRC values. Since this routine is likely to be CPU-intensive, its direct use to generate RTCP periods is inappropriate because predictability is not an issue. Note that this routine produces the same result on repeated calls until the value of the system clock changes unless different values are supplied for the type argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この又は類似のルーチンの使用は、シーケンス番号とタイムスタンプの初期値を生成するために、（付録A.7に示すように）RTCP期間を生成する乱数発生器のための初期シードを生成するために、及びSSRC値を生成することが推奨されます。このルーチンは、CPU集約型である可能性が高いので、予測可能性が問題にならないので、RTCP期間を生成するために、その直接の使用が不適切です。異なる値は、型引数に供給されない限り、システム・クロックの値が変化するまで、このルーチンを繰り返し呼び出しで同じ結果をもたらすことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Generate a random 32-bit quantity.
    */
   #include &lt;sys/types.h&gt;   /* u_long */
   #include &lt;sys/time.h&gt;    /* gettimeofday() */
   #include &lt;unistd.h&gt;      /* get..() */
   #include &lt;stdio.h&gt;       /* printf() */
   #include &lt;time.h&gt;        /* clock() */
   #include &lt;sys/utsname.h&gt; /* uname() */
   #include &#34;global.h&#34;      /* from RFC 1321 */
   #include &#34;md5.h&#34;         /* from RFC 1321 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define MD_CTX MD5_CTX #define MDInit MD5Init #define MDUpdate MD5Update #define MDFinal MD5Final
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define MD_CTX MD5_CTXの#define MDInit MD5Initの#define MDUpdate MD5Updateの#define MDFinal MD5Final
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   static u_long md_32(char *string, int length)
   {
       MD_CTX context;
       union {
           char   c[16];
           u_long x[4];
       } digest;
       u_long r;
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
MDInit (&amp;context);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
MDInit（＆コンテキスト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       MDUpdate (&amp;context, string, length);
       MDFinal ((unsigned char *)&amp;digest, &amp;context);
       r = 0;
       for (i = 0; i &lt; 3; i++) {
           r ^= digest.x[i];
       }
       return r;
   }                               /* md_32 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Return random unsigned 32-bit quantity.  Use &#39;type&#39; argument if
    * you need to generate several different values in close succession.
    */
   u_int32 random32(int type)
   {
       struct {
           int     type;
           struct  timeval tv;
           clock_t cpu;
           pid_t   pid;
           u_long  hid;
           uid_t   uid;
           gid_t   gid;
           struct  utsname name;
       } s;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       gettimeofday(&amp;s.tv, 0);
       uname(&amp;s.name);
       s.type = type;
       s.cpu  = clock();
       s.pid  = getpid();
       s.hid  = gethostid();
       s.uid  = getuid();
       s.gid  = getgid();
       /* also: system uptime */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       return md_32((char *)&amp;s, sizeof(s));
   }                               /* random32 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.7 Computing the RTCP Transmission Interval
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
RTCP送信間隔を計算A.7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following functions implement the RTCP transmission and reception rules described in Section 6.2. These rules are coded in several functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の機能は、セクション6.2で説明したRTCP送信および受信のルールを実装します。これらのルールは、いくつかの機能でコード化されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rtcp_interval() computes the deterministic calculated interval, measured in seconds. The parameters are defined in Section 6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O rtcp_interval（）秒単位で測定された決定論的計算された間隔を算出します。パラメータは、6.3節で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OnExpire() is called when the RTCP transmission timer expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP送信タイマが満了した場合）（OnExpire Oが呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OnReceive() is called whenever an RTCP packet is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケットが受信されるたびにO OnReceive（）が呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both OnExpire() and OnReceive() have event e as an argument. This is the next scheduled event for that participant, either an RTCP report or a BYE packet. It is assumed that the following functions are available:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらOnExpire（）およびOnReceive（）は、引数としてイベントeを持っています。これは、その参加者のために次のスケジュールされたイベント、RTCPレポートまたはBYEパケットのいずれかです。以下の機能が利用可能であることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Schedule(time t, event e) schedules an event e to occur at time t. When time t arrives, the function OnExpire is called with e as an argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oスケジュール（時刻t、イベントe）スケジュール時刻tで発生するイベントe。時間tが到着すると、関数OnExpireは、引数として電子と呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Reschedule(time t, event e) reschedules a previously scheduled event e for time t.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O再スケジュール（時刻t、イベントe）は時間t以前にスケジュールされたイベントeを再スケジュールします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SendRTCPReport(event e) sends an RTCP report.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SendRTCPReport（イベントe）はRTCPレポートを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SendBYEPacket(event e) sends a BYE packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SendBYEPacket（イベントe）はBYEパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TypeOfEvent(event e) returns EVENT_BYE if the event being processed is for a BYE packet to be sent, else it returns EVENT_REPORT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
処理されているイベントが送信されるBYEパケットのためであれば、O TypeOfEvent（イベントe）は、EVENT_REPORTを返す他に、EVENT_BYEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PacketType(p) returns PACKET_RTCP_REPORT if packet p is an RTCP report (not BYE), PACKET_BYE if its a BYE RTCP packet, and PACKET_RTP if its a regular RTP data packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PacketType（P）は、パケットpがRTCPレポート（ないBYE）である場合PACKET_RTCP_REPORTを返し、PACKET_BYEそのBYE RTCPパケットであれば、そしてPACKET_RTPその正規のRTPデータパケットであれば。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ReceivedPacketSize() and SentPacketSize() return the size of the referenced packet in octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O ReceivedPacketSize（）とSentPacketSize（）オクテットで参照されるパケットのサイズを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NewMember(p) returns a 1 if the participant who sent packet p is not currently in the member list, 0 otherwise. Note this function is not sufficient for a complete implementation because each CSRC identifier in an RTP packet and each SSRC in a BYE packet should be processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットPを送信した参加者が他のメンバーリスト、0に現在ない場合、O NewMember（p）は1を返します。 BYEパケット内のRTPパケット内の各CSRC識別子と各SSRCを処理しなければならないので、この関数は、完全な実装のためには十分ではないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NewSender(p) returns a 1 if the participant who sent packet p is not currently in the sender sublist of the member list, 0 otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外の場合は0、pはメンバーリストの送信者サブリストには、現在ではありませんパケットを送信した参加者ならば、O NewSender（p）は1を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o AddMember() and RemoveMember() to add and remove participants from the member list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O AddMember（）とRemoveMemberは（）メンバーリストから参加者を追加し、削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o AddSender() and RemoveSender() to add and remove participants from the sender sublist of the member list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O AddSender（）とRemoveSenderは（）メンバーリストの送信者サブリストから参加者を追加し、削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These functions would have to be extended for an implementation that allows the RTCP bandwidth fractions for senders and non-senders to be specified as explicit parameters rather than fixed values of 25% and 75%. The extended implementation of rtcp_interval() would need to avoid division by zero if one of the parameters was zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの機能は、送信者と非送信者のためのRTCP帯域幅画分は、明示的なパラメータではなく、25％及び75％の固定値として指定することを可能にする実装のために拡張しなければなりません。 rtcp_intervalの拡張されたインプリメンテーションは、（）のパラメータのいずれかがゼロであった場合は、ゼロによる除算を回避するために必要であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   double rtcp_interval(int members,
                        int senders,
                        double rtcp_bw,
                        int we_sent,
                        double avg_rtcp_size,
                        int initial)
   {
       /*
        * Minimum average time between RTCP packets from this site (in
        * seconds).  This time prevents the reports from `clumping&#39; when
        * sessions are small and the law of large numbers isn&#39;t helping
        * to smooth out the traffic.  It also keeps the report interval
        * from becoming ridiculously small during transient outages like
        * a network partition.
        */
       double const RTCP_MIN_TIME = 5.;
       /*
        * Fraction of the RTCP bandwidth to be shared among active
        * senders.  (This fraction was chosen so that in a typical
        * session with one or two active senders, the computed report
        * time would be roughly equal to the minimum report time so that
        * we don&#39;t unnecessarily slow down receiver reports.)  The
        * receiver fraction must be 1 - the sender fraction.
        */
       double const RTCP_SENDER_BW_FRACTION = 0.25;
       double const RTCP_RCVR_BW_FRACTION = (1-RTCP_SENDER_BW_FRACTION);
       /*
       /* To compensate for &#34;timer reconsideration&#34; converging to a
        * value below the intended average.
        */
       double const COMPENSATION = 2.71828 - 1.5;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       double t;                   /* interval */
       double rtcp_min_time = RTCP_MIN_TIME;
       int n;                      /* no. of members for computation */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*
        * Very first call at application start-up uses half the min
        * delay for quicker notification while still allowing some time
        * before reporting for randomization and to learn about other
        * sources so the report interval will converge to the correct
        * interval more quickly.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        */
       if (initial) {
           rtcp_min_time /= 2;
       }
       /*
        * Dedicate a fraction of the RTCP bandwidth to senders unless
        * the number of senders is large enough that their share is
        * more than that fraction.
        */
       n = members;
       if (senders &lt;= members * RTCP_SENDER_BW_FRACTION) {
           if (we_sent) {
               rtcp_bw *= RTCP_SENDER_BW_FRACTION;
               n = senders;
           } else {
               rtcp_bw *= RTCP_RCVR_BW_FRACTION;
               n -= senders;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*
        * The effective number of sites times the average packet size is
        * the total number of octets sent when each site sends a report.
        * Dividing this by the effective bandwidth gives the time
        * interval over which those packets must be sent in order to
        * meet the bandwidth target, with a minimum enforced.  In that
        * time interval we send one report so this time is also our
        * average time between reports.
        */
       t = avg_rtcp_size * n / rtcp_bw;
       if (t &lt; rtcp_min_time) t = rtcp_min_time;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*
        * To avoid traffic bursts from unintended synchronization with
        * other sites, we then pick our actual next report interval as a
        * random number uniformly distributed between 0.5*t and 1.5*t.
        */
       t = t * (drand48() + 0.5);
       t = t / COMPENSATION;
       return t;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void OnExpire(event e,
                 int    members,
                 int    senders,
                 double rtcp_bw,
                 int    we_sent,
                 double *avg_rtcp_size, int    *initial,
                 time_tp   tc,
                 time_tp   *tp,
                 int    *pmembers)
   {
       /* This function is responsible for deciding whether to send an
        * RTCP report or BYE packet now, or to reschedule transmission.
        * It is also responsible for updating the pmembers, initial, tp,
        * and avg_rtcp_size state variables.  This function should be
        * called upon expiration of the event timer used by Schedule().
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       double t;     /* Interval */
       double tn;    /* Next transmit time */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* In the case of a BYE, we use &#34;timer reconsideration&#34; to
        * reschedule the transmission of the BYE if necessary */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (TypeOfEvent(e) == EVENT_BYE) {
           t = rtcp_interval(members,
                             senders,
                             rtcp_bw,
                             we_sent,
                             *avg_rtcp_size,
                             *initial);
           tn = *tp + t;
           if (tn &lt;= tc) {
               SendBYEPacket(e);
               exit(1);
           } else {
               Schedule(tn, e);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       } else if (TypeOfEvent(e) == EVENT_REPORT) {
           t = rtcp_interval(members,
                             senders,
                             rtcp_bw,
                             we_sent,
                             *avg_rtcp_size,
                             *initial);
           tn = *tp + t;
           if (tn &lt;= tc) {
               SendRTCPReport(e);
               *avg_rtcp_size = (1./16.)*SentPacketSize(e) +
                   (15./16.)*(*avg_rtcp_size);
               *tp = tc;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               /* We must redraw the interval.  Don&#39;t reuse the
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
one computed above, since its not actually distributed the same, as we are conditioned on it being small enough to cause a packet to be sent */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
そのは実際には同じ分布していないので、我々はそれがパケットを引き起こすのに十分に小さいことを条件としているように、1つが送信されるように、上記計算* /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
t = rtcp_interval(members, senders, rtcp_bw, we_sent, *avg_rtcp_size, *initial);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
T = rtcp_interval（メンバー、送信者、rtcp_bw、we_sent、* avg_rtcp_size、*初期）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               Schedule(t+tc,e);
               *initial = 0;
           } else {
               Schedule(tn, e);
           }
           *pmembers = members;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   void OnReceive(packet p,
                  event e,
                  int *members,
                  int *pmembers,
                  int *senders,
                  double *avg_rtcp_size,
                  double *tp,
                  double tc,
                  double tn)
   {
       /* What we do depends on whether we have left the group, and are
        * waiting to send a BYE (TypeOfEvent(e) == EVENT_BYE) or an RTCP
        * report.  p represents the packet that was just received.  */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (PacketType(p) == PACKET_RTCP_REPORT) {
           if (NewMember(p) &amp;&amp; (TypeOfEvent(e) == EVENT_REPORT)) {
               AddMember(p);
               *members += 1;
           }
           *avg_rtcp_size = (1./16.)*ReceivedPacketSize(p) +
               (15./16.)*(*avg_rtcp_size);
       } else if (PacketType(p) == PACKET_RTP) {
           if (NewMember(p) &amp;&amp; (TypeOfEvent(e) == EVENT_REPORT)) {
               AddMember(p);
               *members += 1;
           }
           if (NewSender(p) &amp;&amp; (TypeOfEvent(e) == EVENT_REPORT)) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               AddSender(p);
               *senders += 1;
           }
       } else if (PacketType(p) == PACKET_BYE) {
           *avg_rtcp_size = (1./16.)*ReceivedPacketSize(p) +
               (15./16.)*(*avg_rtcp_size);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (TypeOfEvent(e) == EVENT_REPORT) {
               if (NewSender(p) == FALSE) {
                   RemoveSender(p);
                   *senders -= 1;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (NewMember(p) == FALSE) {
                   RemoveMember(p);
                   *members -= 1;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               if (*members &lt; *pmembers) {
                   tn = tc +
                       (((double) *members)/(*pmembers))*(tn - tc);
                   *tp = tc -
                       (((double) *members)/(*pmembers))*(tc - *tp);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   /* Reschedule the next report for time tn */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   Reschedule(tn, e);
                   *pmembers = *members;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 } else if (TypeOfEvent(e) == EVENT_BYE) { *members += 1; } } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}そうであれば（TypeOfEvent（E）== EVENT_BYE）{*メンバー+ = 1; }}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.8 Estimating the Interarrival Jitter
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
interarrivalジッタの推定A.8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The code fragments below implement the algorithm given in Section 6.4.1 for calculating an estimate of the statistical variance of the RTP data interarrival time to be inserted in the interarrival jitter field of reception reports. The inputs are r-&gt;ts, the timestamp from the incoming packet, and arrival, the current time in the same units. Here s points to state for the source; s-&gt;transit holds the relative transit time for the previous packet, and s-&gt;jitter holds the estimated jitter. The jitter field of the reception report is measured in timestamp units and expressed as an unsigned integer, but the jitter estimate is kept in a floating point. As each data packet arrives, the jitter estimate is updated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のコード断片は、受信レポートの到着間ジッタフィールドに挿入されるRTPデータ到着間隔時間の統計的分散の推定値を計算するためのセクション6.4.1で指定されたアルゴリズムを実装します。入力は、R-&gt; TS、着信パケットからタイムスタンプと到着、同じ単位で現在の時刻です。ここでソースする状態にポイントをです。 S-&gt;トランジットは、以前のパケットのための相対的な通過時間を保持しており、S-&gt;ジッタは推定ジッタを保持しています。受信レポートのジッタフィールドは、タイムスタンプ単位で測定され、符号なし整数として表現が、ジッタの推定値は、浮動小数点に保持されています。各データパケットが到着すると、ジッタの推定値が更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      int transit = arrival - r-&gt;ts;
      int d = transit - s-&gt;transit;
      s-&gt;transit = transit;
      if (d &lt; 0) d = -d;
      s-&gt;jitter += (1./16.) * ((double)d - s-&gt;jitter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a reception report block (to which rr points) is generated for this member, the current jitter estimate is returned:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信レポートブロック（へRR点）はこのメンバーのために生成された場合、現在のジッタの推定値が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
rr-&gt;jitter = (u_int32) s-&gt;jitter;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RR-&gt;ジッタ=（u_int32）S-&gt;ジッター。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternatively, the jitter estimate can be kept as an integer, but scaled to reduce round-off error. The calculation is the same except for the last line:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あるいは、ジッタ推定値は整数として保持するが、丸め誤差を低減するためにスケーリングすることができます。計算は最後の行を除いて同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
s-&gt;jitter += d - ((s-&gt;jitter + 8) &gt;&gt; 4);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
S-&gt;ジッタ+ = D  - （（S-&gt;ジッタ+ 8）&gt;&gt; 4）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, the estimate is sampled for the reception report as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、推定値は、受信レポートなどのためにサンプリングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
rr-&gt;jitter = s-&gt;jitter &gt;&gt; 4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RR-&gt;ジッタ= S-&gt;ジッタ&gt;&gt; 4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix B - Changes from RFC 1889
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録B  -  RFC 1889からの変更点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most of this RFC is identical to RFC 1889. There are no changes in the packet formats on the wire, only changes to the rules and algorithms governing how the protocol is used. The biggest change is an enhancement to the scalable timer algorithm for calculating when to send RTCP packets:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このRFCのほとんどは、ワイヤ上のパケットフォーマットに変化、プロトコルが使用されている方法に関する規則及びアルゴリズムへの唯一の変更はありませんRFC 1889と同じです。最大の変化は、RTCPパケットを送信する際に計算するためのスケーラブルなタイマーアルゴリズムの拡張機能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The algorithm for calculating the RTCP transmission interval specified in Sections 6.2 and 6.3 and illustrated in Appendix A.7 is augmented to include &#34;reconsideration&#34; to minimize transmission in excess of the intended rate when many participants join a session simultaneously, and &#34;reverse reconsideration&#34; to reduce the incidence and duration of false participant timeouts when the number of participants drops rapidly. Reverse reconsideration is also used to possibly shorten the delay before sending RTCP SR when transitioning from passive receiver to active sender mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O付録A.7のセクション6.2および6.3に指定され、図示RTCP送信間隔を算出するためのアルゴリズムは、「再検討」は、多くの参加者が同時にセッションに参加するときに意図速度を超える送信を最小化するため、及び「逆再検討を含むように拡張されています参加者の数が急激に低下した場合に「偽参加者のタイムアウトの発生率と持続時間を低減します。逆再考はまた、おそらくアクティブ送信者モードにパッシブ受信機からの移行時のRTCP SRを送信する前に遅延を短縮するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 6.3.7 specifies new rules controlling when an RTCP BYE packet should be sent in order to avoid a flood of packets when many participants leave a session simultaneously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部6.3.7は多くの参加者が同時にセッションを離れる際にRTCP BYEパケットは、パケットの洪水を避けるために送られるべきときに制御新しいルールを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The requirement to retain state for inactive participants for a period long enough to span typical network partitions was removed from Section 6.2.1. In a session where many participants join for a brief time and fail to send BYE, this requirement would cause a significant overestimate of the number of participants. The reconsideration algorithm added in this revision compensates for the large number of new participants joining simultaneously when a partition heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O要件は、6.2.1項から削除された典型的なネットワークパーティションをスパンに十分な長さの期間の非アクティブな参加者の状態を保持します。多くの参加者が短時間のために参加し、BYEを送信するために失敗したセッションでは、この要件は、参加者数の大幅な過大評価を引き起こします。この改正で添加再考アルゴリズムがパーティション治癒同時に接合新しい参加者の多数を補償します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that these enhancements only have a significant effect when the number of session participants is large (thousands) and most of the participants join or leave at the same time. This makes testing in a live network difficult. However, the algorithm was subjected to a thorough analysis and simulation to verify its performance. Furthermore, the enhanced algorithm was designed to interoperate with the algorithm in RFC 1889 such that the degree of reduction in excess RTCP bandwidth during a step join is proportional to the fraction of participants that implement the enhanced algorithm. Interoperation of the two algorithms has been verified experimentally on live networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション参加者の数が多い（数千人）で、参加者のほとんどが参加したり、同時に去るときに、これらの機能強化だけ大きな影響を持っていることに留意すべきです。これは、ライブネットワークでテストを困難にします。しかし、このアルゴリズムは、その性能を検証するために徹底的な分析とシミュレーションを行いました。また、拡張アルゴリズムがステップ間に過剰RTCP帯域幅の減少の程度が向上アルゴリズムを実装する参加者の割合に比例している参加するようRFC 1889年アルゴリズムと相互運用するように設計されました。 2つのアルゴリズムの相互運用は、ライブネットワーク上で実験的に検証されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other functional changes were:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の機能の変更は以下のとおりでした：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 6.2.1 specifies that implementations may store only a sampling of the participants&#39; SSRC identifiers to allow scaling to very large sessions. Algorithms are specified in RFC 2762 [21].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部6.2.1の実装は非常に大きなセッションにスケーリングできるように、参加者のSSRC識別子の唯一のサンプリングを格納することができることを指定します。アルゴリズムは、RFC 2762 [21]で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In Section 6.2 it is specified that RTCP sender and non-sender bandwidths may be set as separate parameters of the session rather than a strict percentage of the session bandwidth, and may be set to zero. The requirement that RTCP was mandatory for RTP sessions using IP multicast was relaxed. However, a clarification was also added that turning off RTCP is NOT RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 6.2節では、RTCP送信者と非送信側の帯域幅がセッションではなくセッション帯域幅の厳密なパーセンテージの別個のパラメータとして設定することができ、ゼロに設定されてもよいことが規定されています。 RTCPはIPマルチキャストを使用してRTPセッションのために必須だった要件が緩和しました。しかし、明確化は、RTCPをオフにすることは推奨されていないことを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In Sections 6.2, 6.3.1 and Appendix A.7, it is specified that the fraction of participants below which senders get dedicated RTCP bandwidth changes from the fixed 1/4 to a ratio based on the RTCP sender and non-sender bandwidth parameters when those are given. The condition that no bandwidth is dedicated to senders when there are no senders was removed since that is expected to be a transitory state. It also keeps non-senders from using sender RTCP bandwidth when that is not intended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oセクション6.2、6.3.1および付録A.7では、参加者の割合は、送信者がRTCP送信者と非送信側帯域幅パラメータに基づく比に固定された1/4から専用のRTCP帯域幅変更を取得これを下回ることが指定されていますそれらが与えられているとき。それは一時的な状態であることが予想されるので、何も送信者が存在しない場合、帯域が送信者に捧げていない状態を除去しました。また、それが意図されていない場合、送信者のRTCP帯域幅を使用してから、非送信者を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Also in Section 6.2 it is specified that the minimum RTCP interval may be scaled to smaller values for high bandwidth sessions, and that the initial RTCP delay may be set to zero for unicast sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oはセクション6.2で最小RTCP間隔が高帯域セッションの小さい値にスケーリングすることができること、および初期RTCP遅延がユニキャストセッションのためにゼロに設定されてもよいことが規定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Timing out a participant is to be based on inactivity for a number of RTCP report intervals calculated using the receiver RTCP bandwidth fraction even for active senders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者Oタイミングアウトは、アクティブな送信者のためにも、受信機RTCP帯域幅の割合を用いて計算さRTCPレポート間隔の数のために非アクティブに基づくことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Sections 7.2 and 7.3 specify that translators and mixers should send BYE packets for the sources they are no longer forwarding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oセクション7.2および7.3は、翻訳者とミキサーが、彼らはもはや転送されているソースのBYEパケットを送信することを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Rule changes for layered encodings are defined in Sections 2.4, 6.3.9, 8.3 and 11. In the last of these, it is noted that the address and port assignment rule conflicts with the SDP specification, RFC 2327 [15], but it is intended that this restriction will be relaxed in a revision of RFC 2327.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイヤード符号化のためのOルールの変更はセクション2.4、6.3.9、8.3及びこれらの最後に11で定義され、それが注目されるSDP仕様とアドレスとポート割り当てルールの競合、RFC 2327 [15]、それをこの制限は、RFC 2327の改正で緩和されることが意図されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The convention for using even/odd port pairs for RTP and RTCP in Section 11 was clarified to refer to destination ports. The requirement to use an even/odd port pair was removed if the two ports are specified explicitly. For unicast RTP sessions, distinct port pairs may be used for the two ends (Sections 3, 7.1 and 11).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oセクション11でRTPとRTCPのために偶数/奇数のポートのペアを使用するための規則は、宛先ポートを参照するために明らかになりました。 2つのポートが明示的に指定された場合に偶数/奇数のポートペアを使用する必要性を除去しました。ユニキャストRTPセッションのために、別個のポートのペアは、両端（セクション3、7.1および11）のために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A new Section 10 was added to explain the requirement for congestion control in applications using RTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O新しいセクション10は、RTPを使用したアプリケーションで輻輳制御のための要件を説明するために追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In Section 8.2, the requirement that a new SSRC identifier MUST be chosen whenever the source transport address is changed has been relaxed to say that a new SSRC identifier MAY be chosen. Correspondingly, it was clarified that an implementation MAY choose to keep packets from the new source address rather than the existing source address when an SSRC collision occurs between two other participants, and SHOULD do so for applications such as telephony in which some sources such as mobile entities may change addresses during the course of an RTP session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 8.2節では、ソーストランスポートアドレスが変更されるたびに新しいSSRC識別子を選ばなければなりません要件は、新しいSSRC識別子を選択することができると言うことで緩和されています。これに対応し、それは実装がSSRC衝突が2人の他の参加者の間で発生したときに新しい送信元アドレスではなく、既存の送信元アドレスからのパケットを保持するように選択することができ、例えば、携帯などでいくつかのソースなど、テレフォニーなどのアプリケーションのためにそうすべきであることが明らかになりましたエンティティは、RTPセッションの途中でアドレスを変更することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An indentation bug in the RFC 1889 printing of the pseudo-code for the collision detection and resolution algorithm in Section 8.2 has been corrected by translating the syntax to pseudo C language, and the algorithm has been modified to remove the restriction that both RTP and RTCP must be sent from the same source port number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 8.2節における衝突検出および解決アルゴリズムの疑似コードのRFC 1889印刷における押し込みバグが擬似C言語の構文を変換することにより修正され、アルゴリズムは制限を解除するように改変されたそのRTPの両方とRTCPは、同じ送信元ポート番号から送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The description of the padding mechanism for RTCP packets was clarified and it is specified that padding MUST only be applied to the last packet of a compound RTCP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCPパケットのパディング・メカニズムの説明oを明らかにしたところ、パディングのみ複合RTCPパケットの最後のパケットに適用されなければならないことが規定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In Section A.1, initialization of base_seq was corrected to be seq rather than seq - 1, and the text was corrected to say the bad sequence number plus 1 is stored. The initialization of max_seq and other variables for the algorithm was separated from the text to make clear that this initialization must be done in addition to calling the init_seq() function (and a few words lost in RFC 1889 when processing the document from source to output form were restored).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OセクションA.1では、base_seqの初期化は、配列ではなく配列よりなるように補正された -  1、およびテキストが悪いシーケンス番号を言うために修正されましたプラス1が格納されています。アルゴリズムのmax_seqおよび他の変数の初期化は、明確なこの初期化は、出力にinit_seq（）関数（およびソースからドキュメントを処理するときにRFC 1889で失われたいくつかの単語を呼び出すに加えて行われなければならないことを確認するために、テキストから分離しましたフォーム復元されました）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clamping of number of packets lost in Section A.3 was corrected to use both positive and negative limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OセクションA.3で失われたパケットの数のクランプは、正と負の両方の制限を使用するように修正されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The specification of &#34;relative&#34; NTP timestamp in the RTCP SR section now defines these timestamps to be based on the most common system-specific clock, such as system uptime, rather than on session elapsed time which would not be the same for multiple applications started on the same machine at different times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTCP SRのセクションの「相対」NTPタイムスタンプは、現在、このようなシステムの稼働時間として最も一般的なシステム固有のクロック、上ではなく、複数のアプリケーションのために同じではないであろうセッションの経過時間に基づくように、これらのタイムスタンプを定義する仕様O異なる時間に同じマシン上で起動。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-functional changes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非機能の変更：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is specified that a receiver MUST ignore packets with payload types it does not understand.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O受信機はそれが理解していないペイロードタイプを持つパケットを無視しなければならないことが明記されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In Fig. 2, the floating point NTP timestamp value was corrected, some missing leading zeros were added in a hex number, and the UTC timezone was specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図2では、浮動小数点NTPタイムスタンプ値を補正したO、一部欠落先行ゼロは、進数に加え、UTCタイムゾーンが指定されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The inconsequence of NTP timestamps wrapping around in the year 2036 is explained.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 2036年に折り返しNTPタイムスタンプのinconsequenceについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The policy for registration of RTCP packet types and SDES types was clarified in a new Section 15, IANA Considerations. The suggestion that experimenters register the numbers they need and then unregister those which prove to be unneeded has been removed in favor of using APP and PRIV. Registration of profile names was also specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RTCPパケットの種類とSDESタイプの登録のための政策は、新しいセクション15、IANAの考慮事項に明らかにしました。実験者は、彼らが必要とする番号を登録して、不要であることを証明するものの登録を解除することを提案はAPPとPRIVを使用しての賛成で削除されました。プロファイル名の登録も指定されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The reference for the UTF-8 character set was changed from an X/Open Preliminary Specification to be RFC 2279.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UTF-8文字セットの参照oをRFC 2279であることをX / Openの予備仕様から変更されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The reference for RFC 1597 was updated to RFC 1918 and the reference for RFC 2543 was updated to RFC 3261.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RFC 1597のための参照は、RFC 1918に更新され、RFC 2543のための参照は、RFC 3261に更新されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The last paragraph of the introduction in RFC 1889, which cautioned implementors to limit deployment in the Internet, was removed because it was deemed no longer relevant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはもはや、関連すると考えられたため、インターネットでの展開を制限するために、実装を警告RFC 1889で導入、の最後の段落O、削除されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A non-normative note regarding the use of RTP with Source-Specific Multicast (SSM) was added in Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oソース固有マルチキャスト（SSM）とRTPの使用に関する非規範ノートはセクション6で添加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The definition of &#34;RTP session&#34; in Section 3 was expanded to acknowledge that a single session may use multiple destination transport addresses (as was always the case for a translator or mixer) and to explain that the distinguishing feature of an RTP session is that each corresponds to a separate SSRC identifier space. A new definition of &#34;multimedia session&#34; was added to reduce confusion about the word &#34;session&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3は、単一のセッションは（常にトランスレータやミキサーの場合のように）複数の宛先トランスポート・アドレスを使用してもよいし、RTPセッションの際立った特徴は、ということであることを説明することを確認するために拡大されたの「RTPセッション」の定義Oそれぞれが別々のSSRC識別子空間に相当します。 「マルチメディアセッション」の新しい定義は、単語「セッション」についての混乱を軽減するために追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The meaning of &#34;sampling instant&#34; was explained in more detail as part of the definition of the timestamp field of the RTP header in Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O「サンプリング時点」の意味は、セクション5.1でRTPヘッダのタイムスタンプフィールドの定義の一部としてより詳細に説明しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Small clarifications of the text have been made in several places, some in response to questions from readers. In particular:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oテキストの小さな明確化は、一部の読者からの質問に応じて、いくつかの場所で行われています。特に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- In RFC 1889, the first five words of the second sentence of Section 2.2 were lost in processing the document from source to output form, but are now restored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  RFC 1889年、第2.2節の第二文の最初の5つのワードはソースからの出力形式にドキュメントを処理する際に失われたが、現在は復元されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- A definition for &#34;RTP media type&#34; was added in Section 3 to allow the explanation of multiplexing RTP sessions in Section 5.2 to be more clear regarding the multiplexing of multiple media. That section also now explains that multiplexing multiple sources of the same medium based on SSRC identifiers may be appropriate and is the norm for multicast sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - 「RTPメディアタイプ」の定義は、セクション5.2で多重化RTPセッションの説明は、複数のメディアの多重化に関するより明確にすることができるように、第3節で追加されました。その部分はまた、今SSRC識別子に基づいて、同じ培地の多重化複数のソースが適切であり得ることを説明し、マルチキャストセッションのための標準です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The definition for &#34;non-RTP means&#34; was expanded to include examples of other protocols constituting non-RTP means.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - の定義の非RTP手段を構成する他のプロトコルの例を含むように拡張した「非RTP手段」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The description of the session bandwidth parameter is expanded in Section 6.2, including a clarification that the control traffic bandwidth is in addition to the session bandwidth for the data traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - セッションの帯域幅パラメータの説明は、制御トラフィックの帯域幅は、データトラフィックのためのセッション帯域幅に加えてであることを明確化を含む、セクション6.2で拡張されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The effect of varying packet duration on the jitter calculation was explained in Section 6.4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - ジッタの計算にパケット持続時間を変化させることの効果は、セクション6.4.4で説明しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The method for terminating and padding a sequence of SDES items was clarified in Section 6.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  SDESアイテムのシーケンスを終了し、パディングのための方法は、6.5節で明らかにしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- IPv6 address examples were added in the description of SDES CNAME in Section 6.5.1, and &#34;example.com&#34; was used in place of other example domain names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  IPv6アドレスの例は、6.5.1項でSDES CNAMEの説明に加え、そして「example.com」他の例ドメイン名の代わりに使用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The Security section added a formal reference to IPSEC now that it is available, and says that the confidentiality method defined in this specification is primarily to codify existing practice. It is RECOMMENDED that stronger encryption algorithms such as Triple-DES be used in place of the default algorithm, and noted that the SRTP profile based on AES will be the correct choice in the future. A caution about the weakness of the RTP header as an initialization vector was added. It was also noted that payload-only encryption is necessary to allow for header compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  [セキュリティ]セクションでは、それが利用可能であり、この仕様で定義された機密性の方法は、既存の慣行を成文化するために、主であると言うことになりましたIPSECへの正式な参照を追加しました。このようなトリプルDESなどの強力な暗号化アルゴリズムがデフォルトのアルゴリズムの代わりに使用することを推奨し、AESに基づいてSRTPプロファイルは将来的に正しい選択であることに留意されたいです。初期化ベクトルとしてRTPヘッダの弱点について注意を加えました。それはまた、ペイロードのみが暗号化ヘッダ圧縮を可能にするために必要であることに留意しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The method for partial encryption of RTCP was clarified; in particular, SDES CNAME is carried in only one part when the compound RTCP packet is split.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  RTCPを部分的に暗号化する方法を明らかにしました。化合物RTCPパケットが分割される場合、特に、SDES CNAMEは、ただ1つの部分で行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- It is clarified that only one compound RTCP packet should be sent per reporting interval and that if there are too many active sources for the reports to fit in the MTU, then a subset of the sources should be selected round-robin over multiple intervals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - それだけで一つの化合物RTCPパケットは、報告間隔ごととMTUに合わせてレポートのためにあまりにも多くのアクティブなソースがある場合、その情報源のサブセットは、複数の間隔でラウンドロビンを選択する必要があることを送られるべきであることが明らかになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- A note was added in Appendix A.1 that packets may be saved during RTP header validation and delivered upon success.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - ノートは、パケットがRTPヘッダの検証中に保存し、成功時に送達することができる付録A.1に添加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Section 7.3 now explains that a mixer aggregating SDES packets uses more RTCP bandwidth due to longer packets, and a mixer passing through RTCP naturally sends packets at higher than the single source rate, but both behaviors are valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - セクション7.3は現在、SDESパケットを集約ミキサーはより長いパケットに多くのRTCP帯域幅を使用し、RTCPを通過するミキサーが自然に単一のソースレートよりも高いでパケットを送信しますが、両方の行動が有効であることを説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Section 13 clarifies that an RTP application may use multiple profiles but typically only one in a given session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - セクション13は、RTPアプリケーションが複数のプロファイルが、典型的に、所与のセッション中に一つだけを使用することができることを明確にしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The terms MUST, SHOULD, MAY, etc. are used as defined in RFC 2119.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  RFC 2119で定義されるように用語は、等SHOULD、MAYは、使用されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The bibliography was divided into normative and informative references.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - 参考文献は、規範的で有益な参考文献に分かれていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
リファレンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Normative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
引用規格
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Schulzrinne, H. and S. Casner, &#34;RTP Profile for Audio and Video Conferences with Minimal Control&#34;, RFC 3551, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Schulzrinneと、H.とS. Casner、 &#34;最小量のコントロールがあるオーディオとビデオ会議システムのためのRTPプロフィール&#34;、RFC 3551、2003年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Bradner, S., &#34;Key Words for Use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の &#34;RFCsにおける使用のためのレベルを示すために&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Postel, J., &#34;Internet Protocol&#34;, STD 5, RFC 791, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3]ポステル、J.、 &#34;インターネットプロトコル&#34;、STD 5、RFC 791、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Mills, D., &#34;Network Time Protocol (Version 3) Specification, Implementation and Analysis&#34;, RFC 1305, March 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4]ミルズ、D.、 &#34;ネットワーク時間プロトコル（バージョン3）仕様、実装と分析&#34;、RFC 1305、1992年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Yergeau, F., &#34;UTF-8, a Transformation Format of ISO 10646&#34;, RFC 2279, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Yergeau、F.、 &#34;UTF-8、ISO 10646の変換フォーマット&#34;、RFC 2279、1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Mockapetris, P., &#34;Domain Names - Concepts and Facilities&#34;, STD 13, RFC 1034, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Mockapetris、P.、 &#34;ドメイン名 - 概念および機能&#34;、STD 13、RFC 1034、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Mockapetris, P., &#34;Domain Names - Implementation and Specification&#34;, STD 13, RFC 1035, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Mockapetris、P.、 &#34;ドメイン名 - 実装と仕様&#34;、STD 13、RFC 1035、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Braden, R., &#34;Requirements for Internet Hosts - Application and Support&#34;, STD 3, RFC 1123, October 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8]ブレーデン、R.、 &#34;インターネットホストのための要件 - 、アプリケーションとサポート&#34;、STD 3、RFC 1123、1989年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Resnick, P., &#34;Internet Message Format&#34;, RFC 2822, April 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9]レズニック、P.、 &#34;インターネットメッセージ形式&#34;、RFC 2822、2001年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Informative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Clark, D. and D. Tennenhouse, &#34;Architectural Considerations for a New Generation of Protocols,&#34; in SIGCOMM Symposium on Communications Architectures and Protocols , (Philadelphia, Pennsylvania), pp. 200--208, IEEE Computer Communications Review, Vol. 20(4), September 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10]クラーク、D.とD. Tennenhouse、「プロトコルの新世代のための建築の考慮事項、」SIGCOMM通信アーキテクチャに関するシンポジウムやプロトコル、（ペンシルベニア州フィラデルフィア）、頁インチ200--208、IEEEコンピュータコミュニケーションレビュー、巻。 20（4）、1990年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Schulzrinne, H., &#34;Issues in designing a transport protocol for audio and video conferences and other multiparticipant real-time applications.&#34; expired Internet Draft, October 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Schulzrinneと、H.、「オーディオおよびビデオ会議やその他のmultiparticipantリアルタイムアプリケーションのためのトランスポートプロトコルを設計する上での問題。」期限切れのインターネットドラフト、1993年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Comer, D., Internetworking with TCP/IP , vol. 1. Englewood Cliffs, New Jersey: Prentice Hall, 1991.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12]カマー、D.、TCP / IP、容量とインターネットワーキング。 1.イングルウッドクリフ、ニュージャージー州：プレンティスホール、1991。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M. and E. Schooler, &#34;SIP: Session Initiation Protocol&#34;, RFC 3261, June 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 &#34;SIP：セッション開始プロトコル&#34;、 RFC 3261、2002年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] International Telecommunication Union, &#34;Visual telephone systems and equipment for local area networks which provide a non-guaranteed quality of service&#34;, Recommendation H.323, Telecommunication Standardization Sector of ITU, Geneva, Switzerland, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14]国際電気通信連合、勧告H.323、ITU、ジュネーブ、スイス、2003年7月の電気通信標準化部門「非保証サービスの品質を提供するローカルエリアネットワークのためのビジュアル電話システムおよび機器」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Handley, M. and V. Jacobson, &#34;SDP: Session Description Protocol&#34;, RFC 2327, April 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15]ハンドレー、M.およびV. Jacobsonの &#34;SDP：セッション記述プロトコル&#34;、RFC 2327、1998年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Schulzrinne, H., Rao, A. and R. Lanphier, &#34;Real Time Streaming Protocol (RTSP)&#34;, RFC 2326, April 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] SchulzrinneとH.とラオとA.とR. Lanphier、 &#34;リアルタイムストリーミングプロトコル（RTSP）&#34;、RFC 2326、1998年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Eastlake 3rd, D., Crocker, S. and J. Schiller, &#34;Randomness Recommendations for Security&#34;, RFC 1750, December 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17]イーストレイク3日、D.、クロッカー、S.とJ.シラー、 &#34;セキュリティのためのランダム性に関する推奨事項&#34;、RFC 1750、1994年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] Bolot, J.-C., Turletti, T. and I. Wakeman, &#34;Scalable Feedback Control for Multicast Video Distribution in the Internet&#34;, in SIGCOMM Symposium on Communications Architectures and Protocols, (London, England), pp. 58--67, ACM, August 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信アーキテクチャとプロトコルのSIGCOMMシンポジウム、（ロンドン、イングランド）、頁の「インターネットにおけるマルチキャスト映像配信のためのスケーラブルなフィードバック制御」[18] Bolot、J.-C.、Turletti、T.およびI.ウェイクマン、、。 58--67、ACM、1994年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[19] Busse, I., Deffner, B. and H. Schulzrinne, &#34;Dynamic QoS Control of Multimedia Applications Based on RTP&#34;, Computer Communications , vol. 19, pp. 49--58, January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[19]ブッセ、I.、Deffner、B.およびH. Schulzrinneと、 &#34;RTPに基づいて、マルチメディアアプリケーションの動的QoS制御&#34;、コンピュータ通信、巻。 19頁。49--58、1996年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[20] Floyd, S. and V. Jacobson, &#34;The Synchronization of Periodic Routing Messages&#34;, in SIGCOMM Symposium on Communications Architectures and Protocols (D. P. Sidhu, ed.), (San Francisco, California), pp. 33--44, ACM, September 1993. Also in [34].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[20]フロイド、S.およびV. Jacobsonの、通信アーキテクチャ及びプロトコルにSIGCOMMシンポジウム（DPシドゥ、ED。）、（サンフランシスコ、カリフォルニア州）、PPにおいて、 &#34;周期的ルーティングメッセージの同期&#34;。33--44また、[34]で、ACM、1993年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[21] Rosenberg, J. and H. Schulzrinne, &#34;Sampling of the Group Membership in RTP&#34;, RFC 2762, February 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[21]ローゼンバーグ、J.とH. Schulzrinneと、 &#34;RTPでのグループメンバーシップのサンプリング&#34;、RFC 2762、2000年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[22] Cadzow, J., Foundations of Digital Signal Processing and Data Analysis New York, New York: Macmillan, 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[22] Cadzow、J.、デジタル信号処理とデータ分析ニューヨーク、ニューヨークの基礎：マクミラン、1987。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[23] Hinden, R. and S. Deering, &#34;Internet Protocol Version 6 (IPv6) Addressing Architecture&#34;, RFC 3513, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[23] HindenとR.とS.デアリング、 &#34;インターネットプロトコルバージョン6（IPv6）のアドレス指定アーキテクチャ&#34;、RFC 3513、2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[24] Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G. and E. Lear, &#34;Address Allocation for Private Internets&#34;, RFC 1918, February 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[24] Rekhter、Y.、モスコウィッツ、B.、Karrenberg、D.、デ・グルート、G.、およびE.リア、 &#34;個人的なインターネットのための配分&#34;、RFC 1918、1996年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[25] Lear, E., Fair, E., Crocker, D. and T. Kessler, &#34;Network 10 Considered Harmful (Some Practices Shouldn&#39;t be Codified)&#34;, RFC 1627, July 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[25]リア、E.、フェア、E.、クロッカー、D.とT.ケスラー、 &#34;ネットワーク（いくつかのプラクティスを成文化してはいけません）有害と考えられ10&#34;、RFC 1627、1994年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[26] Feller, W., An Introduction to Probability Theory and its Applications, vol. 1. New York, New York: John Wiley and Sons, third ed., 1968.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[26]フェラー、W.、確率論とその応用、巻の紹介。 1.ニューヨーク、ニューヨーク：ジョン・ワイリー・アンド・サンズ、第三編、1968。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[27] Kent, S. and R. Atkinson, &#34;Security Architecture for the Internet Protocol&#34;, RFC 2401, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[27]ケント、S.とR.アトキンソン、 &#34;インターネットプロトコルのためのセキュリティー体系&#34;、RFC 2401、1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[28] Baugher, M., Blom, R., Carrara, E., McGrew, D., Naslund, M., Norrman, K. and D. Oran, &#34;Secure Real-time Transport Protocol&#34;, Work in Progress, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[28] Baugher、M.、ブロム、R.、カララ、E.、マグリュー、D.、Naslund、M.、Norrman、K.およびD.オラン、 &#34;リアルタイム転送プロトコルセキュア&#34;、進行中で働いて、 2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[29] Balenson, D., &#34;Privacy Enhancement for Internet Electronic Mail: Part III&#34;, RFC 1423, February 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[29] Balenson、D.、 &#34;インターネット電子メールのためのプライバシー増進：パートIII&#34;、RFC 1423、1993年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[30] Voydock, V. and S. Kent, &#34;Security Mechanisms in High-Level Network Protocols&#34;, ACM Computing Surveys, vol. 15, pp. 135-171, June 1983.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[30] Voydock、V.とS.ケント、「ハイレベルネットワークプロトコルのセキュリティメカニズム」、ACMコンピューティング調査、巻。 15頁135から171まで、1983年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[31] Floyd, S., &#34;Congestion Control Principles&#34;, BCP 41, RFC 2914, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[31]フロイド、S.、 &#34;輻輳制御の原理&#34;、BCP 41、RFC 2914、2000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[32] Rivest, R., &#34;The MD5 Message-Digest Algorithm&#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[32]リベスト、R.、 &#34;MD5メッセージダイジェストアルゴリズム&#34;、RFC 1321、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[33] Stubblebine, S., &#34;Security Services for Multimedia Conferencing&#34;, in 16th National Computer Security Conference, (Baltimore, Maryland), pp. 391--395, September 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[33] Stubblebineが、S.、第16回全国コンピュータセキュリティ会議で &#34;マルチメディア会議のためのセキュリティサービス&#34;、（ボルチモア、メリーランド州）、頁。391--395、1993年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[34] Floyd, S. and V. Jacobson, &#34;The Synchronization of Periodic Routing Messages&#34;, IEEE/ACM Transactions on Networking, vol. 2, pp. 122--136, April 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[34]フロイド、S.およびV. Jacobsonの &#34;周期的ルーティングメッセージの同期&#34;、ネットワーク上のIEEE / ACMトランザクション、巻。 2頁。122--136、1994年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Henning Schulzrinne Department of Computer Science Columbia University 1214 Amsterdam Avenue New York, NY 10027 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘニングSchulzrinneとコンピュータサイエンスコロンビア大学の学部1214年アムステルダムアベニュー、ニューヨーク、NY 10027米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: schulzrinne@cs.columbia.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：schulzrinne@cs.columbia.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stephen L. Casner Packet Design 3400 Hillview Avenue, Building 3 Palo Alto, CA 94304 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スティーブンL. Casnerパケットデザイン3400ヒルビュー・アベニュー、3パロアルト、CA 94304米国の構築
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: casner@acm.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：casner@acm.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ron Frederick Blue Coat Systems Inc. 650 Almanor Avenue Sunnyvale, CA 94085 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロン・フレデリック・ブルーコートシステムズ社650 Almanorアベニューサニーベール、CA 94085米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: ronf@bluecoat.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：ronf@bluecoat.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Van Jacobson Packet Design 3400 Hillview Avenue, Building 3 Palo Alto, CA 94304 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヴァンヤコブソンパケットデザイン3400ヒルビュー・アベニュー、3パロアルト、CA 94304米国の構築
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: van@packetdesign.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：van@packetdesign.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
