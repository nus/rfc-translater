<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 4346 - The Transport Layer Security (TLS) Protocol Version 1.1 日本語訳</title>

  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
    <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 4346 - The Transport Layer Security (TLS) Protocol Version 1.1 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc4346">
              https://tools.ietf.org/html/rfc4346
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 4346 - トランスポート層セキュリティ（TLS）プロトコルバージョン1.1</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                          T. Dierks
Request for Comments: 4346                                   Independent
Obsoletes: 2246                                              E. Rescorla
Category: Standards Track                                     RTFM, Inc.
                                                              April 2006
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              The Transport Layer Security (TLS) Protocol
                              Version 1.1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2006）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies Version 1.1 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、トランスポート層セキュリティ（TLS）プロトコルのバージョン1.1を指定します。 TLSプロトコルは、インターネット上の通信のセキュリティを提供します。プロトコルは、クライアント/サーバアプリケーションは、盗聴、改ざん、またはメッセージ偽造を防ぐために設計された方法で通信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................4
      1.1. Differences from TLS 1.0 ...................................5
      1.2. Requirements Terminology ...................................5
   2. Goals ...........................................................5
   3. Goals of This Document ..........................................6
   4. Presentation Language ...........................................6
      4.1. Basic Block Size ...........................................7
      4.2. Miscellaneous ..............................................7
      4.3. Vectors ....................................................7
      4.4. Numbers ....................................................8
      4.5. Enumerateds ................................................8
      4.6. Constructed Types ..........................................9
           4.6.1. Variants ...........................................10
      4.7. Cryptographic Attributes ..................................11
      4.8. Constants .................................................12
   5. HMAC and the Pseudorandom Function .............................12
   6. The TLS Record Protocol ........................................14
      6.1. Connection States .........................................15
      6.2. Record layer ..............................................17
           6.2.1. Fragmentation ......................................17
           6.2.2. Record Compression and Decompression ...............19
           6.2.3. Record Payload Protection ..........................19
                  6.2.3.1. Null or Standard Stream Cipher ............20
                  6.2.3.2. CBC Block Cipher ..........................21
      6.3. Key Calculation ...........................................24
   7. The TLS Handshaking Protocols ..................................24
      7.1. Change Cipher Spec Protocol ...............................25
      7.2. Alert Protocol ............................................26
           7.2.1. Closure Alerts .....................................27
           7.2.2. Error Alerts .......................................28
      7.3. Handshake Protocol Overview ...............................31
      7.4. Handshake Protocol ........................................34
           7.4.1. Hello Messages .....................................35
                  7.4.1.1. Hello request .............................35
                  7.4.1.2. Client Hello ..............................36
                  7.4.1.3. Server Hello ..............................39
           7.4.2. Server Certificate .................................40
           7.4.3. Server Key Exchange Message ........................42
           7.4.4. Certificate request ................................44
           7.4.5. Server Hello Done ..................................46
           7.4.6. Client certificate .................................46
           7.4.7. Client Key Exchange Message ........................47
                  7.4.7.1. RSA Encrypted Premaster Secret Message ....47
                  7.4.7.2. Client Diffie-Hellman Public Value ........50
           7.4.8. Certificate verify .................................50
           7.4.9. Finished ...........................................51
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   8. Cryptographic Computations .....................................52
      8.1. Computing the Master Secret ...............................52
           8.1.1. RSA ................................................53
           8.1.2. Diffie-Hellman .....................................53
   9. Mandatory Cipher Suites ........................................53
   10. Application Data Protocol .....................................53
   11. Security Considerations .......................................53
   12. IANA Considerations ...........................................54
   A. Appendix - Protocol constant values ............................55
           A.1. Record layer .........................................55
           A.2. Change cipher specs message ..........................56
           A.3. Alert messages .......................................56
           A.4. Handshake protocol ...................................57
           A.4.1. Hello messages .....................................57
           A.4.2. Server authentication and key exchange messages ....58
           A.4.3. Client authentication and key exchange messages ....59
           A.4.4.Handshake finalization message ......................60
           A.5. The CipherSuite ......................................60
           A.6. The Security Parameters ..............................63
   B. Appendix - Glossary ............................................64
   C. Appendix - CipherSuite definitions .............................68
   D. Appendix - Implementation Notes ................................69
           D.1 Random Number Generation and Seeding ..................70
           D.2 Certificates and authentication .......................70
           D.3 CipherSuites ..........................................70
   E. Appendix - Backward Compatibility With SSL .....................71
           E.1. Version 2 client hello ...............................72
           E.2. Avoiding man-in-the-middle version rollback ..........74
   F. Appendix - Security analysis ...................................74
           F.1. Handshake protocol ...................................74
           F.1.1. Authentication and key exchange ....................74
           F.1.1.1. Anonymous key exchange ...........................75
           F.1.1.2. RSA key exchange and authentication ..............75
           F.1.1.3. Diffie-Hellman key exchange with authentication ..76
           F.1.2. Version rollback attacks ...........................77
           F.1.3. Detecting attacks against the handshake protocol ...77
           F.1.4. Resuming sessions ..................................78
           F.1.5. MD5 and SHA ........................................78
           F.2. Protecting application data ..........................78
           F.3. Explicit IVs .........................................79
           F.4  Security of Composite Cipher Modes ...................79
           F.5  Denial of Service ....................................80
           F.6. Final notes ..........................................80
   Normative References ..............................................81
   Informative References ............................................82
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The primary goal of the TLS Protocol is to provide privacy and data integrity between two communicating applications. The protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. At the lowest level, layered on top of some reliable transport protocol (e.g., TCP[TCP]), is the TLS Record Protocol. The TLS Record Protocol provides connection security that has two basic properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSプロトコルの主な目的は、2つの通信アプリケーション間のプライバシーとデータの整合性を提供することです。 TLSレコードプロトコルとTLSハンドシェイクプロトコル：プロトコルは二つの層から構成されています。最下位レベルでは、いくつかの信頼性の高いトランスポートプロトコル（例えば、TCP [TCP]）の上に積層、TLSレコード・プロトコルです。 TLSレコードプロトコルは、2つの基本的な性質を持っている接続のセキュリティを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The connection is private. Symmetric cryptography is used for data encryption (e.g., DES [DES], RC4 [SCH] etc.). The keys for this symmetric encryption are generated uniquely for each connection and are based on a secret negotiated by another protocol (such as the TLS Handshake Protocol). The Record Protocol can also be used without encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 接続はプライベートです。対称暗号は、データの暗号化（例えば、DES [DES]、RC4 [SCH]など）のために使用されます。この対称暗号化のための鍵は、接続ごとに固有に生成され、（例えば、TLSハンドシェイクプロトコルのような）別のプロトコルによって交渉秘密に基づいています。レコードプロトコルは、暗号化せずに使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The connection is reliable. Message transport includes a message integrity check using a keyed MAC. Secure hash functions (e.g., SHA, MD5, etc.) are used for MAC computations. The Record Protocol can operate without a MAC, but is generally only used in this mode while another protocol is using the Record Protocol as a transport for negotiating security parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 接続が信頼性があります。メッセージトランスポートは、鍵付きMACを使用して、メッセージの整合性チェックが含まれています。セキュアハッシュ関数（例えば、SHA、MD5など）はMAC計算のために使用されます。レコードプロトコルは、MACなしで動作することができるが、他のプロトコルは、セキュリティパラメータを交渉するためのトランスポートとしてレコードプロトコルを使用している間、一般的にこのモードでのみ使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS Record Protocol is used for encapsulation of various higher-level protocols. One such encapsulated protocol, the TLS Handshake Protocol, allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. The TLS Handshake Protocol provides connection security that has three basic properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSレコードプロトコルは、様々な上位レベルのプロトコルのカプセル化に使用されます。そのようなカプセル化されたプロトコル、TLSハンドシェイクプロトコルは、サーバーとクライアントが互いを認証し、アプリケーションプロトコルは、データの最初のバイトを送信または受信する前に、暗号化アルゴリズムと暗号鍵を交渉することを可能にします。 TLSハンドシェイクプロトコルは、3つの基本的な性質を持っている接続のセキュリティを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The peer&#39;s identity can be authenticated using asymmetric, or public key, cryptography (e.g., RSA [RSA], DSS [DSS], etc.). This authentication can be made optional, but is generally required for at least one of the peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ピアのアイデンティティは、非対称、または公開鍵暗号（たとえば、RSA [RSA]、DSS [DSS]など）を使用して認証することができます。この認証はオプションで行うことができますが、一般的にピアの少なくとも一方のために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The negotiation of a shared secret is secure: the negotiated secret is unavailable to eavesdroppers, and for any authenticated connection the secret cannot be obtained, even by an attacker who can place himself in the middle of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 共有秘密の交渉は安全である：交渉さの秘密は、盗聴者に利用できない、と任意の認証済みの接続のために秘密であっても、接続の途中で自分自身を配置することができ、攻撃者により、得ることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 交渉は信頼性がある：なし攻撃者は、通信の当事者によって検出されることなく交渉コミュニケーションを変更できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One advantage of TLS is that it is application protocol independent. Higher level protocols can layer on top of the TLS Protocol transparently. The TLS standard, however, does not specify how protocols add security with TLS; the decisions on how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left to the judgment of the designers and implementors of protocols that run on top of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの利点の一つは、それが独立したアプリケーションプロトコルであることです。より高いレベルのプロトコルが透過的TLSプロトコルの上の層ができます。 TLS標準は、しかし、プロトコルはTLSを使用してセキュリティを追加する方法を指定しません。 TLSハンドシェイクとどのように交換された認証証明書を解釈するを開始する方法についての決定はTLSの上で動作するプロトコルの設計者と実装者の判断に委ねられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Differences from TLS 1.0
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。 TLS 1.0との違い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a revision of the TLS 1.0 [TLS1.0] protocol, and contains some small security improvements, clarifications, and editorial improvements. The major changes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、TLS 1.0 [TLS1.0]プロトコルの改正で、いくつかの小さなセキュリティの改善、明確化、および編集上の改善点が含まれています。主な変更点は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The implicit Initialization Vector (IV) is replaced with an explicit IV to protect against CBC attacks [CBCATT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 暗黙の初期化ベクトル（IV）はCBC攻撃[CBCATT]から保護するために、明示的なIVに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Handling of padding errors is changed to use the bad_record_mac alert rather than the decryption_failed alert to protect against CBC attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - パディングエラーの取り扱いは、CBC攻撃から保護するために、アラートbad_record_macではなくdecryption_failedアラートを使用するように変更されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- IANA registries are defined for protocol parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  IANAレジストリはプロトコルパラメータに対して定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Premature closes no longer cause a session to be nonresumable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 早期の閉じは、もはやセッションがnonresumableことになりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Additional informational notes were added for various new attacks on TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 追加情報のメモは、TLS上の様々な新しい攻撃のために追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, a number of minor clarifications and editorial improvements were made.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、マイナーの明確化と編集多くの改良が行われました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Requirements Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。要件の用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this document, the keywords &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34; and &#34;MAY&#34; are to be interpreted as described in RFC 2119 [REQ].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書、キーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34; において、および[REQ] RFC 2119に記載されるように解釈されるべきである、 &#34;MAY&#34;、 &#34;SHOULD NOTは&#34; &#34;べきです&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The goals of TLS Protocol, in order of their priority, are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにTLSプロトコルの目標は、その優先度の高い順に、以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Cryptographic security: TLS should be used to establish a secure connection between two parties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.暗号セキュリティ：TLSは、二者間の安全な接続を確立するために使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Interoperability: Independent programmers should be able to develop applications utilizing TLS that can successfully exchange cryptographic parameters without knowledge of one another&#39;s code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.相互運用性：独立したプログラマは成功し、互いのコードの知識がなくても、暗号化パラメータを交換することができTLSを利用するアプリケーションを開発することができるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Extensibility: TLS seeks to provide a framework into which new public key and bulk encryption methods can be incorporated as necessary. This will also accomplish two sub-goals: preventing the need to create a new protocol (and risking the introduction of possible new weaknesses) and avoiding the need to implement an entire new security library.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.拡張性：TLSは、新しい公開鍵とバルク暗号化の方法は、必要に応じて組み込むことができるにフレームワークを提供することを目的とします。これは、2つのサブ目標を達成します：新しいプロトコルを作成する必要が防止（および可能な新しい弱点の導入を危険にさらし）と全体の新しいセキュリティライブラリを実装する必要がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Relative efficiency: Cryptographic operations tend to be highly CPU intensive, particularly public key operations. For this reason, the TLS protocol has incorporated an optional session caching scheme to reduce the number of connections that need to be established from scratch. Additionally, care has been taken to reduce network activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.相対的効率：暗号操作は、特に公開鍵操作、非常にCPU集中する傾向があります。この理由のために、TLSプロトコルは、最初から確立される必要がある接続の数を減少させる任意のセッションキャッシュ方式を組み込んでいます。さらに、ケアはネットワーク活動を減らすためにとられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Goals of This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
このドキュメントの3目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the TLS protocol itself are based on the SSL 3.0 Protocol Specification as published by Netscape. The differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough that TLS 1.1, TLS 1.0, and SSL 3.0 do not interoperate (although each protocol incorporates a mechanism by which an implementation can back down prior versions). This document is intended primarily for readers who will be implementing the protocol and for those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups. For that reason, many of the algorithm-dependent data structures and rules are included in the body of the text (as opposed to in an appendix), providing easier access to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Netscapeが発表され、このドキュメントとTLSプロトコル自体は、SSL 3.0プロトコル仕様に基づいています。このプロトコルとSSL 3.0の違いは劇的ではありませんが、（各プロトコルは実装が以前のバージョンをダウンバックアップすることができる機構を組み込んだが）TLS 1.1、TLS 1.0、およびSSL 3.0を相互運用していないことを十分に重要です。この文書は、主にプロトコルを実装します読者のために、それの暗号解析を行う人のためのものです。仕様では、これを念頭において書かれている、これら二つのグループのニーズを反映することを意図しています。そのため、アルゴリズム依存のデータ構造と規則の多くは、それらへの容易なアクセスを提供し、（付録のではなく）テキストの本文に含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is not intended to supply any details of service definition or of interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、それらが固体安全の維持のために必要とされる、それは政策の選択領域をカバーんが、サービス定義のか、インターフェイス定義のいずれかの詳細を提供するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Presentation Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.プレゼンテーション言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document deals with the formatting of data in an external representation. The following very basic and somewhat casually defined presentation syntax will be used. The syntax draws from several sources in its structure. Although it resembles the programming language &#34;C&#34; in its syntax and XDR [XDR] in both its syntax and intent, it would be risky to draw too many parallels. The purpose of this presentation language is to document TLS only; it has no general application beyond that particular goal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、外部表現内のデータのフォーマットを扱います。以下の非常に基本的な、ややカジュアルに定義されたプレゼンテーション構文が使用されます。構文は、その構造中にいくつかのソースから描画します。それはその構文と意図の両方に[XDR]の構文とXDRでのプログラミング言語「C」に似ているが、あまりにも多くの類似点を描画することは危険だろう。このプレゼンテーション言語の目的にのみTLSを文書化することです。それは、その特定の目標を超えていない一般的なアプリケーションを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Basic Block Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。基本ブロックサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The representation of all data items is explicitly specified. The basic data block size is one byte (i.e., 8 bits). Multiple byte data items are concatenations of bytes, from left to right, from top to bottom. From the bytestream, a multi-byte item (a numeric in the example) is formed (using C notation) by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのデータ項目の表現は、明示的に指定されています。基本的なデータ・ブロック・サイズは、1バイト（すなわち、8ビット）です。上から下へ、左から右への複数バイトのデータ項目は、バイトの連結です。バイトストリームから、マルチバイト項目（例の数値）は、（C表記を使用して）することによって形成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
               ... | byte[n-1];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This byte ordering for multi-byte values is the commonplace network byte order or big endian format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチバイト値のためのこのバイト順は、平凡なネットワークバイト順序またはビッグエンディアン形式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Miscellaneous
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。雑多
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Comments begin with &#34;/*&#34; and end with &#34;*/&#34;.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Optional components are denoted by enclosing them in &#34;[[ ]]&#34; double brackets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションのコンポーネントは、「[[]]」二重括弧で囲んで示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Single-byte entities containing uninterpreted data are of type opaque.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
未解釈のデータを含むシングルバイト実体がタイプで不透明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Vectors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。ベクトル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A vector (single dimensioned array) is a stream of homogeneous data elements. The size of the vector may be specified at documentation time or left unspecified until runtime. In either case, the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type, T&#39;, that is a fixed-length vector of type T is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ベクター（単一寸法のアレイ）は均質のデータ要素のストリームです。ベクトルの大きさは、ドキュメンテーション時に指定されるか、または実行時まで未指定のままにすることができます。いずれの場合においても、長さは、ベクター内のバイト数ではなく、要素の数を宣言する。新しいタイプ、T」を指定するための構文、それはタイプTの固定長ベクトルであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T&#39;[n];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T &#39;[n]は、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here, T&#39; occupies n bytes in the data stream, where n is a multiple of the size of T. The length of the vector is not included in the encoded stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、T」は、nはベクトルの長さを符号化ストリームに含まれていないTのサイズの複数のデータストリームにnバイトを占めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データは9バイトの合計を消費する、三つの連続データムである次の例では、データムは、プロトコルが解釈しない三つの連続バイトであると定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       opaque Datum[3];      /* three uninterpreted bytes */
       Datum Data[9];        /* 3 consecutive 3 byte vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Variable-length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation &lt;floor..ceiling&gt;. When these are encoded, the actual length precedes the vector&#39;s contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector&#39;s specified maximum (ceiling) length. A variable-length vector with an actual length field of zero is referred to as an empty vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
可変長ベクトルは、表記&lt;floor..ceiling&gt;を使用して、包括的、法的な長さの部分範囲を指定することによって定義されます。これらがコード化されている場合、実際の長さはバイトストリームでベクトルのコンテンツに先行します。長さは、ベクトルの指定された最大（天井）の長さを保持するのに必要な数のバイトを消費数の形態であろう。ゼロの実際の長さフィールドを持つ可変長ベクトルは、空ベクターと呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T&#39;&lt;floor..ceiling&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T &#39;&lt;floor..ceiling&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the following example, mandatory is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, sufficient to represent the value 400 (see Section 4.4). On the other hand, longer can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two-byte actual length field prepended to the vector. The length of an encoded vector must be an even multiple of the length of a single element (for example, a 17-byte vector of uint16 would be illegal).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の例では、必須では、不透明なタイプの300と400バイトの間に含んでいなければならないベクトルです。それは空になることはありません。実際の長さフィールドは、2バイト、値400を表現するのに十分なuint16のを、（4.4節を参照）を消費します。一方、長いデータの最大800バイト、または400個のuint16の要素を表すことができ、それが空であってもよいです。そのエンコーディングは、ベクターの先頭に追加2バイトの実際の長さフィールドが含まれます。エンコードされたベクトルの長さは、単一の要素（例えば、uint16の17バイトのベクトルが不正であろう）の長さの偶数倍でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       opaque mandatory&lt;300..400&gt;;
             /* length field is 2 bytes, cannot be empty */
       uint16 longer&lt;0..800&gt;;
             /* zero to 400 16-bit unsigned integers */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4。数字
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed-length series of bytes concatenated as described in Section 4.1 and are also unsigned. The following numeric types are predefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
基本的な数値データ型は、符号なしバイト（uint8の）です。すべての大きな数値データ・タイプは、セクション4.1に記載し、また、符号なしであるように連結されたバイトの固定長シリーズから形成されます。以下の数値型は事前に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       uint8 uint16[2];
       uint8 uint24[3];
       uint8 uint32[4];
       uint8 uint64[8];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All values, here and elsewhere in the specification, are stored in &#34;network&#34; or &#34;big-endian&#34; order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての値は、ここおよび本明細書の他の箇所で、「ネットワーク」または「ビッグエンディアン」の順番で格納されます。ヘクスで表さUINT32 01 02 03 04進値16909060に相当するバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Enumerateds
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5。 、列挙
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An additional sparse data type is available called enum. A field of type enum can only assume the values declared in the definition. Each definition is a different type. Only enumerateds of the same type may be assigned or compared. Every element of an enumerated must be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
追加のまばらなデータ型は、列挙型と呼ば可能です。型列挙型のフィールドが定義のみで宣言された値をとることができます。各定義は異なるタイプです。同じタイプの列挙品目のみが割り当てまたは比較することができます。次の例で示されるように列挙のすべての要素は、値が割り当てられなければなりません。列挙の要素が順序付けされていないので、彼らは任意の順序で、任意の一意の値を割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Enumerateds occupy as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その最大の順序値を定義したと同じように、列挙はバイトストリームのように多くのスペースを占有します。以下の定義は、1バイトのタイプ色のフィールドを運ぶために使用されることを引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { red(3), blue(5), white(7) } Color;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element. In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2, or 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一つは、必要に応じて余分な要素を定義することなく、幅の定義を強制的にその関連タグなしで値を指定することができます。以下の例では、味は、データストリーム内の2つのバイトを消費するだけの値1、2、または4をとることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The names of the elements of an enumeration are scoped within the defined type. In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙の要素の名前は、定義された型内にスコープされています。最初の例では、列挙の2番目の要素への完全修飾参照はColor.blueあろう。割り当てのターゲットがよく指定されている場合、このような資格は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Color color = Color.blue;     /* overspecified, legal */
       Color color = blue;           /* correct, type implicit */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For enumerateds that are never converted to external representation, the numerical information may be omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
外部表現に変換されることはない列挙に関しては、数値情報を省略してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { low, medium, high } Amount;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Constructed Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6。建設タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax for definition is much like that of C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造タイプは便宜のためにプリミティブ型から構築することができます。各仕様は、新しい、ユニークなタイプを宣言します。定義の構文はCのようなくらいです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
         T1 f1;
         T2 f2;
         ...
         Tn fn;
       } [[T]];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fields within a structure may be qualified using the type&#39;s name, with a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration. Structure definitions may be embedded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造内のフィールドは、列挙において利用できるように多くの構文を使用して、タイプの名前を使用して修飾することができます。例えば、T.f2は、以前の宣言の2番目のフィールドを意味します。構造体の定義が埋め込まれていてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1。バリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. There must be a case arm for every element of the enumeration declared in the select. The body of the variant structure may be given a label for reference. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義された構造が環境で利用できる情報に基づいたバリエーションを有することができます。セレクタは、構造が定義可能な変形を定義する列挙型でなければなりません。選択で宣言された列挙のすべての要素のためのケースアームが存在する必要があります。変異体構造の本体は、参照のためにラベルを与えることができます。バリアントは、実行時に選択されるメカニズムは、プレゼンテーションの言語で規定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           T1 f1;
           T2 f2;
           ....
           Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               ....
               case en: Ten;
           } [[fv]];
       } [[Tv]];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { apple, orange } VariantTag;
       struct {
           uint16 number;
           opaque string&lt;0..10&gt;; /* variable length */
       } V1;
       struct {
           uint32 number;
           opaque string[10];    /* fixed length */
       } V2;
       struct {
           select (VariantTag) { /* value of selector is implicit */
               case apple: V1;   /* VariantBody, tag = apple */
               case orange: V2;  /* VariantBody, tag = orange */
           } variant_body;       /* optional label on variant */
       } VariantRecord;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Variant structures may be qualified (narrowed) by specifying a value for the selector prior to the type. For example, an
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変異体の構造は、型の前にセレクタの値を指定して（狭く）修飾されてもよいです。たとえば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
orange VariantRecord
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オレンジVariantRecord
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
is a narrowed type of a VariantRecord containing a variant_body of type V2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイプV2のvariant_bodyを含むVariantRecordの狭窄タイプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. Cryptographic Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7。暗号化属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The four cryptographic operations digital signing, stream cipher encryption, block cipher encryption, and public key encryption are designated digitally-signed, stream-ciphered, block-ciphered, and public-key-encrypted, respectively. A field&#39;s cryptographic processing is specified by prepending an appropriate key word designation before the field&#39;s type specification. Cryptographic keys are implied by the current session state (see Section 6.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4つの暗号化操作のデジタル署名は、デジタル署名されたストリーム暗号、ブロック暗号、及び公開鍵で暗号化され、それぞれ指定された暗号の暗号化、ブロック暗号の暗号化、及び公開鍵暗号をストリーミングします。フィールドの暗号処理は、フィールドの型を指定する前に、適切なキーワードの指定を付加することによって特定されます。暗号化キーは、現在のセッション状態によって暗示されている（6.1節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In digital signing, one-way hash functions are used as input for a signing algorithm. A digitally-signed element is encoded as an opaque vector &lt;0..2^16-1&gt;, where the length is specified by the signing algorithm and key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デジタル署名では、一方向ハッシュ関数は署名アルゴリズムのための入力として使用されます。デジタル署名された要素は、長さが署名アルゴリズムと鍵によって指定された不透明なベクトル&lt;0..2 ^ 16-1&gt;としてコード化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In RSA signing, a 36-byte structure of two hashes (one SHA and one MD5) is signed (encrypted with the private key). It is encoded with PKCS #1 block type 1, as described in [PKCS1A].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSA署名では、2つのハッシュ（一方SHAと一つMD5）の36バイト構造（秘密鍵で暗号化された）署名されます。 【PKCS1A]に記載されているように、それは、PKCS＃1ブロックタイプ1で符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The standard reference for PKCS#1 is now RFC 3447 [PKCS1B]. However, to minimize differences with TLS 1.0 text, we are using the terminology of RFC 2313 [PKCS1A].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：PKCS＃1のための標準的な参照は、[PKCS1B]今RFC 3447です。しかし、TLS 1.0テキストとの違いを最小限に抑えるために、我々は、RFC 2313 [PKCS1A]の用語を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In DSS, the 20 bytes of the SHA hash are run directly through the Digital Signing Algorithm with no additional hashing. This produces two values, r and s. The DSS signature is an opaque vector, as above, the contents of which are the DER encoding of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DSSでは、SHAハッシュの20のバイトは追加論じ尽くすことのないデジタル署名アルゴリズムを通じて直接実行されています。これは、2つの値、rおよびsを生成します。 DSS署名は、上記のように、のDER符号化された内容不透明ベクトルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Dss-Sig-Value  ::=  SEQUENCE  {
            r       INTEGER,
            s       INTEGER
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically secure keyed pseudorandom number generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ストリーム暗号の暗号化では、平文は、排他的論理和は、暗号的に安全なキー付き疑似乱数発生器から生成される出力の同じ量です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In block cipher encryption, every block of plaintext encrypts to a block of ciphertext. All block cipher encryption is done in CBC (Cipher Block Chaining) mode, and all items that are block-ciphered will be an exact multiple of the cipher block length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブロック暗号の暗号化では、平文のすべてのブロックは、暗号文のブロックに暗号化します。全てのブロック暗号の暗号化は、CBC（Cipher Block Chaining）モードで行われ、ブロック暗号化されているすべての項目が暗号ブロック長の正確な倍数であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In public key encryption, a public key algorithm is used to encrypt data in such a way that it can be decrypted only with the matching private key. A public-key-encrypted element is encoded as an opaque vector &lt;0..2^16-1&gt;, where the length is specified by the signing algorithm and key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
公開鍵暗号では、公開鍵アルゴリズムは、それだけで対応する秘密鍵で復号することができるような方法でデータを暗号化するために使用されます。公開鍵暗号化された要素は、長さが署名アルゴリズムと鍵によって指定された不透明なベクトル&lt;0..2 ^ 16-1&gt;としてコード化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An RSA-encrypted value is encoded with PKCS #1 block type 2, as described in [PKCS1A].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【PKCS1A]で説明されるようにRSA暗号化値は、PKCS＃1ブロックタイプ2で符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the following example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の例では、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       stream-ciphered struct {
           uint8 field1;
           uint8 field2;
           digitally-signed opaque hash[20];
       } UserType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
the contents of hash are used as input for the signing algorithm, and then the entire structure is encrypted with a stream cipher. The length of this structure, in bytes, would be equal to two bytes for field1 and field2, plus two bytes for the length of the signature, plus the length of the output of the signing algorithm. This is known because the algorithm and key used for the signing are known prior to encoding or decoding this structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハッシュの内容は署名アルゴリズムのための入力として使用され、次いで全体の構造は、ストリーム暗号で暗号化されています。この構造の長さは、バイト単位で、フィールド1及びフィールド2用の2つのバイトに加え、署名の長さ2バイト、プラス署名アルゴリズムの出力の長さに等しくなります。署名に使用されるアルゴリズムと鍵を符号化するか、この構造をデコードする前に知られているので、これが知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8。定数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Typed constants can be defined for purposes of specification by declaring a symbol of the desired type and assigning values to it. Under-specified types (opaque, variable length vectors, and structures that contain opaque) cannot be assigned values. No fields of a multi-element structure or vector may be elided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
型付き定数は、所望のタイプのシンボルを宣言し、それに値を割り当てることにより明細書の目的のために定義することができます。アンダー指定されたタイプ（不透明、可変長ベクトル、および不透明含む構造）の値を割り当てることはできません。多素子構造又はベクターのないフィールドは省略されなくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           uint8 f1;
           uint8 f2;
       } Example1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. HMAC and the Pseudorandom Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. HMACと擬似ランダム機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A number of operations in the TLS record and handshake layer require a keyed MAC; this is a secure digest of some data protected by a secret. Forging the MAC is infeasible without knowledge of the MAC secret. The construction we use for this operation is known as HMAC, and is described in [HMAC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSレコードと握手層における動作の数は、鍵付きMACを必要とします。これは秘密で保護されたいくつかのデータの安全なダイジェストです。 MACを鍛造すると、MACの秘密の知識がなくても実行不可能です。我々は、この操作に使用する構造は、HMACとして知られており、[HMAC]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HMAC can be used with a variety of different hash algorithms. TLS uses it in the handshake with two different algorithms, MD5 and SHA-1, denoting these as HMAC_MD5(secret, data) and HMAC_SHA(secret, data). Additional hash algorithms can be defined by cipher suites and used to protect record data, but MD5 and SHA-1 are hard coded into the description of the handshaking for this version of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HMACは、異なるハッシュアルゴリズムの様々な使用することができます。 TLSはHMAC_MD5（秘密データ）とHMAC_SHA（秘密データ）としてこれらを表す、二つの異なるアルゴリズム、MD5とSHA-1との握手でそれを使用します。追加のハッシュアルゴリズムは暗号スイートによって定義され、記録データを保護するために使用されるが、MD5とSHA-1は、ハードプロトコルのこのバージョンのハンドシェイクの記述に符号化されることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, a construction is required to do expansion of secrets into blocks of data for the purposes of key generation or validation. This pseudo-random function (PRF) takes as input a secret, a seed, and an identifying label and produces an output of arbitrary length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、工事が、キー生成や検証の目的のためにデータのブロックに秘密の拡張を行うために必要とされます。この擬似ランダム関数（PRF）は、入力として、秘密、種子、及び識別ラベルを取得し、任意の長さの出力を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to make the PRF as secure as possible, it uses two hash algorithms in a way that should guarantee its security if either algorithm remains secure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
可能な限り安全なようPRFを作るためには、どちらかのアルゴリズムが安全なままであれば、そのセキュリティを保証すべきであるように、2つのハッシュアルゴリズムを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First, we define a data expansion function, P_hash(secret, data) that uses a single hash function to expand a secret and seed into an arbitrary quantity of output:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、秘密を展開し、出力の任意の量に播種するために単一のハッシュ関数を使用してデータ拡張機能、P_hash（秘密、データ）を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
                              HMAC_hash(secret, A(2) + seed) +
                              HMAC_hash(secret, A(3) + seed) + ...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where + indicates concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
+は、連結を示す場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A() is defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（）のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       A(0) = seed
       A(i) = HMAC_hash(secret, A(i-1))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
P_hash can be iterated as many times as is necessary to produce the required quantity of data. For example, if P_SHA-1 is being used to create 64 bytes of data, it will have to be iterated 4 times (through A(4)), creating 80 bytes of output data; the last 16 bytes of the final iteration will then be discarded, leaving 64 bytes of output data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
P_hashは、データの必要な量を生成するのに必要な回数だけ反復することができます。 P_SHA-1は、64バイトのデータを作成するために使用されている場合、例えば、それは（〜（4））を4回反復されなければならない、出力データの80のバイトを生成します。最後の反復の最後の16のバイトは、出力データの64のバイトを残して、廃棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS&#39;s PRF is created by splitting the secret into two halves and using one half to generate data with P_MD5 and the other half to generate data with P_SHA-1, then exclusive-ORing the outputs of these two expansion functions together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSのPRFは、これら2つの拡張関数の出力は、一緒になって、その後の排他的論理和、半分に秘密を分割し、P_SHA-1との間でデータを生成するP_MD5および他の半分でデータを生成するために半分を使用して作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
S1 and S2 are the two halves of the secret, and each is the same length. S1 is taken from the first half of the secret, S2 from the second half. Their length is created by rounding up the length of the overall secret, divided by two; thus, if the original secret is an odd number of bytes long, the last byte of S1 will be the same as the first byte of S2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
S1とS2は、秘密の二つの半分であり、それぞれが同じ長さです。 S1は、後半から秘密の前半、S2から取られます。その長さは2で割った、全体的な秘密の長さを切り上げて作成されます。元の秘密が長いバイト数が奇数である場合、従って、S1の最後のバイトは、S2の最初のバイトと同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       L_S = length in bytes of secret;
       L_S1 = L_S2 = ceil(L_S / 2);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The secret is partitioned into two halves (with the possibility of one shared byte) as described above, S1 taking the first L_S1 bytes, and S2 the last L_S2 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
秘密は、上述したように、S1は第L_S1バイトを取り、S2最後L_S2のバイト（1バイトの共有の可能性）は、2つの半分に分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PRF is then defined as the result of mixing the two pseudorandom streams by exclusive-ORing them together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PRFは、次いで、それらを一緒に排他的論理和により2つの擬似ランダムストリームを混合した結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR
                                  P_SHA-1(S2, label + seed);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The label is an ASCII string. It should be included in the exact form it is given without a length byte or trailing null character. For example, the label &#34;slithy toves&#34; would be processed by hashing the following bytes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ラベルには、ASCII文字列です。それはそれは、長さバイトまたは末尾のヌル文字なしで指定された正確な形式に含まれるべきです。たとえば、ラベル次のバイトをハッシュすることによって処理される「slithy toves」は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
73 6C 69 74 68 79 20 74 6F 76 65 73
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
73 74 TtsのTaqポリメラーゼのTaq右2074テフはTKH 73上陸しました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that because MD5 produces 16-byte outputs and SHA-1 produces 20-byte outputs, the boundaries of their internal iterations will not be aligned. Generating an 80-byte output will require that P_MD5 iterate through A(5), while P_SHA-1 will only iterate through A(4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MD5は、16バイトの出力を生成し、SHA-1は、20バイトの出力を生成するので、それらの内部反復の境界が整列されないことに注意してください。 P_SHA-1のみを反復する一方、P_MD5（5）を反復することを必要とする80バイトの出力を生成する（4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. The TLS Record Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. TLSレコードプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS Record Protocol is a layered protocol. At each layer, messages may include fields for length, description, and content. The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. Received data is decrypted, verified, decompressed, reassembled, and then delivered to higher-level clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSレコードプロトコルは、階層型プロトコルです。各レイヤでは、メッセージの長さ、説明、コンテンツのためのフィールドを含むことができます。レコードプロトコルは、メッセージを送信するのにかかる管理ブロックにデータを断片化し、必要に応じてデータを圧縮し、MACを適用し、暗号化し、結果を送信します。受信したデータは、復号化された検証、解凍、再組み立て、その後、より高いレベルのクライアントに配信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Four record protocol clients are described in this document: the handshake protocol, the alert protocol, the change cipher spec protocol, and the application data protocol. In order to allow extension of the TLS protocol, additional record types can be supported by the record protocol. Any new record types SHOULD allocate type values immediately beyond the ContentType values for the four record types described here (see Appendix A.1). All such values must be defined by RFC 2434 Standards Action. See Section 11 for IANA Considerations for ContentType values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
四の、レコードプロトコルクライアントは、この文書で説明されています。ハンドシェイクプロトコル、アラートのプロトコル、変化暗号仕様プロトコル、およびアプリケーションデータプロトコルを。 TLSプロトコルの拡張を可能にするために、追加のレコードタイプは、レコード・プロトコルによってサポートすることができます。すべての新しいレコードタイプは、ここで説明した4つのレコードタイプのContentType値を超えて、すぐに型の値を割り当てる必要があります（付録A.1を参照してください）。すべてのこのような値は、RFC 2434回の標準アクションで定義する必要があります。 ContentTypeを値のためのIANAの考慮事項については、セクション11を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a TLS implementation receives a record type it does not understand, it SHOULD just ignore it. Any protocol designed for use over TLS MUST be carefully designed to deal with all possible attacks against it. Note that because the type and length of a record are not protected by encryption, care SHOULD be taken to minimize the value of traffic analysis of these values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの実装は、それが理解していないレコードタイプを受信した場合、それはちょうどそれを無視すべきです。 TLS以上の使用のために設計されたプロトコルは、慎重にそれに対するすべての可能な攻撃に対処するように設計されなければなりません。レコードのタイプと長さが暗号化によって保護されていないので、ケアは、これらの値のトラフィック分析の価値を最小限に抑えるように注意する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Connection States
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。接続状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A TLS connection state is the operating environment of the TLS Record Protocol. It specifies a compression algorithm, and encryption algorithm, and a MAC algorithm. In addition, the parameters for these algorithms are known: the MAC secret and the bulk encryption keys for the connection in both the read and the write directions. Logically, there are always four connection states outstanding: the current read and write states, and the pending read and write states. All records are processed under the current read and write states. The security parameters for the pending states can be set by the TLS Handshake Protocol, and the Change Cipher Spec can selectively make either of the pending states current, in which case the appropriate current state is disposed of and replaced with the pending state; the pending state is then reinitialized to an empty state. It is illegal to make a state that has not been initialized with security parameters a current state. The initial current state always specifies that no encryption, compression, or MAC will be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS接続状態はTLSレコードプロトコルの動作環境です。これは、圧縮アルゴリズム、および暗号化アルゴリズム、およびMACアルゴリズムを指定します。また、これらのアルゴリズムのためのパラメータが知られている：MACの秘密と、読み取りと書き込みの両方向で接続するためのバルク暗号化キーを。現在の読み取りおよび状態を書き、そして読み保留中と状態を記述します。論理的には、優れた4つの接続状態が常にあります。すべてのレコードは、現在の読み取りと書き込みの状態の下で処理されています。ペンディング状態のセキュリティパラメータは、TLSハンドシェイクプロトコルにより設定することができ、および変更暗号仕様を選択的に適切な現在の状態が廃棄と保留状態に置き換えた場合には、現在の保留中の状態、のいずれかを行うことができます。保留状態は、空の状態に再初期化されます。セキュリティパラメータの現在の状態に初期化されていない状態を作ることは違法です。初期の現在の状態は常に何の暗号化、圧縮、またはMACを使用しないことを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The security parameters for a TLS Connection read and write state are set by providing the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS接続の読み取りと書き込み状態のためのセキュリティパラメータは、以下の値を提供することで、設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
connection end Whether this entity is considered the &#34;client&#34; or the &#34;server&#34; in this connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続は、このエンティティは、これに関連して、「クライアント」または「サーバー」と見なされているかどうかに終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
bulk encryption algorithm An algorithm to be used for bulk encryption. This specification includes the key size of this algorithm, how much of that key is secret, whether it is a block or stream cipher, and the block size of the cipher (if appropriate).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バルク暗号化アルゴリズムアルゴリズムは、バルク暗号化に使用します。この仕様は、このアルゴリズムのキーサイズを含む、どのくらいのそのキーのは、それがブロックまたはストリーム暗号、および暗号（適切な場合）のブロックサイズであるかどうか、秘密です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAC algorithm An algorithm to be used for message authentication. This specification includes the size of the hash returned by the MAC algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MACは、メッセージの認証に使用するアルゴリズムをアルゴリズムです。この仕様は、MACアルゴリズムによって返されたハッシュのサイズが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
compression algorithm An algorithm to be used for data compression. This specification must include all information the algorithm requires compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
圧縮は、データ圧縮に使用するアルゴリズムをアルゴリズムです。この仕様はアルゴリズムが圧縮を必要とするすべての情報を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
master secret A 48-byte secret shared between the two peers in the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連して2つのピア間で共有マスターシークレット48バイトの秘密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client random A 32-byte value provided by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントによって提供されるクライアントランダム32バイトの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
server random A 32-byte value provided by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバによって提供されるサーバのランダムな32バイトの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These parameters are defined in the presentation language as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのパラメータは、次のようにプレゼンテーション言語で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { server, client } ConnectionEnd;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null, rc4, rc2, des, 3des, des40, idea, aes }
       BulkCipherAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { stream, block } CipherType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null, md5, sha } MACAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* The algorithms specified in CompressionMethod,
          BulkCipherAlgorithm, and MACAlgorithm may be added to. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ConnectionEnd          entity;
           BulkCipherAlgorithm    bulk_cipher_algorithm;
           CipherType             cipher_type;
           uint8                  key_size;
           uint8                  key_material_length;
           MACAlgorithm           mac_algorithm;
           uint8                  hash_size;
           CompressionMethod      compression_algorithm;
           opaque                 master_secret[48];
           opaque                 client_random[32];
           opaque                 server_random[32];
       } SecurityParameters;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The record layer will use the security parameters to generate the following four items:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
記録層には、以下の4つの項目を生成するために、セキュリティパラメータを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       client write MAC secret
       server write MAC secret
       client write key
       server write key
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client write parameters are used by the server when receiving and processing records and vice-versa. The algorithm used for generating these items from the security parameters is described in Section 6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント書き込みパラメータが記録及びその逆を受信して​​処理するときにサーバーが使用されます。セキュリティパラメータからこれらの項目を生成するために使用されるアルゴリズムは、セクション6.3に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once the security parameters have been set and the keys have been generated, the connection states can be instantiated by making them the current states. These current states MUST be updated for each record processed. Each connection state includes the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティパラメータが設定されているとキーが生成されたら、接続状態は、それらの現在の状態作ることによってインスタンス化することができます。これらの現在の状態は、処理された各レコードに更新されなければなりません。それぞれの接続状態は、以下の要素が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
compression state The current state of the compression algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
圧縮は圧縮アルゴリズムの現在の状態を述べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher state The current state of the encryption algorithm. This will consist of the scheduled key for that connection. For stream ciphers, this will also contain whatever state information is necessary to allow the stream to continue to encrypt or decrypt data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号状態暗号化アルゴリズムの現在の状態。これは、その接続のためにスケジュールされたキーから構成されます。ストリーム暗号の場合、これはまた、ストリームはデータを暗号化または復号化を継続することができるようにする必要があるどんな状態の情報が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAC secret The MAC secret for this connection, as generated above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この接続のためのMAC秘密のMAC秘密、上記生成されたとして。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
sequence number Each connection state contains a sequence number, which is maintained separately for read and write states. The sequence number MUST be set to zero whenever a connection state is made the active state. Sequence numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do not wrap. If a TLS implementation would need to wrap a sequence number, it must renegotiate instead. A sequence number is incremented after each record: specifically, the first record transmitted under a particular connection state MUST use sequence number 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シーケンス番号は、各接続状態が読み取りおよび書き込み状態に対して別々に維持されているシーケンス番号を含んでいます。シーケンス番号は、接続状態がアクティブ状態にされるたびにゼロに設定しなければなりません。シーケンス番号は、タイプUINT64のものであり、2 ^ 64-1を超えてはなりません。シーケンス番号は折り返されません。 TLSの実装は、シーケンス番号をラップする必要がある場合は、代わりに再交渉しなければなりません。シーケンス番号は、各レコードの後に​​インクリメントされる。具体的には、特定の接続状態で送信された最初のレコードは、シーケンス番号0を使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Record layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。記録層
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS Record Layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSレコード層は、任意のサイズの空でないブロック内の上位層からの未解釈のデータを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1。フラグメンテーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Client message boundaries are not preserved in the record layer (i.e., multiple client messages of the same ContentType MAY be coalesced into a single TLSPlaintext record, or a single message MAY be fragmented across several records).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
記録層は2 ^ 14バイト以下のチャンクでデータを搬送するのTLSPlaintextレコードに情報ブロックをフラグメント。クライアントメッセージの境界は、記録層に保存されていない（すなわち、同一のContentTypeの複数のクライアントメッセージは、単一のTLSPlaintextレコードに合体されてもよく、または単一のメッセージは、いくつかのレコードを横切って断片化することができます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           uint8 major, minor;
       } ProtocolVersion;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum {
           change_cipher_spec(20), alert(21), handshake(22),
           application_data(23), (255)
       } ContentType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           opaque fragment[TLSPlaintext.length];
       } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
type The higher-level protocol used to process the enclosed fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
囲まれたフラグメントを処理するために使用されるより高いレベルのプロトコルを入力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
version The version of the protocol being employed. This document describes TLS Version 1.1, which uses the version { 3, 2 }. The version value 3.2 is historical: TLS version 1.1 is a minor modification to the TLS 1.0 protocol, which was itself a minor modification to the SSL 3.0 protocol, which bears the version value 3.0. (See Appendix A.1.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バージョン使用されているプロトコルのバージョン。この文書は、バージョン{3,2}を使用してTLSバージョン1.1を、記載されています。バージョン値3.2は歴史的である：TLSバージョン1.1は、バージョン値3.0を担持SSL 3.0プロトコルのマイナー改変自体たTLS 1.0プロトコルのマイナー変形例です。 （付録A.1を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
length The length (in bytes) of the following TLSPlaintext.fragment. The length should not exceed 2^14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のTLSPlaintext.fragmentの長さ長さ（バイト単位）。長さが2 ^ 14を超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fragment The application data. This data is transparent and is treated as an independent block to be dealt with by the higher-level protocol specified by the type field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションデータを断片化。このデータは、透明であり、タイプフィールドで指定されたより高いレベルのプロトコルによって対処される独立したブロックとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Data of different TLS Record layer content types MAY be interleaved. Application data is generally of lower precedence for transmission than other content types. However, records MUST be delivered to the network in the same order as they are protected by the record layer. Recipients MUST receive and process interleaved application layer traffic during handshakes subsequent to the first one on a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：別のTLSレコード層コンテンツタイプのデータがインターリーブされるかもしれません。アプリケーションデータは、一般に、他のコンテンツタイプより送信に対して低い優先順位のものです。しかし、レコードは、レコード層によって保護されているのと同じ順番でネットワークに送達されなければなりません。受信者は、接続上の最初のものに続くハンドシェイク中にインターリーブアプリケーションレイヤトラフィックを受信して​​処理しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. Record Compression and Decompression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2。レコード圧縮と解凍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All records are compressed using the compression algorithm defined in the current session state. There is always an active compression algorithm; however, initially it is defined as CompressionMethod.null. The compression algorithm translates a TLSPlaintext structure into a TLSCompressed structure. Compression functions are initialized with default state information whenever a connection state is made active.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのレコードは、現在のセッション状態に定義された圧縮アルゴリズムを使用して圧縮されています。アクティブな圧縮アルゴリズムは常にあります。しかし、当初はCompressionMethod.nullと定義されます。圧縮アルゴリズムはTLSCompressed構造にのTLSPlaintext構造を変換します。圧縮機能は、接続状態がアクティブになるたびデフォルト状態の情報で初期化されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Compression must be lossless and may not increase the content length by more than 1024 bytes. If the decompression function encounters a TLSCompressed.fragment that would decompress to a length in excess of 2^14 bytes, it should report a fatal decompression failure error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
圧縮はロスレスでなければならず、1024バイト以上で、コンテンツの長さを増加させないかもしれません。解凍機能は、2 ^ 14バイトを超える長さに解凍しまうのTLSCompressed.fragmentに遭遇した場合、それは致命的な減圧失敗誤りを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ContentType type;       /* same as TLSPlaintext.type */
           ProtocolVersion version;/* same as TLSPlaintext.version */
           uint16 length;
           opaque fragment[TLSCompressed.length];
       } TLSCompressed;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
length The length (in bytes) of the following TLSCompressed.fragment. The length should not exceed 2^14 + 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のTLSCompressed.fragmentの長さ長さ（バイト単位）。長さは、+ 1024年2 ^ 14を超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fragment The compressed form of TLSPlaintext.fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSPlaintext.fragmentの圧縮形式を断片。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: A CompressionMethod.null operation is an identity operation; no fields are altered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：CompressionMethod.null操作は一致演算です。分野は全く変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementation note: Decompression functions are responsible for ensuring that messages cannot cause internal buffer overflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装上の注意：解凍機能は、メッセージが内部バッファオーバーフローを引き起こさないことを保証する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3. Record Payload Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3。レコードのペイロードの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The encryption and MAC functions translate a TLSCompressed structure into a TLSCiphertext. The decryption functions reverse the process. The MAC of the record also includes a sequence number so that missing, extra, or repeated messages are detectable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号化とMAC機能はTLSCiphertextにTLSCompressed構造を翻訳します。復号化機能は、プロセスを逆転します。レコードのMACも不足している、余分な、または繰り返しのメッセージが検出可能であるように、シーケンス番号が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           select (CipherSpec.cipher_type) {
               case stream: GenericStreamCipher;
               case block: GenericBlockCipher;
           } fragment;
       } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
type The type field is identical to TLSCompressed.type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイプフィールドを入力してTLSCompressed.typeと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
version The version field is identical to TLSCompressed.version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バージョンバージョンフィールドはTLSCompressed.versionと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
length The length (in bytes) of the following TLSCiphertext.fragment. The length may not exceed 2^14 + 2048.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のTLSCiphertext.fragmentの長さ長さ（バイト単位）。長さは、+ 2048年2 ^ 14を超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fragment The encrypted form of TLSCompressed.fragment, with the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MACで、のTLSCompressed.fragmentの暗号化された形式を断片化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.1. Null or Standard Stream Cipher
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.1。 NULLまたは標準ストリーム暗号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stream ciphers (including BulkCipherAlgorithm.null, see Appendix A.6) convert TLSCompressed.fragment structures to and from stream TLSCiphertext.fragment structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ストリーム暗号（BulkCipherAlgorithm.nullを含むが、付録A.6を参照）ストリームのTLSCiphertext.fragment構造からTLSCompressed.fragment構造を変換。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       stream-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
       } GenericStreamCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The MAC is generated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MACは次のように生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +
                     TLSCompressed.version + TLSCompressed.length +
                     TLSCompressed.fragment));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where &#34;+&#34; denotes concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、「+」連結を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
seq_num The sequence number for this record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このための一連番号が記録するseq_num。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
hash The hashing algorithm specified by SecurityParameters.mac_algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SecurityParameters.mac_algorithmで指定されたハッシュアルゴリズムをハッシュ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the MAC is computed before encryption. The stream cipher encrypts the entire block, including the MAC. For stream ciphers that do not use a synchronization vector (such as RC4), the stream cipher state from the end of one record is simply used on the subsequent packet. If the CipherSuite is TLS_NULL_WITH_NULL_NULL, encryption consists of the identity operation (i.e., the data is not encrypted, and the MAC size is zero, implying that no MAC is used). TLSCiphertext.length is TLSCompressed.length plus CipherSpec.hash_size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MACは、暗号化の前に計算されることに注意してください。ストリーム暗号はMACを含むブロック全体を、暗号化します。 （例えば、RC4など）同期ベクトルを使用しないストリーム暗号のために、一つのレコードの終わりからストリーム暗号状態は、単に次のパケットに使用されます。 CipherSuiteがTLS_NULL_WITH_NULL_NULLである場合、暗号化は同一の動作で構成され（すなわち、データは暗号化されず、MACサイズにはMACが使用されないことを意味し、ゼロです）。 TLSCiphertext.lengthはTLSCompressed.lengthプラスCipherSpec.hash_sizeです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.2. CBC Block Cipher
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.2。 CBCブロック暗号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For block ciphers (such as RC2, DES, or AES), the encryption and MAC functions convert TLSCompressed.fragment structures to and from block TLSCiphertext.fragment structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（例えば、RC2、DESまたはAESなどの）ブロック暗号は、暗号化とMAC機能ブロックのTLSCiphertext.fragment構造からTLSCompressed.fragment構造を変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       block-ciphered struct {
           opaque IV[CipherSpec.block_length];
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       } GenericBlockCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The MAC is generated as described in Section 6.2.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション6.2.3.1に記載されるようにMACが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IV Unlike previous versions of SSL and TLS, TLS 1.1 uses an explicit IV in order to prevent the attacks described by [CBCATT]. We recommend the following equivalently strong procedures. For clarity we use the following notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSLおよびTLSの以前のバージョンとは異なりIVは、TLS 1.1 [CBCATT]で説明された攻撃を防止するために、明示的なIVを使用します。我々は、次の同等に強力な手順をお勧めします。明確にするために、私たちは、次の表記法を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IV The transmitted value of the IV field in the GenericBlockCipher structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IVのGenericBlockCipher構造におけるIVフィールドの送信された値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CBC residue The last ciphertext block of the previous record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CBCは、前のレコードの最後の暗号文ブロックを残基。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
mask The actual value that the cipher XORs with the plaintext prior to encryption of the first cipher block of the record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前のレコードの最初の暗号ブロックの暗号化に平文と暗号のXORこと実際の値をマスクします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In prior versions of TLS, there was no IV field and the CBC residue and mask were one and the same. See Sections 6.1, 6.2.3.2, and 6.3, of [TLS1.0] for details of TLS 1.0 IV handling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの以前のバージョンでは、そこにはIVフィールドがなかったとCBC残基とマスクは、同一でした。 TLS 1.0 IV取り扱いの詳細については、[TLS1.0]のセクション6.1、6.2.3.2、および6.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One of the following two algorithms SHOULD be used to generate the per-record IV:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の2つのアルゴリズムの一つは、あたりのレコードIVを生成するために使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) Generate a cryptographically strong random string R of length CipherSpec.block_length. Place R in the IV field. Set the mask to R. Thus, the first cipher block will be encrypted as E(R XOR Data).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）長さCipherSpec.block_lengthの暗号強いランダムな文字列Rを生成します。 IVフィールドにRを置きます。したがって、R.にマスクを設定し、最初の暗号ブロックは、E（R XORデータ）として暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) Generate a cryptographically strong random number R of length CipherSpec.block_length and prepend it to the plaintext prior to encryption. In this case either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）長さCipherSpec.block_lengthの暗号的に強い乱数Rを生成し、暗号化する前の平文にそれを付加します。この場合、次のいずれか
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          (a) The cipher may use a fixed mask such as zero.
          (b) The CBC residue from the previous record may be used as
              the mask.  This preserves maximum code compatibility with
              TLS 1.0 and SSL 3.  It also has the advantage that it does
              not require the ability to quickly reset the IV, which is
              known to be a problem on some systems.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In either (2)(a) or (2)(b) the data (R || data) is fed into the encryption process. The first cipher block (containing E(mask XOR R) is placed in the IV field. The first block of content contains E(IV XOR data).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれか（2）（a）又は（2）（b）のデータ（R ||データ）を暗号化処理に供給されます。 E（マスクXOR R）を含む第一の暗号ブロックが（IVフィールドに配置される。コンテンツの最初のブロック）E（IVのXORデータを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following alternative procedure MAY be used; however, it has not been demonstrated to be as cryptographically strong as the above procedures. The sender prepends a fixed block F to the plaintext (or, alternatively, a block generated with a weak PRNG). He then encrypts as in (2), above, using the CBC residue from the previous block as the mask for the prepended block. Note that in this case the mask for the first record transmitted by the application (the Finished) MUST be generated using a cryptographically strong PRNG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の代替手順が使用されてもよいです。しかし、上記の手順と同様に暗号強力であることが実証されていません。送信者は（あるいは、弱いPRNGを用いて生成されたブロック）平文に固定されたブロックFを付加します。彼は次に、前置ブロックのためのマスクとして前のブロックからCBC残基を用いて、上記（2）のように暗号化します。この場合、アプリケーション（終了）によって送信された最初のレコードのためのマスクが暗号強いPRNGを用いて生成しなければならないことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The decryption operation for all three alternatives is the same. The receiver decrypts the entire GenericBlockCipher structure and then discards the first cipher block, corresponding to the IV component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての3つの選択肢のための復号化操作は同じです。受信機は、全体のGenericBlockCipher構造を解読し、次いでIV成分に対応する、第一の暗号ブロックを破棄する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
padding Padding that is added to force the length of the plaintext to be an integral multiple of the block cipher&#39;s block length. The padding MAY be any length up to 255 bytes, as long as it results in the TLSCiphertext.length being an integral multiple of the block length. Lengths longer than necessary might be desirable to frustrate attacks on a protocol that are based on analysis of the lengths of exchanged messages. Each uint8 in the padding data vector MUST be filled with the padding length value. The receiver
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブロック暗号のブロック長の整数倍となるように、平文の長さを強制するために添加されるパディングパディング。パディングは、それがブロック長の整数倍であるTLSCiphertext.lengthになるように、255バイトまでの任意の長さまでであり得ます。必要以上に長い長が交換されたメッセージの長さの分析に基づいているプロトコルへの攻撃を挫折させることが望ましいかもしれません。パディングデータベクトルの各UINT8は、パディング長の値で埋めなければなりません。受信機
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MUST check this padding and SHOULD use the bad_record_mac alert to indicate padding errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このパディングをチェックしなければなりませんし、パディングエラーを示すためにbad_record_macアラートを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
padding_length The padding length MUST be such that the total size of the GenericBlockCipher structure is a multiple of the cipher&#39;s block length. Legal values range from zero to 255, inclusive. This length specifies the length of the padding field exclusive of the padding_length field itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
するpadding_lengthパディングの長さはのGenericBlockCipher構造体の合計サイズが暗号のブロック長の倍数であるようなものでなければなりません。有効な値は、包括的、ゼロから255までの範囲。この長さはするpadding_lengthフィールド自体の排他的なパディングフィールドの長さを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The encrypted data length (TLSCiphertext.length) is one more than the sum of CipherSpec.block_length, TLSCompressed.length, CipherSpec.hash_size, and padding_length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号化されたデータ長（TLSCiphertext.length）はCipherSpec.block_length、TLSCompressed.length、CipherSpec.hash_size、およびpadding_lengthの合計より1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example: If the block length is 8 bytes, the content length (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, then the length before padding is 82 bytes (this does not include the IV, which may or may not be encrypted, as discussed above). Thus, the padding length modulo 8 must be equal to 6 in order to make the total length an even multiple of 8 bytes (the block length). The padding length can be 6, 14, 22, and so on, through 254. If the padding length were the minimum necessary, 6, the padding would be 6 bytes, each containing the value 6. Thus, the last 8 octets of the GenericBlockCipher before block encryption would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例：ブロック長が8バイトである場合、コンテンツの長さ（TLSCompressed.length）が61バイトであり、MACの長さは20バイトであり、その後、パディング前の長さは82バイトである（これはIVが含まれていない、これもよい、または月上述したように）、暗号化されません。従って、パディング長モジュロ8は、全8バイト長（ブロック長）の偶数倍にするために、6に等しくなければなりません。パディング長パディングが6バイト、したがって、値6をそれぞれ含む、最後の8つのオクテットであろう、6最低限必要であればパディングの長さは254を通るように6、14、22、とすることができますxxは、MACの最後のオクテットがどこにあるのGenericBlockCipherは、ブロック暗号化の前に、06 06 06 06 06 06 06 xxをされるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: With block ciphers in CBC mode (Cipher Block Chaining), it is critical that the entire plaintext of the record be known before any ciphertext is transmitted. Otherwise, it is possible for the attacker to mount the attack described in [CBCATT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：CBCモード（暗号ブロック連鎖）でのブロック暗号では、任意の暗号文が送信される前に、レコードの全体の平文が知られていることが重要です。攻撃者は、[CBCATT]で説明した攻撃をマウントするためにそれ以外の場合は、それが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementation Note: Canvel et al. [CBCTIME] have demonstrated a timing attack on CBC padding based on the time required to compute the MAC. In order to defend against this attack, implementations MUST ensure that record processing time is essentially the same whether or not the padding is correct. In general, the best way to do this is to compute the MAC even if the padding is incorrect, and only then reject the packet. For instance, if the pad appears to be incorrect, the implementation might assume a zero-length pad and then compute the MAC. This leaves a small timing channel, since MAC performance depends to some extent on the size of the data fragment, but it is not believed to be large enough to be exploitable, due to the large block size of existing MACs and the small size of the timing signal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装上の注意：Canvelら。 【CBCTIME】MACを計算するのに必要な時間に基づいて、CBCパディングにタイミング攻撃を実証しています。この攻撃に対して防御するために、実装は、レコードの処理時間がパディングが正しいか否か、本質的に同じであることを保証しなければなりません。一般的には、これを行うための最善の方法は、パディングが間違っている場合でも、MACを計算し、だけにしてパケットを拒否することです。パッドが正しくないと表示された場合例えば、実装は長さゼロのパッドを想定して、MACを計算することがあります。これは、既存のMACの大きいブロックサイズの小さいサイズのため、MAC性能がデータ断片のサイズにある程度依存するので、小さなタイミングチャネルを出るが、悪用することに十分な大きさではないと考えられますタイミング信号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Key Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3。主な計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Record Protocol requires an algorithm to generate keys, and MAC secrets from the security parameters provided by the handshake protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レコードプロトコルは、ハンドシェイクプロトコルによって提供されるセキュリティパラメータからキー、およびMACシークレットを生成するアルゴリズムが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The master secret is hashed into a sequence of secure bytes, which are assigned to the MAC secrets and keys required by the current connection state (see Appendix A.6). CipherSpecs require a client write MAC secret, a server write MAC secret, a client write key, and a server write key, each of which is generated from the master secret in that order. Unused values are empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マスターシークレットが現在の接続状態によって必要とされるMACシークレットとキーに割り当てられている安全なバイトのシーケンスにハッシュされる（付録A.6を参照）。 CipherSpecは、MACの秘密を書くクライアントを必要とし、サーバーはMACの秘密、クライアントの書き込みキー、およびそのために、マスターシークレットから生成されるそれぞれのサーバーの書き込みキーを、書きます。未使用の値は空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When keys and MAC secrets are generated, the master secret is used as an entropy source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鍵とMACシークレットが生成されると、マスターシークレットは、エントロピー源として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To generate the key material, compute
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キーマテリアルを生成するには、計算
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       key_block = PRF(SecurityParameters.master_secret,
                          &#34;key expansion&#34;,
                          SecurityParameters.server_random +
             SecurityParameters.client_random);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
until enough output has been generated. Then the key_block is partitioned as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まで十分な出力が生成されています。次に、以下のようなkey_blockが仕切られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       client_write_MAC_secret[SecurityParameters.hash_size]
       server_write_MAC_secret[SecurityParameters.hash_size]
       client_write_key[SecurityParameters.key_material_length]
       server_write_key[SecurityParameters.key_material_length]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementation note: The currently defined cipher suite that requires the most material is AES_256_CBC_SHA, defined in [TLSAES]. It requires 2 x 32 byte keys, 2 x 20 byte MAC secrets, and 2 x 16 byte Initialization Vectors, for a total of 136 bytes of key material.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装上の注意：ほとんどの材料を必要とし、現在定義されている暗号スイートは、[TLSAES]で定義され、AES_256_CBC_SHAです。これは、鍵データの136バイトの合計、2×32バイトのキー、2×20バイトのMAC秘密、および2×16バイトの初期化ベクトルを必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. The TLS Handshaking Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. TLSハンドシェイクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS has three subprotocols that are used to allow peers to agree upon security parameters for the record layer, to authenticate themselves, to instantiate negotiated security parameters, and to report error conditions to each other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSはピアは、記録層のためのセキュリティパラメータに合意するために自分自身を認証するために交渉セキュリティパラメータをインスタンス化するために、お互いにエラー状況を報告できるようにするために使用される3つのサブプロトコルがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Handshake Protocol is responsible for negotiating a session, which consists of the following items:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイクプロトコルは、以下の項目で構成されたセッションを、交渉を担当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
session identifier An arbitrary byte sequence chosen by the server to identify an active or resumable session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セッション識別子アクティブまたは再開可能なセッション状態を識別するためにサーバによって選択された任意のバイトシーケンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
peer certificate X509v3 [X509] certificate of the peer. This element of the state may be null.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピアのピア証明書X509v3 [X509]証明書。状態のこの要素はnullの場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
compression method The algorithm used to compress data prior to encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
圧縮方式暗号化の前にデータを圧縮するために使用されるアルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher spec Specifies the bulk data encryption algorithm (such as null, DES, etc.) and a MAC algorithm (such as MD5 or SHA). It also defines cryptographic attributes such as the hash_size. (See Appendix A.6 for formal definition.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号仕様は、バルクデータ暗号化アルゴリズムと（例えばMD5やSHAのような）MACアルゴリズム（例えばヌル、DESなど）を指定します。また、hash_sizeなどの暗号属性を定義します。 （正式な定義については付録A.6を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
master secret 48-byte secret shared between the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバの間で共有される秘密48バイトの秘密を習得。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
is resumable A flag indicating whether the session can be used to initiate new connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再開可能セッションが新しい接続を開始するために使用することができるか否かを示すフラグです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These items are then used to create security parameters for use by the Record Layer when protecting application data. Many connections can be instantiated using the same session through the resumption feature of the TLS Handshake Protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの項目は、アプリケーションのデータを保護する際にレコード層で使用するためのセキュリティパラメータを作成するために使用されています。多くの接続は、TLSハンドシェイクプロトコルの再開機能を使用して、同じセッションを使用してインスタンス化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Change Cipher Spec Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。暗号仕様変更プロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The change cipher spec protocol exists to signal transitions in ciphering strategies. The protocol consists of a single message, which is encrypted and compressed under the current (not the pending) connection state. The message consists of a single byte of value 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変化暗号仕様プロトコルは、暗号化戦略の遷移を通知するために存在しています。プロトコルは、（保留中ではない）現在の接続状態の下で暗号化され、圧縮された単一のメッセージからなります。メッセージは、値1の単一バイトから成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           enum { change_cipher_spec(1), (255) } type;
       } ChangeCipherSpec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The change cipher spec message is sent by both the client and the server to notify the receiving party that subsequent records will be protected under the newly negotiated CipherSpec and keys. Reception of this message causes the receiver to instruct the Record Layer to immediately copy the read pending state into the read current state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変化暗号仕様メッセージは、クライアントと後続のレコードは、新たに交渉のCipherSpecと鍵の下で保護されます受信者に通知するサーバの両方で送信されます。このメッセージの受信は、受信機はすぐに読み、現在の状態に読み取り保留状態をコピーするレコード層を指示する原因となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Immediately after sending this message, the sender MUST instruct the record layer to make the write pending state the write active state. (See Section 6.1.) The change cipher spec message is sent during the handshake after the security parameters have been agreed upon, but before the verifying finished message is sent (see Section 7.4.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すぐにこのメッセージを送信した後、送信者は、書き込み保留状態の書き込みアクティブ状態を作るために、記録層に指示する必要があります。 （6.1節を参照してください。）ChangeCipherSpecメッセージは、セキュリティパラメータが合意された後の握手の間に送信されますが、検証完成メッセージが送信される前に、（セクション7.4.9を参照）されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: If a rehandshake occurs while data is flowing on a connection, the communicating parties may continue to send data using the old CipherSpec. However, once the ChangeCipherSpec has been sent, the new CipherSpec MUST be used. The first side to send the ChangeCipherSpec does not know that the other side has finished computing the new keying material (e.g., if it has to perform a time consuming public key operation). Thus, a small window of time, during which the recipient must buffer the data, MAY exist. In practice, with modern machines this interval is likely to be fairly short.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：データは、接続に流れている間に再ハンドシェイクが発生した場合、通信者は古いのCipherSpecを使用してデータを送信し続ける可能性があります。 ChangeCipherSpecをが送信された後しかし、新しいのCipherSpecを使用しなければなりません。 ChangeCipherSpecをを送信する第1の側が（それは公開鍵のかかる作業時間を実行する必要がある場合、例えば）他の側は、新たな鍵素材を計算し終えたことを知りません。したがって、受信者がデータをバッファリングしなければならない時間の小さなウィンドウは、存在してもよいです。実際には、近代的な機械で、この間隔はかなり短くなる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Alert Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。アラートプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         One of the content types supported by the TLS Record layer is
         the alert type.  Alert messages convey the severity of the
         message and a description of the alert.  Alert messages with a
         level of fatal result in the immediate termination of the
         connection.  In this case, other connections corresponding to
         the session may continue, but the session identifier MUST be
         invalidated, preventing the failed session from being used to
         establish new connections.  Like other messages, alert messages
         are encrypted and compressed, as specified by the current
         connection state.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             enum {
                 close_notify(0),
                 unexpected_message(10),
                 bad_record_mac(20),
                 decryption_failed(21),
                 record_overflow(22),
                 decompression_failure(30),
                 handshake_failure(40),
                 no_certificate_RESERVED (41),
                 bad_certificate(42),
                 unsupported_certificate(43),
                 certificate_revoked(44),
                 certificate_expired(45),
                 certificate_unknown(46),
                 illegal_parameter(47),
                 unknown_ca(48), access_denied(49),
                 decode_error(50),
                 decrypt_error(51),
                 export_restriction_RESERVED(60),
                 protocol_version(70),
                 insufficient_security(71),
                 internal_error(80),
                 user_canceled(90),
                 no_renegotiation(100),
                 (255)
             } AlertDescription;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             struct {
                 AlertLevel level;
                 AlertDescription description;
             } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. Closure Alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1。クロージャアラート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack. Either party may initiate the exchange of closing messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバーの接続がトランケーション攻撃を避けるために終了しているという知識を共有しなければなりません。いずれの当事者から終了メッセージの交換を開始することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
close_notify This message notifies the recipient that the sender will not send any more messages on this connection. Note that as of TLS 1.1, failure to properly close a connection no longer requires that a session not be resumed. This is a change from TLS 1.0 to conform with widespread implementation practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
close_notifyこのメッセージは、送信者がこの接続上の任意の複数のメッセージを送信しません受信者に通知します。 TLS 1.1のように、適切な接続を閉じるには、障害がもはやセッションが再開されないことを必要とすることに注意してください。これは、広範囲の実装の練習に準拠するためにTLS 1.0からの変更点です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Either party may initiate a close by sending a close_notify alert. Any data received after a closure alert is ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれの当事者は、は、close_notifyを送信することにより、クローズを開始することができます。閉鎖警報後に受信したデータはすべて無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unless some other fatal alert has been transmitted, each party is required to send a close_notify alert before closing the write side of the connection. The other party MUST respond with a close_notify alert of its own and close down the connection immediately, discarding any pending writes. It is not required for the initiator of the close to wait for the responding close_notify alert before closing the read side of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他のいくつかの致命的なアラートが送信された場合を除き、各当事者は、接続の書き込み側を閉じる前には、close_notifyを送信するために必要とされます。他の当事者は、独自のは、close_notifyで応答し、すぐにコネクションを閉じ、保留中の書き込みを破棄しなければなりません。接続の読み取り側を閉じる前に、応答は、close_notifyを待つために近くのイニシエータは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation must receive the responding close_notify alert before indicating to the application layer that the TLS connection has ended. If the application protocol will not transfer any additional data, but will only close the underlying transport connection, then the implementation MAY choose to close the transport without waiting for the responding close_notify. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSを使用してアプリケーションプロトコルは、TLS接続が閉じられた後、任意のデータは、基礎となるトランスポートを介して行うことができることを提供する場合、TLSの実装は、TLS接続が終了したことをアプリケーション層に示す前に、応答は、close_notifyアラートを受信しなければなりません。アプリケーションプロトコルが追加のデータを転送することはありませんが、唯一の基礎となるトランスポート接続をクローズする場合は、その実装は、応答は、close_notifyを待たずにトランスポートを閉じるために選ぶかもしれません。この規格のいかなる部分も、TLSの使用プロファイルは、接続が開いているか閉じているときを含め、そのデータ転送を管理する方法を決定するために取られるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: It is assumed that closing a connection reliably delivers pending data before destroying the transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：接続を閉じると確実に輸送を破壊する前に、保留中のデータを配信するものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. Error Alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2。エラーアラート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Error handling in the TLS Handshake protocol is very simple. When an error is detected, the detecting party sends a message to the other party. Upon transmission or receipt of a fatal alert message, both parties immediately close the connection. Servers and clients MUST forget any session-identifiers, keys, and secrets associated with a failed connection. Thus, any connection terminated with a fatal alert MUST NOT be resumed. The following error alerts are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSハンドシェイクプロトコルにおけるエラー処理は非常に簡単です。エラーが検出されると、検出当事者が他の当事者にメッセージを送信します。致命的な警告メッセージの送信または受信すると、両当事者は、直ちに接続を閉じます。サーバーとクライアントが失敗した接続に関連付けられているすべてのセッション識別子、キー、および秘密を忘れなければなりません。このように、致命的な警告で終了任意の接続が再開してはなりません。次のエラーアラートが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unexpected_message An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
unexpected_message不適切なメッセージが受信されました。このアラートは常にfatalである。適切な実装間の通信に観察すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
bad_record_mac This alert is returned if a record is received with an incorrect MAC. This alert also MUST be returned if an alert is sent because a TLSCiphertext decrypted in an invalid way: either it wasn&#39;t an even multiple of the block length, or its padding values, when checked, weren&#39;t correct. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レコードが正しくないMACで受信された場合にbad_record_macこのアラートが返されます。アラートが送信された場合TLSCiphertextが無効な方法で復号化されたので、この警告はまた返さなければなりません：チェックすると、それは、偶数ブロック長の倍数、またはそのパディング値ではなかったのいずれか、正しくありませんでした。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
decryption_failed This alert MAY be returned if a TLSCiphertext decrypted in an invalid way: either it wasn&#39;t an even multiple of the block length, or its padding values, when checked, weren&#39;t correct. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSCiphertextが無効な方法で復号化された場合は、この警告は返されることがありdecryption_failed：チェックすると、それは、偶数ブロック長の倍数、またはそのパディング値ではなかったのいずれか、正しくありませんでした。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Differentiating between bad_record_mac and decryption_failed alerts may permit certain attacks against CBC mode as used in TLS [CBCATT]. It is preferable to uniformly use the bad_record_mac alert to hide the specific type of the error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：TLS [CBCATT]で使用されるbad_record_mac間微分しdecryption_failedアラートがCBCモードに対する特定の攻撃を可能にすることができます。一様にエラーの特定のタイプを非表示にするbad_record_macアラートを使用することが好ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
record_overflow A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
record_overflow A TLSCiphertextレコードは長さ以上2 ^ 14 + 2048バイト、または以上2 ^ 14の+ 1024バイトとTLSCompressedレコードに復号化されたレコードを有していたことを受け取りました。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
decompression_failure The decompression function received improper input (e.g., data that would expand to excessive length). This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
減圧機能decompression_failure不適切な入力（過剰な長さに拡大する、例えば、データ）を受け取りました。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
handshake_failure Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
握手_警告メッセージの握手_レセプションは、送信者が利用可能なオプション特定のセキュリティパラメータの許容可能なセットを交渉することができなかったことを示しています。これは致命的なエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
no_certificate_RESERVED This alert was used in SSLv3 but not in TLS. It should not be sent by compliant implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
no_certificate_RESERVEDこのアラートは、SSLv3のではなく、TLSを使用しました。これは、準拠した実装で送るべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
bad_certificate A certificate was corrupt, contained signatures that did not verify correctly, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明書が破損したbad_certificate、正しく検証しませんでした署名などが含まれてい
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unsupported_certificate A certificate was of an unsupported type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
unsupported_certificate証明書はサポートされていないタイプでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_revoked A certificate was revoked by its signer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明書は、その署名者によって取り消されましたcertificate_revoked。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_expired A certificate has expired or is not currently valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明書の有効期限が切れたり、現在有効ではありませんしていcertificate_expired。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_unknown Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他のいくつかの（詳細不明）問題certificate_unknown容認できない、それをレンダリング、証明書の処理で生じました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
illegal_parameter A field in the handshake was out of range or inconsistent with other fields. This is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
握手のフィールドillegal_parameter範囲外であったか、他のフィールドと矛盾。これは、常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unknown_ca A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn&#39;t be matched with a known, trusted CA. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
unknown_ca有効な証明書チェーンまたは部分的にチェーンを受信しましたが、証明書は、CA証明書が見つかりませんでしたので、受け入れられなかったか、知られている、信頼できるCAと一致することができませんでしたこのメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
access_denied A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS_DENIED有効な証明書を受信しましたが、アクセス制御が適用されたとき、送信者が交渉を進めないことを決定しました。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
decode_error A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのフィールドは、指定された範囲外であったか、メッセージの長さが間違っていたのでdecode_errorメッセージをデコードできませんでした。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
decrypt_error A handshake cryptographic operation failed, including being unable to correctly verify a signature, decrypt a key exchange, or validate a finished message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェーク暗号演算decrypt_error正しく署名を検証鍵交換を復号化、または完成したメッセージを検証することができないことを含めて、失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
export_restriction_RESERVED This alert was used in TLS 1.0 but not TLS 1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このアラートは、TLS 1.1、TLS 1.0ではなく、使用されたexport_restriction_RESERVED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
protocol_version The protocol version the client has attempted to negotiate is recognized but not supported. (For example, old protocol versions might be avoided for security reasons). This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが交渉しようとしたプロトコルバージョンをPROTOCOL_VERSION認識しますが、サポートされていません。 （例えば、古いプロトコルバージョンは、セキュリティ上の理由から回避される可能性があります）。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
insufficient_security Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがクライアントによってサポートされているものよりもより安全な暗号を必要とするため、交渉が具体的に失敗したときinsufficient_securityは握手_の代わりに返されます。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
internal_error An internal error unrelated to the peer or the correctness of the protocol (such as a memory allocation failure) makes it impossible to continue. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピアまたは（例えば、メモリ割り当て障害など）プロトコルの正確とは無関係INTERNAL_ERROR内部エラーが継続することを不可能にします。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
user_canceled This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
user_canceledこのハンドシェイクは、プロトコルのエラーとは関係のない理由でキャンセルされています。握手だけでは、close_notifyを送信することにより、接続を閉じる、完了した後、ユーザーが操作をキャンセルした場合、より適切です。このアラートの後には、close_notifyが続くべきです。このメッセージは、一般的警告です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
no_renegotiation Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert. At that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate is where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
no_renegotiationは、初期ハンドシェイクの後にクライアントハローに応じて、ハロー要求に応じて、クライアントまたはサーバーによって送信されます。これらのいずれかが正常に再交渉につながります。それが適切でない場合、受信者はこのアラートに応答する必要があります。その時点で、オリジナルのリクエスタは、接続を続行するかどうかを決定することができます。サーバは要求を満たすためのプロセスを生み出した場合、これは適切であろう一つの場合です。このプロセスは、起動時にセキュリティパラメータ（鍵長、認証など）を受ける可能性があり、その時点の後に、これらのパラメータの変更を通信することは困難かもしれません。このメッセージは、常に警告です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For all errors where an alert level is not explicitly specified, the sending party MAY determine at its discretion whether this is a fatal error or not; if an alert with a level of warning is received, the receiving party MAY decide at its discretion whether to treat this as a fatal error or not. However, all messages that are transmitted with a level of fatal MUST be treated as fatal messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警戒レベルが明示的に指定されていないすべてのエラーのため、送信側は、これは致命的なエラーであるかどうかをその裁量により決定することができます。警告のレベルの警報を受信した場合、受信側は致命的なエラーとしてこれを治療するかどうかをその裁量で決めることができます。しかし、致命的なレベルで送信されるすべてのメッセージは致命的なメッセージとして扱われなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
New alert values MUST be defined by RFC 2434 Standards Action. See Section 11 for IANA Considerations for alert values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいアラートの値は、RFC 2434の標準アクションで定義されなければなりません。警報値のためのIANAの考慮事項については、セクション11を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Handshake Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。ハンドシェイクプロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cryptographic parameters of the session state are produced by the TLS Handshake Protocol, which operates on top of the TLS Record Layer. When a TLS client and server first start communicating, they agree on a protocol version, select cryptographic algorithms, optionally authenticate each other, and use public-key encryption techniques to generate shared secrets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セッション状態の暗号パラメータは、TLSレコード層の上で動作TLSハンドシェイクプロトコルによって生成されます。 TLSクライアントとサーバが最初に通信を開始すると、彼らは、必要に応じて相互に認証、暗号化アルゴリズムを選択し、共有秘密を生成するために、公開鍵暗号化技術を使用し、プロトコルバージョンについては同意します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS Handshake Protocol involves the following steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSハンドシェイクプロトコルは、次の手順を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Exchange hello messages to agree on algorithms, exchange random values, and check for session resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 為替helloメッセージは、アルゴリズムに同意し、ランダムな値を交換し、セッション再開をチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Exchange the necessary cryptographic parameters to allow the client and server to agree on a premaster secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - クライアントとサーバがプレマスター秘密に同意できるようにするために必要な暗号パラメータを交換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Exchange certificates and cryptographic information to allow the client and server to authenticate themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 為替証明書と暗号情報は、クライアントとサーバーが自分自身を認証できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Generate a master secret from the premaster secret and exchanged random values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - このpremaster_secretからマスターシークレットを生成し、ランダムな値を交換しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Provide security parameters to the record layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 記録層にセキュリティパラメータを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Allow the client and server to verify that their peer has calculated the same security parameters and that the handshake occurred without tampering by an attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - クライアントとサーバがそのピアが同じセキュリティパラメータを計算し、ハンドシェイクが攻撃者によって改ざんせずに発生したことをしていることを確認できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that higher layers should not be overly reliant on whether TLS always negotiates the strongest possible connection between two peers. There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support. The protocol has been designed to minimize this risk, but there are still attacks available. For example, an attacker could block access to the port a secure service runs on, or attempt to get the peers to negotiate an unauthenticated connection. The fundamental rule is that higher levels must be cognizant of what their security requirements are and never transmit information over a channel less secure than what they require. The TLS protocol is secure in that any cipher suite offers its promised level of security: if you negotiate 3DES with a 1024 bit RSA key exchange with a host whose certificate you have verified, you can expect to be that secure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上位層は、TLSは常に2つのピア間の最強の可能な接続をネゴシエートするかどうかに過度に依存すべきではないことに注意してください。 man-in-the-middle攻撃者は2つのエンティティが、彼らがサポートする最も安全な方法まで低下させることを試みることができる多くの方法があります。プロトコルは、このリスクを最小限に抑えるように設計されていますが、利用可能な攻撃が残っています。例えば、攻撃者は、安全なサービスを実行しているポートへのアクセスをブロックする、またはピアが認証されていない接続を交渉するために取得しようとする可能性があり。基本的なルールは、より高いレベルがそのセキュリティ要件が何であるかを認識することと、彼らが必要とするものよりも安全チャネルを介して情報を送信することはありませんしなければならないということです。証明書あなたが確認したホストとの1024ビットRSA鍵交換と3DESを交渉するならば、あなたはその安全であることを期待することができます：TLSプロトコルは、任意の暗号スイートは、セキュリティの約束のレベルを提供することで安全です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, one SHOULD never send data over a link encrypted with 40-bit security unless one feels that data is worth no more than the effort required to break that encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1は、データがその暗号を破るために必要な労力を超えない価値があると感じている場合を除きしかし、一つは40ビットセキュリティで暗号化されたリンクを介してデータを送信することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These goals are achieved by the handshake protocol, which can be summarized as follows: The client sends a client hello message to which the server must respond with a server hello message, or else a fatal error will occur and the connection will fail. The client hello and server hello are used to establish security enhancement capabilities between client and server. The client hello and server hello establish the following attributes: Protocol Version, Session ID, Cipher Suite, and Compression Method. Additionally, two random values are generated and exchanged: ClientHello.random and ServerHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの目標は、次のように要約することができるハンドシェイクプロトコルによって達成される：クライアントは、サーバがサーバハローメッセージで応答しなければならない、または他の致命的なエラーが発生しますと、接続が失敗する先のクライアントhelloメッセージを送信します。クライアントハローとサーバハローは、クライアントとサーバ間のセキュリティ強化機能を確立するために使用されています。プロトコルバージョン、セッションID、暗号スイート、および圧縮方法：クライアントハローとサーバはハロー次の属性を確立します。さらに、2つのランダムな値が生成され、交換される：ClientHello.randomとしてServerHello.randomを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The actual key exchange uses up to four messages: the server certificate, the server key exchange, the client certificate, and the client key exchange. New key exchange methods can be created by specifying a format for these messages and by defining the use of the messages to allow the client and server to agree upon a shared secret. This secret MUST be quite long; currently defined key exchange methods exchange secrets that range from 48 to 128 bytes in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ証明書、サーバの鍵交換、クライアント証明書、およびクライアント鍵交換：実際のキー交換は4つのまでのメッセージを使用しています。新しい鍵交換方法は、これらのメッセージの形式を指定することで、クライアントとサーバが共有秘密に同意できるようにするためにメッセージの使用を定義することによって作成することができます。この秘密は非常に長くする必要があります。現在、長さが48から128バイトの範囲で鍵交換方法交換秘密を定義しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Following the hello messages, the server will send its certificate, if it is to be authenticated. Additionally, a server key exchange message may be sent, if it is required (e.g., if the server has no certificate, or if its certificate is for signing only). If the server is authenticated, it may request a certificate from the client, if that is appropriate to the cipher suite selected. Next, the server will send the server hello done message, indicating that the hello-message phase of the handshake is complete. The server will then wait for a client response. If the server has sent a certificate request message, the client must send the certificate message. The client key exchange message is now sent, and the content of that message will depend on the public key algorithm selected between the client hello and the server hello. If the client has sent a certificate with signing ability, a digitally- signed certificate verify message is sent to explicitly verify the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが認証される場合はhelloメッセージに続き、サーバは、その証明書を送信します。それが必要な場合、さらに、サーバーキー交換メッセージは、送信されても​​よい（例えば、サーバは全く証明書を持たない場合、またはその証明書が署名のみのためのものである場合）。サーバーが認証された場合には、選択された暗号スイートに適切であれば、それは、クライアントからの証明書を要求することができます。次に、サーバは、サーバハローがハンドシェイクのハロー・メッセージ・フェーズが完了したことを示す、メッセージを行って送信します。その後、サーバーはクライアントの応答を待ちます。サーバが証明書要求メッセージを送信した場合、クライアントは、証明書のメッセージを送信する必要があります。クライアント鍵交換メッセージは、現在送信され、そのメッセージの内容は、クライアントハローとサーバハローの間で選択された公開鍵アルゴリズムに依存します。クライアントが署名能力を持つ証明書を送信した場合、digitally-署名証明書は、メッセージが明示的に証明書を検証するために送信されることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At this point, a change cipher spec message is sent by the client, and the client copies the pending Cipher Spec into the current Cipher Spec. The client then immediately sends the finished message under the new algorithms, keys, and secrets. In response, the server will send its own change cipher spec message, transfer the pending to the current Cipher Spec, and send its finished message under the new Cipher Spec. At this point, the handshake is complete, and the client and server may begin to exchange application layer data. (See flow chart below.) Application data MUST NOT be sent prior to the completion of the first handshake (before a cipher suite other TLS_NULL_WITH_NULL_NULL is established).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この時点で、ChangeCipherSpecメッセージは、現在の暗号スペックに未決の暗号スペックをクライアントから送信され、クライアントコピーされます。その後、クライアントは、直ちに新しいアルゴリズム、鍵、および秘密の下に完成したメッセージを送信します。それに応答して、サーバは、自身のChangeCipherSpecメッセージを送信します現在の暗号スペックに未決を転送し、新しい暗号スペックの下でその完成メッセージを送信します。この時点で、ハンドシェイクが完了し、クライアントとサーバは、アプリケーション層のデータを交換し始めるかもしれません。 （以下のフローチャートを参照してください。）アプリケーションデータ（他のTLS_NULL_WITH_NULL_NULLが確立されている暗号スイートの前に）最初のハンドシェイクが完了する前に送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ClientHello                  --------&gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      Application Data             &lt;-------&gt;     Application Data
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fig. 1. Message flow for a full handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図フルハンドシェーク1.メッセージフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Indicates optional or situation-dependent messages that are not always sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*常に送信されていないオプションや状況依存のメッセージを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: To help avoid pipeline stalls, ChangeCipherSpec is an independent TLS Protocol content type, and is not actually a TLS handshake message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：パイプラインの停止を避けるために、ChangeCipherSpecを、独立したTLSプロトコルコンテンツタイプであり、実際TLSハンドシェイクメッセージではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client and server decide to resume a previous session or duplicate an existing session (instead of negotiating new security parameters), the message flow is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバは、前のセッションを再開するか、（代わりに新しいセキュリティパラメータを交渉の）既存のセッションを複製することを決定した場合は、次のように、メッセージフローは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client sends a ClientHello using the Session ID of the session to be resumed. The server then checks its session cache for a match.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが再開されるセッションのセッションIDを使用してClientHelloを送信します。その後、サーバーは、一致するセッションキャッシュをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a match is found, and the server is willing to re-establish the connection under the specified session state, it will send a ServerHello with the same Session ID value. At this point, both client and server MUST send change cipher spec messages and proceed directly to finished messages. Once the re-establishment is complete, the client and server MAY begin to exchange application layer data. (See flow chart below.) If a Session ID match is not found, the server generates a new session ID and the TLS client and server perform a full handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一致するものが見つかった、とサーバーが指定されたセッション状態の下でコネクションを再確立しようとした場合は、同じセッションIDの値を含めたServerHelloメッセージを送信します。この時点で、クライアントとサーバの両方は、ChangeCipherSpecメッセージを送らなければなりませんし、完成したメッセージに直接進みます。再確立が完了すると、クライアントとサーバは、アプリケーション層のデータを交換し始めるかもしれません。セッションIDの一致が見つからない場合（下のフローチャートを参照してください。）、サーバーは新しいセッションIDを生成し、TLSクライアントとサーバは完全な握手を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ClientHello                   --------&gt;
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    &lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&gt;
      Application Data              &lt;-------&gt;     Application Data
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fig. 2. Message flow for an abbreviated handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図略記ハンドシェーク2.メッセージフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The contents and significance of each message will be presented in detail in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ及び各メッセージの意味は、以下のセクションで詳細に提示されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Handshake Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4。ハンドシェイクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS Handshake Protocol is one of the defined higher-level clients of the TLS Record Protocol. This protocol is used to negotiate the secure attributes of a session. Handshake messages are supplied to the TLS Record Layer, where they are encapsulated within one or more TLSPlaintext structures, which are processed and transmitted as specified by the current active session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSハンドシェイクプロトコルは、TLSレコードプロトコルの定義されたより高いレベルのクライアントの一つです。このプロトコルは、セッションの安全な属性を交渉するために使用されます。ハンドシェイクメッセージは、それらが現在アクティブなセッション状態によって指定されるように処理され、送信される1つのまたは複数のTLSPlaintext構造内に封入されているTLSレコード層に供給されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_hello_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
          } body;
      } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The handshake protocol messages are presented below in the order they MUST be sent; sending handshake messages in an unexpected order results in a fatal error. Unneeded handshake messages can be omitted, however. Note one exception to the ordering: the Certificate message is used twice in the handshake (from server to client, then from client to server), but is described only in its first position. The one message that is not bound by these ordering rules is the Hello Request message, which can be sent at any time, but which should be ignored by the client if it arrives in the middle of a handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
握手プロトコルメッセージは、それらが送らなければならないために、以下に提示します。致命的なエラーで予期しないため結果にハンドシェイクメッセージを送信します。不要なハンドシェイクメッセージは、しかし、省略することができます。発注の例外に注意してください：Certificateメッセージは、（その後、クライアントからサーバに、サーバーからクライアントへの）ハンドシェイクで二回使用されているが、唯一のその最初の位置に記述されています。これらの発注ルールに縛られていない一つのメッセージをいつでも送信することができますが、それは握手の途中に到着した場合、クライアントによって無視されるべきこんにちはRequestメッセージ、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
New Handshake message type values MUST be defined via RFC 2434 Standards Action. See Section 11 for IANA Considerations for these values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいハンドシェイクメッセージタイプの値は、RFC 2434の標準アクションで定義されなければなりません。これらの値のIANAの考慮事項については、セクション11を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. Hello Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1。 helloメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The hello phase messages are used to exchange security enhancement capabilities between the client and server. When a new session begins, the Record Layer&#39;s connection state encryption, hash, and compression algorithms are initialized to null. The current connection state is used for renegotiation messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハロー位相メッセージは、クライアントとサーバ間のセキュリティ強化機能を交換するために使用されています。新しいセッションが始まると、レコード層の接続状態の暗号化、ハッシュ、および圧縮アルゴリズムはnullに初期化されます。現在の接続状態が再交渉メッセージに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1. Hello request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1。こんにちはリクエスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The hello request message MAY be sent by the server at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハロー要求メッセージは、いつでもサーバによって送信されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hello request is a simple notification that the client should begin the negotiation process anew by sending a client hello message when convenient. This message will be ignored by the client if the client is currently negotiating a session. This message may be ignored by the client if it does not wish to renegotiate a session, or the client may, if it wishes, respond with a no_renegotiation alert. Since handshake messages are intended to have transmission precedence over application data, it is expected that the negotiation will begin before no more than a few records are received from the client. If the server sends a hello request but does not receive a client hello in response, it may close the connection with a fatal alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
こんにちは要求は、クライアントが都合のよいときに、クライアントのhelloメッセージを送信することにより、新たに交渉プロセスを開始する必要があり、単純な通知です。クライアントが現在のセッションを交渉している場合、このメッセージはクライアントによって無視されます。それは、セッションを再交渉したくない場合、このメッセージは、クライアントによって無視されてもよいし、クライアントは、それが希望する場合、no_renegotiationのアラートに応答することができます。ハンドシェイクメッセージは、アプリケーションデータを介した送信の優先順位を有することが意図されているので、それを超えない数のレコードがクライアントから受信される前に交渉が開始されることが期待されます。サーバはハローリクエストを送信しますが、応答でクライアントのhelloを受信しない場合、それは致命的な警告との接続を閉じることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After sending a hello request, servers SHOULD not repeat the request until the subsequent handshake negotiation is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その後の握手交渉が完了するまでのhello要求を送信した後、サーバはリクエストを繰り返すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             struct { } HelloRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: This message MUST NOT be included in the message hashes that are maintained throughout the handshake and used in the finished messages and the certificate verify message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：このメッセージは、ハンドシェイクを通じて維持し、完成したメッセージと証明書を確認するメッセージで使用されているメッセージのハッシュに含まれてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2. Client Hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2。クライアントこんにちは
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client first connects to a server it is required to send the client hello as its first message. The client can also send a client hello in response to a hello request or on its own initiative in order to renegotiate the security parameters in an existing connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが最初のサーバに接続するときには、その最初のメッセージとして、クライアントのhelloを送信するために必要とされます。また、クライアントは、ハロー要求したり、既存の接続におけるセキュリティパラメータを再交渉するために、自らに応じて、クライアントのhelloを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client hello message includes a random structure, which is used later in the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントハローメッセージは、プロトコルの後半で使用されるランダム構造を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
         uint32 gmt_unix_time;
         opaque random_bytes[28];
      } Random;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
gmt_unix_time The current time and date in standard UNIX 32-bit format (seconds since the midnight starting Jan 1, 1970, GMT, ignoring leap seconds) according to the sender&#39;s internal clock. Clocks are not required to be set correctly by the basic TLS Protocol; higher-level or application protocols may define additional requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者の内部クロックに従って（うるう秒を無視して、1970年1月1日、GMTを開始午前0時からの秒）の標準的なUNIX 32ビットフォーマットで現在の時刻と日付をgmt_unix_time。時計は、基本的なTLSプロトコルによって正しく設定されている必要はありません。より高いレベルまたはアプリケーション・プロトコルが追加要件を定義してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         random_bytes
             28 bytes generated by a secure random number generator.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client hello message includes a variable-length session identifier. If not empty, the value identifies a session between the same client and server whose security parameters the client wishes to reuse. The session identifier MAY be from an earlier connection, from this connection, or from another currently active connection. The second option is useful if the client only wishes to update the random structures and derived values of a connection, and the third option makes it possible to establish several independent secure connections without repeating the full handshake protocol. These independent connections may occur sequentially or simultaneously; a SessionID becomes valid when the handshake negotiating it completes with the exchange of Finished messages and persists until it is removed due to aging or because a fatal error was encountered on a connection associated with the session. The actual contents of the SessionID are defined by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントハローメッセージは、可変長のセッション識別子を含みます。空でない場合、値は、セキュリティパラメータ、クライアントが再利用しようと、同じクライアントとサーバ間のセッションを識別する。セッション識別子は、以前の接続から、この接続から、または別の現在アクティブな接続からのものであってもよいです。クライアントのみランダム構造や接続の派生値を更新したい、そして第三の選択肢は、完全なハンドシェイクプロトコルを繰り返さずに、いくつかの独立した安全な接続を確立することを可能にする場合は、2番目のオプションが便利です。これらの独立した接続を順次又は同時に起こり得ます。それを交渉のハンドシェイクが完成メッセージの交換を完了し、それが経年や致命的なエラーがセッションに関連付けられている接続に遭遇したため、削除されるまで持続したときにセッションIDが有効になります。セッションIDの実際の内容はサーバーによって定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque SessionID&lt;0..32&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明なセッションID &lt;0 32&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warning: Because the SessionID is transmitted without encryption or immediate MAC protection, servers MUST not place confidential information in session identifiers or let the contents of fake session identifiers cause any breach of security. (Note that the content of the handshake as a whole, including the SessionID, is protected by the Finished messages exchanged at the end of the handshake.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告：セッションIDは、暗号化または即時MAC保護なしで送信されるため、サーバはセッション識別子に秘密情報を置くか、偽のセッション識別子の内容は、セキュリティの違反を起こさせてはなりません。 （ハンドシェイクの終了時に交換SessionIDを含む全体としてのハンドシェイクのコンテンツは、Finishedメッセージによって保護されることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CipherSuite list, passed from the client to the server in the client hello message, contains the combinations of cryptographic algorithms supported by the client in order of the client&#39;s preference (favorite choice first). Each CipherSuite defines a key exchange algorithm, a bulk encryption algorithm (including secret key length), and a MAC algorithm. The server will select a cipher suite or, if no acceptable choices are presented, return a handshake failure alert and close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのhelloメッセージでクライアントからサーバに渡されたのCipherSuiteのリストは、クライアントの好み（最初のお気に入りの選択）のために、クライアントでサポートされている暗号アルゴリズムの組み合わせが含まれています。それぞれのCipherSuiteは、鍵交換アルゴリズム、（秘密鍵の長さを含む）をバルク暗号化アルゴリズム、およびMACアルゴリズムを定義します。サーバーは、暗号スイートを選択するか、受け入れ可能な選択肢が提示されていない場合、handshake_failureアラートを返して接続を閉じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      uint8 CipherSuite[2];    /* Cryptographic suite selector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client hello includes a list of compression algorithms supported by the client, ordered according to the client&#39;s preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのhelloが、クライアントの好みに応じて注文したクライアントでサポートされている圧縮アルゴリズムのリストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ProtocolVersion client_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suites&lt;2..2^16-1&gt;;
          CompressionMethod compression_methods&lt;1..2^8-1&gt;;
      } ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client_version The version of the TLS protocol by which the client wishes to communicate during this session. This SHOULD be the latest (highest valued) version supported by the client. For this version of the specification, the version will be 3.2. (See Appendix E for details about backward compatibility.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがこのセッション中に通信することを希望することにより、TLSプロトコルのバージョンをクライアント_。これは、クライアントがサポートする最新（最高のもの）であるべきです。仕様のこのバージョンでは、バージョンが3.2になります。 （後方互換性の詳細については、付録Eを参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
random A client-generated random structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ランダムクライアントが生成したランダム構造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
session_id The ID of a session the client wishes to use for this connection. This field should be empty if no session_id is available or if the client wishes to generate new security parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、この接続のために使用したいセッションのIDを。 session_idが利用可能でない場合、場合またはクライアントが新しいセキュリティパラメータを生成することを希望する場合は、このフィールドは空でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_suites This is a list of the cryptographic options supported by the client, with the client&#39;s first preference first. If the session_id field is not empty (implying a session resumption request) this vector MUST include at least the cipher_suite from that session. Values are defined in Appendix A.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_suitesこれは、最初のクライアントの最初の好みで、クライアントによってサポートされている暗号オプションのリストです。 SESSION_IDフィールドが空でない場合、このベクターは、そのセッションからの少なくとも暗号_スイートを含まなければなりません（セッション再開要求を意味します）。値は、付録A.5で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
compression_methods This is a list of the compression methods supported by the client, sorted by client preference. If the session_id field is not empty (implying a session resumption request) it MUST include the compression_method from that session. This vector MUST contain, and all implementations MUST support, CompressionMethod.null. Thus, a client and server will always be able to agree on a compression method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
圧縮_これは、クライアントの好みによってソートされたクライアントによってサポートされている圧縮方法のリストです。 SESSION_IDフィールドは、（セッション再開要求を含意して）空でない場合には、そのセッションのcompression_methodを含まなければなりません。このベクターは含まなければならない、とすべての実装は、CompressionMethod.nullをサポートしなければなりません。このように、クライアントとサーバは常に圧縮方法に同意することができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After sending the client hello message, the client waits for a server hello message. Any other handshake message returned by the server except for a hello request is treated as a fatal error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのhelloメッセージを送信した後、クライアントは、サーバのhelloメッセージを待機します。ハロー要求を除いて、サーバから返された任意の他の握手メッセージは致命的なエラーとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Forward compatibility note: In the interests of forward compatibility, it is permitted that a client hello message include extra data after the compression methods. This data MUST be included in the handshake hashes, but must otherwise be ignored. This is the only handshake message for which this is legal; for all other messages, the amount of data in the message MUST match the description of the message precisely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前方互換性に関する注意：上位互換性の利益では、圧縮方法の後に余分なデータが含まれ、クライアントのhelloメッセージことを許可されています。このデータは握手ハッシュに含まれなければならないが、それ以外は無視されなければなりません。これは、これが法的であるためにのみ握手メッセージです。他のすべてのメッセージについて、メッセージ内のデータの量を正確にメッセージの説明と一致しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: For the intended use of trailing data in the ClientHello, see RFC 3546 [TLSEXT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：のClientHelloでデータを後続の用途については、RFC 3546 [TLSEXT]を参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3. Server Hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3。サーバーこんにちは
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server will send this message in response to a client hello message when it was able to find an acceptable set of algorithms. If it cannot find such a match, it will respond with a handshake failure alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
許容できるセットのアルゴリズムを見つけることができたとき、サーバは、クライアントのhelloメッセージに応答して、このメッセージを送信します。それは、このような一致が見つからない場合は、握手故障警報で応じるでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ProtocolVersion server_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suite;
           CompressionMethod compression_method;
       } ServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
server_version This field will contain the lower of that suggested by the client in the client hello and the highest supported by the server. For this version of the specification, the version is 3.2. (See Appendix E for details about backward compatibility.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SERVER_VERSIONこのフィールドは、クライアントハローにクライアントによって示唆の下を含み、最高サーバによってサポートされます。仕様のこのバージョンでは、バージョンは3.2です。 （後方互換性の詳細については、付録Eを参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
random This structure is generated by the server and MUST be independently generated from the ClientHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ランダムこの構造は、サーバーによって生成され、独立してClientHello.randomとから生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
session_id This is the identity of the session corresponding to this connection. If the ClientHello.session_id was non-empty, the server will look in its session cache for a match. If a match is found and the server is willing to establish the new connection using the specified session state, the server will respond with the same value as was supplied by the client. This indicates a resumed session and dictates that the parties must proceed directly to the finished messages. Otherwise this field will contain a different value identifying the new session. The server may return an empty session_id to indicate that the session will not be cached and therefore cannot be resumed. If a session is resumed, it must be resumed using the same cipher suite it was originally negotiated with.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SESSION_IDこれは、この接続に対応するセッションのアイデンティティがあります。 ClientHello.session_idが空だった場合、サーバーは、一致のためにそのセッションキャッシュになります。一致するものが見つかったと、サーバーは、指定されたセッション状態を使用して新しい接続を確立するために喜んでいる場合は、サーバはクライアントによって供給されたのと同じ値で応答します。これは再開しているセッションを示し、当事者が完成メッセージへ進まなければなりません。それ以外の場合、このフィールドには、新しいセッションを特定する別の値が含まれます。サーバーは、セッションがキャッシュされませんので、再開できないことを示すために、空のsession_idを返す場合があります。セッションが再開された場合、それは元々と交渉したのと同じ暗号スイートを使用して再開する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_suite The single cipher suite selected by the server from the list in ClientHello.cipher_suites. For resumed sessions, this field is the value from the state of the session being resumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でClientHello.cipher_内のリストからサーバーによって選ばれた単一の暗号スイートを暗号_スイート。セッションを再開し、このフィールドは再開されたセッションの状態からの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
compression_method The single compression algorithm selected by the server from the list in ClientHello.compression_methods. For resumed sessions this field is the value from the resumed session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientHello.compression_メソッドのリストから、サーバによって選択された単一の圧縮アルゴリズムを圧縮_。再開したセッションの場合、このフィールドは再開セッション状態からの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. Server Certificate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2。サーバー証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MUST send a certificate whenever the agreed-upon key exchange method is not an anonymous one. This message will always immediately follow the server hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
合意された鍵交換方式が匿名のものではない時はいつでも、サーバーは、証明書を送らなければなりません。このメッセージは、常にすぐにサーバーのhelloメッセージに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The certificate type MUST be appropriate for the selected cipher suite&#39;s key exchange algorithm, and is generally an X.509v3 certificate. It MUST contain a key that matches the key exchange method, as follows. Unless otherwise specified, the signing algorithm for the certificate MUST be the same as the algorithm for the certificate key. Unless otherwise specified, the public key MAY be of any length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明書の種類は、選択された暗号スイートの鍵交換アルゴリズムに適切である、と一般的にX.509v3証明書である必要があります。それは次のように、鍵交換方式と一致するキーを含まなければなりません。特に指定がない限り、証明書の署名アルゴリズムは、証明書のキーのためのアルゴリズムと同じでなければなりません。特に指定しない限り、公開鍵は、任意の長さのものであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Key Exchange Algorithm Certificate Key Type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鍵交換アルゴリズム証明書キーの種類
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSA RSA public key; the certificate MUST allow the key to be used for encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSA RSA公開鍵。証明書は、鍵が暗号化に使用されることを許容しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DHE_DSS DSS public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DHE_DSS DSS公開鍵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DHE_RSA RSA public key that can be used for signing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
署名に使用することができますDHE_RSA RSA公開鍵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DH_DSS Diffie-Hellman key. The algorithm used to sign the certificate MUST be DSS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DH_DSSのDiffie-Hellman鍵。証明書に署名するために使用されるアルゴリズムはDSSでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DH_RSA Diffie-Hellman key. The algorithm used to sign the certificate MUST be RSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DH_RSAのDiffie-Hellman鍵。証明書に署名するために使用されるアルゴリズムはRSAでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All certificate profiles and key and cryptographic formats are defined by the IETF PKIX working group [PKIX]. When a key usage extension is present, the digitalSignature bit MUST be set for the key to be eligible for signing, as described above, and the keyEncipherment bit MUST be present to allow encryption, as described above. The keyAgreement bit must be set on Diffie-Hellman certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての証明書プロファイルおよびキーと暗号フォーマットはIETF PKIXワーキンググループ[PKIX]によって定義されています。鍵用途拡張が存在する場合、デジタル署名ビットは上述したように、署名の対象とされるキーを設定する必要があり、及びkeyEnciphermentビットは、上述したように、暗号化を可能にするために存在しなければなりません。するKeyAgreementビットはのDiffie-Hellman証明書に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As CipherSuites that specify new key exchange methods are specified for the TLS Protocol, they will imply certificate format and the required encoded keying information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい鍵交換方法を指定しているCipherSuiteは、TLSプロトコルに指定されているとして、彼らは、証明書の形式と必要なエンコードされたキーイング情報を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque ASN.1Cert&lt;1..2^24-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明ASN.1Cert &lt;1..2 ^ 24-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
      } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_list This is a sequence (chain) of X.509v3 certificates. The sender&#39;s certificate must come first in the list. Each following certificate must directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority may optionally be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_listこれはのX.509v3証明書のシーケンス（連鎖）です。送信者の証明書は、リストの最初に来なければなりません。それぞれの次の証明書は直接それに先行するものを証明する必要があります。証明書の検証がルートキーは独立に分布されることを必要とするので、ルート認証局を特定する自己署名証明書は、必要に応じて、リモートエンドが既にどのような場合に、それを検証するためにそれを持っていなければならないという仮定の下で、チェーンから省略されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The same message type and structure will be used for the client&#39;s response to a certificate request message. Note that a client MAY send no certificates if it does not have an appropriate certificate to send in response to the server&#39;s authentication request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じメッセージタイプと構造は、証明書要求メッセージに対するクライアントの応答のために使用されます。それは、サーバーの認証要求に応答して送信するための適切な証明書を持っていない場合、クライアントは何の証明書を送信しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: PKCS #7 [PKCS7] is not used as the format for the certificate vector because PKCS #6 [PKCS6] extended certificates are not used. Also, PKCS #7 defines a SET rather than a SEQUENCE, making the task of parsing the list more difficult.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：PKCS＃6 [PKCS6】拡張証明書が使用されないので、PKCS＃7 [PKCS7]は、証明書ベクトルの形式として使用されていません。また、PKCS＃7は、リストを解析する作業がより困難に、SETはなくSEQUENCEを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. Server Key Exchange Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3。サーバー鍵交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This message will be sent immediately after the server certificate message (or the server hello message, if this is an anonymous negotiation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（これが匿名の交渉である場合、またはサーバーのhelloメッセージ）このメッセージは、サーバ証明書のメッセージの直後に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server key exchange message is sent by the server only when the server certificate message (if sent) does not contain enough data to allow the client to exchange a premaster secret. This is true for the following key exchange methods:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー証明書のメッセージは、（送信された場合）クライアントが前マスター秘密を交換できるようにするための十分なデータが含まれていない場合にのみ、サーバー鍵交換メッセージがサーバによって送信されます。これは、次の鍵交換方法についても同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           DHE_DSS
           DHE_RSA
           DH_anon
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is not legal to send the server key exchange message for the following key exchange methods:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の鍵交換方式のためのサーバ鍵交換メッセージを送信するために法的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           RSA
           DH_DSS
           DH_RSA
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This message conveys cryptographic information to allow the client to communicate the premaster secret: either an RSA public key with which to encrypt the premaster secret, or a Diffie-Hellman public key with which the client can complete a key exchange (with the result being the premaster secret).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
結果があることでプレマスターシークレットを暗号化するとRSA公開鍵、またはクライアントが鍵交換を完了することができたを使ってDiffie-Hellman公開鍵（いずれか：このメッセージは、クライアントが秘密のプレマスターを通信できるようにするために、暗号化情報を伝えますこのpremaster_secret）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As additional CipherSuites are defined for TLS that include new key exchange algorithms, the server key exchange message will be sent if and only if the certificate type associated with the key exchange algorithm does not provide enough information for the client to exchange a premaster secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
追加のCipherSuitesが新しい鍵交換アルゴリズムを含むTLSのために定義されているように、サーバ鍵交換メッセージが送信されます場合は、キー交換アルゴリズムに関連付けられた証明書の種類がプレマスターの秘密を交換するためのクライアントのための十分な情報を提供しない場合にのみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { rsa, diffie_hellman } KeyExchangeAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque rsa_modulus&lt;1..2^16-1&gt;;
          opaque rsa_exponent&lt;1..2^16-1&gt;;
      } ServerRSAParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
rsa_modulus The modulus of the server&#39;s temporary RSA key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSAは、サーバーの一時的RSA鍵のモジュラスモジュラス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
rsa_exponent The public exponent of the server&#39;s temporary RSA key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーの一時的RSA鍵の公開指数をrsa_exponent。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque dh_p&lt;1..2^16-1&gt;;
          opaque dh_g&lt;1..2^16-1&gt;;
          opaque dh_Ys&lt;1..2^16-1&gt;;
      } ServerDHParams;     /* Ephemeral DH parameters */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dh_p The prime modulus used for the Diffie-Hellman operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Diffie-Hellman演算に使用されるプライムモジュラスをdh_p。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dh_g The generator used for the Diffie-Hellman operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Diffie-Hellman演算に使用される発電機をdh_g。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dh_Ys The server&#39;s Diffie-Hellman public value (g^X mod p).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーののDiffie-Hellman公開値（g ^ Xモッズp）dh_Ys。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (KeyExchangeAlgorithm) {
              case diffie_hellman:
                  ServerDHParams params;
                  Signature signed_params;
              case rsa:
                  ServerRSAParams params;
                  Signature signed_params;
          };
      } ServerKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (KeyExchangeAlgorithm) {
              case diffie_hellman:
                  ServerDHParams params;
              case rsa:
                  ServerRSAParams params;
          };
       } ServerParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
params The server&#39;s key exchange parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバの鍵交換パラメータをparamsは。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
signed_params For non-anonymous key exchanges, a hash of the corresponding params value, with the signature appropriate to that hash applied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非匿名鍵交換のsigned_pa​​rams、そのハッシュに適切な署名を有する対応のparams値のハッシュは、適用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
md5_hash MD5(ClientHello.random + ServerHello.random + ServerParams);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
md5_hash MD5（ClientHello.randomと+ ServerHello.random + ServerParams）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
sha_hash SHA(ClientHello.random + ServerHello.random + ServerParams);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
sha_hash SHA（ClientHello.randomと+ ServerHello.random + ServerParams）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { anonymous, rsa, dsa } SignatureAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (SignatureAlgorithm) {
              case anonymous: struct { };
              case rsa:
                  digitally-signed struct {
                      opaque md5_hash[16];
                      opaque sha_hash[20];
                  };
              case dsa:
                  digitally-signed struct {
                      opaque sha_hash[20];
                  };
              };
          };
      } Signature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. Certificate request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4。証明書の要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A non-anonymous server can optionally request a certificate from the client, if it is appropriate for the selected cipher suite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは選択された暗号スイートに適切であれば非匿名のサーバは、クライアントからの証明書を要求、必要に応じてすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This message, if sent, will immediately follow the Server Key Exchange message (if it is sent; otherwise, the Server Certificate message).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（それが送られた場合、それ以外の場合、サーバー証明書のメッセージ）このメッセージは、送信された場合は、すぐにサーバ鍵交換メッセージに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
       fortezza_dms_RESERVED(20),
          (255)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
} ClientCertificateType;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientCertificateType}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque DistinguishedName&lt;1..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明な識別名&lt;1..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
          DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
      } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_types This field is a list of the types of certificates requested, sorted in order of the server&#39;s preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明書_このフィールドは、サーバの優先順にソートされた要求された証明書の種類のリストがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_authorities A list of the distinguished names of acceptable certificate authorities. These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe both known roots and a desired authorization space. If the certificate_authorities list is empty then the client MAY send any certificate of the appropriate ClientCertificateType, unless there is some external arrangement to the contrary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
許容できる認証局の識別名のリストを証明してください。これらの識別名は、ルートCAまたは下位CAのために必要な識別名を指定することもできます。したがって、このメッセージは、既知の根および所望の許可スペースの両方を記述するために使用することができます。証明してリストが空の場合は逆に、いくつかの外部の配列が存在しない限り、クライアントは、適切なClientCertificateTypeのいずれかの証明書を送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientCertificateType values are divided into three groups:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント証明書の種類の値は、三つのグループに分けられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Values from 0 (zero) through 63 decimal (0x3F) inclusive are reserved for IETF Standards Track protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
包括的な63進（は0x3F）を介して、0（ゼロ）から1の値は、IETF標準化過程プロトコルのために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Values from 64 decimal (0x40) through 223 decimal (0xDF) inclusive are reserved for assignment for non-Standards Track methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
64進（0x40の）から包括223小数（0xDF）を介して2値は、非標準化過程法の割り当てのために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Values from 224 decimal (0xE0) through 255 decimal (0xFF) inclusive are reserved for private use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
224小数（0xE0となって）から包括255小数（0xff）の3値は、私的使用のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Additional information describing the role of IANA in the allocation of ClientCertificateType code points is described in Section 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientCertificateTypeコードポイントの割り当てにおけるIANAの役割を記述する追加情報は、セクション11に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Values listed as RESERVED may not be used. They were used in SSLv3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：RESERVEDとして記載されている値が使用されない場合があります。彼らは、SSLv3の中で使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: DistinguishedName is derived from [X501]. DistinguishedNames are represented in DER-encoded format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：識別名は[X501]から誘導されます。 DistinguishedNamesはDERエンコード形式で表現されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: It is a fatal handshake_failure alert for an anonymous server to request client authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：これは、クライアント認証を要求する匿名サーバーのための致命的なhandshake_failureアラートとなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. Server Hello Done
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5。 Serverは、こんにちは完了します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server hello done message is sent by the server to indicate the end of the server hello and associated messages. After sending this message, the server will wait for a client response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバハロー行わメッセージがサーバハローと関連するメッセージの終わりを示すために、サーバによって送信されます。このメッセージを送信した後、サーバーは、クライアントの応答を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This message means that the server is done sending messages to support the key exchange, and the client can proceed with its phase of the key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージは、サーバが鍵交換をサポートするために、メッセージを送信して行われていることを意味し、クライアントは、鍵交換のその段階に進むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon receipt of the server hello done message, the client SHOULD verify that the server provided a valid certificate, if required and check that the server hello parameters are acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーハロー行われたメッセージを受信すると、クライアントは、必要に応じて、サーバーは、有効な証明書を提供していることを確認し、サーバーのhelloパラメータが許容可能であることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct { } ServerHelloDone;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.6. Client certificate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.6。クライアント証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is the first message the client can send after receiving a server hello done message. This message is only sent if the server requests a certificate. If no suitable certificate is available, the client SHOULD send a certificate message containing no certificates. That is, the certificate_list structure has a length of zero. If client authentication is required by the server for the handshake to continue, it may respond with a fatal handshake failure alert. Client certificates are sent using the Certificate structure defined in Section 7.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、クライアントがサーバハロー行ってメッセージを受信した後、送信することができます最初のメッセージです。サーバーが証明書を要求した場合、このメッセージにのみ送信されます。もし適切な証明書が利用できない場合、クライアントは証明書を全く含まない証明書メッセージを送信する必要があります。つまり、certificate_list構造は、ゼロの長さを有します。クライアント認証を継続するためのハンドシェイクのために、サーバーによって要求された場合、それは致命的な握手故障警報で応答することができます。クライアント証明書は、セクション7.4.2で定義された証明書の構造を使用して送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: When using a static Diffie-Hellman based key exchange method (DH_DSS or DH_RSA), if client authentication is requested, the Diffie-Hellman group and generator encoded in the client&#39;s certificate MUST match the server specified Diffie-Hellman parameters if the client&#39;s parameters are to be used for the key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：静的なディフィー - ヘルマンベースの鍵交換法（DH_DSS又はDH_RSA）を使用する場合、クライアント認証が要求された場合、クライアントのパラメータの場合は、クライアントの証明書でエンコードのDiffie-Hellmanグループ及びジェネレータは、サーバ指定のDiffie-Hellmanパラメータと一致しなければなりません鍵交換のために使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7. Client Key Exchange Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7。クライアント鍵交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This message is always sent by the client. It MUST immediately follow the client certificate message, if it is sent. Otherwise it MUST be the first message sent by the client after it receives the server hello done message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージは、常にクライアントによって送信されます。それが送信された場合は、直ちに、クライアント証明書メッセージに従わなければなりません。それは、サーバハロー行ってメッセージを受信した後、それ以外の場合は、クライアントから送信された最初のメッセージでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With this message, the premaster secret is set, either though direct transmission of the RSA-encrypted secret or by the transmission of Diffie-Hellman parameters that will allow each side to agree upon the same premaster secret. When the key exchange method is DH_RSA or DH_DSS, client certification has been requested, and the client was able to respond with a certificate that contained a Diffie-Hellman public key whose parameters (group and generator) matched those specified by the server in its certificate, this message MUST not contain any data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージでは、このpremaster_secretは、RSA暗号化秘密の直接伝送かかわらまたはそれぞれの側が同じプレマスター秘密に同意することを可能にするのDiffie-Hellmanパラメータを送信することにより、いずれか、設定されています。鍵交換方式がDH_RSAまたはDH_DSSである場合には、クライアント認証が要求されている、そしてクライアントがパラメータ（グループおよび発電機）のDiffie-Hellman公開鍵を含ま証明書で応答することができた、その証明書のサーバーで指定されたものと一致しましたこのメッセージは、任意のデータを含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The choice of messages depends on which key exchange method has been selected. See Section 7.4.3 for the KeyExchangeAlgorithm definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージの選択が鍵交換方式が選択されているに依存します。 KeyExchangeAlgorithm定義に関してセクション7.4.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (KeyExchangeAlgorithm) {
              case rsa: EncryptedPreMasterSecret;
              case diffie_hellman: ClientDiffieHellmanPublic;
          } exchange_keys;
      } ClientKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.1. RSA Encrypted Premaster Secret Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.1。 RSA暗号化されたプレマスターシークレットメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If RSA is being used for key agreement and authentication, the client generates a 48-byte premaster secret, encrypts it using the public key from the server&#39;s certificate or the temporary RSA key provided in a server key exchange message, and sends the result in an encrypted premaster secret message. This structure is a variant of the client key exchange message and is not a message in itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSAが主要な協定と認証に使用されている場合、クライアントは、48バイトのpremaster_secretを生成するサーバーの証明書またはサーバーキー交換メッセージに提供する一時的RSA鍵から公開鍵を使って暗号化し、中に結果を送信しますプリマスター秘密のメッセージを暗号化。この構造は、クライアント鍵交換メッセージの変種であり、それ自体ではメッセージではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ProtocolVersion client_version;
          opaque random[46];
      } PreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client_version The latest (newest) version supported by the client. This is used to detect version roll-back attacks. Upon receiving the premaster secret, the server SHOULD check that this value matches the value transmitted by the client in the client hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがサポートする最新バージョンをクライアント_。これは、バージョンロールバック攻撃を検出するために使用されます。 premaster_secretを受信すると、サーバは、この値は、クライアントのhelloメッセージに、クライアントによって送信された値と一致することを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
random 46 securely-generated random bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ランダム46確実に、生成されたランダムバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
pre_master_secret This random value is generated by the client and is used to generate the master secret, as specified in Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pre_master_secretはこの乱数値はクライアントによって生成され、セクション8.1で指定されるように、マスターシークレットを生成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: An attack discovered by Daniel Bleichenbacher [BLEI] can be used to attack a TLS server that is using PKCS#1 v 1.5 encoded RSA. The attack takes advantage of the fact that, by failing in different ways, a TLS server can be coerced into revealing whether a particular message, when decrypted, is properly PKCS#1 v1.5 formatted or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：ダニエルBleichenbacherの[BLEI]によって発見された攻撃は、PKCS＃1 V 1.5エンコードされたRSAを使用しているTLSサーバを攻撃するために使用することができます。攻撃は、様々な方法で失敗することによって、TLSサーバは解読特定のメッセージが、適切にPKCS＃1 V1.5フォーマットであるか否かを明らかに強制することができる、という事実を利用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         The best way to avoid vulnerability to this attack is to treat
         incorrectly formatted messages in a manner indistinguishable
         from correctly formatted RSA blocks.  Thus, when a server
         receives an incorrectly formatted RSA block, it should generate
         a random 48-byte value and proceed using it as the premaster
         secret.  Thus, the server will act identically whether the
         received RSA block is correctly encoded or not.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKCS1B] defines a newer version of PKCS#1 encoding that is more secure against the Bleichenbacher attack. However, for maximal compatibility with TLS 1.0, TLS 1.1 retains the original encoding. No variants of the Bleichenbacher attack are known to exist provided that the above recommendations are followed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【PKCS1B] Bleichenbacherの攻撃に対してより安全であるPKCS＃1の符号化の新しいバージョンを定義します。しかし、TLS 1.0との最大の互換性のために、TLS 1.1は、元のエンコーディングを保持します。 Bleichenbacherの攻撃のいかなる変異体は、上記の勧告に従っていることを提供存在することが知られていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementation Note: Public-key-encrypted data is represented as an opaque vector &lt;0..2^16-1&gt; (see Section 4.7). Thus, the RSA-encrypted PreMasterSecret in a ClientKeyExchange is preceded by two length bytes. These bytes are redundant in the case of RSA because the EncryptedPreMasterSecret is the only data in the ClientKeyExchange and its length can therefore be unambiguously determined. The SSLv3 specification was not clear about the encoding of public-key-encrypted data, and therefore many SSLv3 implementations do not include the length bytes, encoding the RSA encrypted data directly in the ClientKeyExchange message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装上の注意：公開鍵で暗号化されたデータは不透明なベクトルとして表され、&lt;0..2 ^ 16-1&gt;（4.7節を参照してください）。したがって、ClientKeyExchangeでRSA暗号化されたPreMasterSecretは、二つの長さバイトが先行します。 EncryptedPreMasterSecretはClientKeyExchangeその長さのデータのみが、従って明確に決定することが可能であるため、これらのバイトは、RSAの場合には冗長です。 SSLv3仕様は公開鍵暗号化データの符号化について明確ではなかったので、多くのSSLv3実装は、RSAは、ClientKeyExchangeメッセージ内のデータを直接暗号化コード、長さバイトを含みません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        This specification requires correct encoding of
                        the EncryptedPreMasterSecret complete with
                        length bytes.  The resulting PDU is incompatible
                        with many SSLv3 implementations.  Implementors
                        upgrading from SSLv3 must modify their
                        implementations to generate and accept the
                        correct encoding.  Implementors who wish to be
                        compatible with both SSLv3 and TLS should make
                        their implementation&#39;s behavior dependent on the
                        protocol version.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementation Note: It is now known that remote timing-based attacks on SSL are possible, at least when the client and server are on the same LAN. Accordingly, implementations that use static RSA keys SHOULD use RSA blinding or some other anti-timing technique, as described in [TIMING].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装上の注意：これは、今、SSL上のリモートタイミングベースの攻撃は、クライアントとサーバが同じLAN上にある少​​なくともとき、可能であることが知られています。 [タイミング]で説明されるようしたがって、静的RSAキーを使用する実装は、RSAの盲目またはいくつかの他の抗タイミング技法を使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The version number in the PreMasterSecret MUST be the version offered by the client in the ClientHello, not the version negotiated for the connection. This feature is designed to prevent rollback attacks. Unfortunately, many implementations use the negotiated version instead, and therefore checking the version number may lead to failure to interoperate with such incorrect client implementations. Client implementations, MUST and Server implementations MAY, check the version number. In practice, since the TLS handshake MACs prevent downgrade and no good attacks are known on those MACs, ambiguity is not considered a serious security risk. Note that if servers choose to check the version number, they should randomize the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：たPreMasterSecretにバージョン番号はのClientHelloにクライアントによって提供されたバージョンではなく、接続のために交渉バージョンである必要があります。この機能は、ロールバック攻撃を防ぐように設計されています。残念ながら、多くの実装ではなく、ネゴシエートバージョンを使用するため、バージョン番号をチェックすることは、そのような不正なクライアント実装と相互運用の失敗につながる可能性があります。クライアントの実装、MUSTとサーバーの実装は、バージョン番号を確認するかもしれません。 TLSハンドシェイクのMACはダウングレードを防止しない良い攻撃がこれらのMacで知られていないので、実際には、あいまいさは、深刻なセキュリティ上のリスクとはみなされません。サーバはバージョン番号を確認することを選択した場合、彼らはランダム化する必要があることに注意してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         PreMasterSecret in case of error, rather than generate an
         alert, in order to avoid variants on the Bleichenbacher attack.
         [KPR03]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.2. Client Diffie-Hellman Public Value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.2。クライアントのDiffie-Hellman公開値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This structure conveys the client&#39;s Diffie-Hellman public value (Yc) if it was not already included in the client&#39;s certificate. The encoding used for Yc is determined by the enumerated PublicValueEncoding. This structure is a variant of the client key exchange message and not a message in itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはすでにクライアントの証明書に含まれていなかった場合は、この構造はクライアントのディフィー-Hellman公開値（YC）を伝えます。 Ycのために使用される符号化は、列挙型のPublicValueEncodingによって決定されます。この構造は、クライアント鍵交換メッセージのバリアントではなく、それ自体ではメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
implicit If the client certificate already contains a suitable Diffie-Hellman key, then Yc is implicit and does not need to be sent again. In this case, the client key exchange message will be sent, but it MUST be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント証明書がすでに、適切なのDiffie-Hellmanキーが含まれている場合は、暗黙の、そしてYcのは暗黙的で、再び送られる必要はありません。この場合、クライアント鍵交換メッセージが送信されますが、それは空である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
explicit Yc needs to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
明示的なYcを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (PublicValueEncoding) {
              case implicit: struct { };
              case explicit: opaque dh_Yc&lt;1..2^16-1&gt;;
          } dh_public;
      } ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dh_Yc The client&#39;s Diffie-Hellman public value (Yc).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのディフィー-Hellman公開値（YC）dh_Yc。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.8. Certificate verify
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.8。証明書が検証します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This message is used to provide explicit verification of a client certificate. This message is only sent following a client certificate that has signing capability (i.e., all certificates except those containing fixed Diffie-Hellman parameters). When sent, it MUST immediately follow the client key exchange message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージは、クライアント証明書の明示的な検証を提供するために使用されます。このメッセージは、機能のみを署名したクライアント証明書下記送信される（すなわち、それらを含有する固定のDiffie-Hellmanパラメータを除くすべての証明書）。送信された場合は、すぐにクライアント鍵交換メッセージに従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
           Signature signature;
      } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Signature type is defined in 7.4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
署名タイプが7.4.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerify.signature.md5_hash MD5(handshake_messages);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerify.signature.md5_hash MD5（握手）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerify.signature.sha_hash SHA(handshake_messages);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerify.signature.sha_hash SHA（握手）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here handshake_messages refers to all handshake messages sent or received starting at client hello up to but not including this message, including the type and length fields of the handshake messages. This is the concatenation of all the Handshake structures, as defined in 7.4, exchanged thus far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでは、クライアントから始まる送信または受信したすべてのハンドシェイクメッセージを参照握手ハローが、ハンドシェイクメッセージのタイプと長さフィールドを含む、このメッセージを含めないようにアップ。 7.4で定義されている。これは、すべてのHandshake構造の連結です、これまでに交換しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.9. Finished
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.9。完成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A finished message is always sent immediately after a change cipher spec message to verify that the key exchange and authentication processes were successful. It is essential that a change cipher spec message be received between the other handshake messages and the Finished message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完成したメッセージは、常に鍵交換と認証プロセスが成功したことを確認するために、変更暗号仕様メッセージの直後に送信されます。 ChangeCipherSpecメッセージは、他のハンドシェイクメッセージとFinishedメッセージの間で送受信されることが不可欠です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The finished message is the first protected with the just-negotiated algorithms, keys, and secrets. Recipients of finished messages MUST verify that the contents are correct. Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完成したメッセージはただ交渉アルゴリズム、鍵、および秘密で保護最初です。完成したメッセージの受信者は、内容が正しいことを確かめなければなりません。側面がFinishedメッセージを送受信し、そのピアからのFinishedメッセージを検証した後、それが接続を介してアプリケーションデータを送受信するために開始することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque verify_data[12];
      } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
verify_data PRF(master_secret, finished_label, MD5(handshake_messages) + SHA-1(handshake_messages)) [0..11];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
verify_data PRF（マスター_、finished_label、MD5（握手）+ SHA-1（握手））[0..11]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
finished_label For Finished messages sent by the client, the string &#34;client finished&#34;. For Finished messages sent by the server, the string &#34;server finished&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントから送信されたFinishedメッセージについてはfinished_label、文字列「クライアントが終了しました」。サーバによって送信されるFinishedメッセージについては、文字列「サーバが終わっ」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
handshake_messages All of the data from all messages in this handshake (not including any HelloRequest messages) up to but not including this message. This is only data visible at the handshake layer and does not include record layer headers. This is the concatenation of all the Handshake structures, as defined in 7.4, exchanged thus far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
握手（どんなHelloRequestメッセージを含まない）、このハンドシェイクのすべてのメッセージからのデータの全てまでが、このメッセージを含んでいません。これは、ハンドシェイク層における可視データのみであり、記録層ヘッダを含んでいません。 7.4で定義されている。これは、すべてのHandshake構造の連結です、これまでに交換しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is a fatal error if a finished message is not preceded by a change cipher spec message at the appropriate point in the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完成したメッセージが握手で適切なポイントでChangeCipherSpecメッセージに先行されていない場合は、致命的なエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The value handshake_messages includes all handshake messages starting at client hello up to, but not including, this finished message. This may be different from handshake_messages in Section 7.4.8 because it would include the certificate verify message (if sent). Also, the handshake_messages for the finished message sent by the client will be different from that for the finished message sent by the server, because the one that is sent second will include the prior one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでhandshake_messagesは、クライアントから始まる、しかし、この完成したメッセージを含んでいないすべてのハンドシェイクメッセージが含まれています。 （送信された場合）は、証明書検証メッセージを含むことになるので、これは、セクション7.4.8に握手異なっていてもよいです。第二送られる1は、従来の1が含まれますので、また、クライアントから送信され、完成したメッセージのための握手は、サーバーから送信された完成したメッセージとは異なるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Change cipher spec messages, alerts, and any other record types are not handshake messages and are not included in the hash computations. Also, Hello Request messages are omitted from handshake hashes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：メッセージはハンドシェイクされていないと、ハッシュ計算には含まれていない暗号仕様メッセージ、警告、およびその他のレコードタイプを変更します。また、ハロー要求メッセージは握手ハッシュから省略されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Cryptographic Computations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.暗号計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to begin connection protection, the TLS Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The authentication, encryption, and MAC algorithms are determined by the cipher_suite selected by the server and revealed in the server hello message. The compression algorithm is negotiated in the hello messages, and the random values are exchanged in the hello messages. All that remains is to calculate the master secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続保護を開始するためには、TLSレコードプロトコルは、アルゴリズムのスイート、マスターシークレット、およびクライアントとサーバーのランダムな値を指定する必要があります。認証、暗号化、およびMACアルゴリズムがサーバハローメッセージ内のサーバによって選択されたと明らかにした暗号_スイートによって決定されます。圧縮アルゴリズムは、helloメッセージに交渉され、ランダムな値がhelloメッセージで交換されています。残っているのは、マスターシークレットを計算することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Computing the Master Secret
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。マスターシークレットの計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For all key exchange methods, the same algorithm is used to convert the pre_master_secret into the master_secret. The pre_master_secret should be deleted from memory once the master_secret has been computed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての鍵交換方法については、同じアルゴリズムがpre_master_secretをmaster_secretに変換するために使用されます。 master_secretが計算されると、pre_master_secretはメモリから削除されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       master_secret = PRF(pre_master_secret, &#34;master secret&#34;,
                           ClientHello.random + ServerHello.random)
       [0..47];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The master secret is always exactly 48 bytes in length. The length of the premaster secret will vary depending on key exchange method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マスターシークレットの長さは常に正確に48バイトです。このpremaster_secretの長さは、鍵交換方式によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. RSA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1。 RSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When RSA is used for server authentication and key exchange, a 48- byte pre_master_secret is generated by the client, encrypted under the server&#39;s public key, and sent to the server. The server uses its private key to decrypt the pre_master_secret. Both parties then convert the pre_master_secret into the master_secret, as specified above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSAは、サーバー認証と鍵交換のために使用されている場合は、48-バイトのpre_master_secretは、クライアントによって生成されたサーバの公開鍵で暗号化し、サーバーに送信されます。サーバーは、前_のマスター_秘密を解読するためにその秘密鍵を使用しています。両当事者は、その後、上記のような方法でmaster_secretに前_のマスター_秘密に変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSA digital signatures are performed using PKCS #1 [PKCS1] block type 1. RSA public key encryption is performed using PKCS #1 block type 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSAデジタル署名は、PKCS＃1を使用して行われる[PKCS1ブロックタイプ1 RSA公開鍵暗号は、PKCS＃1ブロックタイプ2を使用して実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. Diffie-Hellman
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2。ディフィー・ヘルマン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A conventional Diffie-Hellman computation is performed. The negotiated key (Z) is used as the pre_master_secret, and is converted into the master_secret, as specified above. Leading bytes of Z that contain all zero bits are stripped before it is used as the pre_master_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従来のDiffie-Hellman計算が行われます。ネゴシエートされたキー（Z）は、前_のマスター_秘密として使用され、上記指定されるように、マスター_に変換されます。それは前_のマスター_秘密として使用される前に、すべてのゼロのビットを含むZの先頭バイトが取り除かれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Diffie-Hellman parameters are specified by the server and may be either ephemeral or contained within the server&#39;s certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：のDiffie-Hellmanパラメータは、サーバによって指定され、一時的またはサーバの証明書内に含まれるのいずれであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Mandatory Cipher Suites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.必須の暗号スイート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the absence of an application profile standard specifying otherwise, a TLS compliant application MUST implement the cipher suite TLS_RSA_WITH_3DES_EDE_CBC_SHA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうでなければ特定のアプリケーションプロファイル規格の非存在下で、TLS準拠アプリケーションは、暗号スイートTLS_RSA_WITH_3DES_EDE_CBC_SHAを実装しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Application Data Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.アプリケーションデータプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Application data messages are carried by the Record Layer and are fragmented, compressed, and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションデータメッセージはレコード層によって運ばれ、断片化され、圧縮され、現在の接続状態に基づいて暗号化されています。メッセージは、記録層への透過的なデータとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.セキュリティについての考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Security issues are discussed throughout this memo, especially in Appendices D, E, and F.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティの問題は、特に付録D、E、およびFに、このメモ中で議論されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes a number of new registries that have been created by IANA. We recommended that they be placed as individual registries items under a common TLS category.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、IANAによって作成された新しいレジストリの数を示します。我々は、彼らが共通TLSカテゴリの下に、個々のレジストリ項目として配置することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 7.4.3 describes a TLS ClientCertificateType Registry to be maintained by the IANA, defining a number of such code point identifiers. ClientCertificateType identifiers with values in the range 0-63 (decimal) inclusive are assigned via RFC 2434 Standards Action. Values from the range 64-223 (decimal) inclusive are assigned via [RFC2434] Specification Required. Identifier values from 224-255 (decimal) inclusive are reserved for RFC 2434 Private Use. The registry will initially be populated with the values in this document, Section 7.4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション7.4.3は、コード・ポイント識別子の数を定義する、IANAによって維持されるTLS ClientCertificateTypeレジストリを記述する。包含範囲0-63（10進数）の値を持つClientCertificateType識別子はRFC 2434標準化アクションを経由して割り当てられます。範囲64から223（10進数）包括の値は[RFC2434]仕様必須介して割り当てられています。包括的な224から255（10進数）からの識別子の値は、RFC 2434私的使用のために予約されています。レジストリは、最初にこの文書に記載されている値は、7.4.4が取り込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section A.5 describes a TLS Cipher Suite Registry to be maintained by the IANA, and it defines a number of such cipher suite identifiers. Cipher suite values with the first byte in the range 0-191 (decimal) inclusive are assigned via RFC 2434 Standards Action. Values with the first byte in the range 192-254 (decimal) are assigned via RFC 2434 Specification Required. Values with the first byte 255 (decimal) are reserved for RFC 2434 Private Use. The registry will initially be populated with the values from Section A.5 of this document, [TLSAES], and from Section 3 of [TLSKRB].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクションA.5はIANAによって維持されるTLS暗号スイートレジストリについて説明し、そのような暗号スイート識別子の数を定義します。範囲0から191（10進数）包括的で最初のバイトを持つ暗号スイート値は、RFC 2434標準アクションを経由して割り当てられます。範囲192から254（10進数）の最初のバイトでの値は、RFC 2434仕様が必要経由して割り当てられます。最初のバイト255（10進数）との値は、RFC 2434私的使用のために予約されています。レジストリは、最初にこのドキュメントのセクションA.5から、[TLSAES]、および[TLSKRB]のセクション3からの値が取り込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 6 requires that all ContentType values be defined by RFC 2434 Standards Action. IANA has created a TLS ContentType registry, initially populated with values from Section 6.2.1 of this document. Future values MUST be allocated via Standards Action as described in [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第6節では、すべてのContentTypeを値がRFC 2434の標準アクションで定義されている必要があります。 IANAは当初、このドキュメントのセクション6.2.1からの値で埋め、TLS ContentTypeをレジストリを作成しました。 [RFC2434]で説明されるように将来の値は標準化作用を介して割り当てられなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 7.2.2 requires that all Alert values be defined by RFC 2434 Standards Action. IANA has created a TLS Alert registry, initially populated with values from Section 7.2 of this document and from Section 4 of [TLSEXT]. Future values MUST be allocated via Standards Action as described in [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7.2.2項では、すべてのアラートの値はRFC 2434標準アクションで定義されている必要があります。 IANAは、最初にこのドキュメントのセクション7.2からおよび[TLSEXT]のセクション4からの値で埋め、TLS警告レジストリを作成しました。 [RFC2434]で説明されるように将来の値は標準化作用を介して割り当てられなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 7.4 requires that all HandshakeType values be defined by RFC 2434 Standards Action. IANA has created a TLS HandshakeType registry, initially populated with values from Section 7.4 of this document and from Section 2.4 of [TLSEXT]. Future values MUST be allocated via Standards Action as described in [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7.4節では、すべてのHandshakeType値はRFC 2434標準アクションで定義されている必要があります。 IANAは当初、このドキュメントのセクション7.4からおよび[TLSEXT]の2.4節からの値で埋め、TLS HandshakeTypeレジストリを作成しました。 [RFC2434]で説明されるように将来の値は標準化作用を介して割り当てられなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. Protocol Constant Values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A.プロトコル定数値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes protocol types and constants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、プロトコルの種類と定数について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1. Record Layer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1。レコード層
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       uint8 major, minor;
   } ProtocolVersion;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ProtocolVersion version = { 3, 2 };     /* TLS v1.1 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum {
       change_cipher_spec(20), alert(21), handshake(22),
       application_data(23), (255)
   } ContentType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSCompressed.length];
   } TLSCompressed;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       select (CipherSpec.cipher_type) {
           case stream: GenericStreamCipher;
           case block:  GenericBlockCipher;
       } fragment;
   } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   stream-ciphered struct {
       opaque content[TLSCompressed.length];
       opaque MAC[CipherSpec.hash_size];
   } GenericStreamCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   block-ciphered struct {
       opaque IV[CipherSpec.block_length];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       opaque content[TLSCompressed.length];
       opaque MAC[CipherSpec.hash_size];
       uint8 padding[GenericBlockCipher.padding_length];
       uint8 padding_length;
   } GenericBlockCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.2. Change Cipher Specs Message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.2。変更暗号仕様メッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       enum { change_cipher_spec(1), (255) } type;
   } ChangeCipherSpec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.3. Alert Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.3。警告メッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum {
           close_notify(0),
           unexpected_message(10),
           bad_record_mac(20),
           decryption_failed(21),
           record_overflow(22),
           decompression_failure(30),
           handshake_failure(40),
           no_certificate_RESERVED (41),
           bad_certificate(42),
           unsupported_certificate(43),
           certificate_revoked(44),
           certificate_expired(45),
           certificate_unknown(46),
           illegal_parameter(47),
           unknown_ca(48),
           access_denied(49),
           decode_error(50),
           decrypt_error(51),
           export_restriction_RESERVED(60),
           protocol_version(70),
           insufficient_security(71),
           internal_error(80),
           user_canceled(90),
           no_renegotiation(100),
           (255)
       } AlertDescription;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4. Handshake Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4。ハンドシェイクプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_hello_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20), (255)
   } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       HandshakeType msg_type;
       uint24 length;
       select (HandshakeType) {
           case hello_request:       HelloRequest;
           case client_hello:        ClientHello;
           case server_hello:        ServerHello;
           case certificate:         Certificate;
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done:   ServerHelloDone;
           case certificate_verify:  CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished:            Finished;
       } body;
   } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4.1. Hello messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4.1。 helloメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct { } HelloRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
   } Random;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque SessionID&lt;0..32&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明なセッションID &lt;0 32&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
uint8 CipherSuite[2];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UINT8のCipherSuite [2]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites&lt;2..2^16-1&gt;;
       CompressionMethod compression_methods&lt;1..2^8-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
} ClientHello;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientHello}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ProtocolVersion server_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suite;
       CompressionMethod compression_method;
   } ServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4.2. Server Authentication and Key Exchange Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4.2。サーバー認証と鍵交換のメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque ASN.1Cert&lt;2^24-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明ASN.1Cert &lt;2 ^ 24-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
   } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { rsa, diffie_hellman } KeyExchangeAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       opaque rsa_modulus&lt;1..2^16-1&gt;;
       opaque rsa_exponent&lt;1..2^16-1&gt;;
   } ServerRSAParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       opaque dh_p&lt;1..2^16-1&gt;;
       opaque dh_g&lt;1..2^16-1&gt;;
       opaque dh_Ys&lt;1..2^16-1&gt;;
   } ServerDHParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       select (KeyExchangeAlgorithm) {
           case diffie_hellman:
               ServerDHParams params;
               Signature signed_params;
           case rsa:
               ServerRSAParams params;
               Signature signed_params;
       };
   } ServerKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { anonymous, rsa, dsa } SignatureAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       select (KeyExchangeAlgorithm) {
           case diffie_hellman:
               ServerDHParams params;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           case rsa:
               ServerRSAParams params;
       };
   } ServerParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       select (SignatureAlgorithm) {
           case anonymous: struct { };
           case rsa:
               digitally-signed struct {
                   opaque md5_hash[16];
                   opaque sha_hash[20];
               };
           case dsa:
               digitally-signed struct {
                   opaque sha_hash[20];
               };
           };
       };
   } Signature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum {
       rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
    fortezza_dms_RESERVED(20),
    (255)
   } ClientCertificateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque DistinguishedName&lt;1..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明な識別名&lt;1..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
       DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
   } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct { } ServerHelloDone;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4.3. Client Authentication and Key Exchange Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4.3。クライアント認証と鍵交換のメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       select (KeyExchangeAlgorithm) {
           case rsa: EncryptedPreMasterSecret;
           case diffie_hellman: ClientDiffieHellmanPublic;
       } exchange_keys;
   } ClientKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ProtocolVersion client_version;
       opaque random[46];
   }
   PreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       public-key-encrypted PreMasterSecret pre_master_secret;
   } EncryptedPreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       select (PublicValueEncoding) {
           case implicit: struct {};
           case explicit: opaque DH_Yc&lt;1..2^16-1&gt;;
       } dh_public;
   } ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       Signature signature;
   } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4.4. Handshake Finalization Message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4.4。握手ファイナライズのメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       opaque verify_data[12];
   } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5. The CipherSuite
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5。 CipherSuite
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following values define the CipherSuite codes used in the client hello and server hello messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の値は、クライアントハローとサーバのhelloメッセージに使用されるのCipherSuiteコードを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A CipherSuite defines a cipher specification supported in TLS Version 1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CipherSuiteは、TLSバージョン1.1でサポートされる暗号仕様を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a TLS connection during the first handshake on that channel, but must not be negotiated, as it provides no more protection than an unsecured connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS_NULL_WITH_NULL_NULLは、指定された、そのチャネル上の最初のハンドシェイクの間のTLS接続の初期状態であり、それはセキュリティで保護されていない接続を超えない保護を提供するように、交渉されてはならないれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CipherSuite TLS_NULL_WITH_NULL_NULL = { 0x00,0x00 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CipherSuite TLS_NULL_WITH_NULL_NULL = {0x00,0x00}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following CipherSuite definitions require that the server provide an RSA certificate that can be used for key exchange. The server may request either an RSA or a DSS signature-capable certificate in the certificate request message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のCipherSuite定義は、サーバーが鍵交換のために使用することができるRSA証明書を提供する必要があります。サーバは、RSAまたは証明書要求メッセージにおけるDSS署名可能な証明書のいずれかを要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite TLS_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };
    CipherSuite TLS_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };
    CipherSuite TLS_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };
    CipherSuite TLS_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };
    CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };
    CipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };
    CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following CipherSuite definitions are used for server-authenticated (and optionally client-authenticated) Diffie-Hellman. DH denotes cipher suites in which the server&#39;s certificate contains the Diffie-Hellman parameters signed by the certificate authority (CA). DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman parameters are signed by a DSS or RSA certificate that has been signed by the CA. The signing algorithm used is specified after the DH or DHE parameter. The server can request an RSA or DSS signature-capable certificate from the client for client authentication or it may request a Diffie-Hellman certificate. Any Diffie-Hellman certificate provided by the client must use the parameters (group and generator) described by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のCipherSuite定義は、サーバ認証（および必要に応じてクライアント認証）のDiffie-Hellmanのために使用されます。 DHは、サーバーの証明書は、認証局（CA）によって署名のDiffie-Hellmanパラメータが含まれている暗号スイートを示しています。 DHEはのDiffie-Hellmanパラメータは、CAによって署名されたDSSまたはRSA証明書によって署名され短命ディフィー - ヘルマンを示し使用署名アルゴリズムは、DHまたはDHEパラメータの後に指定されています。サーバは、クライアント認証のためにクライアントからRSAまたはDSS署名可能な証明書を要求することができるか、のDiffie-Hellman証明書を要求することができます。クライアントによって提供される任意のDiffie-Hellman証明書がサーバによって記述パラメータ（群と発電機）を使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };
    CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };
    CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };
    CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };
    CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };
    CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };
    CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };
    CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following cipher suites are used for completely anonymous Diffie-Hellman communications in which neither party is authenticated. Note that this mode is vulnerable to man-in-the-middle attacks and is therefore deprecated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の暗号スイートは、いずれの当事者が認証されている完全に匿名のDiffie-Hellman通信に使用されています。このモードでは、man-in-the-middle攻撃に対して脆弱であるため、推奨されませんので注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };
    CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };
    CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When SSLv3 and TLS 1.0 were designed, the United States restricted the export of cryptographic software containing certain strong encryption algorithms. A series of cipher suites were designed to operate at reduced key lengths in order to comply with those regulations. Due to advances in computer performance, these algorithms are now unacceptably weak, and export restrictions have since been loosened. TLS 1.1 implementations MUST NOT negotiate these cipher suites in TLS 1.1 mode. However, for backward compatibility they may be offered in the ClientHello for use with TLS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSLv3およびTLS 1.0を設計したとき、アメリカは、特定の強力な暗号化アルゴリズムを含む暗号ソフトウェアの輸出を制限しました。暗号スイートのシリーズは、それらの規制に準拠するために低減キー長で動作するように設計しました。コンピュータのパフォーマンスの進歩に、これらのアルゴリズムは現在、許容できないほど弱く、および輸出規制が緩ん以来されています。 TLS 1.1実装では、TLS 1.1モードでこれらの暗号スイートを交渉してはなりません。ただし、下位互換性を維持するために、彼らは、TLSで使用するためのClientHelloで提供することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.0 or SSLv3-only servers. TLS 1.1 clients MUST check that the server did not choose one of these cipher suites during the handshake. These ciphersuites are listed below for informational purposes and to reserve the numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.0またはSSLv3の専用サーバ。 TLS 1.1クライアントは、サーバがハンドシェイク中にこれらの暗号スイートのいずれかを選択していないことをチェックしなければなりません。これらの暗号スイートは、情報提供の目的のために以下に記載されており、番号を予約します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };
    CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };
    CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };
    CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };
    CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };
    CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };
    CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };
    CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following cipher suites were defined in [TLSKRB] and are included here for completeness. See [TLSKRB] for details:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の暗号スイートは、[TLSKRB]で定義された万全を期すためにここに含まれています。詳細については、[TLSKRB]を参照してください：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite    TLS_KRB5_WITH_DES_CBC_SHA           = { 0x00,0x1E }:
    CipherSuite    TLS_KRB5_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1F };
    CipherSuite    TLS_KRB5_WITH_RC4_128_SHA           = { 0x00,0x20 };
    CipherSuite    TLS_KRB5_WITH_IDEA_CBC_SHA          = { 0x00,0x21 };
    CipherSuite    TLS_KRB5_WITH_DES_CBC_MD5           = { 0x00,0x22 };
    CipherSuite    TLS_KRB5_WITH_3DES_EDE_CBC_MD5      = { 0x00,0x23 };
    CipherSuite    TLS_KRB5_WITH_RC4_128_MD5           = { 0x00,0x24 };
    CipherSuite    TLS_KRB5_WITH_IDEA_CBC_MD5          = { 0x00,0x25 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following exportable cipher suites were defined in [TLSKRB] and are included here for completeness. TLS 1.1 implementations MUST NOT negotiate these cipher suites.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のエクスポート暗号スイートは、[TLSKRB]で定義された万全を期すためにここに含まれています。 TLS 1.1実装では、これらの暗号スイートを交渉してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    CipherSuite  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA    = { 0x00,0x26};
    CipherSuite  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA    = { 0x00,0x27};
    CipherSuite  TLS_KRB5_EXPORT_WITH_RC4_40_SHA        = { 0x00,0x28};
    CipherSuite  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5    = { 0x00,0x29};
    CipherSuite  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5    = { 0x00,0x2A};
    CipherSuite  TLS_KRB5_EXPORT_WITH_RC4_40_MD5        = { 0x00,0x2B};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following cipher suites were defined in [TLSAES] and are included here for completeness. See [TLSAES] for details:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の暗号スイートは、[TLSAES]で定義された万全を期すためにここに含まれています。詳細については、[TLSAES]を参照してください：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA      = { 0x00, 0x2F };
         CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA   = { 0x00, 0x30 };
         CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA   = { 0x00, 0x31 };
         CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA  = { 0x00, 0x32 };
         CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA  = { 0x00, 0x33 };
         CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA  = { 0x00, 0x34 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA      = { 0x00, 0x35 };
         CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA   = { 0x00, 0x36 };
         CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA   = { 0x00, 0x37 };
         CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA  = { 0x00, 0x38 };
         CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA  = { 0x00, 0x39 };
         CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA  = { 0x00, 0x3A };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cipher suite space is divided into three regions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号スイート空間は3つの領域に分割されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Cipher suite values with first byte 0x00 (zero) through decimal 191 (0xBF) inclusive are reserved for the IETF Standards Track protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
包括小数191（0xbfの）を介して第一のバイトは0x00（ゼロ）と1暗号スイート値は、IETF標準化過程プロトコルのために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Cipher suite values with first byte decimal 192 (0xC0) through decimal 254 (0xFE) inclusive are reserved for assignment for non-Standards Track methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
小数254（0xFEの）を介して、最初のバイトの小数192（0xC0の）包括2.暗号スイート値が非標準化過程法の割り当てのために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Cipher suite values with first byte 0xFF are reserved for private use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のバイトは0xFF 3.暗号スイート値は、私的使用のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Additional information describing the role of IANA in the allocation of cipher suite code points is described in Section 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号スイートのコードポイントの割り当てにおけるIANAの役割を記述する追加情報は、セクション11に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid collision with Fortezza-based cipher suites in SSL 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：暗号スイート値{0x00で、0x1cに}及び{0x00の、0x1Dの}は、SSL 3にフォルテッツァベースの暗号スイートとの衝突を回避するために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.6. The Security Parameters
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.6。セキュリティパラメータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         These security parameters are determined by the TLS Handshake
         Protocol and provided as parameters to the TLS Record Layer in
         order to initialize a connection state.  SecurityParameters
         includes:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            enum { server, client } ConnectionEnd;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            enum { null, rc4, rc2, des, 3des, des40, aes, idea }
            BulkCipherAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            enum { stream, block } CipherType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            enum { null, md5, sha } MACAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /* The algorithms specified in CompressionMethod,
         BulkCipherAlgorithm, and MACAlgorithm may be added to. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            struct {
                ConnectionEnd entity;
                BulkCipherAlgorithm bulk_cipher_algorithm;
                CipherType cipher_type;
                uint8 key_size;
                uint8 key_material_length;
                MACAlgorithm mac_algorithm;
                uint8 hash_size;
                CompressionMethod compression_algorithm;
                opaque master_secret[48];
                opaque client_random[32];
                opaque server_random[32];
            } SecurityParameters;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B. Glossary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録B.用語集
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Advanced Encryption Standard (AES) AES is a widely used symmetric encryption algorithm. AES is a block cipher with a 128, 192, or 256 bit keys and a 16 byte block size. [AES] TLS currently only supports the 128 and 256 bit key sizes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Advanced Encryption Standard（AES）AESは広く使われている対称暗号化アルゴリズムです。 AESは、128、192、または256ビットのキーと16バイトのブロックサイズを有するブロック暗号です。 [AES] TLSは現在、128および256ビットのキーサイズをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
application protocol An application protocol is a protocol that normally layers directly on top of the transport layer (e.g., TCP/IP). Examples include HTTP, TELNET, FTP, and SMTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションプロトコルアプリケーションプロトコルは、（例えば、TCP / IP）、トランスポート層の上に直接、通常、層のプロトコルです。例としては、HTTP、TELNET、FTP、およびSMTPが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
asymmetric cipher See public key cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非対称暗号は、公開鍵暗号方式を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
authentication Authentication is the ability of one entity to determine the identity of another entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証認証とは別のエンティティの同一性を決定する一つのエンティティの能力です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
block cipher A block cipher is an algorithm that operates on plaintext in groups of bits, called blocks. 64 bits is a common block size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブロック暗号暗号ブロックは、ブロックと呼ばれる、ビットのグループに平文で動作するアルゴリズムです。 64ビットは、共通のブロックサイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
bulk cipher A symmetric encryption algorithm used to encrypt large quantities of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バルク暗号大量のデータを暗号化するために使用される対称暗号化アルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher block chaining (CBC) CBC is a mode in which every plaintext block encrypted with a block cipher is first exclusive-ORed with the previous ciphertext block (or, in the case of the first block, with the initialization vector). For decryption, every block is first decrypted, then exclusive-ORed with the previous ciphertext block (or IV).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号ブロック連鎖（CBC）CBCは、（初期化ベクトルを用いて、または、最初のブロックの場合）ブロック暗号で暗号化されたすべての平文ブロックは、前の暗号文ブロックと第一の排他的論理和するモードです。復号化のために、すべてのブロックが最初に排他的論理和は、前の暗号文ブロック（またはIV）を用いて、復号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate As part of the X.509 protocol (a.k.a. ISO Authentication framework), certificates are assigned by a trusted Certificate Authority and provide a strong binding between a party&#39;s identity or some other attributes and its public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
X.509プロトコル（別称、ISO認証フレームワーク）の一環として、証明書、証明書は信頼できる認証局によって割り当てられ、党のアイデンティティまたはその他の属性と公開鍵の間に強い結合を提供しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client The application entity that initiates a TLS connection to a server. This may or may not imply that the client initiated the underlying transport connection. The primary operational difference between the server and client is that the server is generally authenticated, while the client is only optionally authenticated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントサーバーへのTLS接続を開始アプリケーションエンティティ。これは、クライアントが、ベースとなるトランスポート接続を開始したことを意味しない場合があります。サーバとクライアントとの間の主な操作上の違いは、クライアントが唯一のオプションとして認証されている間、サーバーは、一般的に、認証されていることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client write key The key used to encrypt data written by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、クライアントによって書き込まれたデータを暗号化するために使用されるキーのキーを書きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client write MAC secret The secret data used to authenticate data written by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、MACの秘密クライアントによって書き込まれたデータを認証するために使用される秘密データを書き込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
connection A connection is a transport (in the OSI layering model definition) that provides a suitable type of service. For TLS, such connections are peer-to-peer relationships. The connections are transient. Every connection is associated with one session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続接続は、サービスの適切なタイプを提供する（OSI階層化モデルの定義で）輸送です。 TLSのために、そのような接続は、ピア・ツー・ピア関係です。接続が一時的なものです。すべての接続は、1つのセッションに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Data Encryption Standard DES is a very widely used symmetric encryption algorithm. DES is a block cipher with a 56 bit key and an 8 byte block size. Note that in TLS, for key generation purposes, DES is treated as having an 8 byte key length (64 bits), but it still only provides 56 bits of protection. (The low bit of each key byte is presumed to be set to produce odd parity in that key byte.) DES can also be operated in a mode where three independent keys and three encryptions are used for each block of data; this uses 168 bits of key (24 bytes in the TLS key generation method) and provides the equivalent of 112 bits of security. [DES], [3DES]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データ暗号化規格DESは非常に広く使用されている対称暗号化アルゴリズムです。 DESは56ビットキーと8バイトのブロックサイズを有するブロック暗号です。 TLSでなお、鍵生成のために、DESは8バイトの鍵長（64ビット）を有するように処理され、それはまだのみ保護の56ビットを提供します。 （各キーのバイトの下位ビットは、その鍵バイトにおける奇数パリティを生成するように設定されると推定される。）DESはまた、三つの独立したキー三個の暗号化は、データの各ブロックのために使用されるモードで動作させることができます。これは、キーの168ビット（TLS鍵生成方法における24バイト）を使用し、セキュリティの112ビットの同等物を提供します。 [DES]、[3DES]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Digital Signature Standard (DSS) A standard for digital signing, including the Digital Signing Algorithm, approved by the National Institute of Standards and Technology, defined in NIST FIPS PUB 186, &#34;Digital Signature Standard,&#34; published May 1994 by the U.S. Dept. of Commerce. [DSS]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デジタル署名標準（DSS）NIST FIPSのPUB 186で定義されたアメリカ国立標準技術研究所によって承認されたデジタル署名アルゴリズムを含むデジタル署名、のための標準は、「デジタル署名標準」の米国部門で1994年5月に発表されコマース。 [DSS]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
digital signatures Digital signatures utilize public key cryptography and one-way hash functions to produce a signature of the data that can be authenticated, and is difficult to forge or repudiate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デジタル署名デジタル署名を認証することができるデータの署名を生成するために公開鍵暗号と一方向ハッシュ関数を利用して、偽造又は否認することは困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
handshake An initial negotiation between client and server that establishes the parameters of their transactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その取引のパラメータを確立するために、クライアントとサーバ間の最初のネゴシエーションをハンドシェイク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Initialization Vector (IV) When a block cipher is used in CBC mode, the initialization vector is exclusive-ORed with the first plaintext block prior to encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブロック暗号がCBCモードで使用される初期化ベクトル（IV）は、初期化ベクトルは、暗号化の前に最初の平文ブロックとの排他的論理和です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IDEA A 64-bit block cipher designed by Xuejia Lai and James Massey. [IDEA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Xuejia LaiとJames Masseyによって設計IDEA 64ビットブロック暗号。 [アイデア]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Message Authentication Code (MAC) A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージ認証コード（MAC）メッセージ認証コードは、メッセージおよび何らかの秘密データから計算された一方向ハッシュです。秘密データを知らずに偽造することは困難です。その目的は、メッセージが変更されたかどうかを検出することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
master secret Secure secret data used for generating encryption keys, MAC secrets, and IVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号化キー、MACシークレット、IVを生成するために使用される秘密セキュアな秘密データを習得。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MD5 MD5 is a secure hashing function that converts an arbitrarily long data stream into a digest of fixed size (16 bytes). [MD5]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MD5 MD5は、固定サイズのダイジェスト（16バイト）に任意に長いデータ・ストリームを変換するセキュアハッシュ関数です。 [MD5]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
public key cryptography A class of cryptographic techniques employing two-key ciphers. Messages encrypted with the public key can only be decrypted with the associated private key. Conversely, messages signed with the private key can be verified with the public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2個の鍵を使用する暗号技術の公開鍵暗号Aクラス。公開鍵で暗号化されたメッセージにのみ関連する秘密鍵で復号化することができます。逆に、秘密鍵で署名されたメッセージは、公開鍵で検証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
one-way hash function A one-way transformation that converts an arbitrary amount of data into a fixed-length hash. It is computationally hard to reverse the transformation or to find collisions. MD5 and SHA are examples of one-way hash functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方向ハッシュ関数固定長のハッシュへのデータの任意の量を変換する一方向変換。変換を逆にするか、衝突を発見するのは困難です。 MD5とSHAは、一方向ハッシュ関数の例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RC2 A block cipher developed by Ron Rivest at RSA Data Security, Inc. [RSADSI] described in [RC2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RC2]で説明したRSA Data Security社[RSADSI]でロナルド・リベストによって開発されたRC2ブロック暗号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RC4 A stream cipher invented by Ron Rivest. A compatible cipher is described in [SCH].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロナルド・リベストによって発明されたRC4ストリーム暗号。互換性のある暗号は[SCH]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSA A very widely used public-key algorithm that can be used for either encryption or digital signing. [RSA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSA Aは非常に広く、暗号化、デジタル署名のどちらにも使用することができ、公開鍵アルゴリズムを使用していました。 [RSA]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
server The server is the application entity that responds to requests for connections from clients. See also under client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーサーバーは、クライアントからの接続のための要求に応答するアプリケーションエンティティです。クライアントの下でも参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
session A TLS session is an association between a client and a server. Sessions are created by the handshake protocol. Sessions define a set of cryptographic security parameters that can be shared among multiple connections. Sessions are used to avoid the expensive negotiation of new security parameters for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セッションTLSセッションは、クライアントとサーバの間の関連付けです。セッションはハンドシェイクプロトコルによって作成されます。セッションは複数の接続間で共有できる暗号化セキュリティパラメータのセットを定義します。セッションは、接続ごとに新しいセキュリティパラメータの高価な交渉を回避するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
session identifier A session identifier is a value generated by a server that identifies a particular session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セッション識別子は、セッション識別子は、特定のセッションを識別するサーバによって生成された値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
server write key The key used to encrypt data written by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、サーバーによって書き込まれたデータを暗号化するために使用されるキーをキー書きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
server write MAC secret The secret data used to authenticate data written by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、MACの秘密にサーバーによって書き込まれたデータを認証するために使用される秘密データを書き込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA The Secure Hash Algorithm is defined in FIPS PUB 180-2. It produces a 20-byte output. Note that all references to SHA actually use the modified SHA-1 algorithm. [SHA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHAセキュアハッシュアルゴリズムは、FIPS PUB 180-2の中で定義されています。これは、20バイトの出力を生成します。 SHAへのすべての参照が実際に変更SHA-1アルゴリズムを使用することに注意してください。 [SHA]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSL Netscape&#39;s Secure Socket Layer protocol [SSL3]. TLS is based on SSL Version 3.0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSL Netscapeのセキュアソケットレイヤプロトコル[SSL3]。 TLSは、SSLバージョン3.0に基づいています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
stream cipher An encryption algorithm that converts a key into a cryptographically strong keystream, which is then exclusive-ORed with the plaintext.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その後、平文との排他的論理和である、暗号強度の高いキーストリーム、にキーを変換する暗号化アルゴリズムの暗号ストリーム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
symmetric cipher See bulk cipher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
対称暗号は、バルク暗号を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transport Layer Security (TLS) This protocol; also, the Transport Layer Security working group of the Internet Engineering Task Force (IETF). See &#34;Comments&#34; at the end of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トランスポート層セキュリティ（TLS）このプロトコル。インターネットエンジニアリングタスクフォース（IETF）のも、トランスポート・レイヤ・セキュリティワーキンググループ。このドキュメントの最後に「コメント」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix C. CipherSuite Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録C.のCipherSuite定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CipherSuite Key Exchange Cipher Hash
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CipherSuiteは鍵交換暗号ハッシュ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS_NULL_WITH_NULL_NULL NULL NULL NULL TLS_RSA_WITH_NULL_MD5 RSA NULL MD5 TLS_RSA_WITH_NULL_SHA RSA NULL SHA TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_WITH_IDEA_CBC_SHA RSA IDEA_CBC SHA TLS_RSA_WITH_DES_CBC_SHA RSA DES_CBC SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_DH_DSS_WITH_DES_CBC_SHA DH_DSS DES_CBC SHA TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_WITH_DES_CBC_SHA DH_RSA DES_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_WITH_DES_CBC_SHA DHE_DSS DES_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_WITH_DES_CBC_SHA DHE_RSA DES_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_WITH_DES_CBC_SHA DH_anon DES_CBC SHA TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
沙TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128沙TLS_RSA_WITH_IDEA_CBC_SHA RSA IDEA_CBC沙TLS_RSA_WITH_DES_CBC_SHA RSA DES_CBC沙TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC沙TLS_DH_DSS_WITH_DES_CBC_SHA DH_DSS DES_CBC沙TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC沙TLS_DH_RSA_WITH_DES_CBC_SHA DH_RSA DES_CBC沙TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC沙TLS_DHE_DSS_WITH_DES_CBC_SHA DHE_DSSオーバーMD5 TLS_RSA_WITH_NULL_SHA RSAオーバーTLS_NULL_WITH_NULL_NULLヌルヌルヌルTLS_RSA_WITH_NULL_MD5 RSA DES_CBC沙沙TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC TLS_DHE_RSA_WITH_DES_CBC_SHA DHE_RSA DES_CBC沙沙TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_WITH_DES_CBC_SHA DH_anon DES_CBC沙沙TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Key
      Exchange
      Algorithm     Description                        Key size limit
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DHE_DSS Ephemeral DH with DSS signatures None DHE_RSA Ephemeral DH with RSA signatures None DH_anon Anonymous DH, no signatures None DH_DSS DH with DSS-based certificates None DH_RSA DH with RSA-based certificates None RSA = none NULL No key exchange N/A RSA RSA key exchange None
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSAベースの証明書とRSA署名なしDH_anon匿名DH、DSSベースの証明書なしDH_RSA DHと無署名なしDH_DSS DHとDSS署名なしDHE_RSAエフェメラルDHとDHE_DSSエフェメラルDHなしRSA =なしNULLなし鍵交換N / A RSA RSA鍵交換なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 Key Expanded IV Block Cipher Type Material Key Material Size Size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
主な拡張IVブロック暗号タイプ材質主材質サイズサイズ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NULL Stream 0 0 0 N/A IDEA_CBC Block 16 16 8 8 RC2_CBC_40 Block 5 16 8 8 RC4_40 Stream 5 16 0 N/A RC4_128 Stream 16 16 0 N/A DES40_CBC Block 5 8 8 8 DES_CBC Block 8 8 8 8 3DES_EDE_CBC Block 24 24 8 8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NULLストリーム0 0 N / IDEA_CBCブロック16 16 8 8 RC2_CBC_40ブロック5 16 8 8 RC4_40ストリーム5 16 0 N / RC4_128ストリーム16 16 0 N / DES_CBCブロック8 8 8 8 3DES_EDE_CBCブロックDES40_CBCブロック5 8 8 8 24 24 8 8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Type Indicates whether this is a stream cipher or a block cipher running in CBC mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイプは、これはストリーム暗号やCBCモードで実行されているブロック暗号であるかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Key Material The number of bytes from the key_block that are used for generating the write keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号化キーの書き込みキーを生成するために使用されているなkey_blockからのバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Expanded Key Material The number of bytes actually fed into the encryption algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号化キーに実際に暗号化アルゴリズムに供給されたバイト数を拡大しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IV Size The amount of data needed to be generated for the initialization vector. Zero for stream ciphers; equal to the block size for block ciphers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IVサイズ初期化ベクトルのために生成されるために必要なデータの量。ストリーム暗号のためのゼロ。ブロック暗号のブロックサイズに等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Block Size The amount of data a block cipher enciphers in one chunk; a block cipher running in CBC mode can only encrypt an even multiple of its block size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブロックサイズデータの量が1つのチャンク内のブロック暗号暗号化し、 CBCモードで実行されているブロック暗号はそのブロックサイズの倍数を暗号化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Hash      Hash      Padding
       function    Size       Size
         NULL       0          0
         MD5        16         48
         SHA        20         40
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix D. Implementation Notes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録D.実装ノート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS protocol cannot prevent many common security mistakes. This section provides several recommendations to assist implementors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSプロトコルは、多くの一般的なセキュリティ上のミスを防ぐことはできません。このセクションでは、実装を支援するために、いくつかの提言を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.1. Random Number Generation and Seeding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.1。乱数生成と播種
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS requires a cryptographically secure pseudorandom number generator (PRNG). Care must be taken in designing and seeding PRNGs. PRNGs based on secure hash operations, most notably MD5 and/or SHA, are acceptable, but cannot provide more security than the size of the random number generator state. (For example, MD5-based PRNGs usually provide 128 bits of state.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、暗号論的擬似乱数生成器（PRNG）が必要です。ケアのPRNGの設計と播種に注意する必要があります。セキュアハッシュ操作に基づいのPRNG、最も顕著にはMD5および/またはSHAは、許容可能であるが、乱数発生器の状態のサイズよりも多くのセキュリティを提供することができません。 （例えば、MD5ベースのPRNGは、通常状態の128ビットを提供します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To estimate the amount of seed material being produced, add the number of bits of unpredictable information in each seed byte. For example, keystroke timing values taken from a PC compatible&#39;s 18.2 Hz timer provide 1 or 2 secure bits each, even though the total size of the counter value is 16 bits or more. Seeding a 128-bit PRNG would thus require approximately 100 such timer values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
生産されたシード材料の量を推定するために、各シードバイトの予測不可能な情報のビット数を追加します。例えば、のPC互換18.2 Hzのタイマーから採取したキーストロークタイミング値は、カウンタ値の合計サイズが16ビット以上であっても、1つの又は2の安全なビットそれぞれを提供します。 128ビットのPRNGを播種することは、したがって、約100そのようなタイマ値を必要とするであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RANDOM] provides guidance on the generation of random values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ランダム]はランダム値の生成に関するガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.2 Certificates and Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.2証明書と認証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully. Users should be able to view information about the certificate and root CA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、証明書の有効性について検証する責任があり、一般的に証明書失効メッセージをサポートする必要があります。証明書は常に信頼できる認証局（CA）によって適切な署名を確認するために検証する必要があります。信頼できるCAの選択や追加は非常に慎重に行われるべきです。ユーザーは、証明書とルートCAの情報を閲覧することができるはずです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.3 CipherSuites
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.3いるCipherSuite
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS supports a range of key sizes and security levels, including some that provide no or minimal security. A proper implementation will probably not support many cipher suites. For example, 40-bit encryption is easily broken, so implementations requiring strong security should not allow 40-bit keys. Similarly, anonymous Diffie-Hellman is strongly discouraged because it cannot prevent man-in-the-middle attacks. Applications should also enforce minimum and maximum key sizes. For example, certificate chains containing 512- bit RSA keys or signatures are not appropriate for high-security applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSはないか、最小限のセキュリティを提供することも含め、キーのサイズとセキュリティレベルの範囲を、サポートしています。適切な実装は、おそらく多くの暗号スイートをサポートしていません。強力なセキュリティを必要とする実装が40ビットのキーを許可してはならないので、例えば、40ビットの暗号化を容易に破壊されます。それはman-in-the-middle攻撃を防ぐことができないので、同様に、匿名のDiffie-Hellmanは強くお勧めします。また、アプリケーションは、最小と最大のキーサイズを強制する必要があります。例えば、512-ビットRSAキーまたは署名を含む証明書チェーンは、高セキュリティアプリケーションに適していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix E. Backward Compatibility with SSL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録E. SSLとの下位互換性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For historical reasons and in order to avoid a profligate consumption of reserved port numbers, application protocols that are secured by TLS 1.1, TLS 1.0, SSL 3.0, and SSL 2.0 all frequently share the same connection port. For example, the https protocol (HTTP secured by SSL or TLS) uses port 443 regardless of which security protocol it is using. Thus, some mechanism must be determined to distinguish and negotiate among the various protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
歴史的な理由と予約済みポート番号の浪費消費を回避するために、そのアプリケーションプロトコルがしばしば同一の接続ポートを共有するすべてのTLS 1.1、TLS 1.0、SSL 3.0、およびSSL 2.0によって固定されています。例えば、httpsプロトコル（SSLまたはTLSによって固定HTTP）は関係なく、それが使用されるセキュリティプロトコルのポート443を使用します。したがって、いくつかのメカニズムが識別及び様々なプロトコルの間で交渉するために決定されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS versions 1.1 and 1.0, and SSL 3.0 are very similar; thus, supporting both is easy. TLS clients who wish to negotiate with such older servers SHOULD send client hello messages using the SSL 3.0 record format and client hello structure, sending {3, 2} for the version field to note that they support TLS 1.1. If the server supports only TLS 1.0 or SSL 3.0, it will respond with a downrev 3.0 server hello; if it supports TLS 1.1 it will respond with a TLS 1.1 server hello. The negotiation then proceeds as appropriate for the negotiated protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSバージョン1.1と1.0、およびSSL 3.0は非常に似ています。このように、両方をサポートするのは簡単です。こうした古いサーバと交渉したいTLSクライアントは、TLS 1.1をサポートすることに注意するバージョンフィールドのために、{3,2}を送信し、ハローSSL 3.0レコード形式とクライアントを使用してハロー構造を、メッセージをクライアントに送るべきです。サーバがTLS 1.0またはSSL 3.0のみをサポートしている場合、それはハローdownrev 3.0サーバーで応答します。それがTLS 1.1をサポートしている場合には、TLS 1.1サーバーのハローで応答します。ネゴシエーションは、その後ネゴシエートプロトコルに応じて進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Similarly, a TLS 1.1 server that wishes to interoperate with TLS 1.0 or SSL 3.0 clients SHOULD accept SSL 3.0 client hello messages and respond with a SSL 3.0 server hello if an SSL 3.0 client hello with a version field of {3, 0} is received, denoting that this client does not support TLS. Similarly, if a SSL 3.0 or TLS 1.0 hello with a version field of {3, 1} is received, the server SHOULD respond with a TLS 1.0 hello with a version field of {3, 1}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、TLS 1.0またはSSL 3.0クライアントと相互運用することを望むTLS 1.1サーバは、SSL 3.0クライアントハローメッセージを受け入れてのバージョンフィールドとSSL 3.0クライアントハロー場合{3,0}が受信されるハローSSL 3.0サーバーで応答する必要があり、このクライアントはTLSをサポートしていないことを示します。受信された同様のバージョンフィールドとSSL 3.0またはTLS 1.0ハロー場合{3,1}、サーバは、バージョンフィールド{3,1}とTLS 1.0ハローで応答すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever a client already knows the highest protocol known to a server (for example, when resuming a session), it SHOULD initiate the connection in that native protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（セッションを再開する際に、例えば）クライアントがすでにサーバーに知られている最上位のプロトコルを知っているときはいつでも、それは、そのネイティブプロトコルで接続を開始すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.1 clients that support SSL Version 2.0 servers MUST send SSL Version 2.0 client hello messages [SSL2]. TLS servers SHOULD accept either client hello format if they wish to support SSL 2.0 clients on the same connection port. The only deviations from the Version 2.0 specification are the ability to specify a version with a value of three and the support for more ciphering types in the CipherSpec.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSLバージョン2.0のサーバをサポートしてTLS 1.1のクライアントは、SSLバージョン2.0クライアントhelloメッセージ[SSL2]を送らなければなりません。彼らは同じ接続ポートでSSL 2.0のクライアントをサポートしたい場合は、TLSサーバは、クライアントのhello形式のいずれかを受け入れる必要があります。バージョン2.0の仕様から唯一の偏差が3の値とのCipherSpecでより多くの暗号化の種類をサポートしたバージョンを指定する機能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warning: The ability to send Version 2.0 client hello messages will be phased out with all due haste. Implementors SHOULD make every effort to move forward as quickly as possible. Version 3.0 provides better mechanisms for moving to newer versions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告：バージョン2.0クライアントのhelloメッセージを送信する機能は、すべての原因急いで段階的に廃止されます。実装者は、可能な限り迅速に前進するためにあらゆる努力をするべきです。バージョン3.0は、新しいバージョンへの移行のためのより良いメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       The following cipher specifications are carryovers from SSL
       Version 2.0. These are assumed to use RSA for key exchange and
       authentication.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };
        V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };
        V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };
        V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5
                                                   = { 0x04,0x00,0x80 };
        V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };
        V2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };
        V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cipher specifications native to TLS can be included in Version 2.0 client hello messages using the syntax below. Any V2CipherSpec element with its first byte equal to zero will be ignored by Version 2.0 servers. Clients sending any of the above V2CipherSpecs SHOULD also include the TLS equivalent (see Appendix A.5):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSへのネイティブ暗号仕様は、以下の構文を使用して、バージョン2.0クライアントのhelloメッセージに含めることができます。ゼロに等しいその最初のバイトを持つ任意のV2CipherSpec要素は、バージョン2.0のサーバーによって無視されます。上記V2CipherSpecsのいずれかを送信するクライアントはまた、（付録A.5を参照）TLS同等物を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
V2CipherSpec (see TLS name) = { 0x00, CipherSuite };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
V2CipherSpec（TLS名を参照）= {0x00で、のCipherSuite}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: TLS 1.1 clients may generate the SSLv2 EXPORT cipher suites in handshakes for backward compatibility but MUST NOT negotiate them in TLS 1.1 mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：TLS 1.1クライアントは、下位互換性のために握手でのSSLv2 EXPORT暗号スイートを発生させることができるが、TLS 1.1モードでそれらを交渉してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1. Version 2 Client Hello
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1。バージョン2クライアントこんにちは
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Version 2.0 client hello message is presented below using this document&#39;s presentation model. The true definition is still assumed to be the SSL Version 2.0 specification. Note that this message MUST be sent directly on the wire, not wrapped as an SSLv3 record
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バージョン2.0クライアントのhelloメッセージは、このドキュメントのプレゼンテーションモデルを用いて以下に提示されます。真の定義は、まだSSLバージョン2.0の仕様を想定しています。このメッセージは、のSSLv3記録としてラップされていない、ワイヤーに直接送信される必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
uint8 V2CipherSpec[3];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UINT8 V2CipherSpec [3]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct {
         uint16 msg_length;
         uint8 msg_type;
         Version version;
         uint16 cipher_spec_length;
         uint16 session_id_length;
         uint16 challenge_length;
         V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
         opaque session_id[V2ClientHello.session_id_length];
         opaque challenge[V2ClientHello.challenge_length;
     } V2ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
msg_length This field is the length of the following data in bytes. The high bit MUST be 1 and is not part of the length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
msg_lengthこのフィールドは、バイト単位で、以下のデータの長さです。高いビットが1である、長さの一部ではないしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
msg_type This field, in conjunction with the version field, identifies a version 2 client hello message. The value SHOULD be one (1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このフィールドをMSG_TYPE、バージョンフィールドと連動して、バージョン2クライアントのhelloメッセージを識別する。値は1（1）であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
version The highest version of the protocol supported by the client (equals ProtocolVersion.version; see Appendix A.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バージョンのクライアントでサポートされているプロトコルの最も高いバージョン（はProtocolVersion.versionに等しい。付録A.1を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_spec_length This field is the total length of the field cipher_specs. It cannot be zero and MUST be a multiple of the V2CipherSpec length (3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_spec長さこのフィールドは、フィールドcipher_specsの長さの合計です。それはゼロにすることはできず、V2暗号スペック長さ（3）の倍数でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
session_id_length This field MUST have a value of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
session_id_lengthこのフィールドはゼロの値を持たなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
challenge_length The length in bytes of the client&#39;s challenge to the server to authenticate itself. When using the SSLv2 backward compatible handshake the client MUST use a 32-byte challenge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
自身を認証するために、サーバーへのクライアントの挑戦の長さをバイト単位でchallenge_length。 SSLv2の後方互換性のハンドシェイクを使用している場合、クライアントは、32バイトのチャレンジを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_specs This is a list of all CipherSpecs the client is willing and able to use. There MUST be at least one CipherSpec acceptable to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_specsこれは、クライアントが喜んでと使用することができ、すべてのCipherSpecのリストです。サーバーへの許容可能な少なくとも一つのCipherSpecがあるに違いありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
session_id This field MUST be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SESSION_IDこのフィールドは空である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
challenge The client challenge to the server for the server to identify itself is a (nearly) arbitrary-length random. The TLS server will right-justify the challenge data to become the ClientHello.random data (padded with leading zeroes, if necessary), as specified in this protocol specification. If the length of the challenge is greater than 32 bytes, only the last 32 bytes are used. It is legitimate (but not necessary) for a V3 server to reject a V2 ClientHello that has fewer than 16 bytes of challenge data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
自身を識別するためのサーバのサーバへのクライアントの課題に挑戦することは、ランダムな（ほぼ）任意の長さです。 TLSサーバは、このプロトコル仕様で指定されたチャレンジデータは、（必要であれば、先行ゼロで埋め）のClientHello.randomデータになるために右詰めされます。チャレンジの長さが32のバイトよりも大きい場合、最後の32のバイトが使用されます。 V3サーバーは、チャレンジデータの16のバイトよりも少ないを持っているV2のClientHelloを拒絶することが（必要ではない）正当なものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Requests to resume a TLS session MUST use a TLS client hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：TLSセッションを再開する要求はTLSクライアントのhelloを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.2. Avoiding Man-in-the-Middle Version Rollback
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.2。マン・イン・ザ・ミドル・バージョンのロールバックを回避
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When TLS clients fall back to Version 2.0 compatibility mode, they SHOULD use special PKCS #1 block formatting. This is done so that TLS servers will reject Version 2.0 sessions with TLS-capable clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSクライアントがバックバージョン2.0互換モードにフォールすると、彼らは特別なPKCS＃1ブロックフォーマットを使用すべきです。 TLSサーバがTLS対応のクライアントとのバージョン2.0セッションを拒絶するように行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When TLS clients are in Version 2.0 compatibility mode, they set the right-hand (least significant) 8 random bytes of the PKCS padding (not including the terminal null of the padding) for the RSA encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY to 0x03 (the other padding bytes are random). After decrypting the ENCRYPTED-KEY-DATA field, servers that support TLS SHOULD issue an error if these eight padding bytes are 0x03. Version 2.0 servers receiving blocks padded in this manner will proceed normally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSクライアントがバージョン2.0互換モードである場合、それらは、右の設定（最下位）のENCRYPTED-KEY-DATAフィールドのRSA暗号化のため（パディングの端子ヌルを含まない）PKCSパディングの8つのランダムバイト0×03にCLIENT-MASTER-KEY（他のパディングバイトがランダムです）。これら8つのパディングバイトが0x03であればENCRYPTED-KEY-DATAフィールドを復号化した後、TLSをサポートするサーバーはエラーを発行する必要があります。このように埋められたブロックを受けるバージョン2.0のサーバーが正常に進行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix F. Security Analysis
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録F.セキュリティ分析
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS protocol is designed to establish a secure connection between a client and a server communicating over an insecure channel. This document makes several traditional assumptions, including that attackers have substantial computational resources and cannot obtain secret information from sources outside the protocol. Attackers are assumed to have the ability to capture, modify, delete, replay, and otherwise tamper with messages sent over the communication channel. This appendix outlines how TLS has been designed to resist a variety of attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSプロトコルは、クライアントと安全でないチャネルを介して通信サーバ間の安全な接続を確立するために設計されています。この文書では、攻撃者が実質的な計算リソースを持っており、プロトコル外部ソースから秘密情報を得ることができないことを含め、いくつかの伝統的な仮定を行います。攻撃者は、キャプチャ、変更、削除、再生、およびそれ以外の通信チャネルを介して送信されたメッセージを改ざんする能力を持っていると想定されています。この付録では、TLSがさまざまな攻撃に耐えるように設計されている方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1. Handshake Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1。ハンドシェイクプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The handshake protocol is responsible for selecting a CipherSpec and generating a Master Secret, which together comprise the primary cryptographic parameters associated with a secure session. The handshake protocol can also optionally authenticate parties who have certificates signed by a trusted certificate authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイクプロトコルは、のCipherSpecを選択し、一緒に安全なセッションに関連付けられたプライマリ暗号パラメータを含むマスターシークレットを生成する責任があります。ハンドシェイクプロトコルはまた、必要に応じて、信頼できる認証局によって署名された証明書を持って、当事者を認証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.1. Authentication and Key Exchange
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.1。認証と鍵交換
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS supports three authentication modes: authentication of both parties, server authentication with an unauthenticated client, and total anonymity. Whenever the server is authenticated, the channel is secure against man-in-the-middle attacks, but completely anonymous sessions are inherently vulnerable to such attacks. Anonymous servers cannot authenticate clients. If the server is authenticated, its certificate message must provide a valid certificate chain leading to an acceptable certificate authority. Similarly, authenticated clients must supply an acceptable certificate to the server. Each party is responsible for verifying that the other&#39;s certificate is valid and has not expired or been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
両当事者の認証、認証されていないクライアントとサーバー認証、および総匿名：TLSは、3つの認証モードをサポートしています。サーバーが認証されるたびに、チャネルは、man-in-the-middle攻撃に対して安全であるが、完全に匿名のセッションはそのような攻撃にさらされやすいです。匿名のサーバはクライアントを認証することはできません。サーバーが認証されている場合は、その証明書のメッセージは許容できる認証局につながる有効な証明書チェーンを提供する必要があります。同様に、認証されたクライアントは、サーバーへの許容可能な証明書を提供する必要があります。各当事者は、他の証明書が有効で、期限が切れていないか、取り消されていることを検証する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The general goal of the key exchange process is to create a pre_master_secret known to the communicating parties and not to attackers. The pre_master_secret will be used to generate the master_secret (see Section 8.1). The master_secret is required to generate the finished messages, encryption keys, and MAC secrets (see Sections 7.4.8, 7.4.9, and 6.3). By sending a correct finished message, parties thus prove that they know the correct pre_master_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鍵交換プロセスの一般的な目標は、通信相手にしていない攻撃者に知られている前_のマスター_秘密を作成することです。前_のマスター_秘密をmaster_secretを生成するのに使用されます（8.1節を参照してください）。でマスター_が完成したメッセージ、暗号化キー、およびMAC秘密を（セクション7.4.8、7.4.9、および6.3を参照）を生成するために必要とされます。正しいFinishedメッセージを送信することにより、関係者は、このように、彼らは正しい前_のマスター_秘密を知っていることを証明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.1.1. Anonymous Key Exchange
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.1.1。匿名の鍵交換
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Completely anonymous sessions can be established using RSA or Diffie-Hellman for key exchange. With anonymous RSA, the client encrypts a pre_master_secret with the server&#39;s uncertified public key extracted from the server key exchange message. The result is sent in a client key exchange message. Since eavesdroppers do not know the server&#39;s private key, it will be infeasible for them to decode the pre_master_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全に匿名のセッションは、鍵交換のためのRSAまたはディフィー・ヘルマンを使用して確立することができます。匿名RSAでは、クライアントは、サーバ鍵交換メッセージから抽出されたサーバーの未認定公開鍵で前_のマスター_秘密を暗号化します。結果は、クライアント鍵交換メッセージで送信されます。盗聴者は、サーバの秘密鍵を知らないので、彼らはpre_master_secretを復号することは実行不可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: No anonymous RSA Cipher Suites are defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：いいえ匿名RSA暗号スイートは、この文書で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With Diffie-Hellman, the server&#39;s public parameters are contained in the server key exchange message and the client&#39;s are sent in the client key exchange message. Eavesdroppers who do not know the private values should not be able to find the Diffie-Hellman result (i.e., the pre_master_secret).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディフィー・ヘルマンでは、サーバの公開パラメータは、サーバ鍵交換メッセージに含まれており、クライアントのは、クライアント鍵交換メッセージで送信されます。民間の値を知らない盗聴者は、Diffie-Hellman結果（すなわち、前_のマスター_秘密を）見つけることができないようにする必要があり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warning: Completely anonymous connections only provide protection against passive eavesdropping. Unless an independent tamper-proof channel is used to verify that the finished messages were not replaced by an attacker, server authentication is required in environments where active man-in-the-middle attacks are a concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告：完全に匿名接続のみ受動的盗聴に対する保護を提供します。独立した改ざん防止チャンネルが完成し、メッセージが攻撃者に取り替えられなかったことを確認するために使用されていない限り、サーバー認証がアクティブman-in-the-middle攻撃が懸念されている環境で必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.1.2. RSA Key Exchange and Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.1.2。 RSA鍵交換と認証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With RSA, key exchange and server authentication are combined. The public key either may be contained in the server&#39;s certificate or may be a temporary RSA key sent in a server key exchange message. When temporary RSA keys are used, they are signed by the server&#39;s RSA certificate. The signature includes the current ClientHello.random, so old signatures and temporary keys cannot be replayed. Servers may use a single temporary RSA key for multiple negotiation sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSAでは、鍵交換およびサーバー認証が組み合わされています。公開鍵は、いずれかのサーバーの証明書に含まれていてもよいか、サーバ鍵交換メッセージで送信された一時的RSA鍵かもしれません。一時的RSA鍵が使用される場合、それらはサーバのRSA証明書によって署名されています。署名は、現在のClientHello.random、とても古い署名と一時キーは再生できないことが含まれます。サーバは、複数の交渉セッションのための単一の一時的RSA鍵を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The temporary RSA key option is useful if servers need large
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：サーバが大きい必要がある場合は、一時的なRSAキーオプションが便利です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         certificates but must comply with government-imposed size
         limits on keys used for key exchange.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that if ephemeral RSA is not used, compromise of the server&#39;s static RSA key results in a loss of confidentiality for all sessions protected under that static key. TLS users desiring Perfect Forward Secrecy should use DHE cipher suites. The damage done by exposure of a private key can be limited by changing one&#39;s private key (and certificate) frequently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
なお、一時的RSAが使用されていない場合に、その静的なキーの下に保護されたすべてのセッションの機密性の損失におけるサーバの静的なRSAキーの結果の妥協。完全転送秘密を希望TLSユーザはDHE暗号スイートを使用する必要があります。秘密鍵の暴露によるダメージは、頻繁に自分の秘密鍵（および証明書）を変更することによって制限することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After verifying the server&#39;s certificate, the client encrypts a pre_master_secret with the server&#39;s public key. By successfully decoding the pre_master_secret and producing a correct finished message, the server demonstrates that it knows the private key corresponding to the server certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーの証明書を検証した後、クライアントは、サーバの公開鍵で前_のマスター_秘密を暗号化します。首尾よく前_のマスター_秘密を解読し、正しいFinishedメッセージを出すことによって、サーバは、サーバ証明書に対応する秘密鍵を知っていることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When RSA is used for key exchange, clients are authenticated using the certificate verify message (see Section 7.4.8). The client signs a value derived from the master_secret and all preceding handshake messages. These handshake messages include the server certificate, which binds the signature to the server, and ServerHello.random, which binds the signature to the current handshake process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSAは、鍵交換に使用されている場合、クライアントは証明書（セクション7.4.8を参照）のメッセージを確認するを使用して認証されます。クライアントは、マスター_と先行するすべてのハンドシェイクメッセージから得られた値に署名します。これらのハンドシェイクメッセージは、現在のハンドシェイクプロセスへの署名をバインドするサーバーサーバーへの署名を結合した証明書、およびServerHello.randomが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.1.3. Diffie-Hellman Key Exchange with Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.1.3。認証を使ってDiffie-Hellman鍵交換
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When Diffie-Hellman key exchange is used, the server can either supply a certificate containing fixed Diffie-Hellman parameters or use the server key exchange message to send a set of temporary Diffie-Hellman parameters signed with a DSS or RSA certificate. Temporary parameters are hashed with the hello.random values before signing to ensure that attackers do not replay old parameters. In either case, the client can verify the certificate or signature to ensure that the parameters belong to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Diffie-Hellman鍵交換を使用した場合、サーバは、固定のDiffie-Hellmanパラメータを含む証明書を提供またはDSSまたはRSA証明書で署名された一時的のDiffie-Hellmanパラメータのセットを送信するためにサーバ鍵交換メッセージを使用しますか。一時的なパラメータは、攻撃者が古いパラメータを再生していないことを保証するために署名する前のhello.random値でハッシュ化されています。いずれの場合も、クライアントは、パラメータがサーバーに属していることを確認するために証明書または署名を検証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client has a certificate containing fixed Diffie-Hellman parameters, its certificate contains the information required to complete the key exchange. Note that in this case the client and server will generate the same Diffie-Hellman result (i.e., pre_master_secret) every time they communicate. To prevent the pre_master_secret from staying in memory any longer than necessary, it should be converted into the master_secret as soon as possible. Client Diffie-Hellman parameters must be compatible with those supplied by the server for the key exchange to work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが固定Diffie-Hellmanパラメータを含む証明書を持っている場合は、その証明書は、鍵交換を完了するために必要な情報が含まれています。この場合、クライアントとサーバが同一のDiffie-Hellman結果（すなわち、前_のマスター_秘密）は、それらが通信するたびに発生することに注意してください。もはや必要以上にメモリに滞在から前_のマスター_秘密を防止するためには、できるだけ早くmaster_secretへ変換する必要があります。クライアントのDiffie-Hellmanパラメータは、鍵交換を行うために、サーバによって提供されたものと互換性がなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client has a standard DSS or RSA certificate or is unauthenticated, it sends a set of temporary parameters to the server in the client key exchange message, then optionally uses a certificate verify message to authenticate itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが標準DSSまたはRSA証明書を持っているか、認証されていない場合には、それはクライアント鍵交換メッセージでサーバーに一時的なパラメータのセットを送信し、その後、必要に応じて自分自身を認証するためのメッセージを確認し、証明書を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the same DH keypair is to be used for multiple handshakes, either because the client or server has a certificate containing a fixed DH keypair or because the server is reusing DH keys, care must be taken to prevent small subgroup attacks. Implementations SHOULD follow the guidelines found in [SUBGROUP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じDH鍵ペアは、複数の握手のために使用される、クライアントまたはサーバが固定DH鍵ペアを含む証明書を持っているか、サーバがDHキーを再利用しているため、介護が小さいサブグループ攻撃を防ぐために取らなければならないので、場合。実装は[SUBGROUP]で見つかったガイドラインに従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Small subgroup attacks are most easily avoided by using one of the DHE ciphersuites and generating a fresh DH private key (X) for each handshake. If a suitable base (such as 2) is chosen, g^X mod p can be computed very quickly, therefore the performance cost is minimized. Additionally, using a fresh key for each handshake provides Perfect Forward Secrecy. Implementations SHOULD generate a new X for each handshake when using DHE ciphersuites.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
小さなサブグループ攻撃は最も簡単DHE暗号スイートのいずれかを使用し、各握手のために新鮮なDH秘密鍵（X）を生成することによって回避されています。適切な塩基は、（例えば2など）を選択した場合、G ^ X MOD pは、したがって、性能コストが最小化され、非常に迅速に計算することができます。また、各握手のために新鮮なキーを使用すると、完全転送秘密を提供します。 DHE暗号群を使用した場合、実装は各握手のための新しいXを生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.2. Version Rollback Attacks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.2。バージョンロールバック攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because TLS includes substantial improvements over SSL Version 2.0, attackers may try to make TLS-capable clients and servers fall back to Version 2.0. This attack can occur if (and only if) two TLS-capable parties use an SSL 2.0 handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、SSLバージョン2.0からのかなりの改良が含まれているため、攻撃者は、TLS対応のクライアントとサーバがバージョン2.0に戻すようにさせるかもしれません。 （および場合のみ）2 TLS対応の当事者はSSL 2.0ハンドシェイクを使用する場合は、この攻撃が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although the solution using non-random PKCS #1 block type 2 message padding is inelegant, it provides a reasonably secure way for Version 3.0 servers to detect the attack. This solution is not secure against attackers who can brute force the key and substitute a new ENCRYPTED-KEY-DATA message containing the same key (but with normal padding) before the application specified wait threshold has expired. Parties concerned about attacks of this scale should not use 40-bit encryption keys. Altering the padding of the least-significant 8 bytes of the PKCS padding does not impact security for the size of the signed hashes and RSA key lengths used in the protocol, since this is essentially equivalent to increasing the input block size by 8 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非ランダムPKCS＃1ブロック型2メッセージパディングを使用したソリューションは無粋ですが、それはバージョン3.0のサーバーが攻撃を検出するための合理的に安全な方法を提供します。このソリューションでは、キーをブルートフォースし、アプリケーション指定の待機しきい値が経過する前に同じキーを（ただし、通常のパディングを持つ）を含む新しいENCRYPTED-KEY-DATAメッセージを置き換えることができ、攻撃者に対して安全ではありません。この規模の攻撃を懸念締約国は、40ビットの暗号化キーを使用しないでください。これは8バイトの入力ブロックサイズを大きくすると本質的に同等であるので、PKCSパディングの最下位8バイトのパディングを変更すると、署名されたハッシュとプロトコルで使用されるRSA鍵の長さのサイズのセキュリティに影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.3. Detecting Attacks against the Handshake Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.3。ハンドシェイクプロトコルに対する攻撃を検出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An attacker might try to influence the handshake exchange to make the parties select different encryption algorithms than they would normally chooses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
攻撃者は、彼らが正常に選ぶだろうより当事者が異なる暗号化アルゴリズムを選択するためにハンドシェイク交換に影響を与えることを試みるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others&#39; finished messages. Without the master_secret, the attacker cannot repair the finished messages, so the attack will be discovered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この攻撃では、攻撃者が積極的に一つ以上のハンドシェイクメッセージを変更する必要があります。この問題が発生した場合、クライアントとサーバーはハンドシェイクメッセージのハッシュに異なる値を計算します。その結果、当事者はお互いのFinishedメッセージを受け付けません。攻撃が検出されますので、マスター_がなければ、攻撃者は、完成したメッセージを修復することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.4. Resuming Sessions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.4。セッションを再開
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a connection is established by resuming a session, new ClientHello.random and ServerHello.random values are hashed with the session&#39;s master_secret. Provided that the master_secret has not been compromised and that the secure hash operations used to produce the encryption keys and MAC secrets are secure, the connection should be secure and effectively independent from previous connections. Attackers cannot use known encryption keys or MAC secrets to compromise the master_secret without breaking the secure hash operations (which use both SHA and MD5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続がセッションを再開することによって確立されたとき、新しいClientHello.randomととServerHello.random値はセッションのマスター_秘密で論じ尽くされます。マスター_が損なわれていないことと、暗号化鍵とMACシークレットを生成するために使用されるセキュアハッシュ操作が安全であることを条件とする、接続は、以前の接続から安全かつ効果的に独立であるべきです。攻撃者は、（SHAとMD5の両方を使用）、セキュアハッシュ演算を壊すことなくでマスター_を損なうことが知られている暗号化キーまたはMAC秘密を使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sessions cannot be resumed unless both the client and server agree. If either party suspects that the session may have been compromised, or that certificates may have expired or been revoked, it should force a full handshake. An upper limit of 24 hours is suggested for session ID lifetimes, since an attacker who obtains a master_secret may be able to impersonate the compromised party until the corresponding session ID is retired. Applications that may be run in relatively insecure environments should not write session IDs to stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバの両方が同意しない限り、セッションは再開できません。いずれかの当事者が、セッションが侵害された可能性があること、または証明書の期限が切れたか、取り消されていることを疑った場合、それは完全なハンドシェイクを強制する必要があります。対応するセッションIDがリタイアするまでmaster_secretを入手した攻撃者は妥協がパーティを偽装することができる可能性があるため、24時間の上限は、セッションIDの寿命のために提案されます。比較的安全でない環境で実行されるアプリケーションは、安定したストレージにセッションIDを書くべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.5. MD5 and SHA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.1.5。 MD5とSHA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS uses hash functions very conservatively. Where possible, both MD5 and SHA are used in tandem to ensure that non-catastrophic flaws in one algorithm will not break the overall protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは非常に保守的ハッシュ関数を使用しています。可能であれば、MD5とSHAの両方を1つのアルゴリズムにおける非致命的な欠陥が、全体的なプロトコルを壊さないようにするためにタンデムで使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.2. Protecting Application Data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.2。アプリケーションデータの保護
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The master_secret is hashed with the ClientHello.random and ServerHello.random to produce unique data encryption keys and MAC secrets for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でマスター_は、接続ごとに固有のデータ暗号化鍵とMACシークレットを生成するためのClientHello.randomとServerHello.randomでハッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outgoing data is protected with a MAC before transmission. To prevent message replay or modification attacks, the MAC is computed from the MAC secret, the sequence number, the message length, the message contents, and two fixed character strings. The message type field is necessary to ensure that messages intended for one TLS Record Layer client are not redirected to another. The sequence number ensures that attempts to delete or reorder messages will be detected. Since sequence numbers are 64 bits long, they should never overflow. Messages from one party cannot be inserted into the other&#39;s output, since they use independent MAC secrets. Similarly, the server-write and client-write keys are independent, so stream cipher keys are used only once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信データが送信される前にMACで保護されています。メッセージの再生または変更攻撃を防ぐために、MACはMACの秘密、シーケンス番号、メッセージ長、メッセージの内容、および2つの固定文字列から計算されます。メッセージタイプフィールドは1つのTLSレコード層クライアント向けのメッセージを別のにリダイレクトされていないことを確認する必要があります。シーケンス番号は、メッセージを削除したり、並べ替えしようとする試みが検出されることを保証します。シーケンス番号は64ビット長であるので、彼らがオーバーフローありません。彼らは独立したMAC秘密を使用するので、1回のパーティーからのメッセージは、相手の出力に挿入することはできません。同様に、サーバ・ライトおよびクライアント・ライトキーが独立しているので、暗号キーは一度だけ使用されているストリーム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an attacker does break an encryption key, all messages encrypted with it can be read. Similarly, compromise of a MAC key can make message modification attacks possible. Because MACs are also encrypted, message-alteration attacks generally require breaking the encryption algorithm as well as the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
攻撃者が暗号化キーを破るない場合、それを用いて暗号化されたすべてのメッセージを読み取ることができます。同様に、MACキーの妥協は、メッセージ変更攻撃を可能にすることができます。 MACのも暗号化されているので、メッセージ改ざん攻撃は、一般的に、暗号化アルゴリズムと同様にMACを破る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: MAC secrets may be larger than encryption keys, so messages can remain tamper resistant even if encryption keys are broken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：メッセージは暗号化キーが壊れている場合でも、耐タンパ残ることができるようにMACの秘密は、暗号化キーより大きいかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.3. Explicit IVs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.3。明示的なIV
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CBCATT] describes a chosen plaintext attack on TLS that depends on knowing the IV for a record. Previous versions of TLS [TLS1.0] used the CBC residue of the previous record as the IV and therefore enabled this attack. This version uses an explicit IV in order to protect against this attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CBCATT]はレコードのIVを知ることに依存TLS上の選択平文攻撃を説明しています。 TLSの以前のバージョンでは、[TLS1.0] IVとして前のレコードのCBC残基を使用し、したがって、この攻撃を可能にしました。このバージョンでは、この攻撃から保護するために、明示的なIVを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.4. Security of Composite Cipher Modes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.4。コンポジット暗号モードのセキュリティ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS secures transmitted application data via the use of symmetric encryption and authentication functions defined in the negotiated ciphersuite. The objective is to protect both the integrity and confidentiality of the transmitted data from malicious actions by active attackers in the network. It turns out that the order in which encryption and authentication functions are applied to the data plays an important role for achieving this goal [ENCAUTH].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSはネゴシエート暗号の組み合わせで定義された対称暗号化と認証機能の使用を介して送信されたアプリケーションデータを保護します。目的は、ネットワーク内のアクティブな攻撃者によって悪質な行為から送信されたデータの整合性と機密性の両方を保護することです。これは、暗号化と認証機能をデータに適用される順序は、この目標[ENCAUTH]を達成するための重要な役割を果たしていることが判明しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The most robust method, called encrypt-then-authenticate, first applies encryption to the data and then applies a MAC to the ciphertext. This method ensures that the integrity and confidentiality goals are obtained with ANY pair of encryption and MAC functions, provided that the former is secure against chosen plaintext attacks and that the MAC is secure against chosen-message attacks. TLS uses another method, called authenticate-then-encrypt, in which first a MAC is computed on the plaintext and then the concatenation of plaintext and MAC is encrypted. This method has been proven secure for CERTAIN combinations of encryption functions and MAC functions, but it is not guaranteed to be secure in general. In particular, it has been shown that there exist perfectly secure encryption functions (secure even in the information-theoretic sense) that combined with any secure MAC function, fail to provide the confidentiality goal against an active attack. Therefore, new ciphersuites and operation modes adopted into TLS need to be analyzed under the authenticate-then-encrypt method to verify that they achieve the stated integrity and confidentiality goals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号化は、当時の認証と呼ばれる最も堅牢な方法は、第1のデータに暗号化を適用して、暗号文にMACを適用します。この方法は、完全性と機密性の目標は、暗号化とMAC機能の任意のペアを用いて得られることを保証し、前者は選択平文攻撃に対するおよびMACは、選択したメッセージ攻撃に対して安全である安全であることを条件とします。 TLSは、最初のMACが平文で計算され、その後、平文とMACの連結が暗号化された認証、次いで暗号化と呼ばれる別の方法を使用します。この方法では、暗号化機能とMAC機能の特定の組み合わせのために安全な証明されているが、一般的に安全であると保証するものではありません。特に、任意の安全なMAC機能と組み合わせる完全に安全な暗号化機能が（たとえ情報理論的な意味で固定）、アクティブ攻撃に対する機密性の目標を提供することができないが存在することが示されています。したがって、TLSに採用し、新たな暗号スイートおよび動作モードは、彼らが述べ完全性と機密性の目標を達成することを確認するために、認証、そして暗号化方式で分析する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Currently, the security of the authenticate-then-encrypt method has been proven for some important cases. One is the case of stream ciphers in which a computationally unpredictable pad of the length of the message, plus the length of the MAC tag, is produced using a pseudo-random generator and this pad is xor-ed with the concatenation of plaintext and MAC tag. The other is the case of CBC mode using a secure block cipher. In this case, security can be shown if one applies one CBC encryption pass to the concatenation of plaintext and MAC and uses a new, independent, and unpredictable IV for each new pair of plaintext and MAC. In previous versions of SSL, CBC mode was used properly EXCEPT that it used a predictable IV in the form of the last block of the previous ciphertext. This made TLS open to chosen plaintext attacks. This version of the protocol is immune to those attacks. For exact details in the encryption modes proven secure, see [ENCAUTH].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在、認証、そして暗号化方式のセキュリティは、いくつかの重要な例のために証明されています。一つは、メッセージの長さ、プラスMACタグの長さの計算予測不可能なパッドは、擬似乱数発生器を使用して製造されたストリーム暗号の場合であり、このパッドは、平文とMACの連結との排他的論理和演算であります鬼ごっこ。他のセキュアなブロック暗号を使用して、CBCモードの場合です。一つは平文とMACの連結に1つのCBC暗号化パスを適用して平文とMACの新しい各対について、新たな独立した予測不可能なIVを使用している場合この場合、セキュリティを示すことができます。 SSLの以前のバージョンでは、CBCモードでは、それは前の暗号文の最後のブロックの形で予測可能なIVを使用したことを除き、適切に使用されました。これは、TLSは平文攻撃を選択するために開きました。プロトコルのこのバージョンは、これらの攻撃に免疫があります。安全な実績のある暗号化モードでの正確な詳細については、[ENCAUTH]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.5. Denial of Service
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.5。サービス拒否
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS is susceptible to a number of denial of service (DoS) attacks. In particular, an attacker who initiates a large number of TCP connections can cause a server to consume large amounts of CPU doing RSA decryption. However, because TLS is generally used over TCP, it is difficult for the attacker to hide his point of origin if proper TCP SYN randomization is used [SEQNUM] by the TCP stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、サービス拒否（DoS）攻撃の拒否の数の影響を受けやすいです。具体的には、TCPコネクションの多数を開始し、攻撃者は、サーバーがRSAの復号化を行うCPUを大量に消費する可能性があります。 TLSは、一般的にTCP上で使用されているため、適切なTCPのSYNのランダム化は、TCPスタックによって[SEQNUM]使用されている場合、攻撃者が起源の彼のポイントを非表示にするためしかし、それは困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because TLS runs over TCP, it is also susceptible to a number of denial of service attacks on individual connections. In particular, attackers can forge RSTs, thereby terminating connections, or forge partial TLS records, thereby causing the connection to stall. These attacks cannot in general be defended against by a TCP-using protocol. Implementors or users who are concerned with this class of attack should use IPsec AH [AH-ESP] or ESP [AH-ESP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSはTCP上で実行されるため、それはまた、個々の接続上のサービス妨害攻撃の数の影響を受けやすいです。具体的には、攻撃者は、偽造のRSTをこれによって接続を終了する、または部分的なTLSレコードを偽造することにより停止する接続を生じさせることができます。これらの攻撃は、一般的にTCP-使用してプロトコルによりに対して擁護することはできません。攻撃のこのクラスに関係している実装者またはユーザーは、IPsec AH [AH-ESP]またはESP [AH-ESP]を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.6. Final Notes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F.6。最終的な注意事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For TLS to be able to provide a secure connection, both the client and server systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSが安全な接続を提供することができるようにするには、クライアントとサーバシステム、キー、およびアプリケーションの両方が安全でなければなりません。また、実装は、セキュリティエラーがあってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys, 40-bit bulk encryption keys, and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
システムは、最も弱いキー交換および認証アルゴリズムがサポートされる唯一のような強く、唯一信頼できる暗号化機能を使用すべきです。短い公開鍵、40ビットバルク暗号化キー、および匿名のサーバは十分に注意して使用する必要があります。証明書と認証局が許容されるかを決めるとき、実装し、ユーザーが注意しなければなりません。不正認証局は多大なダメージを与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Normative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引用規格
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AES] National Institute of Standards and Technology, &#34;Specification for the Advanced Encryption Standard (AES)&#34; FIPS 197. November 26, 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
標準技術[AES]国立研究所、FIPS 197 2001年11月26日 &#34;のAdvanced Encryption Standard（AES）のための仕様&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3DES] W. Tuchman, &#34;Hellman Presents No Shortcut Solutions To DES,&#34; IEEE Spectrum, v. 16, n. 7, July 1979, pp. 40-41.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3DES] W. Tuchmanは、nは、IEEEスペクトラム、V。16 &#34;HellmanはDESへの近道のソリューションを提示していません&#34;。 7、1979年7月、頁40-41。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DES] ANSI X3.106, &#34;American National Standard for Information Systems-Data Link Encryption,&#34; American National Standards Institute, 1983.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DES] ANSI X3.106、米国規格協会、1983年「情報システム、データリンク暗号化、アメリカ国家規格」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS] NIST FIPS PUB 186-2, &#34;Digital Signature Standard,&#34; National Institute of Standards and Technology, U.S. Department of Commerce, 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS] NIST FIPS PUB 186-2、「デジタル署名標準、」アメリカ国立標準技術研究所、米国商務省が2000年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HMAC] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 &#34;HMAC：メッセージ認証のための鍵付きハッシュ化&#34;、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IDEA] X. Lai, &#34;On the Design and Security of Block Ciphers,&#34; ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IDEA] X.ライ、 &#34;ブロック暗号のデザインとセキュリティ上、&#34; 情報処理におけるETHシリーズ、V 1、コンスタンツ：。アルトゥング-Gorre Verlag社、1992。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MD5] Rivest, R., &#34;The MD5 Message-Digest Algorithm &#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MD5] Rivest氏、R.、 &#34;MD5メッセージダイジェストアルゴリズム&#34;、RFC 1321、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKCS1A] B. Kaliski, &#34;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 1.5&#34;, RFC 2313, March 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKCS1A] B. Kaliski、 &#34;公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン1.5&#34;、RFC 2313、1998年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKCS1B] J. Jonsson, B. Kaliski, &#34;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1&#34;, RFC 3447, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKCS1B] J.ジョンソン、B. Kaliski、 &#34;公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1&#34;、RFC 3447、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKIX] Housley, R., Polk, W., Ford, W., and D. Solo, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 3280, April 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKIX] Housley氏、R.、ポーク、W.、フォード、W.、およびD.ソロ、 &#34;インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィール&#34;、RFC 3280、2002年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RC2] Rivest, R., &#34;A Description of the RC2(r) Encryption Algorithm&#34;, RFC 2268, March 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RC2]リベスト、R.、 &#34;RC2（R）暗号化アルゴリズムの説明&#34;、RFC 2268、1998年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SCH] B. Schneier. &#34;Applied Cryptography: Protocols, Algorithms, and Source Code in C, 2ed&#34;, Published by John Wiley &amp; Sons, Inc. 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SCH] B.シュナイアー。 「応用暗号：C、2EDでプロトコル、アルゴリズム、およびソースコードの」ジョン・ワイリー＆サンズ社1996年発行、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHA] NIST FIPS PUB 180-2, &#34;Secure Hash Standard,&#34; National Institute of Standards and Technology, U.S. Department of Commerce., August 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHA] NIST FIPS PUB 180-2の、「セキュアハッシュ標準、」アメリカ国立標準技術研究所、商務米国部門、2001年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[REQ] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[REQ]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2434] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 2434, October 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2434] Narten氏、T.とH. Alvestrand、 &#34;RFCsにIANA問題部に書くためのガイドライン&#34;、BCP 26、RFC 2434、1998年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLSAES] Chown, P., &#34;Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)&#34;, RFC 3268, June 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、RFC 3268、2002年6月[TLSAES]のchown、P.、 &#34;トランスポート層セキュリティ（TLS）用のAdvanced Encryption Standard（AES）暗号の組み合わせ&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLSEXT] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &#34;Transport Layer Security (TLS) Extensions&#34;, RFC 3546, June 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【TLSEXT]ブレイク・ウィルソン、S.、Nystrom、M.、ホップウッド、D.、ミケルセン、J.、およびT.ライト、 &#34;トランスポート層セキュリティ（TLS）の拡張&#34;、RFC 3546、2003年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLSKRB] Medvinsky, A. and M. Hur, &#34;Addition of Kerberos Cipher Suites to Transport Layer Security (TLS)&#34;, RFC 2712, October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLSKRB] Medvinsky、A.とM.ハー、RFC 2712、1999年10月 &#34;Layer Security（TLS）を輸送するためのケルベロス暗号スイートの追加&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Informative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AH-ESP] Kent, S., &#34;IP Authentication Header&#34;, RFC 4302, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AH-ESP]ケント、S.、 &#34;IP認証ヘッダー&#34;、RFC 4302、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Eastlake 3rd, D., &#34;Cryptographic Algorithm Implementation
              Requirements for Encapsulating Security Payload (ESP) and
              Authentication Header (AH)&#34;, RFC 4305, December 2005.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BLEI] Bleichenbacher D., &#34;Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1&#34; in Advances in Cryptology -- CRYPTO&#39;98, LNCS vol. 1462, pages: 1-12, 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【BLEI] BleichenbacherのD.、暗号理論における進歩で「RSA暗号化標準PKCS＃1に基づくプロトコルに対して選択暗号文攻撃」 -  CRYPTO&#39;98、LNCS体積。 1462年、頁：1-12、1998。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CBCATT] Moeller, B., &#34;Security of CBC Ciphersuites in SSL/TLS: Problems and Countermeasures&#34;, http://www.openssl.org/~bodo/tls-cbc.txt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CBCATT]メラー、B.、 &#34;SSL / TLSでのCBC暗号の組み合わせのセキュリティ：問題点と対策&#34;、http://www.openssl.org/~bodo/tls-cbc.txt。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CBCTIME] Canvel, B., &#34;Password Interception in a SSL/TLS Channel&#34;, http://lasecwww.epfl.ch/memo_ssl.shtml, 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CBCTIME] Canvel、B.、 &#34;SSL / TLSチャンネルでのパスワードの傍受&#34;、http://lasecwww.epfl.ch/memo_ssl.shtml、2003。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ENCAUTH] Krawczyk, H., &#34;The Order of Encryption and Authentication for Protecting Communications (Or: How Secure is SSL?)&#34;, Crypto 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ENCAUTH] Krawczyk、H.、 &#34;通信を保護するための暗号化および認証の順序（または：SSLどのように安全ですか？）&#34;、暗号2001。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KPR03] Klima, V., Pokorny, O., Rosa, T., &#34;Attacking RSA-based Sessions in SSL/TLS&#34;, http://eprint.iacr.org/2003/052/, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KPR03]クリマ、V.、Pokorny、O.、ローザ、T.、 &#34;SSL / TLSでのRSAベースのセッションへの攻撃&#34;、http://eprint.iacr.org/2003/052/、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKCS6] RSA Laboratories, &#34;PKCS #6: RSA Extended Certificate Syntax Standard,&#34; version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKCS6] RSA Laboratories社、 &#34;PKCS＃6：RSA拡張証明書の構文規格、&#34; バージョン1.5、1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKCS7] RSA Laboratories, &#34;PKCS #7: RSA Cryptographic Message Syntax Standard,&#34; version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PKCS7] RSA Laboratories社、 &#34;PKCS＃7：RSA暗号メッセージ構文規格、&#34; バージョン1.5、1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RANDOM] Eastlake, D., 3rd, Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ランダム]イーストレーク、D.、3、シラー、J.、およびS.クロッカー、 &#34;セキュリティのためのランダム要件&#34;、BCP 106、RFC 4086、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RSA] R. Rivest, A. Shamir, and L. M. Adleman, &#34;A Method for Obtaining Digital Signatures and Public-Key Cryptosystems,&#34; Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120-126.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RSA] R.リベスト、A. Shamir、およびL. M.エイドルマン、N、ACM、V。21の通信 &#34;デジタル署名と公開鍵暗号得るための方法&#34;。 2、1978年2月、頁120-126。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SEQNUM] Bellovin, S., &#34;Defending Against Sequence Number Attacks&#34;, RFC 1948, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SEQNUM] Bellovin氏、S.、 &#34;シーケンス番号攻撃からの保護&#34;、RFC 1948、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SSL2] Hickman, Kipp, &#34;The SSL Protocol&#34;, Netscape Communications Corp., Feb 9, 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SSL2]ヒックマン、キップ、 &#34;SSLプロトコル&#34;、ネットスケープ・コミュニケーションズ社、1995年2月9日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SSL3] A. Frier, P. Karlton, and P. Kocher, &#34;The SSL 3.0 Protocol&#34;, Netscape Communications Corp., Nov 18, 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SSL3] A. Frier、P. Karlton、およびP.コッヘル、 &#34;SSL 3.0プロトコル&#34;、ネットスケープ・コミュニケーションズ社、1996年11月18日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SUBGROUP] Zuccherato, R., &#34;Methods for Avoiding the &#34;Small-Subgroup&#34; Attacks on the Diffie-Hellman Key Agreement Method for S/MIME&#34;, RFC 2785, March 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SUBGROUP] Zuccherato、R.、 &#34;S / MIMEにDiffie-Hellman鍵合意方式に対する攻撃 &#34;小サブグループ&#34; の回避のための方法&#34;、RFC 2785、2000年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TCP] Hellstrom, G. and P. Jones, &#34;RTP Payload for Text Conversation&#34;, RFC 4103, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TCP]ヘルストローム、G.とP.ジョーンズ、 &#34;テキストの会話のためのRTPペイロード&#34;、RFC 4103、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TIMING] Boneh, D., Brumley, D., &#34;Remote timing attacks are practical&#34;, USENIX Security Symposium 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[タイミング] Boneh、D.、Brumley、D.、 &#34;リモートタイミング攻撃が実用的である&#34;、USENIXセキュリティシンポジウム2003。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLS1.0] Dierks, T. and C. Allen, &#34;The TLS Protocol Version 1.0&#34;, RFC 2246, January 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLS1.0]ダークス、T.とC.アレン、 &#34;TLSプロトコルバージョン1.0&#34;、RFC 2246、1999年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X501] ITU-T Recommendation X.501: Information Technology - Open Systems Interconnection - The Directory: Models, 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X501] ITU-T勧告X.501：情報技術 - 開放型システム間相互接続 - ディレクトリ：モデル、1993。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X509] ITU-T Recommendation X.509 (1997 E): Information Technology - Open Systems Interconnection - &#34;The Directory - Authentication Framework&#34;. 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X509] ITU-T勧告X.509（1997年E）：情報技術 - 開放型システム間相互接続 -  &#34;ディレクトリ - 認証フレームワーク&#34;。 1988。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[XDR] Srinivasan, R., &#34;XDR: External Data Representation Standard&#34;, RFC 1832, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[XDR]スリニバサン、R.、 &#34;XDR：外部データ表現標準&#34;、RFC 1832、1995年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Working Group Chairs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ワーキンググループチェア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Win Treese
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
勝利Treese
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: treese@acm.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：treese@acm.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Eric Rescorla
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エリックレスコラ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: ekr@rtfm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：ekr@rtfm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Editors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
編集者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tim Dierks Independent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ティム・ダークス独立
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: tim@dierks.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：tim@dierks.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Eric Rescorla RTFM, Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エリックレスコラRTFM株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: ekr@rtfm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：ekr@rtfm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Other Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他の貢献者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Christopher Allen (co-editor of TLS 1.0) Alacrity Ventures EMail: ChristopherA@AlacrityManagement.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クリストファー・アレン（TLS 1.0の共同編集者）いそいそベンチャーズEメール：ChristopherA@AlacrityManagement.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Martin Abadi University of California, Santa Cruz EMail: abadi@cs.ucsc.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
カリフォルニア州のマーティン・アバディ大学、サンタクルス電子メール：abadi@cs.ucsc.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ran Canetti IBM EMail: canetti@watson.ibm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
蘭カネッティIBMのEメール：canetti@watson.ibm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Taher Elgamal Securify EMail: taher@securify.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タハー・エルガマルSecurify Eメール：taher@s​​ecurify.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Anil Gangolli EMail: anil@busybuddha.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アニルGangoliメール：ಅನಿಲ್@ಬ್ಯುಸಿಬ್ಯುದ್ಧ.ಒರ್ಗ್
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kipp Hickman
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キップヒックマン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phil Karlton (co-author of SSLv3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィル・Karlton（のSSLv3の共著）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Paul Kocher (co-author of SSLv3) Cryptography Research EMail: paul@cryptography.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポール・コッヘル（のSSLv3の共著）暗号技術Eメール：paul@cryptography.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hugo Krawczyk Technion Israel Institute of Technology EMail: hugo@ee.technion.ac.il
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
テクノロジーの電子メールのヒューゴKrawczyk Technionのイスラエル研究所：hugo@ee.technion.ac.il
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Robert Relyea Netscape Communications EMail: relyea@netscape.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロバートRelyeaネットスケープ・コミュニケーションズEメール：relyea@netscape.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jim Roskind Netscape Communications EMail: jar@netscape.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジム・Roskindネットスケープ・コミュニケーションズEメール：jar@netscape.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Michael Sabin
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マイケル・セービン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Dan Simon Microsoft, Inc. EMail: dansimon@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そしてサイモンマイクロソフト株式会社メールアドレス：dansimon@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tom Weinstein
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トム・ワインスタイン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Comments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注釈
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The discussion list for the IETF TLS working group is located at the e-mail address &lt;ietf-tls@lists.consensus.com&gt;. Information on the group and information on how to subscribe to the list is at &lt;http://lists.consensus.com/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETF TLSワーキンググループの議論のリストは、電子メールアドレス&lt;ietf-tls@lists.consensus.com&gt;に位置しています。リストの購読方法グループ情報に関する情報は、&lt;http://lists.consensus.com/&gt;です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Archives of the list can be found at: &lt;http://www.imc.org/ietf-tls/mail-archive/&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;http://www.imc.org/ietf-tls/mail-archive/&gt;：リストのアーカイブはで見つけることができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2006）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
