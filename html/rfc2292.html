<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 2292 - Advanced Sockets API for IPv6 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2292</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 2292 - Advanced Sockets API for IPv6 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc2292">
              https://tools.ietf.org/html/rfc2292
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 2292 - IPv6用の拡張ソケットAPI</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                        W. Stevens
Request for Comments: 2292                                   Consultant
Category: Informational                                       M. Thomas
                                                              AltaVista
                                                          February 1998
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     Advanced Sockets API for IPv6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（1998）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifications are in progress for changes to the sockets API to support IP version 6 [RFC-2133]. These changes are for TCP and UDP-based applications and will support most end-user applications in use today: Telnet and FTP clients and servers, HTTP clients and servers, and the like.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仕様は、[RFC-2133] IPバージョン6をサポートするためのソケットAPIへの変更のために進行中です。これらの変更は、TCPおよびUDPベースのアプリケーションのためのものであり、使用されているほとんどのエンドユーザーアプリケーション今日をサポートします：TelnetやFTPクライアントとサーバ、HTTPクライアントとサーバ、などが挙げられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But another class of applications exists that will also be run under IPv6. We call these &#34;advanced&#34; applications and today this includes programs such as Ping, Traceroute, routing daemons, multicast routing daemons, router discovery daemons, and the like. The API feature typically used by these programs that make them &#34;advanced&#34; is a raw socket to access ICMPv4, IGMPv4, or IPv4, along with some knowledge of the packet header formats used by these protocols. To provide portability for applications that use raw sockets under IPv6, some standardization is needed for the advanced API features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、アプリケーションの別のクラスは、IPv6の下で実行されるものが存在します。我々は、これらの「高度な」アプリケーションを呼び出すと、今日、このようなPingの、トレースルート、ルーティングデーモン、マルチキャストルーティングデーモン、ルータディスカバリデーモンなどのプログラムが含まれます。通常、それら作るこれらのプログラムによって使用されるAPIの機能は、「高度な」、これらのプロトコルで使用されるパケットのヘッダフォーマットのいくつかの知識とともに、ICMPv4の、IGMPv4、またはIPv4にアクセスするために、生のソケットです。 IPv6の下rawソケットを使用するアプリケーションのための移植性を提供するために、いくつかの標準化が進んだAPI機能のために必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are other features of IPv6 that some applications will need to access: interface identification (specifying the outgoing interface and determining the incoming interface) and IPv6 extension headers that are not addressed in [RFC-2133]: Hop-by-Hop options, Destination options, and the Routing header (source routing). This document provides API access to these features too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホップバイホップオプション、宛先：[RFC-2133]で扱われていないインタフェース識別（発信インターフェイスを指定して、着信インターフェイスを決定する）とIPv6拡張ヘッダ：他のいくつかのアプリケーションがアクセスする必要があることのIPv6の特徴がありますオプション、およびルーティングヘッダ（ソースルーティング）。この文書では、あまりにも、これらの機能へのAPIアクセスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    1.  Introduction ................................................3
    2.  Common Structures and Definitions ...........................5
       2.1.  The ip6_hdr Structure ..................................5
            2.1.1.  IPv6 Next Header Values .........................6
            2.1.2.  IPv6 Extension Headers ..........................6
       2.2.  The icmp6_hdr Structure ................................8
            2.2.1.  ICMPv6 Type and Code Values .....................8
            2.2.2.  ICMPv6 Neighbor Discovery Type and Code Values ..9
       2.3.  Address Testing Macros .................................12
       2.4.  Protocols File .........................................12
    3.  IPv6 Raw Sockets ............................................13
       3.1.  Checksums ..............................................14
       3.2.  ICMPv6 Type Filtering ..................................14
    4.  Ancillary Data ..............................................17
       4.1.  The msghdr Structure ...................................18
       4.2.  The cmsghdr Structure ..................................18
       4.3.  Ancillary Data Object Macros ...........................19
            4.3.1.  CMSG_FIRSTHDR ...................................20
            4.3.2.  CMSG_NXTHDR .....................................22
            4.3.3.  CMSG_DATA .......................................22
            4.3.4.  CMSG_SPACE ......................................22
            4.3.5.  CMSG_LEN ........................................22
       4.4.  Summary of Options Described Using Ancillary Data ......23
       4.5.  IPV6_PKTOPTIONS Socket Option ..........................24
            4.5.1.  TCP Sticky Options ..............................25
            4.5.2.  UDP and Raw Socket Sticky Options ...............26
    5.  Packet Information ..........................................26
       5.1.  Specifying/Receiving the Interface .....................27
       5.2.  Specifying/Receiving Source/Destination Address ........27
       5.3.  Specifying/Receiving the Hop Limit .....................28
       5.4.  Specifying the Next Hop Address ........................29
       5.5.  Additional Errors with sendmsg() .......................29
    6.  Hop-By-Hop Options ..........................................30
       6.1.  Receiving Hop-by-Hop Options ...........................31
       6.2.  Sending Hop-by-Hop Options .............................31
       6.3.  Hop-by-Hop and Destination Options Processing ..........32
            6.3.1.  inet6_option_space ..............................32
            6.3.2.  inet6_option_init ...............................32
            6.3.3.  inet6_option_append .............................33
            6.3.4.  inet6_option_alloc ..............................33
            6.3.5.  inet6_option_next ...............................34
            6.3.6.  inet6_option_find ...............................35
            6.3.7.  Options Examples ................................35
    7.  Destination Options .........................................42
       7.1.  Receiving Destination Options ..........................42
       7.2.  Sending Destination Options ............................43
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    8.  Routing Header Option .......................................43
       8.1.  inet6_rthdr_space ......................................44
       8.2.  inet6_rthdr_init .......................................45
       8.3.  inet6_rthdr_add ........................................45
       8.4.  inet6_rthdr_lasthop ....................................46
       8.5.  inet6_rthdr_reverse ....................................46
       8.6.  inet6_rthdr_segments ...................................46
       8.7.  inet6_rthdr_getaddr ....................................46
       8.8.  inet6_rthdr_getflags ...................................47
       8.9.  Routing Header Example .................................47
    9.  Ordering of Ancillary Data and IPv6 Extension Headers .......53
   10.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses .......54
   11.  rresvport_af ................................................55
   12.  Future Items ................................................55
       12.1.  Flow Labels ...........................................55
       12.2.  Path MTU Discovery and UDP ............................56
       12.3.  Neighbor Reachability and UDP .........................56
   13.  Summary of New Definitions ..................................56
   14.  Security Considerations .....................................59
   15.  Change History ..............................................59
   16.  References ..................................................65
   17.  Acknowledgments .............................................65
   18.  Authors&#39; Addresses ..........................................66
   19.  Full Copyright Statement ....................................67
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifications are in progress for changes to the sockets API to support IP version 6 [RFC-2133]. These changes are for TCP and UDP-based applications. The current document defines some the &#34;advanced&#34; features of the sockets API that are required for applications to take advantage of additional features of IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仕様は、[RFC-2133] IPバージョン6をサポートするためのソケットAPIへの変更のために進行中です。これらの変更は、TCPおよびUDPベースのアプリケーションのためのものです。現在のドキュメントは、IPv6の追加機能を利用するアプリケーションのために必要とされるソケットAPIのいくつかの「高度な」機能を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Today, the portability of applications using IPv4 raw sockets is quite high, but this is mainly because most IPv4 implementations started from a common base (the Berkeley source code) or at least started with the Berkeley headers. This allows programs such as Ping and Traceroute, for example, to compile with minimal effort on many hosts that support the sockets API. With IPv6, however, there is no common source code base that implementors are starting from, and the possibility for divergence at this level between different implementations is high. To avoid a complete lack of portability amongst applications that use raw IPv6 sockets, some standardization is necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今日、IPv4の生のソケットを使用するアプリケーションの移植性は非常に高いが、ほとんどのIPv4実装が共通のベース（バークレーソースコード）から起動または少なくともバークレーヘッダで開始するので、これは主にあります。これは、pingやtracerouteのようなプログラムは、例えば、ソケットAPIをサポートする多くのホスト上で最小限の労力でコンパイルすることができます。 IPv6では、しかし、そこに実装から始めて共通ソースコードベースはなく、異なる実装の間でこのレベルの発散の可能性が高いです。生のIPv6ソケットを使用するアプリケーション間での移植性の完全な欠如を避けるために、いくつかの標準化が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are also features from the basic IPv6 specification that are not addressed in [RFC-2133]: sending and receiving Hop-by-Hop options, Destination options, and Routing headers, specifying the outgoing interface, and being told of the receiving interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信側と受信側のホップバイホップオプション、宛先オプション、およびルーティングヘッダを、発信インターフェイスを指定し、受信インタフェースの言われて：[RFC-2133]で扱われていない基本IPv6仕様から機能もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document can be divided into the following main sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、次の主要なセクションに分けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Definitions of the basic constants and structures required for applications to use raw IPv6 sockets. This includes structure definitions for the IPv6 and ICMPv6 headers and all associated constants (e.g., values for the Next Header field).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生のIPv6ソケットを使用するアプリケーションに必要な基本的な定数と構造体の1.定義。これは、IPv6とICMPv6のヘッダと関連するすべての定数（例えば、次ヘッダフィールドの値）のための構造定義を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Some basic semantic definitions for IPv6 raw sockets. For example, a raw ICMPv4 socket requires the application to calculate and store the ICMPv4 header checksum. But with IPv6 this would require the application to choose the source IPv6 address because the source address is part of the pseudo header that ICMPv6 now uses for its checksum computation. It should be defined that with a raw ICMPv6 socket the kernel always calculates and stores the ICMPv6 header checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. IPv6のrawソケットのためのいくつかの基本的なセマンティック定義が。例えば、生ICMPv4のソケットはICMPv4のヘッダチェックサムを計算して格納するアプリケーションを必要とします。しかし、IPv6でこれは、送信元アドレスは、ICMPv6のは今そのチェックサムの計算に使用する擬似ヘッダの一部であるため、送信元IPv6アドレスを選択するためのアプリケーションが必要になります。生のICMPv6ソケットにカーネルは常にICMPv6のヘッダチェックサムを計算し、記憶することが定義されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Packet information: how applications can obtain the received interface, destination address, and received hop limit, along with specifying these values on a per-packet basis. There are a class of applications that need this capability and the technique should be portable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前記パケット情報：アプリケーションは、受信インタフェース、宛先アドレス、およびパケット単位でこれらの値を指定するとともに、ホップ制限を受けを得ることができる方法。ポータブルである必要があり、この機能と技術を必要とするアプリケーションのクラスがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Access to the optional Hop-by-Hop, Destination, and Routing headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションのホップバイホップ、送信先、およびルーティングヘッダーへのアクセス4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Additional features required for IPv6 application portability.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
IPv6のアプリケーションの移植性のために必要な5.その他の機能。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet information along with access to the extension headers (Hop-by-Hop options, Destination options, and Routing header) are specified using the &#34;ancillary data&#34; fields that were added to the 4.3BSD Reno sockets API in 1990. The reason is that these ancillary data fields are part of the Posix.1g standard (which should be approved in 1997) and should therefore be adopted by most vendors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張ヘッダーへのアクセス（ホップバイホップオプション、宛先オプション、およびルーティングヘッダ）と共にパケット情報は、理由は1990年に4.3BSDレノソケットAPIに追加された「補助データ」フィールドを使用して指定されていますこれらの補助データフィールドは、（1997年に承認されなければならない）Posix.1g標準の一部であるため、ほとんどのベンダーによって採用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not address application access to either the authentication header or the encapsulating security payload header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、認証ヘッダやカプセル化セキュリティペイロードヘッダのいずれかへのアクセスをアプリケーションに対応していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All examples in this document omit error checking in favor of brevity and clarity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントのすべての例では、簡潔かつ明瞭に賛成してエラーチェックを省略します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that many of the functions and socket options defined in this document may have error returns that are not defined in this document. Many of these possible error returns will be recognized only as implementations proceed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、この文書で定義された関数とソケットのオプションの多くは、この文書で定義されていないエラーリターンを持っているかもしれないことに注意します。これらの可能性のあるエラーを返すの多くは、実装が進むだけとして認識されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Datatypes in this document follow the Posix.1g format: intN_t means a signed integer of exactly N bits (e.g., int16_t) and uintN_t means an unsigned integer of exactly N bits (e.g., uint32_t).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書に記載されているデータ型はPosix.1gフォーマットは、次のとおりintN_tは正確にNビットの符号付き整数（例えば、int16_t）を意味し、uintN_tは正確にNビットの符号なし整数（例えば、のuint32_t）を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and ARPv4 to avoid any confusion with the newer ICMPv6 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は新しいICMPv6のプロトコルとの混同を避けるために（非公式）用語ICMPv4の、IGMPv4、およびARPv4を使用することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Common Structures and Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.一般的な構造と定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many advanced applications examine fields in the IPv6 header and set and examine fields in the various ICMPv6 headers. Common structure definitions for these headers are required, along with common constant definitions for the structure members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの高度なアプリケーションは、IPv6ヘッダーのフィールドを調べて、各種のICMPv6ヘッダー内のフィールドを設定して調べ。これらのヘッダーのための一般的な構造体の定義は、構造体のメンバーのための共通の定数の定義とともに、必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two new headers are defined: &lt;netinet/ip6.h&gt; and &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
二つの新しいヘッダが定義されています。&lt;netinetの/ ip6.h&gt;と&lt;netinetの/ icmp6.h&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an include file is specified, that include file is allowed to include other files that do the actual declaration or definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インクルードファイルを指定すると、そのファイルが含まれるが、実際の宣言または定義を行う他のファイルを含めることが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. The ip6_hdr Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.  ip6_hdr構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following structure is defined as a result of including &lt;netinet/ip6.h&gt;. Note that this is a new header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の構造は、&lt;netinetの/ ip6.h&gt;などの結果として定義されます。これは新しいヘッダであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct ip6_hdr {
      union {
        struct ip6_hdrctl {
          uint32_t ip6_un1_flow;   /* 24 bits of flow-ID */
          uint16_t ip6_un1_plen;   /* payload length */
          uint8_t  ip6_un1_nxt;    /* next header */
          uint8_t  ip6_un1_hlim;   /* hop limit */
        } ip6_un1;
        uint8_t ip6_un2_vfc;       /* 4 bits version, 4 bits priority */
      } ip6_ctlun;
      struct in6_addr ip6_src;      /* source address */
      struct in6_addr ip6_dst;      /* destination address */
    };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
#define ip6_vfc ip6_ctlun.ip6_un2_vfc #define ip6_flow ip6_ctlun.ip6_un1.ip6_un1_flow #define ip6_plen ip6_ctlun.ip6_un1.ip6_un1_plen #define ip6_nxt ip6_ctlun.ip6_un1.ip6_un1_nxt #define ip6_hlim ip6_ctlun.ip6_un1.ip6_un1_hlim
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
#define ip6_vfc ip6_ctlun.ip6_un2_vfcの#define ip6_flow ip6_ctlun.ip6_un1.ip6_un1_flowの#define ip6_plen ip6_ctlun.ip6_un1.ip6_un1_plenの#define ip6_nxt ip6_ctlun.ip6_un1.ip6_un1_nxtの#define ip6_hlim ip6_ctlun.ip6_un1.ip6_un1_hlim
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
#define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
#define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1. IPv6 Next Header Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1.  IPv6の次のヘッダ値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6 defines many new values for the Next Header field. The following constants are defined as a result of including &lt;netinet/in.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6は、次ヘッダフィールドのための多くの新しい値を定義します。以下の定数は、&lt;netinetの/ in.h&gt;などの結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define IPPROTO_HOPOPTS        0 /* IPv6 Hop-by-Hop options */
   #define IPPROTO_IPV6          41 /* IPv6 header */
   #define IPPROTO_ROUTING       43 /* IPv6 Routing header */
   #define IPPROTO_FRAGMENT      44 /* IPv6 fragmentation header */
   #define IPPROTO_ESP           50 /* encapsulating security payload */
   #define IPPROTO_AH            51 /* authentication header */
   #define IPPROTO_ICMPV6        58 /* ICMPv6 */
   #define IPPROTO_NONE          59 /* IPv6 no next header */
   #define IPPROTO_DSTOPTS       60 /* IPv6 Destination options */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Berkeley-derived IPv4 implementations also define IPPROTO_IP to be 0. This should not be a problem since IPPROTO_IP is used only with IPv4 sockets and IPPROTO_HOPOPTS only with IPv6 sockets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バークレー由来のIPv4実装もIPPROTO_IPのみIPv6ソケットとIPv4のみのソケットとIPPROTO_HOPOPTSと共に使用されるので、これは問題にはならない0にIPPROTO_IPを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2. IPv6 Extension Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2.  IPv6拡張ヘッダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Six extension headers are defined for IPv6. We define structures for all except the Authentication header and Encapsulating Security Payload header, both of which are beyond the scope of this document. The following structures are defined as a result of including &lt;netinet/ip6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シックス・拡張ヘッダは、IPv6のために定義されています。私たちは、このドキュメントの範囲を超えて、どちらも認証ヘッダーとカプセル化セキュリティペイロードヘッダ、以外のすべてのための構造を定義します。以下の構造は、&lt;netinetの/ ip6.h&gt;を含めた結果として定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Hop-by-Hop options header */
   /* XXX should we pad it to force alignment on an 8-byte boundary? */
   struct ip6_hbh {
     uint8_t  ip6h_nxt;        /* next header */
     uint8_t  ip6h_len;        /* length in units of 8 octets */
       /* followed by options */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Destination options header */
   /* XXX should we pad it to force alignment on an 8-byte boundary? */
   struct ip6_dest {
     uint8_t  ip6d_nxt;        /* next header */
     uint8_t  ip6d_len;        /* length in units of 8 octets */
       /* followed by options */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Routing header */
   struct ip6_rthdr {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     uint8_t  ip6r_nxt;        /* next header */
     uint8_t  ip6r_len;        /* length in units of 8 octets */
     uint8_t  ip6r_type;       /* routing type */
     uint8_t  ip6r_segleft;    /* segments left */
       /* followed by routing type specific data */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Type 0 Routing header */
   struct ip6_rthdr0 {
     uint8_t  ip6r0_nxt;       /* next header */
     uint8_t  ip6r0_len;       /* length in units of 8 octets */
     uint8_t  ip6r0_type;      /* always zero */
     uint8_t  ip6r0_segleft;   /* segments left */
     uint8_t  ip6r0_reserved;  /* reserved field */
     uint8_t  ip6r0_slmap[3];  /* strict/loose bit map */
     struct in6_addr  ip6r0_addr[1];  /* up to 23 addresses */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Fragment header */
   struct ip6_frag {
     uint8_t   ip6f_nxt;       /* next header */
     uint8_t   ip6f_reserved;  /* reserved field */
     uint16_t  ip6f_offlg;     /* offset, reserved, and flag */
     uint32_t  ip6f_ident;     /* identification */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #if     BYTE_ORDER == BIG_ENDIAN
   #define IP6F_OFF_MASK       0xfff8  /* mask out offset from _offlg */
   #define IP6F_RESERVED_MASK  0x0006  /* reserved bits in ip6f_offlg */
   #define IP6F_MORE_FRAG      0x0001  /* more-fragments flag */
   #else   /* BYTE_ORDER == LITTLE_ENDIAN */
   #define IP6F_OFF_MASK       0xf8ff  /* mask out offset from _offlg */
   #define IP6F_RESERVED_MASK  0x0600  /* reserved bits in ip6f_offlg */
   #define IP6F_MORE_FRAG      0x0100  /* more-fragments flag */
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Defined constants for fields larger than 1 byte depend on the byte ordering that is used. This API assumes that the fields in the protocol headers are left in the network byte order, which is big-endian for the Internet protocols. If not, then either these constants or the fields being tested must be converted at run-time, using something like htons() or htonl().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1バイトを超えるフィールドの定義された定数が使用されているバイト順序に依存します。このAPIは、プロトコルヘッダ内のフィールドは、インターネットプロトコルのためのビッグエンディアンであるネットワークバイト順、に残されていることを前提としています。そうでない場合には、これらの定数またはテストされているいずれかのフィールドはhtons（）やhtonl（）のようなものを使用して、実行時に変換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: We show an implementation that supports both big-endian and little-endian byte ordering, assuming a hypothetical compile-time #if test to determine the byte ordering. The constant that we show,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：私たちは、バイト順序を決定するために、テストの#if架空のコンパイル時を想定し、ビッグエンディアンとリトルエンディアンバイト順の両方サポートする実装を示し、我々は示すことが定数、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYTE_ORDER, with values of BIG_ENDIAN and LITTLE_ENDIAN, are for example purposes only. If an implementation runs on only one type of hardware it need only define the set of constants for that hardware&#39;s byte ordering.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BYTE_ORDER、BIG_ENDIANとLITTLE_ENDIANの値で、例のみを目的としています。実装は、ハードウェアの一種類のみで実行されている場合にのみ、そのハードウェアのバイト順の定数のセットを定義する必要が。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. The icmp6_hdr Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.  icmp6_hdr構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ICMPv6 header is needed by numerous IPv6 applications including Ping, Traceroute, router discovery daemons, and neighbor discovery daemons. The following structure is defined as a result of including &lt;netinet/icmp6.h&gt;. Note that this is a new header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv6のヘッダはPingの、トレースルート、ルータディスカバリデーモン、近傍検索デーモンを含む多数のIPv6アプリケーションで必要とされます。以下の構造は、&lt;netinetの/ icmp6.h&gt;などの結果として定義されます。これは新しいヘッダであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct icmp6_hdr {
     uint8_t     icmp6_type;   /* type field */
     uint8_t     icmp6_code;   /* code field */
     uint16_t    icmp6_cksum;  /* checksum field */
     union {
       uint32_t  icmp6_un_data32[1]; /* type-specific field */
       uint16_t  icmp6_un_data16[2]; /* type-specific field */
       uint8_t   icmp6_un_data8[4];  /* type-specific field */
     } icmp6_dataun;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define icmp6_data32    icmp6_dataun.icmp6_un_data32
   #define icmp6_data16    icmp6_dataun.icmp6_un_data16
   #define icmp6_data8     icmp6_dataun.icmp6_un_data8
   #define icmp6_pptr      icmp6_data32[0]  /* parameter prob */
   #define icmp6_mtu       icmp6_data32[0]  /* packet too big */
   #define icmp6_id        icmp6_data16[0]  /* echo request/reply */
   #define icmp6_seq       icmp6_data16[1]  /* echo request/reply */
   #define icmp6_maxdelay  icmp6_data16[0]  /* mcast group membership */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. ICMPv6 Type and Code Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1.  ICMPv6のタイプとコード値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to a common structure for the ICMPv6 header, common definitions are required for the ICMPv6 type and code fields. The following constants are also defined as a result of including &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv6のヘッダの共通の構造に加えて、一般的な定義は、ICMPv6のタイプとコードフィールドに必要とされます。以下の定数はまた、&lt;netinetの/ icmp6.h&gt;などの結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define ICMP6_DST_UNREACH 1 #define ICMP6_PACKET_TOO_BIG 2 #define ICMP6_TIME_EXCEEDED 3 #define ICMP6_PARAM_PROB 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define ICMP6_DST_UNREACH 1の#define ICMP6_PACKET_TOO_BIG 2の#define ICMP6_TIME_EXCEEDED 3の#define ICMP6_PARAM_PROB 4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define ICMP6_INFOMSG_MASK  0x80    /* all informational messages */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define ICMP6_ECHO_REQUEST 128 #define ICMP6_ECHO_REPLY 129
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define ICMP6_ECHO_REQUEST 128の#define ICMP6_ECHO_REPLY 129
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define ICMP6_MEMBERSHIP_QUERY 130 #define ICMP6_MEMBERSHIP_REPORT 131 #define ICMP6_MEMBERSHIP_REDUCTION 132
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define ICMP6_MEMBERSHIP_QUERY 130の#define ICMP6_MEMBERSHIP_REPORT 131の#define ICMP6_MEMBERSHIP_REDUCTION 132
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to destination */
#define ICMP6_DST_UNREACH_ADMIN       1 /* communication with */
                                        /* destination */
                                        /* administratively */
                                        /* prohibited */
#define ICMP6_DST_UNREACH_NOTNEIGHBOR 2 /* not a neighbor */
#define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */
#define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in transit */
#define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define ICMP6_PARAMPROB_HEADER        0 /* erroneous header field */
#define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized Next Header */
#define ICMP6_PARAMPROB_OPTION        2 /* unrecognized IPv6 option */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The five ICMP message types defined by IPv6 neighbor discovery (133- 137) are defined in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6近隣探索（133- 137）によって定義された5つのICMPメッセージタイプは、次のセクションで定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. ICMPv6 Neighbor Discovery Type and Code Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2.  ICMPv6の近隣探索タイプとコード値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following structures and definitions are defined as a result of including &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の構造および定義は、&lt;netinetの/ icmp6.h&gt;などの結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ND_ROUTER_SOLICIT 133 #define ND_ROUTER_ADVERT 134 #define ND_NEIGHBOR_SOLICIT 135 #define ND_NEIGHBOR_ADVERT 136 #define ND_REDIRECT 137
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ND_ROUTER_SOLICIT 133の#define ND_ROUTER_ADVERT 134の#define ND_NEIGHBOR_SOLICIT 135の#define ND_NEIGHBOR_ADVERT 136の#define ND_REDIRECT 137
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nd_router_solicit {     /* router solicitation */
     struct icmp6_hdr  nd_rs_hdr;
       /* could be followed by options */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define nd_rs_type nd_rs_hdr.icmp6_type #define nd_rs_code nd_rs_hdr.icmp6_code #define nd_rs_cksum nd_rs_hdr.icmp6_cksum #define nd_rs_reserved nd_rs_hdr.icmp6_data32[0]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define nd_rs_type nd_rs_hdr.icmp6_typeの#define nd_rs_code nd_rs_hdr.icmp6_codeの#define nd_rs_cksum nd_rs_hdr.icmp6_cksumの#define nd_rs_reserved nd_rs_hdr.icmp6_data32 [0]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nd_router_advert {      /* router advertisement */
     struct icmp6_hdr  nd_ra_hdr;
     uint32_t   nd_ra_reachable;   /* reachable time */
     uint32_t   nd_ra_retransmit;  /* retransmit timer */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* could be followed by options */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define nd_ra_type nd_ra_hdr.icmp6_type #define nd_ra_code nd_ra_hdr.icmp6_code #define nd_ra_cksum nd_ra_hdr.icmp6_cksum #define nd_ra_curhoplimit nd_ra_hdr.icmp6_data8[0] #define nd_ra_flags_reserved nd_ra_hdr.icmp6_data8[1] #define ND_RA_FLAG_MANAGED 0x80 #define ND_RA_FLAG_OTHER 0x40 #define nd_ra_router_lifetime nd_ra_hdr.icmp6_data16[1]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define nd_ra_type nd_ra_hdr.icmp6_typeの#define nd_ra_code nd_ra_hdr.icmp6_codeの#define nd_ra_cksum nd_ra_hdr.icmp6_cksumの#define nd_ra_curhoplimit nd_ra_hdr.icmp6_data8 [0]の#define nd_ra_flags_reserved nd_ra_hdr.icmp6_data8 [1]の#define ND_RA_FLAG_MANAGEDは0x80の#define ND_RA_FLAG_OTHER 0x40のに#define nd_ra_router_lifetime nd_ra_hdr.icmp6_data16 [1]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nd_neighbor_solicit {   /* neighbor solicitation */
     struct icmp6_hdr  nd_ns_hdr;
     struct in6_addr   nd_ns_target; /* target address */
       /* could be followed by options */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define nd_ns_type nd_ns_hdr.icmp6_type #define nd_ns_code nd_ns_hdr.icmp6_code #define nd_ns_cksum nd_ns_hdr.icmp6_cksum #define nd_ns_reserved nd_ns_hdr.icmp6_data32[0]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define nd_ns_type nd_ns_hdr.icmp6_typeの#define nd_ns_code nd_ns_hdr.icmp6_codeの#define nd_ns_cksum nd_ns_hdr.icmp6_cksumの#define nd_ns_reserved nd_ns_hdr.icmp6_data32 [0]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nd_neighbor_advert {    /* neighbor advertisement */
     struct icmp6_hdr  nd_na_hdr;
     struct in6_addr   nd_na_target; /* target address */
       /* could be followed by options */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #define nd_na_type               nd_na_hdr.icmp6_type
   #define nd_na_code               nd_na_hdr.icmp6_code
   #define nd_na_cksum              nd_na_hdr.icmp6_cksum
   #define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]
   #if     BYTE_ORDER == BIG_ENDIAN
   #define ND_NA_FLAG_ROUTER        0x80000000
   #define ND_NA_FLAG_SOLICITED     0x40000000
   #define ND_NA_FLAG_OVERRIDE      0x20000000
   #else   /* BYTE_ORDER == LITTLE_ENDIAN */
   #define ND_NA_FLAG_ROUTER        0x00000080
   #define ND_NA_FLAG_SOLICITED     0x00000040
   #define ND_NA_FLAG_OVERRIDE      0x00000020
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nd_redirect {           /* redirect */
     struct icmp6_hdr  nd_rd_hdr;
     struct in6_addr   nd_rd_target; /* target address */
     struct in6_addr   nd_rd_dst;    /* destination address */
       /* could be followed by options */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define nd_rd_type nd_rd_hdr.icmp6_type #define nd_rd_code nd_rd_hdr.icmp6_code #define nd_rd_cksum nd_rd_hdr.icmp6_cksum #define nd_rd_reserved nd_rd_hdr.icmp6_data32[0]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define nd_rd_type nd_rd_hdr.icmp6_typeの#define nd_rd_code nd_rd_hdr.icmp6_codeの#define nd_rd_cksum nd_rd_hdr.icmp6_cksumの#define nd_rd_reserved nd_rd_hdr.icmp6_data32 [0]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nd_opt_hdr {           /* Neighbor discovery option header */
     uint8_t  nd_opt_type;
     uint8_t  nd_opt_len;        /* in units of 8 octets */
       /* followed by option specific data */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ND_OPT_SOURCE_LINKADDR 1 #define ND_OPT_TARGET_LINKADDR 2 #define ND_OPT_PREFIX_INFORMATION 3 #define ND_OPT_REDIRECTED_HEADER 4 #define ND_OPT_MTU 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ND_OPT_SOURCE_LINKADDR 1の#define ND_OPT_TARGET_LINKADDR 2の#define ND_OPT_PREFIX_INFORMATION 3の#define ND_OPT_REDIRECTED_HEADER 4の#define ND_OPT_MTU 5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nd_opt_prefix_info {    /* prefix information */
     uint8_t   nd_opt_pi_type;
     uint8_t   nd_opt_pi_len;
     uint8_t   nd_opt_pi_prefix_len;
     uint8_t   nd_opt_pi_flags_reserved;
     uint32_t  nd_opt_pi_valid_time;
     uint32_t  nd_opt_pi_preferred_time;
     uint32_t  nd_opt_pi_reserved2;
     struct in6_addr  nd_opt_pi_prefix;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ND_OPT_PI_FLAG_ONLINK 0x80 #define ND_OPT_PI_FLAG_AUTO 0x40
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define ND_OPT_PI_FLAG_ONLINKは0x80に#define ND_OPT_PI_FLAG_AUTOは0x40
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nd_opt_rd_hdr {         /* redirected header */
     uint8_t   nd_opt_rh_type;
     uint8_t   nd_opt_rh_len;
     uint16_t  nd_opt_rh_reserved1;
     uint32_t  nd_opt_rh_reserved2;
       /* followed by IP header and data */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nd_opt_mtu {            /* MTU option */
     uint8_t   nd_opt_mtu_type;
     uint8_t   nd_opt_mtu_len;
     uint16_t  nd_opt_mtu_reserved;
     uint32_t  nd_opt_mtu_mtu;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that the nd_na_flags_reserved flags have the same byte ordering problems as we discussed with ip6f_offlg.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々はip6f_offlgして説明したようにnd_na_flags_reservedフラグは同じバイト順序の問題を抱えていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Address Testing Macros
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. テストマクロアドレス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic API ([RFC-2133]) defines some macros for testing an IPv6 address for certain properties. This API extends those definitions with additional address testing macros, defined as a result of including &lt;netinet/in.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的なAPI（[RFC-2133]）は、特定のプロパティのIPv6アドレスをテストするためのいくつかのマクロを定義します。このAPIは、&lt;netinetの/ in.h&gt;を含めた結果として定義され、追加のアドレステストマクロとそれらの定義を拡張します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
int IN6_ARE_ADDR_EQUAL(const struct in6_addr *, const struct in6_addr *);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
int型IN6_ARE_ADDR_EQUAL（constの構造体のin6_addr *、constの構造体のin6_addr *）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. Protocols File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. プロトコルファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many hosts provide the file /etc/protocols that contains the names of the various IP protocols and their protocol number (e.g., the value of the protocol field in the IPv4 header for that protocol, such as 1 for ICMP). Some programs then call the function getprotobyname() to obtain the protocol value that is then specified as the third argument to the socket() function. For example, the Ping program contains code of the form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのホストは、様々なIPプロトコルの名前とそのプロトコル番号を含む、ファイル/ etc /プロトコルを提供する（例えば、そのプロトコルのIPv4ヘッダのプロトコルフィールドの値は、ICMPのような1）。いくつかのプログラムは、次いで、ソケット（）関数の3番目の引数として指定されたプロトコル値を得るために、関数getprotobyname（）を呼び出します。たとえば、pingプログラムは、フォームのコードが含まれています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
struct protoent *proto;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
構造体protoent *プロト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
proto = getprotobyname(&#34;icmp&#34;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
プロト= getprotobyname（ &#34;ICMP&#34;）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
s = socket(AF_INET, SOCK_RAW, proto-&gt;p_proto);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
S =ソケット（aphaiset、sockra、プロト&gt; pproto）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Common names are required for the new IPv6 protocols in this file, to provide portability of applications that call the getprotoXXX() functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的な名前はgetprotoXXX（）関数を呼び出すアプリケーションの移植性を提供するために、このファイルに新しいIPv6プロトコルのために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We define the following protocol names with the values shown. These are taken from ftp://ftp.isi.edu/in-notes/iana/assignments/protocol-numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、示された値と、次のプロトコル名を定義します。これらは、ftp://ftp.isi.edu/in-notes/iana/assignments/protocol-numbersから取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       hopopt           0    # hop-by-hop options for ipv6
       ipv6            41    # ipv6
       ipv6-route      43    # routing header for ipv6
       ipv6-frag       44    # fragment header for ipv6
       esp             50    # encapsulating security payload for ipv6
       ah              51    # authentication header for ipv6
       ipv6-icmp       58    # icmp for ipv6
       ipv6-nonxt      59    # no next header for ipv6
       ipv6-opts       60    # destination options for ipv6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IPv6 Raw Sockets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IPv6のrawソケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Raw sockets bypass the transport layer (TCP or UDP). With IPv4, raw sockets are used to access ICMPv4, IGMPv4, and to read and write IPv4 datagrams containing a protocol field that the kernel does not process. An example of the latter is a routing daemon for OSPF, since it uses IPv4 protocol field 89. With IPv6 raw sockets will be used for ICMPv6 and to read and write IPv6 datagrams containing a Next Header field that the kernel does not process. Examples of the latter are a routing daemon for OSPF for IPv6 and RSVP (protocol field 46).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rawソケットは、トランスポート層（TCPまたはUDP）をバイパスします。 IPv4では、rawソケットがICMPv4の、IGMPv4にアクセスするには、カーネルが処理しないことをプロトコルフィールドを含むIPv4のデータグラムを読み書きするために使用されています。それはICMPv6のために使用され、カーネルが処理をしないことを次のヘッダーフィールドを含むIPv6データグラムを読み書きするIPv6の生のソケットをIPv4プロトコルフィールド89を使用するので、後者の例は、OSPFのルーティングデーモンです。後者の例は、IPv6とRSVP（プロトコルフィールド46）のためのOSPFのルーティングデーモンです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All data sent via raw sockets MUST be in network byte order and all data received via raw sockets will be in network byte order. This differs from the IPv4 raw sockets, which did not specify a byte ordering and typically used the host&#39;s byte order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rawソケット経由で送信されたすべてのデータはネットワークバイト順でなければならず、生のソケットを介して受信されたすべてのデータはネットワークバイト順になります。これは、バイト順序を指定して、通常、ホストのバイト順序を使用していなかったのIPv4生ソケットとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another difference from IPv4 raw sockets is that complete packets (that is, IPv6 packets with extension headers) cannot be read or written using the IPv6 raw sockets API. Instead, ancillary data objects are used to transfer the extension headers, as described later in this document. Should an application need access to the complete IPv6 packet, some other technique, such as the datalink interfaces BPF or DLPI, must be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4の生のソケットから別の違いは、完全なパケット（つまり、拡張ヘッダを持つIPv6パケットである）のIPv6生ソケットAPIを使用して読み書きすることができないことです。本書で後述するように、その代わりに、補助的なデータオブジェクトは、拡張ヘッダを転送するために使用されます。アプリケーションは、完全なIPv6パケットにアクセスする必要がある場合は、そのようなデータリンクインタフェースなどのいくつかの他の技術、BPFやDLPIは、使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All fields in the IPv6 header that an application might want to change (i.e., everything other than the version number) can be modified using ancillary data and/or socket options by the application for output. All fields in a received IPv6 header (other than the version number and Next Header fields) and all extension headers are also made available to the application as ancillary data on input. Hence there is no need for a socket option similar to the IPv4 IP_HDRINCL socket option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6におけるすべてのフィールドは、アプリケーションが変更する可能性があることをヘッダ（すなわち、バージョン番号以外のすべて）を出力するためのアプリケーションで補助的なデータ及び/又はソケットオプションを使用して修正することができます。 （バージョン番号と次ヘッダフィールドを除く）を受信したIPv6ヘッダ内のすべてのフィールドと全ての拡張ヘッダは、入力上の補助データとしてアプリケーションに利用可能にされます。そのためのIPv4 IP_HDRINCLソケットオプションに似たソケットオプションは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When writing to a raw socket the kernel will automatically fragment the packet if its size exceeds the path MTU, inserting the required fragmentation headers. On input the kernel reassembles received fragments, so the reader of a raw socket never sees any fragment headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生のソケットに書き込むときに、そのサイズがパスMTUを超えた場合、カーネルは自動的に必要な断片化ヘッダを挿入し、パケットを断片化します。入力時にカーネルは受け取った断片を再構成するので、生のソケットの読者は、任意のフラグメントヘッダを見たことがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When we say &#34;an ICMPv6 raw socket&#34; we mean a socket created by calling the socket function with the three arguments PF_INET6, SOCK_RAW, and IPPROTO_ICMPV6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは「ICMPv6の生のソケット」と言うとき、私たちは三つの引数PF_INET6、SOCK_RAW、およびIPPROTO_ICMPV6とソケット関数を呼び出すことによって作成されたソケットを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most IPv4 implementations give special treatment to a raw socket created with a third argument to socket() of IPPROTO_RAW, whose value is normally 255. We note that this value has no special meaning to an IPv6 raw socket (and the IANA currently reserves the value of 255 when used as a next-header field). (Note: This feature was added to IPv4 in 1988 by Van Jacobson to support traceroute, allowing a complete IP header to be passed by the application, before the IP_HDRINCL socket option was added.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどのIPv4の実装では、その値が、通常255です。私たちは、この値はIPv6の生のソケット（およびIANAには特別な意味が現在値を予約していないことに注意してくださいIPPROTO_RAW、の）（ソケットへの第三引数で作成された生のソケットに特別な治療を与えます次ヘッダフィールドとして使用される255）の。 （注：この機能は、IP_HDRINCLソケットオプションを添加する前に完全なIPヘッダは、アプリケーションによって渡されることを可能にする、tracerouteをサポートするために、バン・ジェイコブソンによって1988年にはIPv4に添加しました。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Checksums
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. チェックサム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The kernel will calculate and insert the ICMPv6 checksum for ICMPv6 raw sockets, since this checksum is mandatory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチェックサムは必須であるため、カーネルは、ICMPv6の生のソケット用のICMPv6チェックサムを計算して挿入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For other raw IPv6 sockets (that is, for raw IPv6 sockets created with a third argument other than IPPROTO_ICMPV6), the application must set the new IPV6_CHECKSUM socket option to have the kernel (1) compute and store a checksum for output, and (2) verify the received checksum on input, discarding the packet if the checksum is in error. This option prevents applications from having to perform source address selection on the packets they send. The checksum will incorporate the IPv6 pseudo-header, defined in Section 8.1 of [RFC-1883]. This new socket option also specifies an integer offset into the user data of where the checksum is located.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の生のIPv6ソケット（すなわちIPPROTO_ICMPV6以外の第三引数で作成された生のIPv6ソケットのために）、カーネルを持つ新しいIPV6_CHECKSUMソケットオプションを設定する必要があり、アプリケーション（1）を計算して出力するためのチェックサムを格納し、（2 ）チェックサムがエラーである場合、パケットを廃棄する、入力に受信したチェックサムを検証します。このオプションは、彼らが送信するパケットに送信元アドレス選択を実行することからアプリケーションを防ぎます。チェックサムは、[RFC-1883]のセクション8.1で定義されたIPv6疑似ヘッダを組み込みます。この新しいソケットオプションもチェックサムが配置されている場所のユーザデータへのオフセットの整数を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    int  offset = 2;
    setsockopt(fd, IPPROTO_IPV6, IPV6_CHECKSUM, &amp;offset, sizeof(offset));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By default, this socket option is disabled. Setting the offset to -1 also disables the option. By disabled we mean (1) the kernel will not calculate and store a checksum for outgoing packets, and (2) the kernel will not verify a checksum for received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトでは、このソケットオプションが無効になっています。オフセットに-1を設定すると、オプションを無効にします。無効にすることで、我々は、（1）カーネルが計算し、発信パケットのチェックサムを格納し、（2）カーネルは、受信したパケットのチェックサムを検証しませんしませんを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: Since the checksum is always calculated by the kernel for an ICMPv6 socket, applications are not able to generate ICMPv6 packets with incorrect checksums (presumably for testing purposes) using this API.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：チェックサムは常にのICMPv6ソケットのカーネルによって計算されるので、アプリケーションはこのAPIを使用して、おそらくテスト目的のために間違ったチェックサム（）とのICMPv6パケットを生成することができません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. ICMPv6 Type Filtering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.  ICMPv6のタイプのフィルタリング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv4 raw sockets receive most ICMPv4 messages received by the kernel. (We say &#34;most&#34; and not &#34;all&#34; because Berkeley-derived kernels never pass echo requests, timestamp requests, or address mask requests to a raw socket. Instead these three messages are processed entirely by the kernel.) But ICMPv6 is a superset of ICMPv4, also including the functionality of IGMPv4 and ARPv4. This means that an ICMPv6 raw socket can potentially receive many more messages than would be received with an ICMPv4 raw socket: ICMP messages similar to ICMPv4, along with neighbor solicitations, neighbor advertisements, and the three group membership messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv4の生のソケットは、カーネルが受信したほとんどのICMPv4のメッセージを受信します。 （バークレー由来カーネルがrawソケットにエコー要求、タイムスタンプ要求、またはアドレスマスク要求を渡すことはありませんので、我々は。代わりに、これらの3件のメッセージがカーネルによって完全に処理されます。「すべて」「ほとんど」とされていないと言う）しかし、ICMPv6がスーパーセットでICMPv4のの、またIGMPv4とARPv4の機能を含みます。近隣要請、近隣広告、および3グループメンバーシップのメッセージとともに、ICMPv4のに似たICMPメッセージ：これはICMPv6の生のソケットが潜在的に多くのより多くのICMPv4生ソケットで受信されるよりもメッセージを受信できることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most applications using an ICMPv6 raw socket care about only a small subset of the ICMPv6 message types. To transfer extraneous ICMPv6 messages from the kernel to user can incur a significant overhead. Therefore this API includes a method of filtering ICMPv6 messages by the ICMPv6 type field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv6メッセージの種類の小さなサブセットのみについてのICMPv6 rawソケットのケアを使用してほとんどのアプリケーション。大きなオーバーヘッドが発生することができ、ユーザにカーネルから余分なICMPv6メッセージを転送します。したがって、このAPIはICMPv6のタイプフィールドでICMPv6メッセージをフィルタリングする方法を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ICMPv6 raw socket has an associated filter whose datatype is defined as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ICMPv6の生のソケットは、そのデータ型として定義されている関連するフィルタを有します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
struct icmp6_filter;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
構造体icmp6_filter。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure, along with the macros and constants defined later in this section, are defined as a result of including the &lt;netinet/icmp6.h&gt; header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、この節の後半で定義されたマクロおよび定数とともに、&lt;netinetの/ icmp6.h&gt;ヘッダを含むの結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filter is fetched and stored using getsockopt() and setsockopt() with a level of IPPROTO_ICMPV6 and an option name of ICMP6_FILTER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のフィルタは、フェッチとIPPROTO_ICMPV6のレベルとICMP6_FILTERのオプション名とのgetsockopt（）とのsetsockopt（）を使用して格納されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Six macros operate on an icmp6_filter structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シックス・マクロはicmp6_filter構造に動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       void ICMP6_FILTER_SETPASSALL (struct icmp6_filter *);
       void ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       void ICMP6_FILTER_SETPASS ( int, struct icmp6_filter *);
       void ICMP6_FILTER_SETBLOCK( int, struct icmp6_filter *);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int  ICMP6_FILTER_WILLPASS (int, const struct icmp6_filter *);
       int  ICMP6_FILTER_WILLBLOCK(int, const struct icmp6_filter *);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first argument to the last four macros (an integer) is an ICMPv6 message type, between 0 and 255. The pointer argument to all six macros is a pointer to a filter that is modified by the first four macros examined by the last two macros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の4つのマクロ（整数）の最初の引数は、0と255の間にすべての6つのマクロへのポインタ引数が最後の二つのマクロによって調べ、最初の4つのマクロによって変更されるフィルタへのポインタは、ICMPv6メッセージのタイプであります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first two macros, SETPASSALL and SETBLOCKALL, let us specify that all ICMPv6 messages are passed to the application or that all ICMPv6 messages are blocked from being passed to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の二つのマクロ、SETPASSALLとSETBLOCKALL、私たちはすべてのICMPv6メッセージがアプリケーションに渡されるか、すべてのICMPv6メッセージがアプリケーションに渡されてからブロックされていることをされていることを指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next two macros, SETPASS and SETBLOCK, let us specify that messages of a given ICMPv6 type should be passed to the application or not passed to the application (blocked).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の二つのマクロ、SETPASSとSETBLOCK、私たちは与えられたのICMPv6タイプのメッセージがアプリケーションに渡される、またはアプリケーション（ブロック）に渡されないべきであることを指定しましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final two macros, WILLPASS and WILLBLOCK, return true or false depending whether the specified message type is passed to the application or blocked from being passed to the application by the filter pointed to by the second argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の二つのマクロ、WILLPASSとWILLBLOCKは、指定されたメッセージタイプがアプリケーションに渡されるか、フィルタによってアプリケーションに渡されるから遮断されているかどうかをtrueまたはfalseを返すによって第二引数によって指さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an ICMPv6 raw socket is created, it will by default pass all ICMPv6 message types to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv6の生のソケットが作成されると、それはデフォルトでは、アプリケーションにすべてのICMPv6メッセージタイプを渡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, a program that wants to receive only router advertisements could execute the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例として、唯一のルータ広告を受信したい番組は、次のコマンドを実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
struct icmp6_filter myfilt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
構造体icmp6_filterのmyfilt。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
fd = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
FD =ソケット（PF_INET6、SOCK_RAW、IPPROTO_ICMPV6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
ICMP6_FILTER_SETBLOCKALL(&amp;myfilt);
ICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &amp;myfilt);
setsockopt(fd, IPPROTO_ICMPV6, ICMP6_FILTER, &amp;myfilt, sizeof(myfilt));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filter structure is declared and then initialized to block all messages types. The filter structure is then changed to allow router advertisement messages to be passed to the application and the filter is installed using setsockopt().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィルタ構造が宣言され、すべてのメッセージの種類をブロックするために初期化されます。フィルタ構造は、ルータ広告メッセージをアプリケーションに渡すことができるように変更され、フィルタは、（）のsetsockoptを使用してインストールされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The icmp6_filter structure is similar to the fd_set datatype used with the select() function in the sockets API. The icmp6_filter structure is an opaque datatype and the application should not care how it is implemented. All the application does with this datatype is allocate a variable of this type, pass a pointer to a variable of this type to getsockopt() and setsockopt(), and operate on a variable of this type using the six macros that we just defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
icmp6_filter構造は、ソケットAPIの選択（）関数で使用FD_SETデータ型と類似しています。 icmp6_filter構造は不透明なデータ型であり、アプリケーションは、それがどのように実装されるか気にしてはいけません。すべてのアプリケーションは、このデータ型で行い、この型の変数を割り当てる（GETSOCKOPTするために、この型の変数へのポインタを渡す）とのsetsockopt（）、と私たちは定義された6つのマクロを使用して、この型の変数を操作しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nevertheless, it is worth showing a simple implementation of this datatype and the six macros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、このデータ型の単純な実装と6つのマクロを示す価値があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
struct icmp6_filter {
  uint32_t  icmp6_filt[8];  /* 8*32 = 256 bits */
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define ICMP6_FILTER_WILLPASS(type, filterp) \ ((((filterp)-&gt;icmp6_filt[(type) &gt;&gt; 5]) &amp; (1 &lt;&lt; ((type) &amp; 31))) != 0) #define ICMP6_FILTER_WILLBLOCK(type, filterp) \ ((((filterp)-&gt;icmp6_filt[(type) &gt;&gt; 5]) &amp; (1 &lt;&lt; ((type) &amp; 31))) == 0) #define ICMP6_FILTER_SETPASS(type, filterp) \ ((((filterp)-&gt;icmp6_filt[(type) &gt;&gt; 5]) |= (1 &lt;&lt; ((type) &amp; 31)))) #define ICMP6_FILTER_SETBLOCK(type, filterp) \ ((((filterp)-&gt;icmp6_filt[(type) &gt;&gt; 5]) &amp;= ~(1 &lt;&lt; ((type) &amp; 31)))) #define ICMP6_FILTER_SETPASSALL(filterp) \ memset((filterp), 0xFF, sizeof(struct icmp6_filter)) #define ICMP6_FILTER_SETBLOCKALL(filterp) \ memset((filterp), 0, sizeof(struct icmp6_filter))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define ICMP6_FILTER_WILLPASS（タイプ、filterpは）\（（（（filterpは）！ - &gt; icmp6_filt [（タイプ）&gt;&gt; 5]）＆（1 &lt;&lt;（（タイプ）＆31）））= 0）の#define ICMP6_FILTER_WILLBLOCK（タイプ、filterpは）\（（（（filterpは） - &gt; icmp6_filt [（タイプ）&gt;&gt; 5]）＆（1 &lt;&lt;（（タイプ）＆31）））== 0）の#define ICMP6_FILTER_SETPASS（タイプ、filterpは）\（ （（（filterpは） - &gt; icmp6_filt [（タイプ）&gt;&gt; 5]）| =（1 &lt;&lt;（（タイプ）＆31））））の#define ICMP6_FILTER_SETBLOCK（タイプ、filterpは）\（（（（filterpは） - &gt; icmp6_filt [（タイプ）&gt;&gt; 5]）＆=〜（1 &lt;&lt;（（タイプ）＆31））））の#define ICMP6_FILTER_SETPASSALL（filterpは）\のmemset（（filterpは）、0xFFで、はsizeof（構造体icmp6_filter））の#define ICMP6_FILTER_SETBLOCKALL（filterpは）\ memsetの（（filterpは）、0、はsizeof（構造体icmp6_filter））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: These sample definitions have two limitations that an implementation may want to change. The first four macros evaluate their first argument two times. The second two macros require the inclusion of the &lt;string.h&gt; header for the memset() function.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：これらのサンプルの定義は、実装は、最初の4つのマクロは、その最初の引数を2回評価変更することを第2のマクロは&lt;string.hの&gt;ヘッダのmemset（）関数を含めることを必要とする2つの制限を有します。 ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Ancillary Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.補助データ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.2BSD allowed file descriptors to be transferred between separate processes across a UNIX domain socket using the sendmsg() and recvmsg() functions. Two members of the msghdr structure, msg_accrights and msg_accrightslen, were used to send and receive the descriptors. When the OSI protocols were added to 4.3BSD Reno in 1990 the names of these two fields in the msghdr structure were changed to msg_control and msg_controllen, because they were used by the OSI protocols for &#34;control information&#34;, although the comments in the source code call this &#34;ancillary data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.2BSDは、ファイル記述子がにsendmsg（）とのrecvmsg（）関数を使用して、UNIXドメインソケットを横切って別のプロセスとの間で転送することができました。 msghdr構造体の2人のメンバー、msg_accrightsとmsg_accrightslenは、ディスクリプタを送受信するために使用されました。 OSIプロトコルは、1990年に4.3BSDレノに添加したときに、ソースコード内のコメントが、それらは、「制御情報」のOSIプロトコルによって使用されたので、msghdr構造体におけるこれら二つのフィールドの名前は、msg_controlおよびmsg_controllenに変更しましたこの「補助データ」と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other than the OSI protocols, the use of ancillary data has been rare. In 4.4BSD, for example, the only use of ancillary data with IPv4 is to return the destination address of a received UDP datagram if the IP_RECVDSTADDR socket option is set. With Unix domain sockets ancillary data is still used to send and receive descriptors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSIプロトコル以外に、補助的なデータの使用は稀となっています。 4.4BSDでは、例えば、IPv4のと補助データの使用のみがIP_RECVDSTADDRソケットオプションが設定されている場合、受信したUDPデータグラムの宛先アドレスを返すことです。 Unixドメインソケットで補助データはまだ記述子を送受信するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nevertheless the ancillary data fields of the msghdr structure provide a clean way to pass information in addition to the data that is being read or written. The inclusion of the msg_control and msg_controllen members of the msghdr structure along with the cmsghdr structure that is pointed to by the msg_control member is required by the Posix.1g sockets API standard (which should be completed during 1997).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それでもmsghdr構造体の補助的なデータフィールドは、読み取りまたは書き込みが行われているデータの他に情報を渡すためにクリーンな方法を提供します。 msg_control部材によって指されるcmsghdr構造体と共にmsg_controlとmsghdr構造体のmsg_controllenメンバーを含めることは（1997の間に完了しなければならない）Posix.1gソケットAPI規格によって必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this document ancillary data is used to exchange the following optional information between the application and the kernel:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本書で補助データは、アプリケーションとカーネルとの間の次のオプションの情報を交換するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       1.  the send/receive interface and source/destination address,
       2.  the hop limit,
       3.  next hop address,
       4.  Hop-by-Hop options,
       5.  Destination options, and
       6.  Routing header.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before describing these uses in detail, we review the definition of the msghdr structure itself, the cmsghdr structure that defines an ancillary data object, and some functions that operate on the ancillary data objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
詳細にこれらの用途を説明する前に、我々はmsghdr構造体の定義自体、補助的なデータオブジェクトを定義するcmsghdr構造体、および補助的なデータオブジェクトを操作するいくつかの機能を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. The msghdr Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.  msghdr構造体
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The msghdr structure is used by the recvmsg() and sendmsg() functions. Its Posix.1g definition is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
msghdr構造体は、のrecvmsg（）とsendmsgの（）関数によって使用されます。そのPosix.1g定義は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct msghdr {
      void      *msg_name;        /* ptr to socket address structure */
      socklen_t  msg_namelen;     /* size of socket address structure */
      struct iovec  *msg_iov;     /* scatter/gather array */
      size_t     msg_iovlen;      /* # elements in msg_iov */
      void      *msg_control;     /* ancillary data */
      socklen_t  msg_controllen;  /* ancillary data buffer length */
      int        msg_flags;       /* flags on received message */
    };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The structure is declared as a result of including &lt;sys/socket.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体は&lt;sysの/ socket.h&gt;に含めた結果として宣言されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: Before Posix.1g the two &#34;void *&#34; pointers were typically &#34;char *&#34;, and the two socklen_t members and the size_t member were typically integers. Earlier drafts of Posix.1g had the two socklen_t members as size_t, but Draft 6.6 of Posix.1g, apparently the final draft, changed these to socklen_t to simplify binary portability for 64-bit implementations and to align Posix.1g with X/Open&#39;s Networking Services, Issue 5. The change in msg_control to a &#34;void *&#34; pointer affects any code that increments this pointer.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：。Posix.1g 2「void *型」のポインタは、典型的には、「char型*」だった、と2人のsocklen_tメンバーとsize_tのメンバーは、一般的に整数になる前Posix.1gの以前のドラフトはsize_tのように2人のsocklen_tメンバーを持っていたが、ドラフトPosix.1gの6.6、明らかに最終案は、64ビットの実装のためのバイナリポータビリティを簡素化し、X / OpenのネットワークサービスとのPosix.1gを整列させるのsocklen_tする「void *型」にmsg_controlの変化5.問題がこれらを変更しましたポインタは、このポインタをインクリメントするコードに影響を与えます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most Berkeley-derived implementations limit the amount of ancillary data in a call to sendmsg() to no more than 108 bytes (an mbuf). This API requires a minimum of 10240 bytes of ancillary data, but it is recommended that the amount be limited only by the buffer space reserved by the socket (which can be modified by the SO_SNDBUF socket option). (Note: This magic number 10240 was picked as a value that should always be large enough. 108 bytes is clearly too small as the maximum size of a Type 0 Routing header is 376 bytes.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最もバークレー由来の実装では、これ以上108バイト以内（MBUF）まで）（SENDMSG呼び出しにおける補助データの量を制限します。このAPIは、補助データの10240バイトの最小値を必要とするが、量が（SO_SNDBUFソケットオプションによって変更することができる）ソケットによって予約バッファ空間によってのみ制限されることが推奨されます。 （注：このマジックナンバー10240は、常に十分に大きくなければならない値として選ばれた108のバイトが明確に376バイトであり、タイプ0ルーティングヘッダの最大サイズが小さすぎます。）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. The cmsghdr Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.  cmsghdr構造体
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cmsghdr structure describes ancillary data objects transferred by recvmsg() and sendmsg(). Its Posix.1g definition is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsghdr構造体は、補助データのrecvmsgによって転送オブジェクト（）とsendmsgのを記述する（）。そのPosix.1g定義は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct cmsghdr {
      socklen_t  cmsg_len;   /* #bytes, including this header */
      int        cmsg_level; /* originating protocol */
      int        cmsg_type;  /* protocol-specific type */
                 /* followed by unsigned char cmsg_data[]; */
    };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is declared as a result of including &lt;sys/socket.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造体は、&lt;sysの/ socket.h&gt;に含めた結果として宣言されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As shown in this definition, normally there is no member with the name cmsg_data[]. Instead, the data portion is accessed using the CMSG_xxx() macros, as described shortly. Nevertheless, it is common to refer to the cmsg_data[] member.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この定義に示されているように、通常は[] CMSG_DATA名前のメンバが存在しません。すぐに記載されるように代わりに、データ部分は、CMSG_xxx（）マクロを使用してアクセスされます。それにもかかわらず、CMSG_DATA []メンバーを参照するのが一般的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: Before Posix.1g the cmsg_len member was an integer, and not a socklen_t. See the Note in the previous section for why socklen_t is used here.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注意：Posix.1g前CMSG_LENメンバーは、整数、およびないのsocklen_tたのsocklen_tがここで使用されている理由については、前のセクションでノートを参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When ancillary data is sent or received, any number of ancillary data objects can be specified by the msg_control and msg_controllen members of the msghdr structure, because each object is preceded by a cmsghdr structure defining the object&#39;s length (the cmsg_len member). Historically Berkeley-derived implementations have passed only one object at a time, but this API allows multiple objects to be passed in a single call to sendmsg() or recvmsg(). The following example shows two ancillary data objects in a control buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助データが送信または受信されたときに、各オブジェクトは、オブジェクトの長さを画定するcmsghdr構造体（CMSG_LEN部材​​）が先行しているため、補助データオブジェクトの任意の数は、msg_controlとmsghdr構造体のmsg_controllenメンバーで指定することができます。歴史的にはバークレー由来の実装は、一度に1つのオブジェクトに合格したが、このAPIは、複数のオブジェクトが（SENDMSGする単一の呼び出しに渡されることを可能にする）またはのrecvmsg（）。次の例では、制御バッファ内の2つの補助的なデータオブジェクトを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
|&lt;--------------------------- msg_controllen --------------------------&gt;|
|                                                                       |
|&lt;----- ancillary data object -----&gt;|&lt;----- ancillary data object -----&gt;|
|&lt;---------- CMSG_SPACE() ---------&gt;|&lt;---------- CMSG_SPACE() ---------&gt;|
|                                   |                                   |
|&lt;---------- cmsg_len ----------&gt;|  |&lt;--------- cmsg_len -----------&gt;|  |
|&lt;--------- CMSG_LEN() ---------&gt;|  |&lt;-------- CMSG_LEN() ----------&gt;|  |
|                                |  |                                |  |
+-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+
|cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|
|len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|
+-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+
 ^
 |
msg_control
points here
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fields shown as &#34;XX&#34; are possible padding, between the cmsghdr structure and the data, and between the data and the next cmsghdr structure, if required by the implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装によって必要とされる場合は、「XX」として表示されるフィールドは、cmsghdr構造体との間でデータ、及びデータと次のcmsghdr構造体との間に、可能パディングです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Ancillary Data Object Macros
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 補助データオブジェクトのマクロ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To aid in the manipulation of ancillary data objects, three macros from 4.4BSD are defined by Posix.1g: CMSG_DATA(), CMSG_NXTHDR(), and CMSG_FIRSTHDR(). Before describing these macros, we show the following example of how they might be used with a call to recvmsg().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助的なデータオブジェクトの操作を助けるために、4.4BSDからの3つのマクロがPosix.1gによって定義されています。CMSG_DATA（）、CMSG_NXTHDR（）、およびCMSG_FIRSTHDR（）。これらのマクロを説明する前に、我々は、彼らが（）をrecvmsgのための呼び出しで使用されるかもしれない方法の以下の例を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct msghdr   msg;
    struct cmsghdr  *cmsgptr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* fill in msg */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* call recvmsg() */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (cmsgptr = CMSG_FIRSTHDR(&amp;msg); cmsgptr != NULL;
         cmsgptr = CMSG_NXTHDR(&amp;msg, cmsgptr)) {
        if (cmsgptr-&gt;cmsg_level == ... &amp;&amp; cmsgptr-&gt;cmsg_type == ... ) {
            u_char  *ptr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            ptr = CMSG_DATA(cmsgptr);
            /* process data pointed to by ptr */
        }
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now describe the three Posix.1g macros, followed by two more that are new with this API: CMSG_SPACE() and CMSG_LEN(). All these macros are defined as a result of including &lt;sys/socket.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_SPACE（）とCMSG_LEN（）：私たちは、今、このAPIを使用して新しいある以上2に続く3つのPosix.1gマクロを記述します。すべてのこれらのマクロは、&lt;SYS / socket.h&gt;に含めた結果として定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. CMSG_FIRSTHDR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1.  CMSG_FIRSTHDR
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr *mhdr);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
構造体のcmsghdr * CMSG_FIRSTHDR（constの構造体のmsghdr * MHDR）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_FIRSTHDR() returns a pointer to the first cmsghdr structure in the msghdr structure pointed to by mhdr. The macro returns NULL if there is no ancillary data pointed to the by msghdr structure (that is, if either msg_control is NULL or if msg_controllen is less than the size of a cmsghdr structure).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_FIRSTHDR（）は、msghdr構造体の最初のcmsghdr構造体へのポインタは、MHDRによって指さ戻ります。 NULLマクロ戻るには補助データが存在しない場合（いずれかmsg_controlがNULLであるかmsg_controllen場合はcmsghdr構造体のサイズよりも小さい場合には、である）msghdr構造体によって指されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つの可能な実装は、可能性があり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       #define CMSG_FIRSTHDR(mhdr) \
           ( (mhdr)-&gt;msg_controllen &gt;= sizeof(struct cmsghdr) ? \
             (struct cmsghdr *)(mhdr)-&gt;msg_control : \
             (struct cmsghdr *)NULL )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: Most existing implementations do not test the value of msg_controllen, and just return the value of msg_control. The value of msg_controllen must be tested, because if the application asks recvmsg() to return ancillary data, by setting msg_control to point to the application&#39;s buffer and setting msg_controllen to the length of this buffer, the kernel indicates that no ancillary data is available by setting msg_controllen to 0 on return. It is also easier to put this test into this macro, than making the application perform the test.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：ほとんどの既存の実装がmsg_controllenの値をテストし、ちょうどmsg_controlの値を返しませんmsg_controllenの値をテストする必要があり、アプリケーションが指すようにmsg_controlを設定することにより、補助データを返すために（）のrecvmsgを要求した場合ので。アプリケーションのバッファと、このバッファの長さにmsg_controllenを設定するには、カーネルには補助データは、リターン時に0にmsg_controllenを設定することにより、利用できないことを示している。アプリケーションがテストを実行することよりも、このマクロにこのテストを置くことも簡単です。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. CMSG_NXTHDR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2.  CMSG_NXTHDR
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,
                                   const struct cmsghdr *cmsg);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_NXTHDR() returns a pointer to the cmsghdr structure describing the next ancillary data object. mhdr is a pointer to a msghdr structure and cmsg is a pointer to a cmsghdr structure. If there is not another ancillary data object, the return value is NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_NXTHDR（）は、次の補助データオブジェクトを記述したcmsghdr構造体へのポインタを返します。 MHDRはmsghdr構造体へのポインタであり、CMSGはcmsghdr構造体へのポインタです。別の補助的なデータオブジェクトが存在しない場合、戻り値はNULLです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following behavior of this macro is new to this API: if the value of the cmsg pointer is NULL, a pointer to the cmsghdr structure describing the first ancillary data object is returned. That is, CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr). If there are no ancillary data objects, the return value is NULL. This provides an alternative way of coding the processing loop shown earlier:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このマクロの次の動作は、このAPIの新しいですCMSGポインタの値がNULLの場合、最初の補助データオブジェクトを記述したcmsghdr構造体へのポインタが返されます。つまり、CMSG_NXTHDR（MHDR、NULL）がCMSG_FIRSTHDR（MHDR）に相当します。何の補助的なデータオブジェクトが存在しない場合、戻り値はNULLです。これは、先に示した処理ループを符号化する別の方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
struct msghdr  msg;
struct cmsghdr  *cmsgptr = NULL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* fill in msg */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* call recvmsg() */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
while ((cmsgptr = CMSG_NXTHDR(&amp;msg, cmsgptr)) != NULL) { if (cmsgptr-&gt;cmsg_level == ... &amp;&amp; cmsgptr-&gt;cmsg_type == ... ) { u_char *ptr;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
しばらく（！（cmsgptr = CMSG_NXTHDR（＆MSG、cmsgptr））= NULL）{場合（cmsgptr-&gt; cmsg_levelメンバ== ... &amp;&amp; cmsgptr-&gt; cmsg_type == ...）{u_char型の*のPTR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        ptr = CMSG_DATA(cmsgptr);
        /* process data pointed to by ptr */
    }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つの可能​​な実装は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
#define CMSG_NXTHDR(mhdr, cmsg) \ ( ((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \ (((u_char *)(cmsg) + ALIGN((cmsg)-&gt;cmsg_len) \ + ALIGN(sizeof(struct cmsghdr)) &gt; \ (u_char *)((mhdr)-&gt;msg_control) + (mhdr)-&gt;msg_controllen) ? \ (struct cmsghdr *)NULL : \ (struct cmsghdr *)((u_char *)(cmsg) + ALIGN((cmsg)-&gt;cmsg_len))) )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
#define CMSG_NXTHDR（MHDR、CMSG）\（（（CMSG）== NULL）CMSG_FIRSTHDR（MHDR）：？\（（（u_char型*）（CMSG）+ ALIGN（（CMSG） - &gt; CMSG_LEN）\ + ALIGN（はsizeof（構造体のcmsghdr））&gt; \（u_char型*）（（MHDR） - &gt; msg_control）+（MHDR） - &gt; msg_controllen）\（構造体のcmsghdr *）NULL：？\（構造体のcmsghdr *）（（u_char型*）（CMSG）+ ALIGN（（CMSG） - &gt; CMSG_LEN））））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macro ALIGN(), which is implementation dependent, rounds its argument up to the next even multiple of whatever alignment is required (probably a multiple of 4 or 8 bytes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装に依存してマクロALIGN（）は、必要とされるどのような位置合わせの次の偶数倍（4または8バイトのおそらく複数）までの引数を丸め。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3. CMSG_DATA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3.  CMSG_DATA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
unsigned char *CMSG_DATA(const struct cmsghdr *cmsg);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
unsigned char型* CMSG_DATA（constの構造体のcmsghdr *のCMSG）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_DATA() returns a pointer to the data (what is called the cmsg_data[] member, even though such a member is not defined in the structure) following a cmsghdr structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_DATA（）は、cmsghdr構造体以下（例えば、部材が構造体で定義されていない場合でも、CMSG_DATA []メンバーと呼ばれるもの）データへのポインタを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つの可能​​な実装は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       #define CMSG_DATA(cmsg) ( (u_char *)(cmsg) + \
                                 ALIGN(sizeof(struct cmsghdr)) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.4. CMSG_SPACE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.4.  CMSG_SPACE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
unsigned int CMSG_SPACE(unsigned int length);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
unsigned int型CMSG_SPACE（unsigned int型の長さ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This macro is new with this API. Given the length of an ancillary data object, CMSG_SPACE() returns the space required by the object and its cmsghdr structure, including any padding needed to satisfy alignment requirements. This macro can be used, for example, to allocate space dynamically for the ancillary data. This macro should not be used to initialize the cmsg_len member of a cmsghdr structure; instead use the CMSG_LEN() macro.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このマクロは、このAPIで新しく追加されました。補助データオブジェクトの長さが与えられ、CMSG_SPACE（）は、アライメント要件を満たすために必要なパディングを含むオブジェクトとそのcmsghdr構造体に必要なスペースを返します。このマクロは、補助データのための動的領域を割り当てる、例えば、使用することができます。このマクロは、cmsghdr構造体のCMSG_LENメンバを初期化するために使用すべきではありません。代わりCMSG_LEN（）マクロを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つの可能​​な実装は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       #define CMSG_SPACE(length) ( ALIGN(sizeof(struct cmsghdr)) + \
                                    ALIGN(length) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.5. CMSG_LEN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.5.  CMSG_LEN
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
unsigned int CMSG_LEN(unsigned int length);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
unsigned int型CMSG_LEN（unsigned int型の長さ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This macro is new with this API. Given the length of an ancillary data object, CMSG_LEN() returns the value to store in the cmsg_len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このマクロは、このAPIで新しく追加されました。補助データオブジェクトの長さが与えられ、CMSG_LEN（）は考慮アラインメント要件を満たすために必要なパディングを取って、cmsghdr構造体のCMSG_LENメンバに格納する値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible implementation could be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つの可能​​な実装は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       #define CMSG_LEN(length) ( ALIGN(sizeof(struct cmsghdr)) + length
       )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note the difference between CMSG_SPACE() and CMSG_LEN(), shown also in the figure in Section 4.2: the former accounts for any required padding at the end of the ancillary data object and the latter is the actual length to store in the cmsg_len member of the ancillary data object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助データオブジェクトの末尾に必要なパディングのために元のアカウントを、後者はCMSG_LENメンバーに格納する実際の長さ：4.2節の図にも示さCMSG_SPACE（）とCMSG_LEN（）との差を、注意してください補助的なデータオブジェクト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Summary of Options Described Using Ancillary Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. オプションの概要は、補助データを用いて説明しました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are six types of optional information described in this document that are passed between the application and the kernel using ancillary data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補助的なデータを使用して、アプリケーションとカーネルの間で渡され、この文書で説明するオプション情報の6種類があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       1.  the send/receive interface and source/destination address,
       2.  the hop limit,
       3.  next hop address,
       4.  Hop-by-Hop options,
       5.  Destination options, and
       6.  Routing header.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, to receive any of this optional information (other than the next hop address, which can only be set), the application must call setsockopt() to turn on the corresponding flag:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、この任意の情報のいずれか（のみ設定することができる次ホップアドレス以外）を受信するように、アプリケーションは、対応するフラグをオンにするのsetsockopt（）を呼び出す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int on = 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
= 1の整数;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       setsockopt(fd, IPPROTO_IPV6, IPV6_PKTINFO,  &amp;on, sizeof(on));
       setsockopt(fd, IPPROTO_IPV6, IPV6_HOPLIMIT, &amp;on, sizeof(on));
       setsockopt(fd, IPPROTO_IPV6, IPV6_HOPOPTS,  &amp;on, sizeof(on));
       setsockopt(fd, IPPROTO_IPV6, IPV6_DSTOPTS,  &amp;on, sizeof(on));
       setsockopt(fd, IPPROTO_IPV6, IPV6_RTHDR,    &amp;on, sizeof(on));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When any of these options are enabled, the corresponding data is returned as control information by recvmsg(), as one or more ancillary data objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのオプションのいずれかが有効な場合、対応するデータは、一つ以上の補助的なデータオブジェクトとして）のrecvmsg（の制御情報として返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nothing special need be done to send any of this optional information; the application just calls sendmsg() and specifies one or more ancillary data objects as control information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何も特別な必要性は、このオプションの情報のいずれかを送信するために行われます。アプリケーションだけにsendmsg（）を呼び出し、制御情報などの1つまたは複数の補助的なデータオブジェクトを特定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We also summarize the three cmsghdr fields that describe the ancillary data objects:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、補助的なデータオブジェクトを記述する3つのcmsghdrフィールドを要約したものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       cmsg_level    cmsg_type      cmsg_data[]               #times
       ------------  ------------   ------------------------  ------
       IPPROTO_IPV6  IPV6_PKTINFO   in6_pktinfo structure     once
       IPPROTO_IPV6  IPV6_HOPLIMIT  int                       once
       IPPROTO_IPV6  IPV6_NEXTHOP   socket address structure  once
       IPPROTO_IPV6  IPV6_HOPOPTS   implementation dependent  mult.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IPPROTO_IPV6 IPV6_DSTOPTS implementation dependent mult. IPPROTO_IPV6 IPV6_RTHDR implementation dependent once
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IPPROTO_IPV6は実装に依存MULTをIPV6_DSTOPTS。一度依存IPPROTO_IPV6 IPV6_RTHDR実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final column indicates how many times an ancillary data object of that type can appear as control information. The Hop-by-Hop and Destination options can appear multiple times, while all the others can appear only one time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の列は、そのタイプの補助データオブジェクトは、制御情報として表示することができる回数を示しています。他のすべては、一度だけを表示することができながら、バイホップホップと宛先オプションは、複数回表示されることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All these options are described in detail in following sections. All the constants beginning with IPV6_ are defined as a result of including the &lt;netinet/in.h&gt; header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのオプションはすべてのセクションを以下に詳細に記載されています。 IPV6_で始まるすべての定数は、&lt;netinetの/ in.h&gt;ヘッダを含めた結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: We intentionally use the same constant for the cmsg_level member as is used as the second argument to getsockopt() and setsockopt() (what is called the &#34;level&#34;), and the same constant for the cmsg_type member as is used as the third argument to getsockopt() and setsockopt() (what is called the &#34;option name&#34;). This is consistent with the existing use of ancillary data in 4.4BSD: returning the destination address of an IPv4 datagram.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用されるGETSOCKOPT第2の引数として使用される（我々が意図的cmsg_levelメンバ部材に同じ定数を使用）とのsetsockopt（）（「レベル」と呼ばれるもの）、およびcmsg_type部材に対して同じ定数（注第三GETSOCKOPTの引数（）と（「オプション名」と呼ばれるもの）のsetsockopt（）これは4.4BSDでの補助的なデータの既存の使用と一致している：。。のIPv4データグラムの宛先アドレスを返します）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: It is up to the implementation what it passes as ancillary data for the Hop-by-Hop option, Destination option, and Routing header option, since the API to these features is through a set of inet6_option_XXX() and inet6_rthdr_XXX() functions that we define later. These functions serve two purposes: to simplify the interface to these features (instead of requiring the application to know the intimate details of the extension header formats), and to hide the actual implementation from the application. Nevertheless, we show some examples of these features that store the actual extension header as the ancillary data. Implementations need not use this technique.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：それはホップバイホップオプション、宛先オプション、およびルーティング・ヘッダ・オプションと補助データを渡すもの実装に任されて、これらの機能のAPIはinet6_option_XXX（）とinet6_rthdr_XXXのセットを介してであるので（） 。我々は、後で定義する機能は、これらの機能は、2つの目的を果たす：それにもかかわらず（代わりに、拡張ヘッダフォーマットの親密な詳細を知るためのアプリケーションを必要とする）、これらの機能へのインタフェースを簡素化するために、アプリケーションからの実際の実装を隠すために、我々補助データとして実際の拡張ヘッダを格納し、これらの機能のいくつかの例を示す。実装は、この手法を使用する必要はありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. IPV6_PKTOPTIONS Socket Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.  IPV6_PKTOPTIONSソケットオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The summary in the previous section assumes a UDP socket. Sending and receiving ancillary data is easy with UDP: the application calls sendmsg() and recvmsg() instead of sendto() and recvfrom().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前節の概要はUDPソケットを前提としています。送信と補助データを受信すると、UDPと簡単です：アプリケーションの呼び出しにsendmsg（）とのrecvmsg（）の代わりのsendto（）とのrecvfrom（）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But there might be cases where a TCP application wants to send or receive this optional information. For example, a TCP client might want to specify a Routing header and this needs to be done before calling connect(). Similarly a TCP server might want to know the received interface after accept() returns along with any Destination options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、TCPアプリケーションは、このオプション情報を送信または受信したい場合があるかもしれません。たとえば、TCPクライアントは、ルーティングヘッダを指定したい場合があり、これは（）を呼び出す前に接続して行われる必要があります。同様にTCPサーバ）が後に（受け入れ受信したインターフェイスを知りたいかもしれない任意の宛先オプションと一緒に返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A new socket option is defined that provides access to the optional information described in the previous section, but without using recvmsg() and sendmsg(). Setting the socket option specifies any of the optional output fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいソケットオプションは、前のセクションで説明した任意の情報へのアクセスを提供し、その定義された、しかしのrecvmsg（）とにsendmsgを使用せずに（）されています。ソケットオプションを設定すると、オプションの出力フィールドのいずれかを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
setsockopt(fd, IPPROTO_IPV6, IPV6_PKTOPTIONS, &amp;buf, len);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
setsockopt（FD、IPPROTO_IPV6、IPV6_PKTOPTIONS、＆BUF、LEN）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fourth argument points to a buffer containing one or more ancillary data objects, and the fifth argument is the total length of all these objects. The application fills in this buffer exactly as if the buffer were being passed to sendmsg() as control information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つ以上の補助的なデータオブジェクトを含むバッファへの第四引数点、及び5番目の引数は、すべてのこれらのオブジェクトの長さの合計です。アプリケーションは、このバッファに正確に（）バッファがSENDMSGに渡されていたかのように制御情報として埋め。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The options set by calling setsockopt() for IPV6_PKTOPTIONS are called &#34;sticky&#34; options because once set they apply to all packets sent on that socket. The application can call setsockopt() again to change all the sticky options, or it can call setsockopt() with a length of 0 to remove all the sticky options for the socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一度設定し、彼らはそのソケット上で送信されるすべてのパケットに適用されますのでIPV6_PKTOPTIONSは、setsockopt（）を呼び出すことによって設定されたオプションは、「スティッキー」オプションと呼ばれています。アプリケーションは、すべてのスティッキーオプションを変更するために、再度のsetsockopt（）を呼び出すことができ、またはそれはソケットのすべてのスティッキオプションを除去するために、0の長さ（）のsetsockoptを呼び出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The corresponding receive option
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションを受け取る対応
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
getsockopt(fd, IPPROTO_IPV6, IPV6_PKTOPTIONS, &amp;buf, &amp;len);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
getsockopt（FD、IPPROTO_IPV6、IPV6_PKTOPTIONS、＆BUF、＆LEN）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
returns a buffer with one or more ancillary data objects for all the optional receive information that the application has previously specified that it wants to receive. The fourth argument points to the buffer that is filled in by the call. The fifth argument is a pointer to a value-result integer: when the function is called the integer specifies the size of the buffer pointed to by the fourth argument, and on return this integer contains the actual number of bytes that were returned. The application processes this buffer exactly as if the buffer were returned by recvmsg() as control information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションは、アプリケーションが以前にそれを受信したいことを指定した情報を受信するすべてのための一つ以上の補助的なデータオブジェクトでバッファを返します。四番目の引数は、呼び出しによって記入されたバッファを指しています。 5番目の引数の値結果整数へのポインタである：関数が呼び出されたとき整数バッファのサイズは、第四の引数によって指さ特定し、リターンに、この整数が戻された実際のバイト数を含んでいます。バッファは、制御情報としてのrecvmsg（）によって返された正確かのようにアプリケーション・プロセスのバッファ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To simplify this document, in the remaining sections when we say &#34;can be specified as ancillary data to sendmsg()&#34; we mean &#34;can be specified as ancillary data to sendmsg() or specified as a sticky option using setsockopt() and the IPV6_PKTOPTIONS socket option&#34;. Similarly when we say &#34;can be returned as ancillary data by recvmsg()&#34; we mean &#34;can be returned as ancillary data by recvmsg() or returned by getsockopt() with the IPV6_PKTOPTIONS socket option&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちが言うとき、残りのセクションでは、この文書を簡素化するために「SENDMSGする補助データ（）として指定することができ、」我々は「SENDMSGする補助データとして指定された（）またはのsetsockopt（）とIPV6_PKTOPTIONSを使用して粘着性のオプションとして指定することを意味しますソケットオプション」。私たちが言う場合も同様に「のrecvmsgによって補助データとして返すことができます（）」我々は意味「（のrecvmsgによって補助データとして返される）または（）IPV6_PKTOPTIONSソケットオプションでのgetsockoptで返すことができます」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. TCP Sticky Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1.  TCPスティッキーオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using getsockopt() with the IPV6_PKTOPTIONS option and a TCP socket, only the options from the most recently received segment are retained and returned to the caller, and only after the socket option has been set. That is, TCP need not start saving a copy of the options until the application says to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPV6_PKTOPTIONSオプションとTCPソケットでのgetsockopt（）を使用する場合は、最後に受信したセグメントからの唯一のオプションは保持され、呼び出し元に返され、ソケットオプションが設定された後にのみされています。これは、アプリケーションがそうするようにと言うまで、TCPは、オプションのコピーの保存を開始する必要はない、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application is not allowed to specify ancillary data in a call to sendmsg() on a TCP socket, and none of the ancillary data that we describe in this document is ever returned as control information by recvmsg() on a TCP socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPソケット上で）アプリケーションは、TCPソケット上）（SENDMSGへの呼び出しに補助データを指定することが許可されていない、と私たちは、この文書で説明する補助データのいずれも、これまでのrecvmsg（による制御情報として返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. UDP and Raw Socket Sticky Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2.  UDPと生ソケットスティッキーオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPV6_PKTOPTIONS socket option can also be used with a UDP socket or with a raw IPv6 socket, normally to set some of the options once, instead of with each call to sendmsg().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPV6_PKTOPTIONSソケットオプションも）一度、いくつかのオプションを設定し、代わりに（SENDMSGするために、各コールにするために、通常、UDPソケットまたは生のIPv6ソケットで使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike the TCP case, the sticky options can be overridden on a per-packet basis with ancillary data specified in a call to sendmsg() on a UDP or raw IPv6 socket. If any ancillary data is specified in a call to sendmsg(), none of the sticky options are sent with that datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPの場合とは異なり、粘着性のオプションは、UDPまたは生のIPv6ソケット上）（SENDMSGの呼び出しで指定された補助データをパケット単位で上書きすることができます。任意の補助データは、（）SENDMSGの呼び出しで指定されている場合は、粘着性のオプションのいずれもそのデータグラムで送信されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Packet Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.パケット情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are four pieces of information that an application can specify for an outgoing packet using ancillary data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、補助的なデータを使用して発信パケットに指定できる4件の情報があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       1.  the source IPv6 address,
       2.  the outgoing interface index,
       3.  the outgoing hop limit, and
       4.  the next hop address.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three similar pieces of information can be returned for a received packet as ancillary data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
情報の三つの同様の部分は補助的なデータとして受信したパケットのために返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       1.  the destination IPv6 address,
       2.  the arriving interface index, and
       3.  the arriving hop limit.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first two pieces of information are contained in an in6_pktinfo structure that is sent as ancillary data with sendmsg() and received as ancillary data with recvmsg(). This structure is defined as a result of including the &lt;netinet/in.h&gt; header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
情報の最初の2枚（）にsendmsgと補助データとして送信さin6_pktinfo構造に含まれ、（）のrecvmsgと補助データとして受信されます。この構造体は、&lt;netinetの/ in.h&gt;ヘッダを含むの結果として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct in6_pktinfo {
         struct in6_addr ipi6_addr;    /* src/dst IPv6 address */
         unsigned int    ipi6_ifindex; /* send/recv interface index */
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_PKTINFO, and the first byte of cmsg_data[] will be the first byte of the in6_pktinfo structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_PKTINFOなり、CMSG_DATAの最初のバイトは[] in6_pktinfo構造の最初のバイトであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This information is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_PKTINFO socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この情報は、アプリケーションがIPV6_PKTINFOソケットオプションを有効にしている場合のみ）（のrecvmsgによって補助データとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int  on = 1;
       setsockopt(fd, IPPROTO_IPV6, IPV6_PKTINFO, &amp;on, sizeof(on));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nothing special need be done to send this information: just specify the control information as ancillary data for sendmsg().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この情報を送信するために行うことは何も特別な必要性：ただsendmsgのための補助的なデータとして制御情報を指定します（）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: The hop limit is not contained in the in6_pktinfo structure for the following reason. Some UDP servers want to respond to client requests by sending their reply out the same interface on which the request was received and with the source IPv6 address of the reply equal to the destination IPv6 address of the request. To do this the application can enable just the IPV6_PKTINFO socket option and then use the received control information from recvmsg() as the outgoing control information for sendmsg(). The application need not examine or modify the in6_pktinfo structure at all. But if the hop limit were contained in this structure, the application would have to parse the received control information and change the hop limit member, since the received hop limit is not the desired value for an outgoing packet.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：ホップ限界は次の理由in6_pktinfo構造に含まれていないいくつかのUDPサーバは要求を受信したのと同じインターフェイスから、応答の送信元IPv6アドレスとその回答を送信することによって、クライアントの要求に応答します。リクエストの宛先IPv6アドレスに等しい。このアプリケーションだけIPV6_PKTINFOソケットオプションを有効にしてからは、sendmsg（の発信制御情報としてのrecvmsg（）から受信した制御情報を使用することができます行うには）。アプリケーションは、検査または変更する必要はありませんホップ限界がこの構造に含まれた場合in6_pktinfo構造は全く。しかし、アプリケーションは、受信したホップ限界は、発信パケットのための所望の値ではないので、受信した制御情報を解析し、ホップリミット部材を変更しなければなりません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Specifying/Receiving the Interface
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. インターフェイスの受信/指定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interfaces on an IPv6 node are identified by a small positive integer, as described in Section 4 of [RFC-2133]. That document also describes a function to map an interface name to its interface index, a function to map an interface index to its interface name, and a function to return all the interface names and indexes. Notice from this document that no interface is ever assigned an index of 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-2133]のセクション4で説明したようにIPv6ノード上のインタフェースは、小さな正の整数によって識別されます。その文書はまた、インタフェースインデックス、そのインタフェース名にインタフェースインデックスをマッピングする機能、およびすべてのインターフェイス名とインデックスを返す関数へのインターフェイス名をマッピングするための機能について説明します。何のインターフェースがこれまで0のインデックスが割り当てられていない、この文書から注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When specifying the outgoing interface, if the ipi6_ifindex value is 0, the kernel will choose the outgoing interface. If the application specifies an outgoing interface for a multicast packet, the interface specified by the ancillary data overrides any interface specified by the IPV6_MULTICAST_IF socket option (described in [RFC-2133]), for that call to sendmsg() only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信インターフェイスを指定する場合ipi6_ifindex値が0であれば、カーネルが発信インターフェイスを選択します。アプリケーションは、マルチキャストパケットの発信インターフェイスを指定している場合、補助データで指定されたインターフェイスのみ）（その呼び出しがSENDMSGするために、（[RFC-2133]に記載されている）IPV6_MULTICAST_IFソケットオプションで指定された任意のインターフェイスをオーバーライド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the IPV6_PKTINFO socket option is enabled, the received interface index is always returned as the ipi6_ifindex member of the in6_pktinfo structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPV6_PKTINFOソケットオプションが有効になっている場合、受信インタフェースインデックスは常にin6_pktinfo構造のipi6_ifindexメンバーとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Specifying/Receiving Source/Destination Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 指定受信/送信元/宛先アドレス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The source IPv6 address can be specified by calling bind() before each output operation, but supplying the source address together with the data requires less overhead (i.e., fewer system calls) and requires less state to be stored and protected in a multithreaded application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信元IPv6アドレスが各出力動作の前にバインド（）を呼び出すが、データと共にソースアドレスを供給することによって特定することができるが少ないオーバーヘッド（すなわち、より少ないシステムコール）を必要とし、記憶し、マルチスレッドのアプリケーションで保護されるべきより少ない状態を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When specifying the source IPv6 address as ancillary data, if the ipi6_addr member of the in6_pktinfo structure is the unspecified address (IN6ADDR_ANY_INIT), then (a) if an address is currently bound to the socket, it is used as the source address, or (b) if no address is currently bound to the socket, the kernel will choose the source address. If the ipi6_addr member is not the unspecified address, but the socket has already bound a source address, then the ipi6_addr value overrides the already-bound source address for this output operation only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in6_pktinfo構造のipi6_addr部材は、その後、不特定のアドレス（IN6ADDR_ANY_INIT）である場合、補助データとして送信元IPv6アドレスを指定するとき、アドレスが現在のソケットにバインドされている場合（A）には、送信元アドレスとして使用されるか、または（何のアドレスが現在のソケットにバインドされていない場合b）に、カーネルは、送信元アドレスを選択します。 ipi6_addrメンバーが未指定のアドレスではなく、ソケットがすでに元アドレスをバインドしている場合は、ipi6_addr値にのみ、この出力動作のためにすでに結合元アドレスを上書きします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The kernel must verify that the requested source address is indeed a unicast address assigned to the node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カーネルは、要求された送信元アドレスが実際にノードに割り当てられたユニキャストアドレスであることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the in6_pktinfo structure is returned as ancillary data by recvmsg(), the ipi6_addr member contains the destination IPv6 address from the received packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in6_pktinfo構造が）のrecvmsg（によって補助データとして返されるとき、ipi6_addr部材は、受信したパケットから宛先IPv6アドレスを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Specifying/Receiving the Hop Limit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. ホップ制限を受ける/指定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The outgoing hop limit is normally specified with either the IPV6_UNICAST_HOPS socket option or the IPV6_MULTICAST_HOPS socket option, both of which are described in [RFC-2133]. Specifying the hop limit as ancillary data lets the application override either the kernel&#39;s default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation. Returning the received hop limit is useful for programs such as Traceroute and for IPv6 applications that need to verify that the received hop limit is 255 (e.g., that the packet has not been forwarded).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-2133]に記載されている両方とも発信ホップ制限は、通常、IPV6_UNICAST_HOPSソケットオプションまたはIPV6_MULTICAST_HOPSソケットオプションのいずれかで指定されています。補助データは、アプリケーションが単一出力操作のために、ユニキャスト宛先またはマルチキャストの宛先のいずれかのために、カーネルのデフォルトまたは以前に指定した値のいずれかをオーバーライドすることができますようホップ制限を指定します。受信ホップ限界を返すことは、このようなトレースルートのようなプログラムおよび受信ホップ制限が255（例えば、パケットが転送されていないこと）であることを確認する必要があるIPv6アプリケーションに有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The received hop limit is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_HOPLIMIT socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信ホップ限界は、アプリケーションがIPV6_HOPLIMITソケットオプションを有効にしている場合のみ）（のrecvmsgによって補助データとして返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int  on = 1;
       setsockopt(fd, IPPROTO_IPV6, IPV6_HOPLIMIT, &amp;on, sizeof(on));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_HOPLIMIT, and the first byte of cmsg_data[] will be the first byte of the integer hop limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_HOPLIMITなり、CMSG_DATAの最初のバイト[]は整数ホップ限界の最初のバイトであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nothing special need be done to specify the outgoing hop limit: just specify the control information as ancillary data for sendmsg(). As specified in [RFC-2133], the interpretation of the integer hop limit value is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何も特別な必要性が出ホップ制限を指定するために行われる。ただsendmsgのための補助的なデータとして制御情報を指定します（）。 [RFC-2133]で指定されるように、整数ホップ限界値の解釈であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       x &lt; -1:        return an error of EINVAL
       x == -1:       use kernel default
       0 &lt;= x &lt;= 255: use x
       x &gt;= 256:      return an error of EINVAL
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Specifying the Next Hop Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. ネクストホップアドレスを指定します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPV6_NEXTHOP ancillary data object specifies the next hop for the datagram as a socket address structure. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_NEXTHOP, and the first byte of cmsg_data[] will be the first byte of the socket address structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPV6_NEXTHOP補助データオブジェクトは、ソケットアドレス構造体としてデータグラムのための次のホップを指定します。この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_NEXTHOPなり、CMSG_DATAの最初のバイト[]はソケットアドレス構造の最初のバイトであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a privileged option. (Note: It is implementation defined and beyond the scope of this document to define what &#34;privileged&#34; means. Unix systems use this term to mean the process must have an effective user ID of 0.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは特権オプションです。 （注：どのような「特権」の手段を定義するために、実装定義されており、このドキュメントの範囲を超えているUnixシステムは、プロセスを意味するためにこの用語を使用し、0の実効ユーザーIDを持っている必要があります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the socket address structure contains an IPv6 address (e.g., the sin6_family member is AF_INET6), then the node identified by that address must be a neighbor of the sending host. If that address equals the destination IPv6 address of the datagram, then this is equivalent to the existing SO_DONTROUTE socket option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソケットアドレス構造体（例えば、sin6_family部材がAF_INET6である）のIPv6アドレスが含まれている場合は、そのアドレスによって識別されるノードは、送信ホストの近隣でなければなりません。そのアドレスがデータグラムの宛先IPv6アドレスに等しい場合、これは、既存のSO_DONTROUTEソケットオプションに相当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Additional Errors with sendmsg()
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.  sendmsgのと追加のエラー（）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the IPV6_PKTINFO socket option there are no additional errors possible with the call to recvmsg(). But when specifying the outgoing interface or the source address, additional errors are possible from sendmsg(). The following are examples, but some of these may not be provided by some implementations, and some implementations may define additional errors:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPV6_PKTINFOソケットオプションで追加のエラーがrecvmsgの呼び出しで可能はありません（）。発信インターフェイスまたは送信元アドレスを指定する場合には、追加のエラーがsendmsgのから（）が可能です。以下は一例であり、これらのいくつかは、いくつかの実装によって提供されない場合があり、そしていくつかの実装形態は、追加のエラーを定義してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENXIO The interface specified by ipi6_ifindex does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENXIO ipi6_ifindexで指定されたインターフェイスは存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENETDOWN The interface specified by ipi6_ifindex is not enabled for IPv6 use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENETDOWN ipi6_ifindexで指定されたインターフェイスは、IPv6の使用が有効になっていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EADDRNOTAVAIL ipi6_ifindex specifies an interface but the address ipi6_addr is not available for use on that interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EADDRNOTAVAIL ipi6_ifindexインターフェイスを指定するが、アドレスipi6_addrは、そのインターフェイス上で使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EHOSTUNREACH No route to the destination exists over the interface specified by ifi6_ifindex.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EHOSTUNREACH宛先へのルートがifi6_ifindexによって指定されたインターフェイス上存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Hop-By-Hop Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.ホップバイホップオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A variable number of Hop-by-Hop options can appear in a single Hop-by-Hop options header. Each option in the header is TLV-encoded with a type, length, and value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホップバイホップオプションの可変数は、単一のホップバイホップオプションヘッダに現れることができます。ヘッダの各オプションは、タイプ、長さ、および値でTLVエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Today only three Hop-by-Hop options are defined for IPv6 [RFC-1883]: Jumbo Payload, Pad1, and PadN, although a proposal exists for a router-alert Hop-by-Hop option. The Jumbo Payload option should not be passed back to an application and an application should receive an error if it attempts to set it. This option is processed entirely by the kernel. It is indirectly specified by datagram-based applications as the size of the datagram to send and indirectly passed back to these applications as the length of the received datagram. The two pad options are for alignment purposes and are automatically inserted by a sending kernel when needed and ignored by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今日は3つだけのホップバイホップオプションは、[RFC-1883] IPv6のために定義されています：ジャンボペイロード、パッド1、及びパッドN、提案はルータアラートホップバイホップオプションのために存在するが。巨大ペイロードオプションは、アプリケーションに戻されるべきではない、それはそれを設定しようとした場合にアプリケーションがエラーを受け取る必要があります。このオプションは、カーネルによって完全に処理されます。これは間接的に送信するためのデータグラムのサイズなどのデータグラムベースのアプリケーションによって指定され、間接的に受信したデータグラムの長さとして、これらのアプリケーションに戻されます。 2つのパッドオプションは、アライメント目的としたものであり、必要とで無視するときに自動的に送信するカーネルによって挿入されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the receiving kernel. This section of the API is therefore defined for future Hop-by-Hop options that an application may need to specify and receive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信カーネル。 APIのこのセクションでは、したがって、アプリケーションが指定して受信する必要があり、将来のホップバイホップオプションのために定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Individual Hop-by-Hop options (and Destination options, which are described shortly, and which are similar to the Hop-by-Hop options) may have specific alignment requirements. For example, the 4-byte Jumbo Payload length should appear on a 4-byte boundary, and IPv6 addresses are normally aligned on an 8-byte boundary. These requirements and the terminology used with these options are discussed in Section 4.2 and Appendix A of [RFC-1883]. The alignment of each option is specified by two values, called x and y, written as &#34;xn + y&#34;. This states that the option must appear at an integer multiple of x bytes from the beginning of the options header (x can have the values 1, 2, 4, or 8), plus y bytes (y can have a value between 0 and 7, inclusive). The Pad1 and PadN options are inserted as needed to maintain the required alignment. Whatever code builds either a Hop-by-Hop options header or a Destination options header must know the values of x and y for each option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個々のホップバイホップオプション固有のアラインメント要件を有することができる（簡単に説明されており、及び宛先オプションは、ホップバイホップオプションと同様です）。例えば、4バイトのジャンボペイロード長は、4バイト境界上に表示され、そしてIPv6アドレスは、通常、8バイト境界で整列されています。これらの要件は、これらのオプションで使用される用語は、[RFC-1883]のセクション4.2および付録Aに記載されています。各オプションの整列は「XN + Y」と書かれたxとyと呼ばれる2つの値によって指定されます。このオプションは、オプションヘッダの先頭からxバイトの整数倍で現れなければならないと述べて、プラスYバイト（xは値1、2、4、または8を有することができる）（yは0と7の間の値を持つことができ、包括的）。必要な整列を維持するために必要に応じてパッド1およびパッドNオプションが挿入されています。どんなコードホップバイホップオプションヘッダまたは各オプションのxとyの値を知らなければならない宛先オプションヘッダのいずれかを構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple Hop-by-Hop options can be specified by the application. Normally one ancillary data object describes all the Hop-by-Hop options (since each option is itself TLV-encoded) but the application can specify multiple ancillary data objects for the Hop-by-Hop options, each object specifying one or more options. Care must be taken designing the API for these options since
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のホップバイホップオプションは、アプリケーションによって指定することができます。通常1つの補助データオブジェクトは、すべてのホップバイホップオプションを（各オプションは、それ自体であるため、TLVエンコード）について説明が、アプリケーションは、ホップバイホップオプションの1つ以上のオプションを指定する各オブジェクトを複数の補助データオブジェクトを指定することができます。ケアは、以来、これらのオプションのAPIを設計取られなければなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. it may be possible for some future Hop-by-Hop options to be generated by the application and processed entirely by the application (e.g., the kernel may not know the alignment restrictions for the option),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.それは（例えば、カーネルは、オプションの位置合わせの制約を知らないかもしれない）アプリケーションによって生成され、アプリケーションによって完全に処理されるいくつかの将来のホップバイホップオプションの可能性があり、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. it must be possible for the kernel to insert its own Hop-by-Hop options in an outgoing packet (e.g., the Jumbo Payload option),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.それは、発信パケットの独自のホップバイホップオプション（例えば、巨大ペイロードオプション）を挿入するために、カーネルのために可能でなければなりません、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. the application can place one or more Hop-by-Hop options into a single ancillary data object,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.アプリケーションは、単一の補助データオブジェクトに一つ以上のホップバイホップオプションを配置することができ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. if the application specifies multiple ancillary data objects, each containing one or more Hop-by-Hop options, the kernel must combine these a single Hop-by-Hop options header, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションはそれぞれ、1つまたは複数のホップバイホップオプションを含む、複数の補助データオブジェクトを指定する場合、カーネルは、これらを単一ホップバイホップオプションヘッダを結合しなければならない4、及び
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. it must be possible for the kernel to remove some Hop-by-Hop options from a received packet before returning the remaining Hop-by-Hop options to the application. (This removal might consist of the kernel converting the option into a pad option of the same length.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カーネルは、アプリケーションに残りのホップバイホップオプションを返す前に、受信したパケットから、いくつかのホップバイホップオプションを削除する5.ことが可能でなければなりません。 （この除去は、同じ長さのパッドオプションにオプションを変換カーネルから成るかもしれません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, we note that access to some Hop-by-Hop options or to some Destination options, might require special privilege. That is, normal applications (without special privilege) might be forbidden from setting certain options in outgoing packets, and might never see certain options in received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、我々はいくつかのホップバイホップオプションまたはいくつかの宛先オプションへのアクセスは、特別な権限を必要とするかもしれないことに注意してください。それは、（特別な権限なし）通常のアプリケーションでは、発信パケットで特定のオプションを設定することが禁止される可能性がありますされ、受信したパケットで特定のオプションを見ることはないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Receiving Hop-by-Hop Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. ホップバイホップオプションを受け取ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To receive Hop-by-Hop options the application must enable the IPV6_HOPOPTS socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホップバイホップオプションを受信するにはアプリケーションがIPV6_HOPOPTSソケットオプションを有効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int  on = 1;
       setsockopt(fd, IPPROTO_IPV6, IPV6_HOPOPTS, &amp;on, sizeof(on));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All the Hop-by-Hop options are returned as one ancillary data object described by a cmsghdr structure. The cmsg_level member will be IPPROTO_IPV6 and the cmsg_type member will be IPV6_HOPOPTS. These options are then processed by calling the inet6_option_next() and inet6_option_find() functions, described shortly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのホップバイホップオプションは、cmsghdr構造体によって説明したもの補助データオブジェクトとして返されます。 cmsg_levelメンバのメンバはIPPROTO_IPV6になり、cmsg_typeメンバーはIPV6_HOPOPTSになります。これらのオプションは、その後まもなく説明し、inet6_option_next（）とinet6_option_find（）関数を呼び出すことによって処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Sending Hop-by-Hop Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. ホップバイホップオプションを送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To send one or more Hop-by-Hop options, the application just specifies them as ancillary data in a call to sendmsg(). No socket option need be set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つ以上のホップバイホップオプションを送信するには、アプリケーションがちょうどSENDMSGへの呼び出しで補助的なデータとしてそれらを指定します（）。いいえソケットオプションを設定する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Normally all the Hop-by-Hop options are specified by a single ancillary data object. Multiple ancillary data objects, each containing one or more Hop-by-Hop options, can also be specified, in which case the kernel will combine all the Hop-by-Hop options into a single Hop-by-Hop extension header. But it should be more efficient to use a single ancillary data object to describe all the Hop-by-Hop options. The cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_HOPOPTS. The option is normally constructed using the inet6_option_init(), inet6_option_append(), and inet6_option_alloc() functions, described shortly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、すべてのホップバイホップオプションは、単一の補助データオブジェクトで指定されています。複数の補助的なデータオブジェクトは、それぞれ含有する1つ以上のホップバイホップオプションは、また、その場合、カーネルは単一ホップバイホップ拡張ヘッダにすべてのホップバイホップオプションを組み合わせるので、特定することができます。しかし、すべてのホップバイホップオプションを記述するために、単一の補助的なデータオブジェクトを使用する方が効率的でなければなりません。 cmsg_levelメンバメンバーはIPPROTO_IPV6に設定され、cmsg_typeメンバーはIPV6_HOPOPTSに設定されています。オプションは、通常、簡単に説明inet6_option_init（）、inet6_option_append（）、及びinet6_option_alloc（）関数を使用して構築されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional errors may be possible from sendmsg() if the specified option is in error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたオプションにエラーがある場合は、追加のエラーは）（にsendmsgから可能かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Hop-by-Hop and Destination Options Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. ホップバイホップと宛先のオプション処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Building and parsing the Hop-by-Hop and Destination options is complicated for the reasons given earlier. We therefore define a set of functions to help the application. The function prototypes for these functions are all in the &lt;netinet/in.h&gt; header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビルやバイホップホップと宛先オプションを解析するには、先に与えられた理由のために複雑です。したがって、我々は、アプリケーションを支援するための関数のセットを定義します。これらの関数の関数プロトタイプは&lt;netinetの/ in.h&gt;ヘッダ内の全てです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. inet6_option_space
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.  inet6_option_space
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int inet6_option_space(int nbytes);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int型inet6_option_space（int型でnbytes）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function returns the number of bytes required to hold an option when it is stored as ancillary data, including the cmsghdr structure at the beginning, and any padding at the end (to make its size a multiple of 8 bytes). The argument is the size of the structure defining the option, which must include any pad bytes at the beginning (the value y in the alignment term &#34;xn + y&#34;), the type byte, the length byte, and the option data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機能は、それが最初にcmsghdr構造体、及び終了時に任意のパディング（サイズ8バイトの倍数にするため）を含む補助データとして記憶されているオプションを保持するために必要なバイト数を返します。引数は、初めに、任意のパッドバイト（アライメント用語「XN + Y」の値y）、型バイト、長さバイト、及びオプションデータを含める必要がありますオプションを定義する構造体のサイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: If multiple options are stored in a single ancillary data object, which is the recommended technique, this function overestimates the amount of space required by the size of N-1 cmsghdr structures, where N is the number of options to be stored in the object. This is of little consequence, since it is assumed that most Hop-by-Hop option headers and Destination option headers carry only one option (p. 33 of [RFC-1883]).)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：複数のオプションを推奨技術である単一の補助データオブジェクトに格納されている場合、この関数はNをに格納するオプションの数であるN-1のcmsghdr構造のサイズによって必要なスペースの量を過大評価オブジェクト。最もホップバイホップオプションヘッダと宛先オプションヘッダは、一つだけのオプション（[RFC-1883]のP 33）を搬送することを想定しているので、これは、ほとんど重要ではありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. inet6_option_init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.  inet6_option_init
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int inet6_option_init(void *bp, struct cmsghdr **cmsgp, int
       type);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function is called once per ancillary data object that will contain either Hop-by-Hop or Destination options. It returns 0 on success or -1 on an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機能は含まれています補助的なデータオブジェクトごとに一度と呼ばれているいずれかのホップバイホップもしくは宛先オプション。これは、エラーの場合は-1成功すると0を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bp is a pointer to previously allocated space that will contain the ancillary data object. It must be large enough to contain all the individual options to be added by later calls to inet6_option_append() and inet6_option_alloc().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BPは補助的なデータオブジェクトが含まれています以前に割り当てられた領域へのポインタです。 （）とinet6_option_alloc（）をinet6_option_appendし、後で呼び出しによって追加されるすべての個々のオプションを含むのに十分な大きさでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsgp is a pointer to a pointer to a cmsghdr structure. *cmsgp is initialized by this function to point to the cmsghdr structure constructed by this function in the buffer pointed to by bp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsgpはcmsghdr構造体へのポインタへのポインタです。 * cmsgpは、緩衝液中で、この機能によって構築cmsghdr構造体を指すように、この関数によって初期化され、BPによって指さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type is either IPV6_HOPOPTS or IPV6_DSTOPTS. This type is stored in the cmsg_type member of the cmsghdr structure pointed to by *cmsgp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプはIPV6_HOPOPTSかIPV6_DSTOPTSのいずれかです。 cmsghdr構造体のcmsg_typeメンバに格納されているこのタイプは、* cmsgpによって指されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3. inet6_option_append
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3.  inet6_option_append
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int inet6_option_append(struct cmsghdr *cmsg, const uint8_t *typep,
                               int multx, int plusy);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function appends a Hop-by-Hop option or a Destination option into an ancillary data object that has been initialized by inet6_option_init(). This function returns 0 if it succeeds or -1 on an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、inet6_option_init（）によって初期化された補助的なデータオブジェクトにホップバイホップオプションまたはデスティネーションオプションを追加します。それが成功した場合や、エラー時に-1この関数は0を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsg is a pointer to the cmsghdr structure that must have been initialized by inet6_option_init().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSGはinet6_option_initによって初期化（）されている必要がありますcmsghdr構造体へのポインタです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typep is a pointer to the 8-bit option type. It is assumed that this field is immediately followed by the 8-bit option data length field, which is then followed immediately by the option data. The caller initializes these three fields (the type-length-value, or TLV) before calling this function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typepは、8ビットのオプションタイプへのポインタです。なお、このフィールドは直ちに、オプションデータが直ちに続く8ビットのオプションデータ長フィールド、続いているものとします。呼び出し側は、この関数を呼び出す前に、これらの三つのフィールド（タイプ - 長さ - 値、またはTLV）を初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The option type must have a value from 2 to 255, inclusive. (0 and 1 are reserved for the Pad1 and PadN options, respectively.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションタイプは、包括的、2から255までの値を持つ必要があります。 （0と1は、それぞれ、パッド1およびパッドNオプションのために予約されています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The option data length must have a value between 0 and 255, inclusive, and is the length of the option data that follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションのデータ長は、0〜255の値を持つ包括的、かつ以下のオプションデータの長さである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
multx is the value x in the alignment term &#34;xn + y&#34; described earlier. It must have a value of 1, 2, 4, or 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
multxは、前述の配向用語「XN + Y」の値xです。これは、1、2、4、または8の値を有していなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
plusy is the value y in the alignment term &#34;xn + y&#34; described earlier. It must have a value between 0 and 7, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
plusyは、前述の配向用語「XN + Y」の値yです。これは、0から7までの値を持つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4. inet6_option_alloc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4.  inet6_option_alloc
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       uint8_t *inet6_option_alloc(struct cmsghdr *cmsg, int datalen,
                                    int multx, int plusy);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function appends a Hop-by-Hop option or a Destination option into an ancillary data object that has been initialized by inet6_option_init(). This function returns a pointer to the 8-bit option type field that starts the option on success, or NULL on an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、inet6_option_init（）によって初期化された補助的なデータオブジェクトにホップバイホップオプションまたはデスティネーションオプションを追加します。この関数は、成功、エラー時にNULLのオプションを開始し、8ビットのオプションタイプフィールドへのポインタを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The difference between this function and inet6_option_append() is that the latter copies the contents of a previously built option into the ancillary data object while the current function returns a pointer to the space in the data object where the option&#39;s TLV must then be built by the caller.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の機能は、オプションのTLVは、それまでに構築されなければならないデータ・オブジェクト内の空間へのポインタを返すときにこの機能とinet6_option_append（差）は、補助的なデータオブジェクトに後者をコピーすることを以前に構築されたオプションの内容であります呼び出し側。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsg is a pointer to the cmsghdr structure that must have been initialized by inet6_option_init().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSGはinet6_option_initによって初期化（）されている必要がありますcmsghdr構造体へのポインタです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
datalen is the value of the option data length byte for this option. This value is required as an argument to allow the function to determine if padding must be appended at the end of the option. (The inet6_option_append() function does not need a data length argument since the option data length must already be stored by the caller.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
datalenを、このオプションのオプションデータ長バイトの値です。この値は、パディングはオプションの最後に追加されなければならない場合、この関数が決定できるようにするの引数として必要とされます。 （オプションのデータ長がすでに呼び出し側によって保存されなければならないのでinet6_option_append（）関数は、データ長引数を必要としません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
multx is the value x in the alignment term &#34;xn + y&#34; described earlier. It must have a value of 1, 2, 4, or 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
multxは、前述の配向用語「XN + Y」の値xです。これは、1、2、4、または8の値を有していなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
plusy is the value y in the alignment term &#34;xn + y&#34; described earlier. It must have a value between 0 and 7, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
plusyは、前述の配向用語「XN + Y」の値yです。これは、0から7までの値を持つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.5. inet6_option_next
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.5.  inet6_option_next
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int inet6_option_next(const struct cmsghdr *cmsg, uint8_t
       **tptrp);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function processes the next Hop-by-Hop option or Destination option in an ancillary data object. If another option remains to be processed, the return value of the function is 0 and *tptrp points to the 8-bit option type field (which is followed by the 8-bit option data length, followed by the option data). If no more options remain to be processed, the return value is -1 and *tptrp is NULL. If an error occurs, the return value is -1 and *tptrp is not NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機能は、補助的なデータオブジェクト内の次のホップバイホップオプションまたはデスティネーションオプションを処理します。別のオプションが処理されないままである場合、関数の戻り値は0と*（オプションデータに続く8ビットのオプションデータ長が続く）8ビットのオプションタイプフィールドにtptrpポイント。これ以上のオプションが処理されずに残っていない場合、戻り値は-1で、* tptrpはNULLです。エラーが発生した場合、戻り値は-1で、* tptrpはNULLではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsg is a pointer to cmsghdr structure of which cmsg_level equals IPPROTO_IPV6 and cmsg_type equals either IPV6_HOPOPTS or IPV6_DSTOPTS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSGはcmsg_levelメンバはIPPROTO_IPV6に等しく、cmsg_typeがIPV6_HOPOPTS又はIPV6_DSTOPTSのいずれかに等しいの構造をのcmsghdrへのポインタです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tptrp is a pointer to a pointer to an 8-bit byte and *tptrp is used by the function to remember its place in the ancillary data object each time the function is called. The first time this function is called for a given ancillary data object, *tptrp must be set to NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tptrpは8ビットのバイトへのポインタへのポインタで、* tptrpは補助的なデータオブジェクトに関数が呼び出されるたびにその場所を覚えておく機能で使用されます。この関数は、与えられた補助的なデータオブジェクトに対して初めて呼び出されたときには、* tptrpはNULLに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each time this function returns success, *tptrp points to the 8-bit option type field for the next option to be processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数が成功を返すたびに、*次のオプションの8ビットのオプションタイプフィールドにtptrpポイントが処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.6. inet6_option_find
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.6.  inet6_option_find
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int inet6_option_find(const struct cmsghdr *cmsg, uint8_t *tptrp,
                             int type);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function is similar to the previously described inet6_option_next() function, except this function lets the caller specify the option type to be searched for, instead of always returning the next option in the ancillary data object. cmsg is a pointer to cmsghdr structure of which cmsg_level equals IPPROTO_IPV6 and cmsg_type equals either IPV6_HOPOPTS or IPV6_DSTOPTS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機能は、発信者がオプションタイプを検索するように指定でき除き、この関数は常に補助データオブジェクト内の次のオプションを返すのではなく、前述のinet6_option_next（）関数に似ています。 CMSGはcmsg_levelメンバはIPPROTO_IPV6に等しく、cmsg_typeがIPV6_HOPOPTS又はIPV6_DSTOPTSのいずれかに等しいの構造をのcmsghdrへのポインタです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tptrp is a pointer to a pointer to an 8-bit byte and *tptrp is used by the function to remember its place in the ancillary data object each time the function is called. The first time this function is called for a given ancillary data object, *tptrp must be set to NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tptrpは8ビットのバイトへのポインタへのポインタで、* tptrpは補助的なデータオブジェクトに関数が呼び出されるたびにその場所を覚えておく機能で使用されます。この関数は、与えられた補助的なデータオブジェクトに対して初めて呼び出されたときには、* tptrpはNULLに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function starts searching for an option of the specified type beginning after the value of *tptrp. If an option of the specified type is located, this function returns 0 and *tptrp points to the 8- bit option type field for the option of the specified type. If an option of the specified type is not located, the return value is -1 and *tptrp is NULL. If an error occurs, the return value is -1 and *tptrp is not NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、* tptrpの値より後に開始する指定されたタイプのオプションのために検索を開始します。指定されたタイプのオプションが配置されている場合、この関数は、指定されたタイプのオプションの8ビットのオプションタイプフィールドに0と* tptrpポイントを返します。指定されたタイプのオプションが配置されていない場合、戻り値は-1で、* tptrpはNULLです。エラーが発生した場合、戻り値は-1で、* tptrpはNULLではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.7. Options Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.7. オプションの例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now provide an example that builds two Hop-by-Hop options. First we define two options, called X and Y, taken from the example in Appendix A of [RFC-1883]. We assume that all options will have structure definitions similar to what is shown below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは今、2ホップバイホップオプションを構築する例を提供します。まず、[RFC-1883]の付録Aの例から採取されたXとYと呼ばれる2つのオプションを定義します。我々は、すべてのオプションを示しているものと同様の構造の定義を持っていることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /* option X and option Y are defined in [RFC-1883], pp. 33-34 */
#define IP6_X_OPT_TYPE       X   /* replace X with assigned value */
#define IP6_X_OPT_LEN       12
#define IP6_X_OPT_MULTX      8   /* 8n + 2 alignment */
#define IP6_X_OPT_OFFSETY    2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
struct ip6_X_opt {
  uint8_t   ip6_X_opt_pad[IP6_X_OPT_OFFSETY];
  uint8_t   ip6_X_opt_type;
  uint8_t   ip6_X_opt_len;
  uint32_t  ip6_X_opt_val1;
  uint64_t  ip6_X_opt_val2;
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define IP6_Y_OPT_TYPE       Y   /* replace Y with assigned value */
#define IP6_Y_OPT_LEN        7
#define IP6_Y_OPT_MULTX      4   /* 4n + 3 alignment */
#define IP6_Y_OPT_OFFSETY    3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
struct ip6_Y_opt {
  uint8_t   ip6_Y_opt_pad[IP6_Y_OPT_OFFSETY];
  uint8_t   ip6_Y_opt_type;
  uint8_t   ip6_Y_opt_len;
  uint8_t   ip6_Y_opt_val1;
  uint16_t  ip6_Y_opt_val2;
  uint32_t  ip6_Y_opt_val3;
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now show the code fragment to build one ancillary data object containing both options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは今、両方のオプションを含む1つの補助的なデータオブジェクトを構築するために、コードのフラグメントを示しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
struct msghdr  msg;
struct cmsghdr  *cmsgptr;
struct ip6_X_opt  optX;
struct ip6_Y_opt  optY;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
msg.msg_control = malloc(inet6_option_space(sizeof(optX) + sizeof(optY)));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
msg.msg_control = malloc関数（inet6_option_space（のsizeof（OPTX）+はsizeof（optY）））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
inet6_option_init(msg.msg_control, &amp;cmsgptr, IPV6_HOPOPTS);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
inet6_option_init（msg.msg_control、＆cmsgptr、IPV6_HOPOPTS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
optX.ip6_X_opt_type = IP6_X_OPT_TYPE;
optX.ip6_X_opt_len  = IP6_X_OPT_LEN;
optX.ip6_X_opt_val1 = &lt;32-bit value&gt;;
optX.ip6_X_opt_val2 = &lt;64-bit value&gt;;
inet6_option_append(cmsgptr, &amp;optX.ip6_X_opt_type,
                    IP6_X_OPT_MULTX, IP6_X_OPT_OFFSETY);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
optY.ip6_Y_opt_type = IP6_Y_OPT_TYPE;
optY.ip6_Y_opt_len  = IP6_Y_OPT_LEN;
optY.ip6_Y_opt_val1 = &lt;8-bit value&gt;;
optY.ip6_Y_opt_val2 = &lt;16-bit value&gt;;
optY.ip6_Y_opt_val3 = &lt;32-bit value&gt;;
inet6_option_append(cmsgptr, &amp;optY.ip6_Y_opt_type,
                    IP6_Y_OPT_MULTX, IP6_Y_OPT_OFFSETY);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
msg.msg_controllen = cmsgptr-&gt;cmsg_len;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
msg.msg_controllen = cmsgptr-&gt; CMSG_LEN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The call to inet6_option_init() builds the cmsghdr structure in the control buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_option_init（）の呼び出しは、制御バッファにおけるcmsghdr構造体を構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_len = CMSG_LEN(0) = 12                             |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_level = IPPROTO_IPV6                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_type = IPV6_HOPOPTS                                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here we assume a 32-bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4-byte boundaries (that is, the ALIGN() macro shown in the sample implementations of the CMSG_xxx() macros rounds up to a multiple of 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、4バイト境界の所望の配向（すなわち、（CMSG_xxxの実装例に示すALIGN（）マクロで）マクロは、最大ラウンドではsizeof（構造体のcmsghdr）が12に等しい32ビットのアーキテクチャを想定し4の倍数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first call to inet6_option_append() appends the X option. Since this is the first option in the ancillary data object, 2 bytes are allocated for the Next Header byte and for the Hdr Ext Len byte. The former will be set by the kernel, depending on the type of header that follows this header, and the latter byte is set to 1. These 2 bytes form the 2 bytes of padding (IP6_X_OPT_OFFSETY) required at the beginning of this option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_option_appendする最初の呼び出しは（）Xオプションを追加します。これは補助データオブジェクトの最初のオプションであるため、2つのバイトは次ヘッダーバイトおよびHDR拡張レンバイトに割り当てられます。前者は、このヘッダに続くヘッダのタイプに応じて、カーネルによって設定され、後者のバイトは、これらの2つのバイトは、このオプションの先頭に必要なパディング（IP6_X_OPT_OFFSETY）の2つのバイトを形成する1に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_len = 28                                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_level = IPPROTO_IPV6                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_type = IPV6_HOPOPTS                                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         4-octet field                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     +                         8-octet field                         +
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cmsg_len member of the cmsghdr structure is incremented by 16, the size of the option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cmsghdr構造体のCMSG_LEN部材​​16、オプションのサイズだけインクリメントされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next call to inet6_option_append() appends the Y option to the ancillary data object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_option_appendする次の呼び出しは（）補助的なデータオブジェクトにYオプションを付加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_len = 44                                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_level = IPPROTO_IPV6                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_type = IPV6_HOPOPTS                                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  Next Header  | Hdr Ext Len=3 | Option Type=X |Opt Data Len=12|
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         4-octet field                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     +                         8-octet field                         +
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     | PadN Option=1 |Opt Data Len=1 |       0       | Option Type=Y |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |Opt Data Len=7 | 1-octet field |         2-octet field         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         4-octet field                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     | PadN Option=1 |Opt Data Len=2 |       0       |       0       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16 bytes are appended by this function, so cmsg_len becomes 44. The inet6_option_append() function notices that the appended data requires 4 bytes of padding at the end, to make the size of the ancillary data object a multiple of 8, and appends the PadN option before returning. The Hdr Ext Len byte is incremented by 2 to become 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CMSG_LENは添付データが補助データのサイズが8の倍数オブジェクト作るために、最後のパディングの4つのバイトを必要とする44 inet6_option_append（）関数の通知となるように16のバイトは、この機能が付加されており、パッドNが追加します戻る前に、オプションを選択します。 HDRのExtレンバイトが3になるために2ずつ増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternately, the application could build two ancillary data objects, one per option, although this will probably be less efficient than combining the two options into a single ancillary data object (as just shown). The kernel must combine these into a single Hop-by-Hop extension header in the final IPv6 packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ちょうど示されるように）、これはおそらく単一の補助データオブジェクトに二つのオプションを組み合わせるよりも効率であろうが、交互に、アプリケーションは二つの補助的なデータオブジェクト、オプション1つずつ構築できます。カーネルは、最終的なIPv6パケット内の単一のホップバイホップ拡張ヘッダにこれらを結合しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct msghdr  msg;
       struct cmsghdr  *cmsgptr;
       struct ip6_X_opt  optX;
       struct ip6_Y_opt  optY;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
msg.msg_control = malloc(inet6_option_space(sizeof(optX)) + inet6_option_space(sizeof(optY)));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
msg.msg_control = malloc関数（inet6_option_space（のsizeof（OPTX））+ inet6_option_space（のsizeof（optY）））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
inet6_option_init(msg.msg_control, &amp;cmsgptr, IPPROTO_HOPOPTS);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
inet6_option_init（msg.msg_control、＆cmsgptr、IPPROTO_HOPOPTS）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
optX.ip6_X_opt_type = IP6_X_OPT_TYPE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
optX.ip6_X_opt_type = IP6_X_OPT_TYPE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       optX.ip6_X_opt_len  = IP6_X_OPT_LEN;
       optX.ip6_X_opt_val1 = &lt;32-bit value&gt;;
       optX.ip6_X_opt_val2 = &lt;64-bit value&gt;;
       inet6_option_append(cmsgptr, &amp;optX.ip6_X_opt_type,
                           IP6_X_OPT_MULTX, IP6_X_OPT_OFFSETY);
       msg.msg_controllen = CMSG_SPACE(sizeof(optX));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
inet6_option_init((u_char *)msg.msg_control + msg.msg_controllen, &amp;cmsgptr, IPPROTO_HOPOPTS);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
inet6_option_init（（u_char型*）+ msg.msg_control msg.msg_controllen、＆cmsgptr、IPPROTO_HOPOPTS）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       optY.ip6_Y_opt_type = IP6_Y_OPT_TYPE;
       optY.ip6_Y_opt_len  = IP6_Y_OPT_LEN;
       optY.ip6_Y_opt_val1 = &lt;8-bit value&gt;;
       optY.ip6_Y_opt_val2 = &lt;16-bit value&gt;;
       optY.ip6_Y_opt_val3 = &lt;32-bit value&gt;;
       inet6_option_append(cmsgptr, &amp;optY.ip6_Y_opt_type,
                           IP6_Y_OPT_MULTX, IP6_Y_OPT_OFFSETY);
       msg.msg_controllen += cmsgptr-&gt;cmsg_len;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each call to inet6_option_init() builds a new cmsghdr structure, and the final result looks like the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_option_init（）を呼び出すたびに、新しいcmsghdr構造体を構築し、最終的な結果は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_len = 28                                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_level = IPPROTO_IPV6                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_type = IPV6_HOPOPTS                                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         4-octet field                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     +                         8-octet field                         +
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_len = 28                                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_level = IPPROTO_IPV6                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_type = IPV6_HOPOPTS                                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  Next Header  | Hdr Ext Len=1 | Pad1 Option=0 | Option Type=Y |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |Opt Data Len=7 | 1-octet field |         2-octet field         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         4-octet field                         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     | PadN Option=1 |Opt Data Len=2 |       0       |       0       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the kernel combines these two options into a single Hop-by-Hop extension header, the first 3 bytes of the second ancillary data object (the Next Header byte, the Hdr Ext Len byte, and the Pad1 option) will be combined into a PadN option occupying 3 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カーネルは単一ホップバイホップ拡張ヘッダ中にこれら二つのオプションを組み合わせたときに、第二補助データオブジェクト（ネクストヘッダバイト、HDR拡張レンバイト、及びパッド1オプション）の最初の3バイトに結合され3つのバイトを占有パッドNオプション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following code fragment is a redo of the first example shown (building two options in a single ancillary data object) but this time we use inet6_option_alloc().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のコードは、（単一の補助データオブジェクト内の2つのオプションがビルド）に示す第1例のやり直しが、我々は（inet6_option_alloc使用この時間）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
uint8_t  *typep;
struct msghdr  msg;
struct cmsghdr  *cmsgptr;
struct ip6_X_opt  *optXp;  /* now a pointer, not a struct */
struct ip6_Y_opt  *optYp;  /* now a pointer, not a struct */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
msg.msg_control = malloc(inet6_option_space(sizeof(*optXp) + sizeof(*optYp)));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
msg.msg_control = malloc関数（inet6_option_space（はsizeof（* optXp）+はsizeof（* optYp）））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
inet6_option_init(msg.msg_control, &amp;cmsgptr, IPV6_HOPOPTS);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
inet6_option_init（msg.msg_control、＆cmsgptr、IPV6_HOPOPTS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
typep = inet6_option_alloc(cmsgptr, IP6_X_OPT_LEN,
                           IP6_X_OPT_MULTX, IP6_X_OPT_OFFSETY);
optXp = (struct ip6_X_opt *) (typep - IP6_X_OPT_OFFSETY);
optXp-&gt;ip6_X_opt_type = IP6_X_OPT_TYPE;
optXp-&gt;ip6_X_opt_len  = IP6_X_OPT_LEN;
optXp-&gt;ip6_X_opt_val1 = &lt;32-bit value&gt;;
optXp-&gt;ip6_X_opt_val2 = &lt;64-bit value&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
typep = inet6_option_alloc(cmsgptr, IP6_Y_OPT_LEN,
                           IP6_Y_OPT_MULTX, IP6_Y_OPT_OFFSETY);
optYp = (struct ip6_Y_opt *) (typep - IP6_Y_OPT_OFFSETY);
optYp-&gt;ip6_Y_opt_type = IP6_Y_OPT_TYPE;
optYp-&gt;ip6_Y_opt_len  = IP6_Y_OPT_LEN;
optYp-&gt;ip6_Y_opt_val1 = &lt;8-bit value&gt;;
optYp-&gt;ip6_Y_opt_val2 = &lt;16-bit value&gt;;
optYp-&gt;ip6_Y_opt_val3 = &lt;32-bit value&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
msg.msg_controllen = cmsgptr-&gt;cmsg_len;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
msg.msg_controllen = cmsgptr-&gt; CMSG_LEN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notice that inet6_option_alloc() returns a pointer to the 8-bit option type field. If the program wants a pointer to an option structure that includes the padding at the front (as shown in our definitions of the ip6_X_opt and ip6_Y_opt structures), the y-offset at the beginning of the structure must be subtracted from the returned pointer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8ビットのオプションタイプフィールドへのポインタを返す（）はinet6_option_allocに注意してください。プログラムは、（ip6_X_optとip6_Y_opt構造の我々の定義に示すように）前面にパディングを含んオプション構造体へのポインタを望んでいる場合は、Y-オフセット構造の初めには、返されたポインタから減算する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following code fragment shows the processing of Hop-by-Hop options using the inet6_option_next() function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のコード断片はinet6_option_next（）関数を使用してホップバイホップオプションの処理を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct msghdr   msg;
    struct cmsghdr  *cmsgptr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* fill in msg */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* call recvmsg() */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
for (cmsgptr = CMSG_FIRSTHDR(&amp;msg); cmsgptr != NULL; cmsgptr = CMSG_NXTHDR(&amp;msg, cmsgptr)) { if (cmsgptr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp; cmsgptr-&gt;cmsg_type == IPV6_HOPOPTS) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
用（cmsgptr = CMSG_FIRSTHDR（＆MSG）;！cmsgptr = NULL; cmsgptr = CMSG_NXTHDR（＆MSG、cmsgptr））{IF（cmsgptr-&gt; cmsg_levelメンバ== IPPROTO_IPV6 &amp;&amp; cmsgptr-&gt; cmsg_type == IPV6_HOPOPTS）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
uint8_t *tptr = NULL;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
uint8_t * TPTR = NULL;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
while (inet6_option_next(cmsgptr, &amp;tptr) == 0) { if (*tptr == IP6_X_OPT_TYPE) { struct ip6_X_opt *optXp;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
一方、（inet6_option_next（cmsgptr、＆TPTR）== 0）{IF（* TPTR == IP6_X_OPT_TYPE）{構造体ip6_X_opt * optXp。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    optXp = (struct ip6_X_opt *) (tptr - IP6_X_OPT_OFFSETY);
                    &lt;do whatever with&gt; optXp-&gt;ip6_X_opt_val1;
                    &lt;do whatever with&gt; optXp-&gt;ip6_X_opt_val2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
} else if (*tptr == IP6_Y_OPT_TYPE) { struct ip6_Y_opt *optYp;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
}もしそうでなければ（* TPTR == IP6_Y_OPT_TYPE）{構造体ip6_Y_opt * optYp。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    optYp = (struct ip6_Y_opt *) (tptr - IP6_Y_OPT_OFFSETY);
                    &lt;do whatever with&gt; optYp-&gt;ip6_Y_opt_val1;
                    &lt;do whatever with&gt; optYp-&gt;ip6_Y_opt_val2;
                    &lt;do whatever with&gt; optYp-&gt;ip6_Y_opt_val3;
                }
            }
            if (tptr != NULL)
                &lt;error encountered by inet6_option_next()&gt;;
        }
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Destination Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.宛先オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A variable number of Destination options can appear in one or more Destination option headers. As defined in [RFC-1883], a Destination options header appearing before a Routing header is processed by the first destination plus any subsequent destinations specified in the Routing header, while a Destination options header appearing after a Routing header is processed only by the final destination. As with the Hop-by-Hop options, each option in a Destination options header is TLV-encoded with a type, length, and value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先オプションの可変数は、1つ以上の宛先オプションヘッダーに表示されます。 [RFC-1883]で定義されるようにルーティングヘッダが最初の目的地プラスルーティングヘッダで指定された任意の後続の宛先によって処理される前に、宛先オプションは、最終によってのみ処理され、ルーティングヘッダの後に現れるヘッダながら、宛先オプションは、出現ヘッダ先。ホップバイホップオプションと同様に、宛先オプションヘッダの各オプションは、タイプ、長さ、および値でTLVエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Today no Destination options are defined for IPv6 [RFC-1883], although proposals exist to use Destination options with mobility and anycasting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
提案は、モビリティとエニーキャストと宛先オプションを使用するために存在するが、今日は何の宛先オプションは、IPv6の[RFC-1883]のために定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Receiving Destination Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 宛先オプションを受け取ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To receive Destination options the application must enable the IPV6_DSTOPTS socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先オプションを受信するにはアプリケーションがIPV6_DSTOPTSソケットオプションを有効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int  on = 1;
       setsockopt(fd, IPPROTO_IPV6, IPV6_DSTOPTS, &amp;on, sizeof(on));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All the Destination options appearing before a Routing header are returned as one ancillary data object described by a cmsghdr structure and all the Destination options appearing after a Routing header are returned as another ancillary data object described by a cmsghdr structure. For these ancillary data objects, the cmsg_level member will be IPPROTO_IPV6 and the cmsg_type member will be IPV6_HOPOPTS. These options are then processed by calling the inet6_option_next() and inet6_option_find() functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングヘッダの前に現れるすべての宛先オプションはcmsghdr構造体とルーティングヘッダはcmsghdr構造体によって記述される他の補助的なデータオブジェクトとして返された後に現れるすべての宛先オプションで説明したもの補助データオブジェクトとして返されます。これらの補助的なデータオブジェクトの場合は、cmsg_levelメンバメンバーはIPPROTO_IPV6になり、cmsg_typeメンバーはIPV6_HOPOPTSになります。これらのオプションは、その後inet6_option_next（）とinet6_option_find（）関数を呼び出すことによって処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Sending Destination Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 宛先オプションを送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To send one or more Destination options, the application just specifies them as ancillary data in a call to sendmsg(). No socket option need be set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つ以上の宛先オプションを送信するには、アプリケーションは、ちょうど）（コールで補助データがSENDMSGするようにそれらを指定します。いいえソケットオプションを設定する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described earlier, one set of Destination options can appear before a Routing header, and one set can appear after a Routing header. Each set can consist of one or more options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述したように、宛先オプションの一組は、ルーティングヘッダの前に表示することができ、そして一組は、ルーティングヘッダの後に現れることができます。各セットは、1つまたは複数のオプションで構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Normally all the Destination options in a set are specified by a single ancillary data object, since each option is itself TLV-encoded. Multiple ancillary data objects, each containing one or more Destination options, can also be specified, in which case the kernel will combine all the Destination options in the set into a single Destination extension header. But it should be more efficient to use a single ancillary data object to describe all the Destination options in a set. The cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_DSTOPTS. The option is normally constructed using the inet6_option_init(), inet6_option_append(), and inet6_option_alloc() functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各オプションは、それ自体がTLVエンコードであるため、通常はセット内のすべての宛先オプションは、単一の補助データオブジェクトで指定されています。複数の補助データオブジェクトをそれぞれ含む1つ以上の宛先オプション、また、カーネルは、単一の宛先拡張ヘッダにセット内のすべての宛先オプションを組み合わせてなる場合には、指定することができます。しかし、セット内のすべての宛先オプションを記述するために、単一の補助的なデータオブジェクトを使用する方が効率的でなければなりません。 cmsg_levelメンバメンバーはIPPROTO_IPV6に設定され、cmsg_typeメンバーはIPV6_DSTOPTSに設定されています。オプションは、通常inet6_option_init（）、inet6_option_append（）、及びinet6_option_alloc（）関数を使用して構築されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional errors may be possible from sendmsg() if the specified option is in error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたオプションにエラーがある場合は、追加のエラーは）（にsendmsgから可能かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Routing Header Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.ルーティングヘッダオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source routing in IPv6 is accomplished by specifying a Routing header as an extension header. There can be different types of Routing headers, but IPv6 currently defines only the Type 0 Routing header [RFC-1883]. This type supports up to 23 intermediate nodes. With this maximum number of intermediate nodes, a source, and a destination, there are 24 hops, each of which is defined as a strict or loose hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6におけるソースルーティングは、拡張ヘッダなどのルーティングヘッダを指定することによって達成されます。そこにルーティングヘッダの異なるタイプであるが、IPv6は現在、タイプ0ルーティングヘッダ[RFC-1883]を定義することができます。このタイプは、23の中間ノードをサポートします。中間ノードのこの最大数、送信元、宛先と、厳密または緩いホップとして定義され、それぞれが24回のホップがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source routing with IPv4 sockets API (the IP_OPTIONS socket option) requires the application to build the source route in the format that appears as the IPv4 header option, requiring intimate knowledge of the IPv4 options format. This IPv6 API, however, defines eight functions that the application calls to build and examine a Routing header. Four functions build a Routing header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4では、ソースルーティングは、API（IP_OPTIONSソケットオプション）はIPv4オプションフォーマットの詳細な知識を必要とし、IPv4ヘッダーオプションとして表示される形式でソースルートを構築するためのアプリケーションを必要とするソケット。このIPv6のAPIは、しかし、アプリケーションが構築し、ルーティングヘッダを調べるために呼び出す8つの関数を定義しています。 4つの機能は、ルーティングヘッダを構築します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rthdr_space() - return #bytes required for ancillary data inet6_rthdr_init() - initialize ancillary data for Routing header inet6_rthdr_add() - add IPv6 address &amp; flags to Routing header inet6_rthdr_lasthop() - specify the flags for the final hop
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rthdr_space（） - 補助データinet6_rthdr_initために必要な戻り#bytes（） - ）（ヘッダinet6_rthdr_addをルーティングするための補助データを初期化 - （ヘッダinet6_rthdr_lasthopルーティングにIPv6アドレスとフラグを追加） - 最終ホップのためにフラグを指定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Four functions deal with a returned Routing header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4つの関数は、返されたルーティングヘッダを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
inet6_rthdr_reverse() - reverse a Routing header inet6_rthdr_segments() - return #segments in a Routing header inet6_rthdr_getaddr() - fetch one address from a Routing header inet6_rthdr_getflags() - fetch one flag from a Routing header
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
inet6_rthdr_reverse（） - ルーティングヘッダinet6_rthdr_segments（）逆 - ルーティングヘッダinet6_rthdr_getaddrに戻り#segmentsを（） - ルーティングヘッダinet6_rthdr_getflags（）から一つのアドレスをフェッチ - ルーティングヘッダから1つのフラグをフェッチ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function prototypes for these functions are all in the &lt;netinet/in.h&gt; header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの関数の関数プロトタイプは&lt;netinetの/ in.h&gt;ヘッダ内の全てです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To receive a Routing header the application must enable the IPV6_RTHDR socket option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングヘッダを受信するにはアプリケーションがIPV6_RTHDRソケットオプションを有効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int  on = 1;
       setsockopt(fd, IPPROTO_IPV6, IPV6_RTHDR, &amp;on, sizeof(on));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To send a Routing header the application just specifies it as ancillary data in a call to sendmsg().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングヘッダを送信するために、アプリケーションは、単に（SENDMSGの呼び出しで補助データとして指定します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Routing header is passed between the application and the kernel as an ancillary data object. The cmsg_level member has a value of IPPROTO_IPV6 and the cmsg_type member has a value of IPV6_RTHDR. The contents of the cmsg_data[] member is implementation dependent and should not be accessed directly by the application, but should be accessed using the eight functions that we are about to describe.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングヘッダは、アプリケーションと補助データオブジェクトとカーネルとの間に通されます。 cmsg_levelメンバ部材はIPPROTO_IPV6の値を有し、cmsg_type部材がIPV6_RTHDRの値を有します。 CMSG_DATA []メンバーの内容は実装依存であり、アプリケーションによって直接アクセスされるべきではなく、我々が説明しようとしている8つの関数を使用してアクセスされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following constants are defined in the &lt;netinet/in.h&gt; header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の定数は、&lt;netinetの/ in.h&gt;ヘッダに定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    #define IPV6_RTHDR_LOOSE     0 /* this hop need not be a neighbor */
    #define IPV6_RTHDR_STRICT    1 /* this hop must be a neighbor */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    #define IPV6_RTHDR_TYPE_0    0 /* IPv6 Routing header type 0 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a Routing header is specified, the destination address specified for connect(), sendto(), or sendmsg() is the final destination address of the datagram. The Routing header then contains the addresses of all the intermediate nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングヘッダが指定されている場合、送信先の接続のための指定されたアドレス（）のsendto（）、またはsendmsgの（）は、データグラムの最終的な宛先アドレスです。ルーティングヘッダは、すべての中間ノードのアドレスを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. inet6_rthdr_space
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.  inet6_rthdr_space
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
size_t inet6_rthdr_space(int type, int segments);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
size_tのinet6_rthdr_space（int型、INTセグメント）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function returns the number of bytes required to hold a Routing header of the specified type containing the specified number of segments (addresses). For an IPv6 Type 0 Routing header, the number of segments must be between 1 and 23, inclusive. The return value includes the size of the cmsghdr structure that precedes the Routing header, and any required padding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、セグメント（アドレス）の指定された数を含む指定されたタイプのルーティングヘッダを保持するために必要なバイト数を返します。 IPv6のタイプ0ルーティングヘッダは、セグメントの数は、1〜23、包括的でなければなりません。戻り値は、ルーティングヘッダに先行cmsghdr構造体の大きさ、および任意の必要なパディングを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the return value is 0, then either the type of the Routing header is not supported by this implementation or the number of segments is invalid for this type of Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
戻り値が0である場合には、ルーティングヘッダのタイプは、この実装でサポートされていないか、またはセグメントの数は、ヘッダルーティングこのタイプの無効のいずれか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: This function returns the size but does not allocate the space required for the ancillary data. This allows an application to allocate a larger buffer, if other ancillary data objects are desired, since all the ancillary data objects must be specified to sendmsg() as a single msg_control buffer.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：この関数はサイズを返すが、補助データに必要なスペースを割り当てない他の補助的なデータオブジェクトが所望される場合、すべての補助データオブジェクトがSENDMSGするために指定されなければならないので、これは、アプリケーションが大きなバッファを割り当てることができます（。 ）単一msg_controlバッファとして）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. inet6_rthdr_init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.  inet6_rthdr_init
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
struct cmsghdr *inet6_rthdr_init(void *bp, int type);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
構造体のcmsghdr * inet6_rthdr_init（ボイド* bpの、int型）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function initializes the buffer pointed to by bp to contain a cmsghdr structure followed by a Routing header of the specified type. The cmsg_len member of the cmsghdr structure is initialized to the size of the structure plus the amount of space required by the Routing header. The cmsg_level and cmsg_type members are also initialized as required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、バッファが指定されたタイプのルーティングヘッダに続くcmsghdr構造体を含むようにBPによって指さ初期化します。 cmsghdr構造体のCMSG_LEN部材​​は、構造のサイズとルーティングヘッダに必要なスペースの量に初期化されます。必要に応じて、cmsg_levelメンバとcmsg_typeメンバーも初期化されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The caller must allocate the buffer and its size can be determined by calling inet6_rthdr_space().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
呼び出し側は、バッファを割り当てる必要があり、そのサイズはinet6_rthdr_space（）を呼び出すことによって決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon success the return value is the pointer to the cmsghdr structure, and this is then used as the first argument to the next two functions. Upon an error the return value is NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功した場合、戻り値はcmsghdr構造体へのポインタであり、これは、次いで、次の二つの関数の最初の引数として使用されます。エラー時には、戻り値はNULLです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. inet6_rthdr_add
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.  inet6_rthdr_add
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    int inet6_rthdr_add(struct cmsghdr *cmsg,
                        const struct in6_addr *addr, unsigned int flags);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function adds the address pointed to by addr to the end of the Routing header being constructed and sets the type of this hop to the value of flags. For an IPv6 Type 0 Routing header, flags must be either IPV6_RTHDR_LOOSE or IPV6_RTHDR_STRICT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、アドレスが構成されているルーティングヘッダの終わりにADDRによって指さ加算し、フラグの値にこのホップのタイプを設定します。 IPv6のタイプ0ルーティングヘッダは、フラグはIPV6_RTHDR_LOOSE又はIPV6_RTHDR_STRICTのいずれかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If successful, the cmsg_len member of the cmsghdr structure is updated to account for the new address in the Routing header and the return value of the function is 0. Upon an error the return value of the function is -1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功した場合、cmsghdr構造体のCMSG_LEN部材​​がルーティングヘッダに新しいアドレスを考慮するために更新され、関数の戻り値はエラー時に0である関数の戻り値は-1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. inet6_rthdr_lasthop
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.  inet6_rthdr_lasthop
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int inet6_rthdr_lasthop(struct cmsghdr *cmsg,
                               unsigned int flags);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function specifies the Strict/Loose flag for the final hop of a Routing header. For an IPv6 Type 0 Routing header, flags must be either IPV6_RTHDR_LOOSE or IPV6_RTHDR_STRICT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、ルーティングヘッダの最終ホップのために厳密/ルースフラグを指定します。 IPv6のタイプ0ルーティングヘッダは、フラグはIPV6_RTHDR_LOOSE又はIPV6_RTHDR_STRICTのいずれかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The return value of the function is 0 upon success, or -1 upon an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数の戻り値は成功時に0、あるいはエラー時に-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notice that a Routing header specifying N intermediate nodes requires N+1 Strict/Loose flags. This requires N calls to inet6_rthdr_add() followed by one call to inet6_rthdr_lasthop().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N中間ノードを指定するルーティングヘッダは、N + 1厳密/ルースフラグを必要とすることに注意してください。これは、）Nは（inet6_rthdr_addの呼び出しが必要です）（inet6_rthdr_lasthop 1つの呼び出しが続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. inet6_rthdr_reverse
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5.  inet6_rthdr_reverse
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
int inet6_rthdr_reverse(const struct cmsghdr *in, struct cmsghdr *out);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
int型inet6_rthdr_reverse（constの構造体のcmsghdr *で、構造体のcmsghdr *アウト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function takes a Routing header that was received as ancillary data (pointed to by the first argument) and writes a new Routing header that sends datagrams along the reverse of that route. Both arguments are allowed to point to the same buffer (that is, the reversal can occur in place).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、（最初​​の引数によって指される）補助データとして受信されたルーティングヘッダを取得し、そのルートの逆に沿ってデータグラムを送信する新しいルーティングヘッダを書き込みます。両方の引数は、同じ緩衝液（すなわち、反転が場所で起こり得る）を指すように許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The return value of the function is 0 on success, or -1 upon an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数の戻り値は成功時に0、あるいはエラー時に-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. inet6_rthdr_segments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.  inet6_rthdr_segments
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int inet6_rthdr_segments(const struct cmsghdr *cmsg);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
inet6_rthdr_segments（constの構造体のcmsghdr *のCMSG）をint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function returns the number of segments (addresses) contained in the Routing header described by cmsg. On success the return value is between 1 and 23, inclusive. The return value of the function is -1 upon an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、CMSGによって記述ルーティングヘッダに含まれるセグメント（アドレス）の数を返します。成功した場合、戻り値は1と23の間で、包括的です。関数の戻り値は、エラー時に-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. inet6_rthdr_getaddr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7.  inet6_rthdr_getaddr
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *cmsg, int
    index);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function returns a pointer to the IPv6 address specified by index (which must have a value between 1 and the value returned by inet6_rthdr_segments()) in the Routing header described by cmsg. An application should first call inet6_rthdr_segments() to obtain the number of segments in the Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、CMSGによって記述ルーティングヘッダ（1間の値とinet6_rthdr_segments（）によって返される値を有していなければならない）インデックスで指定されたIPv6アドレスへのポインタを返します。アプリケーションは、最初のルーティングヘッダ内のセグメントの数を得るために）（inet6_rthdr_segmentsを呼び出す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon an error the return value of the function is NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー時には、関数の戻り値はNULLです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. inet6_rthdr_getflags
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8.  inet6_rthdr_getflags
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int inet6_rthdr_getflags(const struct cmsghdr *cmsg, int index);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int型inet6_rthdr_getflags（のconst構造体のcmsghdr * CMSG、int型のインデックス）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function returns the flags value specified by index (which must have a value between 0 and the value returned by inet6_rthdr_segments()) in the Routing header described by cmsg. For an IPv6 Type 0 Routing header the return value will be either IPV6_RTHDR_LOOSE or IPV6_RTHDR_STRICT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この関数は、CMSGによって記述ルーティングヘッダ内の（0の間の値とinet6_rthdr_segments（）によって返される値を有していなければならない）インデックスで指定されたフラグの値を返します。 IPv6のタイプ0ルーティングヘッダの戻り値はIPV6_RTHDR_LOOSE又はIPV6_RTHDR_STRICTのいずれかであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon an error the return value of the function is -1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー時の関数の戻り値は-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: Addresses are indexed starting at 1, and flags starting at 0, to maintain consistency with the terminology and figures in [RFC-1883].)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：アドレスは1から始まるインデックス付けされ、フラグが0から始まる、[RFC-1883]における用語と図面との整合性を維持するため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.9. Routing Header Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.9. ルーティングヘッダの例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example of these Routing header functions, we go through the function calls for the example on p. 18 of [RFC-1883]. The source is S, the destination is D, and the three intermediate nodes are I1, I2, and I3. f0, f1, f2, and f3 are the Strict/Loose flags for each hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのルーティングヘッダ機能の例として、我々は、p上の例えば、関数呼び出しを通過します。 [RFC-1883]の18。ソースがSであり、宛先がDであり、そして3つの中間ノードは、I1、I2、およびI3です。 F0、F1、F2、F3とは、各ホップのための厳格/ルースフラグです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   f0        f1        f2        f3
               S -----&gt; I1 -----&gt; I2 -----&gt; I3 -----&gt; D
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
src: * S S S S S dst: D I1 I2 I3 D D A[1]: I1 I2 I1 I1 I1 I1 A[2]: I2 I3 I3 I2 I2 I2 A[3]: I3 D D D I3 I3 #seg: 3 3 2 1 0 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
SRC：* S S S S S DST：D I1 I2 I3 D D A [1]：I1 I2 I1 I1 I1 I1 A [2]：I2 I3 I3 I2 I2 I2 A [3]：I3 D D D I3 I3の#seg：3 ​​3 2 1 0 3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
check: f0 f1 f2 f3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
チェック：F0、F1、F2、F3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
src and dst are the source and destination IPv6 addresses in the IPv6 header. A[1], A[2], and A[3] are the three addresses in the Routing header. #seg is the Segments Left field in the Routing header. check indicates which bit of the Strict/Loose Bit Map (0 through 3, specified as f0 through f3) that node checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRCとDSTは、IPv6は、IPv6ヘッダのアドレス、送信元および宛先です。 [1]、A [2]、A [3]ルーティングヘッダ内に3つのアドレスです。 #segルーティングヘッダフィールドを左セグメントです。チェックは、（F3を通してF0として指定された0〜3）厳密/ルースビットマップそのノードチェックのどのビットを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The six values in the column beneath node S are the values in the Routing header specified by the application using sendmsg(). The function calls by the sender would look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードSの下の列の6つの値は、sendmsgの（）を使用して、アプリケーションによって指定されたルーティングヘッダ内の値です。機能は次のようになります。送信者によって呼び出されます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       void  *ptr;
       struct msghdr  msg;
       struct cmsghdr  *cmsgptr;
       struct sockaddr_in6  I1, I2, I3, D;
       unsigned int  f0, f1, f2, f3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ptr = malloc(inet6_rthdr_space(IPV6_RTHDR_TYPE_0, 3));
       cmsgptr = inet6_rthdr_init(ptr, IPV6_RTHDR_TYPE_0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       inet6_rthdr_add(cmsgptr, &amp;I1.sin6_addr, f0);
       inet6_rthdr_add(cmsgptr, &amp;I2.sin6_addr, f1);
       inet6_rthdr_add(cmsgptr, &amp;I3.sin6_addr, f2);
       inet6_rthdr_lasthop(cmsgptr, f3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       msg.msg_control = ptr;
       msg.msg_controllen = cmsgptr-&gt;cmsg_len;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* finish filling in msg{}, msg_name = D */
       /* call sendmsg() */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We also assume that the source address for the socket is not specified (i.e., the asterisk in the figure).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々はまた、ソケットの送信元アドレスが指定されていないことを前提とし（すなわち、図のアスタリスク）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The four columns of six values that are then shown between the five nodes are the values of the fields in the packet while the packet is in transit between the two nodes. Notice that before the packet is sent by the source node S, the source address is chosen (replacing the asterisk), I1 becomes the destination address of the datagram, the two addresses A[2] and A[3] are &#34;shifted up&#34;, and D is moved to A[3]. If f0 is IPV6_RTHDR_STRICT, then I1 must be a neighbor of S.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットが2つのノード間の通過している間に、次に5つのノードの間に示されている6つの値の4つの列は、パケットのフィールドの値です。パケットがソースノードSによって送信される前に、送信元アドレスは、（アスタリスクを置換する）選択されていることを確認し、I1は、データグラムの宛先アドレスとなり、二つのアドレス[2]、A [3]が「シフトアップ」 、およびDは、[3]に移動されます。 f0はIPV6_RTHDR_STRICTであれば、I1はS.の隣人である必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The columns of values that are shown beneath the destination node are the values returned by recvmsg(), assuming the application has enabled both the IPV6_PKTINFO and IPV6_RTHDR socket options. The source address is S (contained in the sockaddr_in6 structure pointed to by the msg_name member), the destination address is D (returned as an ancillary data object in an in6_pktinfo structure), and the ancillary data object specifying the Routing header will contain three addresses (I1, I2, and I3) and four flags (f0, f1, f2, and f3). The number of segments in the Routing header is known from the Hdr Ext Len field in the Routing header (a value of 6, indicating 3 addresses).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先ノードの下に示されている値の列は、アプリケーションがIPV6_PKTINFOとIPV6_RTHDRソケットオプションの両方を有効にしていると仮定のrecvmsg（）によって返される値です。 S（sockaddr_in6構造体に含まれているが、はmsg_name部材によって指される）ソース・アドレスは、宛先アドレスがD（in6_pktinfo構造における補助データオブジェクトとして返される）である、ルーティングヘッダを指定する補助データオブジェクトは、3つのアドレスを含むことになります（I1、I2、及びI3）と4つのフラグ（F0、F1、F2、及びF3）。ルーティングヘッダ内のセグメントの数は（3つのアドレスを示し、6の値）ルーティングヘッダにHDR拡張LENフィールドから知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The return value from inet6_rthdr_segments() will be 3 and inet6_rthdr_getaddr(1) will return I1, inet6_rthdr_getaddr(2) will return I2, and inet6_rthdr_getaddr(3) will return I3, The return value from inet6_rthdr_flags(0) will be f0, inet6_rthdr_flags(1) will return f1, inet6_rthdr_flags(2) will return f2, and inet6_rthdr_flags(3) will return f3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rthdr_segmentsからの戻り値が（3）3及びinet6_rthdr_getaddr（1）I1、inet6_rthdr_getaddr（2）I2を返し、inet6_rthdr_getaddr（3）I3、inet6_rthdr_flagsからの戻り値は（0）F0となり戻り、inet6_rthdr_flags（戻りますであろう1）、F1返されinet6_rthdr_flags（2）F2を返し、inet6_rthdr_flags（3）F3を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the receiving application then calls inet6_rthdr_reverse(), the order of the three addresses will become I3, I2, and I1, and the order of the four Strict/Loose flags will become f3, f2, f1, and f0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信側アプリケーションは、その後、（）inet6_rthdr_reverseを呼び出した場合、3つのアドレスの順序はI3、I2、I1となり、四厳格/ルースフラグの順序は、F3、F2、F1、F0となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can also show what an implementation might store in the ancillary data object as the Routing header is being built by the sending process. If we assume a 32-bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4-byte boundaries, then the call to inet6_rthdr_space(3) returns 68: 12 bytes for the cmsghdr structure and 56 bytes for the Routing header (8 + 3*16).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、ルーティングヘッダが送信プロセスによって構築されているような実装は、補助的なデータオブジェクトに格納かもしれないものを表示することができます。我々ははsizeof（構造体のcmsghdr）が4バイト境界の所望の配向を有する、12に等しい32ビットのアーキテクチャを想定した場合、コールはinet6_rthdr_space（3）68戻り：ルーティングのためのcmsghdr構造体のための12バイト、56のバイトヘッダ（8 + 3 * 16）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The call to inet6_rthdr_init() initializes the ancillary data object to contain a Type 0 Routing header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rthdr_init（）の呼び出しはタイプ0ルーティングヘッダを含むように補助データオブジェクトを初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_len = 20                                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_level = IPPROTO_IPV6                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_type = IPV6_RTHDR                                  |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  Next Header  | Hdr Ext Len=0 | Routing Type=0|  Seg Left=0   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |   Reserved    |             Strict/Loose Bit Map              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first call to inet6_rthdr_add() adds I1 to the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rthdr_addする最初の呼び出しは（）リストにI1を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_len = 36                                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_level = IPPROTO_IPV6                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_type = IPV6_RTHDR                                  |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  Next Header  | Hdr Ext Len=2 | Routing Type=0|  Seg Left=1   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |   Reserved    |X|           Strict/Loose Bit Map              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     +                                                               +
     |                                                               |
     +                           Address[1] = I1                     +
     |                                                               |
     +                                                               +
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bit 0 of the Strict/Loose Bit Map contains the value f0, which we just mark as X. cmsg_len is incremented by 16, the Hdr Ext Len field is incremented by 2, and the Segments Left field is incremented by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
厳密/ルースビットマップのビット0がX.のCMSG_LENが16ずつインクリメントされるよう、我々はちょうどマーク値F0が、含まれている、HDRのExtレンフィールドは2インクリメントされ、そしてフィールド左セグメントは1だけインクリメントされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next call to inet6_rthdr_add() adds I2 to the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6_rthdr_addする次の呼び出しは（）リストにI2を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_len = 52                                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_level = IPPROTO_IPV6                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_type = IPV6_RTHDR                                  |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  Next Header  | Hdr Ext Len=4 | Routing Type=0|  Seg Left=2   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |   Reserved    |X|X|         Strict/Loose Bit Map              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     +                                                               +
     |                                                               |
     +                           Address[1] = I1                     +
     |                                                               |
     +                                                               +
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     +                                                               +
     |                                                               |
     +                           Address[2] = I2                     +
     |                                                               |
     +                                                               +
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next bit of the Strict/Loose Bit Map contains the value f1. cmsg_len is incremented by 16, the Hdr Ext Len field is incremented by 2, and the Segments Left field is incremented by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
厳密/ルースビットマップの次のビットは値f1が含まれています。 CMSG_LENを16だけインクリメントされ、HDR拡張LENフィールドは2だけインクリメントされ、そしてフィールド左セグメントは1だけインクリメントされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last call to inet6_rthdr_add() adds I3 to the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（inet6_rthdr_addへの最後の呼び出し）リストにI3を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_len = 68                                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_level = IPPROTO_IPV6                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |       cmsg_type = IPV6_RTHDR                                  |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=3   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |   Reserved    |X|X|X|       Strict/Loose Bit Map              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     +                                                               +
     |                                                               |
     +                           Address[1] = I1                     +
     |                                                               |
     +                                                               +
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     +                                                               +
     |                                                               |
     +                           Address[2] = I2                     +
     |                                                               |
     +                                                               +
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     +                                                               +
     |                                                               |
     +                           Address[3] = I3                     +
     |                                                               |
     +                                                               +
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next bit of the Strict/Loose Bit Map contains the value f2. cmsg_len is incremented by 16, the Hdr Ext Len field is incremented by 2, and the Segments Left field is incremented by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
厳密/ルースビットマップの次のビットは値F2が含まれています。 CMSG_LENを16だけインクリメントされ、HDR拡張LENフィールドは2だけインクリメントされ、そしてフィールド左セグメントは1だけインクリメントされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the call to inet6_rthdr_lasthop() sets the next bit of the Strict/Loose Bit Map to the value specified by f3. All the lengths remain unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、呼び出しは（）inet6_rthdr_lasthop F3で指定した値に厳密/ルースビットマップの次のビットをセットします。すべての長さは変わりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Ordering of Ancillary Data and IPv6 Extension Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
補助データとIPv6拡張ヘッダーの9.注文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three IPv6 extension headers can be specified by the application and returned to the application using ancillary data with sendmsg() and recvmsg(): Hop-by-Hop options, Destination options, and the Routing header. When multiple ancillary data objects are transferred via sendmsg() or recvmsg() and these objects represent any of these three extension headers, their placement in the control buffer is directly tied to their location in the corresponding IPv6 datagram. This API imposes some ordering constraints when using multiple ancillary data objects with sendmsg().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
三のIPv6拡張ヘッダは、アプリケーションによって指定され、（）にsendmsgと補助データを使用するアプリケーション（）とのrecvmsgに戻すことができる：ホップバイホップオプション、宛先オプション、ルーティングヘッダ。複数の補助データオブジェクトが（にsendmsgを介して転送）またはのrecvmsg（）と、これらのオブジェクトは、これらの3つの拡張ヘッダのいずれかを表している場合、制御バッファにおけるそれらの配置は、直接対応するIPv6データグラム内のそれらの位置に接続されています。複数の補助的なデータオブジェクトを使用している場合、このAPIは、（）にsendmsgでいくつかの順序制約を課します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple IPv6 Hop-by-Hop options having the same option type are specified, these options will be inserted into the Hop-by-Hop options header in the same order as they appear in the control buffer. But when multiple Hop-by-Hop options having different option types are specified, these options may be reordered by the kernel to reduce padding in the Hop-by-Hop options header. Hop-by-Hop options may appear anywhere in the control buffer and will always be collected by the kernel and placed into a single Hop-by-Hop options header that immediately follows the IPv6 header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じオプションタイプを有する複数のIPv6ホップバイホップオプションが指定されている場合、これらのオプションは、それらが制御バッファに現れるのと同じ順序でホップバイホップオプションヘッダに挿入されます。別のオプションタイプを有する複数のホップバイホップオプションが指定されている場合には、これらのオプションは、ホップバイホップオプションヘッダにパディングを低減するためにカーネルによって並べ替えることができます。ホップバイホップオプションは、制御バッファのどこにでも現れることがあり、常にカーネルによって収集し、直ちにIPv6ヘッダの後に続く単一ホップバイホップオプションヘッダに配置されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similar rules apply to the Destination options: (1) those of the same type will appear in the same order as they are specified, and (2) those of differing types may be reordered. But the kernel will build up to two Destination options headers: one to precede the Routing header and one to follow the Routing header. If the application specifies a Routing header then all Destination options that appear in the control buffer before the Routing header will appear in a Destination options header before the Routing header and these options might be reordered, subject to the two rules that we just stated. Similarly all Destination options that appear in the control buffer after the Routing header will appear in a Destination options header after the Routing header, and these options might be reordered, subject to the two rules that we just stated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様のルールが宛先オプションに適用される：（1）同じタイプのものは、それらが指定されているのと同じ順序で表示され、（2）異なるタイプのものが並べ替えてもよいです。ルーティングヘッダに従うことをルーティングヘッダと1の前に1：しかし、カーネルは、2つの宛先オプションヘッダに構築されます。アプリケーションは、ルーティングヘッダを指定する場合は、ルーティングヘッダの前に制御バッファに表示されるすべての宛先オプションは、オプションは、ルーティングヘッダの前にヘッダーとこれらのオプションは、我々はちょうど述べた二つの規則の対象に再順序付けされる場合があります先に表示されます。同様にルーティングヘッダーの後に制御バッファに表示されるすべての宛先オプションは、ルーティングヘッダーの後に宛先オプションヘッダーに表示され、これらのオプションは、我々はちょうど述べた二つの規則の対象に再順序付けされる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, assume that an application specifies control information to sendmsg() containing six ancillary data objects: the first containing two Hop-by-Hop options, the second containing one Destination option, the third containing two Destination options, the fourth containing a Routing header, the fifth containing a Hop-by-Hop option, and the sixth containing two Destination options. We also assume that all the Hop-by-Hop options are of different types, as are all the Destination options. We number these options 1-9, corresponding to their order in the control buffer, and show them on the left below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第四に含む、第一含む二つのホップバイホップオプション、1つの宛先オプションを含む第二、第三含む2つの宛先オプション：一例として、アプリケーションは、6つの補助的なデータオブジェクトを含む）（SENDMSGに制御情報を指定することを前提としていヘッダルーティング、ホップバイホップオプションを含む第五、および2つの宛先オプションを含む第六。我々はまた、すべての宛先オプションがあるように、すべてのホップバイホップオプションは、さまざまな種類のものであることを前提としています。私たちは、制御バッファ内の順序に対応し、これらのオプション1-9数、および下記の左側にそれらを表示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the middle we show the final arrangement of the options in the extension headers built by the kernel. On the right we show the four ancillary data objects returned to the receiving application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
途中で我々はカーネルによって構築された拡張ヘッダのオプションの最終的配置を示します。右側には、我々は4つの補助的なデータオブジェクトは受信側アプリケーションに返さ示しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          Sender&#39;s                                       Receiver&#39;s
       Ancillary Data      --&gt;   IPv6 Extension   --&gt;  Ancillary Data
          Objects                    Headers              Objects
       ------------------        ---------------       --------------
       HOPOPT-1,2 (first)        HOPHDR(J,7,1,2)       HOPOPT-7,1,2
       DSTOPT-3                  DSTHDR(4,5,3)         DSTOPT-4,5,3
       DSTOPT-4,5                RTHDR(6)              RTHDR-6
       RTHDR-6                   DSTHDR(8,9)           DSTOPT-8,9
       HOPOPT-7
       DSTOPT-8,9 (last)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sender&#39;s two Hop-by-Hop ancillary data objects are reordered, as are the first two Destination ancillary data objects. We also show a Jumbo Payload option (denoted as J) inserted by the kernel before the sender&#39;s three Hop-by-Hop options. The first three Destination options must appear in a Destination header before the Routing header, and the final two Destination options must appear in a Destination header after the Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の2つの宛先の補助データオブジェクトがそうであるように、送信者の2つのホップバイホップの補助的なデータオブジェクトは、並べ替えています。また、送信者の3ホップバイホップオプションの前にカーネルによって挿入された（Jと表記）巨大ペイロードオプションを示しています。最初の三つの宛先オプションは、ルーティングヘッダの前に宛先ヘッダに表示される必要があり、最終的な2つの宛先オプションは、ルーティングヘッダの後に宛先ヘッダに現れなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If Destination options are specified in the control buffer after a Routing header, or if Destination options are specified without a Routing header, the kernel will place those Destination options after an authentication header and/or an encapsulating security payload header, if present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先オプションがルーティングヘッダの後に制御バッファに指定されている場合宛先オプションがルーティングヘッダなしで指定された場合に存在する場合、または、カーネルは、認証ヘッダおよび/またはカプセル化セキュリティペイロードヘッダの後にそれらの宛先オプションを配置します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. IPv6-Specific Options with IPv4-Mapped IPv6 Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
IPv4マップIPv6アドレスを持つ10 IPv6固有オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The various socket options and ancillary data specifications defined in this document apply only to true IPv6 sockets. It is possible to create an IPv6 socket that actually sends and receives IPv4 packets, using IPv4-mapped IPv6 addresses, but the mapping of the options defined in this document to an IPv4 datagram is beyond the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
様々なソケットオプションと、この文書で定義された補助的なデータ仕様は真のIPv6ソケットにのみ適用されます。実際に送信し、IPv4射影IPv6アドレスを使用して、IPv4パケットを受信したIPv6ソケットを作成することは可能ですが、IPv4のデータグラムには、この文書で定義されたオプションのマッピングは、このドキュメントの範囲を超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, attempting to specify an IPv6-only option, such as the Hop-by-Hop options, Destination options, or Routing header on an IPv6 socket that is using IPv4-mapped IPv6 addresses, will probably result in an error. Some implementations, however, may provide access to the packet information (source/destination address, send/receive interface, and hop limit) on an IPv6 socket that is using IPv4-mapped IPv6 addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、このようなIPv4マップIPv6アドレスを使用しているIPv6ソケット上のホップバイホップオプション、宛先オプション、またはルーティングヘッダとして、IPv6のみのオプションを指定しようとすると、おそらくエラーになります。いくつかの実装では、しかし、IPv4マップIPv6アドレスを使用しているIPv6ソケットに（ソース/宛先アドレス、インターフェース、およびホップリミットを受信/送信）パケット情報へのアクセスを提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. rresvport_af
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. rresvport_af
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rresvport() function is used by the rcmd() function, and this function is in turn called by many of the &#34;r&#34; commands such as rlogin. While new applications are not being written to use the rcmd() function, legacy applications such as rlogin will continue to use it and these will be ported to IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rresvport（）関数は、RCMD（）関数によって使用され、この機能は、今度は、そのようなrloginのような「R」コマンドの多くによって呼び出されます。新しいアプリケーションは、RCMD（）関数を使用するように書かれていないが、そのようなrloginなどのレガシーアプリケーションはそれを使用し続けると、これらは、IPv6に移植されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rresvport() creates an IPv4/TCP socket and binds a &#34;reserved port&#34; to the socket. Instead of defining an IPv6 version of this function we define a new function that takes an address family as its argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rresvport（）はIPv4の/ TCPソケットを作成し、ソケットに「予約ポート」をバインドします。代わりに、この機能のIPv6のバージョンを定義するので、私たちはその引数としてアドレスファミリを取る新しい関数を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
#include &lt;unistd.h&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
書式#include &lt;unistd.h&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int rresvport_af(int *port, int family);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
あなたrresvport_af（あなた*ポート、あなたの家族）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This function behaves the same as the existing rresvport() function, but instead of creating an IPv4/TCP socket, it can also create an IPv6/TCP socket. The family argument is either AF_INET or AF_INET6, and a new error return is EAFNOSUPPORT if the address family is not supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機能は既存のrresvport（）関数と同じように動作し、代わりのIPv4 / TCPソケットを作成する、それはまたのIPv6 / TCPソケットを作成することができます。家族の引数は、どちらかAF_INETまたはAF_INET6で、アドレスファミリがサポートされていない場合、新しいエラーリターンはEAFNOSUPPORTです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: There is little consensus on which header defines the rresvport() and rcmd() function prototypes. 4.4BSD defines it in &lt;unistd.h&gt;, others in &lt;netdb.h&gt;, and others don&#39;t define the function prototypes at all.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：少しヘッダがrresvportを定義したコンセンサス（）およびRCMD（）関数のプロトタイプがあり4.4BSDは&lt;netdb.h&gt;で他、&lt;unistd.h&gt;にそれを定義し、他のものは関数プロトタイプを定義していません。全然。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: We define this function only, and do not define something like rcmd_af() or rcmd6(). The reason is that rcmd() calls gethostbyname(), which returns the type of address: AF_INET or AF_INET6. It should therefore be possible to modify rcmd() to support either IPv4 or IPv6, based on the address family returned by gethostbyname().)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：私たちは、これだけの機能を定義し、rcmd_afのようなもの（）またはrcmd6（）を定義していない理由は）（アドレスの種類を返すのgethostbyname（）、つまりRCMD呼び出しです：AF_INETまたはAF_INET6をしたがって、する必要がありますgethostbyname（によって返されたアドレスファミリに基づいて、IPv4またはIPv6のいずれかをサポートするために（）RCMDを変更することも可能）。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Future Items
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.未来のアイテム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some additional items may require standardization, but no concrete proposals have been made for the API to perform these tasks. These may be addressed in a later document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの追加項目は、標準化が必要な場合がありますが、具体的な提案は、これらのタスクを実行するためのAPIのために作られていません。これらは、後に文書で対処することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. Flow Labels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. フローラベル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Earlier revisions of this document specified a set of inet6_flow_XXX() functions to assign, share, and free IPv6 flow labels. Consensus, however, indicated that it was premature to specify this part of the API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の以前のリビジョンはアサインするinet6_flow_XXX（）関数のセット、共有し、無料のIPv6フローラベルを指定しました。コンセンサスは、しかし、APIのこの部分を指定するのは時期尚早であることが示されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. Path MTU Discovery and UDP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. パスMTUディスカバリーとUDP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A standard method may be desirable for a UDP application to determine the &#34;maximum send transport-message size&#34; (Section 5.1 of [RFC-1981]) to a given destination. This would let the UDP application send smaller datagrams to the destination, avoiding fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPアプリケーションは、特定の宛先への（[RFC-1981のセクション5.1）を「最大送信トランスポート・メッセージのサイズ」を決定するための標準的な方法が望ましいかもしれません。これは、UDPアプリケーションが断片化を避け、先に小さなデータグラムを送ってみましょうだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. Neighbor Reachability and UDP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. ネイバー到達可能とUDP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A standard method may be desirable for a UDP application to tell the kernel that it is making forward progress with a given peer (Section 7.3.1 of [RFC-1970]). This could save unneeded neighbor solicitations and neighbor advertisements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPアプリケーションが前方に所定のピア（[RFC-1970]のセクション7.3.1）と進展しているカーネルに通知するための標準的な方法が望ましいかもしれません。これは、不要な近隣要請と近隣広告を救うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Summary of New Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
新しい定義の概要13
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following list summarizes the constants and structure, definitions discussed in this memo, sorted by header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のリストは、ヘッダによってソート定数と構造、このメモで議論定義をまとめたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_ADDR &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_ADMIN &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_NOPORT &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_NOROUTE &lt;netinet/icmp6.h&gt; ICMP6_DST_UNREACH_NOTNEIGHBOR &lt;netinet/icmp6.h&gt; ICMP6_ECHO_REPLY &lt;netinet/icmp6.h&gt; ICMP6_ECHO_REQUEST &lt;netinet/icmp6.h&gt; ICMP6_INFOMSG_MASK &lt;netinet/icmp6.h&gt; ICMP6_MEMBERSHIP_QUERY &lt;netinet/icmp6.h&gt; ICMP6_MEMBERSHIP_REDUCTION &lt;netinet/icmp6.h&gt; ICMP6_MEMBERSHIP_REPORT &lt;netinet/icmp6.h&gt; ICMP6_PACKET_TOO_BIG &lt;netinet/icmp6.h&gt; ICMP6_PARAMPROB_HEADER &lt;netinet/icmp6.h&gt; ICMP6_PARAMPROB_NEXTHEADER &lt;netinet/icmp6.h&gt; ICMP6_PARAMPROB_OPTION &lt;netinet/icmp6.h&gt; ICMP6_PARAM_PROB &lt;netinet/icmp6.h&gt; ICMP6_TIME_EXCEEDED &lt;netinet/icmp6.h&gt; ICMP6_TIME_EXCEED_REASSEMBLY &lt;netinet/icmp6.h&gt; ICMP6_TIME_EXCEED_TRANSIT &lt;netinet/icmp6.h&gt; ND_NA_FLAG_OVERRIDE &lt;netinet/icmp6.h&gt; ND_NA_FLAG_ROUTER &lt;netinet/icmp6.h&gt; ND_NA_FLAG_SOLICITED &lt;netinet/icmp6.h&gt; ND_NEIGHBOR_ADVERT &lt;netinet/icmp6.h&gt; ND_NEIGHBOR_SOLICIT &lt;netinet/icmp6.h&gt; ND_OPT_MTU &lt;netinet/icmp6.h&gt; ND_OPT_PI_FLAG_AUTO &lt;netinet/icmp6.h&gt; ND_OPT_PI_FLAG_ONLINK &lt;netinet/icmp6.h&gt; ND_OPT_PREFIX_INFORMATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;netinetの/ icmp6.h&gt; ICMP6_DST_UNREACH &lt;netinetの/ icmp6.h&gt; ICMP6_DST_UNREACH_ADDR &lt;netinetの/ icmp6.h&gt; ICMP6_DST_UNREACH_ADMIN &lt;netinetの/ icmp6.h&gt; ICMP6_DST_UNREACH_NOPORT &lt;netinetの/ icmp6.h&gt; ICMP6_DST_UNREACH_NOROUTE &lt;netinetの/ icmp6.h&gt; ICMP6_DST_UNREACH_NOTNEIGHBOR &lt;netinetの/icmp6.h&gt; ICMP6_ECHO_REPLY &lt;netinetの/ icmp6.h&gt; ICMP6_ECHO_REQUEST &lt;netinetの/ icmp6.h&gt; ICMP6_INFOMSG_MASK &lt;netinetの/ icmp6.h&gt; ICMP6_MEMBERSHIP_QUERY &lt;netinetの/ icmp6.h&gt; ICMP6_MEMBERSHIP_REDUCTION &lt;netinetの/ icmp6.h&gt; ICMP6_MEMBERSHIP_REPORT &lt;netinetの/ ICMP6 .H&gt; ICMP6_PACKET_TOO_BIG &lt;netinetの/ icmp6.h&gt; ICMP6_PARAMPROB_HEADER &lt;netinetの/ icmp6.h&gt; ICMP6_PARAMPROB_NEXTHEADER &lt;netinetの/ icmp6.h&gt; ICMP6_PARAMPROB_OPTION &lt;netinetの/ icmp6.h&gt; ICMP6_PARAM_PROB &lt;netinetの/ icmp6.h&gt; ICMP6_TIME_EXCEEDED &lt;netinetの/ icmp6.h &gt; ICMP6_TIME_EXCEED_REASSEMBLY &lt;netinetの/ icmp6.h&gt; ICMP6_TIME_EXCEED_TRANSIT &lt;netinetの/ icmp6.h&gt; ND_NA_FLAG_OVERRIDE &lt;netinetの/ icmp6.h&gt; ND_NA_FLAG_ROUTER &lt;netinetの/ icmp6.h&gt; ND_NA_FLAG_SOLICITED &lt;netinetの/ icmp6.h&gt; ND_NEIGHBOR_ADVERT &lt;netinetの/ icmp6.h&gt; ND_NEIGHBOR _SOLICIT &lt;netinetの/ icmp6.h&gt; ND_OPT_MTU &lt;netinetの/ icmp6.h&gt; ND_OPT_PI_FLAG_AUTO &lt;netinetの/ icmp6.h&gt; ND_OPT_PI_FLAG_ONLINK &lt;netinetの/ icmp6.h&gt; ND_OPT_PREFIX_INFORMATION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;netinet/icmp6.h&gt; ND_OPT_REDIRECTED_HEADER &lt;netinet/icmp6.h&gt; ND_OPT_SOURCE_LINKADDR &lt;netinet/icmp6.h&gt; ND_OPT_TARGET_LINKADDR &lt;netinet/icmp6.h&gt; ND_RA_FLAG_MANAGED &lt;netinet/icmp6.h&gt; ND_RA_FLAG_OTHER &lt;netinet/icmp6.h&gt; ND_REDIRECT &lt;netinet/icmp6.h&gt; ND_ROUTER_ADVERT &lt;netinet/icmp6.h&gt; ND_ROUTER_SOLICIT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;netinetの/ icmp6.h&gt; ND_OPT_REDIRECTED_HEADER &lt;netinetの/ icmp6.h&gt; ND_OPT_SOURCE_LINKADDR &lt;netinetの/ icmp6.h&gt; ND_OPT_TARGET_LINKADDR &lt;netinetの/ icmp6.h&gt; ND_RA_FLAG_MANAGED &lt;netinetの/ icmp6.h&gt; ND_RA_FLAG_OTHER &lt;netinetの/ icmp6.h&gt; ND_REDIRECT &lt;netinetの/icmp6.h&gt; ND_ROUTER_ADVERT &lt;netinetの/ icmp6.h&gt; ND_ROUTER_SOLICIT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;netinet/icmp6.h&gt; struct icmp6_filter{};
     &lt;netinet/icmp6.h&gt; struct icmp6_hdr{};
     &lt;netinet/icmp6.h&gt; struct nd_neighbor_advert{};
     &lt;netinet/icmp6.h&gt; struct nd_neighbor_solicit{};
     &lt;netinet/icmp6.h&gt; struct nd_opt_hdr{};
     &lt;netinet/icmp6.h&gt; struct nd_opt_mtu{};
     &lt;netinet/icmp6.h&gt; struct nd_opt_prefix_info{};
     &lt;netinet/icmp6.h&gt; struct nd_opt_rd_hdr{};
     &lt;netinet/icmp6.h&gt; struct nd_redirect{};
     &lt;netinet/icmp6.h&gt; struct nd_router_advert{};
     &lt;netinet/icmp6.h&gt; struct nd_router_solicit{};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;netinet/in.h&gt; IPPROTO_AH &lt;netinet/in.h&gt; IPPROTO_DSTOPTS &lt;netinet/in.h&gt; IPPROTO_ESP &lt;netinet/in.h&gt; IPPROTO_FRAGMENT &lt;netinet/in.h&gt; IPPROTO_HOPOPTS &lt;netinet/in.h&gt; IPPROTO_ICMPV6 &lt;netinet/in.h&gt; IPPROTO_IPV6 &lt;netinet/in.h&gt; IPPROTO_NONE &lt;netinet/in.h&gt; IPPROTO_ROUTING &lt;netinet/in.h&gt; IPV6_DSTOPTS &lt;netinet/in.h&gt; IPV6_HOPLIMIT &lt;netinet/in.h&gt; IPV6_HOPOPTS &lt;netinet/in.h&gt; IPV6_NEXTHOP &lt;netinet/in.h&gt; IPV6_PKTINFO &lt;netinet/in.h&gt; IPV6_PKTOPTIONS &lt;netinet/in.h&gt; IPV6_RTHDR &lt;netinet/in.h&gt; IPV6_RTHDR_LOOSE &lt;netinet/in.h&gt; IPV6_RTHDR_STRICT &lt;netinet/in.h&gt; IPV6_RTHDR_TYPE_0 &lt;netinet/in.h&gt; struct in6_pktinfo{};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;netinetの/ in.h&gt; IPPROTO_AH &lt;netinetの/ in.h&gt; IPPROTO_DSTOPTS &lt;netinetの/ in.h&gt; IPPROTO_ESP &lt;netinetの/ in.h&gt; IPPROTO_FRAGMENT &lt;netinetの/ in.h&gt; IPPROTO_HOPOPTS &lt;netinetの/ in.h&gt; IPPROTO_ICMPV6 &lt;netinetの/in.h&gt; IPPROTO_IPV6 &lt;netinetの/ in.h&gt; IPPROTO_NONE &lt;netinetの/ in.h&gt; IPPROTO_ROUTING &lt;netinetの/ in.h&gt; IPV6_DSTOPTS &lt;netinetの/ in.h&gt; IPV6_HOPLIMIT &lt;netinetの/ in.h&gt; IPV6_HOPOPTS &lt;netinetの/に.H&gt; IPV6_NEXTHOP &lt;netinetの/ in.h&gt; IPV6_PKTINFO &lt;netinetの/ in.h&gt; IPV6_PKTOPTIONS &lt;netinetの/ in.h&gt; IPV6_RTHDR &lt;netinetの/ in.h&gt; IPV6_RTHDR_LOOSE &lt;netinetの/ in.h&gt; IPV6_RTHDR_STRICT &lt;netinetの/ in.h &gt; IPV6_RTHDR_TYPE_0 &lt;netinetの/ in.h&gt;構造体in6_pktinfo {}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;netinet/ip6.h&gt;   IP6F_OFF_MASK
     &lt;netinet/ip6.h&gt;   IP6F_RESERVED_MASK
     &lt;netinet/ip6.h&gt;   IP6F_MORE_FRAG
     &lt;netinet/ip6.h&gt;   struct ip6_dest{};
     &lt;netinet/ip6.h&gt;   struct ip6_frag{};
     &lt;netinet/ip6.h&gt;   struct ip6_hbh{};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;netinet/ip6.h&gt;   struct ip6_hdr{};
     &lt;netinet/ip6.h&gt;   struct ip6_rthdr{};
     &lt;netinet/ip6.h&gt;   struct ip6_rthdr0{};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;sys/socket.h&gt;    struct cmsghdr{};
     &lt;sys/socket.h&gt;    struct msghdr{};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のリストは、ヘッダによってソートこのメモで議論機能とマクロプロトタイプをまとめたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
&lt;netinet/icmp6.h&gt; void ICMP6_FILTER_SETBLOCK(int,
                                                struct icmp6_filter *);
&lt;netinet/icmp6.h&gt; void ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);
&lt;netinet/icmp6.h&gt; void ICMP6_FILTER_SETPASS(int, struct icmp6_filter *);
&lt;netinet/icmp6.h&gt; void ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);
&lt;netinet/icmp6.h&gt; int  ICMP6_FILTER_WILLBLOCK(int,
                                           const struct icmp6_filter *);
&lt;netinet/icmp6.h&gt; int  ICMP6_FILTER_WILLPASS(int,
                                           const struct icmp6_filter *);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
&lt;netinet/in.h&gt; int IN6_ARE_ADDR_EQUAL(const struct in6_addr *, const struct in6_addr *);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
&lt;netinetの/ in.h&gt; INT IN6_ARE_ADDR_EQUAL（constの構造体のin6_addr *、constの構造体のin6_addr *）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
&lt;netinet/in.h&gt;    uint8_t *inet6_option_alloc(struct cmsghdr *,
                                               int, int, int);
&lt;netinet/in.h&gt;    int inet6_option_append(struct cmsghdr *,
                                          const uint8_t *, int, int);
&lt;netinet/in.h&gt;    int inet6_option_find(const struct cmsghdr *,
                                        uint8_t *, int);
&lt;netinet/in.h&gt;    int inet6_option_init(void *, struct cmsghdr **, int);
&lt;netinet/in.h&gt;    int inet6_option_next(const struct cmsghdr *,
                                        uint8_t **);
&lt;netinet/in.h&gt;    int inet6_option_space(int);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
&lt;netinet/in.h&gt;    int inet6_rthdr_add(struct cmsghdr *,
                                      const struct in6_addr *,
                                      unsigned int);
&lt;netinet/in.h&gt;    struct in6_addr inet6_rthdr_getaddr(struct cmsghdr *,
                                                      int);
&lt;netinet/in.h&gt;    int inet6_rthdr_getflags(const struct cmsghdr *, int);
&lt;netinet/in.h&gt;    struct cmsghdr *inet6_rthdr_init(void *, int);
&lt;netinet/in.h&gt;    int inet6_rthdr_lasthop(struct cmsghdr *,
                                                          unsigned int);
&lt;netinet/in.h&gt;    int inet6_rthdr_reverse(const struct cmsghdr *,
                                          struct cmsghdr *);
&lt;netinet/in.h&gt;    int inet6_rthdr_segments(const struct cmsghdr *);
&lt;netinet/in.h&gt;    size_t inet6_rthdr_space(int, int);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
&lt;sys/socket.h&gt;    unsigned char *CMSG_DATA(const struct cmsghdr *);
&lt;sys/socket.h&gt;    struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr *);
&lt;sys/socket.h&gt;    unsigned int CMSG_LEN(unsigned int);
&lt;sys/socket.h&gt;    struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,
                                              const struct cmsghdr *);
&lt;sys/socket.h&gt;    unsigned int CMSG_SPACE(unsigned int);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
&lt;unistd.h&gt; int rresvport_af(int *, int);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
&lt;Unistd.h&gt;あなたrresvport_af（あなた*、あなた）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The setting of certain Hop-by-Hop options and Destination options may be restricted to privileged processes. Similarly some Hop-by-Hop options and Destination options may not be returned to nonprivileged applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一定のホップバイホップオプションと宛先オプションの設定は特権プロセスに制限することができます。同様に、いくつかのホップバイホップオプションと宛先オプションは、非特権アプリケーションに返されないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Change History
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.変更履歴
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changes from the June 1997 Edition (-03 draft)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1997年6月版からの変更点（-03案）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added a note that defined constants for multibyte fields are in network byte order. This affects the ip6f_offlg member of the Fragment header (Section 2.1.2) and the nd_na_flags_reserved member of the nd_neighbor_advert structure (Section 2.2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - マルチバイトフィールドの定数はネットワークバイトオーダーにある定義されたノートを追加しました。これは、フラグメントヘッダ（セクション2.1.2）のip6f_offlg部材とnd_neighbor_advert構造（セクション2.2.2）のnd_na_flags_reservedメンバーに影響を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 5: the ipi6_ifindex member of the in6_pktinfo structure should be &#34;unsigned int&#34; instead of &#34;int&#34;, for consistency with the interface indexes in [RFC-2133].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション5：in6_pktinfo構造のipi6_ifindex部材は、[RFC-2133]におけるインターフェースインデックスとの整合のために代わりに「INT」の「unsigned int型」であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 6.3.7: the three calls to inet6_option_space() in the examples needed to be arguments to malloc(). The final one of these was missing the &#34;6&#34; in the name &#34;inet6_option_space&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  6.3.7項：inet6_option_spaceへの3つの呼び出し（）はmallocの引数（なるために必要な例で）。これらの最後の一つが「6」の名前で「inet6_option_spaceを」行方不明になりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 8.6: the function prototype for inet6_rthdr_segments() was missing the ending semicolon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション8.6：inet6_rthdr_segmentsの関数プロトタイプは、（）の終了セミコロンがありませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changes from the March 1997 Edition (-02 draft)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1997年3月版からの変更点（-02案）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- In May 1997 Draft 6.6 of Posix 1003.1g (called Posix.1g herein) passed ballot and will be forwarded to the IEEE Standards Board later in 1997 for final approval. Some changes made for this final Posix draft are incorporated into this Internet Draft, specifically the datatypes mentioned in Section 1 (and used throughout the text), and the socklen_t datatype used in Section 4.1 and 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  1997年5月（ここPosix.1gと呼ばれる）のPosix 1003.1グラムのドラフト6.6には、投票用紙を渡され、最終承認のために、後に1997年にIEEE標準化委員会に転送されます。この最終のPosixドラフトのために作られたいくつかの変更は、このインターネットドラフト、セクション1（及びテキストを通して使用される）に記載された具体的データ型、およびセクション4.1および4.2で使用されるのsocklen_tデータ型に組み込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 1: Added the intN_t signed datatypes, changed the datatype u_intN_t to uintN_t (no underscore after the &#34;u&#34;), and removed the datatype u_intNm_t, as per Draft 6.6 of Posix.1g.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション1：追加intN_tはデータ型に署名し、（「U」の後には下線）uintN_tにデータ型u_intN_tを変えず、Posix.1gのドラフト6.6に従って、データ型u_intNm_tを除去します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Name space issues for structure and constant names in Section 2: Many of the structure member names and constant names were changed so that the prefixes are the same. The following prefixes are used for structure members: &#34;ip6_&#34;, &#34;icmp6_&#34;, and &#34;nd_&#34;. All constants have the prefixes &#34;ICMP6_&#34; and &#34;ND_&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 第2節での構造や定数名のネームスペースの問題：プレフィックスが同じになるように構造体のメンバ名と定数名の多くが変更されました。 「ip6_」、「icmp6_」、および「nd_」：次の接頭辞は、構造体のメンバーのために使用されています。すべての定数は、接頭辞「ICMP6_」と「ND_」を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- New definitions: Section 2.1.2: contains definitions for the IPv6 extension headers, other than AH and ESP. Section 2.2.2: contains additional structures and constants for the neighbor discovery option header and redirected header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 新しい定義：セクション2.1.2：AHとESP以外の、IPv6拡張ヘッダーの定義が含まれています。 2.2.2項は：近隣探索オプションヘッダとリダイレクトヘッダのための追加の構造と定数が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 2.2.2: the enum for the neighbor discovery option field was changed to be a set of #define constants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション2.2.2：近隣探索オプションフィールドの列挙がの#define定数のセットに変更されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed the word &#34;function&#34; to &#34;macro&#34; for references to all the uppercase names in Sections 2.3 (IN6_ARE_ADDR_EQUAL), 3.2 (ICMPV6_FILTER_xxx), and 4.3 (CMSG_xxx).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション2.3（IN6_ARE_ADDR_EQUAL）内のすべての大文字の名前を参照するための「マクロ」、3.2（ICMPV6_FILTER_xxx）、および4.3（CMSG_xxx）に単語「機能」に変更。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added more protocols to the /etc/protocols file (Section 2.4) and changed the name of &#34;icmpv6&#34; to &#34;ipv6-icmp&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - の/ etc / protocolsファイル（2.4節）に複数のプロトコルを追加し、 &#34;ICMPv6の&#34; への &#34;IPv6-ICMP&#34; の名称を変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 3: Made it more explicit that an application cannot read or write entire IPv6 packets, that all extension headers are passed as ancillary data. Added a sentence that the kernel fragments packets written to an IPv6 raw socket when necessary. Added a note that IPPROTO_RAW raw IPv6 sockets are not special.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 第3節：すべての拡張ヘッダは、補助データとして渡されていることを、アプリケーション全体のIPv6パケットを読み取りまたは書き込みができないこと、それは、より明確なメイド。必要なカーネルフラグメントパケットがIPv6生ソケットに書き込まれたという文を追加しました。 IPPROTO_RAW生のIPv6ソケットが特別ではないことに注意してくださいを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 3.1: Explicitly stated that the checksum option applies to both outgoing packets and received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション3.1：明示的にチェックサムオプションが発信パケットと受信パケットの両方に適用されると述べました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 3.2: Changed the array name within the icmp6_filter structure from &#34;data&#34; to &#34;icmp6_filt&#34;. Changes the prefix for the filter macros from &#34;ICMPV6_&#34; to &#34;ICMP6_&#34;, for consistency with the names in Section 2.2. Changed the example from a ping program to a program that wants to receive only router advertisements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション3.2：「icmp6_filt」に「データ」からicmp6_filter構造内の配列名を変更しました。 2.2節内の名前との整合性のために、「ICMP6_」を「ICMPV6_」からフィルタマクロの接頭辞を変更します。のみルータ広告を受信したいプログラムへのpingプログラムからの例を変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 4.1: Changed msg_namelen and msg_controllen from size_t to the Posix.1g socklen_t datatype. Updated the Note that follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション4.1：msg_namelen変更とPosix.1gのsocklen_tデータ型にsize_t型からmsg_controllen。以下の注意事項を更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 4.2: Changed cmsg_len from size_t to the Posix.1g socklen_t datatype. Updated the Note that follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション4.2：Posix.1gのsocklen_tデータ型にsize_t型からCMSG_LEN変更しました。以下の注意事項を更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 4.4: Added a Note that the second and third arguments to getsockopt() and setsockopt() are intentionally the same as the cmsg_level and cmsg_type members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション4.4：第二および第三の引き数はGETSOCKOPTすることが追加された注（）とのsetsockopt（）意図cmsg_levelメンバとcmsg_typeメンバーと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 4.5: Reorganized the section into a description of the option, followed by the TCP semantics, and the UDP and raw socket semantics. Added a sentence on how to clear all the sticky options. Added a note that TCP need not save the options from the most recently received segment until the application says to do so. Added the statement that ancillary data is never passed with sendmsg() or recvmsg() on a TCP socket. Simplified the interaction of the sticky options with ancillary data for UDP or raw IP: none of the sticky options are sent if ancillary data is specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション4.5：TCP意味論が続くオプションの説明にセクション、およびUDPと生ソケットのセマンティクスを再編成しました。すべてのスティッキオプションをオフにする方法についての文を追加しました。 TCPは、アプリケーションがそうするようにと言うまで、最も最近に受信したセグメントからオプションを保存する必要はないことに注意を追加。補助データは、TCPソケット上にsendmsg（）またはのrecvmsg（）に渡されることはありませんという文を追加しました。 UDPまたはRaw IPのための補助的なデータを持つ粘着性のオプションの相互作用を簡素化された：補助データが指定されている場合はスティッキーオプションのいずれも送信されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Final paragraph of Section 5.1: ipi6_index should be ipi6_ifindex.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  5.1節の最後の段落：ipi6_indexがipi6_ifindexする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 5.4: Added a note on the term &#34;privileged&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション5.4：「特権」という用語に注釈を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 5.5: Noted that the errors listed are examples, and the actual errors depend on the implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション5.5：リストされたエラーは一例であり、実際のエラーは、実装に依存していることを指摘しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Removed Section 6 (&#34;Flow Labels&#34;) as the consensus is that it is premature to try and specify an API for this feature. Access to the flow label field in the IPv6 header is still provided through the sin6_flowinfo member of the IPv6 socket address structure in [RFC-2133]. Added a subsection to Section 13 that this is a future item.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - コンセンサスとして除去する第6章（「フローラベル」）は、しようとすると、この機能のためのAPIを指定するのは時期尚早であるということです。 IPv6ヘッダのフロー・ラベル・フィールドへのアクセスは依然として[RFC-2133]でIPv6のソケットアドレス構造のsin6_flowinfo部材を介して設けられています。これは将来のアイテムである第13のサブセクションを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
All remaining changes are identified by their section number in the previous draft. With the removal of Section 6, the section numbers are decremented by one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
残りのすべての変更は、以前のドラフトでのセクション番号で識別されます。第6節の除去と、セクション番号が1ずつ減少しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 7.3.7: the calls to malloc() in all three examples should be calls to inet6_option_space() instead. The two calls to inet6_option_append() in the third example should be calls to inet6_option_alloc(). The two calls to CMSG_SPACE() in the first and third examples should be calls to CMSG_LEN(). The second call to CMSG_SPACE() in the second example should be a call to CMSG_LEN().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション7.3.7：すべての3つの例ではmalloc（）への呼び出しではなく）（呼び出しがinet6_option_spaceしなければなりません。第三の例でinet6_option_appendするための2つの呼び出しは、（））（inet6_option_allocへの呼び出しであるべきです。第一及び第三の実施例におけるCMSG_SPACEへの2つの呼び出しは（））（CMSG_LENへの呼び出しであるべきです。第二の例でCMSG_SPACEに2回目の呼び出しは、（）CMSG_LENへの呼び出しであるべきです（）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Section 7.3.7: All the opt_X_ and opt_Y_ structure member names were changed to be ip6_X_opt_ and ip6_Y_opt_. The two structure names ipv6_opt_X and ipv6_opt_Y were changed to ip6_X_opt and ip6_Y_opt. The constants beginning with IPV6_OPT_X_ and IPV6_OPT_Y_ were changed to begin with IP6_X_OPT_ and IP6_Y_OPT_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション7.3.7：すべてopt_X_とopt_Y_構造体メンバ名はip6_X_opt_とip6_Y_opt_に変更されました。 2構造名ipv6_opt_Xとipv6_opt_Yはip6_X_optとip6_Y_optに変更しました。 IPV6_OPT_X_とIPV6_OPT_Y_で始まる定数はIP6_X_OPT_とIP6_Y_OPT_で始まるように変更されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Use the term &#34;Routing header&#34; throughout the draft, instead of &#34;source routing&#34;. Changed the names of the eight inet6_srcrt_XXX() functions in Section 9 to inet6_rthdr_XXX(). Changed the name of the socket option from IPV6_SRCRT to IPV6_RTHDR, and the names of the three IPV6_SRCRT_xxx constants in Section 9 to IPV6_RTHDR_xxx.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 代わりに、「ソース・ルーティング」のドラフト全体用語「ルーティングヘッダ」を使用。 inet6_rthdr_XXXに9節で8 inet6_srcrt_XXX（）関数の名前を変更しました（）。 IPV6_RTHDRへIPV6_SRCRTからソケットオプション、およびIPV6_RTHDR_xxxに第9節で3つのIPV6_SRCRT_xxx定数の名前の名前を変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added a paragraph to Section 9 on how to receive and send a Routing header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - ルーティングヘッダを受信して​​送信する方法については、セクション9に段落を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed inet6_rthdr_add() and inet6_rthdr_reverse() so that they return -1 upon an error, instead of an Exxx errno value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 彼らが返すよう-1エラー時に、代わりExxxのerrno値の（inet6_rthdr_add変更）とinet6_rthdr_reverse（）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- In the description of inet6_rthdr_space() in Section 9.1, added the qualifier &#34;For an IPv6 Type 0 Routing header&#34; to the restriction of between 1 and 23 segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション9.1でinet6_rthdr_space（）の説明では、1〜23のセグメントの制限への「IPv6タイプ0ルーティングヘッダの」修飾子を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Refer to final function argument in Sections 9.7 and 9.8 as index, not offset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション指標として9.7と9.8の最後の関数の引数を参照して、オフセットしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Updated Section 14 with new names from Section 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 第2節から新しい名前で、セクション14を更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed the References from &#34;[n]&#34; to &#34;[RFC-abcd]&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - に &#34;[RFC-ABCD]&#34; &#34;[N]&#34; からの参照を変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changes from the February 1997 Edition (-01 draft)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1997年2月版からの変更点（-01案）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed the name of the ip6hdr structure to ip6_hdr (Section 2.1) for consistency with the icmp6hdr structure. Also changed the name of the ip6hdrctl structure contained within the ip6_hdr structure to ip6_hdrctl (Section 2.1). Finally, changed the name of the icmp6hdr structure to icmp6_hdr (Section 2.2). All other occurrences of this structure name, within the Neighbor Discovery structures in Section 2.2.1, already contained the underscore.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  icmp6hdr構造との整合性のために（セクション2.1）ip6_hdrするip6hdr構造の名前を変更しました。また、（セクション2.1）ip6_hdrctlするip6_hdr構造内に含まれるip6hdrctl構造の名前を変更しました。最後に、（2.2節）をicmp6_hdrするicmp6hdr構造の名称を変更しました。この構造体名の他のすべての出現は、2.2.1節で近隣探索構造の中に、すでにアンダースコアが含まれていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- The &#34;struct nd_router_solicit&#34; and &#34;struct nd_router_advert&#34; should both begin with &#34;nd6_&#34;. (Section 2.2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 「構造体nd_router_solicit」と「構造体nd_router_advertは」両方「nd6_」で始める必要があります。 （2.2.2項）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed the name of in6_are_addr_equal to IN6_ARE_ADDR_EQUAL (Section 2.3) for consistency with basic API address testing functions. The header defining this macro is &lt;netinet/in.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 基本的なAPIアドレス・テスト機能との整合性を保つためにIN6_ARE_ADDR_EQUAL（2.3節）にin6_are_addr_equalの名前を変更しました。このマクロを定義するヘッダは、&lt;netinetの/ in.h&gt;です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- getprotobyname(&#34;ipv6&#34;) now returns 41, not 0 (Section 2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  getprotobyname（ &#34;IPv6は&#34;）、今ではない0（2.4節）、41を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- The first occurrence of &#34;struct icmpv6_filter&#34; in Section 3.2 should be &#34;struct icmp6_filter&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション3.2の「構造体icmpv6_filter」の最初の発生は、「構造体icmp6_filter」でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    -  Changed the name of the CMSG_LENGTH() macro to CMSG_LEN()
       (Section 4.3.5), since LEN is used throughout the &lt;netinet/*.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ヘッダ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Corrected the argument name for the sample implementations of the CMSG_SPACE() and CMSG_LEN() macros to be &#34;length&#34; (Sections 4.3.4 and 4.3.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 「長さ」（セクション4.3.4および4.3.5）であることをCMSG_SPACE（）とCMSG_LEN（）マクロのサンプルの実装のための引数名を修正しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Corrected the socket option mentioned in Section 5.1 to specify the interface for multicasting from IPV6_ADD_MEMBERSHIP to IPV6_MULTICAST_IF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  IPV6_ADD_MEMBERSHIPからIPV6_MULTICAST_IFにマルチキャストするためのインターフェイスを指定するには、セクション5.1で述べたソケットオプションを修正しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- There were numerous errors in the previous draft that specified &lt;netinet/ip6.h&gt; that should have been &lt;netinet/in.h&gt;. These have all been corrected and the locations of all definitions is now summarized in the new Section 14 (&#34;Summary of New Definitions&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - されている必要があります。&lt;netinetの/ ip6.h&gt;指定された前回のドラフト&lt;netinetの/ in.h&gt;には多くの誤りがありました。これらはすべて修正されていると、すべての定義の位置は今、新たな第14条（「新しい定義の概要」）にまとめられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Changes from the October 1996 Edition (-00 draft)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1996年10月版からの変更点（-00案）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Numerous rationale added using the format (Note: ...).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
（：...注意してください） - 多くの理論的根拠は、形式を使用して追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added note that not all errors may be defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - すべてのエラーを定義することができないノートを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added note about ICMPv4, IGMPv4, and ARPv4 terminology.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  ICMPv4の、IGMPv4、およびARPv4の用語についての注意事項を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed the name of &lt;netinet/ip6_icmp.h&gt; to &lt;netinet/icmp6.h&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  &lt;netinetの/ icmp6.h&gt;に&lt;netinetの/ ip6_icmp.h&gt;の名前を変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed some names in Section 2.2.1: ICMPV6_PKT_TOOBIG to ICMPV6_PACKET_TOOBIG, ICMPV6_TIME_EXCEED to ICMPV6_TIME_EXCEEDED, ICMPV6_ECHORQST to ICMPV6_ECHOREQUEST, ICMPV6_ECHORPLY to ICMPV6_ECHOREPLY, ICMPV6_PARAMPROB_HDR to ICMPV6_PARAMPROB_HEADER, ICMPV6_PARAMPROB_NXT_HDR to ICMPV6_PARAMPROB_NEXTHEADER, and ICMPV6_PARAMPROB_OPTS to ICMPV6_PARAMPROB_OPTION.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
ICMPV6_PARAMPROB_OPTIONにICMPV6_PARAMPROB_NEXTHEADERにICMPV6_PARAMPROB_HEADER、ICMPV6_PARAMPROB_NXT_HDRにICMPV6_ECHOREPLY、ICMPV6_PARAMPROB_HDRにICMPV6_ECHOREQUEST、ICMPV6_ECHORPLYにICMPV6_TIME_EXCEEDED、ICMPV6_ECHORQSTにICMPV6_PACKET_TOOBIG、ICMPV6_TIME_EXCEEDにICMPV6_PKT_TOOBIG、およびICMPV6_PARAMPROB_OPTS： - セクション2.2.1でいくつかの名前を変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Prepend the prefix &#34;icmp6_&#34; to the three members of the icmp6_dataun union of the icmp6hdr structure (Section 2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  icmp6hdr構造（2.2節）のicmp6_dataun組合の三の者に接頭辞「icmp6_」を前に追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Moved the neighbor discovery definitions into the &lt;netinet/icmp6.h&gt; header, instead of being in their own header (Section 2.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 代わりに独自のヘッダ（セクション2.2.1）であることの、&lt;netinetの/ icmp6.h&gt;ヘッダに近隣探索定義を動かしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed Section 2.3 (&#34;Address Testing&#34;). The basic macros are now in the basic API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 変更セクション2.3（ &#34;アドレステスト&#34;）。基本的なマクロは、基本的なAPIになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added the new Section 2.4 on &#34;Protocols File&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 「プロトコルファイル」に新しいセクション2.4が追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added note to raw sockets description that something like BPF or DLPI must be used to read or write entire IPv6 packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  BPFやDLPIのようなものが全体のIPv6パケットを読み書きするために使用されなければならないrawソケットの説明にメモを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Corrected example of IPV6_CHECKSUM socket option (Section 3.1). Also defined value of -1 to disable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  IPV6_CHECKSUMソケットオプション（3.1節）の一例を修正しました。また、無効にするには、-1の値を定義しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Noted that &lt;netinet/icmp6.h&gt; defines all the ICMPv6 filtering constants, macros, and structures (Section 3.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  &lt;netinetの/ icmp6.h&gt;は、すべてのICMPv6フィルタリング定数、マクロ、および構造（セクション3.2）を定義することに留意しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added note on magic number 10240 for amount of ancillary data (Section 4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 補助データの量のためのマジックナンバー10240上の注意事項を追加しました（4.1節）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added possible padding to picture of ancillary data (Section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 補助データ（セクション4.2）の画像に可能なパディングを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Defined &lt;sys/socket.h&gt; header for CMSG_xxx() functions (Section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 定義は&lt;sys / socket.h&gt;にCMSG_xxxのヘッダ（）関数（4.2節）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Note that the data returned by getsockopt(IPV6_PKTOPTIONS) for a TCP socket is just from the optional headers, if present, of the most recently received segment. Also note that control information is never returned by recvmsg() for a TCP socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 存在する場合、TCPソケットのためのgetsockopt（IPV6_PKTOPTIONS）によって返されるデータは、最も最近に受信したセグメントを、単にオプションヘッダからであることに留意されたいです。また、制御情報は、TCPソケット用のrecvmsg（）によって返されることはありませんので注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed header for struct in6_pktinfo from &lt;netinet.in.h&gt; to &lt;netinet/ip6.h&gt; (Section 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  &lt;netinetの/ ip6.h&gt;（セクション5）に&lt;netinet.in.h&gt;から構造体in6_pktinfoのヘッダを変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Removed the old Sections 5.1 and 5.2, because the interface identification functions went into the basic API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - インタフェース識別機能は、基本的なAPIに入ったので、古いセクション5.1と5.2を削除しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Redid Section 5 to support the hop limit field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - やり直し第5節では、ホップ制限フィールドをサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- New Section 5.4 (&#34;Next Hop Address&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 新しいセクション5.4（「ネクストホップアドレス」）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- New Section 6 (&#34;Flow Labels&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 新しいセクション6（ &#34;フローラベル&#34;）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed all of Sections 7 and 8 dealing with Hop-by-Hop and Destination options. We now define a set of inet6_option_XXX() functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - セクション7と8のすべてがバイホップホップと宛先オプションを扱う変更しました。私たちは今、inet6_option_XXX（）関数のセットを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Changed header for IPV6_SRCRT_xxx constants from &lt;netinet.in.h&gt; to &lt;netinet/ip6.h&gt; (Section 9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  &lt;netinet.in.h&gt;から&lt;netinetの/ ip6.h&gt;にIPV6_SRCRT_xxx定数の変更ヘッダ（項9）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Add inet6_rthdr_lasthop() function, and fix errors in description of Routing header (Section 9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  inet6_rthdr_lasthop（）関数を追加し、ヘッダ（セクション9）ルーティングの説明でエラーを修正。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Reworded some of the Routing header descriptions to conform to the terminology in [RFC-1883].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 -  [RFC-1883]における用語に一致するように、ルーティングヘッダの説明の一部を言い換え。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Added the example from [RFC-1883] for the Routing header (Section 9.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - ルーティングヘッダ（セクション9.9）のために[RFC-1883]からの例を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Expanded the example in Section 10 to show multiple options per ancillary data object, and to show the receiver&#39;s ancillary data objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 補助データ・オブジェクトごとに複数のオプションを表示し、受信機の補助データオブジェクトを表示する第10の例を拡大しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- New Section 11 (&#34;IPv6-Specific Options with IPv4-Mapped IPv6 Addresses&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 新しいセクション11（「IPv4射影IPv6アドレスとIPv6固有のオプション」）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- New Section 12 (&#34;rresvport_af&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - 新しいセクション12（ &#34;rresvport_af&#34;）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
- Redid old Section 10 (&#34;Additional Items&#34;) into new Section 13 (&#34;Future Items&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 - やり直し古いセクション10の新しいセクション13（「将来のアイテム」）への（「追加アイテム」）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1883] Deering, S., and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6), Specification&#34;, RFC 1883, December 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1883]デアリング、S.、およびR. Hindenと、 &#34;インターネットプロトコルバージョン6（IPv6）の、仕様&#34;、RFC 1883、1995年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-2133] Gilligan, R., Thomson, S., Bound, J., and W. Stevens, &#34;Basic Socket Interface Extensions for IPv6&#34;, RFC 2133, April 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-2133]ギリガン、R.、トムソン、S.、バウンド、J.、およびW.スティーブンス、 &#34;IPv6の基本的なソケットインタフェース拡張&#34;、RFC 2133、1997年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1981] McCann, J., Deering, S., and J. Mogul, &#34;Path MTU Discovery for IP version 6&#34;, RFC 1981, August 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1981]マッキャン、J.、デアリング、S.、およびJ.モーグル、 &#34;経路MTUディスカバリIPバージョン6&#34;、RFC 1981、1996年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1970] Narten, T., Nordmark, E., and W. Simpson, &#34;Neighbor Discovery for IP Version 6 (IPv6)&#34;, RFC 1970, August 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC-1970] Narten氏、T.、Nordmarkと、E.、およびW.シンプソン、 &#34;IPバージョン6（IPv6）のための近隣探索&#34;、RFC 1970、1996年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Matt Thomas and Jim Bound have been working on the technical details in this draft for over a year. Keith Sklower is the original implementor of ancillary data in the BSD networking code. Craig Metz provided lots of feedback, suggestions, and comments based on his implementing many of these features as the document was being written.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バウンドマット・トーマスとジムは一年以上、この草稿で技術的な詳細に取り組んできました。キースSklowerはBSDのネットワークコードにおける補助データの元の実装です。クレイグ・メッツは、文書が書かれていたとして、彼はこれらの機能の多くを実装するに基づいて、フィードバック、提案、コメントの多くを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following provided comments on earlier drafts: Pascal Anelli, Hamid Asayesh, Ran Atkinson, Karl Auerbach, Hamid Asayesh, Matt Crawford, Sam T. Denton, Richard Draves, Francis Dupont, Bob Gilligan, Tim Hartrick, Masaki Hirabaru, Yoshinobu Inoue, Mukesh Kacker, A. N. Kuznetsov, Pedro Marques, Jack McCann, der Mouse, John Moy, Thomas Narten, Erik Nordmark, Steve Parker, Charles Perkins, Tom Pusateri, Pedro Roque, Sameer Shah, Peter Sjodin, Stephen P. Spackman, Jinmei Tatuya, Karen Tracey, Quaizar Vohra, Carl Williams, Steve Wise, and Kazu Yamamoto.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前のドラフトで次の提供のコメント：パスカルAnelli、ハミドAsayeshは、アトキンソン、カール・アウエルバッハ、ハミドAsayesh、マット・クロフォード、サム・T.デントン、リチャードDraves、フランシスデュポン、ボブギリガン、ティムHartrick、正樹平原、慶喜井上、ムケシュ蘭Kacker、クズネツォフ、ペドロ・マルケス、ジャック・マッキャン、デア・マウス、ジョン・モイ、トーマスNarten氏、エリックNordmarkと、スティーブ・パーカー、チャールズ・パーキンス、トムPusateri、ペドロ・ローク、サミール・シャー、ピーターSjodin、スティーブンP. Spackman、神明達也、カレントレイシー、Quaizar Vohra著、カール・ウィリアムズ、スティーブ・ワイズ、そしてカズ山本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.著者のアドレス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W. Richard Stevens 1202 E. Paseo del Zorro Tucson, AZ 85718
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ｗ。 りちゃｒｄ Ｓてゔぇんｓ １２０２ え。 ぱせお でｌ ぞっろ つｃそん、 あＺ ８５７１８
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: rstevens@kohala.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：rstevens@kohala.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Matt Thomas AltaVista Internet Software LJO2-1/J8 30 Porter Rd Littleton, MA 01460 EMail: matt.thomas@altavista-software.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マット・トーマスアルタビスタインターネットソフトウェアLJO2-1 / J8 30ポーターRdのリトルトン、MA 01460 Eメール：matt.thomas@altavista-software.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.完全な著作権声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（1998）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
