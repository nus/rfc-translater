<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 3072 - Structured Data Exchange Format (SDXF) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3072</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 3072 - Structured Data Exchange Format (SDXF) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc3072">
              https://tools.ietf.org/html/rfc3072
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 3072 - 構造化データ交換フォーマット（SDXF）</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                       M. Wildgrube
Request for Comments: 3072                                    March 2001
Category: Informational
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                 Structured Data Exchange Format (SDXF)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2001). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2001）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IESG Note
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IESG注意
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies a data exchange format and, partially, an API that can be used for creating and parsing such a format. The IESG notes that the same problem space can be addressed using formats that the IETF normally uses including ASN.1 and XML. The document reader is strongly encouraged to carefully read section 13 before choosing SDXF over ASN.1 or XML. Further, when storing text in SDXF, the user is encourage to use the datatype for UTF-8, specified in section 2.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、部分的にデータ交換フォーマットと、このようなフォーマットを作成し、解析するために使用することができるAPIを指定します。 IESGは、同じ問題空間は、IETFが正常にASN.1やXMLなど、使用する形式を使用して対処することができると指摘します。ドキュメントリーダが強く、慎重にASN.1やXMLを介しSDXFを選択する前に、セクション13を読むことを奨励しています。 SDXFにテキストを格納するとき、さらに、ユーザは、セクション2.5で指定されたUTF-8のデータ型を使用することが奨励されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification describes an all-purpose interchange format for use as a file format or for net-working. Data is organized in chunks which can be ordered in hierarchical structures. This format is self-describing and CPU-independent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様は、ファイル形式としてまたはネット・ワーキングのための使用のための万能交換フォーマットを説明しています。データは階層構造で注文することができチャンクで構成されています。このフォーマットは、自己記述およびCPUに依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction ................................................. 2
   2.  Description of the SDXF data format .......................... 3
   3.  Introduction to the SDXF functions ........................... 5
   3.1 General remarks .............................................. 5
   3.2 Writing a SDXF buffer ........................................ 5
   3.3 Reading a SDXF buffer ........................................ 6
   3.4 Example ...................................................... 6
   4.  Platform independence ........................................ 8
   5.  Compression .................................................. 9
   6.  Encryption ...................................................11
   7.  Arrays........................................................11
   8.  Description of the SDXF functions ............................12
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   8.1 Introduction .................................................12
   8.2 Basic definitions ............................................13
   8.3 Definitions for C++ ..........................................15
   8.4 Common Definitions ...........................................16
   8.5 Special functions ............................................17
   9.  &#39;Support&#39; of UTF-8 ...........................................19
   10.  Security Considerations .....................................19
   11.  Some general hints ..........................................20
   12.  IANA Considerations .........................................20
   13.  Discussion ..................................................21
   13.1 SDXF vs. ASN.1 ..............................................21
   13.2 SDXF vs. XML ................................................22
   14.  Author&#39;s Address ............................................24
   15.  Acknowledgements ............................................24
   16.  References ..................................................24
   17.  Full Copyright Statement ....................................26
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The purpose of the Structured Data eXchange Format (SDXF) is to permit the interchange of an arbitrary structured data block with different kinds of data (numerical, text, bitstrings). Because data is normalized to an abstract computer architecture independent &#34;network format&#34;, SDXF is usable as a network interchange data format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造化データ交換フォーマット（SDXF）の目的は、異なる種類のデータ（数値、テキスト、ビット文字列）を有する任意の構造化されたデータブロックの交換を可能にすることです。データ抽象コンピュータ・アーキテクチャに依存しない「ネットワーク形式」に正規化されるので、SDXFはネットワーク交換データ形式として使用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This data format is not limited to any application, the demand for this format is that it is usable as a text format for word-processing, as a picture format, a sound format, for remote procedure calls with complex parameters, suitable for document formats, for interchanging business data, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このデータ・フォーマットは、任意のアプリケーションに限定されるものではなく、この形式の要求は、リモート・プロシージャのための映像フォーマット、音声フォーマットは、文書フォーマットに適した、複雑なパラメータで呼び出しとしては、ワードプロセッサのテキスト形式として使用可能であるということです、ビジネス・データを交換するための、など
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXF is self-describing, every program can unpack every SDXF-data without knowing the meaning of the individual data elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFは自己記述され、すべてのプログラムは、個々のデータ要素の意味を知らなくても、すべてのSDXFデータを解凍することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Together with the description of the data format a set of functions will be introduced. With the help of these functions one can create and access the data elements of SDXF. The idea is that a programmer should only use these functions instead of maintaining the structure by himself on the level of bits and bytes. (In the speech of object-oriented programming these functions are methods of an object which works as a handle for a given SDXF data block.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一緒に機能のセットが導入されるデータ形式の記述です。これらの機能の助けを借りて1はSDXFのデータ要素を作成し、アクセスすることができます。アイデアは、プログラマだけビットとバイトのレベルで自分で構造を維持するのではなく、これらの関数を使用する必要があることです。 （オブジェクト指向プログラミングのスピーチでは、これらの機能は、所与SDXFデータブロックのためのハンドルとして働くオブジェクトのメソッドです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXF is not limited to a specific platform, along with a correct preparation of the SDXF functions the SDXF data can be interchanged (via network or data carrier) across the boundaries of different architectures (specified by the character code like ASCII, ANSI or EBCDIC and the byte order for binary data).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXF特定のプラットフォームに限定されるものではなく、SDXFの正しい調製と共に（ネットワークまたはデータキャリアを介して）SDXFデータを交換することができる機能異なるアーキテクチャの境界を越えて（ASCII、ANSIまたはEBCDICなどの文字コードで指定されたとバイナリデータのバイト順序）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXF is also prepared to compress and encrypt parts or the whole block of SDXF data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFはまた、部分またはSDXFデータのブロック全体を圧縮して暗号化する用意があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Description of SDXF data format.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SDXFデータフォーマットの0002。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.1 First we introduce the term &#34;chunk&#34;. A chunk is a data structure with a fixed set of components. A chunk may be &#34;elementary&#34; or &#34;structured&#34;. The latter one contains itself one or more other chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.1まず、用語「チャンク」を導入します。チャンクは、コンポーネントの固定のセットを有するデータ構造です。チャンクは、「基本」または「構造化」であってもよいです。後者は、それ自体が一個の以上の他のチャンクを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A chunk consists of a header and the data body (content):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
チャンクは、ヘッダとデータ本体（コンテンツ）で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------+-----+-------+-----------------------------------+
   | Name     | Pos.| Length| Description                       |
   +----------+-----+-------+-----------------------------------+
   | chunk-ID |  1  |   2   | ID of the chunk (unsigned short)  |
   | flags    |  3  |   1   | type and properties of this chunk |
   | length   |  4  |   3   | length  of the following data     |
   | content  |  7  |   *)  | net data or a list of of chunks   |
   +----------+-----+-------+-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(* as stated in &#34;length&#34;. total length of chunk is length+6. The chunk ID is a non-zero positive number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「長さ」で述べたように（*。チャンクの全長は長さ+ 6である。チャンクIDがゼロ以外の正の数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
or more visually:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以上の視覚的に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----+----+----+----+----+----+----+----+----+-...
   | chunkID | fl | length       |  content
   +----+----+----+----+----+----+----+----+----+-...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
or in ASN.1 syntax:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
またはASN.1構文で：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   chunk  ::=  SEQUENCE
   {
     chunkID INTEGER (1..65535),
     flags   BIT STRING,
     length  OCTET STRING SIZE 3, -- or: INTEGER (0..16777215)
     content OCTET STRING
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2 Structured chunk.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2構造化チャンク。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A structured chunk is marked as such by the flag byte (see 2.5). Opposed to an elementary chunk its content consists of a list of chunks (elementary or structured):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造チャンクは、（2.5を参照）フラグバイトによってそのようにマークされています。その内容は、（基本または構造）チャンクのリストから成る基本チャンクに対向します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----+-+---+-------+-------+-------+-----+-------+
   | id |f|len| chunk | chunk | chunk | ... | chunk |
   +----+-+---+-------+-------+-------+-----+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the help of this concept you can reproduce every hierarchically structured data into a SDXF chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この概念の助けを借りて、あなたはSDXFチャンクにすべての階層構造のデータを再生することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.3 Some Remarks about the internal representation of the chunk&#39;s elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.3チャンクの要素の内部表現に関するいくつかの注意事項：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Binary values are always in high-order-first (big endian) format, like the binary values in the IP header (network format). A length of 300 (=256 + 32 + 12) is stored as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイナリ値は、IPヘッダー（ネットワーク形式）にバイナリ値のように、高次ファースト（ビッグエンディアン）形式で常に。 300の長さ（= 256 + 32 + 12）として格納されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----+----+----+----+----+----+----+----+----+--
   |         |    | 00   01   2C |  content
   +----+----+----+----+----+----+----+----+----+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
in hexadecimal notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
16進数表記です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is also valid for the chunk-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、チャンク-IDのためにも有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.4 Character values in the content portion are also an object of adaptation: see chapter 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ部分2.4文字の値はまた、適合の目的である。第4章を参照します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.5 Meaning of the flag-bits: Let us represent the flag byte in this manner:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フラグビットの2.5意味：私たちはこのようにフラグバイトを表してみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+
     |0|1|2|3|4|5|6|7|
     +-+-+-+-+-+-+-+-+
      | | | | | | | |
      | | | | | | | +-- reserved
      | | | | | | +---- array
      | | | | | +------ short chunk
      | | | | +-------- encrypted chunk
      | | | +---------- compressed chunk
      | | |
      +-+-+------------ data type (0..7)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
data types are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データの種類は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
0 -- pending structure (chunk is inconsistent, see also 11.1) 1 -- structure 2 -- bit string 3 -- numeric 4 -- character 5 -- float (ANSI/IEEE 754-1985)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0  - ペンディング構造（チャンクは矛盾して、11.1も参照）1  - 構造2  - ビット列3  - 数字4  - 文字5  - フロート（ANSI / IEEE 754-1985）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6 -- UTF-8 7 -- reserved
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6  -  UTF-8 7  - 予約済み
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.6 A short chunk has no data body. The 3 byte Length field is used as data bytes instead. This is used in order to save space when there are many small chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.6短いチャンクはデータ本体を持っていません。データとして使用される3バイトの長さフィールドは、代わりにバイト。これは、多くの小さな塊がある場合にスペースを節約するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.7 Compressed and encrypted chunks are explained in chapter 5 and 6.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.7圧縮と暗号化された塊は、第5章と6で説明されています。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8 Arrays are explained in chapter 7.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8配列は、第7章で説明されています。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9 Handling of UTF-8 is explained in chapter 9.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
UTF-8の2.9取り扱いは、第9章で説明されています。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10 Not all combinations of bits are allowed or reasonable:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10ビットのすべての組み合わせが許可または合理的なされているわけではありません。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- the flags &#39;array&#39; and &#39;short&#39; are mutually exclusive. - &#39;short&#39; is not applicable for data type &#39;structure&#39; and &#39;float&#39;. - &#39;array&#39; is not applicable for data type &#39;structure&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - フラグ「アレイ」と「ショート」は相互に排他的です。 - 「短い」は、データ型「構造」と「フロート」には適用されません。 - 「配列」は、データ型「構造」には適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Introduction to the SDXF functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SDXF機能3.入門
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 General remarks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1総論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The functionality of the SDXF concept is not bounded to any programming language, but of course the functions themselves must be coded in a particular language. I discuss these functions in C and C++, because in the meanwhile these languages are available on almost all platforms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFコンセプトの機能は、任意のプログラミング言語に制限されていないが、もちろん機能自体が特定の言語でコーディングする必要があります。一方でこれらの言語は、ほぼすべてのプラットフォームで利用可能ですので、私は、CおよびC ++でこれらの機能について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All these functions for reading and writing SDXF chunks uses only one parameter, a parameter structure. In C++ this parameter structure is part of the &#34;SDXF class&#34; and the SDXF functions are methods of this class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFチャンクを読み書きのためのすべてのこれらの機能は、唯一つのパラメータ、パラメータ構造体を使用しています。 C ++では、このパラメータの構造「SDXFクラス」の一部であり、SDXF機能は、このクラスのメソッドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An exact description of the interface is given in chapter 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インタフェースの正確な説明は、第8章に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Writing a SDXF buffer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 SDXFバッファを書きます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For to write SDXF chunks, there are following functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFチャンクを書くためには、以下の機能があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
init -- initialize the parameter structure create -- create a new chunk leave -- &#34;close&#34; a structured chunk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
INIT  - 作成パラメータ構造体を初期化 - 新しいチャンク休暇を作成 - 「近い」構造化チャンクを
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 Reading a SDXF buffer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 SDXFバッファを読み取ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For to read SDXF chunks, there are following functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFチャンクを読み込むためには、以下の機能があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
init -- initialize the parameter structure enter -- &#34;go into&#34; a structured chunk next -- &#34;go to&#34; the next chunk inside a structured chunk extract -- extract the content of an elementary chunk into user&#39;s data area leave -- &#34;go out&#34; off a structured chunk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
INIT  - 次構造のチャンク「に入る」 -   - 構造化されたチャンクエキス内の次のチャンク「に行く」 - ユーザーのデータ領域休暇に基本チャンクの内容を抽出 - パラメータ構造を入力して初期化「に行きます構造化チャンクオフ「アウト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 Example:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4例：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1 Writing:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1執筆：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For demonstration we use a reduced (outlined) C++ Form of these functions with polymorph definitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デモンストレーションのために我々は多形の定義でこれらの機能の減少（概説）C ++フォームを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
void create (short chunkID); // opens a new structure, void create (short chunkID, char *string); // creates a new chunk with dataType character, etc.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効（ショートchunkID）を作成します。 //は、新たな構造を開き、ボイドは（短いchunkID、char *文字列）を作成します。 //データ型の文字などで新しいチャンクを作成します）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sequence:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シーケンス：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   SDXF x(new); // create the SDXF object &#34;x&#34; for a new chunk
                // includes the &#34;init&#34;
   x.create (3301);   // opens a new structure
   x.create (3302, &#34;first chunk&#34;);
   x.create (3303, &#34;second chunk&#34;);
   x.create (3304);   // opens a new structure
   x.create (3305, &#34;chunk in a structure&#34;);
   x.create (3306, &#34;next chunk in a structure&#34;);
   x.leave ();        // closes the inner structure
   x.create (3307, &#34;third chunk&#34;);
   x.leave ();        // closes the outer structure creates a chunk which we can show graphically like:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   3301
    |
    +--- 3302 = &#34;first chunk&#34;
    |
    +--- 3303 = &#34;second chunk&#34;
    |
    +--- 3304
    |      |
    |      +--- 3305 = &#34;chunk in a structure&#34;
    |      |
    |      +--- 3306 = &#34;next chunk in a structure&#34;
    |
    +--- 3307 = &#34;last chunk&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2 Reading
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2読書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A typically access to a structured SDXF chunk is a selection inside a loop:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に構造化されたSDXFチャンクへのアクセスをループ内での選択です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXF x(old); // defines a SDXF object &#34;x&#34; for an old chunk x.enter (); // enters the structure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXF×（古いです）。 //）が（古いチャンクx.enterためSDXFオブジェクト「X」を規定します。 //構造に入り、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   while (x.rc == 0) // 0 == ok, rc will set by the SDXF functions
   {
     switch (x.chunkID)
     {
       case 3302:
         x.extract (data1, maxLength1);
                   // extr. 1st chunk into data1
         break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case 3303:
         x.extract (data2, maxLength2);
                   // extr. 2nd chunk into data2
         break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
case 3304: // we know this is a structure x.enter (); // enters the inner structure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース3304：//私たちは）、これは、構造x.enter（知っています。 //内部構造に入り、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
while (x.rc == 0) // inner loop { switch (x.chunkID) { case 3305: x.extract (data3, maxLength3); // extr. the chunk inside struct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方、（x.rc == 0）//内部ループ{スイッチ（x.chunkID）{ケース3305：x.extract（DATA3、maxLength3）。 // EXTR。構造体の内部の塊。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               break;
             case 3306:
               x.extract (data4, maxLength4);
                         // extr. 2nd chunk inside struct.
               break;
           }
           x.next (); // returns x.rc == 1 at end of structure
         } // end-while
         break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       case 3307:
         x.extract (data5, maxLength5);
                   // extract last chunk into data
         break;
       // default: none - ignore unknown chunks !!!
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 } // end-switch x.next (); // returns x.rc = 1 at end of structure } // end-while
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
} //エンドスイッチx.next（）。 //戻りx.rc = 1構造体の端} //エンド一方で
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Platform independence
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.プラットフォームの独立性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The very most of the computer platforms today have a 8-Bits-in-a-Byte architecture, which enables data exchange between these platforms. But there are two significant points in which platforms may be different:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンピュータ・プラットフォーム、今日の非常に大部分は、これらのプラットフォーム間でのデータ交換を可能にし、8ビット・イン・バイトアーキテクチャを持っています。しかし、プラットフォームが異なっていてもよく、二つの重要なポイントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a) The representation of binary numerical (the short and long int and floats).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A）二進数値の表現（短期および長期INTとフロート）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b) The representation of characters (ASCII/ANSI vs. EBCDIC)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
EBCDIC対b）の文字の表現（ASCII / ANSI）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Point (a) is the phenomenon of &#34;byte swapping&#34;: How is a short int value 259 = 0x0103 = X&#39;0103&#39; be stored at address 4402?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポイントは、（a）は、「バイトスワップ」の現象である：どのようにshort int型値259 = 0x0103 = X&#39;0103&#39; のアドレス4402で保存されていますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The two flavours are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2つの種類があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4402 4403 01 03 the big-endian, and 03 01 the little-endian.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4402 4403 01 03ビッグエンディアン、および03 01リトルエンディアン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Point (b) is represented by a table of the assignment of the 256 possible values of a Byte to printable or control characters. (In ASCII the letter &#34;A&#34; is assigned to value (or position) 0x41 = 65, in EBCDIC it is 0xC1 = 193.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポイント（b）は、印刷可能な又は制御文字のバイトの256の可能な値の割り当てのテーブルで表されます。 （ASCIIの文字「」EBCDICに、値（又は位置）0×41 = 65に割り当てられ、それが= 193 0xC1です）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The solution of these problems is to normalize the data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの問題の解決策は、データを正規化することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We fix:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは、修正します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(a) The internal representation of binary numerals are 2-complements in big-endian order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（a）は二進数字の内部表現は、ビッグエンディアン順に2補数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) The internal representation of characters is ISO 8859-1 (also known as Latin 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（b）は、文字の内部表現は、ISO 8859-1（ラテン1としても知られる）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fixing of point (b) should be regarded as a first strike. In some environment 8859-1 seems not to be the best choice, in a greek or russian environment 8859-5 or 8859-7 are appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
点（B）の固定は、先制攻撃とみなされるべきです。一部の環境では8859-1は、ギリシャ語やロシア語環境8859-5または8859-7に適切である、最良の選択ではないように思われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nevertheless, in a specific group (or world) of applications, that is to say all the applications which wants to interchange data with a defined protocol (via networking or diskette or something else), this internal character table must be unique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それにもかかわらず、アプリケーションの特定のグループ（または世界）で、それは、（ネットワークやフロッピーディスクまたは他の何かを経由して）定義されたプロトコルでデータを交換したいすべてのアプリケーションを言うことです、この内部文字テーブルには、一意でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
So a possibility to define a translation table (and his inversion) should be given.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
だから、変換テーブルを定義する可能性（と彼の反転）が与えられるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Important: You construct a SDXF chunk not for a specific addressee, but you adapt your data into a normalized format (or network format).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
重要：あなたが特定の受取人のためではないSDXFチャンクを構築していますが、正規化された形式（またはネットワーク形式）にデータを適応させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This adaption is not done by the programmer, it will be done by the create and extract function. An administrator has take care of defining the correct translation tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この適応は、プログラマによって行われていない、それが作成し、抽出機能によって行われます。管理者は、正しい変換テーブルを定義するの世話を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.圧縮
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) are compressed. This data is not further interpretable until it is decompressed. Compression is transparently done by the SDXF functions: &#34;create&#34; does the compression for elementary chunks, &#34;leave&#34; for structured chunks, &#34;extract&#34; does the decompression for elementary chunks, &#34;enter&#34; for structured chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.5で述べたように（基本または構造）は、以下のデータが圧縮されていることを宣言フラグビットがあります。それが解凍されるまで、このデータは、さらに解釈ではありません。圧縮は、透過的SDXF機能によって行われます：基本チャンクの圧縮は、構造化されたチャンクのために、「残す」ん「作成」、「エキス」は基本チャンクのための解凍には、構造化されたチャンクのための「入力」ん。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transparently means that the programmer has only to tell the SDXF functions that he want compress the following chunk(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
透過的にプログラマが、彼は次のチャンク（複数可）を圧縮したいSDXF機能を伝えるためだけにならないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For choosing between different compression methods and for controlling the decompressed (original) length, there is an additional definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
異なる圧縮方法の間及び解凍（元の）長さを制御するために選択するために、付加的な定義があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After the chunk header for a compressed chunk, a compression header is following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
圧縮されたチャンクのチャンクヘッダの後、圧縮ヘッダは以下の通りです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------------+---------------+----------------&gt;
   |      chunk header     | compr. header | compressed data
   +---+---+---+---+---+---+---+---+---+---+----------------&gt;
   |chunkID|flg|   length  |md | orglength |
   +---+---+---+---+---+---+---+---+---+---+----------------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#39;orglength&#39; is the original (decompressed) length of the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 「orglength」は、データの元の（伸長）の長さです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#39;md&#39; is the &#34;compression method&#34;: Two methods are described here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2つの方法がここで説明されている： - 「MD」「は圧縮方式」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
# method 01 for a simple (fast but not very effective) &#34;Run Length 1&#34; or &#34;Byte Run 1&#34; algorithm. (More then two consecutive identical characters are replaced by the number of these characters and the character itself.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シンプル（高速ではなく、非常に効果的な）「ランレングス1」または「バイトラン1」アルゴリズムの＃方法01。 （その他の2つの連続した同一の文字は、これらの文字と文字自体の数に置き換えられます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
more precisely:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
より正確に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The compressed data consists of several sections of various length. Every section starts with a &#34;counter&#34; byte, a signed &#34;tiny&#34; (8 bit) integer, which contains a length information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
圧縮されたデータは、様々な長さのいくつかのセクションから構成されています。すべてのセクションは、「カウンタ」バイト、長さ情報を含む署名された「小さな」（8ビット）の整数であり、始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         If this byte contains the value &#34;n&#34;,
         with n &gt;= 0 (and n &lt;128), the next n+1 bytes will be taken
         unchanged;
         with n &lt; 0 (and n &gt; -128), the next byte will be replicated
         -n+1 times;
         n = -128 will be ignored.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appending blanks will be cutted in general. If these are necessary, they can be reconstructed while &#34;extract&#34;ing with the parameter field &#34;filler&#34; (see 8.2.1) set to space character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
追加のブランクは、一般的にcuttedされます。これらが必要な場合は、（8.2.1を参照）スペース文字に設定パラメータ・フィールド「フィラー」とINGの「抽出」しながら、再構成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
# method 02 for the wonderful &#34;deflate&#34; algorithm which comes from the &#34;zip&#34;-people. The authors are: Jean-loup Gailly (deflate routine), Mark Adler (inflate routine), and others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ジップ」-peopleから来ている素晴らしい「収縮」アルゴリズムのための＃方法02。著者は次のとおりです：ジャン=ルー・ガイイ（ルーチン収縮）、マーク・アドラー（ルーチンに膨張）、およびその他。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The deflate format is described in [DEFLATE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DEFLATE形式は[DEFLATE]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The values for the compression method number are maintained by IANA, see chap. 12.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
圧縮方法の数の値は、CHAPを参照して、IANAによって維持されています。 12.1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Encryption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.暗号化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) is encrypted. This data is not interpretable until it is decrypted. En/Decryption is transparently done by the SDXF functions, &#34;create&#34; does the encryption for elementary chunks, &#34;leave&#34; for structured chunks, &#34;extract&#34; does the decryption for elementary chunks, &#34;enter&#34; for structured chunks. (Yes it sounds very similar to chapter 5.) More then one encryption method for a given range of applications is not very reasonable. Some encryption algorithms work with block ciphering algorithms. That means that the length of the data to encrypt must be rounded up to the next multiple of this block length. This blocksize (zero means non-blocking) is reported by the encryption interface routine (addressed by the option field *encryptProc, see chapter 8.5) with mode=3. If blocking is used, at least one byte is added, the last byte of the lengthening data contains the number of added bytes minus one. With this the decryption interface routine can calculate the real data length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.5で述べたように（基本または構造）は、以下のデータが暗号化されていることを宣言フラグビットがあります。それが復号化されるまで、このデータは解釈ではありません。 EN /復号化は透過的に、基本チャンクの暗号化を行い、「作成」基本チャンクのための復号化は、構造化されたチャンクのために「と入力し、」ん「を抽出」、構造化されたチャンクのために、「残す」、SDXF機能によって行われます。アプリケーションの特定の範囲のためのより多くのそして1つの暗号化方式は非常に合理的ではない（はい、それは、第5章に非常によく似て聞こえます）。いくつかの暗号化アルゴリズムは、ブロック暗号化アルゴリズムで動作します。すなわち、暗号化するデータの長さが、このブロック長の倍数に切り上げられなければならないことを意味します。このブロックサイズは、（ゼロが非ブロッキングを意味する）の暗号化インターフェース・ルーチンによって報告されたモード= 3と（オプションフィールド*のencryptProcによって対処、章8.5を参照してください）。ブロッキングが使用されている場合は、少なくとも1つのバイトが追加され、延長データの最後のバイトが追加されたバイト数マイナス1が含まれています。これにより、復号化インタフェースルーチンは、実際のデータの長さを計算することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an application (or network connect handshaking protocol) needs to negotiate an encryption method it should be used a method number maintained by IANA, see chap. 12.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション（またはネットワークは、ハンドシェイク・プロトコルを接続する）場合は、IANAによって維持方法の番号を使用されるべき暗号化方法を交渉する必要がある、CHAPを参照。 12.2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Even the en/decryption is done transparently, an encryption key (password) must be given to the SDXF functions. Encryption is done after translating character data into, decryption is done before translation from the internal (&#34;network-&#34;) format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でもアン/復号化を透過的に行われ、暗号化キー（パスワード）がSDXF関数に与えられなければなりません。暗号化は、復号化は内部（「ネットワーク - 」）フォーマットからの変換前に行われるに文字データを変換した後に行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If both, encryption and compression are applied on the same chunk, compression is done first - compression on good encrypted data (same strings appears as different after encryption) tends to zero compression rates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、暗号化と圧縮の両方が同じチャンクに適用されている場合は、圧縮が最初に行われている - 良い暗号化されたデータの圧縮を（同じ文字列が暗号化した後に異なるとして表示されます）ゼロ圧縮率になる傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Arrays
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.配列
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An array is a sequence of chunks with identical chunk-ID, length and data type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アレイは、同一のチャンクID、長さ、およびデータ型を持つチャンクのシーケンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At first a hint: in principle a special definition in SDXF for such an array is not really necessary:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のヒント：原則的に、このようなアレイのSDXFにおける特別な定義は本当に必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is not forbidden that there are more than one chunk with equal chunk-ID within the same structured chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じ構造化されたチャンク内等しいチャンク-IDを持つ複数のチャンクが存在することを禁じられていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Therefore with a sequence of SDX_next / SDX_extract calls one can fill the destination array step by step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従ってSDX_next / SDX_extractの配列と、ワンステップによって宛先アレイステップを埋めることができる呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If there are many occurrences of chunks with the same chunk-ID (and a comparative small length), the overhead of the chunk-packages may be significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同一のチャンクID（比較小長さ）を持つチャンクの多くの発生がある場合、チャンク・パッケージのオーバーヘッドが重要であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Therefore the array flag is introduced. An array chunk has only one chunk header for the complete sequence of elementary chunks. After the chunk header for an array chunk, an array header is following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
したがって、アレイフラグが導入されます。アレイチャンクは、基本チャンクの完全な配列のためにのみ1つのチャンクヘッダを有しています。アレイチャンクのチャンクヘッダの後、アレイヘッダは以下の通りです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is a short integer (big endian!) which contains the number of the array elements (CT). Every element has a fixed length (EL), so the chunklength (CL) is CL = EL * CT + 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、短整数（ビッグエンディアン！）配列要素（CT）の数が含まれています。すべての要素は、固定長（EL）を有しているので、chunklength（CL）は、CL = EL * CT + 2です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The data elements follows immediately after the array header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データ要素は、アレイヘッダの直後に続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The complete array will be constructed by SDX_create, the complete array will be read by SDX_extract.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全な配列はSDX_createによって構築され、完全な配列はSDX_extractによって読み込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The parameter fields (see 8.2.1) &#39;dataLength&#39; and &#39;count&#39; are used for the SDXF functions &#39;extract&#39; and &#39;create&#39;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パラメータフィールド（8.2.1を参照）「データ長」と「カウントが」SDXF機能「エキス」のために使用し、「作成」されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Field &#39;dataLength&#39; is the common length of the array elements, &#39;count&#39; is the actual dimension of the array for &#39;create&#39; (input).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールド「データ長」は、配列要素の一般的な長さは、「カウント」が「作成」（入力）の配列の実際の寸法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the &#39;extract&#39; function &#39;count&#39; acts both as an input and output parameter:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「抽出」機能「カウント」の入力および出力パラメータの両方として作用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Input : the maximum dimension output: the actual array dimension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力：最大寸法出力：実際の配列次元。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(If output count is greater than input count, the &#39;data cutted&#39; warning will be responded and the destination array is filled up to the maximum dimension.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（出力カウントが入力回数よりも大きい場合、「データcutted」警告が応答され、宛先アレイは、最大寸法まで充填されています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Description of the SDXF functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SDXF機能の8説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Following the principles of Object Oriented Programming, not only the description of the data is necessary, but also the functions which manipulate data - the &#34;methods&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「メソッド」 - オブジェクト指向プログラミングだけでなく、データの記述が必要ですが、また、データを操作する関数の原則に続き。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the programmer knowing the methods is more important than knowing the data structure, the methods has to know the exact specifications of the data and guarantees the consistence of the data while creating them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
方法を知っているプログラマは、データ構造を知るよりも重要であるために、方法は、データの正確な仕様を知っている必要があり、それらを作成しながら、データの一貫性を保証しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A SDXF object is an instance of a parameter structure which acts as a programming interface. Especially it points to an actual SDXF data chunk, and, while processing on this data, there is a pointer to the actual inner chunk which will be the focus for the next operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFオブジェクトはプログラミング・インターフェースとして機能するパラメータ構造体のインスタンスです。特に、このデータを処理している間に、次の動作のための焦点となり、実際の内のチャンクへのポインタが存在し、実際のSDXFデータチャンクを指し、そして。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The benefit of an exact interface description is the same as using for example the standard C library functions: By using standard interfaces your code remains platform independent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
正確なインターフェース記述の利点は、例えば、標準のCライブラリ関数を使用するのと同じである：標準インタフェースを使用して、コードがプラットフォームに依存しないままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 Basic definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2基本的な定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1 The SDXF Parameter structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SDXFパラメータ構造を8.2.1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All SDXF access functions need only one parameter, a pointer to the SDXF parameter structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのSDXFアクセス機能は、一つのパラメータのみ、SDXFパラメータ構造体へのポインタを必要とします：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First 3 prerequisite definitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の3つの前提条件の定義：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef short int      ChunkID;
   typedef unsigned char  Byte;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef struct Chunk
   {
     ChunkID    chunkID;
     Byte       flags;
     char       length [3];
     Byte       data;
   } Chunk;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
And now the parameter structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そして今、パラメータ構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef struct { ChunkID chunkID; // name (ID) of Chunk Byte *container; // pointer to the whole Chunk long bufferSize; // size of container Chunk *currChunk; // pointer to actual Chunk long dataLength; // length of data in Chunk long maxLength; // max. length of Chunk for SDX_extract long remainingSize; // rem. size in cont. after SDX_create long value; // for data type numeric double fvalue; // for data type float char *function; // name of the executed SDXF function Byte *data; // pointer to Data Byte *cryptkey; // pointer to Crypt Key short count; // (max.) number of elements in an array short dataType; // Chunk data type / init open type short ec; // extended return-code short rc; // return-code short level; // level of hierarchy char filler; // filler char for SDX_extract Byte encrypt; // Indication if data to encrypt (0 / 1) Byte compression; // compression method // (00=none, 01=RL1, 02=zip/deflate) } SDX_obj, *SDX_handle;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造体のtypedef {ChunkID chunkID。チャンクバイト*コンテナの//名前（ID）; //チャンク全体の長がbufferSizeへのポインタ。 //コンテナのチャンクのサイズ* currChunk。 //実際のチャンク長いデータ長へのポインタ。 //チャンク長いのmaxLength内のデータの長さ。 //最大。 SDX_extract長いremainingSizeのためのチャンクの長さ。 //レム。続きでサイズ。 SDX_create long値の後に、 //データ型の数値ダブルfvalueため、 //データ型フロートのchar *の機能のために、 //実行SDXF機能バイトの名前*データ;データバイト*のcryptkeyへの//ポインタ。 //ポインタは、キー短いカウントCRYPTします。 //配列ショートのdataTypeの要素数（最大） //チャンクデータ型/ initのオープンタイプのショートEC; //拡張リターンコードの短いRC。 //リターンコードを短くレベル。 //階層チャーフィラーのレベル。 // SDX_extractバイトの暗号化のためのフィラーチャー。 //表示データ（0/1）バイト圧縮を暗号化する場合。 //圧縮方法//（00 =なし、01 = RL1、02 =ジッパー/収縮）} SDX_obj、* SDX_handle。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Only the &#34;public&#34; fields of the parameter structure which acts as input and output for the SDXF functions is described here. A given implementation may add some &#34;private&#34; fields to this structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここに記載されてSDXF関数の入力および出力として作用するパラメータ構造のみ「パブリック」フィールド。所与の実施は、この構造にいくつかの「プライベート」のフィールドを追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2 Basic Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2基本機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All these functions works with a SDX_handle as the only formal parameter. Every function returns as output ec and rc as a report of success. For the values for ec, rc and dataType see chap. 8.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの関数はすべて、唯一の仮パラメータとしてSDX_handleで動作します。すべての関数は成功のレポートとして出力ECおよびRCとして返します。 ECの値については、RCとデータ型がchapを参照してください。 8.4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. SDX_init : Initialize the parameter structure.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. SDX_init：パラメータ構造体を初期化します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         input : container, dataType, bufferSize (for dataType =
                 SDX_NEW only)
         output: currChunk, dataLength (for dataType = SDX_OLD only),
                 ec, rc,
                 the other fields of the parameter structure will be
                 initialized.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. SDX_enter : Enter a structured chunk. You can access the first chunk inside this structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. SDX_enter：構造化されたチャンクを入力します。あなたは、この構造化されたチャンク内の最初のチャンクにアクセスすることができます。入力：なし出力：currChunk、chunkID、データ長、レベル、データ型、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. SDX_leave : Leave the actual entered structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. SDX_leave：実際に入力された構造化チャンクを残します。入力：なし出力：currChunk、chunkID、データ長、レベル、データ型、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. SDX_next : Go to the next chunk inside a structured chunk. input : none output: currChunk, chunkID, dataLength, dataType, count, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. SDX_next：構造化されたチャンク内の次のチャンクに移動します。入力：なし出力：currChunk、chunkID、データ長、データ型、カウント、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        At the end of a structured chunk SDX_next returns rc =
        SDX_RC_failed and ec = SDX_EC_eoc (end of chunk)
        The actual structured chunk is SDX_leave&#39;d automatically.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. SDX_extract : Extract data of the actual chunk. (If actual chunk is structured, only a copy is done, elsewhere the data is converted to host format.) input / output depends on the dataType:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. SDX_extract：実際のチャンクのデータを抽出します。 （実際のチャンクが構成されている場合にのみコピーが行われ、他の場所にデータをフォーマットをホストするように変換される）入力/出力は、データ型に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if dataType is structured, binary or char: input : data, maxLength, count, filler output: dataLength, count, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データ型が構成されている場合、バイナリまたはchar：入力：データ、maxLengthの、カウント、充填出力：DATALENGTH、カウント、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if dataType is numeric (float resp.): input : none output: value (fvalue resp.), ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（フロートRESP）データ型が数値の場合：入力：一つの出力：値（値RESP。）、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. SDX_select : Go to the (next) chunk with a given chunkID. input : chunkID output: currChunk, dataLength, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. SDX_select：与えられたchunkIDと（次）のチャンクに移動します。入力：chunkID出力：currChunk、データ長、データ型、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. SDX_create : Creating a new chunk (at the end of the actual structured chunk). input : chunkID, dataLength, data, (f)value, dataType, compression, encrypt, count update: remainingSize, level output: currChunk, dataLength, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. SDX_create：（実際の構造化チャンクの終わりに）新しいチャンクを作成します。入力：chunkID、データ長、データ、（f）の値は、データ型、圧縮、暗号化、更新カウント：remainingSize、レベル出力：currChunk、DATALENGTH、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
8. SDX_append : Append a complete chunk at the end of the actual structured chunk). input : data, maxLength, currChunk update: remainingSize, level output: chunkID, chunkLength, maxLength, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
8. SDX_append：実際の構成チャンクの終わりに完全なチャンクを追加）。入力：データ、maxLengthの、currChunk更新：remainingSize、レベル出力：chunkID、chunkLength、maxLengthの、データ型、EC、RC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3 Definitions for C++
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C 8.3の定義++
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is the specification of the SDXF class in C++: (The type &#39;Byte&#39; is defined as &#34;unsigned char&#34; for bitstrings, opposed to &#34;signed char&#34; for character strings)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、C ++でSDXFクラスの仕様である：（タイプ「バイトが」文字列は、「signed char型」ではなく、ビット文字列は、「unsigned char型」として定義されます）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
class C_SDXF { public:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クラスC_SDXF {パブリック：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
// constructors and destructor: C_SDXF (); // dummy C_SDXF (Byte *cont); // old container C_SDXF (Byte *cont, long size); // new container C_SDXF (long size); // new container ~C_SDXF (); // methods: void init (void); // old container void init (Byte *cont); // old container void init (Byte *cont, long size); // new container void init (long size); // new container
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//コンストラクタとデストラクタ：C_SDXF（）; //ダミーC_SDXF（バイト*の続き）。 //古いコンテナC_SDXF（バイト*の続き、長いサイズ）。 //新しいコンテナC_SDXF（ロングサイズ）。 //新しいコンテナ〜C_SDXF（）; //方法：空のinit（無効）。 //古いコンテナボイドのinit（バイト*の続き）。 //古いコンテナボイドのinit（バイト*の続き、長いサイズ）。 //新しいコンテナボイドのinit（ロングサイズ）。 //新しいコンテナ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     void enter   (void);
     void leave   (void);
     void next    (void);
     long extract (Byte *data, long length);    // chars, bits
     long extract (void);                       // numeric data
     void create  (ChunkID);                    // structured
     void create  (ChunkID, long value);        // numeric
     void create  (ChunkID, double fvalue);     // float
     void create  (ChunkID, Byte *data, long length);// binary
     void create  (ChunkID, char *data);             // chars
     void set_compression (Byte compression_method);
     void set_encryption  (Byte *encryption_key);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
// interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//インタフェース：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ChunkID id; // see 8.4.1 short dataType; // see 8.4.2 long length; // length of data or chunk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ChunkIDのID。 // 8.4.1短いデータ型を参照。 // 8.4.2長い長さを参照してください。 //データまたはチャンクの長さ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     long     value;
     double   fvalue;
     short    rc;  // the raw return code       see 8.4.3
     short    ec;  // the extended return code  see 8.4.4
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
protected: // implementation dependent ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
保護：//実装に依存...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4 Common Definitions:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4一般的な定義：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.1 Definition of ChunkID:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ChunkIDの8.4.1定義：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef short ChunkID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefの短いChunkID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2 Values for dataType:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
データ型の8.4.2値：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_DT_inconsistent = 0 SDX_DT_structured = 1 SDX_DT_binary = 2 SDX_DT_numeric = 3 SDX_DT_char = 4 SDX_DT_float = 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_DT_inconsistent = 0 SDX_DT_structured = 1 SDX_DT_binary = 2 SDX_DT_numeric = 3 SDX_DT_char = 4 SDX_DT_float = 5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_DT_UTF8 = 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_DT_UTF8 = 6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 data types for SDX_init: SDX_OLD = 1 SDX_NEW = 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_initのデータ型：SDX_OLD = 1 SDX_NEW = 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.3 Values for rc:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
RC用8.4.3値：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_RC_ok = 0 SDX_RC_failed = 1 SDX_RC_warning = 1 SDX_RC_illegalOperation = 2 SDX_RC_dataError = 3 SDX_RC_parameterError = 4 SDX_RC_programError = 5 SDX_RC_noMemory = 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_RC_ok = 0 SDX_RC_failed = 1 SDX_RC_warning = 1 SDX_RC_illegalOperation = 2 SDX_RC_dataError = 3 SDX_RC_parameterError = 4 SDX_RC_programError = 5 SDX_RC_noMemory = 6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.4 Values for ec:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ECのための8.4.4値：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_EC_ok = 0 SDX_EC_eoc = 1 // end of chunk SDX_EC_notFound = 2 SDX_EC_dataCutted = 3 SDX_EC_overflow = 4 SDX_EC_wrongInitType = 5 SDX_EC_comprerr = 6 // compression error SDX_EC_forbidden = 7 SDX_EC_unknown = 8 SDX_EC_levelOvflw = 9 SDX_EC_paramMissing = 10 SDX_EC_magicError = 11 SDX_EC_not_consistent = 12 SDX_EC_wrongDataType = 13 SDX_EC_noMemory = 14 SDX_EC_error = 99 // rc is sufficiently
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_EC_ok = 0 SDX_EC_eoc = 1 //チャンクの終わりSDX_EC_notFound = 2 SDX_EC_dataCutted = 3 SDX_EC_overflow = 4 SDX_EC_wrongInitType = 5 SDX_EC_comprerr = 6 //圧縮誤差SDX_EC_forbidden = 7 SDX_EC_unknown = 8 SDX_EC_levelOvflw = 9 SDX_EC_paramMissing = 10 SDX_EC_magicError = 11 SDX_EC_not_consistent = 12 SDX_EC_wrongDataType = 13 SDX_EC_noMemory = 14 SDX_EC_error = 99 // RCは十分です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5 Special functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5特殊機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Besides the basic definitions there is a global function (SDX_getOptions) which returns a pointer to a global table of options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
基本的な定義に加えてオプションのグローバルテーブルへのポインタを返すグローバル関数（SDX_getOptions）があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the help of these options you can adapt the behaviour of SDXF. Especially you can define an alternative pair of translation tables or an alternative function which reads these tables from an external resource (p.e. from disk).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのオプションの助けを借りて、あなたはSDXFの行動を適応させることができます。特にあなたは、変換テーブルの代替ペアや外部リソース（ディスクからP。E.）からこれらのテーブルを読み込み、代替機能を定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Within this table of options there is also a pointer to the function which is used for encryption / decryption: You can install your own encryption algorithm by setting this pointer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションのこの表の中でも、暗号化/復号化のために使用される関数へのポインタがあります：あなたはこのポインタを設定することで、独自の暗号化アルゴリズムをインストールすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The options pointer is received by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションのポインタがで受け取られます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_TOptions *opt = SDX_getOptions ();
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDX_TOptions * OPT = SDX_getOptions（）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
と：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef struct { Byte *toHost; // Trans tab net -&gt; host Byte *toNet; // Trans tab host -&gt; net int maxlevel; // highest possible level int translation; // translation net &lt;-&gt; host // is in effect=1 or not=0 TEncryptProc *encryptProc; // alternate encryption routine TGetTablesProc *getTablesProc; // alternate routine defining // translation Tables TcvtUTF8Proc *convertUTF8; // routine to convert to/from UTF-8 } SDX_TOptions;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefは構造体{バイト* toHost。 //トランスタブネット - &gt;ホストバイト*トネット。 //トランス]タブのホスト - &gt;ネットのint型のmaxlevel。 //可能な限り最高レベルのint型の翻訳; //翻訳ネット&lt; - &gt;ホスト//が有効になっている= 1か= 0 TEncryptProc * encryptProc。 //別の暗号化ルーチンTGetTablesProc * getTablesProc。 //別のルーチンの定義//変換テーブルTcvtUTF8Proc * convertUTF8。 //このルーチンは、UTF-8} SDX_TOptionsへ/から変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef long TencryptProc ( int mode, // 1= to encrypt, 2= to decrypt, 3= encrypted length Byte *buffer, // data to en/decrypt long len, // len: length of buffer char *passw); // Password
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefの長いTencryptProc（INTモード、// 1 =暗号化するために、2 =復号する、3 =暗号化された長さバイト*バッファ、//データEN /長LENを復号// LENに：バッファのchar *のPASSWの長さ）。 //パスワード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
// returns length of en/de-crypted data // (parameter buffer and passw are ignored for mode=3) // returns blocksize for mode=3 and len=0. // blocksize is zero for non-blocking algorithms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
EN /脱暗号化されたデータの//戻り長//モード= 3及びLEN = 0のブロックサイズを返す//（パラメータバッファとパスワードがモード= 3の場合は無視されます）。 //ブロックサイズは、ノンブロッキング・アルゴリズムのためのゼロです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef int TGetTablesProc (Byte **toNet, Byte **toHost); // toNet, toHost: pointer to output params. Both params // points to translation tables of 256 Bytes. // returns success: 1 = ok, 0 = error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefがTGetTablesProc（バイト**トネット、バイト** toHost）をint型。 //トネット、toHost：出力のparamsへのポインタ。どちらも、256バイトの変換テーブルに//ポイントをparamsは。 1 = OK、0 =エラー：//は成功を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef int TcvtUTF8Proc ( int mode, // 1 = to UTF-8, 2 = from UTF-8 Byte *target, int *targetlength, // output Byte *source, int sourcelength); // input // targetlength contains maximal size as input param. // returns success: 1 = ok, 0 = no conversion
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefのINT TcvtUTF8Proc（INTモード、// 1 = UTF-8に、2 = UTF-8からのバイト*ターゲット、INT * targetlength、//出力バイト*ソース、int型sourcelength）。 //入力// targetlengthは、入力のparamとして最大サイズが含まれています。 //リターンの成功：1 = OK、0 =変換なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. &#39;Support&#39; of UTF-8.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
UTF-8の9 &#39;サポート&#39;。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many systems supports [UTF-8] as a character format for transferred data. The benefit is that no fixing of a specific character set for an application is needed because the set of &#39;all&#39; characters is used, represented by the &#39;Universal Character Set&#39; UCS-2 [UCS], a double byte coding for characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くのシステムでは、[UTF-8]転送されたデータの文字形式などをサポートしています。利点は、「すべて」の文字セットが使用されているので、アプリケーションのための特定の文字セットのない固定「がセットユニバーサル文字」によって表される、必要とされていないことであるUCS-2 [UCS]、文字のダブルバイトコーディング。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXF does not really deal with UTF-8 by itself, there are many possibilities to interprete an UTF-8 sequence: The application may:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFが本当にそれ自体でUTF-8を扱っていない、UTF-8シーケンスをinterpreteする多くの可能性があります。アプリケーションは、可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- reconstruct the UCS-2 sequence, - accepts only the pure ASCII character and maps non-ASCII to a special &#39;non-printable&#39; character. - target is pure ASCII, non-ASCII is replaced in a senseful manner (French accented vowels replaced by vowels without accents, etc.). - target is a specific ANSI character set, the non-ASCII chars are mapped as possible, other replaced to a &#39;non-printable&#39;. - etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  UCS-2配列を再構築する、 - 純粋なASCII文字を受け入れ、特別な「非印刷可能な」文字に非ASCIIをマッピングします。 - 目標は、純粋なASCII、非ASCIIはsenseful方法（アクセントなしで母音で置き換えフランス語アクセント母音など）で置換されています。 - ターゲットは、特定のANSI文字セットで、非ASCII文字は、他の「非印刷可能な」に置き換え、可能性としてマッピングされています。 - など
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
But SDXF offers an interface for the &#39;extract&#39; and &#39;create&#39; functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかしSDXFは「エキス」と「作成」機能のためのインタフェースを提供します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A function pointer may be specified in the options table to maintain this possibility (see 8.5). Default for this pointer is NULL: No further conversions are done by SDXF, the data are copied &#39;as is&#39;, it is treated as a bit string as for data type &#39;binary&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関数ポインタは、（8.5を参照）は、この可能性を維持するために、オプションのテーブルで指定されてもよいです。このポインタのデフォルト値はNULLである：それ以上の変換はSDXFによって行われていない、データを「そのまま」にコピーされ、それはデータ・タイプ「バイナリ」のようなビット列として扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If this function is specified, it is used by the &#39;create&#39; function with the &#39;toUTF8&#39; mode, and by the &#39;extract&#39; function with the &#39; fromUTF8&#39; mode. The invoking of these functions is done by SDXF transparently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この関数が指定されている場合は、それを「toUTF8」モードで「作成」機能で使用され、そして「fromUTF8」モードと「抽出」関数で。これらの関数の呼び出しは、透過的にSDXFによって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the function returns zero (no conversion) SDXF copies the data without conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関数は、変換せずに、ゼロ（無変換）SDXFコピーデータを返さない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any corruption of data in the chunk headers denounce the complete SDXF structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
チャンクヘッダ内のデータの任意の破損は、完全なSDXF構造を非難します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any corruption of data in a encrypted or compressed SDXF structure makes this chunk unusable. An integrity check after decryption or decompression should be done by the &#34;enter&#34; function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号化や圧縮されたSDXF構造内のデータの任意の破損が、このチャンクが使用できなくなります。復号化または解凍後の整合性チェックは、「入力」機能により行われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While using TCP/IP (more precisely: IP) as a transmission medium we can trust on his CRC check on the transport layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（より正確には：IP）TCP / IPを使用している間の伝送媒体として、我々は、トランスポート層の上に彼のCRCチェックに信頼することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Some general hints
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.いくつかの一般的なヒント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. A consistent construction of a SDXF structure is done if every &#34;create&#34; to a structured chunk is closed by a paired &#34;leave&#34;. While a structured chunk is under construction, his data type is set to zero - that means: this chunk is inconsistent. The SDX_leave function sets the datatype to &#34;structured&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのは、構造化チャンクに「作成」場合は1 SDXF構造の一貫性の構築が行われているペアリング「のまま」で閉じられています。構造化されたチャンクが建設中ですが、彼のデータ型がゼロに設定されている - つまり：このチャンクは矛盾しています。 SDX_leave機能は、「構造化」へのデータ型を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. While creating an elementary chunk a platform dependent transformation to a platform independent format of the data is performed - at the end of construction the content of the buffer is ready to transport to another site, without any further translation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.データのプラットフォーム独立フォーマットのプラットフォーム依存の変換が行われる基本チャンクを作成中 - 構造の終わりにバッファの内容は、任意のさらなる変換なしに、別のサイトに輸送する準備ができています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. As you see no data definition in your programming language is needed for to construct a specific SDXF structure. The data is created dynamically by function calls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.あなたのプログラミング言語ではデータの定義を参照しないとは、特定のSDXF構造を構築するために必要とされます。データは、関数呼び出しによって動的に作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. With SDXF as a base you can define protocols for client / server applications. These protocols may be extended in downward compatibility manner by following two rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
あなたは、クライアント/サーバアプリケーションのためのプロトコルを定義することができますベースとしてSDXF 4.。これらのプロトコルは、2つのルールを以下により下位互換性的に拡張されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rule 1: Ignore unknown chunkIDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルール1：不明chunkIDsを無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rule 2: The sequence of chunks should not be significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルール2：チャンクの順序は重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The compression and encryption algorithms for SDXF is not fixed, SDXF is open for various algorithms. Therefore an agreement is necessary to interprete the compression and encryption algorithm method numbers. (Encryption methods are not a semantic part of SDXF, but may be used for a connection protocol to negotiate the encryption method to use.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFのための圧縮と暗号化アルゴリズムがSDXFは、様々なアルゴリズムのために開いている、固定されていません。したがって、契約は圧縮と暗号化アルゴリズム方式番号をinterpreteする必要があります。 （暗号化方式はSDXFの意味一部ではないが、使用する暗号化方法を交渉する接続プロトコルのために使用されてもよいです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Following two items are registered by IANA:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2つの項目以下のIANAによって登録されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1 COMPRESSION METHODS FOR SDXF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SDXF FOR 12.1の圧縮方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The compressed SDXF chunk starts with a &#34;compression header&#34;.  This
   header contains the compression method as an unsigned 1-Byte integer
   (1-255).  These numbers are assigned by IANA and listed here: compression
    method     Description                     Hints
   ---------   ------------------------------- -------------
         01    RUN-LENGTH algorithm            see chap. 5
         02    DEFLATE (ZIP)                   see [DEFLATE]
     03-239    IANA to assign
    240-255    private or application specific
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2 ENCRYPTION METHODS FOR SDXF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SDXF FOR 12.2暗号化の方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An unique encryption method is fixed or negotiated by handshaking. For the latter one a number for each encryption method is necessary. These numbers are unsigned 1-Byte integers (1-255). These numbers are assigned by IANA and listed here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
独自の暗号化方式は、固定またはハンドシェイクでネゴシエートされます。後者のために各暗号化方式のための番号が必要です。これらの数値は、符号なしの1バイト整数（1〜255）です。これらの数字は、IANAによって割り当てられ、ここに記載されています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   encryption
     method    Description
    ---------  ------------------------------
     01-239    IANA to assign
    240-255    private or application specific
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3 Hints for assigning a number:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
番号を割り当てるためのヒント12.3：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Developers which want to register a compression or encrypt method for SDXF should contact IANA for a method number. The ASSIGNED NUMBERS document should be referred to for a current list of METHOD numbers and their corresponding protocols, see [IANA]. The new method SHOULD be a standard published as a RFC or by a established standardization organization (as OSI).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFの圧縮や暗号化方式を登録したい開発者は、メソッド番号をIANAにお問い合わせください。割り当てられた番号の文書は、[IANA]参照、METHOD番号とそれに対応するプロトコルの現在のリストについては、を参照されたいです。新しい方法は、RFCとして、または（OSIなど）を設立し標準化団体によって発行された標準であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.ディスカッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are already some standards for Internet data exchanging, IETF prefers ASN.1 and XML therefore. So the reasons for establish a new data format should be discussed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターネットデータを交換するためのいくつかの規格が既にあり、IETFは、したがって、ASN.1とXMLを好みます。だから、新しいデータ形式を確立するための理由が議論されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1 SDXF vs. ASN.1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ASN.1対13.1 SDXF
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The demand of ASN.1 (see [ASN.1]) is to serve program language independent means to define data structures. The real data format which is used to send the data is not defined by ASN.1 but usually BER or PER (or some derivates of them like CER and DER) are used in this context, see [BER] and [PER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1の需要は（[ASN.1]を参照）のデータ構造を定義するためのプログラム言語に依存しない手段を提供することです。データを送信するために使用される実際のデータフォーマットはASN.1通常BERまたはPER（またはCERとDERのようなそれらのいくつかの誘導体）で定義されていないこの文脈で使用されている、[BER]を参照し、[PER]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The idea behind ASN.1 is: On every platform on which a given application is to develop descriptions of the used data structures are available in ASN.1 notation. Out off these notations the real language dependent definitions are generated with the help of an ASN.1-compiler.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1の背後にある考え方は、次のとおりです。与えられたアプリケーションが使用するデータ構造の記述を開発するためにされているすべてのプラットフォームでASN.1表記でご利用いただけます。これらの表記オフうち、実際の言語依存の定義は、ASN.1コンパイラの助けを借りて生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This compiler generates also transform functions for these data structures for to pack and unpack to and from the BER (or other) format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このコンパイラはまた、パックとBER（または他の）形式にしてから解凍するためにこれらのデータ構造に変換関数を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A direct comparison between ASN.1 and SDXF is somehow inappropriate: The data format of SDXF is related rather to BER (and relatives). The use of ASN.1 to define data structures is no contradiction to SDXF, but: SDXF does not require a complete data structure to build the message to send, nor a complete data structure will be generated out off the received message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1とSDXF間の直接比較は、何らかの形で不適切である：SDXFのデータフォーマットではなくBER（および親族）に関連しています。データ構造を定義するためのASN.1の使用はSDXFに矛盾はありませんが、：SDXFは、送信するメッセージ、また完全なデータ構造を構築するために、完全なデータ構造を必要としない、受信したメッセージから外れて生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The main difference lies in the concept of building and interpretation of the message, I want to name it the &#34;static&#34; and &#34;dynamic&#34; concept:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
主な違いは、建物やメッセージの解釈の概念である、私は「静的」と「ダイナミック」という概念それを名前を付けたいです：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o ASN.1 uses a &#34;static&#34; approach: The whole data structure must exists before the message can be created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O ASN.1は、「静的」なアプローチを使用しています：メッセージを作成することができます前に、全体のデータ構造必見存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o SDXF constructs and interpretes the message in a &#34;dynamic&#34; way, the message will be packed and unpacked step by step by SDXF functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O SDXF構築物および「動的」な方法でメッセージをinterpretes、メッセージはSDXF機能によってステップによって充填し、解凍工程であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The use of static structures may be appropriate for a series of applications, but for complex tasks it is often impossible to define the message as a whole. As an example try to define an ASN.1 description for a complex structured text document which is presented in XML: There are sections and paragraphs and text elements which may recursively consist of sections with specific text attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
静的構造の使用は、一連のアプリケーションに適したかもしれないが、複雑なタスクのために多くの場合、全体としてメッセージを定義することは不可能です。一例としてXMLに提示されている複雑な構造化テキスト文書のためのASN.1記述を定義しよう：再帰的に特定のテキスト属性を持つセクションから構成されてもよいセクションと段落やテキスト要素があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2 SDXF vs. XML
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
XML対13.2 SDXF
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On the one hand SDXF and XML are similar as they can handle any recursive complex data stream. The main difference is the kind of data which are to be maintained:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
片手SDXFとXML彼らは、任意の再帰的な複雑なデータ・ストリームを扱うことができるように類似しています。主な違いは維持されるべきデータの一種です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o XML works with pure text data (though it should be noted that the character representation is not standardized by XML). And: a XML document with all his tags is readable by human. Binary data as graphic is not included directly but may be referenced by an external link as in HTML.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（文字表現をXMLで標準化されていないことに留意すべきであるが）O XMLは、純粋なテキストデータで動作します。そして：すべての彼のタグを持つXML文書は、人間によって読み取り可能です。グラフィックなどのバイナリデータを直接含まれていませんが、HTMLのように、外部リンクによって参照することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In XML there is no strong separation between informational and control data, escape characters (like &#34;&lt;&#34; and &#34;&amp;&#34;) and the &lt;![CDATA[...]]&gt; construction are used to distinguish between these two types of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
XMLの文字（のような「&lt;」や「＆」）とを逃れ、情報と制御データとの間には強い分離はありません。&lt;！[CDATA [...]]&gt;建設は、データのこれらの2つのタイプを区別するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o SDXF maintains machine-readable data, it is not designed to be readable by human nor to edit SDXF data with a text editor (even more if compression and encryption is used). With the help of the SDXF functions you have a quick and easy access to every data element. The standard parser for a SDXF data structure follows always a simple template, the &#34;while - switch -case ID - enter/extract&#34; pattern as outlined in chap. 3.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SDXFは、機械読み取り可能なデータを保持し、O、人間が読めるようにも、テキストエディタ（圧縮と暗号化を使用しても多くの場合）とSDXFデータを編集するために設計されていません。 SDXF機能の助けを借りて、あなたはすべてのデータ要素にすばやく簡単にアクセスできます。 CHAPに概説されるようにパターン「入力/抽出 -   -  -case ID切り替えながら」をSDXFデータ構造のための標準的なパーサは、常に単純なテンプレートに従います。 3.4.2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because of the complete different philosophy behind XML and SDXF (and even ASN.1) a direct comparison may not be very senseful, as XML has its own right to exist next to ASN.1 (and even SDXF).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
XMLは、ASN.1（とさえSDXF）の隣に存在する独自の権利を持っているとの直接比較は、非常にsensefulではないかもしれないXMLとSDXF（とさえASN.1）の背後に完全に異なる哲学のため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nevertheless there is a chance to convert a XML data stream into a SDXF structure: As a first strike, every XML tag becomes a SDXF chunk ID. An elementary sequence &lt;tag&gt;pure text&lt;/tag&gt; can be transformed into an elementary (non-structured) chunk with data type &#34;character&#34;. Tags with attributes and sequences with nested tags are transformed into structured chunks. Because XML allows a tag sequence everywhere in a text stream, an artificially &#34;elementary text&#34; tag must be introduced: If &lt;t&gt; is the tag for text elements, the sequence:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それでもSDXF構造にXMLデータ・ストリームを変換する可能性があります：最初のストライキとして、すべてのXMLタグはSDXFチャンクIDになります。基本シーケンス&lt;タグ&gt;純粋なテキスト&lt;/タグ&gt;のデータ型「文字」との基本（非構造化）のチャンクに変換することができます。属性とネストされたタグを有する配列を持つタグは、構造化チャンクに変換されます。 XMLはテキストストリームの至る所にタグ配列を可能にするので、人為的に「基本テキスト」タグを導入する必要があります。&lt;T&gt;は、テキスト要素のためのタグがある場合は、シーケンス：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;t&gt;this is a text &lt;attr value=&#39;bold&#39;&gt;with&lt;/attr&gt; attributes&lt;/t&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;T&gt;これはテキストです。&lt;attrの値= &#39;太字&#39;&gt;と&lt;/ ATTR&gt;属性&lt;/ T&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
is to be &#34;in thought&#34; replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「考え中」に置き換えることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;t&gt;&lt;et&gt;this is a text &lt;/et&gt;&lt;attr value=&#39;bold&#39;&gt;&lt;et&gt;with&lt;/et&gt;&lt;/attr&gt; &lt;et&gt; attributes&lt;/et&gt;&lt;/t&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;T&gt; &lt;ら&gt;これはテキスト&lt;/ら&gt; &lt;ATTR値= &#39;太字&#39;&gt; &lt;ら&gt;と&lt;/ら&gt; &lt;/ ATTR&gt; &lt;ら&gt;属性&lt;/ら&gt; &lt;/ T&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(With &#34;et&#34; as the &#34;elementary text&#34; tag)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（「ら」と「基本テキスト」タグのような）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This results in following SDXF structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、次のSDXFの構造が得られます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ID_t
   |
   +-- ID_et = &#34; this is a text &#34;
   |
   +-- ID_attr
   |   |
   |   +-- ID_value = &#34;bold&#34;
   |   |
   |   +-- ID_et = &#34;with&#34;
   |
   +-- ID_et = &#34; attributes&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ID_t and ID_et may be represented by the same chunk ID, only distinguished by the data type (&#34;structured&#34; for &lt;t&gt; and &#34;character&#34; for &lt;et&gt;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ID_tとID_etのみ（&lt;T&gt;のための「構造化」と&lt;ら&gt;のための「文字」）データ型によって区別、同一のチャンクIDによって表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Binary data as pictures can be directly imbedded into a SDXF structure instead referencing them as an external link like in HTML.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
画像などのバイナリデータを直接代わりにHTMLのように、外部リンクとしてそれらを参照するSDXF構造に埋め込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Author&#39;s Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.著者のアドレス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Max Wildgrube Schlossstrasse 120 60486 Frankfurt Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マックスWildgrubeシュロスシュトラーセ120 60486フランクフルトドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: max@wildgrube.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：max@wildgrube.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
I would like to thank Michael J. Slifcak (mslifcak@iss.net) for the supporting discussions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私は支援の議論のためにマイケル・J Slifcak（mslifcak@iss.net）を感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ASN.1] Information processing systems - Open Systems Interconnection, &#34;Specification of Abstract Syntax Notation One (ASN.1)&#34;, International Organization for Standardization, International Standard 8824, December 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ASN.1]情報処理システム - 開放型システム間相互接続、「仕様抽象の構文記法1（ASN.1）」、国際標準化機構、国際標準8824、1987年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BER] Information Processing Systems - Open Systems Interconnection - &#34;Specification of Basic Encoding Rules for Abstract Notation One (ASN.1)&#34;, International Organization for Standardization, International Standard 8825-1, December 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BER]情報処理システム - オープンシステム間相互接続 - 「抽象記法1（ASN.1）のための基本的な符号化規則の仕様」、国際標準化機構、国際規格8825から1、1987年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DEFLATE] Deutsch, P., &#34;DEFLATE Compressed Data Format Specification version 1.3&#34;, RFC 1951, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DEFLATE]ドイツ、P.、 &#34;DEFLATE圧縮データフォーマット仕様バージョン1.3&#34;、RFC 1951、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IANA] Internet Assigned Numbers Authority, http://www.iana.org/numbers.htm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IANA]インターネット割り当て番号機関、http://www.iana.org/numbers.htm
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PER] Information Processing Systems - Open Systems Interconnection -&#34;Specification of Packed Encoding Rules for Abstract Syntax Notation One (ASN.1)&#34;, International Organization for Standardization, International Standard 8825-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PER]情報処理システム - 開放型システム間相互接続 - 、国際標準化機構、国際標準8825から2「抽象構文記法1（ASN.1）のための圧縮符号化規則の仕様」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[UCS] ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1993：[UCS] ISO / IEC 10646-1。国際規格 - 情報技術 - ユニバーサルマルチオクテット符号化文字セット（UCS）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[UTF8] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, RFC 2279, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[UTF8] Yergeau、F.、 &#34;UTF8、ISO 10646の変換フォーマット&#34;、RFC 2279、1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.完全な著作権声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2001). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2001）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
