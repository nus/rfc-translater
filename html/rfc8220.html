<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8220 - Protocol Independent Multicast (PIM) over Virtual Private LAN Service (VPLS) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8220</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8220 - Protocol Independent Multicast (PIM) over Virtual Private LAN Service (VPLS) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8220">
              https://tools.ietf.org/html/rfc8220
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8220 - プロトコル独立マルチキャスト仮想プライベートLANサービス（VPLS）を超える（PIM）</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         O. Dornon
Request for Comments: 8220                                   J. Kotalwar
Category: Informational                                        V. Hemige
ISSN: 2070-1721                                                    Nokia
                                                                  R. Qiu
                                                              mistnet.io
                                                                Z. Zhang
                                                  Juniper Networks, Inc.
                                                          September 2017
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  Protocol Independent Multicast (PIM)
                over Virtual Private LAN Service (VPLS)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the procedures and recommendations for Virtual Private LAN Service (VPLS) Provider Edges (PEs) to facilitate replication of multicast traffic to only certain ports (behind which there are interested Protocol Independent Multicast (PIM) routers and/or Internet Group Management Protocol (IGMP) hosts) via PIM snooping and proxying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、興味のあるプロトコル独立マルチキャスト（PIM）、ルータおよび/またはインターネットグループ管理プロトコルが存在するその背後にのみ特定のポート（へのマルチキャストトラフィックの複製を容易にするために、仮想プライベートLANサービス（VPLS）プロバイダーエッジ（PES）のための手順や推奨事項について説明しますPIMスヌーピングとプロキシを介して（IGMP）ホスト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With PIM snooping, PEs passively listen to certain PIM control messages to build control and forwarding states while transparently flooding those messages. With PIM proxying, PEs do not flood PIM Join/Prune messages but only generate their own and send them out of certain ports, based on the control states built from downstream Join/Prune messages. PIM proxying is required when PIM Join suppression is enabled on the Customer Edge (CE) devices and is useful for reducing PIM control traffic in a VPLS domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMスヌーピングでは、PEは受動的に透過的にそれらのメッセージをフラッディングしながら、制御と転送状態を構築するために、特定のPIM制御メッセージに耳を傾けます。 PIMのプロキシでは、PEは、下流から構築された制御状態に基づいて、PIMは/プルーンのメッセージを参加あふれさせるだけで、自分のを生成し、特定のポートのうち、それらを送信していない/プルーンのメッセージに参加。 PIMは抑制に参加するときのPIMプロキシが必要とされるカスタマーエッジ（CE）デバイス上で有効になっており、VPLSドメインにPIM制御トラフィックを低減するために有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document also describes PIM relay, which can be viewed as lightweight proxying, where all downstream Join/Prune messages are simply forwarded out of certain ports and are not flooded, thereby avoiding the triggering of PIM Join suppression on CE devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、単に特定のポートから転送されているすべての下流/プルーンJoinメッセージを軽量プロキシ、と見なすことができ、それによってCEデバイス上の抑制に参加し、PIMのトリガ避け、浸水していないPIMリレーを、説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8220.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8220で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................4
      1.1. Multicast Snooping in VPLS .................................5
      1.2. Assumptions ................................................6
      1.3. Definitions ................................................6
      1.4. Requirements Language ......................................7
   2. PIM Snooping for VPLS ...........................................7
      2.1. PIM Protocol Background ....................................7
      2.2. General Rules for PIM Snooping in VPLS .....................8
           2.2.1. Preserving Assert Triggers ..........................8
      2.3. Some Considerations for PIM Snooping .......................9
           2.3.1. Scaling .............................................9
           2.3.2. IPv4 and IPv6 ......................................10
           2.3.3. PIM-SM (*,*,RP) ....................................10
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      2.4. PIM Snooping vs. PIM Proxying .............................10
           2.4.1. Differences between PIM Snooping, Relay,
                  and Proxying .......................................10
           2.4.2. PIM Control Message Latency ........................11
           2.4.3. When to Snoop and When to Proxy ....................12
      2.5. Discovering PIM Routers ...................................13
      2.6. PIM-SM and PIM-SSM ........................................14
           2.6.1. Building PIM-SM States .............................15
           2.6.2. Explanation for Per-(S,G,N) States .................17
           2.6.3. Receiving (*,G) PIM-SM Join/Prune Messages .........18
           2.6.4. Receiving (S,G) PIM-SM Join/Prune Messages .........20
           2.6.5. Receiving (S,G,rpt) Join/Prune Messages ............22
           2.6.6. Sending Join/Prune Messages Upstream ...............23
      2.7. Bidirectional PIM (BIDIR-PIM) .............................24
      2.8. Interaction with IGMP Snooping ............................24
      2.9. PIM-DM ....................................................25
           2.9.1. Building PIM-DM States .............................25
           2.9.2. PIM-DM Downstream Per-Port PIM(S,G,N) State
                  Machine ............................................25
           2.9.3. Triggering Assert Election in PIM-DM ...............26
      2.10. PIM Proxy ................................................26
           2.10.1. Upstream PIM Proxy Behavior .......................26
      2.11. Directly Connected Multicast Source ......................26
      2.12. Data-Forwarding Rules ....................................27
           2.12.1. PIM-SM Data-Forwarding Rules ......................28
           2.12.2. PIM-DM Data-Forwarding Rules ......................29
   3. IANA Considerations ............................................29
   4. Security Considerations ........................................30
   5. References .....................................................30
      5.1. Normative References ......................................30
      5.2. Informative References ....................................31
   Appendix A. BIDIR-PIM Considerations ..............................32
     A.1. BIDIR-PIM Data-Forwarding Rules ............................32
   Appendix B. Example Network Scenario ..............................33
     B.1. PIM Snooping Example .......................................33
     B.2. PIM Proxy Example with (S,G) / (*,G) Interaction ...........36
   Acknowledgements ..................................................42
   Contributors ......................................................42
   Authors&#39; Addresses ................................................43
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the Virtual Private LAN Service (VPLS), the Provider Edge (PE) devices provide a logical interconnect such that Customer Edge (CE) devices belonging to a specific VPLS instance appear to be connected by a single LAN. The Forwarding Information Base (FIB) for a VPLS instance is populated dynamically by Media Access Control (MAC) address learning. Once a unicast MAC address is learned and associated with a particular Attachment Circuit (AC) or pseudowire (PW), a frame destined to that MAC address only needs to be sent on that AC or PW.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仮想プライベートLANサービス（VPLS）において、プロバイダエッジ（PE）デバイスは、特定のVPLSインスタンスに属する顧客エッジ（CE）デバイスは、単一のLANで接続されるように見えるように論理的相互接続を提供します。 VPLSインスタンスの転送情報ベース（FIB）は、メディアアクセス制御（MAC）アドレス学習によって動的に移入されます。ユニキャストMACアドレスが学習され、特定のアタッチメント回路（AC）または疑似回線（PW）と関連していると、そのMACアドレス宛のフレームは、そのACまたはPW上で送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a frame not addressed to a known unicast MAC address, flooding has to be used. This happens with the following so-called &#34;BUM&#34; (Broadcast, Unknown Unicast, and Multicast) traffic:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既知のユニキャストMACアドレス宛ではないフレームに対して、フラッディングを使用しなければなりません。これは、以下の、いわゆる「BUM」（ブロードキャスト、不明ユニキャスト、およびマルチキャスト）トラフィックで起こります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o B: The destination MAC address is a broadcast address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O B：宛先MACアドレスがブロードキャストアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o U: The destination MAC address is unknown (has not been learned).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O U：宛先MACアドレスが（学習されていない）は不明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o M: The destination MAC address is a multicast address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O M：宛先MACアドレスがマルチキャストアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multicast frames are flooded because a PE cannot know where corresponding multicast group members reside. VPLS solutions (RFC 4762 [VPLS-LDP] and RFC 4761 [VPLS-BGP]) perform replication for multicast traffic at the ingress PE devices. As stated in the VPLS Multicast Requirements document (RFC 5501 [VPLS-MCAST-REQ]), there are two issues with VPLS multicast today:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストフレームは、対応するマルチキャスト・グループ・メンバーが存在する場合にPEを知ることができないためにフラッディングされます。 VPLS溶液（RFC 4762 [VPLS-LDP]およびRFC 4761 [VPLS-BGP]）は入口PEデバイスでマルチキャストトラフィックの複製を実行します。 VPLSマルチキャスト要件文書（RFC 5501 [VPLS-MCAST-REQ]）で述べたように、VPLSマルチキャストには2つの問題は、今日があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Multicast traffic is replicated to non-member sites.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.マルチキャストトラフィックは、非会員のサイトにレプリケートされます。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Multicast traffic may be replicated when several PWs share a physical path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのPWSは物理パスを共有する場合2.マルチキャストトラフィックを複製することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Issue 1 can be solved by multicast snooping -- PEs learn sites with multicast group members by snooping multicast protocol control messages on ACs and forward IP multicast traffic only to member sites. This document describes the procedures to achieve this when CE devices are PIM adjacencies of each other. Issue 2 is outside the scope of this document and is discussed in RFC 7117 [VPLS-MCAST].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題1は、マルチキャストスヌーピングによって解決することができます -  PEは唯一のメンバーサイトにACSのマルチキャストプロトコルの制御メッセージと前方IPマルチキャストトラフィックをスヌーピングにより、マルチキャストグループのメンバーを持つサイトを学びます。この文書では、CEデバイスが互いのPIMの隣接しているときにこれを達成するための手順を説明します。問題2は、この文書の範囲外であり、[VPLS-MCAST] RFC 7117に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While descriptions in this document are in the context of the VPLS, the procedures also apply to regular Layer 2 switches interconnected by physical connections, except that the PW-related concepts and procedures do not apply in that case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの説明はVPLSのコンテキストであるが、手順もPW-関連する概念と手順が、その場合には適用されないことを除いて、物理的な接続によって相互接続され、通常のレイヤ2スイッチに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Multicast Snooping in VPLS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1.  VPLSでのマルチキャストスヌーピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMP snooping procedures described in RFC 4541 [IGMP-SNOOP] make sure that IP multicast traffic is only sent on the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 4541で説明IGMPスヌーピング手順[IGMP-SNOOP] IPマルチキャストトラフィックのみ、以下に送られていることを確認します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACs connecting to hosts that report related group membership
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACSは、関連するグループメンバーシップを報告するホストに接続するO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACs connecting to routers that join related multicast groups
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O ACSは、関連するマルチキャストグループに参加するルータに接続します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PWs connecting to remote PEs that have the above-described ACs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのPWは、上述したACSを有するリモートPEに接続します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that traffic is always sent on ports that have point-to-point connections to routers that are attached to a LAN on which there is at least one other router. Because IGMP snooping alone cannot determine if there are interested receivers beyond those routers, we always need to send traffic to these ports, even if there are no snooped group memberships. To further restrict traffic sent to those routers, PIM snooping can be used. This document describes the procedures for PIM snooping, including rules for when both IGMP and PIM snooping are enabled in a VPLS instance; see Sections 2.8 and 2.11 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トラフィックは、常に少なくとも一つの他のルータが存在しているLANに接続されているルータへのポイントツーポイント接続を持っているポートで送信されることに注意してください。 IGMPは、これらのルータを越えて興味受信機があるかどうかを決定することができないだけでスヌーピングので、我々は常に何スヌープグループのメンバーシップが存在しない場合でも、これらのポートにトラフィックを送信する必要があります。さらに、これらのルータに送信されるトラフィックを制限するには、PIMスヌーピングを使用することができます。この文書では、IGMPおよびPIMスヌーピングの両方がVPLSインスタンスで有効になっている場合のルールを含むPIMスヌーピング、の手順を説明し、セクションに詳細については、2.8と2.11を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for both IGMP and PIM, the term &#34;snooping&#34; is used loosely, referring to the fact that a Layer 2 device peeks into Layer 3 routing protocol messages to build relevant control and forwarding states. Depending on whether the control messages are transparently flooded, selectively forwarded, or aggregated, the processing may be called &#34;snooping&#34; or &#34;proxying&#34; in different contexts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMPとPIMの両方のために、「スヌーピング」という用語は、レイヤ3ルーティングプロトコルメッセージにレイヤ2つのデバイス覗き見は、関連する制御および転送状態を構築するという事実を参照し、緩く使用されることに留意されたいです。制御メッセージを透過的にフラッディングされているかどうかに応じて、選択的転送、または凝集し、処理は、異なるコンテキストで「スヌーピング」または「プロキシ」と呼ばれてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will use the term &#34;PIM snooping&#34; in this document; however, unless explicitly noted otherwise, the procedures apply equally to PIM snooping and PIM proxying. The procedures specific to PIM proxying are described in Section 2.6.6. Differences that need to be observed while implementing one or the other and recommendations on which method to employ in different scenarios are noted in Section 2.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、この文書中の用語「PIMスヌーピング」を使用します。明示的に、特に断りのない限りしかし、手順はPIMスヌーピングおよびPIMのプロキシにも同様に適用されます。 PIMのプロキシへの具体的な手順は、2.6.6項で説明されています。どちらか一方を実装し、異なるシナリオで使用するどの方法にお薦めしながら観察する必要がある違いはセクション2.4に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document also describes PIM relay, which can be viewed as lightweight PIM proxying. Unless explicitly noted otherwise, in the rest of this document proxying implicitly includes relay as well. Please refer to Section 2.4.1 for an overview of the differences between snooping, proxying, and relay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書はまた、軽量PIMのプロキシとして見ることができるPIMリレーを、説明しています。明示的に特に記載のない限り、このドキュメントのプロキシ処理の残りの部分では、暗黙的にも中継しています。スヌーピング、プロキシ、およびリレー間の違いの概要については、2.4.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Assumptions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 仮定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document assumes that the reader has a good understanding of the PIM protocols. To help correlate the concepts and make the text easier to follow, this document is written in the same style as the following PIM RFCs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、読者がPIMプロトコルの十分な理解を持っていることを前提としています。概念を相関し、従ってテキストを容易に支援するために、この文書は、次のPIM RFCとして同じスタイルで書かれています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RFC 3973 [PIM-DM]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのRFC 3973 [PIM-DM]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RFC 4607 [PIM-SSM]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのRFC 4607 [PIM-SSM]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RFC 5015 [BIDIR-PIM]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RFC 5015 [BI-D-PIM]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RFC 5384 [JOIN-ATTR]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのRFC 5384 [JOIN-ATTR]を
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RFC 7761 [PIM-SM]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのRFC 7761 [PIM-SM]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid replicating text related to PIM protocol handling from the PIM RFCs, this document cross-references corresponding definitions and procedures in those RFCs. Deviations in protocol handling specific to PIM snooping are specified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMのRFCには、これらのRFCの定義と手順を対応この文書の相互参照から処理PIMプロトコルに関連するテキストの複製を回避するためです。 PIMスヌーピングに固有のプロトコル処理における偏差は、この文書で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. 定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several definitions referenced in this document that are well described in the following PIM RFCs: RFC 3973 [PIM-DM], RFC 5015 [BIDIR-PIM], and RFC 7761 [PIM-SM]. The following definitions and abbreviations are used throughout this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 3973 [PIM-DM]、RFC 5015 [BIDIR-PIM]、およびRFC 7761 [PIM-SM]：いくつかのよく次のPIM RFCで記述されているこのドキュメントで参照定義があります。以下の定義および略語は、この文書全体で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A port is defined as either an AC or a PW.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oポートは、ACまたはPWのいずれかとして定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When we say that a PIM message is received on a PE port, it means that the PE is processing the message for snooping/proxying or relaying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、PIMメッセージはPEポートで受信されると言う場合、O、それはPEは/プロキシスヌーピングまたは中継するためのメッセージを処理していることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Abbreviations used in this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで使用される略語：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o S: IP address of the multicast source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O S：マルチキャスト送信元のIPアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o G: IP address of the multicast group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O G：マルチキャストグループのIPアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N: Upstream Neighbor field in a Join/Prune/Graft message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O N：参加/プルーン/グラフトメッセージで上流のNeighborフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Port(N): Port on which neighbor N is learned, i.e., the port on which N&#39;s Hellos are received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oポート（N）：隣人Nが学習しているポート、すなわち、Nのハローズが受信されているポート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rpt: Rendezvous Point Tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのRPT：ランデブーポイントツリー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PIM-DM: Protocol Independent Multicast - Dense Mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PIM-DM：プロトコル独立マルチキャスト - 稠密モード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PIM-SM: Protocol Independent Multicast - Sparse Mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PIM-SM：プロトコル独立マルチキャスト - スパースモード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PIM-SSM: Protocol Independent Multicast - Source-Specific Multicast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - ソース固有のマルチキャストプロトコル独立マルチキャスト：PIM-SSM O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. PIM Snooping for VPLS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
VPLS 2. PIMスヌーピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. PIM Protocol Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.  PIMプロトコルの背景
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM is a multicast routing protocol running between routers, which are CE devices in a VPLS. It uses the unicast routing table to provide reverse-path information for building multicast trees. There are a few variants of PIM. As described in RFC 3973 [PIM-DM], multicast datagrams are pushed towards downstream neighbors, similar to a broadcast mechanism, but in areas of the network where there are no group members, routers prune back branches of the multicast tree towards the source. Unlike PIM-DM, other PIM flavors (RFC 7761 [PIM-SM], RFC 4607 [PIM-SSM], and RFC 5015 [BIDIR-PIM]) employ a pull methodology via explicit Joins instead of the push-and-prune technique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMは、VPLS内のCEデバイスであるルータ間で実行されているマルチキャストルーティングプロトコルです。これは、マルチキャストツリーを構築するための逆経路情報を提供するために、ユニキャストルーティングテーブルを使用します。 PIMのいくつかのバリエーションがあります。 [PIM-DM] RFC 3973に記載されているように、マルチキャストデータグラムは、放送機構と同様下流の隣人に向かって押され、ないグループメンバーが存在しないネットワークの領域において、ルータは、ソースに向かってマルチキャストツリーの分岐をバック剪定します。 PIM-DMとは異なり、他のPIMフレーバー（RFC 7761 [PIM-SM]、RFC 4607 [PIM-SSM]、およびRFC 5015 [BIDIR-PIM]）は、明示的介しプル方法ではなく、プッシュ・アンド・プルーン技術の参加採用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM routers periodically exchange Hello messages to discover and maintain stateful sessions with neighbors. After neighbors are discovered, PIM routers can signal their intentions to join or prune specific multicast groups. This is accomplished by having downstream routers send an explicit Join/Prune message (for the sake of generalization, consider Graft messages for PIM-DM as Join messages) to their corresponding upstream router. The Join/Prune message can be group specific (*,G) or group and source specific (S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMルータは、定期的に発見し、隣人とステートフルセッションを維持するために、Helloメッセージを交換します。隣人が発見された後、PIMルータが特定のマルチキャストグループへの参加や剪定する彼らの意図を知らせることができます。これは、下流のルータを有することによって達成され、それらの対応するアップストリームルータに（メッセージに参加したように一般化のために、PIM-DMのためのグラフトメッセージを考える）明示的な参加/プルーンメッセージを送信します。参加/プルーンメッセージは、グループ特定（*、G）またはグループおよびソース特定の（S、G）とすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. General Rules for PIM Snooping in VPLS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.  VPLSでPIMスヌーピングのための一般的な規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules for the correct operation of PIM snooping MUST be followed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMスヌーピングが正しく動作するために、以下の規則に従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PIM snooping MUST NOT affect the operation of customer Layer 2 protocols or Layer 3 protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PIMスヌーピングは、顧客のレイヤ2つのプロトコルをまたはレイヤ3つのプロトコルの動作に影響してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PIM messages and multicast data traffic forwarded by PEs MUST follow the split-horizon rule for mesh PWs, as defined in RFC 4762 [VPLS-LDP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VPLS-LDP] RFC 4762で定義されているOのPEによって転送PIMメッセージ及びマルチキャストデータトラフィックは、メッシュのPW用のスプリットホライズンルールに従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PIM states in a PE MUST be per VPLS instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PEにおけるPIM状態がVPLSインスタンスごとになければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PIM Assert triggers MUST be preserved to the extent necessary to avoid sending duplicate traffic to the same PE (see Section 2.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PIMアサートトリガー（セクション2.2.1を参照）と同じPEに重複トラフィックを送信することを避けるために必要な程度に保存されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. Preserving Assert Triggers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. アサートトリガを保存
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In PIM-SM / PIM-DM, there are scenarios where multiple routers could be forwarding the same multicast traffic on a LAN. When this happens, these routers start the PIM Assert election process by sending PIM Assert messages, to ensure that only the Assert winner forwards multicast traffic on the LAN. The Assert election is a data-driven event and happens only if a router sees traffic on the interface to which it should be forwarding the traffic. In the case of a VPLS with PIM snooping, two routers may forward the same multicast datagrams at the same time, but each copy may reach a different set of PEs; this is acceptable from the point of view of avoiding duplicate traffic. If the two copies may reach the same PE, then the sending routers must be able to see each other&#39;s traffic, in order to trigger Assert election and stop duplicate traffic. To achieve that, PEs enabled with PIM-SSM / PIM-SM snooping MUST forward multicast traffic for an (S,G) / (*,G) not only on the ports on which they snooped Join(S,G) / Join(*,G) but also towards the upstream neighbor(s). In other words, the ports on which the upstream neighbors are learned must be added to the outgoing port list, along with the ports on which Joins are snooped. Please refer to Section 2.6.1 for the rules that determine the set of upstream neighbors for a particular (x,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM / PIM-DMでは、複数のルータがLAN上で同じマルチキャストトラフィックを転送することができシナリオがあります。これが発生した場合、これらのルータはアサート勝者は、LAN上のマルチキャストトラフィックを転送することを保証するために、PIMアサートメッセージを送信することにより、PIMアサート選出プロセスを開始します。アサート選挙は、データ駆動型のイベントであり、それはトラフィックを転送すべきルータがインターフェイス上のトラフィックを見ている場合にのみ発生します。 PIMスヌーピングとVPLSの場合には、2つのルータが同時に同じマルチキャストデータグラムを転送することができるが、各コピーは、PESの異なるセットに到達することができます。これは、重複したトラフィックを回避する観点から許容されます。 2つのコピーが同じPEに達する可能性があれば、送信ルータはアサート選挙の引き金と重複したトラフィックを停止するために、互いのトラフィックを見ることができなければなりません。それを達成するために、PIM-SSM / PIM-SMスヌーピングを有効にPEは（（S、G）/（*、G）だけでなく、彼らは（S、G）が参加詮索されているポートで/参加のためのマルチキャストトラフィックを転送しなければなりません*、G）だけでなく、上流隣接（S）に向かいます。つまり、上流の隣人が学習されているポートが参加を詮索されているポートと一緒に、発信ポートリストに追加する必要があります。特定の（X、G）のための上流の近隣の組を決定する規則については、セクション2.6.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, PIM-DM snooping SHOULD make sure that Asserts can be triggered (Section 2.9.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、PIM-DMスヌーピングはそれが（セクション2.9.3）をトリガすることができアサートを確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above logic needs to be facilitated without breaking VPLS split-horizon forwarding rules. That is, traffic should not be forwarded on the port on which it was received, and traffic arriving on a PW MUST NOT be forwarded onto other PW(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のロジックは、VPLSスプリットホライズンの転送ルールを壊すことなく容易に行うことが必要です。これは、トラフィックがそれを受信したポートに転送すべきではない、とPWに到着トラフィックは、他のPW（S）に転送してはならない、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Some Considerations for PIM Snooping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.  PIMスヌーピングのためのいくつかの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIM snooping solution described here requires a PE to examine and operate on only PIM Hello and PIM Join/Prune packets. The PE does not need to examine any other PIM packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで説明PIMスヌーピングソリューションを調べて/プルーンパケットの参加のみPIMこんにちは、PIM上で動作するPEが必要です。 PEは、他のPIMパケットを検査する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most of the PIM snooping procedures for handling Hello/Join/Prune messages are very similar to those executed in a PIM router. However, the PE does not need to have any routing tables like those required in PIM routing. It knows how to forward Join/Prune messages only by looking at the Upstream Neighbor field in the Join/Prune packets, as described in Section 2.12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
こんにちは/参加/プルーンのメッセージを処理するためのPIMスヌーピング手順のほとんどは、PIMルータで実行されるものと非常によく似ています。しかし、PEは、PIMルーティングに必要なような任意のルーティングテーブルを持っている必要はありません。これは、2.12節で説明したように、唯一の参加/プルーンパケットで上流隣接フィールドを見て、/参加プルーンメッセージを転送する方法を知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PE does not need to know about Rendezvous Points (RPs) and does not have to maintain any RP Set. All of that is transparent to a PIM snooping PE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEは、ランデブーポイント（RPS）について知っておく必要はなく、任意のRPセットを維持する必要はありません。すべてのことは、PEをスヌーピングPIMに対して透過的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following subsections, we list some considerations and observations for the implementation of PIM snooping in the VPLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のサブセクションでは、我々は、VPLSでPIMスヌーピングを実装するためのいくつかの考慮事項との観測を一覧表示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. Scaling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. スケーリング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM snooping needs to be employed on ACs at the downstream PEs (PEs receiving multicast traffic across the VPLS core) to prevent traffic from being sent out of ACs unnecessarily. PIM snooping techniques can also be employed on PWs at the upstream PEs (PEs receiving traffic from local ACs in a hierarchical VPLS) to prevent traffic from being sent to PEs unnecessarily. This may work well for small-scale or medium-scale deployments. However, if there are a large number of VPLS instances with a large number of PEs per instance, then the amount of snooping required at the upstream PEs can overwhelm the upstream PEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMスヌーピングが不必要のACから送信されるトラフィックを防ぐために、下流のPE（PEがVPLSコアを横切ってマルチキャストトラフィックを受信する）でACS上で使用する必要があります。 PIMスヌーピング手法はまた、不必要にPEに送信されるトラフィックを防ぐために、上流のPE（PEが階層VPLSにローカルACSからトラフィックを受信する）でのPWに使用することができます。これは、小規模または中規模の展開のために働くことがあります。 VPLSインスタンスの多数のインスタンスごとに、PEの多数である場合は、アップストリームのPEで必要スヌーピングの量は、上流のPEを圧倒することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two methods to reduce the burden on the upstream PEs. One is to use PIM proxying, as described in Section 2.6.6, to reduce the control messages forwarded by a PE. The other is not to snoop on the PWs at all but to have PEs signal the snooped states to other PEs out of band via BGP, as described in RFC 7117 [VPLS-MCAST]. In this document, it is assumed that snooping is performed on PWs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上流のPEの負担を軽減するための2つの方法があります。一つは、セクション2.6.6に記載したようにPEによって転送された制御メッセージを減らすために、PIMプロキシを使用することです。他は、RFC 7117 [VPLS-MCAST]で説明されるようにPEは、BGPを介して帯域外で他のPEへのスヌープ状態を知らせる有することが、すべてでのPWをスヌープすることはありません。この文書では、スヌーピングがPWの上で実行されているものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2. IPv4 and IPv6
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2.  IPv4とIPv6
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the VPLS, PEs forward Ethernet frames received from CEs and as such are agnostic of the Layer 3 protocol used by the CEs. However, as a PIM snooping PE, the PE would have to look deeper into the IP and PIM packets and build snooping state based on that. The PIM protocol specifications handle both IPv4 and IPv6. The specification for PIM snooping in this document can be applied to both IPv4 and IPv6 payloads.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VPLSにおいて、PEの前方イーサネットフレームは複数のCEから受信し、そのようなものとしてのCEによって使用されるレイヤ3プロトコルのとらわれています。しかし、PEスヌーピングPIMとして、PEは、IPおよびPIMパケットに深く見て、それに基づいて状態をスヌーピング構築しなければなりません。 PIMプロトコルの仕様は、IPv4とIPv6の両方を扱います。本書でスヌーピングPIMの仕様は、IPv4とIPv6の両方のペイロードに適用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.3. PIM-SM (*,*,RP)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.3.  PIM-SM（*、*、RP）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not address (*,*,RP) states in the VPLS network, as they have been removed from the PIM protocol as described in RFC 7761 [PIM-SM].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 7761に記載されているように、それらがPIMプロトコルから削除されたとして、この文書は、VPLSネットワークに（*、*、RP）状態に対処していない[PIM-SM]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. PIM Snooping vs. PIM Proxying
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.  PIMスヌーピング対PIMプロキシ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document has previously alluded to PIM snooping/relay/proxying. Details on the PIM relay/proxying solution are discussed in Section 2.6.6. In this section, a brief description and comparison are given.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、以前PIMスヌーピング/リレー/プロキシに言及しています。 PIMリレー/プロキシ・ソリューションの詳細については、2.6.6項で説明されています。このセクションでは、簡単な説明との比較が与えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.1. Differences between PIM Snooping, Relay, and Proxying
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.1.  PIMスヌーピング、リレー、およびプロキシの違い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Differences between PIM snooping and relay/proxying can be summarized as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにPIMスヌーピングおよびリレー/プロキシの違いを要約することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    +--------------------+---------------------+-----------------------+
    |     PIM snooping   |    PIM relay        |    PIM proxying       |
    +====================|=====================|=======================+
    | Join/Prune messages| Join/Prune messages | Join/Prune messages   |
    | snooped and flooded| snooped; forwarded  | consumed.  Regenerated|
    | according to VPLS  | as is out of certain| ones sent out of      |
    | flooding procedures| upstream ports      | certain upstream ports|
    +--------------------+---------------------+-----------------------+
    | Hello messages     | Hello messages      | Hello messages        |
    | snooped and flooded| snooped and flooded | snooped and flooded   |
    | according to VPLS  | according to VPLS   | according to VPLS     |
    | flooding procedures| flooding procedures | flooding procedures   |
    +--------------------+---------------------+-----------------------+
    | No PIM packets     | No PIM packets      | New Join/Prune        |
    | generated          | generated           | messages generated    |
    +--------------------+---------------------+-----------------------+
    | CE Join suppression| CE Join suppression | CE Join suppression   |
    | not allowed        | allowed             | allowed               |
    +--------------------+---------------------+-----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other than the above differences, most of the procedures are common to PIM snooping and PIM relay/proxying, unless specifically stated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の相違点以外は特に断りのない限り、手順のほとんどは、PIMスヌーピングおよびPIMリレー/プロキシに共通しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pure PIM snooping PEs simply snoop on PIM packets as they are being forwarded in the VPLS. As such, they truly provide transparent LAN services, since no customer packets are modified or consumed nor are new packets introduced in the VPLS. It is also simpler to implement than PIM proxying. However, for PIM snooping to work correctly, it is a requirement that CE routers MUST disable Join suppression in the VPLS. Otherwise, most of the CE routers with interest in a given multicast data stream will fail to send Join/Prune messages for that stream, and the PEs will not be able to tell which ACs and/or PWs have listeners for that stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らはVPLSに転送されているとして、純粋なPIMスヌーピングPEは単にPIMパケットをスヌーピング。まだカスタマーパケットがVPLSで導入された新しいパケットを変更していないか、消費もされているので、そのように、彼らは本当に、透明LANサービスを提供します。 PIMのプロキシよりも実装することも簡単です。しかし、正しく動作するPIMスヌーピングのために、それはCEルータは、VPLSに抑制を無効にする必要があり参加要件です。それ以外の場合は、指定したマルチキャストデータストリームに関心のあるCEルータのほとんどは、そのストリームのために/プルーンJoinメッセージを送信するために失敗し、PEはACSおよび/またはPWSはそのストリームのリスナーを持っている伝えることができなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given that a large number of existing CE deployments do not support the disabling of Join suppression and given the operational complexity for a provider to manage the disabling of Join suppression in the VPLS, it becomes a difficult solution to deploy. Another disadvantage of PIM snooping is that it does not scale as well as PIM proxying. If there are a large number of CEs in a VPLS, then every CE will see every other CE&#39;s Join/Prune messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のCEの展開多数の抑制に参加して、VPLSに抑制参加の無効化を管理するために、プロバイダの運用の複雑さを与えられたの無効化をサポートしていないことを考えると、それが展開するのが困難なソリューションとなります。 PIMスヌーピングのもう一つの欠点は、PIMのプロキシ処理と同様にスケールしないということです。 CEの大多数は、VPLSに存在する場合、すべてのCEは、他のすべてのCEの/参加プルーンのメッセージが表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM relay/proxying has the advantage that it does not require Join suppression to be disabled in the VPLS. Multicast as part of a VPLS can be very easily provided without requiring any changes on the CE routers. PIM relay/proxying helps scale VPLS multicast, since Join/Prune messages are only sent to certain upstream ports instead of flooded, and in cases of full proxying (vs. relay), the PEs intelligently generate only one Join/Prune message for a given multicast stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMリレー/プロキシは、それがVPLSで無効になっているの抑制に参加しましょ必要としないという利点を有します。 VPLSの一部としてマルチキャストが非常に容易にCEルータの変更を必要とせずに提供することができます。 PIM中継/プロキシ以来参加/プルーンメッセージのみ特定のアップストリームポートに送信された代わりの浸水、および（リレー対）、フルプロキシの場合には、PEがインテリジェント所与のための唯一の参加/プルーンメッセージを生成し、スケールVPLSマルチキャストを助けますマルチキャストストリーム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM proxying, however, loses the transparency argument, since Join/Prune packets could get modified or even consumed at a PE. Also, new packets could get introduced in the VPLS. However, this loss of transparency is limited to PIM Join/Prune packets. It is in the interest of optimizing multicast in the VPLS and helping a VPLS network scale much better, for both the provider and the customer. Data traffic will still be completely transparent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMのプロキシは、しかし、透明引数、以来、参加/プルーンパケットが変更され得ることができ、さらにはPEで消費を失います。また、新しいパケットがVPLSに紹介を受けることができます。しかし、透明性のこの損失は、/プルーンパケットを参加PIMに制限されています。これは、プロバイダと顧客の両方のために、VPLSでマルチキャストを最適化し、VPLSネットワークの規模を助ける利益にはるかに優れています。データトラフィックは、まだ完全に透明になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.2. PIM Control Message Latency
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.2.  PIM制御メッセージの待ち時間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM snooping/relay/proxying PE snoops on PIM Hello packets while transparently flooding them in the VPLS. As such, there is no latency introduced by the VPLS in the delivery of PIM Hello packets to remote CEs in the VPLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
透過VPLSでそれらをフラッディングしながら、PIMスヌーピング/リレー/プロキシPEは、PIM Helloパケットをスヌーピング。このように、VPLS内のリモートCEにPIM Helloパケットの配信にVPLSによって導入された待ち時間がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM snooping PE snoops on PIM Join/Prune packets while transparently flooding them in the VPLS. There is no latency introduced by the VPLS in the delivery of PIM Join/Prune packets when PIM snooping is employed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEをスヌーピングPIMは、PIMにスヌープ透過VPLSでそれらをフラッディングながら/プルーンパケットに参加。 PIMの配信にVPLSによって導入は待ち時間がPIMスヌーピングが採用されたときに/プルーンパケット参加はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM relay/proxying PE does not simply flood PIM Join/Prune packets. This can result in additional latency for a downstream CE to receive multicast traffic after it has sent a Join. When a downstream CE prunes a multicast stream, the traffic SHOULD stop flowing to the CE with no additional latency introduced by the VPLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMリレー/プロキシのPEは単にPIMは/プルーンパケット参加フラッディングされません。これは、参加を送信した後にマルチキャストトラフィックを受信するために下流のCEのための追加の待ち時間が発生することができます。下流のCEは、マルチキャストストリームを剪定すると、トラフィックがVPLSによって導入されていない追加のレイテンシでCEに流れる停止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Performing only proxying of Join/Prune and not Hello messages keeps the PE&#39;s behavior very similar to that of a PIM router, without introducing too much additional complexity. It keeps the PIM proxying solution fairly simple. Since Join/Prune messages are forwarded by a PE along the slow path and all other PIM packet types are forwarded along the fast path, it is very likely that packets forwarded along the fast path will arrive &#34;ahead&#34; of Join/Prune packets at a CE router (note the stress on the fact that fast-path messages will never arrive after Join/Prune packets). Of particular importance are Hello packets sent along the fast path. We can construct a variety of scenarios resulting in out-of-order delivery of Hellos and Join/Prune messages. However, there should be no deviation from normal expected behavior observed at the CE router receiving these messages out of order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
こんにちは参加/プルーンの唯一のプロキシを実行していないメッセージは、あまりにも多くの追加的な複雑さを導入することなく、PIMルータのものと非常に類似したPEの動作を保持します。それはかなり単純なPIMのプロキシソリューションを保持します。以来/プルーンのメッセージは、低速パスおよび高速パスに沿って転送されている他のすべてのPIMパケットタイプに沿っPEによって転送されて参加し、高速パスに沿って転送されたパケットは、時/プルーンパケット参加の「先」に到着する可能性が非常に高いですCEルータ（ファストパスメッセージは/プルーンパケットに参加した後に到着したことがないという事実上のストレスに注意してください）。特に重要なのは、ファストパスに沿って送信されたHelloパケットです。私たちはハローズのアウトオブオーダー配信結果として、さまざまなシナリオを構築し、/プルーンのメッセージに参加することができます。しかし、順不同で、これらのメッセージを受信したCEルータで観測された通常期待される行動からの逸脱があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.3. When to Snoop and When to Proxy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.3. ときスヌープへとすると、プロキシへ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the above descriptions, factors that affect the choice of snooping/relay/proxying include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以上の説明から、スヌーピング/リレー/プロキシの選択に影響を与える要因は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Whether CEs do Join suppression or not
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CEが抑制に参加したりしていないかどうかO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Whether Join/Prune latency is critical or not
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oかどうかは、/プルーンレイテンシが重要であるかを参加します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Whether the scale of PIM protocol messages/states in a VPLS requires the scaling benefit of proxying
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VPLSでのPIMプロトコルメッセージ/状態の規模は、プロキシのスケーリングの利益を必要とするかどうかO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Of the above factors, Join suppression is the hard one -- pure snooping can only be used when Join suppression is disabled on all CEs. The latency associated with relay/proxying is implementation dependent and may not be a concern at all with a particular implementation. The scaling benefit may not be important either, in that on a real LAN with Explicit Tracking (ET) a PIM router will need to receive and process all PIM Join/Prune messages as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
抑制がすべてのCE上で無効になって参加したときにのみ使用することができ、純粋スヌーピング - 上記の要因のうち、抑制が難しいものです参加。中継/プロキシに関連する待ち時間は実装依存であり、特定の実装とまったく懸念ではないかもしれません。スケーリングの利点は、明示的なトラッキング（ET）ルータが同様にすべてのPIM参加/プルーンのメッセージを受信して​​処理する必要がありますPIMと実際のLAN上のことで、どちらかは重要ではないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM router indicates that Join suppression is disabled if the T-bit is set in the LAN Prune Delay option of its Hello message. If all PIM routers on a LAN set the T-bit, ET is possible, allowing an upstream router to track all the downstream neighbors that have Join states for any (S,G) or (*,G). This has two benefits:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMルータは、Tビットは、そのHelloメッセージのLANプルーンDelayオプションに設定されている場合、その参加抑制が無効になっていることを示します。 LAN上のすべてのPIMルータがTビットを設定した場合、ETは、アップストリームルータは、任意の（S、G）または（*、G）のための状態に参加しているすべてのダウンストリームネイバーを追跡することを可能にする、ことが可能です。これには2つの利点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o No need for the Prune-Pending process -- the upstream router may immediately stop forwarding data when it receives a Prune from the last downstream neighbor and immediately prune to its upstream neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プルーン・保留処理の必要はありません○ - それは最後の下流隣人からプルーンを受信したときに、上流ルータは直ちにデータの転送を停止することがあり、すぐにその上流ネイバーにプルーニング。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For management purposes, the upstream router knows exactly which downstream routers exist for a particular Join state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
管理目的のためにO、上流のルータがダウンストリームルータが特定の参加状態のために存在するかを正確に知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While full proxying can be used with or without Join suppression on CEs and does not interfere with an upstream CE&#39;s bypass of the Prune-Pending process, it does proxy all its downstream CEs as a single one to the upstream neighbors, removing the second benefit mentioned above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フルプロキシは、一緒に使用または無しのCE上の抑制に参加し、プルーン・保留プロセスの上流のCEのバイパスを妨害しないことができるが、それが前記第二の利益を除去し、上流の近隣に単一のものとしてプロキシすべての下流のCEを行い上記。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the general rule is that if Join suppression is enabled on one or more CEs, then proxying or relay MUST be used, but if Join suppression is known to be disabled on all CEs, then snooping, relay, or proxying MAY be used, while snooping or relay SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのため、一般的なルールがあるの抑制は、一の以上のCE上で有効になって、その後リレーが使用されなければならないプロキシまたは、しかし、すべてのCEに抑制無効にすることが知られている参加した場合、その後、スヌーピング、リレー、またはプロキシを使用することができるされて参加した場合には、スヌーピングまたはリレーしながら、使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation MAY choose to dynamically determine which mode to use, through the tracking of the above-mentioned T-bit in all snooped PIM Hello messages, or MAY simply require static provisioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は動的に使用するモードを決定するために選ぶかもしれ、すべてにおける上記Tビットのトラッキングを介してPIM Helloメッセージをスヌープ、又は単に静的プロビジョニングを必要とする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. Discovering PIM Routers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5.  PIMルータを発見
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM snooping PE MUST snoop on PIM Hellos received on ACs and PWs. That is, the PE transparently floods the PIM Hello while snooping on it. PIM Hellos are used by the snooping PE to discover PIM routers and their characteristics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEは、PIM helloメッセージをスヌープしなければならないスヌーピングPIMは、ACSおよびPW上で受信されました。その上でスヌーピングしながら、つまり、PEは、透過的にPIMハローをフラッディングします。 PIMハローズは、PIMルータとその特性を発見するためにスヌーピングPEによって使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each neighbor discovered by a PE, it includes an entry in the PIM Neighbor Database with the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEによって発見された各隣人のために、それは次のフィールドを持つPIMネイバーデータベース内のエントリが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Layer 2 encapsulation for the router sending the PIM Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMハローを送信するルータのOレイヤ2カプセル化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IP address and address family of the router sending the PIM Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O IPアドレスとPIMのHelloを送信するルータのアドレスファミリ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Port (AC/PW) on which the PIM Hello was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMハローが受信されたOポート（AC / PW）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Hello Option fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
こんにちはOオプションフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PE should be able to interpret and act on Hello Option fields as currently defined in RFC 7761 [PIM-SM]. The Option fields of particular interest in this document are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEは解釈し、現在RFC 7761 [PIM-SM]で定義されたハローのオプションフィールドに作用することができなければなりません。この文書の特定の関心のオプションフィールドは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Hello-Hold-Time
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oこんにちはホールドタイム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Tracking Support
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oトラッキングのサポート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Designated Router (DR) Priority
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O指定ルータ（DR）プライオリティ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Please refer to RFC 7761 [PIM-SM] for a list of the Hello Option fields. When a PIM Hello is received, the PE MUST reset the neighbor-expiry-timer to Hello-Hold-Time. If a PE does not receive a Hello message from a router within Hello-Hold-Time, the PE MUST remove that neighbor from its PIM Neighbor Database. If a PE receives a Hello message from a router with the Hello-Hold-Time value set to zero, the PE MUST remove that router from the PIM snooping state immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
こんにちはオプションフィールドのリストについては、RFC 7761 [PIM-SM]を参照してください。 PIMハローが受信されると、PEこんにちはホールド時間に近隣有効期限タイマーをリセットしなければなりません。 PEこんにちは、ホールド時間内にルータからHelloメッセージを受信しない場合、PEはそのPIMネイバーデータベースからそのネイバーを削除する必要があります。 PEはゼロに設定こんにちは、ホールドタイム値を持つルータからHelloメッセージを受信した場合、PEは直後の状態をスヌーピングPIMからそのルータを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the PIM Neighbor Database, a PE MUST be able to use the procedures defined in RFC 7761 [PIM-SM] to identify the PIM DR in the VPLS instance. It should also be able to determine if tracking support is active in the VPLS instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMネイバーデータベースから、PEは、VPLSインスタンスでPIM DRを識別するために、[PIM-SM] RFC 7761で定義された手順を使用することができなければなりません。また、トラッキングサポートがVPLSインスタンスでアクティブであるかどうかを決定することができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6. PIM-SM and PIM-SSM
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.  PIM-SMとPIM-SSM
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key characteristic of PIM-SM and PIM-SSM is explicit Join behavior. In this model, multicast traffic is only forwarded to locations that specifically request it. All the procedures described in this section apply to both PIM-SM and PIM-SSM, except for the fact that there is no (*,G) state in PIM-SSM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SMとPIM-SSMの重要な特徴は、行動に参加し、明示的です。このモデルでは、マルチキャストトラフィックは、具体的にそれを要求した場所に転送されます。このセクションで説明するすべての手順は、PIM-SSMには（*、G）ステートが存在しないという事実を除いて、PIM-SMおよびPIM-SSMの両方に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.1. Building PIM-SM States
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.1. ビルPIM-SMの状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM and PIM-SSM states are built by snooping on the PIM-SM Join/Prune messages received on ACs/PWs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SMとPIM-SSM状態は、PIM-SMにスヌーピングによって構築されている/プルーンのメッセージは、ACS / PWを上で受信しましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The downstream state machine of a PIM-SM snooping PE very closely resembles the downstream state machine of PIM-SM routers. The downstream state consists of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SMスヌーピングPEの下流ステートマシンは、非常に密接にPIM-SMルータの下流のステートマシンに似ています。下流の状態はで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per downstream (Port,*,G):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パー下流（ポート、*、G）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DownstreamJPState: One of {&#34;NoInfo&#34; (NI), &#34;Join&#34; (J), &#34;Prune-Pending&#34; (PP)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DownstreamJPState：の一つ{ &#34;NoInfo&#34;（NI）、 &#34;参加&#34;（J）、 &#34;プルーン・保留&#34;（PP）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per downstream (Port,*,G,N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下流あたり（ポート、*、G、N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Prune-Pending Timer (PPT(N))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oプルーン・ペンディングタイマ（PPT（N））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Join Expiry Timer (ET(N))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O入会有効期限タイマ（ET（N））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per downstream (Port,S,G):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パー下流（ポート、S、G）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DownstreamJPState: One of {&#34;NoInfo&#34; (NI), &#34;Join&#34; (J), &#34;Prune-Pending&#34; (PP)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DownstreamJPState：の一つ{ &#34;NoInfo&#34;（NI）、 &#34;参加&#34;（J）、 &#34;プルーン・保留&#34;（PP）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per downstream (Port,S,G,N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下流（ポート、S、G、N）ごとに：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Prune-Pending Timer (PPT(N))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oプルーン・ペンディングタイマ（PPT（N））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Join Expiry Timer (ET(N))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O入会有効期限タイマ（ET（N））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per downstream (Port,S,G,rpt):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下流（ポート、S、G、RPT）あたり：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DownstreamJPRptState: One of {&#34;NoInfo&#34; (NI), &#34;Pruned&#34; (P), &#34;Prune-Pending&#34; (PP)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DownstreamJPRptState：の一つ{ &#34;NoInfo&#34;（NI）、（P）、 &#34;プルーン・保留&#34;（PP） &#34;剪定&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per downstream (Port,S,G,rpt,N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下流あたり（ポート、S、G、RPT、N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Prune-Pending Timer (PPT(N))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oプルーン・ペンディングタイマ（PPT（N））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Join Expiry Timer (ET(N))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O入会有効期限タイマ（ET（N））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where S is the address of the multicast source, G is the group address, and N is the Upstream Neighbor field in the Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sはマルチキャストソースのアドレスであり、Gはグループアドレスであり、Nは参加/プルーンメッセージにおける上流隣接フィールドです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that unlike the case of PIM-SM routers, where the PPT and ET are per (Interface,S,G), PIM snooping PEs have to maintain the PPT and ET per (Port,S,G,N). The reasons for this are explained in Section 2.6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPT及びETは（インターフェース、S、G）ごとであるPIM-SMルータの場合とは異なり、PIMスヌーピングPEは（ポート、S、G、N）ごとPPTおよびETを維持しなければならないことに留意されたいです。この理由は、セクション2.6.2で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Apart from the above states, we define the following state summarization macros:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記以外の状態から、我々は次の状態の要約マクロを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamNeighbors(*,G): If there are one or more Join(*,G)s received on any port with upstream neighbor N and ET(N) is active, then N is added to UpstreamNeighbors(*,G). This set is used to determine if a Join(*,G) or a Prune(*,G) with upstream neighbor N needs to be sent upstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamNeighbors（*、G）は：が一つであるか、またはより上流隣接N及びET（N）との任意のポートで受信されたS（*、G）参加アクティブである場合、NはUpstreamNeighbors（*、G）に添加します。このセットは、参加するかどうかを決定するために使用される（*、G）または上流隣接Nとプルーン（*、G）は、上流送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamNeighbors(S,G): If there are one or more Join(S,G)s received on any port with upstream neighbor N and ET(N) is active, then N is added to UpstreamNeighbors(S,G). This set is used to determine if a Join(S,G) or a Prune(S,G) with upstream neighbor N needs to be sent upstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamNeighbors（S、G）：一つ以上の参加（S、G）が存在する場合は、上流の隣人NとET（N）を有する任意のポートで受信sはアクティブであり、その後、NはUpstreamNeighbors（S、G）に添加します。このセットは、N、上流送信する必要が上流隣接して（S、G）またはプルーン（S、G）に参加するかどうかを決定するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamPorts(*,G): This is the set of all Port(N) ports where N is in the set UpstreamNeighbors(*,G). Multicast streams forwarded using a (*,G) match MUST be forwarded to these ports. So, UpstreamPorts(*,G) MUST be added to OutgoingPortList(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamPorts（*、G）：これは、Nが設定UpstreamNeighborsにあるすべてのポート（N）ポート（*、G）のセットです。 （*、G）マッチを使用して転送されたマルチキャストストリームは、これらのポートに転送されなければなりません。だから、UpstreamPorts（*、G）がOutgoingPortList（*、G）に追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamPorts(S,G): This is the set of all Port(N) ports where N is in the set UpstreamNeighbors(S,G). UpstreamPorts(S,G) MUST be added to OutgoingPortList(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamPorts（S、G）：これは、Nが設定UpstreamNeighbors（S、G）にあるすべてのポート（N）ポートのセットです。 UpstreamPorts（S、G）はOutgoingPortList（S、G）に追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
InheritedUpstreamPorts(S,G): This is the union of UpstreamPorts(S,G) and UpstreamPorts(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
InheritedUpstreamPorts（S、G）：これはUpstreamPorts（S、G）とUpstreamPorts（*、G）の労働組合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamPorts(S,G,rpt): If PruneDesired(S,G,rpt) becomes TRUE, then this set is set to UpstreamPorts(*,G). Otherwise, this set is empty. UpstreamPorts(*,G) (-) UpstreamPorts(S,G,rpt) MUST be added to OutgoingPortList(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamPorts（S、G、RPT）：PruneDesired（S、G、RPT）が真となる場合、このセットはUpstreamPorts（*、G）に設定されています。そうでない場合は、このセットは空です。 UpstreamPorts（*、G）（ - ）UpstreamPorts（S、G、RPT）がOutgoingPortList（S、G）に追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamPorts(G): This set is the union of all the UpstreamPorts(S,G) and UpstreamPorts(*,G) for a given G. Proxy (S,G) Join/Prune and (*,G) Join/Prune messages MUST be sent to a subset of UpstreamPorts(G) as specified in Section 2.6.6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamPorts（G）：このセットは、指定されたG.プロキシ（S、G）のためのすべてのUpstreamPorts（S、G）とUpstreamPorts（*、G）の労働組合である/プルーンと（*、G）が参加/プルーンのメッセージに参加セクション2.6.6.1で指定されるようにUpstreamPorts（G）のサブセットに送信されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PWPorts: This is the set of all PWs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PWPorts：これは、すべてのPWセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortList(*,G): This is the set of all ports to which traffic needs to be forwarded on a (*,G) match.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortList（*、G）：これは、トラフィックが（*、G）一致に転送する必要があるために、すべてのポートのセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortList(S,G): This is the set of all ports to which traffic needs to be forwarded on an (S,G) match.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortList（S、G）：これは、トラフィックが（S、G）一致に転送する必要があるために、すべてのポートのセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 2.12 (&#34;Data-Forwarding Rules&#34;) for the specification on how OutgoingPortList is calculated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortListを計算する方法の仕様については、セクション2.12（「データフォワーディングルール」）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NumETsActive(Port,*,G): This is the number of (Port,*,G,N) entries that have the Expiry Timer running. This macro keeps track of the number of Join(*,G)s that are received on this Port with different upstream neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NumETsActive（ポート、*、G）：これは、有効期限タイマーを実行している（ポート、*、G、N）のエントリーの数です。このマクロは、異なる上流の隣人と、このポートで受信されている参加（*、G）の数を追跡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NumETsActive(Port,S,G): This is the number of (Port,S,G,N) entries that have the Expiry Timer running. This macro keeps track of the number of Join(S,G)s that are received on this Port with different upstream neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NumETsActive（ポート、S、G）：これは、有効期限タイマーを実行している（ポート、S、G、N）のエントリの数です。このマクロは、異なる上流の隣人と、このポートで受信された参加（S、G）Sの数を追跡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinAttributeTlvs(*,G): Join Attributes (RFC 5384 [JOIN-ATTR]) are TLVs that may be present in received Join(*,G) messages. An example would be Reverse Path Forwarding (RPF) Vectors (RFC 5496 [RPF-VECTOR]). If present, they must be copied to JoinAttributeTlvs(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinAttributeTlvs（*、G）：（[JOIN-ATTR]をRFC 5384）属性の参加は、受信した参加（*、G）メッセージ中に存在してもよいのTLVです。例は、リバースパス転送（RPF）ベクター（RFC 5496 [RPF-VECTOR]）であろう。存在する場合、彼らはJoinAttributeTlvs（*、G）にコピーする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinAttributeTlvs(S,G): Join Attributes (RFC 5384 [JOIN-ATTR]) are TLVs that may be present in received Join(S,G) messages. If present, they must be copied to JoinAttributeTlvs(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinAttributeTlvs（S、G）：（[JOIN-ATTR]をRFC 5384）属性の参加は、受信した参加（S、G）メッセージ中に存在してもよいのTLVです。存在する場合、それらはJoinAttributeTlvs（S、G）にコピーする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since there are a few differences between the downstream state machines of PIM-SM routers and PIM-SM snooping PEs, we specify the details of the downstream state machine of PIM-SM snooping PEs, at the risk of repeating most of the text documented in RFC 7761 [PIM-SM].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SMルータとPIM-SMスヌーピングPEの下流のステートマシンはいくつかの違いがあるので、我々はで文書のテキストのほとんどを繰り返す危険で、PIM-SMスヌーピングPEの下流のステートマシンの詳細を指定しますRFC 7761 [PIM-SM]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.2. Explanation for Per-(S,G,N) States
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.2. パー（S、G、N）の状態についての説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In PIM routing protocols, states are built per (S,G). On a router, an (S,G) has only one RPF-Neighbor. However, a PIM snooping PE does not have the Layer 3 routing information available to the routers in order to determine the RPF-Neighbor for a multicast flow. It merely discovers it by snooping the Join/Prune message. A PE could have snooped on two or more different Join/Prune messages for the same (S,G) that could have carried different Upstream Neighbor fields. This could happen during transient network conditions or due to dual-homed sources. A PE cannot make assumptions on which one to pick but instead must allow the CE routers to decide which upstream neighbor gets elected as the RPF-Neighbor. And for this purpose, the PE will have to track downstream and upstream Joins and Prunes per (S,G,N).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMルーティングプロトコルでは、状態は（S、G）ごとに構築されます。ルータ上で、（S、G）は一つだけRPF-ネイバーを有しています。しかし、PEスヌーピングPIMは、マルチキャストフローのためのRPFネイバーを決定するためにルータに利用可能なレイヤ3ルーティング情報を有していません。これは、単に参加/プルーンのメッセージをスヌーピングすることにより、それを検出します。 PEは、異なる上流隣接フィールドを行っている可能性が同じ（S、G）のための2つ以上の異なる参加/プルーンメッセージにスヌープしている可能性があります。これは一時的なネットワークの状態の間に起こるまたはデュアルホームソースに起因することができます。 PEは、選択する代わりに、CEルータが上流の隣人がRPF-近隣に選出されますかを決定できるようにする必要がありますどちらに仮定することはできません。この目的のために、PEは、下流と上流の参加及び（S、G、N）ごとにプルーンを追跡する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3. Receiving (*,G) PIM-SM Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.3. 受信（*、G）PIM-SM参加/プルーンのメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Join(*,G) or Prune(*,G) is considered &#34;received&#34; if one of the following conditions is met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A（* G）に参加またはプルーン（*、G）は、以下のいずれかの条件が満たされた場合、「受信した」とみなされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The port on which it arrived is not Port(N) where N is the upstream neighbor N of the Join/Prune(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれが到着したポートは、ポートNが参加/プルーン（*、G）の上流隣接Nです（N）ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If both Port(N) and the arrival port are PWs, then there exists at least one other (*,G,Nx) or (Sx,G,Nx) state with an AC UpstreamPort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方のポート（N）および到着ポートのPWである場合、O、次いでAC UpstreamPortを有する少なくとも一つの他の（*、G、Nxの）または（SX、G、Nxの）状態が存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For simplicity, the case where both Port(N) and the arrival port are PWs is referred to as &#34;PW-only Join/Prune&#34; in this document. The PW-only Join/Prune handling is so that the Port(N) PW can be added to the related forwarding entries&#39; OutgoingPortList to trigger an Assert, but that is only needed for those states with AC UpstreamPorts. Note that in the PW-only case, it is OK for the arrival port and Port(N) to be the same. See Appendix B for examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
簡単にするため、ポート（N）および到着ポートの両方がのPWである場合は、この文書の「PW-のみ/プルーンに参加」と呼ばれます。 PW-のみ参加/プルーン処理するようにポート（N）PWはアサートをトリガするために、関連するフォワーディングエントリOutgoingPortListに添加することができるが、それだけAC UpstreamPortsとこれらの状態のために必要とされます。 PW-場合にのみ、同じであることが到着ポートおよびポート（N）のためのOKであることに留意されたいです。例については、付録Bを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a router receives a Join(*,G) or a Prune(*,G) with upstream neighbor N, it must process the message as defined in the state machine below. Note that the macro computations of the various macros resulting from this state machine transition are exactly as specified in RFC 7761 [PIM-SM].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルータは、上流の隣人Nと（*、G）Joinまたはプルーニング（*、G）を受信すると以下のステートマシンで定義され、それはメッセージを処理しなければなりません。 RFC 7761 [PIM-SM]で指定され、この状態マシン遷移に起因する様々なマクロのマクロ計算が正確であることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We define the following per-port (*,G,N) macro to help with the state machine below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、以下のステート・マシンを支援するために、次のポートごとに（*、G、N）マクロを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------++-------------------------------------------------+
   |               ||                 Previous State                  |
   |               ++-------------+--------------+--------------------+
   | Event         || NoInfo (NI) | Join (J)     | Prune-Pending (PP) |
   +---------------++-------------+--------------+--------------------+
   | Receive       || -&gt; J state  | -&gt; J state   | -&gt; J state         |
   | Join(*,G)     || Action      | Action       | Action             |
   |               || RxJoin(N)   | RxJoin(N)    | RxJoin(N)          |
   +---------------++-------------+--------------+--------------------+
   |Receive        || -           | -&gt; PP state  | -&gt; PP state        |
   |Prune(*,G) and ||             | Start PPT(N) |                    |
   |NumETsActive&lt;=1||             |              |                    |
   +---------------++-------------+--------------+--------------------+
   |Receive        || -           | -&gt; J state   | -                  |
   |Prune(*,G) and ||             | Start PPT(N) |                    |
   |NumETsActive&gt;1 ||             |              |                    |
   +---------------++-------------+--------------+--------------------+
   |PPT(N) expires || -           | -&gt; J state   | -&gt; NI state        |
   |               ||             | Action       | Action             |
   |               ||             | PPTExpiry(N) | PPTExpiry(N)       |
   +---------------++-------------+--------------+--------------------+
   |ET(N) expires  || -           | -&gt; NI state  | -&gt; NI state        |
   |and            ||             | Action       | Action             |
   |NumETsActive&lt;=1||             | ETExpiry(N)  | ETExpiry(N)        |
   +---------------++-------------+--------------+--------------------+
   |ET(N) expires  || -           | -&gt; J state   | -                  |
   |and            ||             | Action       |                    |
   |NumETsActive&gt;1 ||             | ETExpiry(N)  |                    |
   +---------------++-------------+--------------+--------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Figure 1: Downstream Per-Port (*,G) State Machine in Tabular Form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
図1：ダウンストリームポート単位の表形式で（*、G）ステートマシン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Action RxJoin(N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクションRxJoin（N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If ET(N) is not already running, then start ET(N). Otherwise, restart ET(N). If N is not already in UpstreamNeighbors(*,G), then add N to UpstreamNeighbors(*,G) and trigger a Join(*,G) with upstream neighbor N to be forwarded upstream. If there are Join Attribute TLVs in the received (*,G) message and if they are different from the recorded JoinAttributeTlvs(*,G), then copy them into JoinAttributeTlvs(*,G). In the case of conflicting attributes, the PE will need to perform conflict resolution per (N) as described in RFC 5384 [JOIN-ATTR].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ET（N）がすでに実行されていない場合は、ET（N）を起動します。それ以外の場合は、ET（N）を再起動します。 NはUpstreamNeighbors（*、G）にない場合、UpstreamNeighbors（*、G）にNを追加し、（*、G）上流の隣人Nと、上流転送する参加トリガー。そこに受信（*、G）メッセージ内の属性のTLVに参加していると、彼らが記録さJoinAttributeTlvs（*、G）が異なっている場合、JoinAttributeTlvs（*、G）にコピーした場合。矛盾する属性の場合、PEは、RFC 5384 [JOIN-ATTR]に記載されているように（N）当たりの競合解決を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Action PPTExpiry(N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクションPPTExpiry（N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Same as Action ETExpiry(N) below, plus send a Prune-Echo(*,G) with upstream neighbor N on the downstream port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下のアクションETExpiry（N）と同じで、プラスダウンストリームポートの上流の隣人Nとプルーン・エコー（*、G）を送ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Action ETExpiry(N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクションETExpiry（N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Disable timers ET(N) and PPT(N). Delete Neighbor state (Port,*,G,N). If there are no other (Port,*,G) states with NumETsActive(Port,*,G) &gt; 0, transition DownstreamJPState (RFC 7761 [PIM-SM]) to NoInfo. If there are no other (Port,*,G,N) states (different ports but for the same N), remove N from UpstreamPorts(*,G) -- this will also trigger the Upstream Finite State Machine (FSM) with &#34;JoinDesired(*,G,N) to FALSE&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
無効タイマET（N）とPPT（N）。近隣の状態（ポート、*、G、N）を削除します。他に存在しない場合（ポートは、*、G）NoInfoにNumETsActive（ポート、*、G）&gt; 0、遷移DownstreamJPState（RFC 7761 [PIM-SM]）と述べています。無（ポート、*、G、N）の状態、他の（異なるポートが、同じNのためには）存在しない場合は、UpstreamPorts（*、G）からNを削除する - これはまた、「上流有限状態機械（FSM）をトリガしますJoinDesired FALSEに（*、G、N）」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.4. Receiving (S,G) PIM-SM Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.4. 受信（S、G）PIM-SM参加/プルーンのメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Join(S,G) or Prune(S,G) is considered &#34;received&#34; if one of the following conditions is met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
：A参加（S、G）またはプルーン（S、G）は、以下のいずれかの条件が満たされた場合、「受信した」とみなされます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The port on which it arrived is not Port(N) where N is the upstream neighbor N of the Join/Prune(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N参加/プルーン（S、G）の上流隣接Nである場合、それが到着したポートOポート（N）ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If both Port(N) and the arrival port are PWs, then there exists at least one other (*,G,Nx) or (S,G,Nx) state with an AC UpstreamPort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方のポート（N）および到着ポートのPWである場合、O、次いでAC UpstreamPortを有する少なくとも一つの他の（*、G、Nxの）または（S、G、Nxの）状態が存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For simplicity, the case where both Port(N) and the arrival port are PWs is referred to as &#34;PW-only Join/Prune&#34; in this document. The PW-only Join/Prune handling is so that the Port(N) PW can be added to the related forwarding entries&#39; OutgoingPortList to trigger an Assert, but that is only needed for those states with AC UpstreamPorts. Note that in the PW-only case, it is OK for the arrival port and Port(N) to be the same. See Appendix B for examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
簡単にするため、ポート（N）および到着ポートの両方がのPWである場合は、この文書の「PW-のみ/プルーンに参加」と呼ばれます。 PW-のみ参加/プルーン処理するようにポート（N）PWはアサートをトリガするために、関連するフォワーディングエントリOutgoingPortListに添加することができるが、それだけAC UpstreamPortsとこれらの状態のために必要とされます。 PW-場合にのみ、同じであることが到着ポートおよびポート（N）のためのOKであることに留意されたいです。例については、付録Bを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a router receives a Join(S,G) or a Prune(S,G) with upstream neighbor N, it must process the message as defined in the state machine below. Note that the macro computations of the various macros resulting from this state machine transition are exactly as specified in RFC 7761 [PIM-SM].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルータは、上流隣接Nと（S、G）またはプルーン（S、G）参加を受信した場合に以下の状態マシンで定義され、それはメッセージを処理しなければなりません。 RFC 7761 [PIM-SM]で指定され、この状態マシン遷移に起因する様々なマクロのマクロ計算が正確であることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------++-------------------------------------------------+
   |               ||                 Previous State                  |
   |               ++-------------+--------------+--------------------+
   | Event         || NoInfo (NI) | Join (J)     | Prune-Pending (PP) |
   +---------------++-------------+--------------+--------------------+
   | Receive       || -&gt; J state  | -&gt; J state   | -&gt; J state         |
   | Join(S,G)     || Action      | Action       | Action             |
   |               || RxJoin(N)   | RxJoin(N)    | RxJoin(N)          |
   +---------------++-------------+--------------+--------------------+
   |Receive        || -           | -&gt; PP state  | -                  |
   |Prune(S,G) and ||             | Start PPT(N) |                    |
   |NumETsActive&lt;=1||             |              |                    |
   +---------------++-------------+--------------+--------------------+
   |Receive        || -           | -&gt; J state   | -                  |
   |Prune(S,G) and ||             | Start PPT(N) |                    |
   |NumETsActive&gt;1 ||             |              |                    |
   +---------------++-------------+--------------+--------------------+
   |PPT(N) expires || -           | -&gt; J state   | -&gt; NI state        |
   |               ||             | Action       | Action             |
   |               ||             | PPTExpiry(N) |PPTExpiry(N)        |
   +---------------++-------------+--------------+--------------------+
   |ET(N) expires  || -           | -&gt; NI state  | -&gt; NI state        |
   |and            ||             | Action       | Action             |
   |NumETsActive&lt;=1||             | ETExpiry(N)  | ETExpiry(N)        |
   +---------------++-------------+--------------+--------------------+
   |ET(N) expires  || -           | -&gt; J state   | -                  |
   |and            ||             | Action       |                    |
   |NumETsActive&gt;1 ||             | ETExpiry(N)  |                    |
   +---------------++-------------+--------------+--------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Figure 2: Downstream Per-Port (S,G) State Machine in Tabular Form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
図2：表形式でダウンストリームポート単位の（S、G）ステートマシン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Action RxJoin(N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクションRxJoin（N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If ET(N) is not already running, then start ET(N). Otherwise, restart ET(N).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ET（N）がすでに実行されていない場合は、ET（N）を起動します。それ以外の場合は、ET（N）を再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If N is not already in UpstreamNeighbors(S,G), then add N to UpstreamNeighbors(S,G) and trigger a Join(S,G) with upstream neighbor N to be forwarded upstream. If there are Join Attribute TLVs in the received (S,G) message and if they are different from the recorded JoinAttributeTlvs(S,G), then copy them into JoinAttributeTlvs(S,G). In cases of conflicting attributes, the PE will need to perform conflict resolution per (N) as described in RFC 5384 [JOIN-ATTR].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NはUpstreamNeighbors（S、G）にない場合、UpstreamNeighbors（S、G）にNを追加して、上流側に転送する上流隣接Nとの結合（S、G）をトリガします。ある場合は、受信した（S、G）メッセージ内の属性のTLVに参加し、彼らが記録さJoinAttributeTlvs（S、G）と異なっている場合、JoinAttributeTlvs（S、G）にコピーします。矛盾する属性の場合には、PEは、RFC 5384 [JOIN-ATTR]に記載されているように（N）当たりの競合解決を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Action PPTExpiry(N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクションPPTExpiry（N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Same as Action ETExpiry(N) below, plus send a Prune-Echo(S,G) with upstream neighbor N on the downstream port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下のアクションETExpiry（N）と同じ、プラスダウンストリームポートに上流隣接Nとプルーンエコー（S、G）を送ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Action ETExpiry(N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクションETExpiry（N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Disable timers ET(N) and PPT(N). Delete Neighbor state (Port,S,G,N). If there are no other (Port,S,G) states with NumETsActive(Port,S,G) &gt; 0, transition DownstreamJPState to NoInfo. If there are no other (Port,S,G,N) states (different ports but for the same N), remove N from UpstreamPorts(S,G) -- this will also trigger the Upstream FSM with &#34;JoinDesired(S,G,N) to FALSE&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
無効タイマET（N）とPPT（N）。近隣状態（ポート、S、G、N）を削除します。他（ポート、S、G）が存在しない場合NumETsActive（ポート、S、G）&gt; 0、NoInfoへ遷移DownstreamJPStateと述べています。他（ポート、S、G、N）の状態（異なるポートが、同じNの場合）、UpstreamPorts（S、G）から、Nを削除がない場合 - これはまたJoinDesired（S、G」上流FSMをトリガしますFALSEに、N）」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.5. Receiving (S,G,rpt) Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.5.  （S、G、RPT）/プルーンのメッセージを受信参加
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Join(S,G,rpt) or Prune(S,G,rpt) is &#34;received&#34; when the port on which it was received is not also the port on which the upstream neighbor N of the Join/Prune(S,G,rpt) was learned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S、G、RPT）又はプルーン（S、G、RPT）が受信したポートがポートもない場合、「受信」さに参加した上で参加/プルーン（S、Gの上流隣接N 、RPT）を学びました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While it is important to ensure that the (S,G) and (*,G) state machines allow for handling per-(S,G,N) states, it is not as important for (S,G,rpt) states. It suffices to say that the downstream (S,G,rpt) state machine is the same as what is defined in Section 4.5.3 of RFC 7761 [PIM-SM].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは（S、G）および（*、G）ステート・マシンは（S、G、N）状態をパーハンドリングを可能にすることを確実にするために重要であるが、それは（S、G、RPT）の状態のために重要ではありません。これは、下流の（S、G、RPT）ステートマシンは、RFC 7761 [PIM-SM]のセクション4.5.3で定義されているものと同じであると言うことで十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.6. Sending Join/Prune Messages Upstream
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.6. 上流参加/プルーンのメッセージの送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section applies only to a PIM relay/proxying PE and not to a PIM snooping PE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、唯一のPIMリレー/プロキシのPEにはないPEをスヌーピングPIMに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A full PIM proxying (not relay) PE MUST implement the Upstream FSM along the lines of the procedure described in Section 4.5.4 of RFC 7761 [PIM-SM].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全なPIMのプロキシ（中継しない）PEは、RFC 7761のセクション4.5.4に記載された手順の線に沿って[PIM-SMを上流FSMを実装しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of the Upstream FSM, a Join or Prune message with upstream neighbor N is &#34;seen&#34; on a PIM relay/proxying PE if the port on which the message was received is also Port(N) and the port is an AC. The AC requirement is needed because a Join received on the Port(N) PW must not suppress this PE&#39;s Join on that PW.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージを受信したポートはまた、ポート（N）であり、ポートがACである場合に上流FSMの目的のために、上流隣接Nと結合またはプルーニングメッセージは、PIM中継/プロキシのPEの「見」されています。このPEのはPWことで参加抑制してはならないポート（N）PW上で受信入会ので、AC要件が必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM relay PE does not implement the Upstream FSM. It simply forwards received Join/Prune messages out of the same set of upstream ports as in the PIM proxying case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMリレーPEは、上流FSMを実装していません。単に転送PIMのプロキシの場合のようにアップストリームポートの同じセットのうち/参加プルーンメッセージを受信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to correctly facilitate Asserts among the CE routers, such Join/Prune messages need to send not only towards the upstream neighbor but also on certain PWs, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後述のように正しくCEルータ間アサート容易にするために、このような参加/プルーンのメッセージは、上流隣接の方だけでなく、特定のPWの上だけでなく、送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If JoinAttributeTlvs(*,G) is not empty, then it must be encoded in a Join(*,G) message sent upstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinAttributeTlvs（*、G）が空でない場合、それは上流の送信参加（*、G）メッセージに符号化されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If JoinAttributeTlvs(S,G) is not empty, then it must be encoded in a Join(S,G) message sent upstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinAttributeTlvs（S、G）が空でない場合、それは上流の送信参加（S、G）メッセージに符号化されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.6.1. Where to Send Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6.6.1。どこに参加/プルーンのメッセージを送信すること
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules apply to both (1) forwarded (in the case of PIM relay) and (2) refreshed and triggered (in the case of PIM proxying) (S,G) / (*,G) Join/Prune messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/プルーンメッセージを参加（G、*）/（S、G）の規則（1）（PIMリレーの場合）転送され、（2）リフレッシュし（PIMのプロキシの場合）トリガの両方に適用される以下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Upstream Neighbor field in the Join/Prune to be sent is set to the N in the corresponding Upstream FSM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O参加/プルーンにおける上流隣接フィールドは、対応するアップストリームFSMにNに設定されて送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If Port(N) is an AC, send the message to Port(N).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oポート（N）がACである場合には、ポート（N）にメッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Additionally, if OutgoingPortList(x,G,N) contains at least one AC, then the message MUST be sent to at least all the PWs in UpstreamPorts(G) (for (*,G)) or InheritedUpstreamPorts(S,G) (for (S,G)). Alternatively, the message MAY be sent to all PWs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortList（X、G、N）は、少なくとも1つのAC、次いで、メッセージは（）*、G（ため）UpstreamPortsに少なくとも全てのPW（G）に送信しなければならないか、またはInheritedUpstreamPorts（S、G）が含まれている場合、さらに、O （（S、G）のために）。また、メッセージはすべてのPWに送ってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sending to a subset of PWs as described above guarantees that if traffic (of the same flow) from two upstream routers were to reach this PE, then the two routers will receive from each other, triggering an Assert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保証上記のように2つのアップストリームルータから（同じ流量の）トラフィックが、このPEに到達した場合、2つのルータがアサートをトリガー、互いから受け取ることのPWのサブセットに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sending to all PWs guarantees that if two upstream routers both send traffic for the same flow (even if it is to different sets of downstream PEs), then the two routers will receive from each other, triggering an Assert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全てのPWへの送信は、2つのアップストリームルータが同じフロー（それは下流のPEの異なるセットにある場合でも）のためにトラフィックを送信し、両方の場合、2つのルータがアサートをトリガー、互いから受け取ることを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.7. Bidirectional PIM (BIDIR-PIM)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.7. 双方向PIM（BIDIR-PIM）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bidirectional PIM (BIDIR-PIM) is a variation of PIM-SM. The main differences between PIM-SM and BIDIR-PIM are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双方向PIM（BIDIR-PIM）は、PIM-SMの変形例です。次のようにPIM-SMとBIDIR-PIMとの主な違いは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There are no source-based trees, and SSM is not supported (i.e., no (S,G) states) in BIDIR-PIM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそこにはソースベースのツリーではない、とSSMはBIDIR-PIMに（即ち、なし（S、G）ステートを）サポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Multicast traffic can flow up the shared tree in BIDIR-PIM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OマルチキャストトラフィックはBIDIR-PIMで共有ツリーを流すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To avoid forwarding loops, one router on each link is elected as the Designated Forwarder (DF) for each RP in BIDIR-PIM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送ループを回避するために、Oは、各リンク上のルータはBIDIR-PIM内の各RP用に指定フォワーダ（DF）として選出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The main advantage of BIDIR-PIM is that it scales well for many-to-many applications. However, the lack of source-based trees means that multicast traffic is forced to remain on the shared tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BIDIR-PIMの主な利点は、多対多のアプリケーションにもスケールするということです。しかし、ソースベースの木の欠如は、マルチキャストトラフィックを共有ツリーの上に残ることを余儀なくされていることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in RFC 5015 [BIDIR-PIM], parts of a BIDIR-PIM-enabled network may forward traffic without exchanging Join/Prune messages -- for instance, between DFs and the Rendezvous Point Link (RPL).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、DFSおよびランデブーポイントリンク（RPL）の間 -  RFC 5015 [BIDIR-PIM]に記載されているように、BIDIR-PIM対応ネットワークの部分は/参加プルーンメッセージを交換することなく、トラフィックを転送することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the described procedures for PIM snooping rely on the presence of Join/Prune messages, enabling PIM snooping on BIDIR-PIM networks could break the BIDIR-PIM functionality. Deploying PIM snooping on BIDIR-PIM-enabled networks will require some further study. Some thoughts on this topic are discussed in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMスヌーピングについて説明した手順のようBIDIR-PIM機能を破ることができBIDIR-PIMネットワーク上でPIMスヌーピングを有効にする、参加/プルーンのメッセージの存在に依存しています。 BIDIR-PIM対応ネットワーク上のPIMスヌーピングを展開すると、いくつかのさらなる研究が必要になります。このトピックに関するいくつかの考えは、付録Aで説明されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8. Interaction with IGMP Snooping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8.  IGMPスヌーピングとの相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever IGMP snooping is enabled in conjunction with PIM snooping in the same VPLS instance, the PE SHOULD follow these rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMPスヌーピングが同じVPLSインスタンスにスヌーピングPIMと組み合わせて有効になっているときはいつでも、PEは、これらの規則に従ってください：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To maintain the list of multicast routers and ports on which they are attached, the PE SHOULD NOT use the rules described in RFC 4541 [IGMP-SNOOP] but SHOULD rely on the neighbors discovered by PIM snooping. This list SHOULD then be used to apply the first forwarding rule (rule 1) listed in Section 2.1.1 of RFC 4541 [IGMP-SNOOP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oは、それらが結合されているマルチキャストルータおよびポートのリストを維持するために、PEは、RFC 4541 [IGMPスヌープ]に記載のルールを使用するべきではなく、PIMスヌーピングによって検出されたネイバーに依存しているべきです。このリストは、その後、RFC 4541 [IGMPスヌープ]のセクション2.1.1に記載されている最初の転送ルール（ルール1）を適用するために使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the PE supports proxy reporting, an IGMP membership learned only on a port to which a PIM neighbor is attached (i.e., not learned elsewhere) SHOULD NOT be included in the summarized upstream report sent to that port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEは、プロキシレポートをサポートしている場合は、O、IGMPメンバーシップ（すなわち、他の場所で学習していない）がPIMネイバーが接続されているポート上でのみ学んだそのポートに送らまとめ上流の報告書に含めるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9. PIM-DM
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.  PIM-DM
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key characteristic of PIM-DM is flood-and-prune behavior. Shortest-path trees are built as a multicast source starts transmitting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DMの主要な特徴は、洪水と-プルーンの動作です。マルチキャストソースが送信を開始するように最短パス木が構築されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.1. Building PIM-DM States
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.1. ビルPIM-DMの状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM states are built by snooping on the PIM-DM Join, Prune, Graft, and State Refresh messages received on ACs/PWs and State Refresh messages sent on ACs/PWs. By snooping on these PIM-DM messages, a PE builds the following states per (S,G,N) where S is the address of the multicast source, G is the group address, and N is the upstream neighbor to which Prunes/Grafts are sent by downstream CEs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DMの状態が参加PIM-DMにスヌーピングによって構築され、プルーン、グラフト、およびステートリフレッシュメッセージは、ACS / PWの上で送信されるのAC / PWをし、ステートリフレッシュメッセージで受信しました。これらのPIM-DMメッセージスヌーピングによって、PE Sはマルチキャスト送信元のアドレスである（S、G、N）ごとに次の状態を構築し、Gはグループアドレスであり、Nは、プルーン/グラフトの上流隣接あります下流のCEによって送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per PIM(S,G,N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DRINKあたり（C、H、N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Port PIM(S,G,N) Prune State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ポートPIM（S、G、N）プルーン状態：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DownstreamPState(S,G,N,Port): One of {&#34;NoInfo&#34; (NI), &#34;Pruned&#34; (P), &#34;Prune-Pending&#34; (PP)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DownstreamPState（S、G、N、ポート）の一つ{ &#34;NoInfo&#34;（NI）、 &#34;プルーニング&#34;（P）、 &#34;プルーン・保留&#34;（PP）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Prune-Pending Timer (PPT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
*プルーン-保留タイマー（PPT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Prune Timer (PT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
*プルーンタイマー（PT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Upstream Port (valid if the PIM(S,G,N) Prune state is &#34;Pruned&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
*アップストリームポート（有効なPIM（S、G、N）プルーン状態は &#34;剪定&#34; されている場合）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.2. PIM-DM Downstream Per-Port PIM(S,G,N) State Machine
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.2.  PIM-DMダウンストリームポート単位のPIM（S、G、N）ステートマシン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The downstream per-port PIM(S,G,N) state machine is as defined in Section 4.4.2 of RFC 3973 [PIM-DM], with a few changes relevant to PIM snooping. When reading Section 4.4.2 of RFC 3973 [PIM-DM], please be aware that, for the purposes of PIM snooping, the downstream states are built per (S,G,N,Downstream-Port) in PIM snooping and not per (Downstream-Interface,S,G) as in a PIM-DM router. As noted in Section 2.9.1, the states (DownstreamPState) and timers (PPT and PT) are per (S,G,N,Port).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMスヌーピングに関連するいくつかの変更と、RFC 3973 [PIM-DM]のセクション4.4.2で定義されるように、下流ポートごとのPIM（S、G、N）状態機械です。 RFC 3973 [PIM-DM]の4.4.2項を読んだときは、PIMスヌーピングの目的のために、下流の状態があたりPIMスヌーピングではなく（S、G、N、ダウンストリームポート）ごとに構築されている、ということに注意してください。 PIM-DMルータのように（下流-インタフェース、S、G）。セクション2.9.1で述べたように、状態（DownstreamPState）及びタイマ（PPT及びPT）が（S、G、N、ポート）ごとです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.3. Triggering Assert Election in PIM-DM
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9.3.  PIM-DMでアサート選挙のトリガ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since PIM-DM is a flood-and-prune protocol, traffic is flooded to all routers unless explicitly pruned. Since PIM-DM routers do not prune on non-RPF interfaces, PEs should typically not receive Prunes on Port(RPF-Neighbor). So, the asserting routers should typically be in pim_oiflist(S,G). In most cases, Assert election should occur naturally without any special handling, since data traffic will be forwarded to the asserting routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DMは、洪水と-プルーンのプロトコルであるので、明示的に剪定されていない限り、トラフィックはすべてのルータにフラッディングされます。 PIM-DMルータは非RPFインターフェイス上で整理しませんので、PEは通常、ポート（RPF-ネイバー）にプルーンを受けるべきではありません。だから、主張するルータは、一般的に（S、G）pim_oiflistにする必要があります。ほとんどの場合、データトラフィックがアサートルータに転送されるので、任意の特別な処理せずに自然に起こるべき選挙をアサートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, there are some scenarios where a Prune might be received on a port that is also an upstream port. If we prune the port from pim_oiflist(S,G), then it would not be possible for the asserting routers to determine if traffic arrived on their downstream port. This can be fixed by adding pim_iifs(S,G) to pim_oiflist(S,G) so that data traffic flows to the upstream ports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、プルーンもアップストリームポートであるポートで受信される可能性がありますいくつかのシナリオがあります。我々はpim_oiflist（S、G）からポートを剪定した場合、トラフィックが自分のダウンストリームポートに到着した場合にアサートルータが決定するために、それは可能ではないでしょう。これは、データトラフィックがアップストリームポートに流れるように（S、G）をpim_oiflistするpim_iifs（S、G）を添加することにより固定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10. PIM Proxy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10. ピム領事
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted earlier, PIM snooping will work correctly only if Join suppression is disabled in the VPLS. If Join suppression is enabled in the VPLS, then PEs MUST do PIM relay/proxying for VPLS multicast to work correctly. This section applies specifically to full proxying and not to relay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先に述べたように、PIMスヌーピングが参加抑制がVPLSで無効になっている場合にのみ正しく動作します。参加抑制がVPLSで有効になっている場合には、PEが正しく機能するVPLSマルチキャスト用のPIMリレー/プロキシを行う必要があります。このセクションでは、フルプロキシに特異的に適用され、中継することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.1. Upstream PIM Proxy Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10.1. 上流PIMプロキシ動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM proxying PE consumes Join/Prune messages and regenerates PIM Join/Prune messages to be sent upstream by implementing the Upstream FSM as specified in Section 4.5.4 of RFC 7761 [PIM-SM]. This is the only difference from PIM relay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMのプロキシPEは/プルーンJoinメッセージを消費し、RFC 7761 [PIM-SM]のセクション4.5.4で指定されるようにPIMは/上流FSMを実装することにより、上流送信するプルーンJoinメッセージを再生します。これは、PIMリレーとの唯一の違いです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The source IP address in PIM packets sent upstream SHOULD be the address of a PIM downstream neighbor in the corresponding Join/Prune state. The chosen address MUST NOT be the Upstream Neighbor field to be encoded in the packet. The Layer 2 encapsulation for the selected source IP address MUST be the encapsulation recorded in the PIM Neighbor Database for that IP address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アップストリーム送信されたPIMパケット内のソースIPアドレスは、対応する参加/プルーン状態でPIM下流ネイバーのアドレスでなければなりません。選択したアドレスはパケットに符号化する上流隣接フィールドにすることはできません。選択された送信元IPアドレスのレイヤ2カプセル化は、そのIPアドレスのPIMネイバーデータベースに記録されているカプセル化でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.11. Directly Connected Multicast Source
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.11. 直接接続されているマルチキャストソース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM snooping/relay/proxying could be enabled on a LAN that connects a multicast source and a PIM First-Hop Router (FHR). As the FHR will not send any downstream Join/Prune messages, we will not be able to establish any forwarding states for that source. Therefore, if there is a source in the CE network that connects directly into the VPLS instance, then multicast traffic from that source MUST be sent to all PIM routers on the VPLS instance in addition to the IGMP receivers in the VPLS. If there is already (S,G) or (*,G) snooping state that is formed on any PE, this will not happen per the current forwarding rules and guidelines. So, in order to determine if traffic needs to be flooded to all routers, a PE must be able to determine if the traffic came from a host on that LAN. There are three ways to address this problem:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIMスヌーピング/リレー/プロキシは、マルチキャストソースとPIMファーストホップルータ（FHR）を接続しているLAN上で有効にすることができます。 FHRは/プルーンのメッセージを参加任意の下流を送信しないように、私たちはそのソースのいずれかの転送状態を確立することができません。 VPLSインスタンスに直接接続CEネットワーク内のソースがある場合、したがって、そのソースからのマルチキャストトラフィックは、VPLS内のIGMP受信機に加えて、VPLSインスタンス上のすべてのPIMルータに送信されなければなりません。任意のPE上に形成されている（S、G）または（*、G）スヌーピング状態が既に存在する場合、これは現在の転送ルールおよびガイドラインごとに起こることはありません。トラフィックは、そのLAN上のホストから来たのであれば、トラフィックはすべてのルータにフラッディングする必要があるかどうかを決定するために、PEは決定できなければなりません。この問題に対処する3つの方法があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The PE would have to do IPv4 ARP snooping and/or IPv6 Neighbor Discovery snooping to determine if a source is directly connected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PEは、IPv4のARPスヌーピングおよび/またはIPv6近隣探索は、ソースが直接接続されているかどうかを決定するためにスヌーピングしなければならないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Another option is to configure all PEs to indicate that there are CE sources that are directly connected to the VPLS instance and disallow snooping for the groups for which the source is going to send traffic. This way, traffic from that source to those groups will always be flooded within the provider network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O別のオプションは直接VPLSインスタンスに接続し、ソースがトラフィックを送信しようとしているためにグループのためにスヌーピング禁止されているCEソースがあることを示すために、すべてのPEを構成することです。このように、それらのグループにそのソースからのトラフィックは常に、プロバイダのネットワーク内でフラッディングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A third option is to require that sources of CE multicast traffic must be behind a router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O第三の選択肢は、CEのマルチキャストトラフィックのソースはルータの背後でなければならないことを要求することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document recommends the third option -- sources of traffic must be behind a router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、第三のオプションをお勧めします - トラフィックのソースはルータの背後に配置する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.12. Data-Forwarding Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.12. データフォワーディングルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, we define the rules that are common to PIM-SM and PIM-DM PEs. Forwarding rules for each protocol type are specified in the subsections below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、我々は、PIM-SMとPIM-DMのPEに共通なルールを定義します。各プロトコルタイプの転送ルールは、以下のサブセクションで指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is no matching forwarding state, then the PE SHOULD discard the packet, i.e., the UserDefinedPortList (Sections 2.12.1 and 2.12.2) SHOULD be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
該当転送状態がない場合、PE、すなわち、UserDefinedPortList（セクション2.12.1および2.12.2）が空になり、パケットを破棄すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following general rules MUST be followed when forwarding multicast traffic in a VPLS:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VPLSにマルチキャストトラフィックを転送するときは、次の一般的な規則に従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Traffic arriving on a port MUST NOT be forwarded back onto the same port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oポートに着信したトラフィックは、同じポート上にバック転送されてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Due to VPLS split-horizon rules, traffic ingressing on a PW MUST NOT be forwarded to any other PW.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O VPLSスプリットホライズンのルールのため、PW上のトラフィックの着信するには、他のどのPWに転送してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.12.1. PIM-SM Data-Forwarding Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.12.1.  PIM-SMのデータフォワーディングルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per the rules in RFC 7761 [PIM-SM] and per the additional rules specified in this document,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 7761の規則ごとの[PIM-SM]この文書で指定された追加ルールごとに、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortList(*,G) = immediate_olist(*,G) (+) UpstreamPorts(*,G) (+) Port(PimDR)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortList（*、G）= immediate_olist（*、G）（+）UpstreamPorts（*、G）（+）ポート（PimDR）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortList(S,G) = inherited_olist(S,G) (+) UpstreamPorts(S,G) (+) (UpstreamPorts(*,G) (-) UpstreamPorts(S,G,rpt)) (+) Port(PimDR)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortList（S、G）=引き継いでいる_olist（S、G）（+）UpstreamPorts（S、G）（+）（UpstreamPorts（*、G）（ - ）UpstreamPorts（S、G、RPT））（+）ポート（PimDR ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 7761 [PIM-SM] specifies how immediate_olist(*,G) and inherited_olist(S,G) are built. PimDR is the IP address of the PIM DR in the VPLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 7761 [PIM-SM]はimmediate_olist（*、G）と引き継いでいる_olist（S、G）が構築される方法を指定します。 PimDRは、VPLSにおけるPIM DRのIPアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIM-SM snooping data-forwarding rules are defined below in pseudocode:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SMスヌーピングデータ転送ルールは、擬似コードで以下に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BEGIN iif is the incoming port of the multicast packet. S is the source IP address of the multicast packet. G is the destination IP address of the multicast packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストパケットの着信ポートであるIIF BEGIN。 Sは、マルチキャストパケットの送信元IPアドレスです。 Gは、マルチキャストパケットの宛先IPアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       If there is (S,G) state on the PE
       Then
           OutgoingPortList = OutgoingPortList(S,G)
       Else if there is (*,G) state on the PE
       Then
           OutgoingPortList = OutgoingPortList(*,G)
       Else
           OutgoingPortList = UserDefinedPortList
       Endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If iif is an AC Then OutgoingPortList = OutgoingPortList (-) iif Else ## iif is a PW OutgoingPortList = OutgoingPortList (-) PWPorts Endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IIFはACである場合、OutgoingPortList = OutgoingPortList（ - ）IIFエルス## IIFあるPW OutgoingPortList = OutgoingPortList（ - ）PWPorts ENDIF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Forward the packet to OutgoingPortList. END
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortListにパケットを転送します。終わり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, if there is (S,G) state on the PE, then the set of outgoing ports is OutgoingPortList(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PE上の（S、G）状態が存在する場合、最初に、次に送信ポートのセットがOutgoingPortList（S、G）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, if there is (*,G) state on the PE, then the set of outgoing ports is OutgoingPortList(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PE上の（*、G）状態がある場合にそうでない場合、次に送信ポートのセットがOutgoingPortList（*、G）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet is forwarded to the selected set of outgoing ports while observing the general rules above in Section 2.12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション2.12で上記の一般的なルールを観察しながら、パケットが発信ポートの選択されたセットに転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.12.2. PIM-DM Data-Forwarding Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.12.2.  PIM-DMデータフォワーディングルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIM-DM snooping data-forwarding rules are defined below in pseudocode:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DMスヌーピングデータ転送ルールは、擬似コードで以下に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BEGIN iif is the incoming port of the multicast packet. S is the source IP address of the multicast packet. G is the destination IP address of the multicast packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストパケットの着信ポートであるIIF BEGIN。 Sは、マルチキャストパケットの送信元IPアドレスです。 Gは、マルチキャストパケットの宛先IPアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       If there is (S,G) state on the PE
       Then
           OutgoingPortList = olist(S,G)
       Else
           OutgoingPortList = UserDefinedPortList
       Endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If iif is an AC Then OutgoingPortList = OutgoingPortList (-) iif Else ## iif is a PW OutgoingPortList = OutgoingPortList (-) PWPorts Endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IIFはACである場合、OutgoingPortList = OutgoingPortList（ - ）IIFエルス## IIFあるPW OutgoingPortList = OutgoingPortList（ - ）PWPorts ENDIF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Forward the packet to OutgoingPortList. END
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortListにパケットを転送します。終わり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is forwarding state for (S,G), then forward the packet to olist(S,G) while observing the general rules above in Section 2.12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送状態が（S、G）のためにそこにある場合、セクション2.12で上記の一般的なルールを観察しながら、次いでOLIST（S、G）にパケットを転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 3973 [PIM-DM] specifies how olist(S,G) is constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 3973は、[PIM-DM] OLIST（S、G）が構築される方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not require any IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IANAのアクションを必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.セキュリティについての考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security considerations provided in the VPLS solution documents (i.e., RFC 4762 [VPLS-LDP] and RFC 4761 [VPLS-BGP]) apply to this document as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VPLS溶液文書で提供されるセキュリティ上の考慮事項（すなわち、RFC 4762 [VPLS-LDP]およびRFC 4761 [VPLS-BGP]）は、同様に、この文書に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BIDIR-PIM] Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, &#34;Bidirectional Protocol Independent Multicast (BIDIR-PIM)&#34;, RFC 5015, DOI 10.17487/RFC5015, October 2007, &lt;https://www.rfc-editor.org/info/rfc5015&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BIDIR-PIM]ハンドレー、M.、Kouvelas、I.、スピークマン、T.、およびL. Vicisano、 &#34;双方向プロトコル独立マルチキャスト（BIDIR-PIM）&#34;、RFC 5015、DOI 10.17487 / RFC5015、2007年10月&lt;HTTPS ：//www.rfc-editor.org/info/rfc5015&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[JOIN-ATTR] Boers, A., Wijnands, I., and E. Rosen, &#34;The Protocol Independent Multicast (PIM) Join Attribute Format&#34;, RFC 5384, DOI 10.17487/RFC5384, November 2008, &lt;https://www.rfc-editor.org/info/rfc5384&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[登録しよ-ATTR]ボーア人、A.、Wijnands、I.、およびE.ローゼンし、 &#34;プロトコル独立マルチキャスト（PIM）属性フォーマットへの参加&#34;、RFC 5384、DOI 10.17487 / RFC5384、2008年11月、&lt;https：//でWWW .rfc-editor.org /情報/ rfc5384&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PIM-DM] Adams, A., Nicholas, J., and W. Siadak, &#34;Protocol Independent Multicast - Dense Mode (PIM-DM): Protocol Specification (Revised)&#34;, RFC 3973, DOI 10.17487/RFC3973, January 2005, &lt;https://www.rfc-editor.org/info/rfc3973&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PIM-DM]アダムス、A.、ニコラス、J.、およびW. Siadak、 &#34;プロトコル独立マルチキャスト - 稠密モード（PIM-DM）：プロトコル仕様（改訂）&#34;、RFC 3973、DOI 10.17487 / RFC3973、2005年1月、&lt;https://www.rfc-editor.org/info/rfc3973&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PIM-SM] Fenner, B., Handley, M., Holbrook, H., Kouvelas, I., Parekh, R., Zhang, Z., and L. Zheng, &#34;Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)&#34;, STD 83, RFC 7761, DOI 10.17487/RFC7761, March 2016, &lt;https://www.rfc-editor.org/info/rfc7761&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PIM-SM]フェナー、B.、ハンドレー、M.、ホルブルック、H.、Kouvelas、I.、Parekhの、R.、張、Z.、およびL.鄭、「プロトコル独立マルチキャスト - スパースモード（PIM- SM）：プロトコル仕様（改訂）」、STD 83、RFC 7761、DOI 10.17487 / RFC7761、2016年3月、&lt;https://www.rfc-editor.org/info/rfc7761&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PIM-SSM] Holbrook, H. and B. Cain, &#34;Source-Specific Multicast for IP&#34;, RFC 4607, DOI 10.17487/RFC4607, August 2006, &lt;https://www.rfc-editor.org/info/rfc4607&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PIM-SSM]ホルブルック、H.、およびB.カイン、 &#34;IPのためのソース固有のマルチキャスト&#34;、RFC 4607、DOI 10.17487 / RFC4607、2006年8月、&lt;https://www.rfc-editor.org/info/rfc4607 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B.、 &#34;RFC 2119個のキーワードに小文字VS大文字の曖昧さ&#34;、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https://www.rfc-editor.org/info/ rfc8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RPF-VECTOR] Wijnands, IJ., Boers, A., and E. Rosen, &#34;The Reverse Path Forwarding (RPF) Vector TLV&#34;, RFC 5496, DOI 10.17487/RFC5496, March 2009, &lt;https://www.rfc-editor.org/info/rfc5496&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RPF-VECTOR] Wijnands、IJ、ボーア人、A.、およびE.ローゼン、 &#34;リバースパス転送（RPF）のベクトルTLV&#34;、RFC 5496、DOI 10.17487 / RFC5496、2009年3月、&lt;HTTPS：// WWW。 rfc-editor.org/info/rfc5496&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IGMP-SNOOP] Christensen, M., Kimball, K., and F. Solensky, &#34;Considerations for Internet Group Management Protocol (IGMP) and Multicast Listener Discovery (MLD) Snooping Switches&#34;, RFC 4541, DOI 10.17487/RFC4541, May 2006, &lt;https://www.rfc-editor.org/info/rfc4541&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IGMP-SNOOP]クリステンセン、M.、キンボール、K.、およびF. Solensky、RFC 4541、DOI 10.17487 / RFC4541、月、 &#34;インターネットグループ管理プロトコル（IGMP）およびMulticast Listener Discovery（MLD）スヌーピングスイッチの考慮事項&#34; 2006年、&lt;https://www.rfc-editor.org/info/rfc4541&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VPLS-BGP] Kompella, K., Ed., and Y. Rekhter, Ed., &#34;Virtual Private LAN Service (VPLS) Using BGP for Auto-Discovery and Signaling&#34;, RFC 4761, DOI 10.17487/RFC4761, January 2007, &lt;https://www.rfc-editor.org/info/rfc4761&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VPLS-BGP] Kompella、K.、エド。、およびY. Rekhter、エド。、 &#34;仮想プライベートLANサービス（VPLS）自動検出およびシグナリングのためにBGPを使用する&#34;、RFC 4761、DOI 10.17487 / RFC4761、2007年1月、 &lt;https://www.rfc-editor.org/info/rfc4761&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VPLS-LDP] Lasserre, M., Ed., and V. Kompella, Ed., &#34;Virtual Private LAN Service (VPLS) Using Label Distribution Protocol (LDP) Signaling&#34;, RFC 4762, DOI 10.17487/RFC4762, January 2007, &lt;https://www.rfc-editor.org/info/rfc4762&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VPLS-LDP] Lasserre、M.、エド。、およびV. Kompella、エド。、RFC 4762、DOI 10.17487 / RFC4762、2007年1月、 &#34;仮想プライベートLANサービス（VPLS）はラベル配布プロトコル（LDP）シグナリングを使用します&#34; &lt;https://www.rfc-editor.org/info/rfc4762&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VPLS-MCAST] Aggarwal, R., Ed., Kamite, Y., Fang, L., Rekhter, Y., and C. Kodeboniya, &#34;Multicast in Virtual Private LAN Service (VPLS)&#34;, RFC 7117, DOI 10.17487/RFC7117, February 2014, &lt;https://www.rfc-editor.org/info/rfc7117&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VPLS-MCAST]アガルワル、R.、エド。、Kamite、Y.、牙、L.、Rekhter、Y.、およびC. Kodeboniya、 &#34;仮想プライベートLANサービス（VPLS）でマルチキャスト&#34;、RFC 7117、DOI 10.17487 / RFC7117、2014年2月、&lt;https://www.rfc-editor.org/info/rfc7117&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VPLS-MCAST-REQ] Kamite, Y., Ed., Wada, Y., Serbest, Y., Morin, T., and L. Fang, &#34;Requirements for Multicast Support in Virtual Private LAN Services&#34;, RFC 5501, DOI 10.17487/RFC5501, March 2009, &lt;https://www.rfc-editor.org/info/rfc5501&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VPLS-MCAST-REQ] Kamite、Y.、エド。、和田、Y.、Serbest、Y.、モリン、T.、およびL.牙、 &#34;仮想プライベートLANサービスにおけるマルチキャストサポートのための要件&#34;、RFC 5501、 DOI 10.17487 / RFC5501、2009年3月、&lt;https://www.rfc-editor.org/info/rfc5501&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. BIDIR-PIM Considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録A. BIDIR-PIMの考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix describes some guidelines that may be used to preserve BIDIR-PIM functionality in combination with PIM snooping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録では、PIMスヌーピングとの組み合わせでBIDIR-PIM機能を維持するために使用できるいくつかのガイドラインを説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to preserve BIDIR-PIM snooping, routers need to set up forwarding states so that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BIDIR-PIMスヌーピングを維持するために、ルータはそのよう転送状態を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o on the RPL, all traffic is forwarded to all Port(N) ports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RPLに、すべてのトラフィックはすべてのポート（N）ポートに転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o on any other interface, traffic is always forwarded to the DF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O他のインターフェイス上で、トラフィックは常にDFに転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information needed to set up these states may be obtained by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの状態を設定するために必要な情報をすることによって得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o determining the mapping between the group (range) and the RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グループ（範囲）とRPとの間のマッピングを決定O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o snooping and storing DF election information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OスヌーピングとDFの選挙情報を格納します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o determining where the RPL is. This could be achieved by static configuration or by combining the information mentioned in the two bullet items above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPLがどこにあるかを決定O。これは、静的な構成によって、または上記の二つの箇条書き項目に記載された情報を組み合わせることによって達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1. BIDIR-PIM Data-Forwarding Rules
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1。 BIDIR-PIMデータフォワーディングルール
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The BIDIR-PIM snooping data-forwarding rules are defined below in pseudocode:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BIDIR-PIMスヌーピングデータ転送ルールは、擬似コードで以下に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BEGIN iif is the incoming port of the multicast packet. G is the destination IP address of the multicast packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストパケットの着信ポートであるIIF BEGIN。 Gは、マルチキャストパケットの宛先IPアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       If there is forwarding state for G
       Then
           OutgoingPortList = olist(G)
       Else
           OutgoingPortList = UserDefinedPortList
       Endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If iif is an AC Then OutgoingPortList = OutgoingPortList (-) iif Else ## iif is a PW OutgoingPortList = OutgoingPortList (-) PWPorts Endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
IIFはACである場合、OutgoingPortList = OutgoingPortList（ - ）IIFエルス## IIFあるPW OutgoingPortList = OutgoingPortList（ - ）PWPorts ENDIF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Forward the packet to OutgoingPortList. END
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OutgoingPortListにパケットを転送します。終わり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is forwarding state for G, then forward the packet to olist(G) while observing the general rules above in Section 2.12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送状態がGのためにそこにある場合、セクション2.12で上記の一般的なルールを観察しながら、次いでOLIST（G）にパケットを転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5015 [BIDIR-PIM] specifies how olist(G) is constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5015 [BIDIR-PIM]はOLIST（G）が構築される方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix B. Example Network Scenario
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録B.例ネットワークのシナリオ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let us consider the scenario in Figure 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、図3のシナリオを考えてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                            +------+ AC3 +------+
                                            |  PE2 |-----| CE3  |
                                           /|      |     +------+
                                          / +------+         |
                                         /     |             |
                                        /      |             |
                                       /PW12   |             |
                                      /        |           /---\
                                     /         |PW23       | S |
                                    /          |           \---/
                                   /           |             |
                                  /            |             |
                                 /             |             |
                       +------+ /           +------+         |
          +------+     |  PE1 |/   PW13     |  PE3 |     +------+
          | CE1  |-----|      |-------------|      |-----| CE4  |
          +------+ AC1 +------+             +------+ AC4 +------+
                           |
                           |AC2
                       +------+
                       | CE2  |
                       +------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Figure 3: An Example Network for Triggering an Assert
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
図3：アサートをトリガするためのネットワークの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the examples below, JT(Port,S,G,N) is the downstream Join Expiry Timer on the specified Port for the (S,G) with upstream neighbor N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の実施例では、JT（ポート、S、G、N）の下流にある上流の隣人Nとのために指定されたポート上の有効期限タイマー（S、G）に参加
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.1. PIM Snooping Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.1。 PIMスヌーピングの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the network depicted in Figure 3, S is the source of a multicast stream (S,G). CE1 and CE2 both have two ECMP routes to reach the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図3に示されているネットワークでは、Sはマルチキャストストリーム（S、G）の供給源です。 CE1とCE2の両方がソースに到達するために2つのECMPルートを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. CE1 sends a Join(S,G) with UpstreamNeighbors(S,G) = CE3.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. CE1はUpstreamNeighbors（S、G）= CE3との結合（S、G）を送信します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. PE1 snoops on the Join(S,G) and builds forwarding state, since it is received on an AC. It also floods the Join(S,G) in the VPLS. PE2 snoops on the Join(S,G) and builds forwarding state, since the Join(S,G)is targeting a neighbor residing on an AC. PE3 does not create forwarding state for (S,G) because this is a PW-only Join and there is neither an existing (*,G) state with an AC in UpstreamPorts(*,G) nor an existing (S,G) state with an AC in UpstreamPorts(S,G). Both PE2 and PE3 will also flood the Join(S,G) in the VPLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加（S、G）にスヌープし、それがAC上で受信されているので、状態を転送構築PE1 2。また、VPLSに（S、G）に参加をフラッディングします。 PE2は、参加する（S、G）にスヌープ及び（S、G）ACに存在するネイバーをターゲットに参加するので、状態を転送構築します。これはPW-のみ参加しているとUpstreamPortsでAC（*、G）との既存の（*、G）状態でも、既存の（S、G）のいずれもがあるのでPE3は（S、G）のための転送状態を作成しませんUpstreamPortsにおけるAC（S、G）を有する状態。 PE2とPE3どちらもVPLSに（S、G）に参加をフラッディングします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The resulting states at the PEs are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
次のようにするPEの結果の状態は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1 states: JT(AC1,S,G,CE3) = JP_HoldTime UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, PW12 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1の状態：JT（AC1、S、G、CE3）= JP_HoldTime UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW12} OutgoingPortList（S、G）= {AC1、PW12}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2 states: JT(PW12,S,G,CE3) = JP_HoldTime UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(S,G) = { PW12, AC3 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2の状態：JT（PW12、S、G、CE3）= JP_HoldTime UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {AC3} OutgoingPortList（S、G）= {PW12、AC3}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 states: No (S,G) state
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3状態：いいえ（S、G）ステートを
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. The multicast stream (S,G) flows along CE3 -&gt; PE2 -&gt; PE1 -&gt; CE1.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.マルチキャストストリーム（S、G）は、CE3に沿って流れる - &gt; PE2  - &gt; PE1  - &gt; CE1。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Now CE2 sends a Join(S,G) with UpstreamNeighbors(S,G) = CE4.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.今CE2はUpstreamNeighbors（S、G）と（S、G）に参加= CE4を送信します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. All PEs snoop on the Join(S,G), build forwarding state, and flood the Join(S,G) in the VPLS. Note that for PE2, even though this is a PW-only Join, forwarding state is built on this Join(S,G), since PE2 has an existing (S,G) state with an AC in UpstreamPorts(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加（S、G）5.すべてのPEのスヌープは、フォワーディングステートを構築し、VPLSに（S、G）が参加洪水。 PE2はUpstreamPorts（S、G）におけるACで既存の（S、G）ステートを有しているので状態は、この参加（S、G）に基づいて構築されて転送、これは、PW-のみ参加しても、PE2のためのことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The resulting states at the PEs are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
次のようにするPEの結果の状態は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1 states: JT(AC1,S,G,CE3) = active JT(AC2,S,G,CE4) = JP_HoldTime UpstreamNeighbors(S,G) = { CE3, CE4 } UpstreamPorts(S,G) = { PW12, PW13 } OutgoingPortList(S,G) = { AC1, PW12, AC2, PW13 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1の状態：JT（AC1、S、G、CE3）=アクティブJT（AC2、S、G、CE4）= JP_HoldTime UpstreamNeighbors（S、G）= {CE3、CE4} UpstreamPorts（S、G）= {PW12、PW13を} OutgoingPortList（S、G）= {AC1、PW12、AC2、PW13}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2 states: JT(PW12,S,G,CE4) = JP_HoldTime JT(PW12,S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3, CE4 } UpstreamPorts(S,G) = { AC3, PW23 } OutgoingPortList(S,G) = { PW12, AC3, PW23 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2の状態：JT（PW12、S、G、CE4）= JP_HoldTime JT（PW12、S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3、CE4} UpstreamPorts（S、G）= {AC3、PW23を} OutgoingPortList（S、G）= {PW12、AC3、PW23}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 states: JT(PW13,S,G,CE4) = JP_HoldTime UpstreamNeighbors(S,G) = { CE4 } UpstreamPorts(S,G) = { AC4 } OutgoingPortList(S,G) = { PW13, AC4 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3状態：JT（PW13、S、G、CE4）= JP_HoldTime UpstreamNeighbors（S、G）= {CE4} UpstreamPorts（S、G）= {AC4} OutgoingPortList（S、G）= {PW13、AC4}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. The multicast stream (S,G) flows into the VPLS from two of the CEs -- CE3 and CE4. PE2 forwards the stream received from CE3 to PW23, and PE3 forwards the stream to AC4. This helps the CE routers to trigger Assert election. Let us say that CE3 becomes the Assert winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CE3及びCE4  -  6マルチキャストストリーム（S、G）は、CEの2からVPLSに流入します。 PE2は、PW23にCE3から受信したストリームを転送し、PE3はAC4にストリームを転送します。これは、アサート選挙をトリガするためにCEルータに役立ちます。私たちはCE3がアサート勝者になると言ってみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. CE3 sends an Assert message to the VPLS. The PEs flood the Assert message without examining it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. CE3は、VPLSにアサートメッセージを送信します。 PEはそれを調べずにアサートメッセージをあふれさせます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. CE4 stops sending the multicast stream to the VPLS.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. CE4は、VPLSにマルチキャストストリームの送信を停止します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. CE2 notices an RPF change due to the Assert and sends a Prune(S,G) with upstream neighbor = CE4. CE2 also sends a Join(S,G) with upstream neighbor = CE3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. CE2起因アサートするRPF変更を通知し、上流隣接= CE4とプルーン（S、G）を送信します。 CE2はまた、上流隣接= CE3と（S、G）加入を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. All the PEs start a Prune-Pending timer on the ports on which they received the Prune(S,G). When the Prune-Pending timer expires, all PEs will remove the downstream (S,G,CE4) states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10.すべてのPEは、それらがプルーン（S、G）を受信したポートのプルーン・保留タイマーを起動します。プルーン、保留タイマーが満了すると、すべてのPEは、下流の（S、G、CE4）の状態を削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The resulting states at the PEs are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
次のようにするPEの結果の状態は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1 states: JT(AC1,S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, AC2, PW12 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1の状態：JT（AC1、S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW12} OutgoingPortList（S、G）= {AC1、AC2、PW12}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2 states: JT(PW12,S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(S,G) = { PW12, AC3 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2の状態：JT（PW12、S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {AC3} OutgoingPortList（S、G）= {PW12、AC3}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 states: JT(PW13,S,G,CE3) = JP_HoldTime UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW23 } OutgoingPortList(S,G) = { PW13, PW23 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3状態：JT（PW13、S、G、CE3）= JP_HoldTime UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW23} OutgoingPortList（S、G）= {PW13、PW23}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note that at this point at PE3, since there is no AC in OutgoingPortList(S,G) and no (*,G) or (S,G) state with an AC in UpstreamPorts(*,G) or UpstreamPorts(S,G), respectively, the existing (S,G) state at PE3 can also be removed. So, finally:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
OutgoingPortList（S、G）なし（*、G）または（S、G）UpstreamPortsにおけるACた状態（*、G）またはUpstreamPorts（S、GにはACが存在しないため、PE3におけるこの時点でなお）、それぞれ、PE3で既存の（S、G）状態も除去することができます。だから、最終的には：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 states: No (S,G) state
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3状態：いいえ（S、G）ステートを
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that at the end of the Assert election, there should be no duplicate traffic forwarded downstream, and traffic should flow only on the desired path. Also note that there are no unnecessary (S,G) states on PE3 after the Assert election.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アサート選挙の終わりに、下流に転送重複トラフィックがあってはならない、とトラフィックが所望の経路に流れのみ必要があることに注意してください。また、不要な（S、G）がアサート選挙後PE3に述べていないがあることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.2. PIM Proxy Example with (S,G) / (*,G) Interaction
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.2。 （S、G）/（*、G）相互作用PIMプロキシ例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the same network, let us assume that CE4 is the upstream neighbor towards the RP for G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同ネットワークでは、私たちはCE4はG.のためのRPに向けた上流の隣人であると仮定しましょう
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPST(S,G,N) is the JP sending timer for the (S,G) with upstream neighbor N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPST（S、G、N）は、上流隣接N.と（S、G）のためのJP送信タイマーであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. CE1 sends a Join(S,G) with UpstreamNeighbors(S,G) = CE3.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. CE1はUpstreamNeighbors（S、G）= CE3との結合（S、G）を送信します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. PE1 consumes the Join(S,G) and builds forwarding state, since the Join(S,G) is received on an AC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. PE1は（S、G）に参加消費し、ACで受信された（S、G）に参加するので、状態を転送構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PE2 consumes the Join(S,G) and builds forwarding state, since the
       Join(S,G) is targeting a neighbor residing on an AC.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 consumes the Join(S,G) but does not create forwarding state for (S,G), since this is a PW-only Join and there is neither an existing (*,G) state with an AC in UpstreamPorts(*,G) nor an existing (S,G) state with an AC in UpstreamPorts(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3は参加（S、G）を消費が、これはPW-のみ参加しているとUpstreamPortsでACで既存の（*、G）状態（どちらも*があるので、（S、G）のための転送状態を作成しません、 G）もUpstreamPortsにおけるAC（S、G）と既存の（S、G）状態。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The resulting states at the PEs are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
次のようにするPEの結果の状態は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1 states: JT(AC1,S,G,CE3) = JP_HoldTime JPST(S,G,CE3) = t_periodic UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, PW12 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1の状態：JT（AC1、S、G、CE3）= JP_HoldTime JPST（S、G、CE3）はt_periodic UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）を= = {PW12} OutgoingPortList（S、G ）= {AC1、PW12}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2 states: JT(PW12,S,G,CE3) = JP_HoldTime JPST(S,G,CE3) = t_periodic UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(S,G) = { PW12, AC3 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2の状態：JT（PW12、S、G、CE3）= JP_HoldTime JPST（S、G、CE3）はt_periodic UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）を= = {AC3} OutgoingPortList（S、G ）= {PW12、AC3}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 states: No (S,G) state
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3状態：いいえ（S、G）ステートを
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Joins are triggered as follows: PE1 triggers a Join(S,G) targeting CE3. Since the Join(S,G) was received on an AC and is targeting a neighbor that is residing across a PW, the triggered Join(S,G) is sent on all PWs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
次のようにトリガーされるジョイン：PE1はCE3を標的とする（S、G）に参加トリガー。 AC上で受信された（S、G）に参加し、PWを横切って常駐さ隣人、トリガ参加（S、G）を標的としているので、全てのPW上で送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2 triggers a Join(S,G) targeting CE3. Since the Join(S,G) is targeting a neighbor residing on an AC, it only sends the Join on AC3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2はCE3を標的とする（S、G）に参加をトリガします。参加（S、G）は、AC上にあるネイバーを標的としているので、それだけAC3に参加送ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 ignores the Join(S,G), since this is a PW-only Join and there is neither an existing (*,G) state with an AC in UpstreamPorts(*,G) nor an existing (S,G) state with an AC in UpstreamPorts(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
これは、PW-のみ参加してUpstreamPortsにおけるAC（*、G）と既存の（*、G）ステートも有する既存の（S、G）状態でもないがあるのでPE3は、（S、G）参加無視しますUpstreamPortsにおけるAC（S、G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. The multicast stream (S,G) flows along CE3 -&gt; PE2 -&gt; PE1 -&gt; CE1.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.マルチキャストストリーム（S、G）は、CE3に沿って流れる - &gt; PE2  - &gt; PE1  - &gt; CE1。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Now let us say that CE2 sends a Join(*,G) with UpstreamNeighbors(*,G) = CE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.今、私たちはCE2はUpstreamNeighbors（*、G）= CE4に参加（*、G）を送ることにしましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. PE1 consumes the Join(*,G) and builds forwarding state, since the Join(*,G) is received on an AC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. PE1は（G、*）参加消費し、参加（*、G）は、AC上で受信されているので、状態を転送構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PE2 consumes the Join(*,G); although this is a PW-only Join,
       forwarding state is built on this Join(*,G), since PE2 has an
       existing (S,G) state with an AC in UpstreamPorts(S,G).  However,
       since this is a PW-only Join, PE2 only adds the PW towards PE3
       (PW23) into UpstreamPorts(*,G) and hence into
       OutgoingPortList(*,G).  It does not add the PW towards PE1 (PW12)
       into OutgoingPortList(*,G).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 consumes the Join(*,G) and builds forwarding state, since the Join(*,G) is targeting a neighbor residing on an AC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（*、G）は、AC上にあるネイバーをターゲットに参加するためPE3は、（*、G）参加消費し、状態を転送構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The resulting states at the PEs are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
次のようにするPEの結果の状態は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1 states: JT(AC1,*,G,CE4) = JP_HoldTime JPST(*,G,CE4) = t_periodic UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { PW13 } OutgoingPortList(*,G) = { AC2, PW13 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1の状態：JT（AC1、*、G、CE4）= JP_HoldTime JPST（*、G、CE4）はt_periodic UpstreamNeighborsを=（*、G）= {CE4} UpstreamPorts（*、G）= {PW13} OutgoingPortList（*は、G ）= {AC2、PW13}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT(AC1,S,G,CE3) = active JPST(S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, PW12, PW13 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT（AC1、S、G、CE3）=アクティブJPST（S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW12} OutgoingPortList（S、G）= { AC1、PW12、PW13}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2 states: JT(PW12,*,G,CE4) = JP_HoldTime UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(G) = { PW23 } OutgoingPortList(*,G) = { PW23 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2の状態：JT（PW12、*、G、CE4）= JP_HoldTime UpstreamNeighbors（*、G）= {CE4} UpstreamPorts（G）= {PW23} OutgoingPortList（*、G）= {} PW23
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT(PW12,S,G,CE3) = active JPST(S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(S,G) = { PW12, AC3, PW23 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT（PW12、S、G、CE3）=アクティブJPST（S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {AC3} OutgoingPortList（S、G）= { PW12、AC3、PW23}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 states: JT(PW13,*,G,CE4) = JP_HoldTime JPST(*,G,CE4) = t_periodic UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { AC4 } OutgoingPortList(*,G) = { PW13, AC4 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3状態：JT（PW13、*、G、CE4）= JP_HoldTime JPST（*、G、CE4）はt_periodic UpstreamNeighborsを=（*、G）= {CE4} UpstreamPorts（*、G）= {AC4} OutgoingPortList（*は、G ）= {PW13、AC4}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Joins are triggered as follows: PE1 triggers a Join(*,G) targeting CE4. Since the Join(*,G) was received on an AC and is targeting a neighbor that is residing across a PW, the triggered Join(S,G) is sent on all PWs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
次のようにトリガーされるジョイン：PE1参加トリガCE4を標的とする（*、G）。 （*、G）参加はACで受信し、PWを横切って常駐さ隣人をターゲットに、トリガー（S、G）に参加するので、全てのPW上で送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2 does not trigger a Join(*,G) based on this Join, since this is a PW-only Join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2は参加トリガされません（*、G）は、この参加に基づいて、これがあるので、PW-のみの参加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 triggers a Join(*,G) targeting CE4. Since the Join(*,G) is targeting a neighbor residing on an AC, it only sends the Join on AC4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3はCE4をターゲットに（*、G）が参加トリガ。 （*、G）参加をACに存在するネイバーを標的としているので、それだけAC4に参加送ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If traffic is not flowing yet (i.e., step 3 is delayed so that it occurs after step 6) and in the interim JPST(S,G,CE3) on PE1 expires, causing it to send a refresh Join(S,G) targeting CE3, since the refresh Join(S,G) is targeting a neighbor that is residing across a PW, the refresh Join(S,G) is sent on all PWs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トラフィックがまだ流れていない場合は6（これはステップ6の後に起こるように、すなわち、ステップ3が遅延される）と暫定JPST PE1に（S、G、CE3）において、リフレッシュが（S、Gに参加し送信することを引き起こす満了します）リフレッシュがPWを横切って常駐さ隣人をターゲットにしている（S、G）に参加するので、CE3を標的、リフレッシュは全てのPWに送信する（S、G）に参加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Note that PE1 refreshes its JT based on reception of refresh Joins from CE1 and CE2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PE1は、リフレッシュの受信に基づいて、そのJTを更新7.注CE1とCE2からジョイン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PE2 consumes the Join(S,G) and refreshes the JT(PW12,S,G,CE3)
       timer.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 consumes the Join(S,G). It also builds forwarding state on this Join(S,G), even though this is a PW-only Join, since now PE2 has an existing (*,G) state with an AC in UpstreamPorts(*,G). However, since this is a PW-only Join, PE3 only adds the PW towards PE2 (PW23) into UpstreamPorts(S,G) and hence into OutgoingPortList(S,G). It does not add the PW towards PE1 (PW13) into OutgoingPortList(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3は参加（S、G）を消費します。また、今PE2はUpstreamPortsにおけるAC（*、G）と既存の（*、G）ステートを有しているので、これはPW-のみ参加しても、この参加（S、G）に状態を転送構築します。しかし、このためであるPW-のみ参加し、PE3のみOutgoingPortListにUpstreamPortsにPE2に向けPW（PW23）（S、G）、従って（S、G）を付加します。それはOutgoingPortList（S、G）にPE1へのPW（PW13）を追加しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 states: JT(PW13,*,G,CE4) = active JPST(S,G,CE4) = active UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { AC4 } OutgoingPortList(*,G) = { PW13, AC4 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3状態：JT（PW13、*、G、CE4）=アクティブJPST（S、G、CE4）=アクティブUpstreamNeighbors（*、G）= {CE4} UpstreamPorts（*、G）= {AC4} OutgoingPortList（*、Gを）= {PW13、AC4}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT(PW13,S,G,CE3) = JP_HoldTime UpstreamNeighbors(*,G) = { CE3 } UpstreamPorts(*,G) = { PW23 } OutgoingPortList(*,G) = { PW13, AC4, PW23 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT（PW13、S、G、CE3）= JP_HoldTime UpstreamNeighbors（*、G）= {CE3} UpstreamPorts（*、G）= {PW23} OutgoingPortList（*、G）= {PW13、AC4、PW23}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Joins are triggered as follows: PE2 already has (S,G) state, so it does not trigger a Join(S,G) based on reception of this refresh Join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
次のようにトリガーされるジョイン：PE2は既に（S、G）状態を有するので、参加このリフレッシュの受信に基づいて参加（S、G）を誘発しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 does not trigger a Join(S,G) based on this Join, since this is a PW-only Join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この結合のみPWであるため、PE3は、この参加に基づいて参加（S、G）を誘発しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. The multicast stream (S,G) flows into the VPLS from two of the CEs -- CE3 and CE4. PE2 forwards the stream received from CE3 to PW12 and PW23. At the same time, PE3 forwards the stream received from CE4 to PW13 and PW23.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CE3及びCE4  -  8マルチキャストストリーム（S、G）は、CEの2からVPLSに流入します。 PE2はPW12及びPW23にCE3から受信したストリームを転送します。同時に、PE3はPW13及びPW23にCE4から受信したストリームを転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       The stream received over PW12 and PW13 is forwarded by PE1 to AC1
       and AC2.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The stream received by PE3 over PW23 is forwarded to AC4. The stream received by PE2 over PW23 is forwarded to AC3. Either of these helps the CE routers to trigger Assert election.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PW23上PE3によって受信されたストリームは、AC4に転送されます。 PW23上PE2によって受信されたストリームは、AC3に転送されます。これらのいずれかがアサート選挙をトリガするためにCEルータに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. CE3 and/or CE4 send(s) Assert message(s) to the VPLS. The PEs flood the Assert message(s) without examining it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. CE3及び/又はCE4は、（S）VPLSにメッセージ（単数または複数）をアサート送ります。 PEはそれを調べずにアサートメッセージ（複数可）をあふれさせます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. CE3 becomes the (S,G) Assert winner, and CE4 stops sending the multicast stream to the VPLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. CE3は（S、G）が勝者をアサートなり、CE4は、VPLSにマルチキャストストリームの送信を停止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. CE2 notices an RPF change due to the Assert and sends a Prune(S,G,rpt) with upstream neighbor = CE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. CE2がアサートによるRPF変更を通知し、上流隣接= CE4とプルーン（S、G、RPT）を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. PE1 consumes the Prune(S,G,rpt), and since PruneDesired(S,G,Rpt,CE4) is TRUE, it triggers a Prune(S,G,rpt) to CE4. Since the Prune is targeting a neighbor across a PW, it is sent on all PWs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. PE1はプルーン（S、G、RPT）を消費し、PruneDesired（S、G、RPT、CE4）がTRUEであるので、それはCE4にプルーン（S、G、RPT）をトリガします。プルーンは、PW間で隣人をターゲットにしているので、それがすべてのPWに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       PE2 consumes the Prune(S,G,rpt) and does not trigger any Prune
       based on this Prune(S,G,rpt), since this was a PW-only Prune.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 consumes the Prune(S,G,rpt), and since PruneDesired(S,G,rpt,CE4) is TRUE, it sends the Prune(S,G,rpt) on AC4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3はプルーン（S、G、RPT）を消費し、PruneDesired（S、G、RPT、CE4）がTRUEであるので、AC4にプルーン（S、G、RPT）を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1 states: JT(AC2,*,G,CE4) = active JPST(*,G,CE4) = active UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { PW13 } OutgoingPortList(*,G) = { AC2, PW13 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE1の状態：JT（AC2、*、G、CE4）=アクティブJPST（*、G、CE4）=アクティブUpstreamNeighbors（*、G）= {CE4} UpstreamPorts（*、G）= {PW13} OutgoingPortList（*、G ）= {AC2、PW13}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT(AC2,S,G,CE4) = JP_HoldTime with S,G,rpt prune flag JPST(S,G,CE4) = none, since this is sent along with the Join(*,G) to CE4 based on JPST(*,G,CE4) expiry UpstreamPorts(S,G,rpt) = { PW13 } UpstreamNeighbors(S,G,rpt) = { CE4 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JTは（AC2、S、G、CE4）= JP_HoldTime S、G、RPTプルーンフラグJPST（S、G、CE4）=なしとは、このためJPSTに基づいCE4（に参加（*、G）と共に送信されます*、G、CE4）有効期限UpstreamPorts（S、G、RPT）= {PW13} UpstreamNeighbors（S、G、RPT）= {} CE4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT(AC1,S,G,CE3) = active JPST(S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, PW12, AC2 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT（AC1、S、G、CE3）=アクティブJPST（S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW12} OutgoingPortList（S、G）= { AC1、PW12、AC2}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2 states: JT(PW12,*,G,CE4) = active UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { PW23 } OutgoingPortList(*,G) = { PW23 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE2が状態：JT（PW12、*、G、CE4）=アクティブUpstreamNeighbors（*、G）= {CE4} UpstreamPorts（*、G）= {PW23} OutgoingPortList（*、G）= {} PW23
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT(PW12,S,G,CE4) = JP_HoldTime with S,G,rpt prune flag JPST(S,G,CE4) = none, since this was created off a PW-only Prune UpstreamPorts(S,G,rpt) = { PW23 } UpstreamNeighbors(S,G,rpt) = { CE4 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT（PW12、S、G、CE4）= JP_HoldTime S、G、RPTプルーンフラグJPST（S、G、CE4）=なしと、これはPW-のみプルーンUpstreamPorts（S、G、RPT）をオフに作成されたので= {PW23} UpstreamNeighbors（S、G、RPT）= {} CE4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT(PW12,S,G,CE3) = active JPST(S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(*,G) = { PW12, AC3 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT（PW12、S、G、CE3）=アクティブJPST（S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {AC3} OutgoingPortList（*、G）= { PW12、AC3}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3 states: JT(PW13,*,G,CE4) = active JPST(*,G,CE4) = active UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { AC4 } OutgoingPortList(*,G) = { PW13, AC4 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PE3状態：JT（PW13、*、G、CE4）=アクティブJPST（*、G、CE4）=アクティブUpstreamNeighbors（*、G）= {CE4} UpstreamPorts（*、G）= {AC4} OutgoingPortList（*、G ）= {PW13、AC4}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT(PW13,S,G,CE4) = JP_HoldTime with S,G,rpt prune flag JPST(S,G,CE4) = none, since this is sent along with the Join(*,G) to CE4 based on JPST(*,G,CE4) expiry UpstreamNeighbors(S,G,rpt) = { CE4 } UpstreamPorts(S,G,rpt) = { AC4 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JTは（PW13、S、G、CE4）= JP_HoldTime S、G、RPTプルーンフラグJPST（S、G、CE4）=なしとは、このためJPSTに基づいCE4（に参加（*、G）と共に送信されます*、G、CE4）有効期限UpstreamNeighbors（S、G、RPT）= {CE4} UpstreamPorts（S、G、RPT）= {} AC4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
JT(PW13,S,G,CE3) = active JPST(S,G,CE3) = none, since this state is created by a PW-only Join UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW23 } OutgoingPortList(S,G) = { PW23 }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
この状態は、PW-のみ参加UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）によって作成されているのでJT（PW13、S、G、CE3）=アクティブJPST（S、G、CE3）は、どれも=いません= {PW23} OutgoingPortList（S、G）= {} PW23
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even in this example, at the end of the (S,G) / (*,G) Assert election, there should be no duplicate traffic forwarded downstream, and traffic should flow only to the desired CEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*、G）選挙をアサートしても、この例では、（S、G）の終わりに/、下流転送重複トラフィックがあってはならない、とのトラフィックは、所望のCEにのみ流れるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, we don&#39;t have duplicate traffic because one of the CEs stops sending traffic due to the Assert, not because we don&#39;t have any forwarding state in the PEs to do this forwarding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CEのいずれかが原因アサートへのトラフィックの送信を停止し、私たちはこの転送を行うためのPE内の任意の転送状態を持っていないではないので、しかし、我々は、重複したトラフィックを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many members of the former L2VPN and PIM working groups have contributed to, and provided valuable comments and feedback on, this document, including Vach Kompella, Shane Amante, Sunil Khandekar, Rob Nath, Marc Lasserre, Yuji Kamite, Yiqun Cai, Ali Sajassi, Jozef Raets, Himanshu Shah (Ciena), and Himanshu Shah (Cisco).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
かつてのL2VPNおよびPIMワーキンググループの多くのメンバーはに貢献し、そしてVACH Kompella、シェーンAmante、スニルKhandekar、ロブナス、マーク・Lasserre、雄二Kamite、Yiqunカイ、アリSajassi、を含む、このドキュメント、上の貴重なコメントやフィードバックを提供してきましたヨゼフRaets、ヒマンシュシャー（シエナ）、およびヒマンシュシャー（シスコ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
協力者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yetik Serbest and Suresh Boddapati coauthored earlier draft versions of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yetik SerbestとスレシュBoddapatiはこのドキュメントの以前のドラフト版を共同執筆しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Karl (Xiangrong) Cai and Princy Elizabeth made significant contributions to bring the specification to its current state, especially in the area of Join forwarding rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カール（Xiangrong）カイとPrincyエリザベスは特に参加転送ルールの領域に、現在の状態に仕様をもたらすために重要な貢献をしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Olivier Dornon Nokia Copernicuslaan 50 B-2018 Antwerp Belgium
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オリヴィエ・ソーンノキアCopernicuslaan 50 B-2018アントワープベルギー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: olivier.dornon@nokia.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：olivier.dornon@nokia.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jayant Kotalwar Nokia 701 East Middlefield Rd. Mountain View, CA 94043 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジャヤントKotalwarノキア701東ミドルRdを。マウンテンビュー、カリフォルニア州アメリカの94043米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: jayant.kotalwar@nokia.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：jayant.kotalwar@nokia.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Venu Hemige Nokia
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノキアはHemigeを来ました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: vhemige@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：vhemige@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ray Qiu mistnet.io
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイQ IUミストnet.IO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: ray@mistnet.io
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：ray@mistnet.io
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jeffrey Zhang Juniper Networks, Inc. 10 Technology Park Drive Westford, MA 01886 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アメリカのジェフリー・チャンジュニパーネットワークス、株式会社10・テクノロジー・パークドライブウェストフォード、マサチューセッツ州01886米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: zzhang@juniper.net
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：zzhang@juniper.net
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
