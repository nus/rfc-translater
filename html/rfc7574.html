<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7574 - Peer-to-Peer Streaming Peer Protocol (PPSPP) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7574</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7574 - Peer-to-Peer Streaming Peer Protocol (PPSPP) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7574">
              https://tools.ietf.org/html/rfc7574
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7574 - ピアツーピアストリーミングピアプロトコル（PPSSPP）</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         A. Bakker
Request for Comments: 7574                  Vrije Universiteit Amsterdam
Category: Standards Track                                    R. Petrocco
ISSN: 2070-1721                                           V. Grishchenko
                                           Technische Universiteit Delft
                                                               July 2015
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Peer-to-Peer Streaming Peer Protocol (PPSPP)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Peer-to-Peer Streaming Peer Protocol (PPSPP) is a protocol for disseminating the same content to a group of interested parties in a streaming fashion. PPSPP supports streaming of both prerecorded (on-demand) and live audio/video content. It is based on the peer-to-peer paradigm, where clients consuming the content are put on equal footing with the servers initially providing the content, to create a system where everyone can potentially provide upload bandwidth. It has been designed to provide short time-till-playback for the end user and to prevent disruption of the streams by malicious peers. PPSPP has also been designed to be flexible and extensible. It can use different mechanisms to optimize peer uploading, prevent freeriding, and work with different peer discovery schemes (centralized trackers or Distributed Hash Tables). It supports multiple methods for content integrity protection and chunk addressing. Designed as a generic protocol that can run on top of various transport protocols, it currently runs on top of UDP using Low Extra Delay Background Transport (LEDBAT) for congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアツーピアストリーミングピアプロトコル（PPSPP）ストリーミング方式で利害関係者のグループに同じコンテンツを広めるためのプロトコルです。 PPSPPは、両方（オンデマンド）事前に録音されたライブのオーディオ/ビデオ・コンテンツのストリーミングをサポートしています。これは、コンテンツを消費するクライアントは誰もが潜在的にアップロードの帯域幅を提供できるシステムを作成するには、最初にコンテンツを提供するサーバと対等に置かれ、ピア・ツー・ピアのパラダイムに基づいています。短い時間まで再生エンドユーザーのために提供し、悪意のあるピアによってストリームの破壊を防ぐように設計されています。 PPSPPはまた、柔軟で拡張できるように設計されています。これは、ピアのアップロードを最適化するために異なるメカニズムを使用フリーライディングを防止し、異なるピア発見方式（集中トラッカー又は分散ハッシュテーブル）を用いて動作することができます。これは、コンテンツの完全性保護とチャンクは対処するための複数の方法をサポートしています。様々なトランスポートプロトコルの上で実行することができ、一般的なプロトコルとして設計され、それが現在の輻輳制御のための低余分な遅延の背景トランスポート（LEDBAT）を使用して、UDPの上で実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7574.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7574で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................5
      1.1. Purpose ....................................................5
      1.2. Requirements Language ......................................6
      1.3. Terminology ................................................6
   2. Overall Operation ...............................................9
      2.1. Example: Joining a Swarm ...................................9
      2.2. Example: Exchanging Chunks ................................10
      2.3. Example: Leaving a Swarm ..................................10
   3. Messages .......................................................11
      3.1. HANDSHAKE .................................................11
           3.1.1. Handshake Procedure ................................12
      3.2. HAVE ......................................................14
      3.3. DATA ......................................................15
      3.4. ACK .......................................................15
      3.5. INTEGRITY .................................................15
      3.6. SIGNED_INTEGRITY ..........................................16
      3.7. REQUEST ...................................................16
      3.8. CANCEL ....................................................16
      3.9. CHOKE and UNCHOKE .........................................17
      3.10. Peer Address Exchange ....................................17
           3.10.1. PEX_REQ and PEX_RES Messages ......................17
      3.11. Channels .................................................19
      3.12. Keep Alive Signaling .....................................20
   4. Chunk Addressing Schemes .......................................21
      4.1. Start-End Ranges ..........................................21
           4.1.1. Chunk Ranges .......................................21
           4.1.2. Byte Ranges ........................................21
      4.2. Bin Numbers ...............................................22
      4.3. In Messages ...............................................23
           4.3.1. In HAVE Messages ...................................23
           4.3.2. In ACK Messages ....................................24
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   5. Content Integrity Protection ...................................24
      5.1. Merkle Hash Tree Scheme ...................................25
      5.2. Content Integrity Verification ............................26
      5.3. The Atomic Datagram Principle .............................27
      5.4. INTEGRITY Messages ........................................28
      5.5. Discussion and Overhead ...................................28
      5.6. Automatic Detection of Content Size .......................29
           5.6.1. Peak Hashes ........................................29
           5.6.2. Procedure ..........................................31
   6. Live Streaming .................................................32
      6.1. Content Authentication ....................................32
           6.1.1. Sign All ...........................................33
           6.1.2. Unified Merkle Tree ................................33
                  6.1.2.1. Signed Munro Hashes .......................34
                  6.1.2.2. Munro Signature Calculation ...............36
                  6.1.2.3. Procedure .................................37
                  6.1.2.4. Secure Tune In ............................37
      6.2. Forgetting Chunks .........................................38
   7. Protocol Options ...............................................38
      7.1. End Option ................................................39
      7.2. Version ...................................................39
      7.3. Minimum Version ...........................................40
      7.4. Swarm Identifier ..........................................40
      7.5. Content Integrity Protection Method .......................41
      7.6. Merkle Tree Hash Function .................................41
      7.7. Live Signature Algorithm ..................................42
      7.8. Chunk Addressing Method ...................................42
      7.9. Live Discard Window .......................................43
      7.10. Supported Messages .......................................44
      7.11. Chunk Size ...............................................44
   8. UDP Encapsulation ..............................................45
      8.1. Chunk Size ................................................45
      8.2. Datagrams and Messages ....................................46
      8.3. Channels ..................................................47
      8.4. HANDSHAKE .................................................47
      8.5. HAVE ......................................................48
      8.6. DATA ......................................................48
      8.7. ACK .......................................................49
      8.8. INTEGRITY .................................................50
      8.9. SIGNED_INTEGRITY ..........................................51
      8.10. REQUEST ..................................................52
      8.11. CANCEL ...................................................52
      8.12. CHOKE and UNCHOKE ........................................53
      8.13. PEX_REQ, PEX_RESv4, PEX_RESv6, and PEX_REScert ...........53
      8.14. KEEPALIVE ................................................55
      8.15. Flow and Congestion Control ..............................56
      8.16. Example of Operation .....................................57
   9. Extensibility ..................................................61
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      9.1. Chunk Picking Algorithms ..................................61
      9.2. Reciprocity Algorithms ....................................62
   10. IANA Considerations ...........................................62
      10.1. PPSPP Message Type Registry ..............................62
      10.2. PPSPP Option Registry ....................................62
      10.3. PPSPP Version Number Registry ............................62
      10.4. PPSPP Content Integrity Protection Method Registry .......62
      10.5. PPSPP Merkle Hash Tree Function Registry .................63
      10.6. PPSPP Chunk Addressing Method Registry ...................63
   11. Manageability Considerations ..................................63
      11.1. Operations ...............................................63
           11.1.1. Installation and Initial Setup ....................63
           11.1.2. Migration Path ....................................64
           11.1.3. Requirements on Other Protocols and
                   Functional Components .............................64
           11.1.4. Impact on Network Operation .......................64
           11.1.5. Verifying Correct Operation .......................65
           11.1.6. Configuration .....................................65
      11.2. Management Considerations ................................66
           11.2.1. Management Interoperability and Information .......67
           11.2.2. Fault Management ..................................67
           11.2.3. Configuration Management ..........................67
           11.2.4. Accounting Management .............................68
           11.2.5. Performance Management ............................68
           11.2.6. Security Management ...............................68
   12. Security Considerations .......................................68
      12.1. Security of the Handshake Procedure ......................68
           12.1.1. Protection against Attack 1 .......................69
           12.1.2. Protection against Attack 2 .......................70
           12.1.3. Protection against Attack 3 .......................70
      12.2. Secure Peer Address Exchange .............................71
           12.2.1. Protection against the Amplification Attack .......71
           12.2.2. Example: Tracker as Certification Authority .......72
           12.2.3. Protection against Eclipse Attacks ................73
      12.3. Support for Closed Swarms ................................73
      12.4. Confidentiality of Streamed Content ......................74
      12.5. Strength of the Hash Function for Merkle Hash Trees ......74
      12.6. Limit Potential Damage and Resource Exhaustion by
            Bad or Broken Peers ......................................74
           12.6.1. HANDSHAKE .........................................75
           12.6.2. HAVE ..............................................75
           12.6.3. DATA ..............................................75
           12.6.4. ACK ...............................................75
           12.6.5. INTEGRITY and SIGNED_INTEGRITY ....................76
           12.6.6. REQUEST ...........................................76
           12.6.7. CANCEL ............................................76
           12.6.8. CHOKE .............................................77
           12.6.9. UNCHOKE ...........................................77
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           12.6.10. PEX_RES ..........................................77
           12.6.11. Unsolicited Messages in General ..................77
      12.7. Exclude Bad or Broken Peers ..............................77
   13. References ....................................................78
      13.1. Normative References .....................................78
      13.2. Informative References ...................................79
   Acknowledgements ..................................................84
   Authors&#39; Addresses ................................................85
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Purpose
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。目的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the Peer-to-Peer Streaming Peer Protocol (PPSPP), designed for disseminating the same content to a group of interested parties in a streaming fashion. PPSPP supports streaming of both prerecorded (on-demand) and live audio/video content. It is based on the peer-to-peer paradigm where clients consuming the content are put on equal footing with the servers initially providing the content, to create a system where everyone can potentially provide upload bandwidth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、ストリーミング方式で利害関係者のグループに同じコンテンツを広めるために設計されたピアツーピアストリーミングピアプロトコル（PPSPP）を、説明しています。 PPSPPは、両方（オンデマンド）事前に録音されたライブのオーディオ/ビデオ・コンテンツのストリーミングをサポートしています。これは、コンテンツを消費するクライアントは誰もが潜在的にアップロードの帯域幅を提供できるシステムを作成するには、最初にコンテンツを提供するサーバと対等に置かれ、ピア・ツー・ピアのパラダイムに基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP has been designed to provide short time-till-playback for the end user and to prevent disruption of the streams by malicious peers. Central in this design is a simple method of identifying content based on self-certification. In particular, content in PPSPP is identified by a single cryptographic hash that is the root hash in a Merkle hash tree calculated recursively from the content [MERKLE] [ABMRKL]. This self-certifying hash tree allows every peer to directly detect when a malicious peer tries to distribute fake content. The tree can be used for both static and live content. Moreover, it ensures only a small amount of information is needed to start a download and to verify incoming chunks of content, thus ensuring short start-up times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPは短い時間まで再生エンドユーザーのために提供し、悪意のあるピアによってストリームの破壊を防ぐように設計されています。この設計では、中央には、自己認証に基づいてコンテンツを特定する簡単な方法です。特に、PPSPP内のコンテンツは、コンテンツ[マークル] [ABMRKL]から再帰的に計算マークル・ハッシュ・ツリーのルートハッシュ単一暗号ハッシュによって識別されます。この自己証明ハッシュツリーは、すべての悪意のあるピアが偽のコンテンツを配信しようとすると、直接検出するために、ピアことができます。ツリーは、静的およびライブコンテンツのために使用することができます。また、情報のみ少量のダウンロードを開始するので、短い起動時間を確保し、コンテンツの受信チャンクを検証するために必要とされることを確実にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP has also been designed to be extensible for different transports and use cases. Hence, PPSPP is a generic protocol that can run directly on top of UDP, TCP, or other protocols. As such, PPSPP defines a common set of messages that make up the protocol, which can have different representations on the wire depending on the lower-level protocol used. When the lower-level transport allows, PPSPP can also use different congestion control algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPは、異なるトランスポートとユースケースのために拡張できるように設計されています。したがって、PPSPPはUDP、TCP、または他のプロトコルの上で直接実行することができ、一般的なプロトコルです。このように、PPSPPを用いる下位レベルのプロトコルに応じて、ワイヤ上の異なる表現を有することができるプロトコルを構成するメッセージの共通のセットを定義します。下位のトランスポートを可能にする場合、PPSPPは、異なる輻輳制御アルゴリズムを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At present, PPSPP is set to run on top of UDP using LEDBAT for congestion control [RFC6817]. Using LEDBAT enables PPSPP to serve the content after playback (seeding) without disrupting the user who may have moved to different tasks that use its network connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現時点では、PPSPPは、輻輳制御[RFC6817]のためのLEDBATを使用してUDPの上で実行するように設定されています。 LEDBATを使用すると、そのネットワーク接続を使用して別のタスクに移動した可能性があり、ユーザーを混乱させることなく再生（播種）後のコンテンツを提供するためにPPSPPを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP is also flexible and extensible in the mechanisms it uses to promote client contribution and prevent freeriding, that is, how to deal with peers that only download content but never upload to others. It also allows different schemes for chunk addressing and content integrity protection, if the defaults are not fit for a particular use case. In addition, it can work with different peer discovery schemes, such as centralized trackers or fast Distributed Hash Tables [JIM11]. Finally, in this default setup, PPSPP maintains only a small amount of state per peer. A reference implementation of PPSPP over UDP is available [SWIFTIMPL].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPは、それがクライアントの貢献を促進し、フリーライディングを防ぐために使用するメカニズムにも柔軟かつ拡張可能であり、それだけで他の人にアップロードしたコンテンツをダウンロードしませんが、決してことを仲間に対処する方法、です。デフォルトは特定のユースケースに適していない場合にも、アドレッシングチャンクとコンテンツの完全性保護のための別のスキームを可能にします。また、そのような集中トラッカーまたは高速分散ハッシュテーブル[JIM11]などの異なるピア発見方式で動作することができます。最後に、このデフォルトの設定では、PPSPPは、ピアごとの状態のわずかな量を維持します。 UDP上PPSPPのリファレンス実装は、[SWIFTIMPL】利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol defined in this document assumes that a peer has already discovered a list of (initial) peers using, for example, a centralized tracker [PPSP-TP]. Once a peer has this list of peers, PPSPP allows the peer to connect to other peers, request chunks of content, and discover other peers disseminating the same content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書で定義されたプロトコルは、ピアは、例えば、集中トラッカ[PPSP-TP]を使用して（初期）のピアのリストを既に発見していると仮定しています。ピアがピアのリストを持っていると、PPSPPピアが他のピアに接続することができ、コンテンツのチャンクを要求し、同じコンテンツを広める他のピアを発見します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The design of PPSPP is based on our research into making BitTorrent [BITTORRENT] suitable for streaming content [P2PWIKI]. Most PPSPP messages have corresponding BitTorrent messages and vice versa. However, PPSPP is specifically targeted towards streaming audio/video content and optimizes time-till-playback. It was also designed to be more flexible and extensible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPの設計は[P2PWIKI]コンテンツをストリーミングするためのBitTorrentは、[BitTorrentの適当な作りに私たちの研究に基づいています。ほとんどのPPSPPメッセージは、BitTorrentのメッセージとその逆に対応しています。しかし、PPSPPは、特にストリーミング・オーディオ/ビデオ・コンテンツをターゲットと時間まで再生を最適化しています。また、より柔軟かつ拡張可能であるように設計されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますRFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3。用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message The basic unit of PPSPP communication. A message will have different representations on the wire depending on the transport protocol used. Messages are typically multiplexed into a datagram for transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージPPSPP通信の基本単位。メッセージは、使用されるトランスポートプロトコルに応じて、ワイヤ上の異なる表現を有することになります。メッセージは、一般的に伝送するためのデータグラムに多重化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
datagram A sequence of messages that is offered as a unit to the underlying transport protocol (UDP, etc.). The datagram is PPSPP&#39;s Protocol Data Unit (PDU).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データグラム基礎となるトランスポートプロトコル（UDPなど）を単位として提供されているメッセージのシーケンス。データグラムはPPSPPのプロトコルデータユニット（PDU）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
content Either a live transmission or a prerecorded multimedia file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツのライブ伝送またはあらかじめ記録されたマルチメディアファイルのどちらか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunk The basic unit in which the content is divided. For example, a block of N kilobytes. A chunk may be of variable size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクコンテンツが分割された基本ユニット。例えば、Nキロバイトのブロック。チャンクは、可変サイズであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunk ID Unique identifier for a chunk of content (e.g., an integer). Its type depends on the chunk addressing scheme used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツ（例えば、整数）のチャンクのチャンクIDの一意の識別子。そのタイプが使用されるチャンクアドレス指定方式に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunk specification An expression that denotes one or more chunk IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクは、一つ以上のチャンクIDを表す式を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunk addressing scheme Scheme for identifying chunks and expressing the chunk availability map of a peer in a compact fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクは、チャンクを識別し、コンパクトな方法でピアのチャンク可用性地図を表現するための方式アドレッシング方式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunk availability map The set of chunks a peer has successfully downloaded and checked the integrity of.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクの可用性は、ピアが正常にダウンロードしたチャンクのセットをマップの整合性をチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bin A number denoting a specific binary interval of the content (i.e., one or more consecutive chunks) in the bin numbers chunk addressing scheme (see Section 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビンはアドレッシング方式ビン番号のチャンク内のコンテンツ（即ち、一つ以上の連続するチャンク）の特定のバイナリ間隔を表す数値（セクション4を参照します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
content integrity protection scheme Scheme for protecting the integrity of the content while it is being distributed via the peer-to-peer network. That is, methods for receiving peers to detect whether a requested chunk has been modified, either maliciously by the sending peer or accidentally in transit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、ピア・ツー・ピアネットワークを介して配信されている間、コンテンツの完全性を保護するためのコンテンツの完全性保護スキームスキーム。すなわち、要求されたチャンクが悪意送信ピアにより又は偶発輸送のいずれかで、変更されたかどうかを検出するために、ピアを受信するための方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash The result of applying a cryptographic hash function, more specifically a Modification Detection Code (MDC) [HAC01], such as SHA-256 [FIPS180-4], to a piece of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データの部分に、[FIPS180-4]そのようなSHA-256のように、[HAC01]変形検出コード（MDC）、より具体的には、暗号ハッシュ関数を適用した結果をハッシュ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Merkle hash tree A tree of hashes whose base is formed by the hashes of the chunks of content, and its higher nodes are calculated by recursively computing the hash of the concatenation of the two child hashes (see Section 5.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークル・ハッシュ・ツリーベース（セクション5.1を参照されたい）コンテンツのチャンクのハッシュによって形成され、その高いノードを再帰的に2つのつの子ハッシュの連結のハッシュを計算することによって計算されるハッシュの木。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
root hash The root in a Merkle hash tree calculated recursively from the content (see Section 5.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルートハッシュは、コンテンツから再帰的に計算マークルハッシュツリーのルートは（セクション5.1を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
munro hash The hash of a subtree that is the unit of signing in the Unified Merkle Tree content authentication scheme for live streaming (see Section 6.1.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マンローは、ライブストリーミングのための統一マークル木コンテンツ認証スキームに署名する単位であるサブツリーのハッシュをハッシュ（6.1.2.1項を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
swarm A group of peers participating in the distribution of the same content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じコンテンツの配信に参加しているピアのグループを群れ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
swarm ID Unique identifier for a swarm of peers, in PPSPP a sequence of bytes. For video on demand with content integrity protection enabled, the identifier is the so-called root hash of a Merkle hash tree over the content. For live streaming, the swarm ID is a public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイトのシーケンスPPSPPに、ピアの群れのためのIDの一意の識別子を群れ。対応コンテンツの完全性保護を備えたビデオオンデマンドのために、識別子は、コンテンツに対してマークルハッシュ木のいわゆるルートハッシュです。ライブストリーミングの場合は、群れのIDは、公開鍵です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tracker An entity that records the addresses of peers participating in a swarm, usually for a set of swarms, and makes this membership information available to other peers on request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、群れのセットのために、群れに参加しているピアのアドレスを記録するエンティティをトラッカーリクエストに応じて他のピアにこのメンバーシップ情報が利用できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
choking When Peer A is choking Peer B, it means that A is currently not willing to accept requests for content from B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアAは、ピアBを窒息された場合窒息は、Aは、現在Bからのコンテンツの要求を受け入れることを望んでいないことを意味します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seeding Peer A is said to be seeding when A has downloaded a static content file completely and is now offering it for others to download.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
播種ピアAは、Aが完全に静的なコンテンツファイルをダウンロードしており、現在ダウンロードする他の人のためにそれを提供されたときに播種されると言われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
leeching Peer A is said to be leeching when A has not completely downloaded a static content file yet or is not offering to upload it to others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リーチングピアAは、Aは、まだ完全に静的なコンテンツファイルをダウンロードされていないか、他の人にそれをアップロードするために提供されていない場合にリーチングされると言われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
channel A logical connection between two peers. The channel concept allows peers to use the same transport address for communicating with different peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのピア間の論理接続チャネル。チャンネルのコンセプトは、ピアが異なるピアと通信するために同じトランスポートアドレスを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
channel ID Unique, randomly chosen identifier for a channel, local to each peer. So the two peers logically connected by a channel each have a different channel ID for that channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャネルID一意、各ピアに対してローカルチャネル用のランダムに選択された識別子。だから、論理チャネルで接続された2つのピアはそれぞれ、そのチャネルの異なるチャネルIDを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
heavy payload A datagram has a heavy payload when it contains DATA messages, SIGNED_INTEGRITY messages, or a large number of smaller messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはデータメッセージ、SIGNED_INTEGRITYメッセージ、以下のメッセージが多数含まれている場合、重いペイロードデータグラムは重いペイロードを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this document the prefixes kilo-, mega-, etc., denote base 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本書ではプレフィクスは、ベース1024示し、キロ、メガなど。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Overall Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.全体動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic unit of communication in PPSPP is the message. Multiple messages are multiplexed into a single datagram for transmission. A datagram (and hence the messages it contains) will have different representations on the wire depending on the transport protocol used (see Section 8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPにおける通信の基本単位はメッセージです。複数のメッセージを送信するために単一のデータグラムに多重化されています。データグラム（したがって、それに含まれるメッセージ）が使用されるトランスポートプロトコルに応じて、ワイヤ上の異なる表現を有することになる（セクション8を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The overall operation of PPSPP is illustrated in the following examples. The examples assume that the content distributed is static, UDP is used for transport, the Merkle Hash Tree scheme is used for content integrity protection, and that a specific policy is used for selecting which chunks to download.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPの全体的な動作は、以下の実施例に示されています。例では、配信されたコンテンツは、UDPが輸送のために使用され、静的であると仮定し、マークルハッシュツリー方式は、コンテンツの完全性保護のために使用され、特定のポリシーをダウンロードするチャンクを選択するために使用されていることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Example: Joining a Swarm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。例：スウォームに参加
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a user who wants to watch a video. To play the video, the user clicks on the play button of a HTML5 &lt;video&gt; element shown in his PPSPP-enabled browser. Imagine this element has a PPSPP URL (to be defined elsewhere) identifying the video as its source. The browser passes this URL to its peer-to-peer streaming protocol handler. Let&#39;s call this protocol handler Peer A. Peer A parses the URL to retrieve the transport address of a peer-to-peer streaming protocol tracker and swarm metadata of the content. The tracker address may be optional in the presence of a decentralized tracking mechanism. The mechanisms for tracking peers are outside of the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
動画を視聴したいユーザーを考えてみましょう。動画を再生するには、ユーザーは自分のPPSPP対応のブラウザで示しHTML5の&lt;video&gt;要素の再生ボタンをクリックします。この要素はPPSPP URLを持っている想像するソースとしてビデオを識別する（他の場所で定義されます）。ブラウザは、ピア・ツー・ピアストリーミングプロトコルハンドラにこのURLを渡します。のは、このプロトコルハンドラピアA.ピアAは、ピア・ツー・ピアストリーミングプロトコルトラッカーとコンテンツの群れメタデータのトランスポートアドレスを取得するために、URLを解析して呼ぶことにしましょう。トラッカー・アドレスは、分散トラッキングメカニズムの存在下で、任意であってもよいです。ピアを追跡するためのメカニズムはこの文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer A now registers with the tracker following the peer-to-peer streaming protocol tracker specification [PPSP-TP] and receives the IP address and port of peers already in the swarm, say, Peers B, C, and D. At this point, the PPSPP starts operating. Peer A now sends a datagram containing a PPSPP HANDSHAKE message to Peers B, C, and D. This message conveys protocol options. In particular, Peer A includes the ID of the swarm (part of the swarm metadata) as a protocol option because the destination peers can listen for multiple swarms on the same transport address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今ピアツーピアストリーミングプロトコルトラッカー仕様[PPSP-TP]以下トラッカに登録し、この時点で群れ、たとえば、ピアB、C、及びDに既にピアのIPアドレスとポートを受け取るピア、PPSPPが動作を開始します。ピア今このメッセージは、プロトコルオプションを搬送するピアB、C、およびDにPPSPPハンドシェークメッセージを含むデータグラムを送信します。宛先ピアが同じトランスポートアドレス上の複数の群れのために聞くことができるので、特に、ピアAは、プロトコルオプションとして群れ（群れのメタデータの一部）のIDを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peers B and C respond with datagrams containing a PPSPP HANDSHAKE message and one or more HAVE messages. A HAVE message conveys (part of) the chunk availability of a peer; thus, it contains a chunk specification that denotes what chunks of the content Peers B and C have, respectively. Peer D sends a datagram with a HANDSHAKE and HAVE messages, but also with a CHOKE message. The latter indicates that Peer D is not willing to upload chunks to Peer A at present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアBおよびCはPPSPPハンドシェークメッセージと一つを含むデータグラムで応答以上のメッセージを有します。 HAVEメッセージは、ピアのチャンク可用性（の一部）を搬送します。従って、それは、それぞれ、コンテンツピアBおよびCのチャンクを持っているものを意味するチャンクの仕様を含んでいます。ピアDは、ハンドシェークでデータグラムを送信し、メッセージを持っているだけでなく、チョークメッセージで。後者は、ピアDは、現在のピアするチャンクをアップロードすることを望んでいないことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Example: Exchanging Chunks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2。例：交換チャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In response to Peers B and C, Peer A sends new datagrams to Peers B and C containing REQUEST messages. A REQUEST message indicates the chunks that a peer wants to download; thus, it contains a chunk specification. The REQUEST messages to Peers B and C refer to disjoint sets of chunks. Peers B and C respond with datagrams containing HAVE, DATA, and, in this example, INTEGRITY messages. In the Merkle hash tree content protection scheme (see Section 5.1), the INTEGRITY messages contain all cryptographic hashes that Peer A needs to verify the integrity of the content chunk sent in the DATA message. Using these hashes, Peer A verifies that the chunks received from Peers B and C are correct against the trusted swarm ID. Peer A also updates the chunk availability of Peers B and C using the information in the received HAVE messages. In addition, it passes the chunks of video to the user&#39;s browser for rendering.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアBおよびCに対応して、ピアAは、ピアBとC含むREQUESTメッセージに新しいデータグラムを送信します。 REQUESTメッセージは、ピアがダウンロードしたいチャンクを示します。したがって、それはチャンクの仕様が含まれています。ピアBとCへの要求メッセージは、チャンクの互いに素な集合を参照してください。ピアBとCは、この例では、INTEGRITYメッセージを持って、データを含むデータグラムで応答し、そして。マークルハッシュ木コンテンツ保護方式では（5.1項を参照）、INTEGRITYメッセージは、Aは、DATAメッセージで送信されたコンテンツチャンクの整合性を検証する必要があるピアすべて暗号化ハッシュが含まれています。これらのハッシュを使用して、ピアAは、ピアBおよびCから受信したチャンクは、信頼群発IDに対して正しいことを検証します。また、受信したメッセージ内の情報を使用して、ピアBおよびCのチャンクの可用性を更新するピア。また、レンダリングのために、ユーザーのブラウザにビデオのチャンクを渡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After processing, Peer A sends a datagram containing HAVE messages for the chunks it just received to all its peers. In the datagram to Peers B and C, it includes an ACK message acknowledging the receipt of the chunks and adds REQUEST messages for new chunks. ACK messages are not used when a reliable transport protocol is used. When, for example, Peer C finds that Peer A obtained a chunk (from Peer B) that Peer C did not yet have, Peer C&#39;s next datagram includes a REQUEST for that chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
処理の後、ピアAはそれだけですべてのピアに受け取ったチャンクを持っているメッセージを含むデータグラムを送信します。ピアBとCにデータグラムでは、チャンクの受信を確認するACKメッセージが含まれており、新しいチャンクのためのメッセージを要求する追加されます。信頼性の高いトランスポートプロトコルが使用されている場合、ACKメッセージは使用されません。例えば、ピアCは、Cがまだ持っていなかったピアそのピアAは、（ピアBから）のチャンクを取得することを発見したとき、ピアCの次のデータグラムは、そのチャンクの要求を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer D also sends HAVE messages to Peer A when it downloads chunks from other peers. When Peer D is willing to accept REQUESTs from Peer A, Peer D sends a datagram with an UNCHOKE message to inform Peer A. If Peer B or C decides to choke Peer A, they send a CHOKE message and Peer A should then re-request from other peers. Peers B and C may continue to send HAVE, REQUEST, or periodic keep-alive messages such that Peer A keeps sending them HAVE messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアDはまた、他のピアからチャンクをダウンロードするときピアするメッセージを持って送信します。ピアDは、ピアAからの要求を受け入れても構わないと思っている場合、ピアDは、ピアBまたはCは、ピアAチョーク、それらはチョークメッセージを送信した後、必要があり、再要求ピアを決定した場合、ピアAを通知するUNCHOKEメッセージでデータグラムを送信します。他のピアから。ピアBとCはHAVE、REQUEST、またはピアAは、それらがメッセージを持って送信し続けるような定期的なキープアライブメッセージを送信し続けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once Peer A has received all content (video-on-demand use case), it stops sending messages to all other peers that have all content (a.k.a. seeders). Peer A can also contact the tracker or another source again to obtain more peer addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアAは、すべてのコンテンツ（ビデオ・オン・デマンドユースケース）を受信したら、それはすべてのコンテンツ（別称、シーダー）を持っている他のすべてのピアへのメッセージ送信を停止します。ピアAは、また、より多くのピア・アドレスを取得するために再び追跡又は他の供給源と接触することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Example: Leaving a Swarm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3。例：スウォームを残します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To leave a swarm in a graceful way, Peer A sends a specific HANDSHAKE message to all its peers (see Section 8.4) and deregisters from the tracker following the tracker specification [PPSP-TP]. Peers receiving the datagram should remove Peer A from their current peer list. If Peer A crashes ungracefully, peers should remove Peer A from their peer list when they detect it no longer sends messages (see Section 3.12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優雅な方法で群れを残すために、ピアAは、すべてのそのピアに特定のハンドシェイクメッセージを送信する（セクション8.4を参照）、トラッカー仕様[PPSP-TP]以下のトラッカーから登録解除します。データグラムを受信したピアは、現在のピアリストからピアAを削除する必要があります。不正にピアAがクラッシュした場合、彼らはそれはもはやメッセージ（項3.12を参照）を送る検出しないとき、ピアはそのピアリストからピアAを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No error codes or responses are used in the protocol; absence of any response indicates an error. Invalid messages are discarded, and further communication with the peer SHOULD be stopped. The rationale is that it is sufficient to classify peers as either good or bad and only use the good ones. A good peer is a peer that responds with chunks; a peer that does not respond, or does not respond in time is classified as bad. The idea is that, in PPSPP, the content is available from multiple sources (unlike HTTP), so a peer should not invest too much effort in trying to obtain it from a particular source. This classification in good or bad allows a peer to deal with slow, crashed, and (silent) malicious peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーコード又は応答は、プロトコルで使用されていません。任意の応答の欠如は、エラーを示します。無効なメッセージは破棄され、およびピアとの更なる通信は中止すべきです。根拠は、良いか悪いかのどちらかとしてピアを分類し、唯一の良いものを使用することで十分であるということです。良いピアはチャンクで応答ピアです。応答しない、または時間内に応答しないピアが悪いと分類されます。アイデアはPPSPPで、内容は（HTTPとは違って）複数のソースから入手可能ですので、ピアは特定のソースからそれを取得しようとする際に、あまりにも多くの努力を投資してはならない、ということです。良いか悪いかではこの分類は、ピアが遅いに対処することを可能に墜落し、及び（サイレント）悪意のあるピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple messages MUST be multiplexed into a single datagram for transmission. Messages in a single datagram MUST be processed in the strict order in which they appear in the datagram. If an invalid message is found in a datagram, the remaining messages MUST be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のメッセージを送信するために単一のデータグラムに多重化されなければなりません。単一のデータグラム内のメッセージは、彼らがデータグラムに表示される厳密な順序で処理しなければなりません。無効なメッセージがデータグラムで発見された場合、残りのメッセージを捨てなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the sake of simplicity, one swarm of peers deals with one content file or stream only. There is a single division of the content into chunks that all peers in the swarm adhere to, determined by the content publisher. Distribution of a collection of files can be done either by using multiple swarms or by using an external storage mapping from the linear byte space of a single swarm to different files, transparent to the protocol. In other words, the audio/video container format used is outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単純化のために、ピアの1人の群れが一つのコンテンツファイルやストリームのみを扱います。コンテンツ発行者によって決定群れ内のすべてのピアが付着チャンクにコンテンツの単一部門は、あります。ファイルの集合の分布は、複数の群れを使って、またはプロトコルに対して透過別のファイルに単一群れの線形バイト空間から外部ストレージマッピングを使用することによってのいずれかで行うことができます。換言すれば、使用されるオーディオ/ビデオコンテナ形式は、この文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. HANDSHAKE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。ハンドシェーク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Peer P to establish communication with Peer Q in Swarm S, the peers must first exchange HANDSHAKE messages by means of a handshake procedure. The initiating Peer P needs to know the metadata of Swarm S, which consists of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアPはスウォームSにおけるピアQとの通信を確立するために、ピアは最初のハンドシェイク手順によって、ハンドシェイクメッセージを交換しなければなりません。開始ピアPは、で構成されていスウォームSのメタデータを、知っておく必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) the swarm ID of the content (see Sections 5.1 and 6),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（A）コンテンツの群れのIDを（セクション5.1および6を参照）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) the chunk size used,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（b）は、チャンクサイズ用い、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(c) the chunk addressing method used,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（C）使用チャンクアドレッシング方法、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(d) the content integrity protection method used, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（d）に使用されているコンテンツの完全性保護方法を、そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(e) the Merkle hash tree function used (if applicable).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（e）の使用マークルハッシュツリー機能（該当する場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(f) If automatic content size detection (see Section 5.6) is not used, the content length is also part of the metadata (for static content.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（f）は、自動コンテンツサイズ検出は（セクション5.6を参照）が使用されていない場合、コンテンツの長さは、メタデータの一部である（静的コンテンツ用）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document assumes the swarm metadata is obtained from a trusted source. In addition, Peer P needs to know a transport address for Peer Q, obtained from a peer discovery/tracking protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、メタデータは信頼できるソースから取得された群れを想定しています。また、ピアPは、ピア発見/追跡プロトコルから得られたピアQ用のトランスポート・アドレスを知る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The payload of the HANDSHAKE message contains a sequence of protocol options. The protocol options encode the swarm metadata just described to enable an end-to-end check to see whether the peers are in the right swarm. Additionally, the options encode a number of per-peer configuration parameters. The complete set of protocol options are specified in Section 7. The HANDSHAKE message also contains a channel ID for multiplexing communication and security (see Sections 3.11 and 12.1). A HANDSHAKE message MUST always be the first message in a datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェークメッセージのペイロードは、プロトコルオプションの配列を含みます。プロトコルオプションは単にピアが右群れにあるかどうか確認するために、エンドツーエンドのチェックを可能にするために記載群れメタデータを符号化します。また、オプションごとのピア・コンフィギュレーション・パラメータの数を符号化します。プロトコル・オプションの完全なセットは、ハンドシェイクメッセージはまた、多重通信及びセキュリティ（セクション3.11及び12.1を参照）のためのチャネルIDを含むセクション7で指定されています。ハンドシェイクメッセージは、常にデータグラムの最初のメッセージでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Handshake Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1。ハンドシェイク手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake procedure for a peer, Peer P, to start communication with another peer, Peer Q, in Swarm S is now as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように群発Sにおいて、他のピア、ピアQとの通信を開始するピア、ピアPのためのハンドシェイク手順は、今です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The first datagram the initiating Peer P sends to Peer Q MUST start with a HANDSHAKE message. This HANDSHAKE message MUST contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.開始ピアPがQをピアに送信最初のデータグラムは、ハンドシェイクメッセージで開始する必要があります。このハンドシェイクメッセージが含まれていなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       *  A channel ID, chanP, randomly chosen as specified in
          Section 12.1.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* The metadata of Swarm S, encoded as protocol options, as specified in Section 7. In particular, the initiating Peer P MUST include the swarm ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*プロトコルオプションとしてエンコード群発Sのメタデータは、特に、セクション7で指定されるように、開始ピアPは、群れのIDを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* The capabilities of Peer P, in particular, its supported protocol versions, &#34;Live Discard Window&#34; (in case of a live swarm) and &#34;Supported Messages&#34;, encoded as protocol options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*プロトコルオプションとしてエンコードピアPの能力、特に、そのサポートされるプロトコルバージョン、「ライブ破棄ウィンドウ」（ライブ群れの場合）及び「サポートメッセージ」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
This first datagram MUST be prefixed with the (destination) channel ID 0; see Section 3.11. Hence, the datagram contains two channel IDs: the destination channel ID prefixed to the datagram and the channel ID chanP included in the HANDSHAKE message inside the datagram. This datagram MAY also contain some minor additional payload, e.g., HAVE messages to indicate Peer P&#39;s current progress, but it MUST NOT include any heavy payload (defined in Section 1.3), such as a DATA message. Allowing minor
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この最初のデータグラムは、（宛先）チャネルID 0接頭辞なければなりません。 3.11節を参照してください。データグラムに接頭辞先チャネルID及びID chanPがデータグラム内のハンドシェイクメッセージに含まれたチャネル：したがって、データグラムは、2つのチャンネルのIDを含んでいます。このデータグラムはまた、例えば、ピアPの現在の進行状況を示すためのメッセージを持っている、いくつかのマイナーな追加のペイロードが含まれているかもしれないが、それは、このようなデータメッセージとして（セクション1.3で定義された）任意の重いペイロードを、含んではいけません。マイナー許可
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
payload minimizes the number of initialization round trips, thus improving time-till-playback. Forbidding heavy payload prevents an amplification attack (see Section 12.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ペイロードは、このように時間まで再生を改善する、初期のラウンドトリップの数を最小限に抑えます。重いペイロードを禁止します（12.1項を参照）、増幅攻撃を防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The receiving Peer Q checks the HANDSHAKE message from Peer P. If any check by Peer Q fails, or if Peers P and Q are not in the same swarm, Peer Q MUST NOT send a HANDSHAKE (or any other) message back, as the message from Peer P may have been spoofed (see Section 12.1). Otherwise, if Peer Q is interested in communicating with Peer P, Peer Q MUST send a datagram to Peer P that starts with a HANDSHAKE message. This reply HANDSHAKE MUST contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.ピアPからQをチェックハンドシェークメッセージの受信ピアをピアQによって任意のチェックが失敗した場合、またはピアPとQは同じ群れにない場合は、ピアQが戻っハンドシェーク（または他の）メッセージを送ってはいけません場合は、ピアPからのメッセージがスプーフィングされていてもよいように（セクション12.1を参照）。ピアQは、ピアPとの通信に興味がある場合はそれ以外の場合は、ピアQは、ハンドシェイクメッセージで始まるPピアにデータグラムを送らなければなりません。この応答ハンドシェイクが含まれていなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       *  A channel ID, chanQ, randomly chosen as specified in
          Section 12.1.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* The metadata of Swarm S, encoded as protocol options, as specified in Section 7. In particular, the responding Peer Q MAY include the swarm ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*プロトコルオプションとしてエンコード群発Sのメタデータは、特に、セクション7で指定されるように、応答ピアQは、群れのIDを含んでいてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* The capabilities of Peer Q, in particular, its supported protocol versions, its &#34;Live Discard Window&#34; (in case of a live swarm) and &#34;Supported Messages&#34;, encoded as protocol options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*ピアQの能力、特に、そのサポートされるプロトコルのバージョン、（ライブ群れの場合）その「ライブ破棄ウィンドウ」とプロトコル・オプションとしてエンコードされた「サポートされているメッセージ」、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
This reply datagram MUST be prefixed with the channel ID chanP sent by Peer P in the first HANDSHAKE message (see Section 3.11). This reply datagram MAY also contain some minor additional payload, e.g., HAVE messages to indicate Peer Q&#39;s current progress, or REQUEST messages (see Section 3.7), but it MUST NOT include any heavy payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この応答データグラムは、最初のハンドシェイクメッセージにピアPによって送信されたチャネルID chanP（セクション3.11を参照）を前に付けなければなりません。この応答データグラムはまた、例えば、ピアQの現在の進行状況を示すメッセージ、またはREQUESTメッセージを（3.7節を参照）は、いくつかのマイナーな追加のペイロードが含まれているかもしれないが、それはどんな重いペイロードを含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The initiating Peer P checks the reply datagram from Peer Q. If the reply datagram is not prefixed with (destination) channel ID chanP, Peer P MUST discard the datagram. Peer P SHOULD continue to process datagrams from Peer Q that do meet this requirement. This check prevents interference by spoofing, see Section 12.1. If Peer P&#39;s channel ID is echoed correctly, the initiator Peer P knows that the addressed Peer Q really responds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答データグラムは、データグラムを廃棄しなければならない（宛先）チャネルID chanP、ピアPが付いていない場合3.開始ピアPは、ピアQ.からの応答データグラムをチェックします。ピアPは、この要件を満たしていないピアQからのデータグラムを処理し続けるべきです。このチェックは、セクション12.1を参照してください、なりすましによる干渉を防止します。ピアPのチャネルIDが正しくエコーされた場合、イニシエータピアPは、アドレス指定されたピアQが実際に応答することを知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Next, Peer P checks the HANDSHAKE message in the datagram from Peer Q. If any check by Peer P fails, or Peer P is no longer interested in communicating with Peer Q, Peer P MAY send a HANDSHAKE message to inform Peer Q it will cease communication. This closing HANDSHAKE message MUST contain an all zeros channel ID and a list of protocol options. The list MUST either be empty or contain the maximum version number Peer P supports, following the min/max versioning scheme defined in [RFC6709], Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアPによるいかなるチェックが失敗した場合、またはピアPはピアQとの通信にはもはや興味を持っていない場合4.次に、ピアPはピアQ.からデータグラムでハンドシェークメッセージをチェックし、ピアPはピアQそれを通知するためのハンドシェイクメッセージを送信することができます通信を中止します。この閉鎖ハンドシェークメッセージは、すべてゼロのチャネルIDとプロトコル・オプションのリストを含まなければなりません。リストが空であるか、[RFC6709]で定義された最小/最大バージョニング・スキーム、セクション4.1以下の最大バージョン番号ピアPの支持体を含む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       The datagram containing this closing HANDSHAKE message MUST be
       prefixed with the (destination) channel ID chanQ.  Peer P MAY
       also simply cease communication.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If the addressed peer, Peer Q, does not respond to initiating Peer P&#39;s first datagram, Peer P MAY resend that datagram until Peer Q is considered dead, according to the rules specified in Section 3.12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5.対処ピア、ピアQは、ピアPの最初のデータグラムを開始するには応答しない場合、ピアQが死んだとみなされるまで、ピアPは3.12節で指定されたルールに従って、そのデータグラムを再送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If the reply datagram by Peer Q does pass the checks by Peer P, and Peer P wants to continue interacting with Peer Q, Peer P can now send REQUEST, PEX_REQ, and other messages to Peer Q. Datagrams carrying these messages MUST be prefixed with the channel ID chanQ sent by Peer Q. More specifically, because Peer P knows that Peer Q really responds, Peer P MAY start sending Peer Q messages with heavy payload. That means that Peer P MAY start responding to any REQUEST messages that Peer Q may have sent in this first reply datagram with DATA messages. Hence, transfer of chunks can start soon in PPSPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6.ピアQによって返信データグラムは、ピアPによるチェックをパスして、ピアPはピアQとの対話継続したい、ピアPは現在、これらのメッセージを運ぶQ.データグラムをピアへの要求、PEX_REQ、およびその他のメッセージを送ることができる場合でなければなりませんピアPはピアQが実際に応答することを知っているので、ピアPが重いペイロードをピアQメッセージの送信を開始することができ、ID chanQは、具体的にはピアQ.によって送信されたチャネルで始まります。これは、ピアPはQがデータメッセージと、この最初の応答データグラムで送られた可能性ピアいかなるREQUESTメッセージへの応答を開始してもよいことを意味します。したがって、チャンクの転送がPPSPPですぐに始めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. If Peer Q receives any datagram (apparently) from Peer P that does not contain channel ID chanQ, Peer Q MUST discard the datagram but SHOULD continue to process datagrams from Peer P that do meet this requirement. Once Peer Q receives a datagram from Peer P that does contain the channel ID chanQ, Peer Q knows that Peer P really received its reply datagram, and the three-way handshake and channel establishment is complete. Peer Q MAY now also start sending messages with heavy payload to Peer P.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7.ピアQチャンネルID chanQが含まれていないピアPから（明らかに）任意のデータグラムを受信した場合、ピアQは、データグラムを捨てなければなりませんが、この要件を満たしていないピアPからのデータグラムを処理し続けるべきです。ピアQチャンネルID chanQを含まないピアPからのデータグラムを受信すると、Qは、そのピアPは本当に、その応答データグラムを受信知っているピア、およびスリーウェイハンドシェイクとチャネル確立は完了です。ピアQは今もP.ピアするために重いペイロードとメッセージの送信を開始するかもしれ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. If Peer P decides it no longer wants to communicate with Peer Q, or vice versa, the peer SHOULD send a closing HANDSHAKE message to the other, as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8.ピアPは、それがもはやピアQ、またはその逆と通信することを望むことを決定しない場合は上記のように、ピアは、他に閉鎖ハンドシェイクメッセージを送信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. HAVE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。持ってる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HAVE message is used to convey which chunks a peer has available for download. The set of chunks it has available may be expressed using different chunk addressing and availability map compression schemes, described in Section 4. HAVE messages can be used both for sending a complete overview of a peer&#39;s chunk availability as well as for updates to that set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HAVEメッセージは、ピアがダウンロードできているチャンクどの伝えるために使用されます。チャンクの組は、セクション4に記載異なるアドレッシングチャンクと可用性地図圧縮方式を用いて表現することができる利用可能なメッセージは、ピアのチャンクの可用性、ならびにそのセットの更新のための完全な概要を送信するための両方に使用することができる持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular, whenever a receiving Peer P has successfully checked the integrity of a chunk, or interval of chunks, it MUST send a HAVE message to all peers Q1..Qn it wants to allow to download those chunks. A policy in Peer P determines when the HAVE is sent. Peer P may send it directly, or Peer P may wait either until it has other data to send to Peer Qi or until it has received and checked multiple chunks. The policy will depend on how urgent it is to distribute this information to the other peers. This urgency is generally determined in turn by the chunk picking policy (see Section 9.1). In general, the HAVE messages can be piggybacked onto other messages. Peers that do not receive HAVE messages are effectively prevented from downloading the newly available chunks; hence, the HAVE message can be used as a method of choking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信ピアPが正常にチャンクの完全性、またはチャンクの間隔を確認した時はいつでも特に、それは、これらのチャンクをダウンロードできるようにしたいQ1..QnすべてのピアにHAVEメッセージを送らなければなりません。 HAVEが送信されるときにピアPにおけるポリシーが決定します。ピアPは、それを直接送信することができ、またはそれは、それが受信され、複数のチャンクを確認するまでは気をピアまたはに送信する他のデータを持ってまで、ピアPは、どちらかを待つことがあります。ポリシーは、それが他のピアにこの情報を配布する方法を緊急に依存します。この緊急性は、一般的に（9.1節を参照）政策を選ぶチャンクによって順番に決定されます。一般的には、HAVEメッセージが他のメッセージにピギーバックすることができます。 HAVEメッセージを受信して​​いないピアは、効果的に新たに利用可能なチャンクをダウンロードすることが防止されます。従って有するメッセージは、窒息の方法として使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HAVE message MUST contain the chunk specification of the received and verified chunks. A receiving peer MUST NOT send a HAVE message to peers for which the handshake procedure is still incomplete, see Section 12.1. A peer SHOULD NOT send a HAVE message to peers that have the complete content already (e.g., in video-on-demand scenarios).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HAVEメッセージを受信して​​検証チャンクのチャンク仕様を含まなければなりません。受信ピアは、セクション12.1を参照して、ハンドシェイク手順がまだ不完全であるためにピアにHAVEメッセージを送ってはいけません。ピアは、すでに（例えば、ビデオ・オン・デマンドのシナリオでは）完全なコンテンツを持っているピアにHAVEメッセージを送るべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. DATA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。データ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DATA message is used to transfer chunks of content. The DATA message MUST contain the chunk ID of the chunk and chunk itself. A peer MAY send the DATA messages for multiple chunks in the same datagram. The DATA message MAY contain additional information if needed by the specific congestion control mechanism used. At present, PPSPP uses LEDBAT [RFC6817] for congestion control, which requires the current system time to be sent along with the DATA message, so the current system time MUST be included.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATAメッセージは、コンテンツのチャンクを転送するために使用されます。 DATAメッセージは、チャンクとチャンク自体のチャンクIDを含まなければなりません。ピアは、同じデータグラムに複数のチャンクのためのデータ・メッセージを送信することができます。使用される特定の輻輳制御機構により、必要に応じてDATAメッセージには、追加情報を含むことができます。現在のところ、PPSPPは、DATAメッセージとともに送信される現在のシステム時間を必要と輻輳制御のためLEDBAT [RFC6817]を使用するため、現在のシステム時刻を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. ACK
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4。 ACK
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACK messages MUST be sent to acknowledge received chunks if PPSPP is run over an unreliable transport protocol. ACK messages MAY be sent if a reliable transport protocol is used. In the former case, a receiving peer that has successfully checked the integrity of a chunk, or interval of chunks C, MUST send an ACK message containing a chunk specification for C. As LEDBAT is used, an ACK message MUST contain the one-way delay, computed from the peer&#39;s current system time received in the DATA message. A peer MAY delay sending ACK messages as defined in the LEDBAT specification [RFC6817].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACKメッセージがPPSPPが信頼できないトランスポートプロトコル上で実行された場合に受信チャンクを確認するために送らなければなりません。信頼性の高いトランスポートプロトコルが使用されている場合、ACKメッセージが送信されるかもしれません。前者の場合、正常チャンクの完全性、又はチャンクCの間隔を確認した受信ピアは、LEDBATが使用されているようにCのチャンク仕様を含むACKメッセージを送らなければなりません、ACKメッセージは、一方向を含まなければなりませんピアの現在のシステム時刻から計算遅延は、DATAメッセージで受信しました。ピアはLEDBAT仕様[RFC6817]で定義されるようにACKメッセージを送信遅延させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. INTEGRITY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5。 INTEGRITY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The INTEGRITY message carries information required by the receiver to verify the integrity of a chunk. Its payload depends on the content integrity protection scheme used. When the Merkle Hash Tree scheme is used, an INTEGRITY message MUST contain a cryptographic hash of a subtree of the Merkle hash tree and the chunk specification that identifies the subtree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インテグリティ・メッセージは、チャンクの完全性を検証するために受信機が必要とする情報を運びます。そのペイロードが使用されるコンテンツの完全性保護方式に依存します。マークル・ハッシュ木方式を使用する場合、完全性メッセージは、マークル・ハッシュ・ツリーおよびサブツリーを識別するチャンク仕様のサブツリーの暗号ハッシュを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a typical example, when a peer wants to send a chunk and Merkle hash trees are used, it creates a datagram that consists of several INTEGRITY messages containing the hashes the receiver needs to verify the chunk and the actual chunk itself encoded in a DATA message. What are the necessary hashes and the exact rules for encoding them into datagrams is specified in Sections 5.3, and 5.4, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがチャンクを送信したいとマークル・ハッシュ・ツリーが使用される場合の典型的な例として、それは、受信機がデータメッセージでエンコードチャンクと実際のチャンク自体を検証する必要があるハッシュを含むいくつかの整合性メッセージから成るデータグラムを作成します。データグラムにそれらをエンコードするために必要なハッシュと正確な規則はどのようなものがあり、それぞれ、セクション5.3で指定され、そして5.4れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. SIGNED_INTEGRITY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6。 SIGNED_INTEGRITY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SIGNED_INTEGRITY message carries digitally signed information required by the receiver to verify the integrity of a chunk in live streaming. It logically contains a chunk specification, a timestamp, and a digital signature. Its exact payload depends on the live content integrity protection scheme used, see Section 6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SIGNED_INTEGRITYメッセージは、ライブストリーミングでチャンクの完全性を検証するために受信機によって必要とされるデジタル署名された情報を運びます。これは、論理的にチャンク仕様、タイムスタンプ、およびデジタル署名が含まれています。その正確なペイロードを使用し、ライブコンテンツの完全性保護方式に依存し、6.1節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. REQUEST
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7。要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While bulk download protocols normally do explicit requests for certain ranges of data (i.e., use a pull model, for example, BitTorrent [BITTORRENT]), live streaming protocols quite often use a push model without requests to save round trips. PPSPP supports both models of operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一括ダウンロードプロトコルは、通常、データのある範囲の明示的な要求を行う一方で（すなわち、例えば、プルモデルを使用し、BitTorrentの[BitTorrentの]）、ライブストリーミングプロトコルは、かなり頻繁に往復を保存することを要求せずに、プッシュモデルを使用します。 PPSPPは、操作の両方のモデルをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REQUEST message is used to request one or more chunks from another peer. A REQUEST message MUST contain the specification of the chunks the requester wants to download. A peer receiving a REQUEST message MAY send out the requested chunks (by means of DATA messages). When Peer Q receives multiple REQUESTs from the same Peer P, Peer Q SHOULD process the REQUESTs in the order received. Multiple REQUEST messages MAY be sent in one datagram, for example, when a peer wants to request several rare chunks at once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUESTメッセージは、別のピアから1つ以上のチャンクを要求するために使用されます。 REQUESTメッセージは、要求者がダウンロードしたいチャンクの仕様を含まなければなりません。 REQUESTメッセージを受信するピアは、（DATAメッセージによって）要求されたチャンクを送るかもしれ。ピアQは、同じピアPから複数の要求を受信すると、ピアQは、受信された順序で要求を処理しなければなりません。複数の要求メッセージは、ピアが一度に複数の希少なチャンクを要求したい場合、例えば、1グラムで送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When live streaming via a push model, a peer receiving REQUESTs also MAY send some other chunks in case it runs out of requests or for some other reason. In that case, the only purpose of REQUEST messages is to provide hints and coordinate peers to avoid unnecessary data retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プッシュモデルを介した場合には、ライブストリーミング、要​​求を受けたピアはまた、要求のうち、または他のいくつかの理由で実行される場合、いくつかの他のチャンクを送信することができます。その場合には、要求メッセージの唯一の目的は、ヒントを提供し、不必要なデータ再送を回避するために、ピアを調整することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. CANCEL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8。キャンセル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When downloading on-demand or live streaming content, a peer can request urgent data from multiple peers to increase the probability of it being delivered on time. In particular, when the specific chunk picking algorithm (see Section 9.1), detects that a request for urgent data might not be served on time, a request for the same data can be sent to a different peer. When a Peer P decides to request urgent data from a Peer Q, Peer P SHOULD send a CANCEL message to all the peers to which the data has been previously requested. The
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オンデマンドやライブストリーミングコンテンツをダウンロードすると、ピアは、それが時間通りに配信される確率を高めるために複数のピアからの緊急データを要求することができます。緊急データの要求が時間通りに提供されていない可能性があることを検出したときに、特定のチャンクがアルゴリズムを選ぶ（9.1節を参照）、特に、同じデータの要求は、別のピアに送信することができます。ピアPはピアQからの緊急データを要求することを決定した場合には、ピアPは、データが以前に要求されたために、すべてのピアにCANCELメッセージを送信する必要があります。ザ・
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CANCEL message contains the specification of the chunks Peer P no longer wants to request. In addition, when Peer Q receives a HAVE message for the urgent data from Peer P, Peer Q MUST also cancel the previous REQUEST(s) from Peer P. In other words, the HAVE message acts as an implicit CANCEL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CANCELメッセージは、チャンクの仕様はPは、もはや要求するために望んでいないピアが含まれています。暗黙的なCANCELとして加えて、ピアQは、ピアPから緊急データを持っているメッセージを受信すると、ピアQもつまりピアPから前の要求（複数可）をキャンセルする必要があり、HAVEメッセージが作用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9. CHOKE and UNCHOKE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9。 CHOKEとUNCHOKE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer A can send a CHOKE message to Peer B to signal it will no longer be responding to REQUEST messages from Peer B, for example, because Peer A&#39;s upload capacity is exhausted. Peer A MAY send a subsequent UNCHOKE message to signal that it will respond to new REQUESTs from Peer B again (Peer A SHOULD discard old requests). When Peer B receives a CHOKE message from Peer A, it MUST NOT send new REQUEST messages and it cannot expect answers to any outstanding ones, as the transfer of chunks is choked. When Peer B is choked but receives a HAVE message from Peer A, it is not automatically unchoked and MUST NOT send any new REQUEST messages. The CHOKE and UNCHOKE messages are informational as responding to REQUESTs is OPTIONAL, see Section 3.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアAのアップロード容量が消耗しているので、もはや、例えば、ピアBからメッセージを要求に応答しません知らせるためにBをピアチョークメッセージを送ることができピア。ピアAは、それが（古い要求を破棄すべきであるピア）再びピアBからの新しい要求に応答しますことを知らせるために、後続のUNCHOKEメッセージを送信することができます。ピアBは、ピアAからチョークメッセージを受信すると、それは新しいREQUESTメッセージを送ってはいけませんし、チャンクの転送が絞られているとして、それは、未処理のものに答えを期待することはできません。ピアBが窒息が、ピアAからHAVEメッセージを受信すると、自動的に非チョークではなく、すべての新しい要求メッセージを送ってはいけません。チョークとUNCHOKEメッセージが要求に応答として情報提供しているオプションですが、3.7節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10. Peer Address Exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10。ピアアドレス交換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.1. PEX_REQ and PEX_RES Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.1。 PEX_REQとPEX_RESメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer Exchange (PEX) messages are common in many peer-to-peer protocols. They allow peers to exchange the transport addresses of the peers they are currently interacting with, thereby reducing the need to contact a central tracker (or Distributed Hash Table) to discovery new peers. The strength of this mechanism is therefore that it enables decentralized peer discovery: after an initial bootstrap, a central tracker is no longer needed. Its weakness is that it enables a number of attacks, so it should not be used on the Internet unless extra security measures are in place.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアエクスチェンジ（PEX）のメッセージは、多くのピア・ツー・ピア・プロトコルに共通しています。彼らは、ピアがそれによって発見新しいピアに中央トラッカ（または分散ハッシュテーブル）に連絡する必要性を減少させる、彼らが現在対話しているピアのトランスポート・アドレスを交換することを可能にします。初期ブートストラップの後、中央のトラッカーはもはや必要とされている。このメカニズムの強さは、それが分散型ピア発見を可能にしていないことがあります。その弱点は、余分なセキュリティ対策が実施されている場合を除き、それは、インターネット上で使用すべきではないので、それは、攻撃の数を可能にするということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP supports peer-address exchange on the Internet and in benign private networks as an OPTIONAL feature (not mandatory to implement) under certain conditions. The general mechanism works as follows. To obtain some peer addresses, a Peer A MAY send a PEX_REQ message to Peer B. Peer B MAY respond with one or more PEX_REScert messages. Logically, a PEX_REScert reply message contains the address of a single peer Ci. Peer B MUST have exchanged messages with Peer Ci in the last 60 seconds to guarantee liveliness. Upon receipt, Peer A may contact any or none of the returned peers Ci. Alternatively, peers MAY ignore PEX_REQ and PEX_REScert messages if uninterested in obtaining new peers or because of security considerations (rate limiting) or any other reason. The PEX messages can be used to construct a dedicated tracker peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPは、インターネット上で、一定の条件の下で（実装するために必須ではありません）オプション機能として良性のプライベートネットワークでピア・アドレスの交換をサポートしています。次のように一般的なメカニズムが機能します。いくつかのピアアドレスを取得するには、ピアAは、一つ以上のPEX_REScertメッセージで応答することができるB.ピアBピアするPEX_REQメッセージを送信することができます。論理的に、PEX_REScert応答メッセージは、単一のピアCiのアドレスを含みます。ピアBは活気を保証するために、最後の60秒でピアCIでメッセージを交換している必要があります。受信すると、ピアAが返さピアCiのいずれかまたはいずれもが接触することができます。新しい仲間を得るのか、セキュリティ上の考慮事項（レート制限）またはその他の理由で無関心ならば代わりに、ピアはPEX_REQとPEX_REScertメッセージを無視するかもしれません。 PEXメッセージは、専用のトラッカーピアを構築するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To use PEX in PPSPP on the Internet, two conditions must be met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネット上PPSSPPでPEXを使用するには、2つの条件が満たされる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Peer transport addresses must be relatively stable.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.ピアトランスポート・アドレスは比較的安定していなければなりません。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. A peer must not obtain all its peer addresses through PEX.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.ピアはPEXを介してすべてのピアアドレスを取得してはなりません。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The full security analysis for PEX messages can be found in Section 12.2. Physically, a PEX_REScert message carries a swarm-membership certificate rather than an IP address and port. A membership certificate for Peer C states that Peer C at address (ipC,portC) is part of Swarm S at Time T and is cryptographically signed by an issuer. The receiver Peer A can check the certificate for a valid signature by a trusted issuer, the right swarm, and liveliness and only then consider contacting C. These swarm-membership certificates correspond to signed node descriptors in secure decentralized peer sampling services [SPS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEXメッセージの完全なセキュリティ分析は、セクション12.2で見つけることができます。物理的には、PEX_REScertメッセージが群れメンバーシップ証明書ではなく、IPアドレスとポートを運びます。アドレスにCピアピアC状態（IPC、PORTC）のメンバーシップ証明書は、時刻Tにおける群発Sの一部であり、暗号発行者によって署名されています。受信ピアAは、信頼できる発行者による有効な署名の証明書、権利群れ、そして活気を確認してのみ、これらの群れメンバーシップ証明書が[SPS]安全な分散型のピアサンプリングサービスにログインノード記述子に対応する℃に接触考慮することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several designs are possible for the security environment for these membership certificates. That is, there are different designs possible for who signs the membership certificates and how public keys are distributed. Section 12.2.2 describes an example where a central tracker acts as the Certification Authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのデザインは、これらの会員証明書のセキュリティ環境のために可能です。これは、メンバーシップ証明書に署名し、公開鍵がどのように分布している人のための可能な種類のデザインがあり、あります。セクション12.2.2は、中央トラッカーが証明機関として機能する例について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a hostile environment, such as the Internet, peers must also ensure that they do not end up interacting only with malicious peers when using the peer-address exchange feature. To this extent, peers MUST ensure that part of their connections are to peers whose addresses came from a trusted and secured tracker (see Section 12.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
敵対的な環境では、インターネットのような、ピアはまた、彼らは、ピア・アドレス交換機能を使用している場合、悪意のあるピアとだけ対話するまで終了しないことを確認する必要があります。この点で、ピアは、アドレスが信頼できるとセキュアなトラッカーから来た仲間にしているその接続の一部を確保しなければならない（第12.2.3項を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the PEX_REScert, there are two other PEX reply messages. The PEX_RESv4 message contains a single IPv4 address and port. The PEX_RESv6 message contains a single IPv6 address and port. They MUST only be used in a benign environment, such as a private network, as they provide no guarantees that the host addressed actually participates in a PPSPP swarm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEX_REScertに加えて、他の二つのPEXの応答メッセージがあります。 PEX_RESv4メッセージは、単一のIPv4アドレスとポートが含まれています。 PEX_RESv6メッセージは、単一のIPv6アドレスとポートが含まれています。彼らはホストがPPSPPの群れに参加し、実際に取り組むという保証を提供しないよう彼らは、そのようなプライベートネットワークとして、良性の環境で使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a PPSPP implementation has obtained a list of peers (either via PEX, from a central tracker, or via a Distributed Hash Table (DHT)), it has to determine which peers to actually contact. In this process, a PPSPP implementation can benefit from information by network or content providers to help improve network usage and boost PPSPP performance. How a peer-to-peer (P2P) system like PPSPP can perform these optimizations using the Application-Layer Traffic Optimization (ALTO) protocol is described in detail in [RFC7285], Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP実装が（PEXを介して、中央トラッカから、または分散ハッシュテーブル（DHT）を介してのいずれか）のピアのリストを取得した後、実際に接触するピアを決定しなければなりません。このプロセスでは、PPSPP実装は、ネットワークの使用状況を改善し、PPSPP性能を高めるために、ネットワークやコンテンツプロバイダによる情報の恩恵を受けることができます。 PPSPPようなピア・ツー・ピア（P2P）システムは、アプリケーションレイヤトラフィックの最適化を使用して、これらの最適化を実行する方法（ALTO）プロトコルは、[RFC7285]に詳細に記載されている、第7節。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.11. Channels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.11。チャンネル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is increasingly complex for peers to enable communication between each other due to NATs and firewalls. Therefore, PPSPP uses a multiplexing scheme, called channels, to allow multiple swarms to use the same transport address. Channels loosely correspond to TCP connections and each channel belongs to a single swarm, as illustrated in Figure 1. As with TCP connections, a channel is identified by a unique identifier local to the peer at each end of the connection (cf. TCP port), which MUST be randomly chosen. In other words, the two peers connected by a channel use different IDs to denote the same channel. The IDs are different and random for security reasons, see Section 12.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが原因のNATやファイアウォールに互いの間の通信を可能にすることは、ますます複雑です。したがって、PPSPPは、複数の群れは、同じトランスポート・アドレスを使用できるように、チャネルと呼ばれる、多重化方式を使用します。チャネルが緩くTCP接続に対応し、TCP接続と同様に、図1に示すように、各チャネルは、単一の群れに属する、チャネルは接続（参照TCPポート）の各端部にピアにローカル一意識別子によって識別されます、ランダムに選択されなければなりません。換言すれば、チャネルによって接続された2つのピアは、同じチャネルを表すために異なるIDを使用します。 IDは、セキュリティ上の理由から異なるとランダムである12.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the PPSP-over-UDP encapsulation (Section 8.3), when a Channel C has been established between Peer A and Peer B, the datagrams containing messages from Peer A to Peer B are prefixed with the four-byte channel ID allocated by Peer B, and vice versa for datagrams from Peer B to A. The channel IDs used are exchanged as part of the handshake procedure, see Section 8.4. In that procedure, the channel ID with value 0 is used for the datagram that initiates the handshake. PPSPP can be used in combination with Session Traversal Utilities for NAT (STUN) [RFC5389].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャネルCは、ピアAとピアBの間で確立されているPPSPオーバーUDPカプセル化（セクション8.3）で、BをピアツーピアAからメッセージを含むデータグラムは、ピアBによって割り当てられた4バイトのチャネルIDと接頭辞A.へピアBからデータグラムを使用するチャネルIDのための、およびその逆は、セクション8.4を参照して、ハンドシェイク手順の一部として交換されます。その手順では、値0のチャネルIDは、ハンドシェイクを開始し、データグラムのために使用されます。 PPSPPはNATのためのセッショントラバーサルユーティリティ（STUN）[RFC5389]と組み合わせて使用​​することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               _________    _________          _________
               |       |    |       |          |       |
               | Swarm |    | Swarm |          | Swarm |
               |  Mgr  |    |   A   |          |   B   |
               |_______|    |_______|          |_______|
                   |            |                /   \
                   |            |               /     \
               ____|____    ____|____    ______/__    _\_______
               |       |    |       |    |       |    |       |
               | Chan  |    | Chan  |    | Chan  |    | Chan  |
               |   0   |    |  481  |    |  836  |    |  372  |
               |_______|    |_______|    |_______|    |_______|
                   |            |            |            |
                   |            |            |            |
               ____|____________|____________|____________|____
               |                                              |
               |                      UDP                     |
               |                   port 6778                  |
               |______________________________________________|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Network stack of a PPSPP peer that is reachable on UDP port 6778 and is connected via channel 481 to one peer in Swarm A and two peers in Swarm B via channels 836 and 372, respectively. Channel ID 0 is special and is used for handshaking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPポート6778に到達可能であり、群発Aにおける1つのピアそれぞれチャネル836及び372を介して群発Bにおける2つのピアにチャネル481を介して接続されているPPSPPピアのネットワークスタック。チャネルID 0は特別で、ハンドシェイクのために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.12. Keep Alive Signaling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.12。アライブ・シグナリングをキープ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer SHOULD send a &#34;keep alive&#34; message periodically to each peer it is interested in, but has no other messages to send to them at present. The goal of the keep alives is to keep a signaling channel open to peers that are of interest. Which peers those are is determined by a policy that decides which peers are of interest now and in the near future. This document does not prescribe a policy, but examples of interesting peers are (a) peers that have chunks on offer that this client needs or (b) peers that currently do not have interesting chunks on offer (because they are still downloading themselves, or in live streaming) but gave good performance in the past. When these peers have new chunks to offer, the peer that kept a signaling channel open can use them again. Periodically sending &#34;keep alive&#34; messages prevents other peers declaring the peer dead. A guideline for declaring a peer dead when using UDP consists of a three minute delay since that last packet has been received from that peer and at least three datagrams having been sent to that peer during the same period. When a peer is declared dead, the channel to it is closed, no more messages will be sent to that peer and the local administration about the peer is discarded. Busy servers can force idle clients to disconnect by not sending keep alives. PPSPP does not define an explicit message type for &#34;keep alive&#34; messages. In the PPSP-over-UDP encapsulation they are implemented as simple datagrams consisting of a four-byte channel ID only, see Sections 8.3 and 8.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、定期的に各それが興味を持っているが、現時点ではそれらに送信するために他のメッセージを持っていないピア「キープアライブ」メッセージを送信する必要があります。キープアライブの目標は、関心のあるピアにオープンシグナリングチャネルを維持することです。ものになりましたし、近い将来に関心のあるどのピア決定ポリシーによって決定されているがピア。この文書では、ポリシーを規定しないが、面白い仲間の一例であり、（a）は、彼らはまだ自分自身をダウンロードしているので、このクライアントが必要とする、または（b）の（現在提供する上で興味深いチャンクを持っていないことをピアことを提供する上でのチャンクを持っている同僚、またはライブストリーミング中）が、過去に良好な性能を与えました。これらのピアが提供する新しいチャンクを持っている場合は、オープンシグナリングチャネルを保持ピアは再びそれらを使用することができます。定期的に「キープアライブ」メッセージを送信することは、ピア死者を宣言する他のピアを防ぐことができます。 UDPを使用してピア死者を宣言するためのガイドラインは、最後のパケットがそのピアから受信された少なくとも3つのデータグラムが同じ期間中にそのピアに送信されたので、3分間の遅延から成ります。ピアが死んで宣言されると、それへのチャネルにはより多くのメッセージがそのピアに送信されず、ピアに関する局所投与は破棄され、閉じられています。ビジーのサーバーがキープアライブを送信しないで切断するアイドル状態のクライアントを強制することができます。 PPSPPメッセージ「キープアライブ」の明示的なメッセージタイプを定義していません。彼らは唯一の4バイトのチャンネルIDからなるシンプルなデータグラムとして実装されているPPSPオーバーUDPカプセル化では、セクション8.3と8.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Chunk Addressing Schemes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.チャンクアドレス指定方式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP can use different methods of chunk addressing, that is, support different ways of identifying chunks and different ways of expressing the chunk availability map of a peer in a compact fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSSPPアドレッシングチャンクの異なる方法を使用することができ、つまり、チャンクとコンパクト方式でピアのチャンク可用性地図を表現する様々な方法を特定するさまざまな方法をサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All peers in a swarm MUST use the same chunk addressing method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
群れのすべてのピアが同じチャンクのアドレス指定方法を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Start-End Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。開始、終了範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A chunk specification consists of a single (start specification,end specification) pair that identifies a range of chunks (end inclusive). The start and end specifications can use one of multiple addressing schemes. Two schemes are currently defined: chunk ranges and byte ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンク仕様はチャンク（端部を含む）の範囲を特定する単一（開始仕様、端仕様）のペアで構成されています。開始と終了の仕様は、複数のアドレス指定方式のいずれかを使用することができます。二つの方式が、現在定義されています：チャンク範囲とバイト範囲。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Chunk Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1。チャンク範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The start and end specification are both chunk identifiers. Chunk identifiers are 32-bit or 64-bit unsigned integers. A PPSPP peer MUST support this scheme.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始と終了の仕様では、両方のチャンク識別子です。チャンク識別子は32ビットまたは64ビットの符号なし整数です。 PPSPPピアは、この方式をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                    Start chunk (32 or 64)                     ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                    End chunk (32 or 64)                       ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Byte Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2。バイト範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The start and end specification are 64-bit byte offsets in the content. The support for this scheme is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始と終了の仕様内容に64ビットのバイトオフセットです。このスキームのためのサポートはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Start byte offset (64)                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    End byte offset (64)                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Bin Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。ビン番号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP introduces a novel method of addressing chunks of content called &#34;bin numbers&#34; (or &#34;bins&#34; for short). Bin numbers allow the addressing of a binary interval of data using a single integer. This reduces the amount of state that needs to be recorded per peer and the space needed to denote intervals on the wire, making the protocol lightweight. In general, this numbering system allows PPSPP to work with simpler data structures, e.g., to use arrays instead of binary trees, thus reducing complexity. The support for this scheme is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP「はビン番号」（または略して「ビン」）と呼ばれるコンテンツのチャンクに対処する新規な方法を導入します。ビン番号は、単一の整数を使用して、データのバイナリ間隔のアドレス指定を可能にします。これは、ピアとプロトコルが軽量化、ワイヤ上の間隔を示すために必要なスペースごとに記録する必要のある状態の量を減少させます。一般に、この番号付けシステムはPPSPPは、このように複雑さを低減、代わりにバイナリツリーのアレイを使用する、例えば、単純なデータ構造で動作することを可能にします。このスキームのためのサポートはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In bin addressing, the smallest binary interval is a single chunk (e.g., a block of bytes that may be of variable size), the largest interval is a complete range of 2**63 chunks. In a novel addition to the classical scheme, these intervals are numbered in a way that lays them out into a vector nicely, which is called bin numbering, as follows. Consider a chunk interval of width W. To derive the bin numbers of the complete interval and the subintervals, a minimal balanced binary tree is built that is at least W chunks wide at the base. The leaves from left-to-right correspond to the chunks 0..W-1 in the interval, and have bin number I*2 where I is the index of the chunk (counting beyond W-1 to balance the tree). The bin number of higher-level node P in the tree is calculated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビン内の最小のバイナリ間隔は単一のチャンクであり、アドレス指定（例えば、可変サイズのものとすることができるバイトのブロック）は、最大間隔が2つの** 63チャンクの完全な範囲です。次のように古典的なスキームの新規加えて、これらの間隔は、ビン番号と呼ばれる、うまくベクターにそれらをレイアウトするように番号付けされています。ベースで少なくとも幅Wの塊である最小限のバランスの取れたバイナリツリーが構築され、完全な間隔とのサブインターバルのビン番号を導出するための幅Wのチャンク間隔を考えてみましょう。左から右の葉は区間内のチャンク0..W-1に対応し、私はチャンクのインデックス（ツリーのバランスをとるためにW-1を超えてカウントされる）2 *ビン番号を有しています。次のようにツリー内の上位ノードPのビン数が計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
binP = (binL + binR) / 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
=（+）/ 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where binL is the bin of node P&#39;s left-hand child and binR is the bin of node P&#39;s right-hand child. Given that each node in the tree represents a subinterval of the original interval, each such subinterval now is addressable by a bin number, a single integer. The bin number tree of an interval of width W=8 looks like this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BINLは、ノードPの左側の子のビンであるとbinRは、ノードPの右側の子のビンです。ツリー内の各ノードは、元の区間の部分区間を表していることを考えると、このような各サブインターバルは現在のビン数、単一の整数によってアドレス指定可能です。 = 8幅Wの間隔のビン数ツリーは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                   7
                                  / \
                                /     \
                              /         \
                            /             \
                           3                11
                          / \              / \
                         /   \            /   \
                        /     \          /     \
                       1       5        9       13
                      / \     / \      / \      / \
                     0   2   4   6    8   10  12   14
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
C0 C1 C2 C3 C4 C5 C6 C7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
C0 C1 C2 C3 C4 C5 C6 C7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
The bin number tree of an interval of width W=8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
= 8 W幅の間隔のビン数木
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So bin 7 represents the complete interval, bin 3 represents the interval of chunk C0..C3, bin 1 represents the interval of chunks C0 and C1, and bin 2 represents chunk C1. The special numbers 0xFFFFFFFF (32-bit) or 0xFFFFFFFFFFFFFFFF (64-bit) stands for an empty interval, and 0x7FFF...FFF stands for &#34;everything&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図7は、完全な間隔を表すので、ビン、ビン3がチャンクC0..C3の間隔を表し、ビン1は、チャンクC0とC1の間隔を表し、ビン2は、チャンクC1を表します。特別な数字は0xFFFFFFFF（32ビット）または0xFFFFFFFFFFFFFFFF（64ビット）は、空の区間の略で、0x7FFFを... FFFは、「すべて」の略です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When bin numbering is used, the ID of a chunk is its corresponding (leaf) bin number in the tree, and the chunk specification in HAVE and ACK messages is equal to a single bin number (32-bit or 64-bit), as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビンナンバリングを使用した場合、チャンクのIDは、ツリー内のその対応する（リーフ）ビン番号であり、且つとして有し、ACKメッセージにおけるチャンク仕様は、単一のビン番号（32ビットまたは64ビット）に等しいです。次の。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                    Bin number (32 or 64)                      ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. In Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。メッセージには
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. In HAVE Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1。 HAVEメッセージに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a receiving peer has successfully checked the integrity of a chunk or interval of chunks, it MUST send a HAVE message to all peers it wants to allow download of those chunk(s) from. The ability to withhold HAVE messages allows them to be used as a method of choking. The HAVE message MUST contain the chunk specification of the biggest complete interval of all chunks the receiver has received and checked so far that fully includes the interval of chunks just received. So the chunk specification MUST denote at least the interval received, but the receiver is supposed to aggregate and acknowledge bigger intervals, when possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信側ピアが正常にチャンクのチャンクまたは間隔の整合性をチェックしたときは、それから、それはチャンク（s）は、それらのダウンロードを可能にするために望んでいるすべてのピアにHAVEメッセージを送らなければなりません。 HAVEメッセージを保留する能力は、彼らが窒息の方法として使用することができます。 HAVEメッセージは、受信機が受信し、これまでに完全に受信されたばかりのチャンクの間隔が含まれていることを確認したすべてのチャンクの最大の完全な間隔のチャンクの指定を含まなければなりません。だから、チャンク仕様は、少なくとも間隔が受信示す必要がありますが、受信機は、可能な場合、より大きな間隔を集約し、承認することになっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result, every single chunk is acknowledged a logarithmic number of times. That provides some necessary redundancy of acknowledgements and sufficiently compensates for unreliable transport protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その結果、すべての単一のチャンクが倍の対数数を認めています。それは肯定応答のいくつかの必要な冗長性を提供し、十分に信頼性のないトランスポートプロトコルを補償します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation note:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       To record which chunks a peer has in the state that an
       implementation keeps for each peer, an implementation MAY use the
       efficient &#34;binmap&#34; data structure, which is a hybrid of a bitmap
       and a binary tree, discussed in detail in [BINMAP].
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. In ACK Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2。 ACKメッセージで
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP peers MUST use ACK messages to acknowledge received chunks if an unreliable transport protocol is used. When a receiving peer has successfully checked the integrity of a chunk or interval of chunks C, it MUST send an ACK message containing the chunk specification of its biggest, complete interval covering C to the sending peer (see HAVE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPピアは信頼できないトランスポートプロトコルが使用されている場合、受信したチャンクを確認するためにACKメッセージを使用しなければなりません。受信ピアは、チャンクまたはチャンクCの間隔の整合性をチェック成功した場合、それは送信ピア（HAVEを参照）にその最大の完全な間隔カバーCのチャンクの指定を含むACKメッセージを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Content Integrity Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.コンテンツの整合性の保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP can use different methods for protecting the integrity of the content while it is being distributed via the peer-to-peer network. More specifically, PPSPP can use different methods for receiving peers to detect whether a requested chunk has been maliciously modified by the sending peer. In benign environments, content integrity protection can be disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPは、ピア・ツー・ピアネットワークを介して配信されている間、コンテンツの完全性を保護するための異なる方法を使用することができます。より具体的には、PPSPPは、要求されたチャンクが悪意送信ピアによって変更されたかどうかを検出するために、ピアを受信するための異なる方法を使用することができます。良性の環境では、コンテンツの完全性保護を無効にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For static content, PPSPP currently defines one method for protecting integrity, called the Merkle Hash Tree scheme. If PPSPP operates over the Internet, this scheme MUST be used. If PPSPP operates in a benign environment, this scheme MAY be used. So the scheme is mandatory to implement, to satisfy the requirement of strong security for an IETF protocol [RFC3365]. An extended version of the scheme is used to efficiently protect dynamically generated content (live streams), as explained below and in Section 6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静的コンテンツの場合、PPSPPは現在、完全性を保護するための一つの方法を定義し、マークルハッシュツリースキームと呼ばれます。 PPSPPは、インターネット上で動作している場合、この方式を使用しなければなりません。 PPSPPは良性の環境で動作している場合、この方式を使用することができます。だから、スキームは、IETFプロトコル[RFC3365]のための強力なセキュリティの要件を満たすために、実装が必須です。以下およびセクション6.1で説明したようにスキームの拡張バージョンは、効率的に動的に生成されたコンテンツ（ライブストリーム）を保護するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Merkle Hash Tree scheme can work with different chunk addressing schemes. All it requires is the ability to address a range of chunks. In the following description abstract node IDs are used to identify nodes in the tree. On the wire, these are translated to the corresponding range of chunks in the chosen chunk addressing scheme.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークルハッシュツリー方式が異なるチャンクアドレス指定方式で動作することができます。それは必要なすべては、チャンクの範囲に対処するための機能です。以下の説明では、抽象ノードIDは、ツリー内のノードを識別するために使用されます。ワイヤ上に、これらは、選択されたチャンクアドレス指定方式におけるチャンクの対応する範囲に変換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Merkle Hash Tree Scheme
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。マークルハッシュツリーのスキーム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP uses a method of naming content based on self-certification. In particular, content in PPSPP is identified by a single cryptographic hash that is the root hash in a Merkle hash tree calculated recursively from the content [ABMRKL]. This self-certifying hash tree allows every peer to directly detect when a malicious peer tries to distribute fake content. It also ensures only a small the amount of information is needed to start a download (the root hash and some peer addresses). For live streaming, a dynamic tree and a public key are used, see below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPは自己認証に基づいてコンテンツを命名する方法を使用しています。特に、PPSPP内のコンテンツは、コンテンツ[ABMRKL]から再帰的に計算マークル・ハッシュ・ツリーのルートハッシュ単一暗号ハッシュによって識別されます。この自己証明ハッシュツリーは、すべての悪意のあるピアが偽のコンテンツを配信しようとすると、直接検出するために、ピアことができます。また、情報だけ少量のダウンロード（ルートハッシュといくつかのピアアドレス）を開始するために必要とされる保証します。ライブストリーミング、動的なツリーと使用されている公開鍵については、以下を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Merkle hash tree of a content file that is divided into N chunks is constructed as follows. Note the construction does not assume chunks of content to be of a fixed size. Given a cryptographic hash function, more specifically an MDC [HAC01], such as SHA-256, the hashes of all the chunks of the content are calculated. Next, a binary tree of sufficient height is created. Sufficient height means that the lowest level in the tree has enough nodes to hold all chunk hashes in the set, as with bin numbering. The figure below shows the tree for a content file consisting of 7 chunks. As with the content addressing scheme, the leaves of the tree correspond to a chunk and, in this case, are assigned the hash of that chunk, starting at the leftmost leaf. As the base of the tree may be wider than the number of chunks, any remaining leaves in the tree are assigned an empty hash value of all zeros. Finally, the hash values of the higher levels in the tree are calculated, by concatenating the hash values of the two children (again left to right) and computing the hash of that aggregate. If the two children are empty hashes, the parent is an empty all-zeros hash as well (to save computation). This process ends in a hash value for the root node, which is called the &#34;root hash&#34;. Note the root hash only depends on the content and any modification of the content will result in a different root hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにN個のチャンクに分割されているコンテンツファイルのマークル・ハッシュ・ツリーが構築されます。固定サイズであるコンテンツのチャンクを想定していない建設に注意してください。暗号ハッシュ関数が与えられ、より具体的には、SHA-256のようなMDC [HAC01]は、コンテンツの全てのチャンクのハッシュが計算されます。次に、十分な高さのバイナリツリーが作成されます。十分な高さは、ツリー内の最下位レベルは、ビンの番号と同じように、セット内のすべてのチャンクのハッシュを保持するのに十分なノードを有することを意味します。以下の図は7つのチャンクからなるコンテンツファイルのツリーを示しています。アドレッシング方式のコンテンツと同様に、ツリーの葉はチャンクに対応し、この場合には、左端の葉から始まる、そのチャンクのハッシュが割り当てられます。ツリーのベースはチャンクの数よりも広くてもよいように、ツリー内の任意の残りの葉をすべてゼロの空のハッシュ値が割り当てられます。最後に、ツリー内のより高いレベルのハッシュ値は、二人の子供のハッシュ値を連結することによって（再び左から右へ）、その集合体のハッシュを計算し、計算されます。 2人の子供が空のハッシュであれば、親はすべてゼロが（計算を節約するために）だけでなくハッシュ空です。このプロセスは、「ルートハッシュ」と呼ばれるルート・ノードのハッシュ値で終わります。なお、ルートハッシュは、コンテンツのみに依存し、コンテンツの任意の変更は、異なるルートハッシュになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                               7 = root hash
                              / \
                            /     \
                          /         \
                        /             \
                      3*               11
                     / \              / \
                    /   \            /   \
                   /     \          /     \
                  1       5        9       13* = uncle hash
                 / \     / \      / \      / \
                0   2   4   6    8   10* 12   14
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
C0 C1 C2 C3 C4 C5 C6 E =chunk index ^^ = empty hash
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
C0 C1 C2 C3 C4 C5 C6 E =チャンクインデックス^^ =空ハッシュ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Merkle hash tree of a content file with N=7 chunks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
N = 7つのチャンクとコンテンツファイルのマークルハッシュ木
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Content Integrity Verification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。コンテンツの整合性の検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming a peer receives the root hash of the content it wants to download from a trusted source, it can check the integrity of any chunk of that content it receives as follows. It first calculates the hash of the chunk it received, for example, chunk C4 in the previous figure. Along with this chunk, it MUST receive the hashes required to check the integrity of that chunk. In principle, these are the hash of the chunk&#39;s sibling (C5) and that of its &#34;uncles&#34;. A chunk&#39;s uncles are the sibling Y of its parent X, and the uncle of that Y, recursively until the root is reached. For chunk C4, the uncles are nodes 13 and 3 and the sibling is 10; all marked with a * in the figure. Using this information, the peer recalculates the root hash of the tree and compares it to the root hash it received from the trusted source. If they match, the chunk of content has been positively verified to be the requested part of the content. Otherwise, the sending peer sent either the wrong content or the wrong sibling or uncle hashes. For simplicity, the set of sibling and uncle hashes is collectively referred to as the &#34;uncle hashes&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアと仮定すると、それが信頼できるソースからダウンロードしたいコンテンツのルートハッシュを受け取り、それは次のように、それが受信するコンテンツのいずれかのチャンクの整合性をチェックすることができます。これは、最初の前の図では、例えば、受信されたチャンクのハッシュ、チャンクC4を算出します。このチャンクとともに、そのチャンクの整合性をチェックするために必要なハッシュを受けなければなりません。原則として、これらは、チャンクの兄弟（C5）のハッシュとその「叔父」のことです。チャンクの叔父は、ルートに到達するまで再帰的に、兄弟、親のXのY、及びそのYの叔父です。チャンクC4ため、叔父は、ノード13 3であり、兄弟は10です。すべての図中の*印。この情報を使用して、ピアは、ツリーのルートハッシュを再計算し、それが信頼できるソースから受信したルートハッシュと比較します。それらが一致した場合、コンテンツのチャンクは積極コンテンツの要求された一部であることが確認されています。それ以外の場合は、送信側ピアは、間違ったコンテンツや、間違った兄弟や叔父のハッシュのいずれかを送りました。簡単にするために、兄弟と叔父の組のハッシュを総称して「叔父ハッシュ」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of live streaming, the tree of chunks grows dynamically and the root hash is undefined or, more precisely, transient, as long as new data is generated by the live source. Section 6.1.2 defines a method for content integrity verification for live streams that works with such a dynamic tree. Although the tree is dynamic, content verification works the same for both live and predefined content, resulting in a unified method for both types of streaming.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ライブストリーミングの場合は、チャンクのツリーは動的に成長し、ルートハッシュは限り新しいデータがライブソースによって生成されるよう、未定義または、より正確には、一時的です。 6.1.2項では、このようなダイナミックなツリーで動作するライブストリームのコンテンツの完全性検証のための方法を定義します。ツリーは動的であるが、コンテンツの検証は、ストリーミングの両方のタイプのための統一された方法で、その結果、両方のライブとあらかじめ定義されたコンテンツについても同様に動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. The Atomic Datagram Principle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。アトミックデータグラムの原理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As explained above, a datagram consists of a sequence of messages. Ideally, every datagram sent must be independent of other datagrams: each datagram SHOULD be processed separately, and a loss of one datagram must not disrupt the flow of datagrams between two peers. Thus, as a datagram carries zero or more messages, both messages and message interdependencies SHOULD NOT span over multiple datagrams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以上説明したように、データグラムは、メッセージのシーケンスから成ります。理想的には、他のデータグラムの独立していなければならない送信されるすべてのデータグラム：各データグラムが別々に処理されるべきであり、1グラムの損失は、2つのピア間のデータグラムの流れを妨害してはなりません。データグラムがゼロまたはそれ以上のメッセージは、両方のメッセージおよびメッセージの相互依存を運ぶようにこのように、複数のデータグラムにわたって及ぶべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This principle implies that as any chunk is verified using its uncle hashes, the necessary hashes SHOULD be put into the same datagram as the chunk&#39;s data. If this is not possible because of a limitation on datagram size, the necessary hashes MUST be sent first in one or more datagrams. As a general rule, if some additional data is still missing to process a message within a datagram, the message SHOULD be dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この原則は、どのチャンクがその叔父のハッシュを使用して検証されるよう、必要なハッシュは、チャンクのデータと同じデータグラムに入れなければならないことを意味します。このため、データグラムサイズの制限のために可能ではない場合、必要なハッシュは、一の以上のデータグラムで最初に送信されなければなりません。いくつかの追加データがまだデータグラム内のメッセージを処理するために不足している場合は、原則として、メッセージは削除されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hashes necessary to verify a chunk are, in principle, its sibling&#39;s hash and all its uncle hashes, but the set of hashes to send can be optimized. Before sending a packet of data to the receiver, the sender inspects the receiver&#39;s previous acknowledgements (HAVE or ACK) to derive which hashes the receiver already has for sure. Suppose the receiver had acknowledged chunks C0 and C1 (the first two chunks of the file), then it must already have uncle hashes 5, 11, and so on. That is because those hashes are necessary to check C0 and C1 against the root hash. Then, hashes 3, 7, and so on must also be known as they are calculated in the process of checking the uncle hash chain. Hence, to send chunk C7, the sender needs to include just the hashes for nodes 14 and 9, which let the data be checked against hash 11, which is already known to the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクを検証するために必要なハッシュは、原則として、その兄弟のハッシュとそのすべての叔父のハッシュですが、送信するためにハッシュのセットを最適化することができます。受信機にデータのパケットを送信する前に、送信側は受信側がすでに確かに持っているハッシュた導出する（持っているか、またはACK）受信機の前の確認応答を検査します。ように、受信機はチャンクC0とC1（ファイルの最初の2つのチャンク）を認めていたが、それは既に叔父は5ハッシュ有していなければならないと仮定し11、および。これらのハッシュがルートハッシュに対してC0及びC1をチェックする必要があるためです。その後、3〜7をハッシュし、そしてそれらは叔父ハッシュチェーンをチェックする過程で算出されるようにも知られていなければなりません。したがって、チャンクC7を送信するために、送信者は、データが既に受信機に知られているハッシュ11、照合させノード14と9のためだけハッシュを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sender MAY optimistically skip hashes that were sent out in previous, still-unacknowledged datagrams. It is an optimization trade-off between redundant hash transmission and the possibility of collateral data loss in the case in which some necessary hashes were lost in the network so some delivered data cannot be verified and thus had to be dropped. In either case, the receiver builds the Merkle hash tree on-demand, incrementally, starting from the root hash, and uses it for data validation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は楽観以前、まだ未確認のデータグラムで送信されたハッシュをスキップすることができます。これは、冗長なハッシュ送信およびいくつかの必要なハッシュがそのように、いくつかの配信されたデータを検証し、従って廃棄されなければならなかったことはできないネットワークで失われた場合には担保データ損失の可能性との間の最適化のトレードオフです。いずれの場合においても、受信機は、ルートハッシュから出発して、増分、オンデマンドマークル・ハッシュ・ツリーを構築し、データ検証のためにそれを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In short, the sender MUST put into the datagram the hashes he believes are necessary for the receiver to verify the chunk. The receiver MUST remember all the hashes it needs to verify missing chunks that it still wants to download. Note that the latter implies that a hardware-limited receiver MAY forget some hashes if it does not plan to announce possession of these chunks to others (i.e., does not plan to send HAVE messages.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要するに、送信側は受信側がチャンクを検証するために、彼は信じているハッシュが必要なデータグラムに入れなければなりません。受信機は、それがまだダウンロードしたい欠けているチャンクを検証するために必要なすべてのハッシュを覚えておく必要があります。後者は、それが他の人にこれらのチャンクの所有権を発表する予定でない場合、ハードウェア限定受信機は、いくつかのハッシュを忘れるかもしれないことを意味ことに留意されたい（すなわち有するメッセージを送信する予定がありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. INTEGRITY Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。 INTEGRITYメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Concretely, a peer that wants to send a chunk of content creates a datagram that MUST consist of a list of INTEGRITY messages followed by a DATA message. If the INTEGRITY messages and DATA message cannot be put into a single datagram because of a limitation on datagram size, the INTEGRITY messages MUST be sent first in one or more datagrams. The list of INTEGRITY messages sent MUST contain an INTEGRITY message for each hash the receiver misses for integrity checking. An INTEGRITY message for a hash MUST contain the chunk specification corresponding to the node ID of the hash and the hash data itself. The chunk specification corresponding to a node ID is defined as the range of chunks formed by the leaves of the subtree rooted at the node. For example, node 3 in Figure 3 denotes chunks 0, 2, 4, and 6, so the chunk specification should denote that interval. The list of INTEGRITY messages MUST be sorted in order of the tree height of the nodes, descending (the leaves are at height 0). The DATA message MUST contain the chunk specification of the chunk and the chunk itself. A peer MAY send the required messages for multiple chunks in the same datagram, depending on the encapsulation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、コンテンツのチャンクを送信したいピアは、DATAメッセージに続いINTEGRITYメッセージのリストで構成されなければならないデータグラムを作成します。インテグリティ・メッセージおよびデータ・メッセージが原因で、データグラムのサイズに制限の単一のデータグラムに入れることができない場合、整合性メッセージは、一の以上のデータグラムで最初に送信されなければなりません。送信されたINTEGRITYメッセージのリストは、それぞれのINTEGRITYメッセージ完全性検査のための受信ミスをハッシュ含まなければなりません。ハッシュのための完全性メッセージは、ハッシュのノードID及びハッシュデータそのものに対応するチャンクの仕様を含まなければなりません。ノードIDに対応するチャンク仕様は、ノードをルートとするサブツリーの葉によって形成されたチャンクの範囲として定義されます。例えば、図3のノード3がチャンク0、2、4、および6を表し、従ってチャンク仕様は、その間隔を示すべきです。インテグリティ・メッセージのリストは、（葉が高さ0である）降順、ノードのツリーの高さの順にソートされなければなりません。 DATAメッセージは、チャンクとチャンク自体のチャンクの指定を含まなければなりません。ピアはカプセル化に応じて、同じデータグラムに複数のチャンクのために必要なメッセージを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Discussion and Overhead
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。ディスカッションやオーバーヘッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current method for protecting content integrity in BitTorrent [BITTORRENT] is not suited for streaming. It involves providing clients with the hashes of the content&#39;s chunks before the download commences by means of metadata files (called .torrent files in BitTorrent.) However, when chunks are small, as in the current UDP encapsulation of PPSPP, this implies having to download a large number of hashes before content download can begin. This, in turn, increases time-till-playback for end users, making this method unsuited for streaming.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【ビットトレント] BitTorrentのコンテンツの完全性を保護するための現在の方法は、ストリーミングには適していません。これは、ダウンロードは、メタデータファイルを用いて開始する前に（ビットトレントで.torrentファイルと呼ばれる。）コンテンツのチャンクのハッシュをクライアントに提供するしかし、チャンクが小さい場合、PPSPPの現在のUDPカプセル化のように、これはダウンロードした意味が含まコンテンツのダウンロードの前にハッシュの多数を開始することができます。これは、順番に、時間を-まで再生高め、エンドユーザーのために、ストリーミングのためのこの方法は不向き作ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The overhead of using Merkle hash trees is limited. The size of the hash tree expressed as the total number of nodes depends on the number of chunks the content is divided (and hence the size of chunks) following this formula:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークルハッシュ木を使用してのオーバーヘッドが限られています。ノードの総数がコンテンツを分割（ひいてはチャンクのサイズ）されているチャンクの数に依存するハッシュ木の大きさは、この式次表さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
nnodes = math.pow(2,math.log(nchunks,2)+1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
NNODES = math.pow（2、math.log（nchunks、2）+1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In principle, the hash values of all these nodes will have to be sent to a peer once for it to verify all of the chunks. Hence, the maximum on-the-wire overhead is hashsize * nnodes. However, the actual number of hashes transmitted can be optimized as described in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
原則的には、これらすべてのノードのハッシュ値は、チャンクのすべてを検証するために、一度ピアに送信する必要があります。したがって、最大オンワイヤオーバーヘッドはHASHSIZE * NNODESあります。セクション5.3で説明されているようしかし、送信されたハッシュの実際の数を最適化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To see a peer can verify all chunks whilst receiving not all hashes, consider the example tree in Section 5.1. In the case of a simple progressive download, of chunks 0, 2, 4, 6, etc., the sending peer will send the following hashes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがないすべてのハッシュを受けながら、すべてのチャンクを確認することができます表示するには、セクション5.1の例の木を考えます。チャンク0の単純なプログレッシブダウンロード、、2、4、6、等の場合には、送信ピアは、次のハッシュを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          +-------+---------------------------------------------+
          | Chunk | Node IDs of hashes sent                     |
          +-------+---------------------------------------------+
          |   0   | 2,5,11                                      |
          |   2   | - (receiver already knows all)              |
          |   4   | 6                                           |
          |   6   | -                                           |
          |   8   | 10,13 (hash 3 can be calculated from 0,2,5) |
          |   10  | -                                           |
          |   12  | 14                                          |
          |   14  | -                                           |
          | Total | # hashes        7                           |
          +-------+---------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Table 1: Overhead for the Example Tree
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
表1：例の木のためのオーバーヘッド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So the number of hashes sent in total (7) is less than the total number of hashes in the tree (16), as a peer does not need to send hashes that are calculated and verified as part of earlier chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが以前のチャンクの一部として計算され、検証されたハッシュを送信する必要がないように、合計で送信ハッシュの数は、（7）、ツリー内のハッシュの合計数（16）未満です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. Automatic Detection of Content Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6。コンテンツサイズの自動検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In PPSPP, the size of a static content file, such as a video file, can be reliably and automatically derived from information received from the network when fixed-size chunks are used. As a result, it is not necessary to include the size of the content file as the metadata of the content for such files. Implementations of PPSPP MAY use this automatic detection feature. Note this feature is the only feature of PPSPP that requires that a fixed-size chunk is used. This feature builds on the Merkle hash tree and the trusted root hash as swarm ID as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPでは、静的コンテンツファイルのサイズは、例えば、ビデオファイルとして、確実かつ自動的に固定サイズのチャンクが使用される場合、ネットワークから受信した情報から導き出すことができます。その結果、このようなファイルのコンテンツのメタデータとしてコンテンツファイルのサイズを含める必要はありません。 PPSPPの実装は、この自動検出機能を使用するかもしれません。この機能は、固定サイズのチャンクが使用されている必要がありますPPSPPの唯一の機能です。この機能は、マークルハッシュ木と、次のように群れのIDとして信頼されたルートハッシュに基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6.1. Peak Hashes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6.1。ピークハッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ability for a newcomer peer to detect the size of the content depends heavily on the concept of peak hashes. The concept of peak hashes depends on the concepts of filled and incomplete nodes. Recall that when constructing the binary trees for content verification and addressing the base of the tree may have more leaves than the number of chunks in the content. In the Merkle hash tree, these leaves were assigned empty all-zero hashes to be able to calculate the higher-level hashes. A filled node is now defined as a node that corresponds to an interval of leaves that consists only of hashes of content chunks, not empty hashes. Reversely, an incomplete (not filled) node corresponds to an interval that also contains empty hashes, typically, an interval that extends past the end of the file. In the following figure, nodes 7, 11, 13, and 14 are incomplete: the rest is filled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツの大きさを検出するために、新人ピアの能力はピークハッシュの概念に大きく依存しています。ピークハッシュの概念が充填され、不完全なノードの概念に依存します。コンテンツ検証用のバイナリツリーを構築し、ツリーのベースに対処するときは、コンテンツ内のチャンクの数よりも多くの葉を有することができることを思い出してください。マークル・ハッシュ・ツリーでは、これらの葉は全てゼロハッシュがより高いレベルのハッシュを計算することができるように空に割り当てました。充填されたノードについてのみコンテンツチャンクはなく、空のハッシュのハッシュで構成された葉の間隔に対応するノードとして定義されます。逆に、不完全な（充填されていない）ノードはまた、典型的には、空のハッシュが含まれている区間、ファイルの終端を越えて延在する間隔に相当します。以下の図では、ノード7、11、13、及び14は不完全で：残りは充填されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Formally, a peak hash is the hash of a filled node in the Merkle hash tree, whose sibling is an incomplete node. Practically, suppose a file is 7162 bytes long and a chunk is 1 kilobyte. That file fits into 7 chunks, the tail chunk being 1018 bytes long. The Merkle hash tree for that file is shown in Figure 4. Following the definition, the peak hashes of this file are in nodes 3, 9, and 12, denoted with an *. E denotes an empty hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正式に、ピークハッシュは兄弟不完全ノードであるマークル・ハッシュ・ツリー、充填ノードのハッシュです。実際には、ファイルが7162バイトの長さで、チャンクが1キロバイトであると仮定します。このファイルには、尾のチャンクが長い1018バイトであること、7つのチャンクに収まります。そのファイルのマークル・ハッシュ・ツリーは、定義に続いて、図4に示され、このファイルのピークハッシュは、ノード3,9にあり、12、*で示します。 Eは、空のハッシュを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                  7
                                 / \
                               /     \
                             /         \
                           /             \
                         3*               11
                        / \              / \
                       /   \            /   \
                      /     \          /     \
                     1       5        9*      13
                    / \     / \      / \      / \
                   0   2   4   6    8   10  12*  14
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
C0 C1 C2 C3 C4 C5 C6 E = 1018 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
C0 C1 C2 C3 C4 C5 C6 E = 1018のバイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Peak hashes in a Merkle hash tree
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
マークルハッシュ木のピークハッシュ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peak hashes can be explained by the binary representation of the number of chunks the file occupies. The binary representation for 7 is 111. Every &#34;1&#34; in binary representation of the file&#39;s packet length corresponds to a peak hash. For this particular file, there are indeed three peaks: nodes 3, 9, and 12. Therefore, the number of peak hashes for a file is also, at most, logarithmic with its size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピークハッシュファイルが占有するチャンクの数のバイナリ表現によって説明することができます。 7用のバイナリ表現は、ファイルのパケット長がピークハッシュに対応のバイナリ表現に111すべて「1」です。その大きさの対数ノード3,9、および12は、したがって、ファイルのピークハッシュの数は最大でもあり、この特定のファイルのために、実際に三つのピークがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer knowing which nodes contain the peak hashes for the file can therefore calculate the number of chunks it consists of; thus, it gets an estimate of the file size (given all chunks but the last are of a fixed size). Which nodes are the peaks can be securely communicated from one (untrusted) peer, Peer A, to another peer, Peer B, by letting Peer A send the peak hashes and their node IDs to Peer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、したがって、それはから成るチャンクの数を計算することができるファイルの最大ハッシュを含む知るピア。したがって、それはファイルサイズ（すべての与えられたチャンクが、固定サイズの最後アール）の推定値を取得します。どのノードピークが確実ピアAがピアするピークのハッシュとそのノードIDを送信させることにより、一方（信頼できない）ピア、ピアA、他のピアに、ピアBから伝達することができるされています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B. It can be shown that the root hash that Peer B obtained from a trusted source is sufficient to verify that these are indeed the right peak hashes, as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B. Bが信頼できるソースから得られたピアルートハッシュは以下のように、これらは、実際に右ピークハッシュであることを確認するのに十分であることを示すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lemma: Peak hashes can be checked against the root hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
補題：ピークハッシュは、ルートハッシュと照合することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Proof: (a) Any peak hash is always the left sibling. Otherwise, if it is the right sibling, its left neighbor/sibling must also be a filled node, because of the way chunks are laid out in the leaves, which contradicts the definition of a peak hash. (b) For the rightmost peak hash, its right sibling is zero. (c) For any peak hash, the right sibling might be calculated using peak hashes to the left and zeros for empty nodes. (d) Once the right sibling of the leftmost peak hash is calculated, its parent might be calculated. (e) Once that parent is calculated, we might trivially get to the root hash by concatenating the hash with zeros and hashing it repeatedly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明：（a）は、任意のピークハッシュは常に左の兄弟です。それは右の兄弟であればそうでない場合は、その左隣/兄弟もあるため、ピークハッシュの定義に矛盾するチャンクは葉にレイアウトされている方法、の、満たされたノードでなければなりません。 （b）の右端のピークハッシュの場合、その右の兄弟はゼロです。 （C）任意ピークハッシュの場合、右の兄弟は空ノードに対する左およびゼロにピークハッシュを使用して計算されるかもしれません。左端のピークハッシュの右兄弟が計算されると（d）に、その親が計算されることがあります。その親が計算されると（e）に、我々は自明ゼロでハッシュを連結し、それを繰り返しハッシュすることによって、ルートハッシュを得る可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Informally, the Lemma might be expressed as follows: peak hashes cover all data, so the remaining hashes are either trivial (zeros) or might be calculated from peak hashes and zero hashes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りのハッシュは些細な（ゼロ）のいずれかであるか、またはピークハッシュゼロハッシュから計算されるかもしれないので、ピークハッシュは、すべてのデータをカバーする：非公式、補題は、次のように表現されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, once Peer B has obtained the number of chunks in the content, it can determine the exact file size as follows. Given that all chunks except the last are of a fixed size, Peer B just needs to know the size of the last chunk. Knowing the number of chunks, Peer B can calculate the node ID of the last chunk and download it. As always, Peer B verifies the integrity of this chunk against the trusted root hash. As there is only one chunk of data that leads to a successful verification, the size of this chunk must be correct. Peer B can then determine the exact file size as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアBは、コンテンツ内のチャンクの数を取得した後、次のように最後に、それが正確なファイルサイズを決定することができます。最後を除くすべてのチャンクが固定サイズのものであることを考えると、ピアBは、ちょうど最後のチャンクの大きさを知る必要があります。チャンクの数を知ることは、ピアBは、最後のチャンクのノードIDを計算し、それをダウンロードすることができます。いつものように、ピアBは、信頼されたルートハッシュに対してこのチャンクの整合性を検証します。検証が成功につながるデータの唯一の1つのチャンクがあるように、このチャンクのサイズが正しくなければなりません。ピアBは、次にように正確なファイルサイズを決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(number of chunks -1) * fixed chunk size + size of last chunk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
最後のチャンクの（チャンクの数-1）*固定チャンクサイズ+サイズ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6.2. Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6.2。手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PPSPP implementation that wants to use automatic size detection MUST operate as follows. When Peer A sends a DATA message for the first time to Peer B, Peer A MUST first send all the peak hashes for the content, in INTEGRITY messages, unless Peer B has already signaled that it knows the peak hashes by having acknowledged any chunk. If they are needed, the peak hashes MUST be sent as an extra list of uncle hashes for the chunk, before the list of actual uncle hashes of the chunk as described in Section 5.3. The receiver, Peer B, MUST check the peak hashes against the root hash to determine the approximate content size. To obtain the definite content size, Peer B MUST download the last chunk of the content from any peer that offers it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように自動サイズ検出を使用したいPPSPPの実装が作動しなければなりません。ピアAがBをピアツーピア初めてDATAメッセージを送信すると、ピアBはすでにそれがどのチャンクを認めたことにより、ピークハッシュを知っていることを合図していない限り、まず、INTEGRITYメッセージに、コンテンツのすべてのピークのハッシュを送らなければなりませんピア。彼らが必要な場合は、セクション5.3で説明したように、ピークハッシュはチャンクの実際の叔父のハッシュのリストの前に、チャンクの叔父ハッシュの余分なリストとして送らなければなりません。受信機、ピアBは、おおよそのコンテンツのサイズを決定するためにルートハッシュに対するピークのハッシュをチェックしなければなりません。明確なコンテンツのサイズを取得するには、ピアBは、それを提供しています任意のピアからのコンテンツの最後のチャンクをダウンロードする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, let&#39;s consider a 7162-byte file, which fits in 7 chunks of 1 kilobyte, distributed by Peer A. Figure 4 shows the relevant Merkle hash tree. Peer B, which only knows the root hash of the file after successfully connecting to Peer A, requests the first chunk of data, C0 in Figure 4. Peer A replies to Peer B by including in the datagram the following messages in this specific order: first, the three peak hashes of this particular file, the hashes of nodes 3, 9, and 12; second, the uncle hashes of C0, followed by the DATA message containing the actual content of C0. Upon receiving the peak hashes, Peer B checks them against the root hash determining that the file is 7 chunks long. To establish the exact size of the file, Peer B needs to request and retrieve the last chunk containing data, C6 in Figure 4. Once the last chunk has been retrieved and verified, Peer B concludes that it is 1018 bytes long, hence determining that the file is exactly 7162 bytes long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例として、ピアA.図4によって分配1キロバイトの7つのチャンクに収まる7162バイトのファイルは、関連するマークル・ハッシュ・ツリーを示す考えます。唯一成功したピアに接続した後、ファイルのルートハッシュを知っているピアBは、データの最初のチャンクを要求し、C0は、図4にピアAは、この特定の順序で次のメッセージのデータグラムに含めることにより、Bピアへの返信：第三のピークこの特定のファイルのハッシュ、ノード3,9のハッシュ、および12。第二、C0の叔父ハッシュ、C0の実際の内容を含むデータメッセージが続きます。ピークハッシュを受信すると、ピアBは、ファイルが7つのチャンクの長さであると判断し、ルートハッシュに対してそれらをチェックします。ファイルの正確なサイズを確立するために、ピアBが要求したデータを含む最後のチャンクを取得する必要があり、図4のC6が最後のチャンクが取得され、検証された後、ピアBは、それが故にと判断し、1018バイトの長さであると結論しますファイルには、正確に7162バイト長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Live Streaming
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.ライブストリーミング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of messages defined above can be used for live streaming as well. In a pull-based model, a live streaming injector can announce the chunks it generates via HAVE messages, and peers can retrieve them via REQUEST messages. Areas that need special attention are content authentication and chunk addressing (to achieve an infinite stream of chunks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記で定義されたメッセージのセットは、同様にライブストリーミングのために使用することができます。プル型モデルでは、ライブストリーミングインジェクタは、それが持つメッセージを介して生成チャンクを発表することができ、ピアはREQUESTメッセージを介してそれらを取得することができます。特別な注意が必要なエリアは、（チャンクの無限ストリームを達成するために）コンテンツの認証とチャンクのアドレス指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Content Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。コンテンツ認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For live streaming, PPSPP supports two methods for a peer to authenticate the content it receives from another peer, called &#34;Sign All&#34; and &#34;Unified Merkle Tree&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ライブストリーミングの場合、PPSPPは、それが「すべての署名」と「統一マークル木」と呼ばれる別のピアから受信したコンテンツを認証するピアの2つのメソッドをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the &#34;Sign All&#34; method, the live injector signs each chunk of content using a private key. Upon receiving the chunk, peers check the signature using the corresponding public key obtained from a trusted source. Support for this method is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「すべての署名」の方法では、ライブインジェクタは秘密鍵を使用して、コンテンツの各チャンクに署名します。チャンクを受信すると、ピアが信頼できるソースから取得した対応する公開鍵を用いて署名を確認してください。このメソッドのサポートはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the &#34;Unified Merkle Tree&#34; method, PPSPP combines the Merkle Hash Tree scheme for static content with signatures to unify the video-on-demand and live streaming scenarios. The use of Merkle hash trees reduces the number of signing and verification operations, hence providing a similar signature amortization to the approach described in [SIGMCAST]. If PPSPP operates over the Internet, the &#34;Unified Merkle Tree&#34; method MUST be used. If the protocol operates in a benign environment, the &#34;Unified Merkle Tree&#34; method MAY be used. So this method is mandatory to implement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「統合マークル木」の方法では、PPSPPは、ビデオオンデマンドおよびライブストリーミングのシナリオを統一するシグネチャを持つ静的コンテンツのマークルハッシュツリースキームを兼ね備えています。マークルハッシュ木の使用は、したがって[SIGMCAST]に記載の手法と同様署名償却を提供し、署名と検証動作の数を減少させます。 PPSPPは、インターネット上で動作している場合は、「ユニファイドマークル木」の方法を使用しなければなりません。プロトコルは良性の環境で動作する場合、「ユニファイドマークル木」の方法を用いることができます。したがって、この方法は、実装が必須です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In both methods, the swarm ID consists of a public key encoded as in a DNSSEC DNSKEY resource record without Base64 encoding [RFC4034].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方の方法において、群れのIDは、Base64エンコード[RFC4034]せずDNSSECのDNSKEYリソースレコードのように符号化された公開鍵で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular, the swarm ID consists of a 1-byte Algorithm field that identifies the public key&#39;s cryptographic algorithm and determines the format of the Public Key field that follows. The value of this Algorithm field is one of the values in the &#34;Domain Name System Security (DNSSEC) Algorithm Numbers&#34; registry [IANADNSSECALGNUM]. The RSASHA1 [RFC4034], RSASHA256 [RFC5702], ECDSAP256SHA256 and ECDSAP384SHA384 [RFC6605] algorithms are mandatory to implement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、群れのIDは、公開鍵の暗号化アルゴリズムを識別し、次の公開鍵フィールドのフォーマットを決定し、1バイトAlgorithmフィールドで構成されています。このアルゴリズムフィールドの値は、「ドメインネームシステムセキュリティ（DNSSEC）アルゴリズム番号」レジストリ[IANADNSSECALGNUM]内の値の一つです。 RSASHA1 [RFC4034]、RSASHA256 [RFC5702]、ECDSAP256SHA256とECDSAP384SHA384 [RFC6605]アルゴリズムを実装するために必須です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Algo Number(8)|                                               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                DNSSEC Public Key (variable)                   ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. Sign All
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1。すべてのサイン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the &#34;Sign All&#34; method, the live injector signs each chunk of content using a private key and peers, upon receiving the chunk, check the signature using the corresponding public key obtained from a trusted source. In particular, in PPSPP, the swarm ID of the live stream is that public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「すべての署名」の方法では、ライブインジェクタ兆候はチャンクを受信すると、秘密鍵とピアを使用してコンテンツの各チャンクは、信頼できるソースから入手した対応する公開鍵を使って署名を確認してください。特に、PPSPPで、ライブストリームの群れのIDは、その公開鍵です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer that wants to send a chunk of content creates a datagram that MUST contain a SIGNED_INTEGRITY message with the chunk&#39;s signature, followed by a DATA message with the actual chunk. If the SIGNED_INTEGRITY message and DATA message cannot be contained into a single datagram, because of a limitation on datagram size, the SIGNED_INTEGRITY message MUST be sent first in a separate datagram. The SIGNED_INTEGRITY message consists of the chunk specification, the timestamp, and the digital signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツのチャンクを送信したいピアは、実際のチャンクでデータメッセージが続くチャンクの署名付きSIGNED_INTEGRITYメッセージを含まなければならないデータグラムを作成します。 SIGNED_INTEGRITYメッセージおよびデータメッセージがあるため、データグラムのサイズの制限のため、単一のデータグラムに含まれることができない場合、SIGNED_INTEGRITYメッセージが別のデータグラムで最初に送信されなければなりません。 SIGNED_INTEGRITYメッセージは、チャンク仕様、タイムスタンプ、デジタル署名から成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The digital signature algorithm that is used, is determined by the Live Signature Algorithm protocol option, see Section 7.7. The signature is computed over a concatenation of the on-the-wire representation of the chunk specification, a 64-bit timestamp in NTP Timestamp format [RFC5905], and the chunk, in that order. The timestamp is the time signature that was made at the injector in UTC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用されるデジタル署名アルゴリズムは、セクション7.7を参照して、ライブ署名アルゴリズム・プロトコル・オプションによって決定されます。署名は、そのために、チャンク仕様のオン・ワイヤー表現、NTPタイムスタンプ形式の64ビットのタイムスタンプ[RFC5905]、およびチャンクの連結にわたって計算されます。タイムスタンプはUTCにインジェクターで行われた拍子です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. Unified Merkle Tree
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2。ユニファイドマークル木
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this method, the chunks of content are used as the basis for a Merkle hash tree as for static content. However, because chunks are continuously generated, this tree is not static, but dynamic. As a result, the tree does not have a root hash, or, more precisely, it has a transient root hash. Therefore, a public key serves as swarm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方法では、コンテンツのチャンクは、静的コンテンツ用としてマークル・ハッシュ・ツリーのための基礎として使用されます。チャンクが連続的に発生しているのでしかし、この木は、静的な、しかし動的ではありません。その結果、ツリーはより正確に、ルートハッシュを持っていないか、または、それは一時ルートハッシュを持っています。したがって、公開鍵は群れとして機能します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID of the content. It is used to digitally sign updates to the tree allowing peers to expand it based on trusted information using the following process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツのID。デジタルでのピアには、以下のプロセスを使用して、信頼できる情報をもとに、それを展開することが可能ツリーへの更新を署名するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2.1. Signed Munro Hashes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2.1。署名付きマンローハッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The live injector generates a number of chunks, denoted NCHUNKS_PER_SIG, corresponding to fixed power of 2 (NCHUNKS_PER_SIG&gt;=2), which are added as new leaves to the existing hash tree. As a result of this expansion, the hash tree contains a new subtree that is NCHUNKS_PER_SIG chunks wide at the base. The root of this new subtree is referred to as the munro of that subtree, and its hash as the munro hash of the subtree, illustrated in Figure 5. In this figure, node 5 is the new munro, labeled with a $ sign.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ライブインジェクタはチャンクの数を生成し、既存のハッシュツリーに新たなリーフとして追加される2（NCHUNKS_PER_SIG&gt; = 2）の固定された電源に対応する、NCHUNKS_PER_SIGで示さ。この拡張の結果、ハッシュツリーをベースに幅広いNCHUNKS_PER_SIGチャンクで新しいサブツリーが含まれています。この新しいサブツリーのルートがそのサブツリーのマンローと呼ばれ、サブツリーのMunroのハッシュとしてそのハッシュ、この図では図5に図示され、ノード5は、$記号で標識された新しいマンロー、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                     3
                                    / \
                                   /   \
                                  /     \
                                 1       5$
                                / \     / \
                               0   2   4   6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Expanded live tree. With NCHUNKS_PER_SIG=2, node 5 is the munro for the new subtree spanning 4 and 6. Node 1 is the munro for the subtree spanning chunks 0 and 2, created in the previous iteration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張ライブツリー。 NCHUNKS_PER_SIG = 2で、ノード5は4,6ノード1にまたがる新しいサブツリーのマンローは、前の反復で作成チャンク0及び2にまたがるサブツリー用マンローです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Informally, the process now proceeds as follows. The injector signs only the munro hash of the new subtree using its private key. Next, the injector announces the existence of the new subtree to its peers using HAVE messages. When a peer, in response to the HAVE messages, requests a chunk from the new subtree, the injector first sends the signed munro hash corresponding to the requested chunk. Afterwards, similar to static content, the injector sends the uncle hashes necessary to verify that chunk, as in Section 5.1. In particular, the injector sends the uncle hashes necessary to verify the requested chunk against the munro hash. This differs from static content, where the verification takes places against the root hash. Finally, the injector sends the actual chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように非公式に、プロセスが進行します。インジェクタの兆しその秘密鍵を使用して新しいサブツリーの唯一のマンローハッシュ。次に、インジェクタはHAVEメッセージを使用して、そのピアに新しいサブツリーの存在を発表しました。ピアは、HAVEメッセージに応じて、新しいサブツリーからチャンクを要求すると、インジェクタは最初に要求されたチャンクに対応する署名マンローハッシュを送信します。その後、静的コンテンツと同様、インジェクタは第5.1節と同様に、叔父は、そのチャンクを確認する必要ハッシュ送ります。具体的には、インジェクタは、叔父がマンローハッシュに対して要求されたチャンクを検証するために必要なハッシュを送信します。これは、検証は、ルートハッシュに対して場所を取る静的コンテンツとは異なります。最後に、注射器は、実際のチャンクを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiving peer verifies the signature on the signed munro using the swarm ID (a public key) and updates its hash tree. As the peer now knows the munro hash is trusted, it can verify all chunks in the subtree against this munro hash, using the accompanying uncle hashes as in Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信ピアは、群れのID（公開鍵）を使用して署名マンローの署名を検証し、そのハッシュツリーを更新します。ピアは今マンローハッシュが信頼されている知っているので、それは、添付の叔父は、5.1節のようにハッシュ使用して、このマンローハッシュに対するサブツリー内のすべてのチャンクを確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To illustrate this procedure, lets consider the next iteration in the process. The injector has generated the current tree shown in Figure 5, and it is connected to several peers that currently have the same tree and all posses chunks 0, 2, 4, and 6. When the injector generates two new chunks, NCHUNKS_PER_SIG=2, the hash tree expands as shown in Figure 6. The two new chunks, 8 and 10, extend the tree on the right side, and to accommodate them, a new root is created: node 7. As this tree is wider at the base than the actual number of chunks, there are currently two empty leaves. The munro node for the new subtree is 9, labeled with a $ sign.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この手順を説明するために、プロセスの次の反復を考えることができます。インジェクタは、図5に示す電流ツリーを生成し、それは、インジェクタは、2つの新しいチャンク、NCHUNKS_PER_SIG = 2を生成すると、現在同じツリーと全てPOSSESチャンク0、2、4、および6を有するいくつかのピアに接続されています。ハッシュツリーは、2つの新しいチャンク、8及び10は、右側のツリーを拡張する図6に示すように膨張し、それらを収容するために、新しいルートが作成されますノード7このツリーは、より基部に広いようチャンクの実際の数は、現在、2枚の空の葉があります。新しいサブツリーのマンローノードは、$記号で標識し、9です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                     7
                                    / \
                                  /     \
                                /         \
                              /             \
                            3               11
                           / \              / \
                          /   \            /   \
                         /     \          /     \
                        1       5        9$      13
                       / \     / \      / \      / \
                      0   2   4   6    8   10   E   E
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Expanded live tree. With NCHUNKS_PER_SIG=2, node 9 is the munro of the newly added subtree spanning chunks 8 and 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
拡張ライブツリー。 = 2 NCHUNKS_PER_SIGと、ノード9はチャンク8及び10にまたがる新たに追加されたサブツリーのマンローあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The injector now needs to inform its peers of the updated tree, communicating the addition of the new munro hash 9. Hence, it sends a HAVE message with a chunk specification for nodes 8 + 10 to its peers. As a response, Peer P requests the newly created chunk, e.g., chunk 8, from the injector by sending a REQUEST message. In reply, the injector sends the signed munro hash of node 9 as an INTEGRITY message with the hash of node 9, and a SIGNED_INTEGRITY message with the signature of the hash of node 9. These messages are followed by an INTEGRITY message with the hash of node 10 and a DATA message with chunk 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インジェクタは、今ではそのピアに+ 10節8のためのチャンク仕様にHAVEメッセージを送信し、そこで新しいマンローハッシュ9の追加を伝える、更新木のそのピアに通知する必要があります。応答として、ピアPは、要求メッセージを送信することにより、インジェクタから、例えば、チャンク8を新しく作成されたチャンクを要求します。応答では、インジェクタは、ハッシュとインテグリティ・メッセージが続いているノード9のハッシュとINTEGRITYメッセージ、およびノー​​ド9これらのメッセージのハッシュの署名付きSIGNED_INTEGRITYメッセージとしてノード9の署名されたMunroのハッシュを送信しますノード10およびチャンク8との間でデータメッセージ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receipt, Peer P verifies the signature of the munro and expands its view of the tree. Next, the peer computes the hash of chunk 8 and combines it with the received hash of node 10, computing the expected hash of node 9. He can then verify the content of chunk 8 by comparing the computed hash of node 9 with the munro hash of the same node he just received; hence, Peer P has successfully verified the integrity of chunk 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信すると、ピアPはマンローの署名を検証し、ツリーのそのビューを拡張します。次彼は次にMunroのハッシュとノード9の計算されたハッシュを比較することにより、チャンク8の内容を確認することができ、ピアはチャンク8のハッシュを計算し、ノード9の期待ハッシュを計算し、ノード10の受信したハッシュと合成します彼はちょうど受け取った同じノードの。したがって、ピアPが正常にチャンク8の整合性を検証しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This procedure requires just one signing operation for every NCHUNKS_PER_SIG chunks created, and one verification operation for every NCHUNKS_PER_SIG received, making it much cheaper than &#34;Sign All&#34;. A receiving peer does additionally need to check one or more hashes per chunk via the Merkle Hash Tree scheme, but this has less hardware requirements than a signature verification for every chunk. This approach is similar to signature amortization via Merkle Tree Chaining [SIGMCAST]. The downside of this scheme is in an increased latency. A peer cannot download the new chunks until the injector has computed the signature and announced the subtree. A peer MUST check the signature before forwarding the chunks to other peers [POLLIVE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この手順では、作成したすべてのNCHUNKS_PER_SIGチャンクのためのちょうど1署名操作を必要とし、すべてのNCHUNKS_PER_SIGのための1つの検証作業は、「すべてのサイン」よりも、それははるかに安くなって、受け取りました。受信ピアはさらに、マークル・ハッシュ木方式を介してチャンク当たり一つ以上のハッシュをチェックする必要がないが、これはすべてのチャンクの署名検証より少ないハードウェア要件を有しています。このアプローチは、マークル木チェーン[SIGMCAST]を介して署名償却と同様です。この方式の欠点は、待ち時間の増加です。インジェクタは、署名を計算し、サブツリーを発表するまで、ピアは新しいチャンクをダウンロードすることはできません。ピアは他のピア[POLLIVE]にチャンクを転送する前に、署名をチェックしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The number of chunks per signature NCHUNKS_PER_SIG MUST be a fixed power of 2 for simplicity. NCHUNKS_PER_SIG MUST be larger than 1 for performance reasons. There are two related factors to consider when choosing a value for NCHUNKS_PER_SIG. First, the allowed CPU load on clients due to signature verifications, given the expected bitrate of the stream. To achieve a low CPU load in a high bitrate stream, NCHUNKS_PER_SIG should be high. Second, the effect on latency, which increases when NCHUNKS_PER_SIG gets higher, as just discussed. Note how the procedure does not preclude the use of variable-size chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名NCHUNKS_PER_SIG当たりのチャンクの数は簡単のため2の固定累乗でなければなりません。 NCHUNKS_PER_SIGは、パフォーマンス上の理由から、1より大きくなければなりません。 NCHUNKS_PER_SIGの値を選択する際に考慮すべき二つの関連要因があります。まず、署名検証のために、クライアント上許容されるCPUの負荷は、ストリームの予期されるビットレートを与えられました。高ビットレートストリームで低CPU負荷を実現するために、NCHUNKS_PER_SIGが高くなければなりません。第NCHUNKS_PER_SIGがちょうど議論したように、高くなったときに増加する待ち時間に、効果は、。手順は、可変サイズのチャンクの使用を排除するものではありませんどのように注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This method of integrity verification provides an additional benefit. If the system includes some peers that saved the complete broadcast, as soon as the broadcast ends, the content is available as a video-on-demand download using the now stabilized tree and the final root hash as swarm identifier. Peers that saved all the chunks, can now announce the root hash to the tracking infrastructure and instantly seed the content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インテグリティ検証するこの方法は、付加的な利点を提供します。システムは、すぐに放送が終了すると、完全な放送を保存したいくつかのピアが含まれている場合、コンテンツは現在、安定したツリーと群れの識別子として、最終的なルートハッシュを使用してビデオ・オン・デマンドでダウンロードできます。すべてのチャンクを保存したピアは、今の追跡インフラストラクチャにルートハッシュを発表し、瞬時にコンテンツをシードすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2.2. Munro Signature Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2.2。マンローの署名計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The digital signature algorithm used is determined by the Live Signature Algorithm protocol option, see Section 7.7. The signature is computed over a concatenation of the on-the-wire representation of the chunk specification of the munro node (see Section 6.1.2.1), a timestamp in 64-bit NTP Timestamp format [RFC5905], and the hash associated with the munro node, in that order. The timestamp is the time signature that was made at the injector in UTC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用されるデジタル署名アルゴリズムは、セクション7.7を参照して、ライブ署名アルゴリズム・プロトコル・オプションによって決定されます。署名はマンローノードのチャンク仕様のオン・ワイヤー表現（セクション6.1.2.1を参照）、64ビットのNTPタイムスタンプ形式でタイムスタンプ[RFC5905]、および関連付けられたハッシュの連結にわたって計算されますそのためにマンローノード、。タイムスタンプはUTCにインジェクターで行われた拍子です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2.3. Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2.3。手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Formally, the injector MUST NOT send a HAVE message for chunks in the new subtree until it has computed the signed munro hash for that subtree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはそのサブツリーのために署名したマンローハッシュを計算するまで正式には、インジェクタは新しいサブツリー内のチャンクを持っているメッセージを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When Peer B requests a chunk C from Peer A (either the injector or another peer), and Peer A decides to reply, it must do so as follows. First, Peer A MUST send an INTEGRITY message with the chunk specification for the munro of chunk C and the munro&#39;s hash, followed by a SIGNED_INTEGRITY message with the chunk specification for the munro, timestamp, and its signature in a single datagram, unless Peer B indicated earlier in the exchange that it already possess a chunk with the same corresponding munro (by means of HAVE or ACK messages). Following these two messages (if any), Peer A MUST send the necessary missing uncles hashes needed for verifying the chunk against its munro hash, and the chunk itself, as described in Section 5.4, sharing datagrams if possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアBは、ピアAからチャンクC（注射器または他のピアのいずれか）を要求し、ピアAに返信することを決定する場合、以下のように、それはそうしなければなりません。まず、ピアAは、ピアBがない限り、マンロー、タイムスタンプ、および単一のデータグラムにおけるその署名のためのチャンク仕様SIGNED_INTEGRITYメッセージに続くチャンクCのマンローとマンローのハッシュのためのチャンク仕様と整合性メッセージを送信しなければなりません以前既に有する（又はACKメッセージを用いて）同じ対応マンローとチャンクを有する交換に示します。 5.4節で説明したように、これらの2つのメッセージ（もしあれば）に続いて、ピアAは、可能な場合はデータグラムを共有し、そのマンローハッシュに対するチャンクとチャンク自体を検証するために必要な必要な不足している叔父のハッシュを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2.4. Secure Tune In
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2.4。チューンでセキュア
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer tunes in to a live stream, it has to determine what is the last chunk the injector has generated. To facilitate this process in the Unified Merkle Tree scheme, each peer shares its knowledge about the injector&#39;s chunks with the others by exchanging their latest signed munro hashes, as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがライブストリームに同調したとき、それは注射器が生成した最後のチャンクであるかを判断する必要があります。次のように統一マークルツリー方式で、このプロセスを容易にするために、各ピアは、彼らの最新の署名マンローハッシュを交換することによって、他の人とインジェクタのチャンクについての知識を共有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recall that, in PPSPP, when Peer A initiates a channel with Peer B, Peer A sends a first datagram with a HANDSHAKE message, and Peer B responds with a second datagram also containing a HANDSHAKE message (see Section 3.1). When Peer A sends a third datagram to Peer B, and it is received by Peer B, both peers know that the other is listening on its stated transport address. Peer B is then allowed to send heavy payload like DATA messages in the fourth datagram. Peer A can already safely do that in the third datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアAは、ピアBとのチャネルを開始PPSPPにおいて、ピアAは、ハンドシェイクメッセージで最初のデータグラムを送信し、ピアBはまた、ハンドシェイクメッセージを含む第二のデータグラムで応答する、ことを思い出してください（セクション3.1を参照）。ピアAはBピア第3データグラムを送信し、それがピアBによって受信されると、両方のピアは、他方は、その記載されたトランスポートアドレスをリッスンしていることを知っています。ピアBは、その後、第四データグラム内のデータメッセージのような重いペイロードを送信することが許可されています。すでに安全に第三データグラムでそれを行うことができピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the Unified Merkle Tree scheme, Peer A MUST send its rightmost signed munro hash to Peer B in the third datagram, and in any subsequent datagrams to Peer B, until Peer B indicates that it possess a chunk with the same corresponding munro or a more recent munro (by means of a HAVE or ACK message). Peer B may already have indicated this fact by means of HAVE messages in the second datagram. Conversely, when Peer B sends the fourth datagram or any subsequent datagram to Peer A, Peer B MUST send its rightmost signed munro hash, unless Peer A indicated knowledge of it or more recent munros. The rightmost signed munro hash of a peer is defined as the munro hash signed by the injector of the rightmost subtree of width NCHUNKS_PER_SIG chunks in the peer&#39;s Merkle hash tree. Peer A MUST
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアBは、それが同じ対応するマンロー以上でチャンクを有することを示すまで統一マークル木方式で、ピアAは、Bピア第3グラムで、および任意の後続のデータグラムにBピアために、その右端の署名されたMunroのハッシュを送らなければなりません（持っているか、ACKメッセージによって）最近マンロー。ピアBは、既に第二のデータグラムを持っているメッセージによってこの事実を示していることができます。ピアBは、第四のデータグラムまたはピアする後続のデータグラムを送信するときに、ピアAはその知識以上最近munrosを示さない限り、逆に、ピアBは、その右端署名されたMunroのハッシュを送らなければなりません。ピアの右端署名されたMunroのハッシュはピアのマークル・ハッシュ・ツリーの幅NCHUNKS_PER_SIGチャンクの右端サブツリーのインジェクタによって署名Munroのハッシュとして定義されます。 MUSTピア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOT send the signed munro hash in the first datagram of the HANDSHAKE procedure and Peer B MUST NOT send it in the second datagram as it is considered heavy payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは重いペイロードと見なされるように、第2のデータグラムにそれを送ってはいけませんハンドシェイク手順とピアBの最初のデータグラムで署名されたMunroのハッシュを送信しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer receives a SIGNED_INTEGRITY message with a signed munro hash but the timestamp is too old, the peer MUST discard the message. Otherwise, it SHOULD use the signed munro to update its hash tree and pick a tune-in in the live stream. A peer may use the information from multiple peers to pick the tune-in point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが署名したマンローハッシュでSIGNED_INTEGRITYメッセージを受信するが、タイムスタンプが古すぎる場合には、ピアはメッセージを捨てなければなりません。それ以外の場合は、そのハッシュツリーを更新し、ライブストリームにチューンインを選択するために署名したマンローを使用すべきです。ピアは、チューンインポイントを選択する複数のピアからの情報を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Forgetting Chunks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。忘却チャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a live broadcast progresses, a peer may want to discard the chunks that it already played out. Ideally, other peers should be aware of this fact so that they will not try to request these chunks from this peer. This could happen in scenarios where live streams may be paused by viewers, or viewers are allowed to start late in a live broadcast (e.g., start watching a broadcast at 20:35 when it actually began at 20:30).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ライブ放送が進行すると、ピアはそれが既に演じチャンクを破棄することもできます。彼らはこのピアからのこれらのチャンクを要求しようとはしませんように、理想的には、他のピアはこの事実を認識する必要があります。これは、ライブストリームは、（それが実際には20:30開始したとき、例えば、20時35分に放送を見始める）視聴者が一時停止されてもよいし、視聴者が生放送で後半開始が許可されているシナリオで発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP provides a simple solution for peers to stay up to date with the chunk availability of a discarding peer. A discarding peer in a live stream MUST enable the Live Discard Window protocol option, specifying how many chunks/bytes it caches before the last chunk/byte it advertised as being available (see Section 7.9). Its peers SHOULD apply this number as a sliding window filter over the peer&#39;s chunk availability as conveyed via its HAVE messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPは廃棄ピアのチャンクの可用性を最新の状態に滞在するピアのためのシンプルなソリューションを提供します。ライブストリームで廃棄ピアは（7.9節を参照してください）/それが利用可能であるとして宣伝最後のチャンク/バイトの前にキャッシュするバイトをどのように多くのチャンクを指定して、ライブ破棄ウィンドウのプロトコルオプションを有効にする必要があります。そのHAVEメッセージを介して伝達としてのピアは、ピアのチャンクの可用性オーバースライディングウィンドウフィルタとして、この番号を適用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three factors are important when deciding for an appropriate value for this option: the desired amount of playback buffer for peers, the bitrate of the stream, and the available resources of the peer. Consider the case of a fresh peer joining the stream. The size of the discard window of the peers it connects to influences how much data it can directly download to establish its prebuffer. If the window is smaller than the desired buffer, the fresh peer has to wait until the peers downloaded more of the stream before it can start playback. As media buffers are generally specified in terms of a number of seconds, the size of the discard window is also related to the (average) bitrate of the stream. Finally, if a peer has few resources to store chunks and metadata, it should choose a small discard window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアの再生バッファの所望の量、ストリームのビットレート、およびピアの利用可能なリソース：このオプションに適切な値を決定する際に3つの要因が重要です。ストリームに参加する新鮮なピアの場合を考えてみましょう。それはそれは直接そのプリバッファを確立するためにダウンロードすることができますどのくらいのデータの影響に接続しているピアの破棄ウィンドウのサイズ。ウィンドウが希望のバッファより小さい場合は、新鮮なピアは、それが再生を開始する前に、ピアがストリームの多くをダウンロードするまで待たなければなりません。メディアバッファは、一般的に秒数で指定されるように、廃棄ウインドウのサイズは、ストリームの（平均）ビットレートに関係しています。ピアはチャンクとメタデータを格納するためのいくつかのリソースを持っている場合最後に、それは小さな破棄ウィンドウを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Protocol Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.プロトコルオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HANDSHAKE message in PPSPP can contain the following protocol options. Unless stated otherwise, a protocol option consists of an 8-bit code followed by an 8-bit value. Larger values are all encoded big-endian. Each protocol option is explained in the following subsections. The list of protocol options MUST be sorted on code value (ascending) in a HANDSHAKE message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPでハンドシェークメッセージには、次のプロトコル・オプションを含めることができます。特に明記しない限り、プロトコルオプションは、8ビットの値に続く8ビットのコードで構成されています。値を大きくすると、すべてのビッグエンディアンをコード化しています。各プロトコルのオプションは以下のサブセクションで説明されています。プロトコル・オプションのリストは、ハンドシェイクメッセージにコード値（昇順）でソートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +--------+-------------------------------------+
             | Code   | Description                         |
             +--------+-------------------------------------+
             | 0      | Version                             |
             | 1      | Minimum Version                     |
             | 2      | Swarm Identifier                    |
             | 3      | Content Integrity Protection Method |
             | 4      | Merkle Hash Tree Function           |
             | 5      | Live Signature Algorithm            |
             | 6      | Chunk Addressing Method             |
             | 7      | Live Discard Window                 |
             | 8      | Supported Messages                  |
             | 9      | Chunk Size                          |
             | 10-254 | Unassigned                          |
             | 255    | End Option                          |
             +--------+-------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
Table 2: PPSPP Options
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
表2：PPSSPPオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. End Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。終了オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST conclude the list of protocol options with the end option. Subsequent octets should be considered protocol messages. The code for the end option is 255, and unlike others, it has no value octet, so the option&#39;s length is 1 octet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは終了オプション付きのプロトコル・オプションのリストを締結しなければなりません。後続のオクテットはプロトコルメッセージを考慮しなければなりません。終了オプションのコードは255であり、その他は異なり、それは値のオクテットを持っていないので、オプションの長さは1つのオクテットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |1 1 1 1 1 1 1 1|
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Version
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。版
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST include the maximum version of the PPSPP it supports as the first protocol option in the list. The code for this option is 0. Defined values are listed in Table 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、リスト内の最初のプロトコル・オプションとしてサポートPPSPPの最大バージョンを含まなければなりません。このオプションのためのコードは0で定義された値は、表3にリストされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +---------+----------------------------------------+
           | Version | Description                            |
           +---------+----------------------------------------+
           | 0       | Reserved                               |
           | 1       | Protocol as described in this document |
           | 2-255   | Unassigned                             |
           +---------+----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Table 3: PPSPP Version Numbers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
表3：PPSSPPバージョン番号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|  Version (8)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Minimum Version
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。最小バージョン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer initiates the handshake, it MUST include the minimum version of the PPSPP it supports in the list of protocol options, following the min/max versioning scheme defined in [RFC6709], Section 4.1, strategy 5. The code for this option is 1. Defined values are listed in Table 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがハンドシェイクを開始するとき、それは、このオプションのためのコードは[RFC6709]で定義された最小/最大バージョニング・スキーム、セクション4.1、戦略5.以下、プロトコル・オプションのリストでサポートPPSPPの最小バージョンを含まなければなりません1.定義された値を表3に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1| Min. Ver. (8) |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Swarm Identifier
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4。スウォーム識別子
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer initiates the handshake, it MUST include a single swarm identifier option. If the peer is not the initiator, it MAY include a swarm identifier option, as an end-to-end check. This option has the following structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが握手を開始すると、それは、単一の群れ識別子オプションを含まなければなりません。ピアがイニシエータでない場合は、エンド・ツー・エンドのチェックとして、群れ識別子オプションを含むかもしれません。このオプションは、以下の構造を有します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 0|     Swarm ID Length (16)      |               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                       Swarm Identifier (variable)             ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Swarm ID Length field contains the length of the single Swarm Identifier that follows in bytes. The Length field is 16 bits wide to allow for large public keys as identifiers in live streaming.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
群発IDの長さフィールドは、バイト単位で、次の単一群発識別子の長さを含みます。 Lengthフィールドは、ライブストリーミングでの識別子として大規模な公開鍵を可能にするために16ビット幅です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each PPSPP peer knows the IDs of the swarms it joins, so this information can be immediately verified upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各PPSPPピアは、それが加入群れのIDを知っているので、この情報はすぐに受信時に確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. Content Integrity Protection Method
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5。コンテンツの整合性の保護方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST include the content integrity method used by a swarm. The code for this option is 3. Defined values are listed in Table 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは群れで使用されるコンテンツ保全方法を含まなければなりません。このオプションのためのコードは、前記定義された値は、表4にリストされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   +--------+-------------------------+
                   | Method | Description             |
                   +--------+-------------------------+
                   | 0      | No integrity protection |
                   | 1      | Merkle Hash Tree        |
                   | 2      | Sign All                |
                   | 3      | Unified Merkle Tree     |
                   | 4-255  | Unassigned              |
                   +--------+-------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Table 4: PPSPP Content Integrity Protection Methods
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
表4：PPSSPPコンテンツ完全性保護方法
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;Merkle Hash Tree&#34; method is the default for static content, see Section 5.1. &#34;Sign All&#34;, and &#34;Unified Merkle Tree&#34; are for live content, see Section 6.1, with &#34;Unified Merkle Tree&#34; being the default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「マークルハッシュツリー」の方法は、静的なコンテンツのデフォルトである、5.1節を参照してください。ライブコンテンツのためのものである「すべての署名」、および「ユニファイドマークル木」、「統合マークル木」はデフォルトであることと、6.1節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 1|   CIPM (8)    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. Merkle Tree Hash Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6。マークル木ハッシュ関数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the content integrity protection method is &#34;Merkle Hash Tree&#34;, this option defining which hash function is used for the tree MUST be included. The code for this option is 4. Defined values are listed in Table 5 (see [FIPS180-4] for the function semantics).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツの完全性保護法は「マークルハッシュツリー」である場合には、ハッシュ関数がツリーのために使用される定義このオプションは含まれなければなりません。このオプションのためのコードは、（関数のセマンティクスは[FIPS180-4]を参照）。4.定義された値は、表5に列挙されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        +----------+-------------+
                        | Function | Description |
                        +----------+-------------+
                        | 0        | SHA-1       |
                        | 1        | SHA-224     |
                        | 2        | SHA-256     |
                        | 3        | SHA-384     |
                        | 4        | SHA-512     |
                        | 5-255    | Unassigned  |
                        +----------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Table 5: PPSPP Merkle Hash Functions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
表5：PPSSPPマークルハッシュ関数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST support SHA-1 (see Section 12.5) and SHA-256. SHA-256 is the default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、SHA-1（12.5項を参照）、SHA-256をサポートしなければなりません。 SHA-256はデフォルトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 0 0|    MHF (8)    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7. Live Signature Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7。ライブ署名アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the content integrity protection method is &#34;Sign All&#34; or &#34;Unified Merkle Tree&#34;, this option MUST be defined. The code for this option is 5. The 8-bit value of this option is one of the values listed in the &#34;Domain Name System Security (DNSSEC) Algorithm Numbers&#34; registry [IANADNSSECALGNUM]. The RSASHA1 [RFC4034], RSASHA256 [RFC5702], ECDSAP256SHA256 and ECDSAP384SHA384 [RFC6605] algorithms are mandatory to implement. Default is ECDSAP256SHA256.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツの完全性保護法は「すべての署名」または「統合マークル木」である場合は、このオプションを定義する必要があります。このオプションのためのコードは、このオプションの5 8ビット値は、「ドメインネームシステムセキュリティ（DNSSEC）アルゴリズムの番号」レジストリ[IANADNSSECALGNUM]に列挙された値のいずれかです。 RSASHA1 [RFC4034]、RSASHA256 [RFC5702]、ECDSAP256SHA256とECDSAP384SHA384 [RFC6605]アルゴリズムを実装するために必須です。デフォルトはECDSAP256SHA256です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 0 1|    LSA (8)    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8. Chunk Addressing Method
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8。チャンクの対処方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST include the chunk addressing method it uses. The code for this option is 6. Defined values are listed in Table 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、それが使用チャンクアドレッシング方法を含まなければなりません。このオプションのためのコードは、前記定義された値は、表6にリストされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     +--------+---------------------+
                     | Method | Description         |
                     +--------+---------------------+
                     | 0      | 32-bit bins         |
                     | 1      | 64-bit byte ranges  |
                     | 2      | 32-bit chunk ranges |
                     | 3      | 64-bit bins         |
                     | 4      | 64-bit chunk ranges |
                     | 5-255  | Unassigned          |
                     +--------+---------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Table 6: PPSPP Chunk Addressing Methods
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
表6：PPSSPPチャンクの対処方法
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST support &#34;32-bit chunk ranges&#34; and &#34;64-bit chunk ranges&#34;. Default is &#34;32-bit chunk ranges&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装がサポートしなければなりません「32ビットチャンクの範囲」および「64ビットのチャンク範囲」。デフォルトでは、「32ビットのチャンクが及ぶ」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 1 0|    CAM (8)    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.9. Live Discard Window
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.9。破棄ウィンドウライブ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer in a live swarm MUST include the discard window it uses. The code for this option is 7. The unit of the discard window depends on the chunk addressing method used, see Table 6. For bins and chunk ranges, it is a number of chunks; for byte ranges, it is a number of bytes. Its data type is the same as for a bin, or one value in a range specification. In other words, its value is a 32-bit or 64-bit integer in big-endian format. If this option is used, the Chunk Addressing Method MUST appear before it in the list. This option has the following structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ライブ群れ内のピアは、使用、廃棄・ウィンドウを含まなければなりません。このオプションのためのコードが使用チャンクアドレッシング方法に依存し、ビン及びチャンクの表6を参照のことはチャンクの数であり、範囲破棄ウィンドウのユニット7です。バイト範囲のために、それはバイト数です。そのデータ型は、ビン、または範囲指定内の1つの値と同じです。換言すれば、その値は、ビッグエンディアン形式の32ビットまたは64ビットの整数です。このオプションを使用すると、メソッドのアドレス指定チャンクはリストにそれの前に現れなければなりません。このオプションは、以下の構造を有します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 1 1|       Live Discard Window (32 or 64)          ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                                                               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer that does not, under normal circumstances, discard chunks MUST set this option to the special value 0xFFFFFFFF (32-bit) or 0xFFFFFFFFFFFFFFFF (64-bit). For example, peers that record a complete broadcast to offer it directly as a static file after the broadcast ends use these values (see Section 6.1.2). Section 6.2 explains how to determine a value for this option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、通常の状況下では、チャンクを破棄しないピアは特別な値は0xFFFFFFFF（32ビット）または0xFFFFFFFFFFFFFFFF（64ビット）にこのオプションを設定しなければなりません。例えば、放送はこれらの値（6.1.2項を参照）を使用して終了した後、レコードの完全な放送が静的ファイルとして直接それを提供することをピア。 6.2節では、このオプションの値を決定する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.10. Supported Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.10。サポートされているメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peers may support just a subset of the PPSPP messages. For example, peers running over TCP may not accept ACK messages or peers used with a centralized tracking infrastructure may not accept PEX messages. For these reasons, peers who support only a proper subset of the PPSPP messages MUST signal which subset they support by means of this protocol option. The code for this option is 8. The value of this option is a length octet (SupMsgLen) indicating the length, in bytes, of the compressed bitmap that follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアはPPSPPメッセージのサブセットだけをサポートすることができます。たとえば、TCP上で実行されているピアは、中央集中型の追跡インフラストラクチャで使用されるACKメッセージやピアを受け付けないことがありPEXメッセージを受け付けない場合があります。これらの理由から、PPSPPメッセージの唯一の適切なサブセットをサポートするピアは、彼らがこのプロトコルオプションによってサポートされているサブセット合図しなければなりません。このオプションのためのコードは、このオプションの8値であり、次の圧縮されたビットマップのバイト長さを示す長さオクテット（SupMsgLen）、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of messages supported can be derived from the compressed bitmap by padding it with bytes of value 0 until it is 256 bits in length. Then, a 1 bit in the resulting bitmap at position X (numbering left to right) corresponds to support for message type X, see Table 7. In other words, to construct the compressed bitmap, create a bitmap with a 1 for each message type supported and a 0 for a message type that is not, store it as an array of bytes, and truncate it to the last non-zero byte. An example of the first 16 bits of the compressed bitmap for a peer supporting every message except ACKs and PEXs is 11011001 11110000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サポートされているメッセージのセットは、長さが256ビットになるまで値0のバイトでそれをパディングすることによって圧縮されたビットマップから導出することができます。次に、位置Xで得られたビットマップの1ビットは、（左から右に番号付け）、メッセージタイプXのサポートすなわち表7を参照して、圧縮されたビットマップを構築するために、各メッセージタイプの1とビットマップを作成するために、対応しますサポートされないメッセージタイプ0、バイトの配列として格納し、最後の非ゼロバイトにこれを切り捨てます。 ACKおよびPEXs除くすべてのメッセージをサポートするピアの圧縮されたビットマップの最初の16ビットの例は、11011001 11110000です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 0| SupMsgLen (8) |                               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~            Supported Messages Bitmap (variable, max 256)      ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.11. Chunk Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.11。チャンクサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer in a swarm MUST include the chunk size the swarm uses. The code for this option is 9. Its value is a 32-bit integer denoting the size of the chunks in bytes in big-endian format. When variable chunk sizes are used, this option MUST be set to the special value 0xFFFFFFFF. Section 8.1 explains how content publishers can determine a value for this option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
群れにおけるピアがスウォームが使用チャンクサイズを含まなければなりません。このオプションのためのコードは9.その値はビッグエンディアン形式のバイト単位のチャンクの大きさを示す32ビットの整数です。変数のチャンクサイズが使用されている場合は、このオプションは特別な値は0xFFFFFFFFに設定しなければなりません。 8.1節では、コンテンツ発行者は、このオプションの値を決定する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 1|       Chunk Size (32)                         ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~               |
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. UDP Encapsulation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. UDPカプセル化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP implementations MUST use UDP as transport protocol and MUST use LEDBAT for congestion control [RFC6817]. Using LEDBAT enables PPSPP to serve the content after playback (seeding) without disrupting the user who may have moved to different tasks that use its network connection. Future PPSPP versions can also run over other transport protocols or use different congestion control algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP実装は、トランスポートプロトコルとしてUDPを使用しなければならないし、輻輳制御[RFC6817]のためLEDBATを使用しなければなりません。 LEDBATを使用すると、そのネットワーク接続を使用して別のタスクに移動した可能性があり、ユーザーを混乱させることなく再生（播種）後のコンテンツを提供するためにPPSPPを可能にします。将来のPPSPPのバージョンは、他のトランスポートプロトコル上で実行するか、または別の輻輳制御アルゴリズムを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Chunk Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。チャンクサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, a UDP datagram containing PPSPP messages SHOULD fit inside a single IP packet, so its maximum size depends on the MTU of the network. If the UDP datagram does not fit, its chance of getting lost in the network increases as the loss of a single fragment of the datagram causes the loss of the complete datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その最大サイズは、ネットワークのMTUに依存して一般的には、PPSPPメッセージを含むUDPデータグラムは、単一のIPパケット内に収まるべきです。 UDPデータグラムが合わない場合は、データグラムの単一の断片の損失などのネットワーク増加で迷子のそのチャンスは、完全なデータグラムの損失が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The largest message in a PPSPP datagram is the DATA message carrying a chunk of content. So the (maximum) size of a chunk to choose for a particular swarm depends primarily on the expected MTU. The chunk size should be chosen such that a chunk and its required INTEGRITY messages can generally be carried inside a single datagram, following the Atomic Datagram Principle (Section 5.3). Other considerations are the hardware capabilities of the peers. Having large chunks and therefore less chunks per megabyte of content reduces processing costs. The chunk addressing schemes can all work with different chunk sizes, see Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPデータグラムで最大のメッセージは、コンテンツのチャンクを搬送するDATAメッセージです。だから、特定の群れのために選択するチャンクの（最大）サイズは、主に予想されるMTUに依存します。チャンクサイズはチャンク、その必要INTEGRITYメッセージは、一般的に原子力データグラム原理（セクション5.3）以下、単一のデータグラム内部に行うことができるように選択されるべきです。その他の考慮事項は、ピアのハードウェア機能です。大きなチャンクを持つため、コンテンツのメガバイトあたり少ないチャンクは処理コストを削減します。チャンクのアドレス指定スキームは、第4節を異なるチャンクサイズですべての作業を見ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED approach is to use fixed-size chunks of 1024 bytes, as this size has a high likelihood of traveling end-to-end across the Internet without any fragmentation. In particular, with this size, a UDP datagram with a DATA message can be transmitted as a single IP packet over an Ethernet network with 1500-byte frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨されるアプローチは、このサイズは、任意の断片化することなく、インターネット経由でエンド・ツー・エンドの走行の高い可能性を有しているように、1024バイトの固定サイズのチャンクを使用することです。具体的には、このサイズで、DATAメッセージをUDPデータグラムが1500バイトのフレームとイーサネット・ネットワーク上の単一のIPパケットとして送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PPSPP implementation MAY use a variant of the Packetization Layer Path MTU Discovery (PLPMTUD), described in [RFC4821], for discovering the optimal MTU between sender and destination. As in PLPMTUD, progressively larger probing packets are used to detect the optimal MTU for a given path. However, in PPSPP, probe packets SHOULD contain actual messages, in particular, multiple DATA messages. By using actual DATA messages as probe packets, the returning ACK messages will confirm the probe delivery, effectively updating the MTU estimate on both ends of the link. To be able to scale up probe packets with sensible increments, a minimum chunk size of 512 bytes SHOULD be used. Smaller chunk sizes lead to an inefficient protocol. An implication is that PPSPP supports datagrams over IPv4 of 576 bytes or more only. This variant is not mandatory to implement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP実装がパケット化層のパスMTU探索（PLPMTUD）の変異体を使用することができるが、送信元と宛先の間の最適MTUを発見するために、[RFC4821]で説明。 PLPMTUDのように、次第に大きくプロービングパケットが所与のパスのための最適MTUを検出するために使用されます。しかし、PPSPPで、プローブパケットは、具体的には、複数のデータ・メッセージを、実際のメッセージを含むべきです。プローブパケットとして、実際のデータメッセージを使用することにより、帰国ACKメッセージを効果的にリンクの両端でMTUの推定値を更新し、プローブの配信を確認します。賢明なインクリメントを有するプローブパケットをスケールアップすることができるように、512バイトの最小チャンクサイズを使用すべきです。小さいチャンクサイズは、非効率的なプロトコルにつながります。含意はPPSPPが576バイト以上のみのIPv4の上でデータグラムをサポートしていることです。この亜種は、実装するために必須ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chunk size used for a particular swarm, or the fact that it is variable, MUST be part of the swarm&#39;s metadata (which then minimally consists of the swarm ID and the chunk nature and size).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の群れのために使用されるチャンクサイズ、またはそれが可変であるという事実は、（その後最小限群発IDとチャンクの性質およびサイズからなる）群れのメタデータの一部でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Datagrams and Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。データグラムとメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using UDP, the abstract datagram described above corresponds directly to a UDP datagram. Most messages within a datagram have a fixed length, which generally depends on the type of the message. The first byte of a message denotes its type. The currently defined types are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPを使用する場合、上述した抽象データグラムは、UDPデータグラムに直接対応します。データグラム内のほとんどのメッセージは、一般的に、メッセージの種類に依存した固定長を、持っています。メッセージの最初のバイトは、その型を表します。現在定義されているタイプは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      +----------+------------------+
                      | Msg Type | Description      |
                      +----------+------------------+
                      | 0        | HANDSHAKE        |
                      | 1        | DATA             |
                      | 2        | ACK              |
                      | 3        | HAVE             |
                      | 4        | INTEGRITY        |
                      | 5        | PEX_RESv4        |
                      | 6        | PEX_REQ          |
                      | 7        | SIGNED_INTEGRITY |
                      | 8        | REQUEST          |
                      | 9        | CANCEL           |
                      | 10       | CHOKE            |
                      | 11       | UNCHOKE          |
                      | 12       | PEX_RESv6        |
                      | 13       | PEX_REScert      |
                      | 14-254   | Unassigned       |
                      | 255      | Reserved         |
                      +----------+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Table 7: PPSPP Message Types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
表7：PPSSPPメッセージタイプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, integers are serialized in network (big-endian) byte order. So, consider the example of a HAVE message (Section 3.2) using bin chunk addressing. It has a message type of 0x03 and a payload of a bin number, a 4-byte integer (say, 1); hence, its on-the-wire representation for UDP can be written in hex as &#34;0300000001&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、整数はネットワーク（ビッグエンディアン）バイトオーダーで連載されています。だから、アドレッシングビンチャンクを使用してHAVEメッセージ（3.2節）の例を考えてみましょう。それは、0×03のメッセージタイプ及びビン番号、4バイトの整数（例えば、1）のペイロードを有します。従って、UDPのためにその上ワイヤ表現は、「0300000001」とヘクスに書き込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All messages are idempotent or recognizable as duplicates. Idempotent means that processing a message more than once does not lead to a different state from if it was processed just once. In particular, a peer MAY resend DATA, ACK, HAVE, INTEGRITY, PEX_*, SIGNED_INTEGRITY, REQUEST, CANCEL, CHOKE, and UNCHOKE messages without problems when loss is suspected. When a peer resends a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのメッセージは、冪等または重複として認識されています。冪等は、それが一度だけ処理された場合は複数回のメッセージを処理することから別の状態につながらないことを意味します。具体的には、ピアは、損失が疑われる場合に問題なく、チョーク、及びUNCHOKEメッセージをCANCEL、DATA、ACK有し、INTEGRITY、PEX_ *、SIGNED_INTEGRITY、REQUESTを再送信することができます。ときにピアが再送信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HANDSHAKE message, it can be recognized as duplicate by the receiver, because it already recorded the first connection attempt, and be dealt with.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既に最初の接続の試みを記録し、扱われるので、ハンドシェイクメッセージは、それは、受信機によって重複として認識することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Channels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3。チャンネル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 3.11, PPSPP uses a multiplexing scheme, called channels, to allow multiple swarms to use the same UDP port. In the UDP encapsulation, each datagram from Peer A to Peer B is prefixed with the channel ID allocated by Peer B. The peers learn about each other&#39;s channel ID during the handshake as explained in Section 3.1.1. A channel ID consists of 4 bytes and MUST be generated following the requirements in [RFC4960] (Section 5.1.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.11節で説明したように、PPSPPは、複数の群れが同じUDPポートを使用できるようにするために、チャンネルと呼ばれる、多重化方式を使用しています。 3.1.1項で説明したようにUDPカプセル化では、ピアBにピアAから各データグラムは、ピアがハンドシェイク中に互いのチャネルのIDについて学習ピアBによって割り当てられたチャネルIDが付いています。チャネルIDは4バイトで構成され、[RFC4960]（セクション5.1.3）の要求後に生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. HANDSHAKE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4。ハンドシェーク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A channel is established with a handshake. To start a handshake, the initiating peer needs to know the swarm metadata, defined in Section 3.1 and the IP address and UDP port of a peer. A datagram containing a HANDSHAKE message then looks as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャネルはハンドシェイクで確立されています。ハンドシェイクを開始するには、開始ピアは、ピアの3.1節で定義された群れのメタデータ、およびIPアドレスとUDPポートを知る必要があります。次のようにハンドシェイクメッセージを含むデータグラムはその後になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Destination Channel ID (32)                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|            Source Channel ID (32)             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                     Protocol Options                          ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Destination Channel ID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
デスティネーションチャンネルID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
If the datagram is sent by the initiating peer, then it MUST be an all-zeros channel ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
データグラムは、開始ピアによって送信された場合、それはすべてゼロチャネルIDでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
If the datagram is sent by the responding peer, then it MUST consist of the Source Channel ID from the sender&#39;s HANDSHAKE message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
データグラムが応答ピアによって送信された場合、それは、送信者のハンドシェークメッセージからソースチャンネルIDから構成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The octet 0x00: The HANDSHAKE message type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
オクテットは0x00：ハンドシェークメッセージタイプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Source Channel ID: A locally unused channel ID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ソースチャンネルID：ローカルで使用されていないチャンネルID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Protocol Options: A list of protocol options encoding the swarm&#39;s metadata, as defined in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プロトコルオプション：第7節で定義されるように、群れのメタデータを符号化するプロトコル・オプションのリスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer SHOULD explicitly close a channel by sending a HANDSHAKE message that MUST contain an all zeros Source Channel ID and a list of protocol options. The list MUST either be empty or contain the maximum version number the sender supports, following the min/max versioning scheme defined in [RFC6709], Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、明示的にすべてゼロソースチャンネルのIDとプロトコル・オプションのリストを含まなければならないハンドシェークメッセージを送信することにより、チャネルを閉じる必要があります。リストが空であるか、[RFC6709]で定義された最小/最大バージョン管理方式、セクション4.1以下、最大バージョン番号に発信者のサポートが含まれている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. HAVE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5。持ってる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A HAVE message (type 0x03) consists of a single chunk specification that states that the sending peer has those chunks and successfully checked their integrity. The single chunk specification represents a consecutive range of verified chunks. A bin consists of a single integer, and a chunk or byte range of two integers, of the width specified by the Chunk Addressing protocol options, encoded big-endian.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HAVEメッセージ（タイプ0x03のは）送信ピアは、それらのチャンクを持っているし、成功した彼らの整合性をチェックすると述べている単一のチャンクの仕様で構成されています。単一チャンク仕様を検証チャンクの連続範囲を表します。ビンは単一の整数であり、ビッグエンディアンコードされるプロトコルオプションをアドレッシングチャンクにより指定された幅の2つの整数のチャンクまたはバイト範囲から成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A HAVE message using 32-bit chunk ranges as Chunk Addressing method:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットのチャンクを使用して、HAVEメッセージは、チャンクアドレッシング方法として、範囲：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 1|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the HAVE message (0x03) followed by the start chunk and the end chunk describing the chunk range. Note this diagram shows a message and not a datagram, so it is not prefixed by the destination Channel ID. This holds for all subsequent message diagrams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、最初のオクテットは、開始チャンクとチャンクの範囲を記述終了チャンクによって従っているメッセージ（0×03）です。この図は、メッセージではなく、データグラムを示し、それは先チャネルIDが付けされていません。これは、すべての後続のメッセージダイアグラムのために保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. DATA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6。データ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DATA message (type 0x01) consists of a chunk specification, a timestamp, and the actual chunk. In case a datagram contains one DATA message, a sender MUST always put the DATA message in the tail of the datagram. A datagram MAY contain multiple DATA messages when the chunk size is fixed and when none of the DATA messages carry the last chunk, if that is smaller than the chunk size. As LEDBAT congestion control is used, a sender MUST include a timestamp, in particular, a 64-bit integer representing the current system time with microsecond accuracy. The timestamp MUST be included between chunk specification and the actual chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATAメッセージ（タイプ0×01）は、チャンク仕様、タイムスタンプ、および実際のチャンクから成ります。データグラムが1つのDATAメッセージが含まれている場合は、送信者は、常にデータグラムの尾部にDATAメッセージを置く必要があります。データメッセージのどれも最後のチャンクを運ばないときには、チャンクサイズよりも小さい場合、チャンクサイズは、固定されたときにデータグラムは、複数のデータ・メッセージを含むかもしれません。 LEDBAT輻輳制御が使用されているように、送信者は、タイムスタンプ、特に、マイクロ秒の精度で現在のシステム時刻を表す64ビットの整数を含まなければなりません。タイムスタンプは、チャンク仕様と実際のチャンクの間に含まれなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DATA message using 32-bit chunk ranges as Chunk Addressing method:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットのチャンクを使用して、DATAメッセージは、チャンクアドレッシング方法として、範囲：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Timestamp (64)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                            Data                               ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the DATA message (0x01) followed by the start chunk and the end chunk describing the single chunk, the timestamp, and the actual data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、最初のオクテットは、開始チャンク及び単一のチャンク、タイムスタンプを記述終了チャンク、及び実際のデータに続くDATAメッセージ（0×01）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. ACK
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7。 ACK
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An ACK message (type 0x02) acknowledges data that was received from its addressee; to comply with the LEDBAT delay-based congestion control, an ACK message consists of a chunk specification and a timestamp representing a one-way delay sample. The one-way delay sample is a 64-bit integer with microsecond accuracy, and it is computed from the timestamp received from the previous DATA message containing the chunk being acknowledged following the LEDBAT specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACKメッセージ（タイプ0×02）は、その宛先から受信されたデータを肯定応答します。 LEDBAT遅延ベースの輻輳制御を遵守するために、ACKメッセージは、チャンク仕様と一方向遅延サンプルを表すタイムスタンプから成ります。一方向遅延サンプルは、マイクロ秒の精度の64ビット整数であり、そしてそれはLEDBAT仕様次の承認されたチャンクを含む以前のデータメッセージから受信したタイムスタンプから計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An ACK message using 32-bit chunk ranges as Chunk Addressing method:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットのチャンクを使用して、ACKメッセージは、チャンクアドレッシング方法として、範囲：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 0|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  One-way delay sample (64)                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the ACK message (0x02) followed by the start chunk and the end chunk describing the chunk range and the one-way delay sample.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、最初のオクテットは、開始チャンクとチャンク範囲と一方向遅延サンプルを記述する終了チャンクに続くACKメッセージ（0×02）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. INTEGRITY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8。 INTEGRITY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An INTEGRITY message (type 0x04) consists of a chunk specification and the cryptographic hash for the specified chunk or node. The type and format of the hash depends on the protocol options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インテグリティ・メッセージ（タイプ0×04）は、チャンク指定し、指定されたチャンクまたはノードの暗号ハッシュから成ります。ハッシュの種類や形式は、プロトコルオプションによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An INTEGRITY message using 32-bit chunk ranges as Chunk Addressing method and a SHA-256 hash:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットのチャンクを使用して整合性メッセージは、チャンクアドレッシング方法及びSHA-256ハッシュとして及びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 0 0|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                            Hash (256)                         ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+ where the first octet is the INTEGRITY message (0x04) followed by the
   start chunk and the end chunk describing the chunk range and the
   hash.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.9. SIGNED_INTEGRITY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.9。 SIGNED_INTEGRITY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SIGNED_INTEGRITY message (type 0x07) consists of a chunk specification, a 64-bit timestamp in NTP Timestamp format [RFC5905] and a digital signature encoded as a Signature field would be in an RRSIG record in DNSSEC without the Base64 encoding [RFC4034]. The signature algorithm is defined by the Live Signature Algorithm protocol option, see Section 7.7. The plaintext over which the signature is taken depends on the content integrity protection method used, see Section 6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SIGNED_INTEGRITYメッセージ（タイプ0x07の）は、チャンク仕様、NTPタイムスタンプ形式の64ビットのタイムスタンプ[RFC5905]で構成され、署名フィールドとして符号化されたデジタル署名は、Base64エンコード[RFC4034]なしDNSSECでRRSIGレコードであろう。署名アルゴリズムは、セクション7.7を参照して、ライブ署名アルゴリズム・プロトコル・オプションによって定義されます。署名が取られた上で平文は6.1項を参照してください、使用されるコンテンツの完全性保護方法によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SIGNED_INTEGRITY message using 32-bit chunk ranges as Chunk Addressing method:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットのチャンクを使用してSIGNED_INTEGRITYメッセージは、チャンクアドレッシング方法として、範囲：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 1 1|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Timestamp (64)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                       Signature                               ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the SIGNED_INTEGRITY message (0x07) followed by the start chunk and the end chunk describing the chunk range, the timestamp, and the Signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のオクテットはSIGNED_INTEGRITYメッセージである場合（0x07の）開始チャンク及びチャンク範囲、タイムスタンプ、署名を記述する終了チャンクが続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The length of the digital signature can be derived from the Live Signature Algorithm protocol option and the swarm ID as follows. The first mandatory algorithms are RSASHA1 and RSASHA256. For those algorithms, the swarm ID consists of a 1-byte Algorithm field followed by an RSA public key stored as a tuple (exponent length, exponent, modulus) [RFC3110]. Given the exponent length and the length of the public key tuple in the swarm ID, the length of the modulus in bytes can be calculated. This yields the length of the signature, as in RSA this is the length of the modulus [HAC01]. The other mandatory algorithms are ECDSAP256SHA256 and ECDSAP384SHA384 [RFC6605]. For these algorithms, the length of the digital signature is 64 and 96 bytes, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにデジタル署名の長さは、ライブ署名アルゴリズム・プロトコル・オプションおよび群発IDに由来することができます。最初の必須のアルゴリズムはRSASHA1とRSASHA256です。これらのアルゴリズムのために、群れのIDは、タプル（指数長、指数、係数）[RFC3110]として記憶RSA公開鍵に続く1バイトのアルゴリズムのフィールドから構成されています。指数長及び群発IDで公開鍵タプルの長さを与えられた、バイト単位でモジュラスの長さを計算することができます。 RSAでは、これは弾性率[HAC01]の長さであり、これは、署名の長さをもたらします。他の必須のアルゴリズムはECDSAP256SHA256とECDSAP384SHA384 [RFC6605]です。これらのアルゴリズムのために、デジタル署名の長さは、それぞれ、64および96バイトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10. REQUEST
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10。要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A REQUEST message (type 0x08) consists of a chunk specification for the chunks the requester wants to download.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUESTメッセージ（タイプ0x08のは）要求者がダウンロードしたいチャンクのためのチャンクの仕様で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A REQUEST message using 32-bit chunk ranges as Chunk Addressing method:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットのチャンクを使用して、要求メッセージは、チャンクアドレッシング方法として、範囲：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 0|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the REQUEST message (0x08) followed by the start chunk and the end chunk describing the chunk range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、最初のオクテットは、開始チャンクとチャンクの範囲を説明する端チャンクに続く要求メッセージ（0×08）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.11. CANCEL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.11。キャンセル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CANCEL message (type 0x09) consists of a chunk specification for the chunks the requester no longer is interested in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CANCELメッセージ（タイプ0x09の）は、依頼者がもはやに興味を持っているチャンクのためのチャンクの仕様で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CANCEL message using 32-bit chunk ranges as Chunk Addressing method:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットのチャンクを使用してCANCELメッセージは、チャンクアドレッシング方法として、範囲：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 1|                 Start chunk (32)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |                  End chunk (32)               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the CANCEL message (0x09) followed by the start chunk and the end chunk describing the chunk range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、最初のオクテットは、CANCELメッセージ（0x09の）が開始チャンク及びチャンクの範囲を記述終了チャンクが続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.12. CHOKE and UNCHOKE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.12。 CHOKEとUNCHOKE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both CHOKE and UNCHOKE messages (types 0x0a and 0x0b, respectively) carry no payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チョークとUNCHOKEメッセージ（それぞれのタイプは0x0Aと0x0Bの、）の両方にはペイロードを運びません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CHOKE message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チョークメッセージ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 1 0|
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the CHOKE message (0x0a).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のオクテットは、チョークメッセージ（0x0Aの）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An UNCHOKE message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNCHOKEメッセージ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 1 1|
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the UNCHOKE message (0x0b).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のオクテットはUNCHOKEメッセージ（0x0Bの）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.13. PEX_REQ, PEX_RESv4, PEX_RESv6, and PEX_REScert
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.13。 PEX_REQ、PEX_RESv4、PEX_RESv6、およびPEX_REScert
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PEX_REQ (0x06) message has no payload. A PEX_RESv4 (0x05) message consists of an IPv4 address in big-endian format followed by a UDP port number in big-endian format. A PEX_RESv6 (0x0c) message contains a 128-bit IPv6 address instead of an IPv4 one. If a PEX_REQ message does not originate from a private, unique-local, link-local, or multicast address [RFC1918] [RFC4193] [RFC4291], then the PEX_RES* messages sent in reply MUST NOT contain such addresses. This is to prevent leaking of internal addresses to external peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEX_REQ（0x06の）メッセージには、ペイロードを持ちません。 PEX_RESv4（0x05の）メッセージは、ビッグエンディアン形式でUDPポート番号に続くビッグエンディアン形式でIPv4アドレスで構成されています。 PEX_RESv6（0x0Cの）メッセージは、128ビットのIPv6アドレスの代わりのIPv4いずれかを含有します。 PEX_REQメッセージは、独自のローカル、プライベートリンクローカル、またはマルチキャストアドレスから発信されない場合は、[RFC1918] [RFC4193] [RFC4291]、そしてPEX_RESは*応答で送信されたメッセージは、そのようなアドレスを含めることはできません。これは、外部ピアに内部アドレスの漏洩を防ぐためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PEX_REQ message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEX_REQメッセージ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 1 0|
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the PEX_REQ message (0x06).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のオクテットはPEX_REQメッセージ（0x06で）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PEX_RESv4 message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEX_RESv4メッセージ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 1 0 1|              IPv4 Address (32)                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |             Port (16)         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the PEX_RESv4 message (0x05) followed by the IPv4 address and the port number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、最初のオクテットは、IPv4アドレスとポート番号に続くPEX_RESv4メッセージ（0×05）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PEX_RESv6 message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEX_RESv6メッセージ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 1 0 0|                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   IPv6 Address (128)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |             Port (16)         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the PEX_RESv6 message (0x0c), followed by the IPv6 address and the port number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、最初のオクテットは、IPv6アドレスとポート番号に続くPEX_RESv6メッセージ（0x0Cの）、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PEX_REScert (0x0d) message consists of a 16-bit integer in big-endian specifying the size of the membership certificate that follows, see Section 12.2.1. This membership certificate states that Peer P at Time T is a member of Swarm S and is a X.509v3 certificate [RFC5280] that is encoded using the ASN.1 distinguished encoding rules (DER) [CCITT.X690.2002]. The certificate MUST contain a &#34;Subject Alternative Name&#34; extension, marked as critical, of type uniformResourceIdentifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEX_REScert（0x0Dの）メッセージは、12.2.1項を参照して、以下の会員証明書のサイズを指定ビッグエンディアンの16ビットの整数から成ります。時間TでPピアこのメンバシップ証明書状態群発Sのメンバーであり、[CCITT.X690.2002] ASN.1識別符号化規則（DER）を用いて符号化されたX.509v3証明書[RFC5280]です。証明書は、タイプuniformResourceIdentifierでの、重要としてマークされた「サブジェクトの別名」の拡張子を、含んでいなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PEX_REScert message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PEX_REScertメッセージ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 1 0 1|   Size of Memb. Cert. (16)    |               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                    Membership Certificate                     ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the first octet is the PEX_REScert message (0x0d) followed by the size of the membership certificate and the membership certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、最初のオクテットはPEX_REScertメッセージ（0x0Dの）は、会員証のサイズおよびメンバーシップ証明書が続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The URL contained in the name extension MUST follow the generic syntax for URLs [RFC3986], where its scheme component is &#34;file&#34;, the host in the authority component is the DNS name or IP address of Peer P, the port in the authority component is the port of Peer P, and the path contains the swarm identifier for Swarm S, in hexadecimal form. In particular, the preferred form of the swarm identifier is xxyyzz..., where the &#39;x&#39;s, &#39;y&#39;s, and &#39;z&#39;s are 2 hexadecimal digits of the 8-bit pieces of the identifier. The validity time of the certificate is set with notBefore UTCTime set to T and notAfter UTCTime set to T plus some expiry time defined by the issuer. An example URL:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名拡張子に含まれるURLは、そのスキームのコンポーネントは、「ファイル」であるURLの一般的な構文[RFC3986]を、従わなければならない、権限コンポーネント内のホストは、DNS名またはピアPのIPアドレス、権限コンポーネントでポートですピアPのポートであり、経路は16進数形式で、群発S用の群れの識別子を含みます。具体的には、群れの識別子の好ましい形態はxxyyzz ...、「のx、Y」の、およびZ」の識別子の8ビット片の2桁の16進数がどこにあるかです。証明書の有効期間は、notBeforeのUTC時刻に設定されているTに設定し、notAfterのUTC時刻は、Tプラス発行者によって定義されたいくつかの有効期限を設定します。例のURL：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
file://192.0.2.0:6778/e5a12c7ad2d8fab33c699d1e198d66f79fa610c3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
ファイル：//192.0.2.0：6778 / e5a12c7ad2d8fab33c699d1e1​​98d66f79fa610c3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14. KEEPALIVE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14。生き続ける
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Keep alives do not have a message type on UDP. They are just simple datagrams consisting of the 4-byte channel ID of the destination only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キープアライブは、UDP上のメッセージ・タイプを持っていません。彼らは先の4バイトのチャンネルIDからなる単純なデータグラムです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A keep-alive datagram:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キープアライブデータグラム：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Channel ID (32)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.15. Flow and Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.15。フローおよび輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Explicit flow control is not required for PPSPP over UDP. In the case of video on demand, the receiver explicitly requests the content from peers, and is therefore in control of how much data is coming towards it. In the case of live streaming, where a push model may be used, the amount of data incoming is limited to the stream bitrate, which the receiver must be able to process for a continuous playback. Should, for any reason, the receiver get saturated with data, the congestion control at the sender side will detect the situation and adjust the sending rate accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明示的なフロー制御は、UDP上でPPSPPは必要ありません。ビデオオンデマンドの場合、受信機は、明示的にピアからコンテンツを要求し、したがってそれに向かって来ているどのくらいのデータの制御です。プッシュモデルを使用することができるライブストリーミングの場合には、データ受信の量は、受信機は、連続再生のために処理することができなければならないストリームのビットレートが、これらに限定されています。 、何らかの理由で、受信機にデータが飽和しなければならない、送信者側の輻輳制御は、状況を検出し、それに応じて、送信レートを調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP over UDP can support different congestion control algorithms. At present, it uses the LEDBAT congestion control algorithm [RFC6817]. LEDBAT is a delay-based congestion control algorithm that is used every day by millions of users as part of the uTP transmission protocol of BitTorrent [LBT] [LCOMPL] and is suitable for P2P streaming [PPSPPERF].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP上PPSPPは異なる輻輳制御アルゴリズムをサポートすることができます。現在のところ、それはLEDBAT輻輳制御アルゴリズム[RFC6817]を使用します。 LEDBATは[LCOMPL] [LBT]のBitTorrentのUTP伝送プロトコルの一部として、ユーザーの何百万人によって毎日使用される遅延ベースの輻輳制御アルゴリズムであり、[PPSPPERF】ストリーミングP2Pするのに適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LEDBAT monitors the delay of the packets on the data path. It uses the one-way delay variations to react early and limit the congestion that the stream may induce in the network [RFC6817]. Using LEDBAT enables PPSPP to serve the content to other interested peers after the playback has finished (seeding), without disrupting the user. After the playback, the user might move to different tasks that use its network link, which are prioritized over PPSPP traffic. Hence, the user does not notice the background PPSPP traffic, which in turn increases the chances of seeding the content for a longer period of time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LEDBATは、データパス上のパケットの遅延を監視します。これは、初期反応とストリームがネットワーク[RFC6817]に誘導することができる混雑を制限する一方向遅延の変動を使用します。 LEDBATを使用すると、再生がユーザーを混乱させることなく、（播種）が終了した後PPSPPが、他の興味のピアにコンテンツを提供することができます。再生した後、ユーザーはPPSPPトラフィックよりも優先され、そのネットワークリンクを使用し、さまざまなタスクに移動する可能性があります。したがって、ユーザーは、順番に、時間の長い期間のためのコンテンツを播種の可能性が高くなり、背景PPSPPトラフィックを、気づいていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The property of reacting early is not a problem in a peer-to-peer system where multiple sources offer the content. Considering the case of congestion near the sender, LEDBAT&#39;s early reaction impacts the transmission of chunks to the receiver. However, for the receiver, it is actually beneficial to learn early that the transmission from a particular source is impacted. The receiver can then choose to download time-critical chunks from other sources during its chunk picking phase.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期の反応の特性は、複数のソースがコンテンツを提供するピア・ツー・ピアシステムでは問題ではありません。送信者の近くに混雑の場合を考えると、LEDBATの初期の反応の影響受信機へのチャンクの送信。しかし、受信機のために、早期に特定のソースからの送信が影響を受けていることを学ぶために実際に有益です。受信機は、そのチャンクピック相の間に他のソースからのタイムクリティカルなチャンクをダウンロードするように選択することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the bottleneck is near the receiver, the receiver is indeed unlucky that transmissions from any source that runs through this bottleneck will back off quite fast due to LEDBAT. However, for the rest of the network (and the network operator), this is beneficial as the video-streaming system will back off early enough and not contribute too much to the congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ボトルネックは、受信機の近くにある場合、受信機は確かにこのボトルネックを通る任意のソースからの送信が原因LEDBATに非常に高速バックオフすること不運です。ビデオストリーミングシステムを早期に十分なバックオフし、渋滞にあまり寄与しないようしかし、ネットワークの残りの部分（およびネットワークオペレータ）のために、これは有益です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The power of LEDBAT is that its behavior can be configured. In the case of live streaming, a PPSPP deployer may want a more aggressive behavior to ensure quality of service. In that case, LEDBAT can be configured to be more aggressive. In particular, LEDBAT&#39;s queuing target delay value (TARGET in [RFC6817]) and other parameters can be adjusted such that it acts as aggressive as TCP (or even more). Hence, LEDBAT is an algorithm that works for many scenarios in a peer-to-peer context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LEDBATのパワーは、その動作を設定することができるということです。ライブストリーミングの場合は、PPSPPデプロイヤは、サービスの品質を保証するために、より積極的な行動をすることもできます。その場合には、LEDBATは、より積極的になるように構成することができます。特に、LEDBATのキューイング目標遅延値（[RFC6817]でTARGET）と他のパラメータは、TCPのように（またはそれ以上）として積極的に作用するように調整することができます。したがって、LEDBATは、ピアツーピアのコンテキストで多くのシナリオで動作するアルゴリズムです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.16. Example of Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.16。動作例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We present a small example of communication between a leecher and a seeder. The example presents the transmission of the file &#34;Hello World!&#34;, which fits within a 1024-byte chunk. For an easy understanding, we use the message description names, as listed in Table 7, and the protocol option names as listed in Table 2, rather than the actual binary value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々はリーチャとシーダーとの間の通信の簡単な例を提示します。例では、1024バイトのチャンク内に収まるファイルに「Hello World！」、の伝送を提示しています。むしろ実際のバイナリ値よりも、表2に示すように簡単に理解するために、我々は、表7に示すように、メッセージの記述名を使用して、プロトコル・オプション名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To do the handshake, the initiating peer sends a datagram that MUST start with an all-zeros channel ID (0x00000000); followed by a HANDSHAKE message, whose payload is a locally unused; a random channel ID (in this case 0x00000001); and a list of protocol options. Channel IDs MUST be randomly chosen, as described in Section 12.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクを行うために、開始ピアはすべてゼロチャネルID（0x00000000の）で開始しなければならないデータグラムを送信します。そのペイロード局所的に使用されていないハンドシェイクメッセージが続きます。 （この場合は0x00000001で）ランダムチャネルID。そして、プロトコル・オプションのリスト。 12.1節で説明したようにチャネルIDは、ランダムに、選ばなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HANDSHAKE   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1|    Version    |0 0 0 0 0 0 0 1|  Min Version  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1|   Swarm ID    |0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 1 0 0 0 1 1 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 1 1 1 0 0 1 1 0|
   ~                             .....                             ~
   |1 0 0 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 1 1 1 0 1 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Cont. Int.  |0 0 0 0 0 0 0 1| Mer.H.Tree F. |0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Chunk Add.  |0 0 0 0 0 0 1 0|   Chunk Size  |0 0 0 0 0 0 0 0~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0|      End      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol options are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルオプションは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Version: 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バージョン：1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Minimum supported Version: 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サポートされる最小バージョン：1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Swarm Identifier: A 32-byte root hash (47a0...b03b) identifying the content
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
群れ識別子：32バイトのルートハッシュ（47a0 ... B03B）コンテンツを識別する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Content Integrity Protection Method: Merkle Hash Tree
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
コンテンツ完全性保護方法：マークルハッシュツリー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Merkle Tree Hash Function: SHA-256
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
マークル木ハッシュ関数：SHA-256
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Chunk Addressing Method: 32-bit chunk ranges
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
チャンクアドレッシング方法：32ビットのチャンク範囲
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Chunk Size: 1024
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
チャンクサイズ：1024
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The receiving peer MAY respond, in which case the returned datagram
   MUST consist of the channel ID from the sender&#39;s HANDSHAKE message
   (0x00000001); a HANDSHAKE message, whose payload is a locally unused;
   a random channel ID (0x00000008); and a list of protocol options;
   followed by any other messages it wants to send.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HANDSHAKE   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 1 0 0 0|    Version    |0 0 0 0 0 0 0 1|   Cont. Int.  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1| Mer.H.Tree F. |0 0 0 0 0 0 1 0|   Chunk Add.  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 1 0|  Chunk Size   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0|      End      |      HAVE     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the protocol options, the receiving peer agrees on speaking protocol version 1, on using the Merkle Hash Tree as the Content Integrity Protection Method, SHA-256 hash as the Merkle Tree Hash Function, 32-bit chunk ranges as the Chunk Addressing Method, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルオプションで、受信ピアはマークル木ハッシュ関数として、コンテンツの完全性保護方法としてマークル・ハッシュ木を使用して、プロトコルバージョン1を話すSHA-256ハッシュに一致する、32ビットのチャンクは、アドレス指定方法チャンクとして範囲そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chunk Size 1024. Furthermore, it sends a HAVE message within the same datagram, announcing that it has locally available the first chunk of content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクサイズ1024は、さらに、それは、コンテンツのローカルで利用できる最初のチャンクを持っていることを発表し、同じデータグラム内HAVEメッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this point, the initiator knows that the peer really responds; for that purpose, channel IDs MUST be random enough to prevent easy guessing. So, the third datagram of a handshake MAY already contain some heavy payload. To minimize the number of initialization round trips, the first two datagrams MAY also contain some minor payload, e.g., the HAVE message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で、イニシエータは、ピアが実際に応答することを知っています。その目的のために、チャネルIDは簡単に推測を防ぐために十分にランダムでなければなりません。だから、握手の第三データグラムは、すでにいくつかの重いペイロードを含むかもしれません。初期のラウンドトリップの数を最小限に抑えるためには、最初の2つのデータグラムはまた、例えば、HAVEメッセージをいくつかのマイナーなペイロードを含むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiating peer MAY send a request for the chunks of content it wants to retrieve from the receiving peer, e.g., the first chunk announced during the handshake. It always precedes the message with the channel ID of the peer it is communicating with (0x00000008 in our example), as described in Section 3.11. Furthermore, it MAY add additional messages such as a PEX_REQ.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開始ピアは、それは、例えば、受信ピアからのハンドシェイク中に発表された最初のチャンクを取得したいコンテンツのチャンクのための要求を送信することができます。セクション3.11に記載されているように、それは常に、それは（この例では0x00000008）と通信しているピアのチャネルIDを持つメッセージに先行します。さらに、そのようなPEX_REQなどの追加メッセージを追加するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    REQUEST    |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|    PEX_REQ    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When receiving the third datagram, both peers have proof that they really talk to each other; the three-way handshake is complete. The receiving peer responds to the request by sending a DATA message containing the requested content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第三のデータグラムを受信すると、両方のピアは、彼らは本当にお互いに話すことの証明を持っています。 3ウェイハンドシェイクが完了します。受信ピアは、要求されたコンテンツを含むデータメッセージを送信することによって要求に応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     DATA      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 1 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 1 1 0 1 1 1 1 1 0 1 1 0 1 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 1 0 0 0 1 0 0|0 1 0 0 1 0 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                           .....                               ~
   |0 1 1 0 1 1 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DATA message consists of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATAメッセージの構成は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The 32-bit chunk range: 0,0 (the first chunk)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
32ビットのチャンク範囲：0,0（最初のチャンク）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The timestamp value: 0004e94180b7db44
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
タイムスタンプ値：0004e94180b7db44
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The data: 48656c6c6f20776f726c6421 (the &#34;Hello world!&#34; file)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
データ：48656c6c6f20776f726c6421（ファイルの &#34;Hello World！&#34;）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the above datagram does not include the INTEGRITY message, as the entire content can fit into a single message; hence, the initiating peer is able to verify it against the root hash. Also, in this example, the peer does not respond to the PEX_REQ as it does not know any third peer participating in the swarm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツ全体が単一のメッセージに収まることができるように、上記データグラムが完全性メッセージを含んでいないことに留意されたいです。したがって、開始ピアがルートハッシュに対してそれを確認することができます。それは群れに参加する任意の第三のピアを知らないとしても、この例では、ピアがPEX_REQに応答しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving the requested data, the initiating peer responds with an ACK message for the first chunk, containing a one-way delay sample (100 ms). Furthermore, it also adds a HAVE message for the chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求されたデータを受信すると、開始ピアは、一方向の遅延サンプル（100ミリ秒）を含む、最初のチャンクのためにACKメッセージで応答します。さらに、それはまた、チャンクを持っているメッセージが追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      ACK      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 1 1 0 0 1 0 0|      HAVE     |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this point, the initiating peer has successfully retrieved the entire file. Then, it explicitly closes the connection by sending a HANDSHAKE message that contains an all-zeros Source Channel ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で、開始ピアが正常にファイル全体を取得しました。その後、それが明示的にすべてゼロのソースチャンネルIDが含まれているハンドシェイクメッセージを送信して接続を閉じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   HANDSHAKE   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0|      End      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Extensibility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Chunk Picking Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。チャンクピッキングアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chunk (or piece) picking entirely depends on the receiving peer. The sending peer is made aware of preferred chunks by the means of REQUEST messages. In some (live) scenarios, it may be beneficial to allow the sender to ignore those hints and send unrequested data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンク（または部分）が完全にピッキング受信ピアに依存します。送信ピアは、REQUESTメッセージによって好まチャンクを認識しています。いくつかの（ライブ）のシナリオでは、送信者は、これらのヒントを無視し、要求されていないデータを送信することを可能にすることが有益であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chunk picking algorithm is external to the PPSPP and will generally be a pluggable policy that uses the mechanisms provided by PPSPP. The algorithm will handle the choices made by the user consuming the content, such as seeking or switching audio tracks or subtitles. Example policies for P2P streaming can be found in [BITOS], and [EPLIVEPERF].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクピッキングアルゴリズムはPPSPPの外部にあり、一般PPSPPによって提供されるメカニズムを使用してプラグ可能なポリシーであろう。このアルゴリズムは、このようなオーディオトラックや字幕を求めているか、切り替えなどのコンテンツを消費するユーザによって行われる選択を、処理します。 P2Pストリーミング用のポリシーの例は、[EPLIVEPERF] [BITOS]で見つかった、とすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Reciprocity Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。互恵アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The role of reciprocity algorithms in peer-to-peer systems is to promote client contribution and prevent freeriding. A peer is said to be freeriding if it only downloads content but never uploads to others. Examples of reciprocity algorithms are tit-for-tat as used in BitTorrent [TIT4TAT] and Give-to-Get [GIVE2GET]. In PPSPP, reciprocity enforcement is the sole responsibility of the sending peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア・ツー・ピア・システムでの互恵アルゴリズムの役割は、クライアントの貢献を促進し、フリーライディングを防ぐためです。ピアは、それが唯一のコンテンツダウンロードが、他の人にアップロードしたことがない場合はフリーライディングしていると言われています。互恵アルゴリズムの例は、BitTorrentのに使用されるように[TIT4TAT]しっぺ返しであり、与えるツー入手[GIVE2GET]。 PPSPPでは、相互主義の執行は、送信ピアの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a new top-level registry called &#34;Peer-to-Peer Streaming Peer Protocol (PPSPP)&#34;, which hosts the six new sub-registries defined below for the extensibility of the protocol. For all registries, assignments consist of a name and its associated value. Also, for all registries, the &#34;Unassigned&#34; ranges designated are governed by the policy &#34;IETF Review&#34; as described in [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、プロトコルの拡張のために以下に定義される6つの新しいサブレジストリをホストする「ピアツーピアストリーミングピアプロトコル（PPSPP）」と呼ばれる新しいトップレベル・レジストリを作成しました。すべてのレジストリの場合、割り当ては名前とその値で構成されています。また、すべてのレジストリのために、指定された「未割り当て」の範囲は、ポリシー[RFC5226]で説明したように「IETFレビュー」に支配されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. PPSPP Message Type Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1。 PPSPPメッセージタイプレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry name is &#34;PPSPP Message Type Registry&#34;. Values are integers in the range 0-255, with initial assignments and reservations given in Table 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリ名は「PPSPPメッセージタイプレジストリ」です。値は表7に与えられた初期割り当てと予約で、0〜255の範囲の整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. PPSPP Option Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2。 PPSPPオプションレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry name is &#34;PPSPP Option Registry&#34;. Values are integers in the range 0-255, with initial assignments and reservations given in Table 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリ名は「PPSPPオプションレジストリ」です。値は表2に与えられた初期割り当てと予約で、0〜255の範囲の整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. PPSPP Version Number Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3。 PPSPPバージョン番号のレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry name is &#34;PPSPP Version Number Registry&#34;. Values are integers in the range 0-255, with initial assignments and reservations given in Table 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリ名は「PPSPPバージョン番号登録」です。値は表3に与えられた初期割り当てと予約で、0〜255の範囲の整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. PPSPP Content Integrity Protection Method Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4。 PPSPPコンテンツ完全性保護方法レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry name is &#34;PPSPP Content Integrity Protection Method Registry&#34;. Values are integers in the range 0-255, with initial assignments and reservations given in Table 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリ名は「PPSPPコンテンツの整合性の保護方法レジストリ」です。値を表4に与えられた初期割り当てと予約で、0〜255の範囲の整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. PPSPP Merkle Hash Tree Function Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5。 PPSPPマークルハッシュツリー機能のレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry name is &#34;PPSPP Merkle Hash Tree Function Registry&#34;. Values are integers in the range 0-255, with initial assignments and reservations given in Table 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリ名は「PPSPPマークルハッシュツリー機能のレジストリ」です。値は、表5に与えられた初期割り当てと予約で、0〜255の範囲の整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. PPSPP Chunk Addressing Method Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6。メソッドのレジストリをアドレッシングPPSPPチャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The registry name is &#34;PPSPP Chunk Addressing Method Registry&#34;. Values are integers in the range 0-255, with initial assignments and reservations given in Table 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レジストリ名は「メソッドレジストリアドレッシングPPSPPチャンク」です。値は表6に与えられた初期割り当てと予約で、0〜255の範囲の整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Manageability Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.管理性の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section presents operations and management considerations following the checklist in [RFC5706], Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、付録A [RFC5706]でチェックリスト次の操作及び管理に関する考慮事項を提示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this section, &#34;PPSPP client&#34; is defined as a PPSPP peer acting on behalf of an end user which may not yet have a copy of the content, and &#34;PPSPP server&#34; as a PPSPP peer that provides the initial copies of the content to the swarm on behalf of a content provider.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、「PPSPPクライアント」まだコンテンツのコピーを持っていない可能性があり、エンドユーザーに代わって動作するPPSPPピアとして定義され、およびへのコンテンツの初期コピーを提供PPSPPピアとして「PPSPPサーバ」コンテンツプロバイダの代わりに群れ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1。オペレーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. Installation and Initial Setup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1。インストールと初期設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A content provider wishing to use PPSPP to distribute content should set up at least one PPSPP server. PPSPP servers need to have access to either some static content or some live audio/video sources. To provide flexibility for implementors, this configuration process is not standardized. The output of this process will be a list of metadata records, one for each swarm. A metadata record consists of the swarm ID, the chunk size used, the chunk addressing method used, the content integrity protection method used, and the Merkle hash tree function used (if applicable). If automatic content size detection (see Section 5.6) is not used, the content length is also part of the metadata record for static content. Note the swarm ID already contains the Live Signature Algorithm used, in case of a live stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツを配信するPPSPPの使用を希望するコンテンツプロバイダは、少なくとも一つのPPSPPサーバーを設定する必要があります。 PPSPPサーバは、いくつかの静的なコンテンツまたはいくつかのライブのオーディオ/ビデオソースのいずれかへのアクセス権を持っている必要があります。実装のための柔軟性を提供するために、この設定プロセスが標準化されていません。このプロセスの出力は、メタデータレコードは、各群れに1つのリストになります。メタデータレコードは、群れのID、使用チャンクサイズ、使用されるチャンクのアドレッシング方法、使用されるコンテンツの完全性保護方法、および使用マークルハッシュツリー機能（該当する場合）で構成されています。コンテンツ自動サイズ検知が（セクション5.6を参照）が使用されていない場合、コンテンツの長さは、静的コンテンツのメタデータレコードの一部です。群れのIDが既にライブストリームの場合には、アルゴリズムが使用ライブ署名が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, a content provider should set up a tracking facility for the content by configuring, for example, a peer-to-peer streaming protocol tracker [PPSP-TP] or a Distributed Hash Table. The output of the latter process is a list of transport addresses for the tracking facility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、コンテンツプロバイダは、例えば、設定することにより、コンテンツのトラッキング機能を設定する必要があり、ピア・ツー・ピア・ストリーミング・プロトコル・トラッカ[PPSP-TP]または分散ハッシュテーブル。後者のプロセスの出力は、トラッキング機能のためのトランスポート・アドレスのリストです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The list of metadata records of available content, and transport address for the tracking facility, can be distributed to users in various ways. Typically, they will be published on a website as links. When a user clicks such a link, the PPSPP client is launched, either as a standalone application or by invoking the browser&#39;s internal PPSPP protocol handler, as exemplified in Section 2. The clients use the tracking facility to obtain the transport address of the PPSPP server(s) and other peers from the swarm, executing the peer protocol to retrieve and redistribute the content. The format of the PPSPP URLs should be defined in an extension document. The default protocol options should be exploited to keep the URLs small.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追跡機能のために利用可能なコンテンツのメタデータレコードのリスト、およびトランスポートアドレスは、さまざまな方法でユーザーに配布することができます。一般的に、彼らはリンクとしてウェブサイト上で公開されます。ユーザーは、このようなリンクをクリックすると、セクション2に例示するように、PPSPPクライアントは、クライアントがPPSPPサーバーのトランスポートアドレスを取得するためのトラッキング機能を使用し、スタンドアロンアプリケーションとして、またはブラウザの内部PPSPPプロトコルハンドラを呼び出すことにより、いずれか、起動されます（S）とコンテンツを取得し、再配布するピアプロトコルを実行群れから他のピア、。 PPSPP URLのフォーマットは、拡張ドキュメントで定義されるべきです。デフォルトのプロトコル・オプションは、小さなURLを維持するために利用されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The minimal information a tracking facility must return when queried for a list of peers for a swarm is as follows. Assuming the communication between tracking facility and requester is protected, the facility must at least return for each peer in the list its IP address, transport protocol identifier (i.e., UDP), and transport protocol port number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように群れのためのピアのリストを照会する場合、追跡機能が戻らなければならない最低限の情報があります。リスト内の各ピアのIPアドレスのために必要があり、少なくとも戻り、トランスポート・プロトコル識別子（すなわち、UDP）、およびトランスポートプロトコルのポート番号は施設、トラッキング機能と要求者との間の通信が保護されていると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2. Migration Path
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2。移行パス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not detail a migration path since there is no previous standard protocol providing similar functionality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様の機能を提供する以前の標準プロトコルが存在しないので、この文書ではなく、詳細な移行パスを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3. Requirements on Other Protocols and Functional Components
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3。その他のプロトコルと機能コンポーネントの要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using the peer-to-peer streaming protocol tracker, PPSPP requires a specific behavior from this protocol for security reasons, as detailed in Section 12.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア・ツー・ピアストリーミングプロトコルトラッカーを使用する場合は、PPSPPは12.2節で説明するように、セキュリティ上の理由により、このプロトコルから特定の動作を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.4. Impact on Network Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.4。ネットワークオペレーションへの影響
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP is a peer-to-peer protocol that takes advantage of the fact that content is available from multiple sources to improve robustness, scalability, and performance. At the same time, poor choices in determining which exact sources to use can lead to bad experience for the end user and high costs for network operators. Hence, PPSPP can benefit from the ALTO protocol to steer peer selection, as described in Section 3.10.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPは、コンテンツが堅牢性、スケーラビリティ、及びパフォーマンスを改善するために、複数のソースから利用可能であるという事実を利用するピア・ツー・ピア・プロトコルです。同時に、使用するソースを正確な決定の貧しい選択肢は、エンドユーザとネットワーク事業者のための高コストのために悪い経験につながることができます。したがって、PPSPPはセクション3.10.1に記載されているように、ピア選択を操縦するALTOプロトコルから利益を得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.5. Verifying Correct Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.5。正しい動作を確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP is operating correctly when all peers obtain the desired content on time. Therefore, the PPSPP client is the ideal location to verify the protocol&#39;s correct operation. However, it is not feasible to mandate logging the behavior of PPSPP peers in all implementations and deployments, for example, due to privacy reasons. There are two alternative options:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのピアが時間に所望のコンテンツを取得する際PPSPPが正常に動作しています。したがって、PPSPPクライアントは、プロトコルの正しい動作を確認するのに理想的な場所です。しかし、原因プライバシー上の理由に、例えば、すべての実装および展開でPPSPPピアの行動をロギング強制することは不可能です。二つの代替オプションがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Monitoring the PPSPP servers initially providing the content, using standard metrics such as bandwidth usage, peer connections, and activity, can help identify trouble, see next section and [RFC2564].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初PPSPPサーバ監視コンテンツを提供するO、そのような帯域幅の使用、ピア接続、および活動などの標準的な指標を用いて、次のセクションと[RFC2564]を参照して、トラブルを特定するのに役立つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The tracker protocol [PPSP-TP] may be used to gather information about all peers in a swarm, to obtain a global view of operation, according to PPSP.OAM.REQ-3 in [RFC6972].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oを追跡プロトコル[PPSP-TP]は[RFC6972]でPPSP.OAM.REQ-3によれば、操作のグローバルなビューを得るために、群れにおけるすべてのピアに関する情報を収集するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Basic operation of the protocol can be easily verified when a tracker and swarm metadata are known by starting a PPSPP download. Deep packet inspection for DATA and ACK messages help to establish that actual content transfer is happening and that the chunk availability signaling and integrity checking are working.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トラッカーと群れのメタデータがPPSPPのダウンロードを開始することで知られているとき、プロトコルの基本的な操作を容易に確認することができます。 DATA及びACKメッセージのためのディープパケットインスペクションは、実際のコンテンツの転送が起こっていることと、チャンクの可用性シグナリングとの整合性チェックが機能していることを証明するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.6. Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.6。設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 8 shows the PPSPP parameters, their defaults, and where the parameter is defined. For parameters that have no default, the table row contains the word &#34;var&#34; and refers to the section discussing the considerations to make when choosing a value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表8はPPSPPパラメータ、それらのデフォルト値を示しており、パラメータがどこに定義されています。デフォルトを持っていないパラメータについては、表の行は、単語「VAR」が含まれ、値を選択する際に作成する注意事項を議論するセクションを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------+-----------------------+-----------------+
   | Name                    | Default               | Definition      |
   +-------------------------+-----------------------+-----------------+
   | Chunk Size              | var, 1024 bytes       | Section 8.1     |
   |                         | recommended           |                 |
   |                         |                       |                 |
   | Static Content          | 1 (Merkle Hash Tree)  | Section 7.5     |
   | Integrity Protection    |                       |                 |
   | Method                  |                       |                 |
   |                         |                       |                 |
   | Live Content Integrity  | 3 (Unified Merkle     | Section 7.5     |
   | Protection Method       | Tree)                 |                 |
   |                         |                       |                 |
   | Merkle Hash Tree        | 2 (SHA-256)           | Section 7.6     |
   | Function                |                       |                 |
   |                         |                       |                 |
   | Live Signature          | 13 (ECDSAP256SHA256)  | Section 7.7     |
   | Algorithm               |                       |                 |
   |                         |                       |                 |
   | Chunk Addressing Method | 2 (32-bit chunk       | Section 7.8     |
   |                         | ranges)               |                 |
   |                         |                       |                 |
   | Live Discard Window     | var                   | Section 6.2,    |
   |                         |                       | Section 7.9     |
   |                         |                       |                 |
   | NCHUNKS_PER_SIG         | var                   | Section 6.1.2.1 |
   |                         |                       |                 |
   | Dead peer detection     | No reply in 3 minutes | Section 3.12    |
   |                         | + 3 datagrams         |                 |
   +-------------------------+-----------------------+-----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
Table 8: PPSPP Defaults
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
表8：PPSPPデフォルト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Management Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2。管理上の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The management considerations for PPSPP are very similar to other protocols that are used for large-scale content distribution, in particular HTTP. How does one manage large numbers of servers? How does one push new content out to a server farm and allows staged releases? How are faults detected and how are servers and end-user performance measured? As standard solutions to these challenges are still being developed, this section cannot provide a definitive recommendation on how PPSPP should be managed. Hence, it describes the standard solutions available at this time and assumes a future extension document will provide more complete guidelines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPの管理の考慮事項は、特定のHTTPで、大規模コンテンツ配信のために使用される他のプロトコルと非常に類似しています。どのようにして多数のサーバーを管理していますか？どのようにして、サーバーファームに新しいコンテンツを押し出すないとのリリースを上演でき？どのように障害が検出され、どのようにサーバとエンドユーザのパフォーマンスを測定していますか？これらの課題への標準溶液は、まだ開発されているように、このセクションでは、PPSPPが管理すべきかについて明確な推奨事項を提供することはできません。したがって、現時点で入手可能な標準のソリューションを説明し、将来の拡張の文書は、より完全なガイドラインを提供します想定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.1. Management Interoperability and Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.1。管理の相互運用性と情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As just stated, PPSPP servers providing initial copies of the content are akin to WWW and FTP servers. They can also be deployed in large numbers and thus can benefit from standard management facilities. Therefore, PPSPP servers may implement an SNMP management interface based on the APPLICATION-MIB [RFC2564], where the file object can be used to report on swarms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ちょうど述べたように、コンテンツの初期コピーを提供PPSPPサーバは、WWWやFTPサーバに似ています。彼らはまた、大量に配備することができ、したがって、標準の管理機能の恩恵を受けることができます。したがって、PPSPPサーバは、ファイルオブジェクトが群れに報告するために使用することができるアプリケーションMIB [RFC2564]に基づいて、SNMP管理インタフェースを実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
What is missing is the ability to remove or rate limit specific PPSPP swarms on a server. This corresponds to removing or limiting specific virtual servers on a web server. In other words, as multiple pieces of content (swarms, virtual WWW servers) are multiplexed onto a single server process, more fine-grained management of that process is required. This functionality is currently missing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何行方不明であることは、サーバー上の特定のPPSPPの群れを削除するか、またはレート制限する機能です。これは、Webサーバー上の特定の仮想サーバーを削除するか、制限に対応しています。換言すれば、コンテンツ（群れ、仮想WWWサーバ）のような複数のピースが単一のサーバプロセスに多重化され、そのプロセスのよりきめ細かな管理が必要です。この機能は、現在不足しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Logging is an important functionality for PPSPP servers and, depending on the deployment, PPSPP clients. Logging should be done via syslog [RFC5424].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロギングはPPSSPPサーバのための重要な機能であると、展開、PPSSPPクライアントに依存します。ログは、syslog [RFC5424]を経由して行われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.2. Fault Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.2。障害管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The facilities for verifying correct operation and server management (just discussed) appear sufficient for PPSPP fault monitoring. This can be supplemented with host resource [RFC2790] and UDP/IP network monitoring [RFC4113], as PPSPP server failures can generally be attributed directly to conditions on the host or network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正しい操作とサーバーの管理（単に議論を）確認するための設備がPPSPPの障害監視のための十分な表示されます。 PPSPPサーバの障害は、一般的にホストまたはネットワーク上の条件に直接帰することができるので、これは、ホストリソース[RFC2790]及びUDP / IPネットワーク監視[RFC4113]を補充することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since PPSPP has been designed to work in a hostile environment, many benign faults will be handled by the mechanisms used for managing attacks. For example, when a malfunctioning peer starts sending the wrong chunks, this is detected by the content integrity protection mechanism and another source is sought.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPが敵対的な環境で動作するように設計されていますので、多くの良性の故障が攻撃を管理するために使用されるメカニズムによって処理されます。誤動作ピアが間違っているチャンクの送信を開始すると、例えば、これは、コンテンツの完全性の保護メカニズムによって検出され、別のソースが求められています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.3. Configuration Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.3。構成管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Large-scale deployments may benefit from a standard way of replicating a new piece of content on a set of initial PPSPP servers. This functionality may need to include controlled releasing, such that content becomes available only at a specific point in time (e.g., the release of a movie trailer). This functionality could be provided via NETCONF [RFC6241], to enable atomic configuration updates over a set of servers. Uploading the new content could be one configuration change, making the content available for download by the public another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大規模な展開では、最初のPPSPPサーバーのセット上のコンテンツの新しい作品を複製する標準的な方法から利益を得ることができます。この機能は、コンテンツが唯一の特定の時点で利用可能となるように、離型制御含める必要があり（例えば、映画の予告編のリリース）。この機能は、サーバのセットに対してアトミック構成の更新を可能にするために、NETCONF [RFC6241]を介して提供することができます。新しいコンテンツをアップロードすると、別のパブリックにより、ダウンロード用コンテンツが利用できるように、1つの設定を変更する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.4. Accounting Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.4。会計管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Content providers may offer PPSPP hosting for different customers and will want to bill these customers, for example, based on bandwidth usage. This situation is a common accounting scenario, similar to billing per virtual server for web servers. PPSPP can therefore benefit from general standardization efforts in this area [RFC2975] when they come to fruition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツプロバイダは、さまざまな顧客のためのホスティングPPSPPを提供することがありますし、帯域幅の使用状況に基づいて、例えば、これらの顧客に請求することになるでしょう。この状況は、Webサーバーの仮想サーバーごとの課金と同様に、共通の会計シナリオです。 PPSPPそのため、彼らが結実に来たときに、この領域[RFC2975]での一般的な標準化の努力の恩恵を受けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.5. Performance Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.5。パフォーマンス管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the deployment scenarios, the application performance measurement facilities of [RFC3729] and associated [RFC4150] can be used with PPSPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
展開シナリオに応じて、[RFC3729]と関連する[RFC4150]のアプリケーションパフォーマンス測定設備はPPSPPと共に使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, when the PPSPP tracker protocol is used, it provides a built-in, application-level, performance measurement infrastructure for different metrics. See PPSP.OAM.REQ-3 in [RFC6972].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、PPSPP追跡プロトコルが使用される場合、それは別のメトリックの組み込み、アプリケーションレベル、性能測定インフラストラクチャを提供します。 [RFC6972]でPPSP.OAM.REQ-3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.6. Security Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.6。セキュリティ管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Malicious peers should ideally be locked out long term. This is primarily for performance reasons, as the protocol is robust against attacks (see next section). Section 12.7 describes a procedure for long-term exclusion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
悪意のあるピアは、理想的には、長期的にロックアウトされるべきです。プロトコルは、（次のセクションを参照）攻撃に対して堅牢であり、これは、パフォーマンス上の理由から、主です。 12.7節は、長期的な除外のための手順を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As any other network protocol, PPSPP faces a common set of security challenges. An implementation must consider the possibility of buffer overruns, DoS attacks and manipulation (i.e., reflection attacks). Any guarantee of privacy seems unlikely, as the user is exposing its IP address to the peers. A probable exception is the case of the user being hidden behind a public NAT or proxy. This section discusses the protocol&#39;s security considerations in detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のネットワークプロトコルとして、PPSPPは、セキュリティ上の課題の共通セットに直面しています。実装は、バッファオーバーラン、DoS攻撃と操作（すなわち、反射攻撃）の可能性を考慮しなければなりません。ユーザーがピアにそのIPアドレスを公開しているとして、プライバシーのいずれかの保証は、考えにくいです。可能性の例外は、パブリックNATやプロキシの背後に隠されているユーザーの場合です。このセクションでは、詳細にプロトコルのセキュリティの考慮事項について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. Security of the Handshake Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1。ハンドシェイク手順のセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Borrowing from the analysis in [RFC5971], the PPSPP may be attacked with three types of denial-of-service attacks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5971]での解析から借りて、PPSPPは、サービス拒否攻撃の3種類で攻撃することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. DoS amplification attack: attackers try to use a PPSPP peer to generate more traffic to a victim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. DoS攻撃増幅攻撃：攻撃者が被害者へのより多くのトラフィックを生成するPPSPPピアを使用するようにしてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. DoS flood attack: attackers try to deny service to other peers by allocating lots of state at a PPSPP peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.のDoSフラッド攻撃：攻撃者はPPSPPピアの状態の多くを割り当てることにより、他のピアへのサービスを拒否してみてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Disrupt service to an individual peer: attackers send bogus, e.g., REQUEST and HAVE messages appearing to come from victim Peer A to the Peers B1..Bn serving that peer. This causes Peer A to receive chunks it did not request or to not receive the chunks it requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.個々のピアにサービスを中断：攻撃者がそのピアにサービスを提供するピアB1..Bnに被害者ピアAから来たように見えるメッセージを偽の、例えば、要求を送信し、HAVE。これは要求しなかったか、要求されたチャンクを受信しないためにチャンクを受信するピアAが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic scheme to protect against these attacks is the use of a secure handshake procedure. In the UDP encapsulation, the handshake procedure is secured by the use of randomly chosen channel IDs as follows. The channel IDs must be generated following the requirements in [RFC4960] (Section 5.1.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの攻撃から保護するための基本的な仕組みは、安全なハンドシェイク手順を使用することです。次のようにUDPカプセル化では、ハンドシェイク手順がランダムに選択されたチャネルIDを使用することによって固定されています。チャネルIDは、[RFC4960]（セクション5.1.3）の要求後に生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When UDP is used, all datagrams carrying PPSPP messages are prefixed with a 4-byte channel ID. These channel IDs are random numbers, established during the handshake phase as follows. Peer A initiates an exchange with Peer B by sending a datagram containing a HANDSHAKE message prefixed with the channel ID consisting of all zeros. Peer A&#39;s HANDSHAKE contains a randomly chosen channel ID, chanA:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPを使用する場合は、PPSPPメッセージを運ぶすべてのデータグラムは、4バイトのチャネルIDが付いています。これらのチャネルIDは次のようにハンドシェークフェーズ確立乱数、あります。ピアAは、すべてゼロからなるチャネルID接頭辞ハンドシェークメッセージを含むデータグラムを送信することによって、ピアBとの交換を開始します。 Aのハンドシェイクがランダムに選ばれたチャンネルID、チャナが含まれていますピア：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A-&gt;B: chan0 + HANDSHAKE(chanA) + ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A-&gt; B：chan0 +ハンドシェーク（チャナ）+ ...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When Peer B receives this datagram, it creates some state for Peer A, that at least contains the channel ID chanA. Next, Peer B sends a response to Peer A, consisting of a datagram containing a HANDSHAKE message prefixed with the chanA channel ID. Peer B&#39;s HANDSHAKE contains a randomly chosen channel ID, chanB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアBは、このデータグラムを受信すると、少なくともチャネルIDチャナが含まれていることを、ピアAのためのいくつかの状態を作成します。次に、ピアBはチャナチャネルID接頭辞ハンドシェークメッセージを含むデータグラムからなる、ピアに応答を送信します。ピアBのハンドシェイクがchanB、ランダムに選択したチャンネルのIDが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B-&gt;A: chanA + HANDSHAKE(chanB) + ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B-&gt; A：チャナ+ハンドシェーク（寝室）+ ...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer A now knows that Peer B really responds, as it echoed chanA. So the next datagram that Peer A sends may already contain heavy payload, i.e., a chunk. This next datagram to Peer B will be prefixed with the chanB channel ID. When Peer B receives this datagram, both peers have the proof they are really talking to each other, the three-way handshake is complete. In other words, the randomly chosen channel IDs act as tags (cf. [RFC4960] (Section 5.1)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはチャナをエコーとして今、ピアBが実際に応答することを知っているピア。だから、Aはすでに重いペイロード、すなわち、チャンクが含まれていてもよい送信ピア次のデータグラム。ピアBにこの次のデータグラムがchanBチャンネルIDの接頭辞を付けることになります。ピアBはこのデータグラムを受信すると、両方のピアが、彼らは本当にお互いに話している証拠を持って、3ウェイハンドシェイクが完了します。換言すれば、ランダムに選択されたチャネルIDは、タグ（参照[RFC4960]（セクション5.1））として作用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A-&gt;B: chanB + HAVE + DATA + ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A-&gt; B：chanB + +データ+を持っています...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.1. Protection against Attack 1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.1。攻撃1に対する保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In short, PPSPP does a so-called return routability check before heavy payload is sent. This means that attack 1 is fended off: PPSPP does not send back much more data than it received, unless it knows it is talking to a live peer. Attackers sending a spoofed HANDSHAKE to Peer B pretending to be Peer A now need to intercept the message from Peer B to Peer A to get Peer B to send heavy payload, and ensure that that heavy payload goes to the victim, something assumed too hard to be a practical attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要するに、PPSPPは重いペイロードが送信される前に、いわゆるリターン・ルータビリティ・チェックを行います。 PPSPPは戻って、それが受け取ったよりもはるかに多くのデータを送信しない、それがライブピアに話している知っていない限り、これは攻撃1がオフfendedされることを意味します。偽装されたハンドシェイクを送信する攻撃者は今重いペイロードを送信するためにピアBを取得するためにピアツーピアBからのメッセージを傍受し、その重いペイロードが被害者になっていることを確認する必要があるピアを装ってBにあまりにもハードと仮定何かをピアに実用的な攻撃をすること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note the rule is that no heavy payload may be sent until the third datagram. This has implications for PPSPP implementations that use chunk addressing schemes that are verbose. If a PPSPP implementation uses large bitmaps to convey chunk availability, these may not be sent by Peer B in the second datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルールがない重いペイロードは、第三のデータグラムまで送信されなくてもよいことに注意してください。これは冗長でチャンクアドレス指定方式を使用しPPSPP実装の意味を持ちます。 PPSPP実装はチャンク利用可能性を伝えるために、大きなビットマップを使用する場合、これらは、第二のデータグラムでピアBによって送信されなくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.2. Protection against Attack 2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.2。攻撃2に対する保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving the first datagram Peer B will record some state about Peer A. At present, this state consists of the chanA channel ID, and the results of processing the other messages in the first datagram. In particular, if Peer A included some HAVE messages, Peer B may add a chunk availability map to Peer A&#39;s state. In addition, Peer B may request some chunks from Peer A in the second datagram, and Peer B will maintain state about these outgoing requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在ピアA.に関するいくつかの状態を記録する最初のデータグラムピアBを受信すると、この状態はチャナチャネルIDからなり、最初のデータグラム内の他のメッセージを処理した結果。ピアAは、いくつかのメッセージを持っている含まれている場合特に、ピアBはAの状態をピアするチャンクの可用性マップを追加することができます。また、ピアBは、第二のデータグラム内のピアAからいくつかのチャンクを要求することができる、とピアBは、これらの発信要求に関する状態を維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So presently, PPSPP is somewhat vulnerable to attack 2. An attacker could send many datagrams with HANDSHAKEs and HAVEs and thus allocate state at the PPSPP peer. Therefore, Peer A MUST respond immediately to the second datagram, if it is still interested in Peer B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
だから、現在、PPSPPは、攻撃者が握手し、持てる者と多くのデータグラムを送信するため、PPSPPピアの状態を割り当てることができ2.攻撃がやや脆弱です。それはまだピアB.に興味がある場合はそのため、ピアAは、第二のデータグラムに即座に応答しなければなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reason for using this slightly vulnerable three-way handshake instead of the safer handshake procedure of Stream Control Transmission Protocol (SCTP) [RFC4960] (Section 5.1) is quicker response time for the user. In the SCTP procedure, Peers A and B cannot request chunks until datagrams 3 and 4 respectively, as opposed to 2 and 1 in the proposed procedure. This means that the user has to wait less time in PPSPP between starting the video stream and seeing the first images.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代わりにストリーム制御伝送プロトコル（SCTP）[RFC4960]（セクション5.1）のより安全なハンドシェイク手順のこのわずかに脆弱なスリーウェイハンドシェイクを使用する理由は、ユーザのために迅速な応答時間です。提案された手順2と1とは対照的に、SCTP手順において、ピアA及びBは、それぞれ、データグラム3及び4までのチャンクを要求することができません。これは、ユーザーがビデオストリームを開始し、最初の画像を見て間PPSPPに少ない時間を待たなければならないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.3. Protection against Attack 3
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.3。アタック3に対する保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, channel IDs serve to authenticate a peer. Hence, to attack, a malicious Peer T would need to be able to eavesdrop on conversations between victim A and a benign Peer B to obtain the channel ID Peer B assigned to Peer A, chanB. Furthermore, attacker Peer T would need to be able to spoof, e.g., REQUEST and HAVE messages from Peer A to cause Peer B to send heavy DATA messages to Peer A, or prevent Peer B from sending them, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的には、チャネルIDは、ピアを認証するのに役立ちます。したがって、攻撃する、悪意のあるピアTはA、chanBピアに割り当てられたチャネルIDピアBを得るために、被害者Aおよび良性ピアBとの間の会話を盗聴できるようにする必要があります。また、攻撃者ピアTは、それぞれ、ピア、又はそれらを送信ピアBを防止するために、重いデータメッセージを送信するピアBを引き起こすこと、例えば、要求を偽装し、ピアAからのメッセージを有することができるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The capability to eavesdrop is not common, so the protection afforded by channel IDs will be sufficient in most cases. If not, point-to-point encryption of traffic should be used, see below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
盗聴する機能は一般的ではありませんので、チャネルIDによる保護は、ほとんどのケースで十分であろう。ない場合は、トラフィックのポイント・ツー・ポイントの暗号化を使用する必要があり、以下を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. Secure Peer Address Exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2。セキュアピアアドレス交換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 3.10, Peer A can send Peer-Exchange messages PEX_RES to Peer B, which contain the IP address and port of other peers that are supposedly also in the current swarm. The strength of this mechanism is that it allows decentralized tracking: after an initial bootstrap, no central tracker is needed. The vulnerability of this mechanism (and DHTs) is that malicious peers can use it for an Amplification attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.10節で説明したように、ピアAは、現在の群れにもたぶんある他のピアのIPアドレスとポートが含まれているBを、ピアツーピア交換メッセージPEX_RESを送ることができます。このメカニズムの強みは、分散型追跡を可能とすることである：初期ブートストラップの後、何の中央トラッカーは必要ありません。このメカニズム（とのDHT）の脆弱性は、悪意のあるピアが増幅攻撃のためにそれを使用することができるということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular, a malicious Peer T could send PEX_RES messages to well-behaved Peer A with addresses of Peers B1..Bn; on receipt, Peer A could send a HANDSHAKE to all these peers. So, in the worst case, a single datagram results in N datagrams. The actual damage depends on Peer A&#39;s behavior. For example, when Peer A already has sufficient connections, it may not connect to the offered ones at all; but if it is a fresh peer, it may connect to all directly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に、悪意のあるピアTは、ピアB1..Bnのアドレスで行儀ピアAにPEX_RESメッセージを送ることができます。領収書に、ピアAは、これらすべてのピアにハンドシェイクを送信することができます。だから、最悪の場合には、N個のデータグラムにおける単一のデータグラムの結果。実際の被害は、ピアAの動作に依存します。ピアAは、すでに十分な接続を持っている場合たとえば、それがすべてで提供されたものに接続することはできません。それは新鮮なピアがある場合は、それはすべて直接に接続することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, PEX can be used in Eclipse attacks [ECLIPSE] where malicious peers try to isolate a particular peer such that it only interacts with malicious peers. Let us distinguish two specific attacks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、PEXは、悪意のあるピアがそれだけ悪意のあるピアと相互作用するように、特定のピアを分離しようとするEclipseの攻撃[ECLIPSE]で使用することができます。私たちは2回の特定の攻撃を区別してみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
E1. Malicious peers try to eclipse the single injector in live streaming.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
E1。悪意のあるピアはライブストリーミングで単一のインジェクタを日食してみてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
E2. Malicious peers try to eclipse a specific consumer peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
E2。悪意のあるピアは、特定の消費者ピアを日食してみてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attack E1 has the most impact on the system as it would disrupt all peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃E1は、それがすべてのピアを乱すとしてシステムに最も影響を与えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.1. Protection against the Amplification Attack
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.1。増幅攻撃に対する保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If peer addresses are relatively stable, strong protection against the attack can be provided by using public key cryptography and certification. In particular, a PEX_REScert message will carry swarm-membership certificates rather than IP address and port. A membership certificate for Peer B states that Peer B at address (ipB,portB) is part of Swarm S at Time T and is cryptographically signed. The receiver Peer A can check the certificate for a valid signature, the right swarm and liveliness, and only then consider contacting Peer B. These swarm-membership certificates correspond to signed node descriptors in secure decentralized peer sampling services [SPS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアアドレスは比較的安定している場合、攻撃に対する強力な保護は、公開鍵暗号化と認証を使用することにより提供することができます。特に、PEX_REScertメッセージは群れメンバーシップ証明書ではなく、IPアドレスとポートを運ぶでしょう。アドレスにBピアピアB状態（IPB、PORTB）のメンバーシップ証明書は、時刻Tにおける群発Sの一部であり、暗号署名されています。受信ピアAは、有効な署名のための右の群れと活気の証明書を確認することができ、そしてだけにして接触ピアBを考えるこれらの群れメンバーシップ証明書は、[SPS]安全な分散型のピアサンプリングサービスで署名されたノード記述子に対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several designs are possible for the security environment for these membership certificates. That is, there are different designs possible for who signs the membership certificates and how public keys are distributed. As an example, we describe a design where the peer-to-peer streaming protocol tracker acts as certification authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのデザインは、これらの会員証明書のセキュリティ環境のために可能です。これは、メンバーシップ証明書に署名し、公開鍵がどのように分布している人のための可能な種類のデザインがあり、あります。例として、我々は、ピア・ツー・ピアストリーミングプロトコルトラッカーは、認証局として動作する設計を記述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.2. Example: Tracker as Certification Authority
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.2。例：認証局としてトラッカー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer A wanting to join Swarm S sends a certificate request message to a Tracker X for that swarm. Upon receipt, the tracker creates a membership certificate from the request with Swarm ID S, a Timestamp T, and the external IP and port it received the message from, signed with the tracker&#39;s private key. This certificate is returned to Peer A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スウォームSに参加したいピアは、その群れのためのトラッカーXに証明書要求メッセージを送信します。受信すると、トラッカーは、トラッカーの秘密鍵で署名からメッセージを受け取ったスウォームID Sとの要求から、会員証明書、タイムスタンプT、および外部IPとポートを作成します。この証明書は、ピアAに返されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer A then includes this certificate when it sends a PEX_REScert to Peer B. Receiver Peer B verifies it against the tracker public key. This tracker public key should be part of the swarm&#39;s metadata, which Peer B received from a trusted source. Subsequently, Peer B can send the member certificate of Peer A to other peers in PEX_REScert messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはB.受信ピアBは、トラッカー公開キーに対してそれを検証するためにピアPEX_REScertを送信した場合、この証明書を含むピア。このトラッカー公開鍵は、Bは、信頼できるソースから受け取ったピア群れのメタデータの一部である必要があります。その後、ピアBはPEX_REScertメッセージ内の他のピアにピアAのメンバー証明書を送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer A can send the certification request when it first contacts the tracker or at a later time. Furthermore, the responses the tracker sends could contain membership certificates instead of plain addresses, such that they can be gossiped securely as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ときに最初に接触するトラッカー以降の時点でピアAは、認証要求を送信することができます。さらに、回答トラッカーは、彼らが同様にしっかりと噂され得るように、会員証明書の代わりに、プレーンなアドレスが含まれている可能性が送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We assume the tracker is protected against attacks and does a return routability check. The latter ensures that malicious peers cannot obtain a certificate for a random host, just for hosts where they can eavesdrop on incoming traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、トラッカーが攻撃から保護され、リターンルータビリティチェックをしていると仮定します。後者は、ちょうど彼らが着信トラフィックを盗聴することができますホストに対して、悪意のあるピアがランダムホスト用の証明書を取得できないことを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The load generated on the tracker depends on churn and the lifetime of a certificate. Certificates can be fairly long lived, given that the main goal of the membership certificates is to prevent that malicious Peer T can cause good Peer A to contact *random* hosts. The freshness of the timestamp just adds extra protection in addition to achieving that goal. It protects against malicious hosts causing a good Peer A to contact hosts that previously participated in the swarm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トラッカーに発生する負荷を解約し、証明書の有効期間によって異なります。証明書はかなり長い会員証明書の主な目的は、悪意のあるピアT *はランダム*ホストに連絡するのは良いピアAを引き起こす可能性があることを防ぐためであることを考えると、住んでいたことができます。タイムスタンプの鮮度はちょうどその目標を達成するために加えて、特別な保護を追加します。これは、以前に群れに参加したホストに連絡するのは良いピアAを引き起こし、悪意のあるホストから保護します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The membership certificate mechanism itself can be used for a kind of amplification attack against good peers. Malicious Peer T can cause Peer A to spend some CPU to verify the signatures on the membership certificates that Peer T sends. To counter this, Peer A SHOULD check a few of the certificates sent and discard the rest if they are defective.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会員証メカニズム自体は良いピアに対する増幅攻撃の種類のために使用することができます。悪意のあるピアTはTが送信するピアメンバーシップの証明書の署名を検証するために、いくつかのCPUを過ごすためにピアAを引き起こす可能性があります。これに対抗するには、ピアAは、送信された証明書の数をチェックして、彼らは欠陥がある場合、残りを捨てるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same membership certificates described above can be registered in a Distributed Hash Table that has been secured against the well-known DHT specific attacks [SECDHTS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記と同じメンバーシップ証明書は、よく知られたDHT特定の攻撃[SECDHTS]に対して固定された分散ハッシュテーブルに登録することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this scheme does not work for peers behind a symmetric Network Address Translator, but neither does normal tracker registration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方式は、対称ネットワークアドレス変換の背後にあるピアのために動作しないことに注意してください、しかし、どちらも通常のトラッカー登録を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.3. Protection against Eclipse Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.3。 Eclipseの攻撃に対する保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before we can discuss Eclipse attacks, we first need to establish the security properties of the central tracker. A tracker is vulnerable to Amplification attacks, too. A malicious Peer T could register a victim Peer B with the tracker, and many peers joining the swarm will contact Peer B. Trackers can also be used in Eclipse attacks. If many malicious peers register themselves at the tracker, the percentage of bad peers in the returned address list may become high. Leaving the protection of the tracker to the peer-to-peer streaming protocol tracker specification [PPSP-TP], we assume for the following discussion that it returns a true random sample of the actual swarm membership (achieved via Sybil attack protection). This means that if 50% of the peers are bad, you&#39;ll still get 50% good addresses from the tracker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちはEclipseの攻撃を議論する前に、まず、中央トラッカーのセキュリティプロパティを確立する必要があります。トラッカーは、あまりにも、増幅攻撃に対して脆弱です。悪意のあるピアTは、トラッカーと被害者ピアBを登録することができ、およびピアB.トラッカー連絡いたし群れに参加する多くのピアはまた、Eclipseの攻撃に使用することができます。多くの悪意のあるピアがトラッカーに自身を登録した場合、返されたアドレスのリストの中の悪いピアの割合が高くなることがあります。ピア・ツー・ピアストリーミングプロトコルトラッカー仕様[PPSP-TP]にトラッカーの保護を残し、我々はそれが（シビル攻撃からの保護を介して実現）実際の群れのメンバーの真のランダムなサンプルを返す以下の議論のための前提としています。これは、ピアの50％が不良である場合、あなたはまだトラッカーから50％の良好なアドレスを取得しますことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attack E1 on PEX can be fended off by letting live injectors disable PEX -- or at least, letting live injectors ensure that part of their connections are to peers whose addresses came from the trusted tracker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ライブインジェクタがその接続の一部が、アドレスが信頼できるトラッカーから来た仲間にしていることを確認させる、少なくともまたは -  PEXへの攻撃E1は、ライブインジェクタはPEXを無効にさせることにより、オフfendedすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same measures defend against attack E2 on PEX. They can also be employed dynamically. When the current set of Peers B that Peer A is connected to doesn&#39;t provide good quality of service, Peer A can contact the tracker to find new candidates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ措置はPEXの攻撃E2から守ります。彼らはまた、動的に使用することができます。そのピアAが接続されているBピアの現在のセットは、サービスの良い品質を提供しない場合は、ピアAは、新たな候補者を見つけるためにトラッカーに連絡することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. Support for Closed Swarms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3。クローズ群れのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regarding PPSP.SEC.REQ-1 in [RFC6972], the Closed Swarms [CLOSED] and Enhanced Closed Swarms [ECS] mechanisms provide swarm-level access control. The basic idea is that a peer cannot download from another peer unless it shows a Proof-of-Access. Enhanced Closed Swarms improve on the original Closed Swarms by adding on-the-wire encryption against man-in-the-middle attacks and more flexible access control rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6972]にPPSP.SEC.REQ-1について、クローズ群れ[CLOSED]および拡張クローズド群れ[ECS]メカニズムは、群れレベルのアクセス制御を提供します。基本的な考え方は、それが証明-のアクセスを示していない限り、ピアは別のピアからダウンロードすることができないということです。強化されたクローズド群れがman-in-the-middle攻撃と、より柔軟なアクセス制御ルールに対してオン・ワイヤー暗号化を追加することで、元のクローズド群れに向上させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The exact mapping of ECS to PPSPP is defined in [ECS-protocol].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPにECSの正確なマッピングは、[ECSプロトコル]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4. Confidentiality of Streamed Content
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4。ストリームコンテンツの機密性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regarding PPSP.SEC.REQ-1 in [RFC6972], no extra mechanism is needed to support confidentiality in PPSPP. A content publisher wishing confidentiality should just distribute content in ciphertext and/or in a format to which Digital Rights Management (DRM) techniques have been applied. In that case, it is assumed a higher layer handles key management out-of-band. Alternatively, pure point-to-point encryption of content and traffic can be provided by the proposed Closed Swarms access control mechanism, by DTLS [RFC6347], or by IPsec [RFC4301].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSP.SEC.REQ-1 [RFC6972]でについては、余分なメカニズムはPPSPPで機密性をサポートするために必要はありません。機密性を希望するコンテンツ発行者は、単に暗号文および/またはデジタル著作権管理（DRM）技術が適用されたフォーマットでコンテンツを配信する必要があります。その場合には、より高い層がアウトオブバンドの鍵管理を扱うものとします。代替的に、コンテンツ及びトラフィックの純粋なポイントツーポイント暗号化が提案されているクローズ群れアクセス制御機構によって、DTLS [RFC6347]によって、またはIPsecの[RFC4301]によって提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When transmitting over DTLS, PPSPP can obtain the PMTU estimate maintained by the IP layer to determine how much payload can be put in a single datagram without fragmentation ([RFC6347], Section 4.1.1.1). If PMTU changes and the chunk size becomes too large to fit into a single datagram, PPSPP can choose to allow fragmentation by clearing the Don&#39;t Fragment (DF) bit. Alternatively, the content publisher can decide to use smaller chunks and transmit multiple in the same datagram when the MTU allows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DTLSにわたって送信するとき、PPSPPが断片化することなく、単一のデータグラムに入れることができるどのくらいのペイロードを決定するためにIPレイヤによって維持PMTU推定値を得ることができる（[RFC6347]、セクション4.1.1.1）。 PMTUの変更とチャンクサイズは、単一のデータグラムの中に収まるように大きくなりすぎると、PPSPPはDo not Fragment（DF）ビットをクリアすることで断片化を許可することを選択することができます。また、コンテンツ発行者は、小さな塊を使用して、MTUが許すときに、同じデータグラムに複数を送信することを決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5. Strength of the Hash Function for Merkle Hash Trees
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5。マークルハッシュ木のハッシュ関数の強度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST support SHA-1 as the hash function for content integrity protection via Merkle hash trees. SHA-1 may be preferred over stronger hash functions by content providers because it reduces on-the-wire overhead. As such, it presents a trade-off between performance and security. The security considerations for SHA-1 are discussed in [RFC6194].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装はマークルハッシュ木を介してコンテンツの完全性保護のためのハッシュ関数としてSHA-1をサポートしなければなりません。それはオン・ザ・ワイヤオーバーヘッドを減少させるため、SHA-1は、コンテンツプロバイダによって強いハッシュ関数よりも好ましいです。このように、それは、パフォーマンスとセキュリティの間のトレードオフを提示しています。 SHA-1のためのセキュリティ問題は[RFC6194]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, note that the hash function is used in a hash tree, which makes it more complex to create collisions. In particular, if attackers manage to find a collision for a hash, it can replace just one chunk, so the impact is limited. If fixed-size chunks are used, the collision even has to be of the same size as the original chunk. For hashes higher up in the hash tree, a collision must be a concatenation of two hashes. In sum, finding collisions that fit with the hash tree are generally harder to find than regular collisions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的には、ハッシュ関数は、それがより複雑な衝突を作成することができ、ハッシュツリー、で使用されていることに注意してください。攻撃者は、ハッシュのための衝突を見つけるために管理する場合は特に、それだけで1つのチャンクを置き換えることができ、その影響は限定的です。固定サイズのチャンクが使用される場合、衝突があっても、元のチャンクと同じサイズでなければなりません。ハッシュツリー内のハッシュ高いアップのために、衝突は、2つのハッシュの連結でなければなりません。要するに、ハッシュツリーにフィット見つけるの衝突は、通常の衝突よりも見つけることが一般的に困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.6. Limit Potential Damage and Resource Exhaustion by Bad or Broken Peers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.6。不良または破損ピアによって破損の恐れやリソースの枯渇を制限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regarding PPSP.SEC.REQ-2 in [RFC6972], this section provides an analysis of the potential damage a malicious peer can do with each message in the protocol, and how it is prevented by the protocol (implementation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSP.SEC.REQ-2 [RFC6972]でに関しては、このセクションでは、悪意あるピアがプロトコルに各メッセージで行うことができる潜在的な損傷の分析を提供し、どのように、プロトコル（実装）によって防止されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.1. HANDSHAKE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.1。ハンドシェーク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Secured against DoS Amplification attacks as described in Section 12.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12.1節で説明したように、OのDoS増幅攻撃から保護。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat HS.1: An Eclipse attack where Peers T1..Tn fill all connection slots of Peer A by initiating the connection to Peer A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威HS.1：ピアT1..Tnは、ピアAに接続を開始することによって、ピアAのすべての接続スロットを埋めるEclipseの攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: Peer A must not let other peers fill all its available connection slots, i.e., Peer A must initiate connections itself too, to prevent isolation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
溶液：すなわち、ピアAは、分離を防ぐために、あまりにも接続自体を開始する必要があり、他のピアがすべての利用可能な接続スロットを充填させてはならないピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.2. HAVE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.2。持ってる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat HAVE.1: Malicious Peer T can claim to have content that it does not. Subsequently, Peer T won&#39;t respond to requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威HAVE.1：悪意のあるピアTは、そうでないコンテンツを持っていると主張することができます。その後、Tが要求に応答しませんピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: Peer A will consider Peer T to be a slow peer and not ask it again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
解決策：ピアAは遅いピアなると再びそれを聞いていないためにピアTを検討します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat HAVE.2: Malicious Peer T can claim not to have content. Hence, it won&#39;t contribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威HAVE.2：悪意のあるピアTは、コンテンツを持っていないと主張することができます。したがって、それは寄与しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: Peer and chunk selection algorithms external to the protocol will implement fairness and provide sharing incentives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ソリューション：プロトコルへの外部ピアおよびチャンク選択アルゴリズムは、公平性を実装し、共有のインセンティブを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.3. DATA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.3。データ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat DATA.1: Peer T sending bogus chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威DATA.1：Tは、偽のチャンクを送信するピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: The content integrity protection schemes defend against this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ソリューション：コンテンツの完全性の保護スキームは、この身を守ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat DATA.2: Peer T sends Peer A unrequested chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威DATA.2：Tが要求されていないチャンクをピアに送信ピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
To protect against this threat we need network-level DoS prevention.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この脅威から保護するために、我々は、ネットワークレベルのDoS防止を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.4. ACK
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.4。 ACK
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat ACK.1: Peer T acknowledges wrong chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威ACK.1：ピアTが間違ったチャンクを認めています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: Peer A will detect inconsistencies with the data it sent to Peer T.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ソリューション：それはT.をピアに送信されたデータとの不整合を検出し、ピア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat ACK.2: Peer T modifies timestamp in ACK to Peer A used for time-based congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威ACK.2：ピアTは、時間ベースの輻輳制御に使用されるピア・ツーACKのタイムスタンプを修正します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: In theory, by decreasing the timestamp, Peer T could fake that there is no congestion when in fact there is, causing Peer A to send more data than it should. [RFC6817] does not list this as a security consideration. Possibly, this attack can be detected by the large resulting asymmetry between round-trip time and measured one-way delay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ソリューション：理論的には、タイムスタンプを減少させることによって、Tはできる偽実際にはそれが必要以上のデータを送信するためにピアAを引き起こし、そこにあるときに輻輳がないことをピア。 [RFC6817]は、セキュリティの対価としてこれを表示されません。おそらく、この攻撃は、ラウンドトリップ時間との間に大きな得非対称によって検出され、一方向の遅延を測定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.5. INTEGRITY and SIGNED_INTEGRITY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.5。 INTEGRITYとSIGNED_INTEGRITY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat INTEGRITY.1: An amplification attack where Peer T sends bogus INTEGRITY or SIGNED_INTEGRITY messages, causing Peer A to checks hashes or signatures, thus spending CPU unnecessarily.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威INTEGRITY.1：ピアTは、このように不必要にCPUを費やし、チェックハッシュまたは署名にピアAを引き起こし、偽INTEGRITYまたはSIGNED_INTEGRITYメッセージを送信増幅攻撃。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: If the hashes/signatures don&#39;t check out, Peer A will stop asking Peer T because of the atomic datagram principle and the content integrity protection. Subsequent unsolicited traffic from Peer T will be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ソリューション：ハッシュ/署名がチェックアウトしていない場合は、ピアAがあるため、原子データグラムの原理とコンテンツの完全性保護のピアTを求めて停止します。ピアTからの後続の迷惑トラフィックは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat INTEGRITY.2: An attack where Peer T sends old SIGNED_INTEGRITY messages in the Unified Merkle Tree scheme, trying to make Peer A tune in at a past point in the live stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威INTEGRITY.2：ピアTは、ライブストリームで、過去の時点でで曲をピアにしようと、ユニファイドマークルツリー方式で古いSIGNED_INTEGRITYメッセージを送信した攻撃。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: The timestamp in the SIGNED_INTEGRITY message protects against such replays. Subsequent traffic from Peer T will be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ソリューション：SIGNED_INTEGRITYメッセージのタイムスタンプは、このようなリプレイから保護します。ピアTからの後続のトラフィックは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.6. REQUEST
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.6。要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat REQUEST.1: Peer T could request lots from Peer A, leaving Peer A without resources for others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威REQUEST.1：他の人のためのリソースなしでピアAを残して、ピアAから多くを要求することができるTピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: A limit is imposed on the upload capacity a single peer can consume, for example, by using an upload bandwidth scheduler that takes into account the need of multiple peers. A natural upper limit of this upload quotum is the bitrate of the content, taking into account that this may be variable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
溶液：限界を考慮に複数のピアの必要性を取るアップロード帯域幅スケジューラを使用することにより、例えば、単一のピアが消費できるアップロード容量に課されます。このアップロードquotumの自然の上限は、これが可変であってもよいことを考慮して、コンテンツのビットレートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.7. CANCEL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.7。キャンセル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat CANCEL.1: Peer T sends CANCEL messages for content it never requested to Peer A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威CANCEL.1：Tは、コンテンツのためのメッセージを送信しますCANCELピアはピアAに要求されたことはありません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: Peer A will detect the inconsistency of the messages and ignore them. Note that CANCEL messages may be received unexpectedly when a transport is used where REQUEST messages may be lost or reordered with respect to the subsequent CANCELs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
解決策：ピアAは、メッセージの矛盾を検出し、それらを無視します。 REQUESTメッセージが失われたり、その後の解除に関して再順序付けすることができる場合、トランスポートが使用される場合、メッセージをキャンセルノートが予期せずに受信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.8. CHOKE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.8。 CHOKE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat CHOKE.1: Peer T sends REQUEST messages after Peer A sent Peer B a CHOKE message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威CHOKE.1は：Tは、ピアA送信ピアBチョークメッセージの後に要求メッセージを送信するピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: Peer A will just discard the unwanted REQUESTs and resend the CHOKE, assuming it got lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
解決策：ピアAはちょうどそれが失われてしまったと仮定すると、不要な要求を破棄し、チョークを再送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.9. UNCHOKE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.9。 UNCHOKE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat UNCHOKE.1: Peer T sends an UNCHOKE message to Peer A without having sent a CHOKE message before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威UNCHOKE.1ピアTは前チョークメッセージを送信したことなく、ピアするUNCHOKEメッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: Peer A can easily detect this violation of protocol state, and ignore it. Note this can also happen due to loss of a CHOKE message sent by a benign peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
解決策：ピアAは、簡単にプロトコル状態のこの違反を検出し、それを無視することができます。これはまたによる良性のピアによって送信されたチョークメッセージの損失に起こることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat UNCHOKE.2: Peer T sends an UNCHOKE message to Peer A, but subsequently does not respond to its REQUESTs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威UNCHOKE.2：TはピアツーピアUNCHOKEメッセージを送信しますが、その後、その要求に応答しないピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: Peer A will consider Peer T to be a slow peer and not ask it again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
解決策：ピアAは遅いピアなると再びそれを聞いていないためにピアTを検討します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.10. PEX_RES
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.10。 PEX_RES
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Secured against amplification and Eclipse attacks as described in Section 12.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12.2節で説明したように、O増幅およびEclipseの攻撃から保護。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.11. Unsolicited Messages in General
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6.11。一般的で未承諾のメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Threat: Peer T could send a spoofed PEX_REQ or REQUEST from Peer B to Peer A, causing Peer A to send a PEX_RES/DATA to Peer B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O脅威は：B.ピア・ツーPEX_RES /データを送信するピアAを引き起こし、TはピアツーピアBから偽装PEX_REQまたはリクエストを送信することができるピア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Solution: the message from Peer T won&#39;t be accepted unless Peer T does a handshake first, in which case the reply goes to Peer T, not victim Peer B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
解決策：ピアTは返信がTピアに行くその場合、最初のハンドシェイクを、しない限り、ピアTからのメッセージは受け付けられません、ない被害者ピアB.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7. Exclude Bad or Broken Peers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7。不良または破損ピアを除外
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is regarding PPSP.SEC.REQ-2 in [RFC6972]. A receiving peer can detect malicious or faulty senders as just described, which it can then subsequently ignore. However, excluding such a bad peer from the system completely is complex. Random monitoring by trusted peers that would blacklist bad peers as described in [DETMAL] is one option. This mechanism does require extra capacity to run such trusted peers, which must be indistinguishable from regular peers, and requires a solution for the timely distribution of this blacklist to peers in a scalable manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[RFC6972]にPPSP.SEC.REQ-2についてれます。受信ピアは、その後無視することができ、今述べたように悪意のあるまたは障害のある送信者を検出することができます。しかし、完全にシステムからそのような悪いピアを除く複雑です。 [DETMAL]で説明したように、悪い仲間をブラックリストになり、信頼できる仲間によるランダム監視が一つの選択肢です。このメカニズムは、通常のピアと区別がつかないでなければならない、そのような信頼されたピアを、実行するための追加容量が必要ですし、スケーラブルな方法でピアにこのブラックリストのタイムリーな配信のためのソリューションが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCITT.X690.2002] International Telephone and Telegraph Consultative Committee, &#34;ASN.1 encoding rules: Specification of basic encoding Rules (BER), Canonical encoding rules (CER) and Distinguished encoding rules (DER)&#34;, CCITT Recommendation X.690, July 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCITT.X690.2002]国際電信電話諮問委員会、「ASN.1エンコーディング規則：基本的な符号化規則（BER）、Canonicalの符号化規則（CER）との識別符号化規則（DER）の仕様」、CCITT勧告X.690 、2002年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS180-4] National Institute of Standards and Technology, Information Technology Laboratory, &#34;Federal Information Processing Standards: Secure Hash Standard (SHS)&#34;, FIPS PUB 180-4, March 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS180-4]米国国立標準技術研究所、情報技術研究所、「連邦情報処理規格：セキュアハッシュ標準（SHS）」、FIPS PUB 180-4の、2012月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IANADNSSECALGNUM] IANA, &#34;Domain Name System Security (DNSSEC) Algorithm Numbers&#34;, March 2014, &lt;http://www.iana.org/assignments/dns-sec-alg-numbers&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IANADNSSECALGNUM] IANA、 &#34;ドメインネームシステムセキュリティ（DNSSEC）アルゴリズム番号&#34;、2014年3月、&lt;http://www.iana.org/assignments/dns-sec-alg-numbers&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1918] Rekhter, Y., Moskowitz, B., Karrenberg, D., J. de Groot, G., and E. Lear, &#34;Address Allocation for Private Internets&#34;, BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996, &lt;http://www.rfc-editor.org/info/rfc1918&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1918] Rekhter、Y.、モスコウィッツ、B.、Karrenberg、D.、J.デ・グルート、G.、およびE.リア、 &#34;個人的なインターネットのための配分&#34;、BCP 5、RFC 1918、DOI 10.17487 / RFC1918、 1996年2月、&lt;http://www.rfc-editor.org/info/rfc1918&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3110] Eastlake 3rd, D., &#34;RSA/SHA-1 SIGs and RSA KEYs in the Domain Name System (DNS)&#34;, RFC 3110, DOI 10.17487/RFC3110, May 2001, &lt;http://www.rfc-editor.org/info/rfc3110&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3110]イーストレイク3日、D.、 &#34;RSA / SHA-1のSIGおよびドメインネームシステム（DNS）でのRSAキー&#34;、RFC 3110、DOI 10.17487 / RFC3110、2001年5月、&lt;のhttp：//www.rfc-editor .ORG /情報/ rfc3110&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, &lt;http://www.rfc-editor.org/info/rfc3986&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 &#34;ユニフォームリソース識別子（URI）：汎用構文&#34;、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月&lt;HTTP：/ /www.rfc-editor.org/info/rfc3986&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4034] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &#34;Resource Records for the DNS Security Extensions&#34;, RFC 4034, DOI 10.17487/RFC4034, March 2005, &lt;http://www.rfc-editor.org/info/rfc4034&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4034]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 &#34;DNSセキュリティ拡張機能のためのリソースレコード&#34;、RFC 4034、DOI 10.17487 / RFC4034、2005年3月、&lt; http://www.rfc-editor.org/info/rfc4034&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4291] Hinden, R. and S. Deering, &#34;IP Version 6 Addressing Architecture&#34;, RFC 4291, DOI 10.17487/RFC4291, February 2006, &lt;http://www.rfc-editor.org/info/rfc4291&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4291] HindenとR.とS.デアリング、 &#34;IPバージョン6アドレッシング体系&#34;、RFC 4291、DOI 10.17487 / RFC4291、2006年2月、&lt;http://www.rfc-editor.org/info/rfc4291&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 5280, DOI 10.17487/RFC5280, May 2008, &lt;http://www.rfc-editor.org/info/rfc5280&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、&lt;http://www.rfc-editor.org/info/rfc5280&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5702] Jansen, J., &#34;Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC&#34;, RFC 5702, DOI 10.17487/RFC5702, October 2009, &lt;http://www.rfc-editor.org/info/rfc5702&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5702]ヤンセン、J.、RFC 5702、DOI 10.17487 / RFC5702、2009年10月 &#34;DNSKEYでRSAとSHA-2アルゴリズムとDNSSECのためのRRSIGリソースレコードの使用&#34;、&lt;http://www.rfc-editor.org /情報/ rfc5702&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5905] Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, &#34;Network Time Protocol Version 4: Protocol and Algorithms Specification&#34;, RFC 5905, DOI 10.17487/RFC5905, June 2010, &lt;http://www.rfc-editor.org/info/rfc5905&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5905]ミルズ、D.、マーティン、J.、エド、バーバンク、J.、およびW. Kasch、 &#34;ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様&#34;。、RFC 5905、DOI 10.17487 / RFC5905、2010年6月、 &lt;http://www.rfc-editor.org/info/rfc5905&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6605] Hoffman, P. and W. Wijngaards, &#34;Elliptic Curve Digital Signature Algorithm (DSA) for DNSSEC&#34;, RFC 6605, DOI 10.17487/RFC6605, April 2012, &lt;http://www.rfc-editor.org/info/rfc6605&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6605]ホフマン、P.及びW. Wijngaards、 &#34;DNSSECのための楕円曲線デジタル署名アルゴリズム（DSA）&#34;、RFC 6605、DOI 10.17487 / RFC6605、2012年4月、&lt;http://www.rfc-editor.org/info / rfc6605&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6817] Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind, &#34;Low Extra Delay Background Transport (LEDBAT)&#34;, RFC 6817, DOI 10.17487/RFC6817, December 2012, &lt;http://www.rfc-editor.org/info/rfc6817&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6817] Shalunov、S.、ヘーゼル、G.、アイアンガー、J.、およびM. Kuehlewind、 &#34;低余分な遅延の背景トランスポート（LEDBAT）&#34;、RFC 6817、DOI 10.17487 / RFC6817、2012年12月、&lt;HTTP：// www.rfc-editor.org/info/rfc6817&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ABMRKL] Bakker, A., &#34;Merkle hash torrent extension&#34;, BitTorrent Enhancement Proposal 30, March 2009, &lt;http://bittorrent.org/beps/bep_0030.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ABMRKL]バッカー、A.、 &#34;マークルハッシュ急流の延長&#34;、BitTorrentの強化の提案30、2009年3月、&lt;http://bittorrent.org/beps/bep_0030.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BINMAP] Grishchenko, V. and J. Pouwelse, &#34;Binmaps: Hybridizing Bitmaps and Binary Trees&#34;, Delft University of Technology Parallel and Distributed Systems Report Series, Report number PDS-2011-005, ISSN 1387-2109, April 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BINMAP] Grishchenko、V.およびJ. Pouwelse、「Binmaps：ハイブリダイズするビットマップとバイナリ木」、デルフト工科大学の並列分散システムレポートシリーズ、レポート番号PDS-2011から005、ISSN 1387年から2109年、2009年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BITOS] Vlavianos, A., Iliofotou, M., Mathieu, F., and M. Faloutsos, &#34;BiToS: Enhancing BitTorrent for Supporting Streaming Applications&#34;, IEEE INFOCOM Global Internet Symposium, Barcelona, Spain, April 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BITOS] Vlavianos、A.、Iliofotou、M.、マチュー、F.、およびM. Faloutsos、 &#34;BiToS：ストリーミングアプリケーションをサポートするためのBitTorrentの強化&#34;、IEEE INFOCOMグローバル・インターネット・シンポジウム、バルセロナ、スペイン、2006年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BITTORRENT] Cohen, B., &#34;The BitTorrent Protocol Specification&#34;, BitTorrent Enhancement Proposal 3, February 2008, &lt;http://bittorrent.org/beps/bep_0003.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BitTorrentの]コーエン、B.、 &#34;BitTorrentのプロトコル仕様&#34;、BitTorrentの強化案3、2008年2月、&lt;http://bittorrent.org/beps/bep_0003.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CLOSED] Borch, N., Mitchell, K., Arntzen, I., and D. Gabrijelcic, &#34;Access Control to BitTorrent Swarms Using Closed Swarms&#34;, ACM workshop on Advanced Video Streaming Techniques for Peer-to-Peer Networks and Social Networking (AVSTP2P &#39;10), Florence, Italy, October 2010, &lt;http://doi.acm.org/10.1145/1877891.1877898&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CLOSED]ボルフ、N.、ミッチェル、K.、Arntzen、I.、およびD. Gabrijelcic、「クローズ群れを使用したBitTorrentの群れへのアクセス制御」、ピアツーピアネットワークと社会のための高度なビデオストリーミング技術上のACMワークショップ（AVSTP2P &#39;10）、フィレンツェ、イタリア、2010年10月ネットワーキング、&lt;http://doi.acm.org/10.1145/1877891.1877898&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DETMAL] Shetty, S., Galdames, P., Tavanapong, W., and Ying. Cai, &#34;Detecting Malicious Peers in Overlay Multicast Streaming&#34;, IEEE Conference on Local Computer Networks, (LCN&#39;06), Tampa, FL, USA, November 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【DETMAL]シェティ、S.、Galdames、P.、Tavanapong、W.、および英。カイ、「オーバーレイマルチキャストストリーミングで悪意のあるピアの検出」、ローカルコンピュータネットワーク上のIEEE会議、（LCN&#39;06）、タンパ、FL、USA、2006年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECLIPSE] Sit, E. and R. Morris, &#34;Security Considerations for Peer-to-Peer Distributed Hash Tables&#34;, IPTPS &#39;01: Revised Papers from the First International Workshop on Peer-to-Peer Systems, pp. 261-269, Springer-Verlag, 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECLIPSE]シット、E.およびR.モリス、「ピアツーピア分散ハッシュテーブルのためのセキュリティの考慮事項」は、&#39;01 IPTPS：ピアツーピアシステムに関する第一回国際ワークショップからの改訂論文を、頁261-269 、シュプリンガー・フェアラーク、2002。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECS] Jovanovikj, V., Gabrijelcic, D., and T. Klobucar, &#34;Access Control in BitTorrent P2P Networks Using the Enhanced Closed Swarms Protocol&#34;, International Conference on Emerging Security Information, Systems and Technologies (SECURWARE 2011), pp. 97-102, Nice, France, August 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECS] Jovanovikj、V.、Gabrijelcic、D.、およびT. Klobucar、 &#34;強化されたクローズド群れプロトコルを使用してBitTorrentのP2Pネットワークにおけるアクセス制御&#34;、新興セキュリティ情報、システムおよび技術に関する国際会議（2011 SECURWARE）、頁。 97-102、ニース、フランス、2011年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECS-protocol] Gabrijelcic, D., &#34;Enhanced Closed Swarm protocol&#34;, Work in Progress, draft-ppsp-gabrijelcic-ecs-01, June 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECS-プロトコル] Gabrijelcic、D.、 &#34;強化されたクローズドスウォームプロトコル&#34; が進行中で働いて、ドラフトppsp-gabrijelcic-ECS-01、2013年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[EPLIVEPERF] Bonald, T., Massoulie, L., Mathieu, F., Perino, D., and A. Twigg, &#34;Epidemic live streaming: optimal performance trade-offs&#34;, Proceedings of the 2008 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems, Annapolis, MD, USA, June 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[EPLIVEPERF]ボナルド、T.、Massoulie、L.、マチュー、F.、ペリーノ、D.、およびA. Twigg、 &#34;流行ライブストリーミング：最適なパフォーマンスのトレードオフ&#34;、測定に関する2008年ACM SIGMETRICS国際会議の議事録およびコンピュータシステム、アナポリス、MD、USA、2008年6月のモデル化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GIVE2GET] Mol, J., Pouwelse, J., Meulpolder, M., Epema, D., and H. Sips, &#34;Give-to-Get: Free-riding-resilient Video-on-Demand in P2P Systems&#34;, Proceedings Multimedia Computing and Networking conference (Proceedings of SPIE, Vol. 6818), San Jose, CA, USA, January 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GIVE2GET]モル、J.、Pouwelse、J.、Meulpolder、M.、Epema、D.、およびH. SIPS、 &#34;与えるツー入手：ビデオオンデマンドP2Pシステムでフリーライディング・弾力性&#34;、議事マルチメディアコンピューティングとネットワーキング会議（SPIE会報、巻。6818）、サンノゼ、CA、USA、2008年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HAC01] Menezes, A., van Oorschot, P., and S. Vanstone, &#34;Handbook of Applied Cryptography&#34;, CRC Press, (Fifth Printing, August 2001), October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HAC01]メネゼス、A.、バンOorschot、P.、およびS. Vanstone著、 &#34;応用暗号のハンドブック&#34;、CRCプレス、（第五印刷、2001年8月）、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[JIM11] Jimenez, R., Osmani, F., and B. Knutsson, &#34;Sub-Second Lookups on a Large-Scale Kademlia-Based Overlay&#34;, IEEE International Conference on Peer-to-Peer Computing (P2P&#39;11), Kyoto, Japan, August 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【JIM11]ヒメネス、R.、Osmani、F.、およびB. Knutsson、「サブセカンドルックアップ大規模Kademliaのベースのオーバーレイの」ピアツーピア・コンピューティングに関するIEEE国際会議（P2P&#39;11）京都、日本、2011年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LBT] Rossi, D., Testa, C., Valenti, S., and L. Muscariello, &#34;LEDBAT: the new BitTorrent congestion control protocol&#34;, Computer Communications and Networks (ICCCN), Zurich, Switzerland, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LBT]ロッシ、D.、テスタ、C.、ヴァレンティ、S.、およびL. Muscariello、 &#34;LEDBAT：新しいBitTorrentの輻輳制御プロトコル&#34;、コンピュータ通信とネットワーク（ICCCN）、チューリッヒ、スイス、2010年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LCOMPL] Testa, C. and D. Rossi, &#34;On the impact of uTP on BitTorrent completion time&#34;, IEEE International Conference on Peer-to-Peer Computing (P2P&#39;11), Kyoto, Japan, August 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LCOMPL]テスタ、C.およびD.ロッシ、「BitTorrentの完了時間にUTPの影響について」、ピア・ツー・ピア・コンピューティングに関するIEEE国際会議（P2P&#39;11）、京都、日本、2011年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MERKLE] Merkle, R., &#34;Secrecy, Authentication, and Public Key Systems&#34;, Ph.D. thesis, Dept. of Electrical Engineering, Stanford University, CA, USA, pp 40-45, 1979.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[マークル]マークル、R.、「プライバシー、認証、および公開鍵システム」、博士論文、電気工学、スタンフォード大学、カリフォルニア州、USA、頁40-45、1979年の部門。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2PWIKI] Bakker, A., Petrocco, R., Dale, M., Gerber, J., Grishchenko, V., Rabaioli, D., and J. Pouwelse, &#34;Online video using BitTorrent and HTML5 applied to Wikipedia&#34;, IEEE International Conference on Peer-to-Peer Computing (P2P&#39;10), Delft, The Netherlands, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【P2PWIKI]バッカー、A.、Petrocco、R.、デール、M.、ガーバー、J.、Grishchenko、V.、Rabaioli、D.、およびJ. Pouwelseは、 &#34;ビットトレントとHTML5を使用してオンラインビデオは、ウィキペディアに適用されます&#34;、ピア・ツー・ピア・コンピューティングに関するIEEE国際会議（P2P&#39;10）、デルフト、オランダ、2010年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[POLLIVE] Dhungel, P., Hei, Xiaojun., Ross, K., and N. Saxena, &#34;Pollution in P2P Live Video Streaming&#34;, International Journal of Computer Networks &amp; Communications (IJCNC) Vol. 1, No. 2, Jul 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[POLLIVE] Dhungel、P.、ヘイ、Xiaojun。、ロス、K.、およびN. Saxena、 &#34;P2Pライブビデオストリーミングで汚染&#34;、コンピュータネットワーク＆コミュニケーションの国際ジャーナル（IJCNC）巻。 1、第2号、2009年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PPSP-TP] Cruz, R., Nunes, M., Yingjie, G., Xia, J., Huang, R., Taveira, J., and D. Lingli, &#34;PPSP Tracker Protocol-Base Protocol (PPSP-TP/1.0)&#34;, Work in Progress, draft-ietf-ppsp-base-tracker-protocol-09, March 2015.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PPSP-TP]クルス、R.、ヌネス、M.、英傑、G.、夏、J.、黄、R.、Taveira、J.、およびD. Lingli、「PPSPトラッカープロトコルベースプロトコル（PPSP- TP / 1.0）」が進行中で働いて、ドラフト-IETF-ppspベーストラッカー・プロトコル-09、2015年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PPSPPERF] Petrocco, R., Pouwelse, J., and D. Epema, &#34;Performance Analysis of the Libswift P2P Streaming Protocol&#34;, IEEE International Conference on Peer-to-Peer Computing (P2P&#39;12), Tarragona, Spain, September 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PPSPPERF] Petrocco、R.、Pouwelse、J.、およびD. Epema、 &#34;Libswift P2Pストリーミングプロトコルの性能解析&#34;、ピア・ツー・ピア・コンピューティングに関するIEEE国際会議（P2P&#39;12）、タラゴナ、スペイン、9月2012。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2564] Kalbfleisch, C., Krupczak, C., Presuhn, R., and J. Saperia, &#34;Application Management MIB&#34;, RFC 2564, DOI 10.17487/RFC2564, May 1999, &lt;http://www.rfc-editor.org/info/rfc2564&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2564] Kalbfleisch、C.、Krupczak、C.、Presuhn、R.、およびJ. Saperia、 &#34;アプリケーション管理MIB&#34;、RFC 2564、DOI 10.17487 / RFC2564、1999年5月、&lt;HTTP：//www.rfc-editor .ORG /情報/ rfc2564&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2790] Waldbusser, S. and P. Grillo, &#34;Host Resources MIB&#34;, RFC 2790, DOI 10.17487/RFC2790, March 2000, &lt;http://www.rfc-editor.org/info/rfc2790&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2790] Waldbusser、S.とP.グリロ、RFC 2790、DOI 10.17487 / RFC2790、2000年3月、&lt;http://www.rfc-editor.org/info/rfc2790&gt; &#34;リソースMIBホスト&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2975] Aboba, B., Arkko, J., and D. Harrington, &#34;Introduction to Accounting Management&#34;, RFC 2975, DOI 10.17487/RFC2975, October 2000, &lt;http://www.rfc-editor.org/info/rfc2975&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2975] Aboba、B.、Arkko、J.、およびD.ハリントン、 &#34;会計管理の概要&#34;、RFC 2975、DOI 10.17487 / RFC2975、2000年10月、&lt;http://www.rfc-editor.org/info / RFC2975&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3365] Schiller, J., &#34;Strong Security Requirements for Internet Engineering Task Force Standard Protocols&#34;, BCP 61, RFC 3365, DOI 10.17487/RFC3365, August 2002, &lt;http://www.rfc-editor.org/info/rfc3365&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3365]シラー、J.、 &#34;インターネットエンジニアリングタスクフォース標準プロトコルのための強力なセキュリティ要件&#34;、BCP 61、RFC 3365、DOI 10.17487 / RFC3365、2002年8月、&lt;http://www.rfc-editor.org/info/ rfc3365&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3729] Waldbusser, S., &#34;Application Performance Measurement MIB&#34;, RFC 3729, DOI 10.17487/RFC3729, March 2004, &lt;http://www.rfc-editor.org/info/rfc3729&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3729] Waldbusser、S.、 &#34;アプリケーションのパフォーマンス測定MIB&#34;、RFC 3729、DOI 10.17487 / RFC3729、2004年3月、&lt;http://www.rfc-editor.org/info/rfc3729&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4113] Fenner, B. and J. Flick, &#34;Management Information Base for the User Datagram Protocol (UDP)&#34;, RFC 4113, DOI 10.17487/RFC4113, June 2005, &lt;http://www.rfc-editor.org/info/rfc4113&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4113]フェナー、B.及びJ.フリック、 &#34;管理情報ベースユーザーデータグラムプロトコル（UDP）のための&#34;、RFC 4113、DOI 10.17487 / RFC4113、2005年6月、&lt;http://www.rfc-editor.org/情報/ rfc4113&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4150] Dietz, R. and R. Cole, &#34;Transport Performance Metrics MIB&#34;, RFC 4150, DOI 10.17487/RFC4150, August 2005, &lt;http://www.rfc-editor.org/info/rfc4150&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4150]ディーツ、R.とR.コール、 &#34;交通パフォーマンス・メトリックMIB&#34;、RFC 4150、DOI 10.17487 / RFC4150、2005年8月、&lt;http://www.rfc-editor.org/info/rfc4150&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4193] Hinden, R. and B. Haberman, &#34;Unique Local IPv6 Unicast Addresses&#34;, RFC 4193, DOI 10.17487/RFC4193, October 2005, &lt;http://www.rfc-editor.org/info/rfc4193&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4193] HindenとR.とB.ハーバーマン、 &#34;ユニークローカルIPv6ユニキャストアドレス&#34;、RFC 4193、DOI 10.17487 / RFC4193、2005年10月、&lt;http://www.rfc-editor.org/info/rfc4193&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4301] Kent, S. and K. Seo, &#34;Security Architecture for the Internet Protocol&#34;, RFC 4301, DOI 10.17487/RFC4301, December 2005, &lt;http://www.rfc-editor.org/info/rfc4301&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4301]ケント、S.とK. Seo、 &#34;インターネットプロトコルのためのセキュリティアーキテクチャ&#34;、RFC 4301、DOI 10.17487 / RFC4301、2005年12月、&lt;http://www.rfc-editor.org/info/rfc4301&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821] Mathis, M. and J. Heffner, &#34;Packetization Layer Path MTU Discovery&#34;, RFC 4821, DOI 10.17487/RFC4821, March 2007, &lt;http://www.rfc-editor.org/info/rfc4821&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821]マシス、M.とJ. Heffner、 &#34;パケット化レイヤのパスMTUディスカバリ&#34;、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、&lt;http://www.rfc-editor.org/info/rfc4821&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960] Stewart, R., Ed., &#34;Stream Control Transmission Protocol&#34;, RFC 4960, DOI 10.17487/RFC4960, September 2007, &lt;http://www.rfc-editor.org/info/rfc4960&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960]スチュワート、R.、エド。、 &#34;ストリーム制御伝送プロトコル&#34;、RFC 4960、DOI 10.17487 / RFC4960、2007年9月、&lt;http://www.rfc-editor.org/info/rfc4960&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, &lt;http://www.rfc-editor.org/info/rfc5226&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226] Narten氏、T.とH. Alvestrand、 &#34;RFCsにIANA問題部に書くためのガイドライン&#34;、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、&lt;http://www.rfc-editor.org /情報/ RFC5226&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &#34;Session Traversal Utilities for NAT (STUN)&#34;, RFC 5389, DOI 10.17487/RFC5389, October 2008, &lt;http://www.rfc-editor.org/info/rfc5389&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389]ローゼンバーグ、J.、マーイ、R.、マシューズ、P.、およびD.翼、 &#34;NAT（STUN）のセッショントラバーサルユーティリティ&#34;、RFC 5389、DOI 10.17487 / RFC5389、2008年10月、&lt;のhttp：// www.rfc-editor.org/info/rfc5389&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5424] Gerhards, R., &#34;The Syslog Protocol&#34;, RFC 5424, DOI 10.17487/RFC5424, March 2009, &lt;http://www.rfc-editor.org/info/rfc5424&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5424] Gerhards氏、R.、 &#34;Syslogのプロトコル&#34;、RFC 5424、DOI 10.17487 / RFC5424、2009年3月、&lt;http://www.rfc-editor.org/info/rfc5424&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5706] Harrington, D., &#34;Guidelines for Considering Operations and Management of New Protocols and Protocol Extensions&#34;, RFC 5706, DOI 10.17487/RFC5706, November 2009, &lt;http://www.rfc-editor.org/info/rfc5706&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5706]ハリントン、D.、 &#34;新しいプロトコルやプロトコル拡張の運用と管理を考えるためのガイドライン&#34;、RFC 5706、DOI 10.17487 / RFC5706、2009年11月、&lt;http://www.rfc-editor.org/info/rfc5706 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5971] Schulzrinne, H. and R. Hancock, &#34;GIST: General Internet Signalling Transport&#34;, RFC 5971, DOI 10.17487/RFC5971, October 2010, &lt;http://www.rfc-editor.org/info/rfc5971&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5971] Schulzrinneと、H.とR.ハンコック、 &#34;GIST：一般的なインターネットシグナリング交通&#34;、RFC 5971、DOI 10.17487 / RFC5971、2010年10月、&lt;http://www.rfc-editor.org/info/rfc5971&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6194] Polk, T., Chen, L., Turner, S., and P. Hoffman, &#34;Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms&#34;, RFC 6194, DOI 10.17487/RFC6194, March 2011, &lt;http://www.rfc-editor.org/info/rfc6194&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6194]ポーク、T.、チェン、L.、ターナー、S.、およびP.ホフマン、RFC 6194、DOI 10.17487 / RFC6194 3月 &#34;SHA-0、SHA-1メッセージダイジェストアルゴリズムのセキュリティの考慮事項&#34; 2011年、&lt;http://www.rfc-editor.org/info/rfc6194&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., &#34;Network Configuration Protocol (NETCONF)&#34;, RFC 6241, DOI 10.17487/RFC6241, June 2011, &lt;http://www.rfc-editor.org/info/rfc6241&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6241]エンス、R.、編、Bjorklund、M.、編、Schoenwaelder、J.、編、及びA. Bierman、編、 &#34;ネットワーク構成プロトコル（NETCONF）&#34;、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、&lt;http://www.rfc-editor.org/info/rfc6241&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347] Rescorla, E. and N. Modadugu, &#34;Datagram Transport Layer Security Version 1.2&#34;, RFC 6347, DOI 10.17487/RFC6347, January 2012, &lt;http://www.rfc-editor.org/info/rfc6347&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347]レスコラ、E.およびN. Modadugu、 &#34;データグラムトランスポート層セキュリティバージョン1.2&#34;、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、&lt;http://www.rfc-editor.org/info/rfc6347&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6709] Carpenter, B., Aboba, B., Ed., and S. Cheshire, &#34;Design Considerations for Protocol Extensions&#34;, RFC 6709, DOI 10.17487/RFC6709, September 2012, &lt;http://www.rfc-editor.org/info/rfc6709&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6709]大工、B.、Aboba、B.、エド、およびS.チェシャー、 &#34;プロトコル拡張のための設計上の考慮事項&#34;、RFC 6709、DOI 10.17487 / RFC6709、2012年9月、&lt;のhttp：。//www.rfc-editor .ORG /情報/ rfc6709&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6972] Zhang, Y. and N. Zong, &#34;Problem Statement and Requirements of the Peer-to-Peer Streaming Protocol (PPSP)&#34;, RFC 6972, DOI 10.17487/RFC6972, July 2013, &lt;http://www.rfc-editor.org/info/rfc6972&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6972]張、Y.およびN.宗、 &#34;問題文とピアツーピアストリーミングプロトコル（PPSP）の要件&#34;、RFC 6972、DOI 10.17487 / RFC6972、2013年7月、&lt;HTTP：//www.rfc -editor.org/info/rfc6972&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7285] Alimi, R., Ed., Penno, R., Ed., Yang, Y., Ed., Kiesel, S., Previdi, S., Roome, W., Shalunov, S., and R. Woundy, &#34;Application-Layer Traffic Optimization (ALTO) Protocol&#34;, RFC 7285, DOI 10.17487/RFC7285, September 2014, &lt;http://www.rfc-editor.org/info/rfc7285&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7285] Alimi、R.、編、Penno、R.、編、ヤン、Y.、編、キーセル、S.、Previdi、S.、Roome、W.、Shalunov、S.、およびR. Woundy、 &#34;アプリケーションレイヤトラフィックの最適化（ALTO）プロトコル&#34;、RFC 7285、DOI 10.17487 / RFC7285、2014年9月、&lt;http://www.rfc-editor.org/info/rfc7285&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SECDHTS] Urdaneta, G., Pierre, G., and M. van Steen, &#34;A Survey of DHT Security Techniques&#34;, ACM Computing Surveys, vol. 43(2), January 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【SECDHTS] Urdaneta、G.、ピエール、G.、およびM.バンスティーン、 &#34;DHTセキュリティ技術の調査&#34;、ACMコンピューティングサーベイ、巻。 43（2）、2011年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SIGMCAST] Wong, C. and S. Lam, &#34;Digital Signatures for Flows and Multicasts&#34;, IEEE/ACM Transactions on Networking 7(4), pp. 502-513, August 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;フローとマルチキャストのデジタル署名&#34; [SIGMCAST]ウォン、C.及びS.ラム、ネットワーク7（4）、頁502から513 1999年8月にIEEE / ACMトランザクション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SPS] Jesi, G., Montresor, A., and M. van Steen, &#34;Secure Peer Sampling&#34;, Computer Networks vol. 54(12), pp. 2086-2098, Elsevier, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SPS]イェージ、G.、モントレ、A.、およびM.バンスティーン、 &#34;セキュア・ピアサンプリング&#34;、コンピュータネットワーク容量。 54（12）、頁。2086年から2098年、エルゼビア、2010年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SWIFTIMPL] Grishchenko, V., Paananen, J., Pronchenkov, A., Bakker, A., and R. Petrocco, &#34;Swift reference implementation&#34;, 2015, &lt;https://github.com/libswift/libswift&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【SWIFTIMPL] Grishchenko、V.、Paananen、J.、Pronchenkov、A.、バッカー、A.、およびR. Petrocco、 &#34;スイフトリファレンス実装&#34; 2015年、&lt;https://github.com/libswift/libswift&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TIT4TAT] Cohen, B., &#34;Incentives Build Robustness in BitTorrent&#34;, 1st Workshop on Economics of Peer-to-Peer Systems, Berkeley, CA, USA, May 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TIT4TAT]コーエン、B.は、ピア・ツー・ピアシステムの経済学、バークレー、CA、USA、2003年5月に第1回ワークショップ「インセンティブは、BitTorrentので堅牢性を構築します」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Arno Bakker, Riccardo Petrocco, and Victor Grishchenko are partially supported by the P2P-Next project &lt;http://www.p2p-next.org/&gt;, a research project supported by the European Community under its 7th Framework Programme (grant agreement no. 216217). The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the P2P-Next project or the European Commission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルノバッカー、リッカルドPetrocco、およびビクターGrishchenkoは、部分的にP2P-次のプロジェクト&lt;http://www.p2p-next.org/&gt;、ノーその第7次フレームワークプログラム（助成金の契約の下で欧州共同体でサポートされている研究プロジェクトによってサポートされています。 。216217）。ここに含まれている見解と結論は著者のものであり、P2P-次のプロジェクトや欧州委員会の、明示または黙示、必ずしも公式のポリシーまたは推薦を表すものとして解釈すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPP was designed by Victor Grishchenko at Technische Universiteit Delft under supervision of Johan Pouwelse. The authors would like to thank the following people for their contributions to this document: the chairs (Martin Stiemerling, Yunfei Zhang, Stefano Previdi, and Ning Zong) and members of the IETF PPSP working group, and Mihai Capota, Raul Jimenez, Flutra Osmani, and Raynor Vliegendhart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PPSPPはヨハンPouwelseの監督の下でTECHNISCHEはUniversiteitデルフトでビクターGrishchenkoによって設計されました。作者はこのドキュメントへの貢献のために、以下の人々に感謝したいと思います：椅子（マーティンStiemerling、Yunfei張、ステファノPrevidi、および寧宗）とIETF PPSPワーキンググループのメンバー、およびミハイCapota、ラウール・ヒメネス、Flutra Osmani 、およびRaynor Vliegendhart。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Arno Bakker Vrije Universiteit Amsterdam De Boelelaan 1081 Amsterdam 1081HV The Netherlands
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルノバッカーVrijeはUniversiteitアムステルダムBoelelaan 1081 1081HVアムステルダムオランダ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: arno@cs.vu.nl
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：arno@cs.vu.nl
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Riccardo Petrocco Technische Universiteit Delft Mekelweg 4 Delft 2628CD The Netherlands
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リッカルドPetroccoデルフト工科大学デルフトMekelweg 4 2628CDオランダ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: r.petrocco@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：r.petrocco@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Victor Grishchenko Technische Universiteit Delft Mekelweg 4 Delft 2628CD The Netherlands
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビクターGrishchenkoデルフト工科大学デルフトMekelweg 4 2628CDオランダ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: victor.grishchenko@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：victor.grishchenko@gmail.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
