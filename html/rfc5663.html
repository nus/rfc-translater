<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 5663 - Parallel NFS (pNFS) Block/Volume Layout 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">5663</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 5663 - Parallel NFS (pNFS) Block/Volume Layout 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc5663">
              https://tools.ietf.org/html/rfc5663
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 5663 - パラレルNFS（pNFSの）ブロック/ボリュームレイアウト</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                          D. Black
Request for Comments: 5663                                   S. Fridella
Category: Standards Track                                EMC Corporation
ISSN: 2070-1721                                               J. Glasgow
                                                                  Google
                                                            January 2010
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                Parallel NFS (pNFS) Block/Volume Layout
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parallel NFS (pNFS) extends Network File Sharing version 4 (NFSv4) to allow clients to directly access file data on the storage used by the NFSv4 server. This ability to bypass the server for data access can increase both performance and parallelism, but requires additional client functionality for data access, some of which is dependent on the class of storage used. The main pNFS operations document specifies storage-class-independent extensions to NFS; this document specifies the additional extensions (primarily data structures) for use of pNFS with block- and volume-based storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラレルNFS（pNFSの）は、クライアントが直接NFSv4サーバが使用するストレージ上のファイルデータにアクセスできるようにするネットワークファイル共有、バージョン4（NFSv4の）を拡張します。データ・アクセス用のサーバーをバイパスするこの機能は、パフォーマンスと並列性の両方を増加させるが、使用されているストレージのクラスに依存しているそのうちのいくつかは、データアクセスのための追加のクライアント機能を必要とすることができます。メインpNFSの業務文書は、NFSのストレージクラスに依存しない拡張子を指定します。この文書では、ブロック - とボリュームベースのストレージとのpNFSを使用するための追加の拡張機能（主にデータ構造）を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5663.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc5663で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................4
      1.1. Conventions Used in This Document ..........................4
      1.2. General Definitions ........................................5
      1.3. Code Components Licensing Notice ...........................5
      1.4. XDR Description ............................................5
   2. Block Layout Description ........................................7
      2.1. Background and Architecture ................................7
      2.2. GETDEVICELIST and GETDEVICEINFO ............................9
           2.2.1. Volume Identification ...............................9
           2.2.2. Volume Topology ....................................10
           2.2.3. GETDEVICELIST and GETDEVICEINFO deviceid4 ..........12
      2.3. Data Structures: Extents and Extent Lists .................12
           2.3.1. Layout Requests and Extent Lists ...................15
           2.3.2. Layout Commits .....................................16
           2.3.3. Layout Returns .....................................16
           2.3.4. Client Copy-on-Write Processing ....................17
           2.3.5. Extents are Permissions ............................18
           2.3.6. End-of-file Processing .............................20
           2.3.7. Layout Hints .......................................20
           2.3.8. Client Fencing .....................................21
      2.4. Crash Recovery Issues .....................................23
      2.5. Recalling Resources: CB_RECALL_ANY ........................23
      2.6. Transient and Permanent Errors ............................24
   3. Security Considerations ........................................24
   4. Conclusions ....................................................26
   5. IANA Considerations ............................................26
   6. Acknowledgments ................................................26
   7. References .....................................................27
      7.1. Normative References ......................................27
      7.2. Informative References ....................................27
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 1 shows the overall architecture of a Parallel NFS (pNFS) system:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1は、パラレルNFS（pNFSの）システムの全体的なアーキテクチャを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-----------+
      |+-----------+                                 +-----------+
      ||+-----------+                                |           |
      |||           |       NFSv4.1 + pNFS           |           |
      +||  Clients  |&lt;------------------------------&gt;|   Server  |
       +|           |                                |           |
        +-----------+                                |           |
             |||                                     +-----------+
             |||                                           |
             |||                                           |
             ||| Storage        +-----------+              |
             ||| Protocol       |+-----------+             |
             ||+----------------||+-----------+  Control   |
             |+-----------------|||           |    Protocol|
             +------------------+||  Storage  |------------+
                                 +|  Systems  |
                                  +-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
Figure 1: pNFS Architecture
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
図1：pNFSのアーキテクチャ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The overall approach is that pNFS-enhanced clients obtain sufficient information from the server to enable them to access the underlying storage (on the storage systems) directly. See the pNFS portion of [NFSv4.1] for more details. This document is concerned with access from pNFS clients to storage systems over storage protocols based on blocks and volumes, such as the Small Computer System Interface (SCSI) protocol family (e.g., parallel SCSI, Fibre Channel Protocol (FCP) for Fibre Channel, Internet SCSI (iSCSI), Serial Attached SCSI (SAS), and Fibre Channel over Ethernet (FCoE)). This class of storage is referred to as block/volume storage. While the Server to Storage System protocol, called the &#34;Control Protocol&#34;, is not of concern for interoperability here, it will typically also be a block/volume protocol when clients use block/ volume protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全体的なアプローチは、pNFSの強化、クライアントが直接（ストレージ・システム上の）基礎となるストレージにアクセスすることを可能にするために、サーバから十分な情報を入手することです。詳細については、[NFSv4.1]のpNFSの部分を参照してください。この文書は、ファイバチャネル、インターネット用のSCSI（Small Computer System Interface）プロトコルファミリ（例えば、パラレルSCSI、ファイバ・チャネル・プロトコル（FCP）のようにブロックとボリュームに基づいてストレージプロトコルを介してストレージシステムへのpNFSクライアントからのアクセスに関係していますSCSI（iSCSIの）、シリアル接続SCSI（SAS）、およびオーバーイーサネット、ファイバチャネル（FCoEの））。ストレージのこのクラスは、ブロック/ボリューム・ストレージと呼ばれています。ストレージシステムのプロトコルにサーバーは、「制御プロトコル」と呼ばれますが、クライアントはブロック/ボリュームプロトコルを使用する場合、それは一般的に、ブロック/ボリュームプロトコルとなり、ここでの相互運用性についての心配ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Conventions Used in This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。このドキュメントの表記規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますRFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. General Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。一般的な定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following definitions are provided for the purpose of providing an appropriate context for the reader.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の定義は、読者のために適切なコンテキストを提供する目的のために提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Byte
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This document defines a byte as an octet, i.e., a datum exactly 8 bits in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この文書では、オクテット、即ち、基準長さが正確に8ビットとしてバイトを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The &#34;client&#34; is the entity that accesses the NFS server&#39;s resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「クライアント」とNFSサーバーのリソースにアクセスするエンティティです。クライアントは直接NFSサーバーにアクセスするためのロジックが含まれているアプリケーションであってもよいです。また、クライアントはアプリケーションのセットのためにリモートファイルシステムのサービスを提供し、伝統的なオペレーティングシステムのクライアントであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The &#34;server&#34; is the entity responsible for coordinating client access to a set of file systems and is identified by a server owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
「サーバー」は、ファイル・システムのセットへのクライアントアクセスの調整を担当するエンティティであり、サーバーの所有者によって識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Code Components Licensing Notice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3。コードコンポーネントのライセンスに関するお知らせ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The external data representation (XDR) description and scripts for extracting the XDR description are Code Components as described in Section 4 of &#34;Legal Provisions Relating to IETF Documents&#34; [LEGAL]. These Code Components are licensed according to the terms of Section 4 of &#34;Legal Provisions Relating to IETF Documents&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「IETFドキュメントに関連法規定」[法的]のセクション4で説明したように外部データ表現（XDR）の説明とXDR記述を抽出するためのスクリプトは、コードコンポーネントです。これらのコードコンポーネントは、「IETFドキュメントに関連法規定」の第4章の条項に従ってライセンスされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. XDR Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4。 XDR説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document contains the XDR ([XDR]) description of the NFSv4.1 block layout protocol. The XDR description is embedded in this document in a way that makes it simple for the reader to extract into a ready-to-compile form. The reader can feed this document into the following shell script to produce the machine readable XDR description of the NFSv4.1 block layout:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、NFSv4.1ブロックレイアウトプロトコルのXDR（[XDR]）記述を含みます。 XDRの説明は、それが単純な読者がすぐにコンパイル形式に抽出することを可能にするように、この文書に埋め込まれています。リーダはNFSv4.1ブロックレイアウトの機械可読XDR記述を生成するために、次のシェル・スクリプトにこの文書を供給することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#!/bin/sh grep &#39;^ *///&#39; $* | sed &#39;s?^ */// ??&#39; | sed &#39;s?^ *///$??&#39;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ます。＃！/ bin / shのはgrep &#39;^ * ///&#39; $ * | SEDの？^ * /// ?? &#39; | SEDの？^ * /// $ ?? &#39;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That is, if the above script is stored in a file called &#34;extract.sh&#34;, and this document is in a file called &#34;spec.txt&#34;, then the reader can do:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のスクリプトは、その後、読者が行うことができ、「extract.sh」と呼ばれるファイルに保存されており、この文書は「spec.txt」というファイルになっている場合には、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
sh extract.sh &lt; spec.txt &gt; nfs4_block_layout_spec.x
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SH extract.sh &lt;spec.txt&gt; nfs4_block_layout_spec.x
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The effect of the script is to remove both leading white space and a sentinel sequence of &#34;///&#34; from each matching line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スクリプトの効果は、先頭の空白各マッチラインから「///」のセンチネル配列の両方を除去することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The embedded XDR file header follows, with subsequent pieces embedded throughout the document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
埋め込みXDRファイルヘッダは、ドキュメント全体に埋め込ま後続片と、次の
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// /*
   ///  * This code was derived from RFC 5663.
   ///  * Please reproduce this note if possible.
   ///  */
   /// /*
   ///  * Copyright (c) 2010 IETF Trust and the persons identified
   ///  * as the document authors.  All rights reserved.
   ///  *
   ///  * Redistribution and use in source and binary forms, with
   ///  * or without modification, are permitted provided that the
   ///  * following conditions are met:
   ///  *
   ///  * - Redistributions of source code must retain the above
   ///  *   copyright notice, this list of conditions and the
   ///  *   following disclaimer.
   ///  *
   ///  * - Redistributions in binary form must reproduce the above
   ///  *   copyright notice, this list of conditions and the
   ///  *   following disclaimer in the documentation and/or other
   ///  *   materials provided with the distribution.
   ///  *
   ///  * - Neither the name of Internet Society, IETF or IETF
   ///  *   Trust, nor the names of specific contributors, may be
   ///  *   used to endorse or promote products derived from this
   ///  *   software without specific prior written permission.
   ///  *
   ///  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
   ///  *   AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED
   ///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   ///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
   ///  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
   ///  *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   ///  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   ///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   ///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   ///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   ///  *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   ///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
   ///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   ///  *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   ///  */
   ///
   /// /*
   ///  *      nfs4_block_layout_prot.x
   ///  */
   ///
   /// %#include &#34;nfsv41.h&#34;
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The XDR code contained in this document depends on types from the nfsv41.x file. This includes both nfs types that end with a 4, such as offset4, length4, etc., as well as more generic types such as uint32_t and uint64_t.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書に含まれるXDRコードはnfsv41.xファイルからの種類によって異なります。これは、等OFFSET4、LENGTH4、並びにのuint32_tとuint64_tを、より一般的なタイプとして4で終わるNFSタイプ、の両方を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Block Layout Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.ブロックレイアウトの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Background and Architecture
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。背景とアーキテクチャ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fundamental storage abstraction supported by block/volume storage is a storage volume consisting of a sequential series of fixed-size blocks. This can be thought of as a logical disk; it may be realized by the storage system as a physical disk, a portion of a physical disk, or something more complex (e.g., concatenation, striping, RAID, and combinations thereof) involving multiple physical disks or portions thereof.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック/容量ストレージによってサポートされる基本的なストレージ抽象化は、固定サイズのブロックの連続する一連からなるストレージ・ボリュームです。これは、論理ディスクとして考えることができます。それは、物理ディスク、物理ディスクの一部、またはより複雑な何かとしてのストレージシステムで実現してもよい（例えば、連結、ストライピング、RAID、およびそれらの組み合わせ）は、複数の物理ディスクまたは部分を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A pNFS layout for this block/volume class of storage is responsible for mapping from an NFS file (or portion of a file) to the blocks of storage volumes that contain the file. The blocks are expressed as extents with 64-bit offsets and lengths using the existing NFSv4 offset4 and length4 types. Clients must be able to perform I/O to the block extents without affecting additional areas of storage (especially important for writes); therefore, extents MUST be aligned to 512-byte boundaries, and writable extents MUST be aligned to the block size used by the NFSv4 server in managing the actual file system (4 kilobytes and 8 kilobytes are common block sizes). This block size is available as the NFSv4.1 layout_blksize attribute. [NFSv4.1]. Readable extents SHOULD be aligned to the block size used by the NFSv4 server, but in order to support legacy file systems with fragments, alignment to 512-byte boundaries is acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージのこのブロック/ボリュームクラスのpNFSのレイアウトは、ファイルを含むストレージボリュームのブロックにNFSファイル（またはファイルの一部）からのマッピングを担当します。ブロックは、既存のNFSv4 OFFSET4とLENGTH4タイプを使用して、64ビットのオフセットおよび長さを有するエクステントとして表されます。クライアントは、ストレージ（書き込みのために特に重要）の追加的な分野に影響を与えることなく、ブロックのエクステントにI / Oを実行できなければなりません。従って、エクステントは512バイト境界に整列されなければならない、及び書き込み可能なエクステントは（4キロバイトおよび8キロバイト共通ブロックサイズである）実際のファイルシステムを管理するNFSv4サーバによって使用されるブロックサイズに整列されなければなりません。このブロックのサイズは、NFSv4.1のlayout_blksize属性として使用可能です。 【NFSv4.1]。読み取り可能なエクステントはNFSv4サーバによって使用されるブロックサイズに整列されるべきであるが、フラグメントとレガシーファイルシステムをサポートするために、512バイト境界にアライメントが許容可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pNFS operation for requesting a layout (LAYOUTGET) includes the &#34;layoutiomode4 loga_iomode&#34; argument, which indicates whether the requested layout is for read-only use or read-write use. A read-only layout may contain holes that are read as zero, whereas a read-write layout will contain allocated, but un-initialized storage in those holes (read as zero, can be written by client). This document also supports client participation in copy-on-write (e.g., for file systems with snapshots) by providing both read-only and un-initialized storage for the same range in a layout. Reads are initially performed on the read-only storage, with writes going to the un-initialized storage. After the first write that initializes the un-initialized storage, all reads are performed to that now-initialized writable storage, and the corresponding read-only storage is no longer used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウト（LAYOUTGET）を要求するためのpNFS動作が要求されたレイアウトは、読み取り専用使用または読み取りと書き込み用であるかどうかを示す「layoutiomode4 loga_iomode」引数を含みます。読み書きレイアウトが割り当てられたが、これらの穴に未初期化ストレージは（0として読ま、クライアントによって書き込むことができる）含有するであろう一方、読み取り専用レイアウトは、0として読まれる穴を含むことができます。この文書はまた、（例えば、スナップショットとファイルシステムの）レイアウトで同じ範囲のための読み取り専用および未初期化ストレージの両方を提供することにより、コピー・オン・ライトでのクライアントの参加をサポートしています。最初に書き込みが初期化されていないストレージに行くと、読み出し専用の記憶装置上で実行されている読み込みます。未初期化ストレージを初期化する最初の書き込みの後、すべてが読み取る今初期化書き込み可能なストレージに行われないため、対応する読み取り専用ストレージはもはや使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The block/volume layout solution expands the security responsibilities of the pNFS clients, and there are a number of environments where the mandatory to implement security properties for NFS cannot be satisfied. The additional security responsibilities of the client follow, and a full discussion is present in Section 3, &#34;Security Considerations&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック/ボリュームレイアウト溶液はpNFSのクライアントのセキュリティ責任を拡張し、NFSのセキュリティプロパティを実装するために必須では満たすことができない環境の数があります。クライアントの追加のセキュリティの責任は、次のとおりと完全な議論は第3節、「セキュリティに関する考慮事項」に存在しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Typically, storage area network (SAN) disk arrays and SAN protocols provide access control mechanisms (e.g., Logical Unit Number (LUN) mapping and/or masking), which operate at the granularity of individual hosts, not individual blocks. For this reason, block-based protection must be provided by the client software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O典型的には、ストレージエリアネットワーク（SAN）ディスクアレイとSANプロトコルは、個々のホストではなく、個々のブロックの粒度で動作するアクセス制御機構（例えば、論理ユニット番号（LUN）マッピング及び/又はマスキング）を提供します。このため、ブロックベースの保護は、クライアントソフトウェアによって提供されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Similarly, SAN disk arrays and SAN protocols typically are not able to validate NFS locks that apply to file regions. For instance, if a file is covered by a mandatory read-only lock, the server can ensure that only readable layouts for the file are granted to pNFS clients. However, it is up to each pNFS client to ensure that the readable layout is used only to service read requests, and not to allow writes to the existing parts of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O同様に、SANのディスクアレイとSANプロトコルは、典型的には、領域をファイルに適用NFSロックを検証することができません。ファイルは必須読み取り専用ロックでカバーされている場合たとえば、サーバーは、ファイルのための唯一の読み込み可能なレイアウトはpNFSのクライアントに付与されていることを確認することができます。しかし、それは読みやすいレイアウトはサービスが要求を読んでのみ使用され、ファイルの既存の部品への書き込みを許可しないことを確実にするために、それぞれのpNFSクライアント次第です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since block/volume storage systems are generally not capable of enforcing such file-based security, in environments where pNFS clients cannot be trusted to enforce such policies, pNFS block/volume storage layouts SHOULD NOT be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック/容量ストレージ・システムは、一般のpNFSクライアントはそのようなポリシーを適用する信頼できない環境において、そのようなファイルベースのセキュリティを強化することができないため、pNFSのブロック/ボリューム・ストレージ・レイアウトを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. GETDEVICELIST and GETDEVICEINFO
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2。 GETDEVICELISTとGETDEVICEINFO
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. Volume Identification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1。ボリューム識別
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Storage systems such as storage arrays can have multiple physical network ports that need not be connected to a common network, resulting in a pNFS client having simultaneous multipath access to the same storage volumes via different ports on different networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなストレージアレイなどのストレージシステムは、異なるネットワーク上の異なるポートを介して、同一のストレージ・ボリュームへの同時マルチアクセスを有するのpNFSクライアントで得られた、共通のネットワークに接続される必要はなく、複数の物理ネットワークポートを有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The networks may not even be the same technology -- for example, access to the same volume via both iSCSI and Fibre Channel is possible, hence network addresses are difficult to use for volume identification. For this reason, this pNFS block layout identifies storage volumes by content, for example providing the means to match (unique portions of) labels used by volume managers. Volume identification is performed by matching one or more opaque byte sequences to specific parts of the stored data. Any block pNFS system using this layout MUST support a means of content-based unique volume identification that can be employed via the data structure given here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークがあっても同じ技術ではないかもしれない - 例えば、iSCSIとファイバ・チャネルの両方を介して同じボリュームへのアクセスが可能であり、したがってネットワークアドレスは、ボリューム識別のために使用することが困難です。この理由のため、このpNFSのブロックレイアウトは、ボリュームマネージャによって使用されるラベル（のユニークな部分）と一致する手段を提供する、例えば、コンテンツによってストレージボリュームを識別する。ボリューム識別は、格納されたデータの特定の部分への1つの以上の不透明なバイトシーケンスを照合することによって行われます。このレイアウトを使用して、任意のブロックのpNFSシステムは、ここで与えられたデータ構造を介して使用することができるコンテンツベースの一意のボリューム識別の手段をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct pnfs_block_sig_component4 { /* disk signature component */
   ///     int64_t bsc_sig_offset;        /* byte offset of component
   ///                                       on volume*/
   ///     opaque  bsc_contents&lt;&gt;;        /* contents of this component
   ///                                       of the signature */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the opaque &#34;bsc_contents&#34; field in the &#34;pnfs_block_sig_component4&#34; structure MUST NOT be interpreted as a zero-terminated string, as it may contain embedded zero-valued bytes. There are no restrictions on alignment (e.g., neither bsc_sig_offset nor the length are required to be multiples of 4). The bsc_sig_offset is a signed quantity, which, when positive, represents an byte offset from the start of the volume, and when negative represents an byte offset from the end of the volume.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、ゼロ値のバイトが埋め込まれてもよいように、「pnfs_block_sig_component4」構造における不透明「bsc_contents」フィールドは、ゼロ終端文字列として解釈されてはならないことに注意してください。アラインメントに制限はありません（例えば、いずれbsc_sig_offsetも長さが4の倍数である必要があります）。 bsc_sig_offsetは、正ボリュームの先頭からのバイトオフセットを表し、符号付き量であり、そして場合負するボリュームの末尾からのバイトオフセットを表しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Negative offsets are permitted in order to simplify the client implementation on systems where the device label is found at a fixed offset from the end of the volume. If the server uses negative offsets to describe the signature, then the client and server MUST NOT see different volume sizes. Negative offsets SHOULD NOT be used in systems that dynamically resize volumes unless care is taken to ensure that the device label is always present at the offset from the end of the volume as seen by the clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
負のオフセットは、デバイスラベルが固定ボリュームの末尾からのオフセットで発見されているシステム上のクライアントの実装を簡素化するために許可されています。サーバは、署名を記述するために、負のオフセットを使用する場合、クライアントとサーバーは異なるボリュームサイズを参照してはなりません。負のオフセットは、介護がデバイスラベルは、クライアントから見たボリュームの末尾からのオフセットに常に存在していることを保証するために取られない限り、ボリュームを動的にリサイズするシステムでは使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A signature is an array of up to &#34;PNFS_BLOCK_MAX_SIG_COMP&#34; (defined below) signature components. The client MUST NOT assume that all signature components are co-located within a single sector on a block device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名は、（以下に定義）「PNFS_BLOCK_MAX_SIG_COMP」署名コンポーネントまでの配列です。クライアントは、すべての署名コンポーネントがブロック・デバイス上の単一のセクタ内の同じ場所に配置されていると仮定してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pNFS client block layout driver uses this volume identification to map pnfs_block_volume_type4 PNFS_BLOCK_VOLUME_SIMPLE deviceid4s to its local view of a LUN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSのクライアントブロックレイアウトドライバは、LUNのローカルビューにpnfs_block_volume_type4 PNFS_BLOCK_VOLUME_SIMPLEのdeviceid4sをマッピングするために、このボリューム識別子を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. Volume Topology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2。ボリュームトポロジ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pNFS block server volume topology is expressed as an arbitrary combination of base volume types enumerated in the following data structures. The individual components of the topology are contained in an array and components may refer to other components by using array indices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSのブロック・サーバ・ボリュームトポロジは、以下のデータ構造で列挙ベースボリュームタイプの任意の組み合わせとして表現されます。トポロジーの個々の成分は、アレイに含まれ、コンポーネントは、配列インデックスを使用して、他の構成要素を指すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// enum pnfs_block_volume_type4 {
   ///     PNFS_BLOCK_VOLUME_SIMPLE = 0,  /* volume maps to a single
   ///                                       LU */
   ///     PNFS_BLOCK_VOLUME_SLICE  = 1,  /* volume is a slice of
   ///                                       another volume */
   ///     PNFS_BLOCK_VOLUME_CONCAT = 2,  /* volume is a
   ///                                       concatenation of
   ///                                       multiple volumes */
   ///     PNFS_BLOCK_VOLUME_STRIPE = 3   /* volume is striped across
   ///                                       multiple volumes */
   /// };
   ///
   /// const PNFS_BLOCK_MAX_SIG_COMP = 16;/* maximum components per
   ///                                       signature */
   /// struct pnfs_block_simple_volume_info4 {
   ///     pnfs_block_sig_component4 bsv_ds&lt;PNFS_BLOCK_MAX_SIG_COMP&gt;;
   ///                                    /* disk signature */
   /// };
   ///
   ///
   /// struct pnfs_block_slice_volume_info4 {
   ///     offset4  bsv_start;            /* offset of the start of the
   ///                                       slice in bytes */
   ///     length4  bsv_length;           /* length of slice in bytes */
   ///     uint32_t bsv_volume;           /* array index of sliced
   ///                                       volume */
   /// };
   ///
   /// struct pnfs_block_concat_volume_info4 {
   ///     uint32_t  bcv_volumes&lt;&gt;;       /* array indices of volumes
   ///                                       which are concatenated */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// };
   ///
   /// struct pnfs_block_stripe_volume_info4 {
   ///     length4  bsv_stripe_unit;      /* size of stripe in bytes */
   ///     uint32_t bsv_volumes&lt;&gt;;        /* array indices of volumes
   ///                                       which are striped across --
   ///                                       MUST be same size */
   /// };
   ///
   /// union pnfs_block_volume4 switch (pnfs_block_volume_type4 type) {
   ///     case PNFS_BLOCK_VOLUME_SIMPLE:
   ///         pnfs_block_simple_volume_info4 bv_simple_info;
   ///     case PNFS_BLOCK_VOLUME_SLICE:
   ///         pnfs_block_slice_volume_info4 bv_slice_info;
   ///     case PNFS_BLOCK_VOLUME_CONCAT:
   ///         pnfs_block_concat_volume_info4 bv_concat_info;
   ///     case PNFS_BLOCK_VOLUME_STRIPE:
   ///         pnfs_block_stripe_volume_info4 bv_stripe_info;
   /// };
   ///
   /// /* block layout specific type for da_addr_body */
   /// struct pnfs_block_deviceaddr4 {
   ///     pnfs_block_volume4 bda_volumes&lt;&gt;; /* array of volumes */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;pnfs_block_deviceaddr4&#34; data structure is a structure that allows arbitrarily complex nested volume structures to be encoded. The types of aggregations that are allowed are stripes, concatenations, and slices. Note that the volume topology expressed in the pnfs_block_deviceaddr4 data structure will always resolve to a set of pnfs_block_volume_type4 PNFS_BLOCK_VOLUME_SIMPLE. The array of volumes is ordered such that the root of the volume hierarchy is the last element of the array. Concat, slice, and stripe volumes MUST refer to volumes defined by lower indexed elements of the array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「pnfs_block_deviceaddr4」データ構造は、任意の複雑なネストされたボリューム構造が符号化されることを可能にする構造です。許可されている集計の種類は、ストライプ、の連結、およびスライスされています。 pnfs_block_deviceaddr4データ構造で表現ボリュームトポロジが常にpnfs_block_volume_type4 PNFS_BLOCK_VOLUME_SIMPLEのセットに解決されることに注意してください。ボリュームの配列は、ボリューム階層のルートは、配列の最後の要素であるように命じています。連結、スライス、ストライプ・ボリュームは、アレイの下側インデックス付き要素によって定義されたボリュームを参照しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;pnfs_block_device_addr4&#34; data structure is returned by the server as the storage-protocol-specific opaque field da_addr_body in the &#34;device_addr4&#34; structure by a successful GETDEVICEINFO operation [NFSv4.1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「pnfs_block_device_addr4」データ構造が[NFSv4.1]成功GETDEVICEINFO操作により「device_addr4」構造におけるストレージプロトコル固有の不透明なフィールドda_addr_bodyとしてサーバによって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted above, all device_addr4 structures eventually resolve to a set of volumes of type PNFS_BLOCK_VOLUME_SIMPLE. These volumes are each uniquely identified by a set of signature components. Complicated volume hierarchies may be composed of dozens of volumes each with several signature components; thus, the device address may require several kilobytes. The client SHOULD be prepared to allocate a large buffer to contain the result. In the case of the server returning NFS4ERR_TOOSMALL, the client SHOULD allocate a buffer of at least gdir_mincount_bytes to contain the expected result and retry the GETDEVICEINFO request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述のように、すべてのdevice_addr4構造は、最終的に型PNFS_BLOCK_VOLUME_SIMPLEのボリュームのセットに解決します。これらのボリュームは、それぞれ一意の署名コンポーネントのセットによって識別されます。複雑なボリューム階層は、ボリュームいくつかの署名コンポーネントとそれぞれ数十から構成されてもよいです。このように、デバイスのアドレスは、数キロバイトが必要な場合があります。クライアントが結果を格納するための大きなバッファを割り当てるために準備する必要があります。 NFS4ERR_TOOSMALLを返すサーバの場合には、クライアントは、期待される結果を含み、GETDEVICEINFO要求を再試行する少なくともgdir_mincount_bytesのバッファを割り当てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3. GETDEVICELIST and GETDEVICEINFO deviceid4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3。 GETDEVICELISTとGETDEVICEINFO deviceid4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server in response to a GETDEVICELIST request typically will return a single &#34;deviceid4&#34; in the gdlr_deviceid_list array. This is because the deviceid4 when passed to GETDEVICEINFO will return a &#34;device_addr4&#34;, which encodes the entire volume hierarchy. In the case of copy-on-write file systems, the &#34;gdlr_deviceid_list&#34; array may contain two deviceid4&#39;s, one referencing the read-only volume hierarchy, and one referencing the writable volume hierarchy. There is no required ordering of the readable and writable IDs in the array as the volumes are uniquely identified by their deviceid4, and are referred to by layouts using the deviceid4. Another example of the server returning multiple device items occurs when the file handle represents the root of a namespace spanning multiple physical file systems on the server, each with a different volume hierarchy. In this example, a server implementation may return either a list of device IDs used by each of the physical file systems, or it may return an empty list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETDEVICELIST要求に応じて、サーバは、一般的にgdlr_deviceid_list配列のシングル「deviceid4」を返します。 GETDEVICEINFOに渡されたdeviceid4は、ボリューム全体の階層をコードする「device_addr4を」、返されるためです。コピー・オン・ライトのファイルシステムの場合は、「gdlr_deviceid_list」配列は、書き込み可能なボリューム階層を参照する2つのdeviceid4年代、読み取り専用ボリューム階層を参照する1、および1つが含まれていてもよいです。ボリュームが一意にdeviceid4によって識別され、deviceid4を使ってレイアウトによって参照される配列の読み書き可能なIDの一切の必要な順序はありません。ファイルハンドルは、サーバー上の複数の物理ファイル・システム、異なるボリューム階層各スパニング名前空間のルートを表す場合、複数のデバイスのアイテムを返すサーバの別の例が生じます。この例では、サーバの実装は、物理ファイル・システムのそれぞれによって使用されるデバイスIDのリストを返すことができる、またはそれは空のリストを返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each deviceid4 returned by a successful GETDEVICELIST operation is a shorthand id used to reference the whole volume topology. These device IDs, as well as device IDs returned in extents of a LAYOUTGET operation, can be used as input to the GETDEVICEINFO operation. Decoding the &#34;pnfs_block_deviceaddr4&#34; results in a flat ordering of data blocks mapped to PNFS_BLOCK_VOLUME_SIMPLE volumes. Combined with the mapping to a client LUN described in Section 2.2.1 &#34;Volume Identification&#34;, a logical volume offset can be mapped to a block on a pNFS client LUN [NFSv4.1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功GETDEVICELIST操作によって返された各deviceid4全体ボリュームトポロジを参照するために使用速記のIDです。これらのデバイスID、ならびにLAYOUTGET動作の範囲で返されたデバイスIDは、GETDEVICEINFO動作への入力として使用することができます。 PNFS_BLOCK_VOLUME_SIMPLEボリュームにマッピングされたデータブロックのフラットな順序で「pnfs_block_deviceaddr4」の結果をデコードします。 LUNは、セクション2.2.1で説明したクライアントへのマッピングと組み合わせる「ボリューム識別」、オフセット論理ボリュームのpNFSクライアントLUN [NFSv4.1]上のブロックにマッピングすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Data Structures: Extents and Extent Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3。データ構造：エクステントとエクステントリスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A pNFS block layout is a list of extents within a flat array of data blocks in a logical volume. The details of the volume topology can be determined by using the GETDEVICEINFO operation (see discussion of volume identification, Section 2.2 above). The block layout describes the individual block extents on the volume that make up the file. The offsets and length contained in an extent are specified in units of bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSのブロックレイアウトは、論理ボリューム内のデータブロックの平坦なアレイ内のエクステントのリストです。ボリュームトポロジの詳細はGETDEVICEINFO操作を使用して決定することができる（ボリューム識別、上記セクション2.2の考察を参照）。ブロックレイアウトは、ファイルを構成するボリューム上の個々のブロックのエクステントを記述する。エクステントに含まれるオフセットと長さをバイト単位で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// enum pnfs_block_extent_state4 {
   ///     PNFS_BLOCK_READ_WRITE_DATA = 0,/* the data located by this
   ///                                       extent is valid
   ///                                       for reading and writing. */
   ///     PNFS_BLOCK_READ_DATA      = 1, /* the data located by this
   ///                                       extent is valid for reading
   ///                                       only; it may not be
   ///                                       written. */
   ///     PNFS_BLOCK_INVALID_DATA   = 2, /* the location is valid; the
   ///                                       data is invalid.  It is a
   ///                                       newly (pre-) allocated
   ///                                       extent.  There is physical
   ///                                       space on the volume. */
   ///     PNFS_BLOCK_NONE_DATA      = 3  /* the location is invalid.
   ///                                       It is a hole in the file.
   ///                                       There is no physical space
   ///                                       on the volume. */
   /// };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ///
   /// struct pnfs_block_extent4 {
   ///     deviceid4    bex_vol_id;       /* id of logical volume on
   ///                                       which extent of file is
   ///                                       stored. */
   ///     offset4      bex_file_offset;  /* the starting byte offset in
   ///                                       the file */
   ///     length4      bex_length;       /* the size in bytes of the
   ///                                       extent */
   ///     offset4      bex_storage_offset;  /* the starting byte offset
   ///                                       in the volume */
   ///     pnfs_block_extent_state4 bex_state;
   ///                                    /* the state of this extent */
   /// };
   ///
   /// /* block layout specific type for loc_body */
   /// struct pnfs_block_layout4 {
   ///     pnfs_block_extent4 blo_extents&lt;&gt;;
   ///                                    /* extents which make up this
   ///                                       layout. */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The block layout consists of a list of extents that map the logical regions of the file to physical locations on a volume. The &#34;bex_storage_offset&#34; field within each extent identifies a location on the logical volume specified by the &#34;bex_vol_id&#34; field in the extent. The bex_vol_id itself is shorthand for the whole topology of the logical volume on which the file is stored. The client is responsible for translating this logical offset into an offset on the appropriate underlying SAN logical unit. In most cases, all extents in a layout will reside on the same volume and thus have the same bex_vol_id. In the case of copy-on-write file systems, the PNFS_BLOCK_READ_DATA extents may have a different bex_vol_id from the writable extents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックレイアウトは、ボリューム上の物理的な位置にファイルの論理的な領域をマッピングエクステントのリストから成ります。各エクステント内の「bex_storage_offset」フィールドは、エクステントに「bex_vol_id」フィールドによって指定された論理ボリューム上の位置を特定します。 bex_vol_id自体は、ファイルが格納されている論理ボリュームの全体のトポロジーの省略形です。クライアントは、適切な基礎となるSAN論理ユニットにオフセットへのオフセットこの論理を変換する責任があります。ほとんどの場合、レイアウト内のすべてのエクステントが同じボリューム上に存在するため、同じbex_vol_idを持つことになります。コピー・オン・ライトのファイルシステムの場合は、PNFS_BLOCK_READ_DATAエクステントは、書き込み可能なエクステントは異なるbex_vol_idを有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each extent maps a logical region of the file onto a portion of the specified logical volume. The bex_file_offset, bex_length, and bex_state fields for an extent returned from the server are valid for all extents. In contrast, the interpretation of the bex_storage_offset field depends on the value of bex_state as follows (in increasing order):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各エクステントは、指定された論理ボリュームの部分にファイルの論理的な領域をマッピングします。サーバから返されたエクステントのbex_file_offset、bex_length、およびbex_stateフィールドは、すべてのエクステントのために有効です。対照的に、bex_storage_offsetフィールドの解釈は、（昇順で）次のようにbex_stateの値に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PNFS_BLOCK_READ_WRITE_DATA means that bex_storage_offset is valid, and points to valid/initialized data that can be read and written.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PNFS_BLOCK_READ_WRITE_DATAはbex_storage_offsetが有効であることを意味し、読み書き可能な有効/初期化されたデータを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PNFS_BLOCK_READ_DATA means that bex_storage_offset is valid and points to valid/ initialized data that can only be read. Write operations are prohibited; the client may need to request a read-write layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PNFS_BLOCK_READ_DATAはbex_storage_offsetしか読み取ることができ、有効/初期化されたデータを有効とポイントであることを意味します。書き込み操作が禁止されています。クライアントは、読み書きのレイアウトを要求する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PNFS_BLOCK_INVALID_DATA means that bex_storage_offset is valid, but points to invalid un-initialized data. This data must not be physically read from the disk until it has been initialized. A read request for a PNFS_BLOCK_INVALID_DATA extent must fill the user buffer with zeros, unless the extent is covered by a PNFS_BLOCK_READ_DATA extent of a copy-on-write file system. Write requests must write whole server-sized blocks to the disk; bytes not initialized by the user must be set to zero. Any write to storage in a PNFS_BLOCK_INVALID_DATA extent changes the written portion of the extent to PNFS_BLOCK_READ_WRITE_DATA; the pNFS client is responsible for reporting this change via LAYOUTCOMMIT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PNFS_BLOCK_INVALID_DATAはbex_storage_offsetが有効であることを意味しますが、ポイントは初期化されていないデータを無効します。それが初期化されるまで、このデータは、物理的にディスクから読み取ることはできません。エクステントは、コピーオンライトファイルシステムのPNFS_BLOCK_READ_DATAの程度によって覆われていない限りPNFS_BLOCK_INVALID_DATAエクステントの読み出し要求は、ゼロでユーザバッファを埋めなければなりません。書き込み要求は、ディスクへのサーバ全体サイズのブロックを記述する必要があります。ユーザーが初期化されていないバイトをゼロに設定する必要があります。 PNFS_BLOCK_INVALID_DATAエクステントの記憶への書き込みはPNFS_BLOCK_READ_WRITE_DATA程度の書かれた部分を変更します。 pNFSのクライアントはLAYOUTCOMMIT経由でこの変更を報告する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PNFS_BLOCK_NONE_DATA means that bex_storage_offset is not valid, and this extent may not be used to satisfy write requests. Read requests may be satisfied by zero-filling as for PNFS_BLOCK_INVALID_DATA. PNFS_BLOCK_NONE_DATA extents may be returned by requests for readable extents; they are never returned if the request was for a writable extent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PNFS_BLOCK_NONE_DATAはbex_storage_offsetが有効でないことを意味し、この範囲は、書き込み要求を満たすために使用することはできません。 PNFS_BLOCK_INVALID_DATA用としてゼロフィリングによって満たされるリクエストをお読みください。 PNFS_BLOCK_NONE_DATAエクステントが読める程度の要求によって返されることがあります。リクエストが書き込み可能な範囲のためだった場合、彼らが返されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extent list contains all relevant extents in increasing order of the bex_file_offset of each extent; any ties are broken by increasing order of the extent state (bex_state).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲リストは、各エクステントのbex_file_offsetの昇順に関連するすべてのエクステントが含まれています。任意関係は、エクステント状態（bex_state）の順序を増加させることによって破壊されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. Layout Requests and Extent Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1。要求とエクステントリストのレイアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each request for a layout specifies at least three parameters: file offset, desired size, and minimum size. If the status of a request indicates success, the extent list returned must meet the following criteria:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルオフセット、所望の大きさ、および最小サイズ：レイアウトのための各要求は、少なくとも3つのパラメータを指定します。リクエストのステータスが成功を示す場合、エクステントリストが返され、次の条件を満たしている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A request for a readable (but not writable) layout returns only PNFS_BLOCK_READ_DATA or PNFS_BLOCK_NONE_DATA extents (but not PNFS_BLOCK_INVALID_DATA or PNFS_BLOCK_READ_WRITE_DATA extents).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O読み取り可能な（しかし書き込み可能ではない）のレイアウトの要求がPNFS_BLOCK_READ_DATAまたはPNFS_BLOCK_NONE_DATAエクステント（ただしPNFS_BLOCK_INVALID_DATA又はPNFS_BLOCK_READ_WRITE_DATAエクステント）のみを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A request for a writable layout returns PNFS_BLOCK_READ_WRITE_DATA or PNFS_BLOCK_INVALID_DATA extents (but not PNFS_BLOCK_NONE_DATA extents). It may also return PNFS_BLOCK_READ_DATA extents only when the offset ranges in those extents are also covered by PNFS_BLOCK_INVALID_DATA extents to permit writes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O書き込み可能なレイアウトの要求が返さPNFS_BLOCK_READ_WRITE_DATAまたはPNFS_BLOCK_INVALID_DATAエクステント（しかしPNFS_BLOCK_NONE_DATAないエクステント）。これらのエクステントのオフセット範囲も書き込みを許可するPNFS_BLOCK_INVALID_DATAのエクステントでカバーされている場合にのみ、それはまたPNFS_BLOCK_READ_DATAエクステントを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The first extent in the list MUST contain the requested starting offset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oリストの最初のエクステントは、オフセット要求の開始を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The total size of extents within the requested range MUST cover at least the minimum size. One exception is allowed: the total size MAY be smaller if only readable extents were requested and EOF is encountered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O要求された範囲内のエクステントの合計サイズが少なくとも最小サイズをカバーしなければなりません。一つの例外が許可されている：のみ読み込み可能なエクステントが要求されたとEOFが発生した場合の合計サイズが小さくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Extents in the extent list MUST be logically contiguous for a read-only layout. For a read-write layout, the set of writable extents (i.e., excluding PNFS_BLOCK_READ_DATA extents) MUST be logically contiguous. Every PNFS_BLOCK_READ_DATA extent in a read-write layout MUST be covered by one or more PNFS_BLOCK_INVALID_DATA extents. This overlap of PNFS_BLOCK_READ_DATA and PNFS_BLOCK_INVALID_DATA extents is the only permitted extent overlap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O範囲リスト内のエクステントは、読み取り専用のレイアウトのための論理的に連続している必要があります。読み書きレイアウト（すなわち、PNFS_BLOCK_READ_DATAエクステントを除く）書き込み可能なエクステントの集合は、論理的に連続していなければなりません。読み書きレイアウト内のすべてのPNFS_BLOCK_READ_DATAの範囲は、一つ以上のPNFS_BLOCK_INVALID_DATAエクステントによって覆われている必要があります。 PNFS_BLOCK_READ_DATAとPNFS_BLOCK_INVALID_DATAエクステントのこの重なりは、許可された範囲の重複です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Extents MUST be ordered in the list by starting offset, with PNFS_BLOCK_READ_DATA extents preceding PNFS_BLOCK_INVALID_DATA extents in the case of equal bex_file_offsets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oエクステントは等しいbex_file_offsetsの場合にPNFS_BLOCK_INVALID_DATAエクステントの前PNFS_BLOCK_READ_DATAエクステントと、開始オフセットによってリストに注文する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the minimum requested size, loga_minlength, is zero, this is an indication to the metadata server that the client desires any layout at offset loga_offset or less that the metadata server has &#34;readily available&#34;. Readily is subjective, and depends on the layout type and the pNFS server implementation. For block layout servers, readily available SHOULD be interpreted such that readable layouts are always available, even if some extents are in the PNFS_BLOCK_NONE_DATA state. When processing requests for writable layouts, a layout is readily available if extents can be returned in the PNFS_BLOCK_READ_WRITE_DATA state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小の要求されたサイズ、loga_minlengthは、ゼロである場合、これはクライアントがメタデータサーバは、「容易に入手可能」を有することオフセットloga_offset以下で任意のレイアウトを希望するメタデータ・サーバへの指示です。容易に主観的であり、かつレイアウトタイプとのpNFSサーバの実装に依存します。ブロックレイアウトサーバの場合、容易に入手できるが、いくつかのエクステントがPNFS_BLOCK_NONE_DATA状態にある場合でも、読みやすいレイアウトが常に利用可能であるように解釈されるべきです。書き込み可能なレイアウトの要求を処理するときにエクステントがPNFS_BLOCK_READ_WRITE_DATA状態に戻すことができる場合、レイアウトが容易に入手可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2. Layout Commits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2。レイアウトは、コミット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// /* block layout specific type for lou_body */
   /// struct pnfs_block_layoutupdate4 {
   ///     pnfs_block_extent4 blu_commit_list&lt;&gt;;
   ///                                    /* list of extents which
   ///                                     * now contain valid data.
   ///                                     */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;pnfs_block_layoutupdate4&#34; structure is used by the client as the block-protocol specific argument in a LAYOUTCOMMIT operation. The &#34;blu_commit_list&#34; field is an extent list covering regions of the file layout that were previously in the PNFS_BLOCK_INVALID_DATA state, but have been written by the client and should now be considered in the PNFS_BLOCK_READ_WRITE_DATA state. The bex_state field of each extent in the blu_commit_list MUST be set to PNFS_BLOCK_READ_WRITE_DATA. The extents in the commit list MUST be disjoint and MUST be sorted by bex_file_offset. The bex_storage_offset field is unused. Implementors should be aware that a server may be unable to commit regions at a granularity smaller than a file-system block (typically 4 KB or 8 KB). As noted above, the block-size that the server uses is available as an NFSv4 attribute, and any extents included in the &#34;blu_commit_list&#34; MUST be aligned to this granularity and have a size that is a multiple of this granularity. If the client believes that its actions have moved the end-of-file into the middle of a block being committed, the client MUST write zeroes from the end-of-file to the end of that block before committing the block. Failure to do so may result in junk (un-initialized data) appearing in that area if the file is subsequently extended by moving the end-of-file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「pnfs_block_layoutupdate4」構造はLAYOUTCOMMIT動作におけるブロックプロトコル固有の引数としてクライアントによって使用されます。 「blu_commit_list」フィールドはPNFS_BLOCK_INVALID_DATA状態で以前いたファイルレイアウトの領域をカバーする範囲リストですが、クライアントによって書かれていると、今PNFS_BLOCK_READ_WRITE_DATA状態で考慮されるべきです。 blu_commit_list内の各エクステントのbex_stateフィールドはPNFS_BLOCK_READ_WRITE_DATAに設定しなければなりません。コミットリスト内のエクステントは互いに素でなければならないとbex_file_offsetでソートする必要があります。 bex_storage_offsetフィールドが未使用です。実装は、サーバがファイル・システム・ブロック（典型的には4キロバイトまたは8 KB）より小さい粒度で領域をコミットすることができない可能性があることに注意すべきです。上述したように、サーバが使用するブロックサイズはNFSv4の属性として使用可能であり、任意のエクステントが「blu_commit_list」に含まれるこの粒状に位置合わせし、この粒度の倍数のサイズを持っている必要があります。クライアントは、そのアクションがコミットされているブロックの中央にエンド・オブ・ファイルを移動したと考えている場合は、クライアントはブロックをコミットする前にそのブロックの最後に、ファイルの終わりからゼロを書き込む必要があります。これを怠ると、ファイルがその後エンド・オブ・ファイルを移動することによって拡張されている場合、その領域に表示されてジャンクで（未初期化されたデータ）を生じる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.3. Layout Returns
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.3。レイアウトを返します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAYOUTRETURN operation is done without any block layout specific data. When the LAYOUTRETURN operation specifies a LAYOUTRETURN4_FILE_return type, then the layoutreturn_file4 data structure specifies the region of the file layout that is no longer needed by the client. The opaque &#34;lrf_body&#34; field of the &#34;layoutreturn_file4&#34; data structure MUST have length zero. A LAYOUTRETURN operation represents an explicit release of resources by the client, usually done for the purpose of avoiding unnecessary CB_LAYOUTRECALL operations in the future. The client may return disjoint regions of the file by using multiple LAYOUTRETURN operations within a single COMPOUND operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRETURN動作は、任意のブロックレイアウトの特定のデータなしで行われます。 LAYOUTRETURN操作がLAYOUTRETURN4_FILE_returnの種類を指定すると、その後、layoutreturn_file4データ構造はもはやクライアントが必要とするファイルレイアウトの領域を特定します。 「layoutreturn_file4」データ構造の不透明な「lrf_body」フィールドは、長さゼロでなければなりません。 LAYOUTRETURN操作は通常、将来的には不要なCB_LAYOUTRECALL操作を回避する目的で行われ、クライアントによるリソースの明示的な解放を表します。クライアントは、単一の複合操作内で複数LAYOUTRETURN操作を使用して、ファイルの互いに素な領域を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the block/volume layout supports unilateral layout revocation. When a layout is unilaterally revoked by the server, usually due to the client&#39;s lease time expiring, or a delegation being recalled, or the client failing to return a layout in a timely manner, it is important for the sake of correctness that any in-flight I/Os that the client issued before the layout was revoked are rejected at the storage. For the block/volume protocol, this is possible by fencing a client with an expired layout timer from the physical storage. Note, however, that the granularity of this operation can only be at the host/logical-unit level. Thus, if one of a client&#39;s layouts is unilaterally revoked by the server, it will effectively render useless *all* of the client&#39;s layouts for files located on the storage units comprising the logical volume. This may render useless the client&#39;s layouts for files in other file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック/ボリュームレイアウトは、一方的なレイアウトの失効をサポートしていることに注意してください。レイアウトが一方的にタイムリーにレイアウトを返すために失敗により通常、クライアントのリース時間期限切れ、あるいはリコールされている委任、またはクライアントに、サーバーによって取り消された場合、それはどんなイン正しさのために重要ですレイアウトが取り消された前に、クライアントが発行した飛行I / Oはストレージで拒否されています。ブロック/ボリュームプロトコルの場合、これは物理ストレージから期限切れのレイアウトタイマーとクライアントをフェンシングすることによって可能です。この操作の粒度でのみホスト/論理ユニットレベルであることができることは、注意してください。クライアントのレイアウトのいずれかが一方的にサーバーによって取り消された場合このように、それが効果的に役に立たないレンダリングします*論理ボリュームを備えたストレージユニット上にあるファイルのためのクライアントのレイアウトのすべての*。これは、他のファイルシステム内のファイルの役に立たないクライアントのレイアウトをレンダリングすることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.4. Client Copy-on-Write Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.4。クライアントのコピー・オン・ライト処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copy-on-write is a mechanism used to support file and/or file system snapshots. When writing to unaligned regions, or to regions smaller than a file system block, the writer must copy the portions of the original file data to a new location on disk. This behavior can either be implemented on the client or the server. The paragraphs below describe how a pNFS block layout client implements access to a file that requires copy-on-write semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コピー・オン・ライトは、ファイルおよび/またはファイルシステムのスナップショットをサポートするために使用されるメカニズムです。整列されていない領域への、またはファイルシステムのブロックよりもより小さな領域に書き込む場合、ライターは、ディスク上の新しい場所に元のファイルのデータの一部をコピーする必要があります。この動作は、クライアントまたはサーバー上で実装することができます。以下の段落では、pNFSのブロックレイアウトのクライアントは、コピーオンライトセマンティクスを必要とし、ファイルへのアクセスを実装する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Distinguishing the PNFS_BLOCK_READ_WRITE_DATA and PNFS_BLOCK_READ_DATA extent types in combination with the allowed overlap of PNFS_BLOCK_READ_DATA extents with PNFS_BLOCK_INVALID_DATA extents allows copy-on-write processing to be done by pNFS clients. In classic NFS, this operation would be done by the server. Since pNFS enables clients to do direct block access, it is useful for clients to participate in copy-on-write operations. All block/volume pNFS clients MUST support this copy-on-write processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PNFS_BLOCK_INVALID_DATAエクステントとPNFS_BLOCK_READ_DATAエクステントの許容オーバーラップと組み合わせてPNFS_BLOCK_READ_WRITE_DATAとPNFS_BLOCK_READ_DATAエクステントタイプを区別することは、コピーオンライト処理のpNFSクライアントによって行われることを可能にします。古典的なNFSでは、この操作は、サーバーによって行われます。 pNFSの直接ブロックアクセスを行うために、クライアントを可能にするので、クライアントはコピーオンライト操作に参加するために、それは便利です。すべてのブロック/ボリュームのpNFSクライアントは、このコピー・オン・ライト処理をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client wishes to write data covered by a PNFS_BLOCK_READ_DATA extent, it MUST have requested a writable layout from the server; that layout will contain PNFS_BLOCK_INVALID_DATA extents to cover all the data ranges of that layout&#39;s PNFS_BLOCK_READ_DATA extents. More precisely, for any bex_file_offset range covered by one or more PNFS_BLOCK_READ_DATA extents in a writable layout, the server MUST include one or more PNFS_BLOCK_INVALID_DATA extents in the layout that cover the same bex_file_offset range. When performing a write to such an area of a layout, the client MUST effectively copy the data from the PNFS_BLOCK_READ_DATA extent for any partial blocks of bex_file_offset and range, merge in the changes to be written, and write the result to the PNFS_BLOCK_INVALID_DATA extent for the blocks for that bex_file_offset and range. That is, if entire blocks of data are to be overwritten by an operation, the corresponding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがPNFS_BLOCK_READ_DATAの程度によってカバーされたデータを書き込みしたいときは、サーバーから書き込み可能なレイアウトを要求していなければなりません。そのレイアウトは、そのレイアウトのPNFS_BLOCK_READ_DATAエクステントのすべてのデータの範囲をカバーするためにPNFS_BLOCK_INVALID_DATAのエクステントが含まれています。より正確には、書き込み可能なレイアウトの1つ以上のPNFS_BLOCK_READ_DATAエクステントによって覆わ任意bex_file_offset範囲について、サーバは同じbex_file_offset範囲をカバーレイアウト内の1つまたは複数のPNFS_BLOCK_INVALID_DATAエクステントを含まなければなりません。レイアウトのような領域への書き込みを行う場合、クライアントは、効果的に書き込まれるように変更をマージし、bex_file_offset及び範囲の任意の部分ブロックのためPNFS_BLOCK_READ_DATAエクステントからデータをコピーし、そしてためPNFS_BLOCK_INVALID_DATAの程度に結果を書き込む必要がありますそのbex_file_offsetおよび範囲のためのブロック。すなわち、データのブロック全体を操作することによって上書きされる場合、ある対応します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PNFS_BLOCK_READ_DATA blocks need not be fetched, but any partial-block writes must be merged with data fetched via PNFS_BLOCK_READ_DATA extents before storing the result via PNFS_BLOCK_INVALID_DATA extents. For the purposes of this discussion, &#34;entire blocks&#34; and &#34;partial blocks&#34; refer to the server&#39;s file-system block size. Storing of data in a PNFS_BLOCK_INVALID_DATA extent converts the written portion of the PNFS_BLOCK_INVALID_DATA extent to a PNFS_BLOCK_READ_WRITE_DATA extent; all subsequent reads MUST be performed from this extent; the corresponding portion of the PNFS_BLOCK_READ_DATA extent MUST NOT be used after storing data in a PNFS_BLOCK_INVALID_DATA extent. If a client writes only a portion of an extent, the extent may be split at block aligned boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PNFS_BLOCK_READ_DATAブロックをフェッチする必要はなく、任意の部分ブロック書き込みはPNFS_BLOCK_INVALID_DATAエクステントを経由して、結果を格納する前にPNFS_BLOCK_READ_DATAエクステントを経由して取り出されたデータとマージする必要があります。この議論の目的のために、「ブロック全体」と「部分ブロックは、」サーバーのファイルシステムのブロックサイズを参照してください。 PNFS_BLOCK_INVALID_DATAエクステントのデータの格納はPNFS_BLOCK_READ_WRITE_DATAエクステントにPNFS_BLOCK_INVALID_DATAエクステントの書かれた部分を変換します。後続のすべてがこの範囲から実行されなければならない読み出します。 PNFS_BLOCK_READ_DATAエクステントの対応する部分がPNFS_BLOCK_INVALID_DATAエクステントにデータを格納した後に使用してはいけません。クライアントはある程度の一部のみを書き込んだ場合、範囲はブロックアライン境界で分割することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client wishes to write data to a PNFS_BLOCK_INVALID_DATA extent that is not covered by a PNFS_BLOCK_READ_DATA extent, it MUST treat this write identically to a write to a file not involved with copy-on-write semantics. Thus, data must be written in at least block-sized increments, aligned to multiples of block-sized offsets, and unwritten portions of blocks must be zero filled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがPNFS_BLOCK_READ_DATAの範囲で覆われていないPNFS_BLOCK_INVALID_DATAエクステントにデータを書き込むことを希望する場合、それはコピーオンライトセマンティクスに関与していないファイルへの書き込みと同一にこの書き込みを扱わなければなりません。したがって、データは、少なくともブロックサイズ単位で書かれたブロックサイズオフセットの倍数に揃え、そしてブロックの未書き込み部分はゼロで埋めなければならないしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the LAYOUTCOMMIT operation that normally sends updated layout information back to the server, for writable data, some PNFS_BLOCK_INVALID_DATA extents may be committed as PNFS_BLOCK_READ_WRITE_DATA extents, signifying that the storage at the corresponding bex_storage_offset values has been stored into and is now to be considered as valid data to be read. PNFS_BLOCK_READ_DATA extents are not committed to the server. For extents that the client receives via LAYOUTGET as PNFS_BLOCK_INVALID_DATA and returns via LAYOUTCOMMIT as PNFS_BLOCK_READ_WRITE_DATA, the server will understand that the PNFS_BLOCK_READ_DATA mapping for that extent is no longer valid or necessary for that file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常バックサーバーに更新されたレイアウト情報を送信LAYOUTCOMMIT動作では、書き込み可能なデータのために、いくつかのPNFS_BLOCK_INVALID_DATAエクステントは、対応bex_storage_offset値でストレージに格納されており、現在有効であると考えられるべきであることを意味する、PNFS_BLOCK_READ_WRITE_DATAエクステントとしてコミットすることができますデータが読み込まれます。 PNFS_BLOCK_READ_DATAエクステントは、サーバーにコミットされていません。クライアントがPNFS_BLOCK_READ_WRITE_DATAとしてLAYOUTCOMMIT経由PNFS_BLOCK_INVALID_DATAとしてLAYOUTGET経由で受け取り、戻りエクステントの場合、サーバーはそのエクステントのPNFS_BLOCK_READ_DATAマッピングは、もはやそのファイルに対して有効か必要でないことを理解するであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.5. Extents are Permissions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.5。エクステントは、権限のあります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Layout extents returned to pNFS clients grant permission to read or write; PNFS_BLOCK_READ_DATA and PNFS_BLOCK_NONE_DATA are read-only (PNFS_BLOCK_NONE_DATA reads as zeroes), PNFS_BLOCK_READ_WRITE_DATA and PNFS_BLOCK_INVALID_DATA are read/write, (PNFS_BLOCK_INVALID_DATA reads as zeros, any write converts it to PNFS_BLOCK_READ_WRITE_DATA). This is the only means a client has of obtaining permission to perform direct I/O to storage devices; a pNFS client MUST NOT perform direct I/O operations that are not permitted by an extent held by the client. Client adherence to this rule places the pNFS server in control of potentially conflicting storage device operations, enabling the server to determine what does conflict and how to avoid conflicts by granting and recalling extents to/from clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトエクステントは、クライアントが読み書きする権限を付与するのpNFSに戻りました。 PNFS_BLOCK_READ_DATAとPNFS_BLOCK_NONE_DATAは、読み取り専用（PNFS_BLOCK_NONE_DATAはゼロとして読み出し）を、PNFS_BLOCK_READ_WRITE_DATA及びPNFS_BLOCK_INVALID_DATAは、読み取り/書き込みされる、（PNFS_BLOCK_INVALID_DATAは、ゼロとして読み出す任意書き込みPNFS_BLOCK_READ_WRITE_DATAに変換します）。これは、クライアントがストレージデバイスへのダイレクトI / Oを実行するために許可を得るのがある意味です。 pNFSのクライアントは、クライアントが保持している範囲で許可されていないダイレクトI / O操作を実行してはなりません。この規則へのクライアント順守は、競合とどのようにクライアントからの/へのエクステントを付与し、リコールによる競合を回避するために何をするかを決定するためにサーバーを有効にする、潜在的にストレージデバイス操作の競合の制御でのpNFSサーバを配置します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Block/volume class storage devices are not required to perform read and write operations atomically. Overlapping concurrent read and write operations to the same data may cause the read to return a mixture of before-write and after-write data. Overlapping write operations can be worse, as the result could be a mixture of data from the two write operations; data corruption can occur if the underlying storage is striped and the operations complete in different orders on different stripes. When there are multiple clients who wish to access the same data, a pNFS server can avoid these conflicts by implementing a concurrency control policy of single writer XOR multiple readers. This policy MUST be implemented when storage devices do not provide atomicity for concurrent read/write and write/write operations to the same data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック/ボリュームクラスのストレージデバイスは、アトミック読み取りおよび書き込み操作を実行する必要はありません。重複同時読み取りと同じデータへの書き込み操作は、読み取り、書き込み、前後のライトデータの混合物を返すために発生することがあります。結果は、2つの書き込み動作からのデータの混合物とすることができるように重複書き込み動作は、より悪いことができます。基礎となるストレージが縞模様と異なるストライプ上の異なる順序で操作が完了している場合、データの破損が発生する可能性があります。同じデータにアクセスしたい複数のクライアントが存在する場合には、pNFSのサーバは、単一のライターXOR複数のリーダーの同時実行制御ポリシーを実装することにより、これらの競合を避けることができます。ストレージデバイスは、同時読み取り/書き込みのための原子性を提供し、同じデータに/書き込み操作を書いていない場合は、このポリシーを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client makes a layout request that conflicts with an existing layout delegation, the request will be rejected with the error NFS4ERR_LAYOUTTRYLATER. This client is then expected to retry the request after a short interval. During this interval, the server SHOULD recall the conflicting portion of the layout delegation from the client that currently holds it. This reject-and-retry approach does not prevent client starvation when there is contention for the layout of a particular file. For this reason, a pNFS server SHOULD implement a mechanism to prevent starvation. One possibility is that the server can maintain a queue of rejected layout requests. Each new layout request can be checked to see if it conflicts with a previous rejected request, and if so, the newer request can be rejected. Once the original requesting client retries its request, its entry in the rejected request queue can be cleared, or the entry in the rejected request queue can be removed when it reaches a certain age.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、既存のレイアウトの代表団と競合するレイアウト要求を行った場合、要求はエラーNFS4ERR_LAYOUTTRYLATERで拒否されます。このクライアントは、その後、短い間隔の後、要求を再試行することが期待されます。この間、サーバーは現在、それを保持しているクライアントからレイアウトの代表団の相反する部分を思い出すべきです。特定のファイルのレイアウトのための競合がある場合に再試行拒否-と-アプローチは、クライアントの飢餓を防ぐことはできません。このため、pNFSのサーバは、飢餓を防ぐためのメカニズムを実装する必要があります。一つの可能​​性は、サーバーが拒否されたレイアウト要求のキューを維持することができるということです。それぞれの新しいレイアウトの要求は、それが以前の拒否要求と矛盾するかどうかを確認するためにチェックすることができ、そうであれば、新しい要求は拒否することができます。要求元のクライアントが要求を再試行すると、拒否されたリクエスト・キュー内のエントリをクリアすることができ、またはそれは一定の年齢に達したときに拒否された要求キュー内のエントリを除去することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4 supports mandatory locks and share reservations. These are mechanisms that clients can use to restrict the set of I/O operations that are permissible to other clients. Since all I/O operations ultimately arrive at the NFSv4 server for processing, the server is in a position to enforce these restrictions. However, with pNFS layouts, I/Os will be issued from the clients that hold the layouts directly to the storage devices that host the data. These devices have no knowledge of files, mandatory locks, or share reservations, and are not in a position to enforce such restrictions. For this reason the NFSv4 server MUST NOT grant layouts that conflict with mandatory locks or share reservations. Further, if a conflicting mandatory lock request or a conflicting open request arrives at the server, the server MUST recall the part of the layout in conflict with the request before granting the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4のは強制ロックと共有の予約をサポートしています。これらは、クライアントが他のクライアントに許容されるI / O操作のセットを制限するために使用できるメカニズムです。すべてのI / O操作は、最終的に処理するためのNFSv4サーバに到着するので、サーバは、これらの制限を強制する位置にあります。しかし、pNFSのレイアウトと、I / Oは、直接データをホストするストレージデバイスへのレイアウトを保持し、クライアントから発行されます。これらのデバイスは、ファイル、強制ロック、または共有の予約の知識がないと、そのような制限を適用する立場にはありません。このためNFSv4サーバは、その強制ロックまたは共有の予約との競合のレイアウトを許可してはなりません。競合必須ロック要求や矛盾オープン要求がサーバーに到着した場合はさらに、サーバは、要求を許可する前に、要求との競合でのレイアウトの一部をリコールしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.6. End-of-file Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.6。エンド・オブ・ファイル処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The end-of-file location can be changed in two ways: implicitly as the result of a WRITE or LAYOUTCOMMIT beyond the current end-of-file, or explicitly as the result of a SETATTR request. Typically, when a file is truncated by an NFSv4 client via the SETATTR call, the server frees any disk blocks belonging to the file that are beyond the new end-of-file byte, and MUST write zeros to the portion of the new end-of-file block beyond the new end-of-file byte. These actions render any pNFS layouts that refer to the blocks that are freed or written semantically invalid. Therefore, the server MUST recall from clients the portions of any pNFS layouts that refer to blocks that will be freed or written by the server before processing the truncate request. These recalls may take time to complete; as explained in [NFSv4.1], if the server cannot respond to the client SETATTR request in a reasonable amount of time, it SHOULD reply to the client with the error NFS4ERR_DELAY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR要求の結果として明示暗黙現在のファイルの終わりを越えWRITEまたはLAYOUTCOMMITの結果として、または：エンドオブファイル位置は、2つの方法で変更することができます。ファイルはSETATTR呼び出しによってNFSv4クライアントによって切断されている場合、通常、サーバーは、新しいファイルの終端バイトを超えているファイルに属するすべてのディスクブロックを解放し、新しいエンドの部分にゼロを書き込む必要があります新しいファイル終了バイトを越えるのファイルブロック。これらのアクションは、解放されたか、意味的に無効で書かれたブロックを参照するすべてのpNFSのレイアウトをレンダリングします。したがって、サーバは、クライアントからのトランケート要求を処理する前に、サーバによって解放または書き込まれるブロックを参照任意のpNFSレイアウトの部分をリコールしなければなりません。これらのリコールが完了するまでに時間がかかる場合があります。 [NFSv4.1]で説明したように、サーバーが妥当な時間内のクライアントSETATTR要求に応答できない場合、それはエラーNFS4ERR_DELAYでクライアントに返信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Blocks in the PNFS_BLOCK_INVALID_DATA state that lie beyond the new end-of-file block present a special case. The server has reserved these blocks for use by a pNFS client with a writable layout for the file, but the client has yet to commit the blocks, and they are not yet a part of the file mapping on disk. The server MAY free these blocks while processing the SETATTR request. If so, the server MUST recall any layouts from pNFS clients that refer to the blocks before processing the truncate. If the server does not free the PNFS_BLOCK_INVALID_DATA blocks while processing the SETATTR request, it need not recall layouts that refer only to the PNFS_BLOCK_INVALID DATA blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいエンド・オブ・ファイルブロックを越えた位置にあるPNFS_BLOCK_INVALID_DATA状態でのブロックは特殊なケースを提示します。サーバーは、ファイルの書き込み可能なレイアウトでのpNFSクライアントが使用するためにこれらのブロックを予約していますが、クライアントはブロックをコミットするためにまだ持っている、と彼らはまだ、ディスク上のファイル・マッピングの一部ではありません。 SETATTR要求を処理している間、サーバーは、これらのブロックを解放するかもしれません。その場合、サーバーは、TRUNCATEを処理する前にブロックを参照のpNFSクライアントから任意のレイアウトをリコールしなければなりません。 SETATTR要求を処理している間、サーバがPNFS_BLOCK_INVALID_DATAブロックを解放していない場合、それはPNFS_BLOCK_INVALIDデータブロックのみを参照レイアウトを思い出す必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file is extended implicitly by a WRITE or LAYOUTCOMMIT beyond the current end-of-file, or extended explicitly by a SETATTR request, the server need not recall any portions of any pNFS layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルは現在のファイルの終わりを超えてWRITEまたはLAYOUTCOMMITによって暗黙的に拡張し、またはSETATTR要求によって明示的に延長された場合、サーバーはpNFSのレイアウトの任意の部分を思い出す必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.7. Layout Hints
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.7。レイアウトのヒント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETATTR operation supports a layout hint attribute [NFSv4.1]. When the client sets a layout hint (data type layouthint4) with a layout type of LAYOUT4_BLOCK_VOLUME (the loh_type field), the loh_body field contains a value of data type pnfs_block_layouthint4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作は[NFSv4.1]レイアウトhint属性をサポートしています。クライアントがLAYOUT4_BLOCK_VOLUME（loh_typeフィールド）のレイアウトタイプとレイアウトヒント（データ型layouthint4）を設定した場合、loh_bodyフィールドは、データ型pnfs_block_layouthint4の値を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// /* block layout specific type for loh_body */
   /// struct pnfs_block_layouthint4 {
   ///     uint64_t blh_maximum_io_time;  /* maximum i/o time in seconds
   ///                                       */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The block layout client uses the layout hint data structure to communicate to the server the maximum time that it may take an I/O to execute on the client. Clients using block layouts MUST set the layout hint attribute before using LAYOUTGET operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックレイアウトクライアントは、サーバにはクライアント上で実行するためにI / Oを取ることができる最大時間を通信するために、レイアウトヒントデータ構造を使用します。ブロックのレイアウトを使用しているクライアントは、LAYOUTGET操作を使用する前に、レイアウトのヒント属性を設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.8. Client Fencing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.8。クライアントフェンシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pNFS block protocol must handle situations in which a system failure, typically a network connectivity issue, requires the server to unilaterally revoke extents from one client in order to transfer the extents to another client. The pNFS server implementation MUST ensure that when resources are transferred to another client, they are not used by the client originally owning them, and this must be ensured against any possible combination of partitions and delays among all of the participants to the protocol (server, storage and client). Two approaches to guaranteeing this isolation are possible and are discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSのブロックプロトコルは、システム障害、一般的にネットワーク接続の問題は、一方的に他のクライアントにエクステントを転送するために、1つのクライアントからのエクステントを取り消すために、サーバーを必要とする状況に対処しなければなりません。 、（サーバーのpNFSサーバ実装は、リソースが他のクライアントに転送されたときに、彼らが最初にそれらを所有しているクライアントによって使用されていないことを確認しなければならない、これはプロトコルへの参加者全員の中のパーティションや遅延の任意の可能な組み合わせに対して保証されなければなりませんストレージおよびクライアント）。この分離を保証するには2つのアプローチが可能であり、以下に説明されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One implementation choice for fencing the block client from the block storage is the use of LUN masking or mapping at the storage systems or storage area network to disable access by the client to be isolated. This requires server access to a management interface for the storage system and authorization to perform LUN masking and management operations. For example, the Storage Management Initiative Specification (SMI-S) [SMIS] provides a means to discover and mask LUNs, including a means of associating clients with the necessary World Wide Names or Initiator names to be masked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックストレージからブロッククライアントフェンシングのための一つの実装の選択は、孤立するクライアントからのアクセスを無効にするには、ストレージ・システムまたはストレージ・エリア・ネットワークでのLUNマスキングまたはマッピングを使用することです。これは、LUNマスキングおよび管理操作を実行するためのストレージシステムと承認の管理インタフェースへのサーバーアクセスが必要です。例えば、ストレージ管理イニシアティブ仕様（SMI-S）[SMIS]は、必要なワールドワイドネームまたはマスクするためのイニシエータ名をクライアントに関連付ける手段を含む、LUNを検出してマスクするための手段を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the absence of support for LUN masking, the server has to rely on the clients to implement a timed-lease I/O fencing mechanism. Because clients do not know if the server is using LUN masking, in all cases, the client MUST implement timed-lease fencing. In timed-lease fencing, we define two time periods, the first, &#34;lease_time&#34; is the length of a lease as defined by the server&#39;s lease_time attribute (see [NFSv4.1]), and the second, &#34;blh_maximum_io_time&#34; is the maximum time it can take for a client I/O to the storage system to either complete or fail; this value is often 30 seconds or 60 seconds, but may be longer in some environments. If the maximum client I/O time cannot be bounded, the client MUST use a value of all 1s as the blh_maximum_io_time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LUNマスキングのためのサポートがない場合には、サーバは、時限リースI / Oフェンシングのメカニズムを実装するために、クライアントに依存しなければなりません。サーバがLUNマスキングを使用している場合、クライアントが分からないので、すべてのケースでは、クライアントは時限リースフェンシングを実装しなければなりません。時限リースフェンシングでは、我々は2つの期間を定義し、第一、「lease_timeは」（[NFSv4.1]参照）サーバのlease_time属性によって定義されるように、リースの長さであり、第二、「blh_maximum_io_time」が最大でありますそれは完全または失敗のいずれかにストレージ・システムへのクライアントI / Oのために取ることができる時間。この値は、多くの場合、30秒または60秒ですが、一部の環境で長くなることがあります。最大クライアントI / O時間が制限されていない場合は、クライアントはblh_maximum_io_timeとしてすべて1の値を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a new client ID is established, the client MUST use SETATTR with a layout hint of type LAYOUT4_BLOCK_VOLUME to inform the server of its maximum I/O time prior to issuing the first LAYOUTGET operation. While the maximum I/O time hint is a per-file attribute, it is actually a per-client characteristic. Thus, the server MUST maintain the last maximum I/O time hint sent separately for each client. Each time the maximum I/O time changes, the server MUST apply it to all files for which the client has a layout. If the client does not specify this attribute on a file for which a block layout is requested, the server SHOULD use the most recent value provided by the same client for any file; if that client has not provided a value for this attribute, the server SHOULD reject the layout request with the error NFS4ERR_LAYOUTUNAVAILABLE. The client SHOULD NOT send a SETATTR of the layout hint with every LAYOUTGET. A server that implements fencing via LUN masking SHOULD accept any maximum I/O time value from a client. A server that does not implement fencing may return an error NFS4ERR_INVAL to the SETATTR operation. Such a server SHOULD return NFS4ERR_INVAL when a client sends an unbounded maximum I/O time (all 1s), or when the maximum I/O time is significantly greater than that of other clients using block layouts with pNFS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいクライアントIDが確​​立された後、クライアントは、I / O時間前に最初のLAYOUTGET操作を発行するその最大のサーバーに通知するタイプLAYOUT4_BLOCK_VOLUMEのレイアウトヒントにSETATTRを使用しなければなりません。最大I / O時間のヒントごとのファイル属性がありますが、それは実際にクライアントごとの特性です。このように、サーバは、クライアントごとに個別に送信された最後の最大I / O時間のヒントを維持しなければなりません。たびに、最大I / O時間の変更は、サーバーは、クライアントが、レイアウトを持つすべてのファイルに適用する必要があります。クライアントは、ブロックレイアウトが要求されたファイルに対してこの属性を指定しない場合、サーバーは任意のファイルのための同じクライアントが提供する最新の値を使用する必要があります。そのクライアントは、この属性の値を提供していない場合、サーバーはエラーNFS4ERR_LAYOUTUNAVAILABLEとレイアウト要求を拒否すべきです。クライアントは、すべてのLAYOUTGETでレイアウトのヒントのSETATTRを送るべきではありません。 LUNマスキングを経由してフェンシングを実装し、サーバーがクライアントから任意の最大I / O時間の値を受け入れる必要があります。フェンシングを実装していないサーバはSETATTR操作にエラーNFS4ERR_INVALを返すことがあります。クライアントは、無制限の最大I / O時間を送信するときに（すべて1）、または最大I / O時間はpNFSの持つブロックレイアウトを使用して他のクライアントよりも有意に大きい場合、このようなサーバがNFS4ERR_INVALを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives the error NFS4ERR_INVAL in response to the SETATTR operation for a layout hint, the client MUST NOT use the LAYOUTGET operation. After responding with NFS4ERR_INVAL to the SETATTR for layout hint, the server MUST return the error NFS4ERR_LAYOUTUNAVAILABLE to all subsequent LAYOUTGET operations from that client. Thus, the server, by returning either NFS4ERR_INVAL or NFS4_OK determines whether or not a client with a large, or an unbounded-maximum I/O time may use pNFS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、レイアウトのヒントのためにSETATTR操作に応答してエラーNFS4ERR_INVALを受信した場合、クライアントはLAYOUTGET操作を使用してはなりません。レイアウトヒントのSETATTRにNFS4ERR_INVALで応答した後、サーバーはそのクライアントからの後続のすべてのLAYOUTGET操作にエラーNFS4ERR_LAYOUTUNAVAILABLEを返さなければなりません。したがって、サーバは、NFS4ERR_INVAL又はNFS4_OKのいずれかを返すことによって、大きな、または無制限-最大I / O時間を有するクライアントはpNFSのを使用することができるか否かを判断します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using the lease time and the maximum I/O time values, we specify the behavior of the client and server as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにリース時間と最大I / O時間の値を使用して、我々はクライアントとサーバの動作を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives layout information via a LAYOUTGET operation, those layouts are valid for at most &#34;lease_time&#34; seconds from when the server granted them. A layout is renewed by any successful SEQUENCE operation, or whenever a new stateid is created or updated (see the section &#34;Lease Renewal&#34; of [NFSv4.1]). If the layout lease is not renewed prior to expiration, the client MUST cease to use the layout after &#34;lease_time&#34; seconds from when it either sent the original LAYOUTGET command or sent the last operation renewing the lease. In other words, the client may not issue any I/O to blocks specified by an expired layout. In the presence of large communication delays between the client and server, it is even possible for the lease to expire prior to the server response arriving at the client. In such a situation, the client MUST NOT use the expired layouts, and SHOULD revert to using standard NFSv41 READ and WRITE operations. Furthermore, the client must be configured such that I/O operations complete within the &#34;blh_maximum_io_time&#34; even in the presence of multipath drivers that will retry I/Os via multiple paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがLAYOUTGET操作によってレイアウト情報を受信すると、それらのレイアウトは、サーバーがそれらを付与されたときから、最も「lease_time」秒で有効です。レイアウトは、任意の成功シーケンス動作によって更新、または新規のstateidが作成または更新されるたびに（セクション「リース更新」の[NFSv4.1]を参照します）。レイアウトリースは有効期限前に更新されていない場合、クライアントは、それがいずれかのオリジナルLAYOUTGETコマンドを送信したり、リースを更新最後の操作を送ったときから「lease_time」秒後にレイアウトを使用することを中止しなければなりません。言い換えれば、クライアントは、期限切れのレイアウトで指定されたブロックへのI / Oを発行しないことがあります。クライアントとサーバとの間に大きな通信遅延の存在下で、リースがクライアントに到着サーバーの応答前に期限切れにすることも可能です。このような状況では、クライアントが期限切れのレイアウトを使用してはならない、と標準NFSv41 READとWRITE操作を使用してに戻すべきです。また、クライアントは、構成されなければならないことも、複数のパスを介してI / Oを再試行するマルチパスドライバの存在下でのI / O操作の「blh_maximum_io_time」以内に完了。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated in the &#34;Dealing with Lease Expiration on the Client&#34; section of [NFSv4.1], if any SEQUENCE operation is successful, but sr_status_flag has SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED, SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED, or SEQ4_STATUS_ADMIN_STATE_REVOKED is set, the client MUST immediately cease to use all layouts and device ID to device address mappings associated with the corresponding server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意のシーケンス動作が成功した場合、[NFSv4.1]の「クライアントにリースの有効期限への対処」の項で述べたが、sr_status_flagはSEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED、SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED、またはSEQ4_STATUS_ADMIN_STATE_REVOKEDが設定されており、クライアントはすぐにすべてのレイアウトを使用することをやめなければならないためと対応するサーバーに関連付けられているデバイスのアドレスマッピングへのデバイスID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the absence of known two-way communication between the client and the server on the fore channel, the server must wait for at least the time period &#34;lease_time&#34; plus &#34;blh_maximum_io_time&#34; before transferring layouts from the original client to any other client. The server, like the client, must take a conservative approach, and start the lease expiration timer from the time that it received the operation that last renewed the lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前部チャネル上のクライアントとサーバの間の既知の双方向通信がない場合には、サーバは、他のクライアントに元のクライアントからのレイアウトを転送する前に、少なくとも期間「lease_time」プラス「blh_maximum_io_time」を待つ必要があります。サーバは、クライアントのように、保守的なアプローチを取り、それが最後のリースを更新操作を受けた時点からリース満了タイマーを起動する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. Crash Recovery Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4。クラッシュリカバリの問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A critical requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts. These requirements and a full discussion of crash recovery issues are covered in the &#34;Crash Recovery&#34; section of the NFSv41 specification [NFSv4.1]. This document contains additional crash recovery material specific only to the block/volume layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラッシュリカバリの重要な要件は、他に障害が発生したときにクライアントとサーバーの両方が知っていることです。さらに、クライアントがサーバを再起動してデータの一貫性のあるビューを見ることが必要です。これらの要件とクラッシュリカバリの問題の完全な議論はNFSv41仕様[NFSv4.1]の「クラッシュリカバリ」セクションで説明されています。この文書では、唯一のブロック/ボリュームレイアウトに固有の追加クラッシュリカバリ材料が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server crashes while the client holds a writable layout, and the client has written data to blocks covered by the layout, and the blocks are still in the PNFS_BLOCK_INVALID_DATA state, the client has two options for recovery. If the data that has been written to these blocks is still cached by the client, the client can simply re-write the data via NFSv4, once the server has come back online. However, if the data is no longer in the client&#39;s cache, the client MUST NOT attempt to source the data from the data servers. Instead, it should attempt to commit the blocks in question to the server during the server&#39;s recovery grace period, by sending a LAYOUTCOMMIT with the &#34;loca_reclaim&#34; flag set to true. This process is described in detail in Section 18.42.4 of [NFSv4.1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ときに、サーバーがクラッシュしたクライアントは、書き込み可能なレイアウトを保持しており、クライアントはレイアウトによってカバーされたブロックにデータを書き込んだ、とブロックがPNFS_BLOCK_INVALID_DATA状態にある間に、クライアントは回復のための2つのオプションがあります。これらのブロックに書き込まれたデータがまだクライアントによってキャッシュされている場合、サーバーがオンラインに戻ってきた後、クライアントは単に、NFSv4のを介してデータを再作成することができます。データがクライアントのキャッシュされなくなった場合は、クライアントは、データ・サーバからのデータをソースしようとしないてはなりません。代わりに、それがtrueに設定された「loca_reclaim」フラグでLAYOUTCOMMITを送信することで、サーバーの回復の猶予期間中にサーバーに問題のブロックをコミットしようとしなければなりません。このプロセスは、[NFSv4.1]のセクション18.42.4に詳細に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. Recalling Resources: CB_RECALL_ANY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5。想起リソース：CB_RECALL_ANY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may decide that it cannot hold all of the state for layouts without running out of resources. In such a case, it is free to recall individual layouts using CB_LAYOUTRECALL to reduce the load, or it may choose to request that the client return any layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはリソースが不足することなく、レイアウトの状態のすべてを保持することはできませんことを決定することができます。このような場合には、負荷を軽減するCB_LAYOUTRECALLを使用して、個々のレイアウトをリコールして自由である、またはそれは、クライアントが任意のレイアウトを返すように要求することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4.1 spec [NFSv4.1] defines the following types:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.1仕様[NFSv4.1]は、次のタイプが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const RCA4_TYPE_MASK_BLK_LAYOUT = 4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONST RCA4_TYPE_MASK_BLK_LAYOUT = 4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL_ANY4args {
          uint32_t      craa_objects_to_keep;
          bitmap4       craa_type_mask;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server sends a CB_RECALL_ANY request to a client specifying the RCA4_TYPE_MASK_BLK_LAYOUT bit in craa_type_mask, the client should immediately respond with NFS4_OK, and then asynchronously return complete file layouts until the number of files with layouts cached on the client is less than craa_object_to_keep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバがcraa_type_maskでRCA4_TYPE_MASK_BLK_LAYOUTビットを指定してクライアントにCB_RECALL_ANY要求を送信すると、クライアントはすぐにNFS4_OKで応答して、非同期的にクライアントにキャッシュレイアウトを持つファイルの数craa_object_to_keep未満になるまで、完全なファイルのレイアウトを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6. Transient and Permanent Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6。過渡および恒久エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may respond to LAYOUTGET with a variety of error statuses. These errors can convey transient conditions or more permanent conditions that are unlikely to be resolved soon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、エラー状態の様々なLAYOUTGETに応答することができます。これらのエラーは、過渡状態またはすぐに解決されそうにない、より恒久的な条件を伝えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transient errors, NFS4ERR_RECALLCONFLICT and NFS4ERR_TRYLATER, are used to indicate that the server cannot immediately grant the layout to the client. In the former case, this is because the server has recently issued a CB_LAYOUTRECALL to the requesting client, whereas in the case of NFS4ERR_TRYLATER, the server cannot grant the request possibly due to sharing conflicts with other clients. In either case, a reasonable approach for the client is to wait several milliseconds and retry the request. The client SHOULD track the number of retries, and if forward progress is not made, the client SHOULD send the READ or WRITE operation directly to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的なエラー、NFS4ERR_RECALLCONFLICTとNFS4ERR_TRYLATERは、サーバーはすぐにクライアントにレイアウトを付与することはできませんことを示すために使用されています。 NFS4ERR_TRYLATERの場合には、サーバーが原因他のクライアントとの競合を共有する可能性の要求を付与することはできません一方、サーバは最近、要求元のクライアントにCB_LAYOUTRECALLを発行しているので、前者の場合には、これがあります。いずれの場合も、クライアントのための合理的なアプローチは、数ミリ秒待ってから、要求を再試行することです。クライアントは、再試行の回数を追跡する必要があり、前方の進歩がなされていない場合、クライアントはサーバーに直接READまたはWRITE操作を送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The error NFS4ERR_LAYOUTUNAVAILABLE may be returned by the server if layouts are not supported for the requested file or its containing file system. The server may also return this error code if the server is the progress of migrating the file from secondary storage, or for any other reason that causes the server to be unable to supply the layout. As a result of receiving NFS4ERR_LAYOUTUNAVAILABLE, the client SHOULD send future READ and WRITE requests directly to the server. It is expected that a client will not cache the file&#39;s layoutunavailable state forever, particular if the file is closed, and thus eventually, the client MAY reissue a LAYOUTGET operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトは要求されたファイルまたはそれを含むファイルシステムのためにサポートされていない場合は、エラーNFS4ERR_LAYOUTUNAVAILABLEは、サーバーによって返されることがあります。サーバは、サーバが二次記憶装置からファイルの移行の進行である場合、このエラーコードを返し、またはサーバがレイアウトを供給できないことになり、他の理由でもよいです。 NFS4ERR_LAYOUTUNAVAILABLEを受信した結果として、クライアントは、サーバに直接将来のREADとWRITE要求を送信します。ファイルが閉じている場合、クライアントは、永遠に特定のファイルのlayoutunavailable状態をキャッシュしませんので、最終的には、クライアントはLAYOUTGET操作を再発行ことが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typically, SAN disk arrays and SAN protocols provide access control mechanisms (e.g., LUN mapping and/or masking) that operate at the granularity of individual hosts. The functionality provided by such mechanisms makes it possible for the server to &#34;fence&#34; individual client machines from certain physical disks -- that is to say, to prevent individual client machines from reading or writing to certain physical disks. Finer-grained access control methods are not generally available. For this reason, certain security responsibilities are delegated to pNFS clients for block/volume layouts. Block/volume storage systems generally control access at a volume granularity, and hence pNFS clients have to be trusted to only perform accesses allowed by the layout extents they currently hold (e.g., and not access storage for files on which a layout extent is not held). In general, the server will not be able to prevent a client that holds a layout for a file from accessing parts of the physical disk not covered by the layout. Similarly, the server will not be able to prevent a client from accessing blocks covered by a layout that it has already returned. This block-based level of protection must be provided by the client software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的には、SANのディスクアレイとSANプロトコルは、個々のホストの粒度で動作するアクセス制御機構（例えば、LUNマッピングおよび/またはマスキング）を提供します。そのようなメカニズムによって提供される機能は、特定の物理ディスクから「フェンス」は、個々のクライアントマシンにサーバーのことを可能にする - それは、読んだり、特定の物理ディスクへの書き込みから、個々のクライアントマシンを防ぐために、と言うことです。きめ細かいアクセス制御方法は、一般的に利用できません。このため、特定のセキュリティの責任は、ブロック/ボリュームレイアウトのためのpNFSクライアントに委任されています。ブロック/ボリュームのストレージ・システムは、一般的に、ボリューム単位でアクセスを制御し、ひいてはクライアントが唯一の彼らは現在、例えば（ホールド、およびレイアウトエクステントが開催されていないファイルのストレージにアクセスしないレイアウトエクステントによって許可されたアクセスを実行するために信頼されている必要はありpNFSの）。一般的には、サーバは、レイアウトでカバーされていない物理ディスクの部分へのアクセスからファイルのレイアウトを保持しているクライアントを防ぐことはできません。同様に、サーバはすでに戻ってきたレイアウトでカバーブロックにアクセスするクライアントを防ぐことはできません。この保護のブロックベースのレベルは、クライアントソフトウェアによって提供されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative method of block/volume protocol use is for the storage devices to export virtualized block addresses, which do reflect the files to which blocks belong. These virtual block addresses are exported to pNFS clients via layouts. This allows the storage device to make appropriate access checks, while mapping virtual block addresses to physical block addresses. In environments where the security requirements are such that client-side protection from access to storage outside of the authorized layout extents is not sufficient, pNFS block/volume storage layouts SHOULD NOT be used unless the storage device is able to implement the appropriate access checks, via use of virtualized block addresses or other means. In contrast, an environment where client-side protection may suffice consists of co-located clients, server and storage systems in a data center with a physically isolated SAN under control of a single system administrator or small group of system administrators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスはブロックが属するファイルを反映しない仮想化ブロック・アドレスを、エクスポートするためのブロック/ボリュームプロトコルを使用する別の方法があります。これらの仮想ブロックアドレスは、レイアウトを経由してのpNFSクライアントにエクスポートされます。物理ブロックアドレスへの仮想ブロックアドレスをマッピングしながらこれは、記憶装置が適切なアクセスチェックを行うことができます。記憶装置は、適切なアクセスチェックを実施することができない限り、セキュリティ要件が許可レイアウトエクステントの外部記憶装置へのアクセスから、クライアント側の保護が十分でないようなものである環境では、pNFSのブロック/容量ストレージレイアウトが使用されるべきではなく、仮想化されたブロックアドレスまたは他の手段の使用を介しました。対照的に、クライアント側の保護が十分である環境は、単一のシステム管理者またはシステム管理者の小グループの制御下で、物理的に単離されたSANとデータセンター内の同一位置のクライアント、サーバとストレージシステムから成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This also has implications for some NFSv4 functionality outside pNFS. For instance, if a file is covered by a mandatory read-only lock, the server can ensure that only readable layouts for the file are granted to pNFS clients. However, it is up to each pNFS client to ensure that the readable layout is used only to service read requests, and not to allow writes to the existing parts of the file. Similarly, block/volume storage devices are unable to validate NFS Access Control Lists (ACLs) and file open modes, so the client must enforce the policies before sending a READ or WRITE request to the storage device. Since block/volume storage systems are generally not capable of enforcing such file-based security, in environments where pNFS clients cannot be trusted to enforce such policies, pNFS block/volume storage layouts SHOULD NOT be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはまた、pNFSの外にいくつかのNFSv4の機能に影響を与えています。ファイルは必須読み取り専用ロックでカバーされている場合たとえば、サーバーは、ファイルのための唯一の読み込み可能なレイアウトはpNFSのクライアントに付与されていることを確認することができます。しかし、それは読みやすいレイアウトはサービスが要求を読んでのみ使用され、ファイルの既存の部品への書き込みを許可しないことを確実にするために、それぞれのpNFSクライアント次第です。同様に、ブロック/容量ストレージデバイスは、NFSアクセス制御リスト（ACL）を検証し、オープンモードをファイルすることができないので、クライアントは、記憶装置への読み取りまたは書き込み要求を送信する前にポリシーを適用しなければなりません。ブロック/容量ストレージ・システムは、一般のpNFSクライアントはそのようなポリシーを適用する信頼できない環境において、そのようなファイルベースのセキュリティを強化することができないため、pNFSのブロック/ボリューム・ストレージ・レイアウトを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access to block/volume storage is logically at a lower layer of the I/O stack than NFSv4, and hence NFSv4 security is not directly applicable to protocols that access such storage directly. Depending on the protocol, some of the security mechanisms provided by NFSv4 (e.g., encryption, cryptographic integrity) may not be available or may be provided via different means. At one extreme, pNFS with block/volume storage can be used with storage access protocols (e.g., parallel SCSI) that provide essentially no security functionality. At the other extreme, pNFS may be used with storage protocols such as iSCSI that can provide significant security functionality. It is the responsibility of those administering and deploying pNFS with a block/volume storage access protocol to ensure that appropriate protection is provided to that protocol (physical security is a common means for protocols not based on IP). In environments where the security requirements for the storage protocol cannot be met, pNFS block/volume storage layouts SHOULD NOT be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック/容量記憶装置へのアクセスが可能なNFSv4よりI / Oスタックの下層に論理的であり、したがってNFSv4のセキュリティは、直接そのようなストレージアクセスプロトコルに直接適用できません。プロトコルに応じて、（例えば、暗号化、暗号完全性）のNFSv4によって提供されるセキュリティメカニズムの一部が利用できない場合があり、または異なる手段を介して提供されてもよいです。一方の極端で、ブロック/容量ストレージとのpNFSは、本質的にセキュリティ機能を提供しないストレージ・アクセス・プロトコル（例えば、パラレルSCSI）と共に使用することができます。他の極端で、pNFSのは、重要なセキュリティ機能を提供することができるようなiSCSIなどのストレージプロトコルと共に使用することができます。適切な保護が（物理的なセキュリティがIPに基づいていないプロトコルのための一般的な手段である）、そのプロトコルに提供されることを保証するために、ブロック/ボリュームのストレージアクセスプロトコルとのそれらの投与および展開のpNFSの責任です。ストレージプロトコルのためのセキュリティ要件を満たすことができない環境では、pNFSのブロック/ボリューム・ストレージ・レイアウトを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When security is available for a storage protocol, it is generally at a different granularity and with a different notion of identity than NFSv4 (e.g., NFSv4 controls user access to files, iSCSI controls initiator access to volumes). The responsibility for enforcing appropriate correspondences between these security layers is placed upon the pNFS client. As with the issues in the first paragraph of this section, in environments where the security requirements are such that client-side protection from access to storage outside of the layout is not sufficient, pNFS block/volume storage layouts SHOULD NOT be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティは、ストレージプロトコルのために利用可能である場合、それは異なる粒度でとのNFSv4よりアイデンティティの異なる概念で一般的である（例えば、NFSv4のファイルへのユーザアクセスを制御し、iSCSIは、ボリュームへのイニシエータのアクセスを制御します）。これらのセキュリティ層の間の適切な対応を実施するための責任はpNFSのクライアント上に配置されます。このセクションの最初の段落の問題と同様に、セキュリティ要件は、レイアウトの外側のストレージへのアクセスから、クライアント側の保護が十分でないようなものである環境では、pNFSのブロック/ボリューム・ストレージ・レイアウトを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Conclusions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.結論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies the block/volume layout type for pNFS and associated functionality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、pNFSのと関連した機能ブロック/ボリュームレイアウトのタイプを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are no IANA considerations in this document. All pNFS IANA Considerations are covered in [NFSv4.1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書にはIANAの考慮事項はありません。すべてのpNFS IANAの考慮事項は、[NFSv4.1]で覆われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document draws extensively on the authors&#39; familiarity with the mapping functionality and protocol in EMC&#39;s Multi-Path File System (MPFS) (previously named HighRoad) system [MPFS]. The protocol used by MPFS is called FMP (File Mapping Protocol); it is an add-on protocol that runs in parallel with file system protocols such as NFSv3 to provide pNFS-like functionality for block/volume storage. While drawing on FMP, the data structures and functional considerations in this document differ in significant ways, based on lessons learned and the opportunity to take advantage of NFSv4 features such as COMPOUND operations. The design to support pNFS client participation in copy-on-write is based on text and ideas contributed by Craig Everhart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、EMCのマルチパス・ファイル・システム（以前街道という名前）（MPFS）システム[MPFS]でマッピング機能とプロトコルとの著者の習熟に広範囲に描画します。 MPFSによって使用されるプロトコルは、FMP（ファイルマッピングプロトコル）と呼ばれます。それはアドオンプロトコルブロック/容量記憶のためのpNFSのような機能を提供するようNFSv3のようなファイル・システム・プロトコルと並行して実行されています。 FMPに描きながら、この文書のデータ構造と機能の考察は教訓を学んだとそのような化合物の操作などのNFSv4の機能を利用する機会に基づいて、重要な点で異なっています。コピー・オン・ライトでのpNFSクライアントの参加を支援するための設計は、クレイグ・エバハートによって寄与テキストやアイデアに基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andy Adamson, Ben Campbell, Richard Chandler, Benny Halevy, Fredric Isaman, and Mario Wurzl all helped to review versions of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アンディ・アダムソン、ベン・キャンベル、リチャード・チャンドラー、ベニー・アレヴィ、フレデリックIsaman、マリオWurzlすべては、この仕様のバージョンを確認するのに役立ちました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.参考
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LEGAL] IETF Trust, &#34;Legal Provisions Relating to IETF Documents&#34;, http://trustee.ietf.org/docs/IETF-Trust-License-Policy.pdf, November 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LEGAL] IETFトラスト、 &#34;IETFドキュメントに関連法規定&#34;、http://trustee.ietf.org/docs/IETF-Trust-License-Policy.pdf、2008年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NFSv4.1] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 Protocol&#34;, RFC 5661, January 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【NFSv4.1] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル&#34;、RFC 5661、2010年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XDR] Eisler, M., Ed., &#34;XDR: External Data Representation Standard&#34;, STD 67, RFC 4506, May 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XDR]アイスラー、M.、エド、 &#34;XDR：外部データ表現標準&#34;、STD 67、RFC 4506、2006年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MPFS] EMC Corporation, &#34;EMC Celerra Multi-Path File System (MPFS)&#34;, EMC Data Sheet, http://www.emc.com/collateral/software/data-sheet/ h2006-celerra-mpfs-mpfsi.pdf.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MPFS] EMCコーポレーション、 &#34;EMC Celerraのマルチパス・ファイル・システム（MPFS）&#34;、EMCデータ・シート、http://www.emc.com/collat​​eral/software/data-sheet/ h2006-Celerraの-MPFS-mpfsi.pdf 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SMIS] SNIA, &#34;Storage Management Initiative Specification (SMI-S) v1.4&#34;, http://www.snia.org/tech_activities/standards/ curr_standards/smi/SMI-S_Technical_Position_v1.4.0r4.zip.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SMIS] SNIA、 &#34;ストレージ管理イニシアティブ仕様（SMI-S）V1.4&#34;、http://www.snia.org/tech_activities/standards/ curr_standards / SMI / SMI-S_Technical_Position_v1.4.0r4.zip。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David L. Black EMC Corporation 176 South Street Hopkinton, MA 01748
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デビッドL.ブラックEMCコーポレーション176サウスストリートホプキントン、MA 01748
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 (508) 293-7953 EMail: black_david@emc.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1（508）293-7953 Eメール：black_david@emc.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stephen Fridella Nasuni Inc 313 Speen St Natick MA 01760
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スティーブンFridella Nasuni株式会社313 SpeenセントナティックMA 01760
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: stevef@nasuni.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：stevef@nasuni.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jason Glasgow Google 5 Cambridge Center Cambridge, MA 02142
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジェイソン・グラスゴーGoogleの5ケンブリッジセンター、ケンブリッジ、MA 02142
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 (617) 575 1599 EMail: jglasgow@aya.yale.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1（617）575 1599 Eメール：jglasgow@aya.yale.edu
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
