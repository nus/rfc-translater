<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2616</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc2616">
              https://tools.ietf.org/html/rfc2616
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 2616 - ハイパーテキスト転送プロトコル -  HTTP / 1.1</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                      R. Fielding
Request for Comments: 2616                                   UC Irvine
Obsoletes: 2068                                              J. Gettys
Category: Standards Track                                   Compaq/W3C
                                                              J. Mogul
                                                                Compaq
                                                            H. Frystyk
                                                               W3C/MIT
                                                           L. Masinter
                                                                 Xerox
                                                              P. Leach
                                                             Microsoft
                                                        T. Berners-Lee
                                                               W3C/MIT
                                                             June 1999
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                Hypertext Transfer Protocol -- HTTP/1.1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（1999）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name servers and distributed object management systems, through extension of its request methods, error codes and headers [47]. A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハイパーテキスト転送プロトコル（HTTP）は、分散、協調、ハイパーメディア情報システムのためのアプリケーションレベルのプロトコルです。それは、そのリクエストメソッド、エラーコードとヘッダ[47]の拡張を介して、そのようなネームサーバ及び分散オブジェクト管理システムとしてのハイパーテキストのためのその使用を超えて多くのタスクに使用することができる一般的な、ステートレスなプロトコルです。 HTTPの特徴は、システムは、独立して転送されるデータを構築することを可能にする、データの表現のタイピング及び交渉です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP has been in use by the World-Wide Web global information initiative since 1990. This specification defines the protocol referred to as &#34;HTTP/1.1&#34;, and is an update to RFC 2068 [33].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPは、この仕様は、プロトコルが「HTTP / 1.1」という定義し、RFC 2068 [33]に更新され、1990年以来、ワールドワイドウェブグローバル情報イニシアティブによって使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1   Introduction ...................................................7
   1.1    Purpose......................................................7
   1.2   Requirements .................................................8
   1.3   Terminology ..................................................8
   1.4   Overall Operation ...........................................12
   2   Notational Conventions and Generic Grammar ....................14
   2.1   Augmented BNF ...............................................14
   2.2   Basic Rules .................................................15
   3   Protocol Parameters ...........................................17
   3.1   HTTP Version ................................................17
   3.2   Uniform Resource Identifiers ................................18
   3.2.1    General Syntax ...........................................19
   3.2.2    http URL .................................................19
   3.2.3    URI Comparison ...........................................20
   3.3   Date/Time Formats ...........................................20
   3.3.1    Full Date ................................................20
   3.3.2    Delta Seconds ............................................21
   3.4   Character Sets ..............................................21
   3.4.1    Missing Charset ..........................................22
   3.5   Content Codings .............................................23
   3.6   Transfer Codings ............................................24
   3.6.1    Chunked Transfer Coding ..................................25
   3.7   Media Types .................................................26
   3.7.1    Canonicalization and Text Defaults .......................27
   3.7.2    Multipart Types ..........................................27
   3.8   Product Tokens ..............................................28
   3.9   Quality Values ..............................................29
   3.10  Language Tags ...............................................29
   3.11  Entity Tags .................................................30
   3.12  Range Units .................................................30
   4   HTTP Message ..................................................31
   4.1   Message Types ...............................................31
   4.2   Message Headers .............................................31
   4.3   Message Body ................................................32
   4.4   Message Length ..............................................33
   4.5   General Header Fields .......................................34
   5   Request .......................................................35
   5.1   Request-Line ................................................35
   5.1.1    Method ...................................................36
   5.1.2    Request-URI ..............................................36
   5.2   The Resource Identified by a Request ........................38
   5.3   Request Header Fields .......................................38
   6   Response ......................................................39
   6.1   Status-Line .................................................39
   6.1.1    Status Code and Reason Phrase ............................39
   6.2   Response Header Fields ......................................41
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   7   Entity ........................................................42
   7.1   Entity Header Fields ........................................42
   7.2   Entity Body .................................................43
   7.2.1    Type .....................................................43
   7.2.2    Entity Length ............................................43
   8   Connections ...................................................44
   8.1   Persistent Connections ......................................44
   8.1.1    Purpose ..................................................44
   8.1.2    Overall Operation ........................................45
   8.1.3    Proxy Servers ............................................46
   8.1.4    Practical Considerations .................................46
   8.2   Message Transmission Requirements ...........................47
   8.2.1    Persistent Connections and Flow Control ..................47
   8.2.2    Monitoring Connections for Error Status Messages .........48
   8.2.3    Use of the 100 (Continue) Status .........................48
   8.2.4    Client Behavior if Server Prematurely Closes Connection ..50
   9   Method Definitions ............................................51
   9.1   Safe and Idempotent Methods .................................51
   9.1.1    Safe Methods .............................................51
   9.1.2    Idempotent Methods .......................................51
   9.2   OPTIONS .....................................................52
   9.3   GET .........................................................53
   9.4   HEAD ........................................................54
   9.5   POST ........................................................54
   9.6   PUT .........................................................55
   9.7   DELETE ......................................................56
   9.8   TRACE .......................................................56
   9.9   CONNECT .....................................................57
   10   Status Code Definitions ......................................57
   10.1  Informational 1xx ...........................................57
   10.1.1   100 Continue .............................................58
   10.1.2   101 Switching Protocols ..................................58
   10.2  Successful 2xx ..............................................58
   10.2.1   200 OK ...................................................58
   10.2.2   201 Created ..............................................59
   10.2.3   202 Accepted .............................................59
   10.2.4   203 Non-Authoritative Information ........................59
   10.2.5   204 No Content ...........................................60
   10.2.6   205 Reset Content ........................................60
   10.2.7   206 Partial Content ......................................60
   10.3  Redirection 3xx .............................................61
   10.3.1   300 Multiple Choices .....................................61
   10.3.2   301 Moved Permanently ....................................62
   10.3.3   302 Found ................................................62
   10.3.4   303 See Other ............................................63
   10.3.5   304 Not Modified .........................................63
   10.3.6   305 Use Proxy ............................................64
   10.3.7   306 (Unused) .............................................64
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   10.3.8   307 Temporary Redirect ...................................65
   10.4  Client Error 4xx ............................................65
   10.4.1    400 Bad Request .........................................65
   10.4.2    401 Unauthorized ........................................66
   10.4.3    402 Payment Required ....................................66
   10.4.4    403 Forbidden ...........................................66
   10.4.5    404 Not Found ...........................................66
   10.4.6    405 Method Not Allowed ..................................66
   10.4.7    406 Not Acceptable ......................................67
   10.4.8    407 Proxy Authentication Required .......................67
   10.4.9    408 Request Timeout .....................................67
   10.4.10   409 Conflict ............................................67
   10.4.11   410 Gone ................................................68
   10.4.12   411 Length Required .....................................68
   10.4.13   412 Precondition Failed .................................68
   10.4.14   413 Request Entity Too Large ............................69
   10.4.15   414 Request-URI Too Long ................................69
   10.4.16   415 Unsupported Media Type ..............................69
   10.4.17   416 Requested Range Not Satisfiable .....................69
   10.4.18   417 Expectation Failed ..................................70
   10.5  Server Error 5xx ............................................70
   10.5.1   500 Internal Server Error ................................70
   10.5.2   501 Not Implemented ......................................70
   10.5.3   502 Bad Gateway ..........................................70
   10.5.4   503 Service Unavailable ..................................70
   10.5.5   504 Gateway Timeout ......................................71
   10.5.6   505 HTTP Version Not Supported ...........................71
   11   Access Authentication ........................................71
   12   Content Negotiation ..........................................71
   12.1  Server-driven Negotiation ...................................72
   12.2  Agent-driven Negotiation ....................................73
   12.3  Transparent Negotiation .....................................74
   13   Caching in HTTP ..............................................74
   13.1.1   Cache Correctness ........................................75
   13.1.2   Warnings .................................................76
   13.1.3   Cache-control Mechanisms .................................77
   13.1.4   Explicit User Agent Warnings .............................78
   13.1.5   Exceptions to the Rules and Warnings .....................78
   13.1.6   Client-controlled Behavior ...............................79
   13.2  Expiration Model ............................................79
   13.2.1   Server-Specified Expiration ..............................79
   13.2.2   Heuristic Expiration .....................................80
   13.2.3   Age Calculations .........................................80
   13.2.4   Expiration Calculations ..................................83
   13.2.5   Disambiguating Expiration Values .........................84
   13.2.6   Disambiguating Multiple Responses ........................84
   13.3  Validation Model ............................................85
   13.3.1   Last-Modified Dates ......................................86
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   13.3.2   Entity Tag Cache Validators ..............................86
   13.3.3   Weak and Strong Validators ...............................86
   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89
   13.3.5   Non-validating Conditionals ..............................90
   13.4  Response Cacheability .......................................91
   13.5  Constructing Responses From Caches ..........................92
   13.5.1   End-to-end and Hop-by-hop Headers ........................92
   13.5.2   Non-modifiable Headers ...................................92
   13.5.3   Combining Headers ........................................94
   13.5.4   Combining Byte Ranges ....................................95
   13.6  Caching Negotiated Responses ................................95
   13.7  Shared and Non-Shared Caches ................................96
   13.8  Errors or Incomplete Response Cache Behavior ................97
   13.9  Side Effects of GET and HEAD ................................97
   13.10   Invalidation After Updates or Deletions ...................97
   13.11   Write-Through Mandatory ...................................98
   13.12   Cache Replacement .........................................99
   13.13   History Lists .............................................99
   14   Header Field Definitions ....................................100
   14.1  Accept .....................................................100
   14.2  Accept-Charset .............................................102
   14.3  Accept-Encoding ............................................102
   14.4  Accept-Language ............................................104
   14.5  Accept-Ranges ..............................................105
   14.6  Age ........................................................106
   14.7  Allow ......................................................106
   14.8  Authorization ..............................................107
   14.9  Cache-Control ..............................................108
   14.9.1   What is Cacheable .......................................109
   14.9.2   What May be Stored by Caches ............................110
   14.9.3   Modifications of the Basic Expiration Mechanism .........111
   14.9.4   Cache Revalidation and Reload Controls ..................113
   14.9.5   No-Transform Directive ..................................115
   14.9.6   Cache Control Extensions ................................116
   14.10   Connection ...............................................117
   14.11   Content-Encoding .........................................118
   14.12   Content-Language .........................................118
   14.13   Content-Length ...........................................119
   14.14   Content-Location .........................................120
   14.15   Content-MD5 ..............................................121
   14.16   Content-Range ............................................122
   14.17   Content-Type .............................................124
   14.18   Date .....................................................124
   14.18.1   Clockless Origin Server Operation ......................125
   14.19   ETag .....................................................126
   14.20   Expect ...................................................126
   14.21   Expires ..................................................127
   14.22   From .....................................................128
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   14.23   Host .....................................................128
   14.24   If-Match .................................................129
   14.25   If-Modified-Since ........................................130
   14.26   If-None-Match ............................................132
   14.27   If-Range .................................................133
   14.28   If-Unmodified-Since ......................................134
   14.29   Last-Modified ............................................134
   14.30   Location .................................................135
   14.31   Max-Forwards .............................................136
   14.32   Pragma ...................................................136
   14.33   Proxy-Authenticate .......................................137
   14.34   Proxy-Authorization ......................................137
   14.35   Range ....................................................138
   14.35.1    Byte Ranges ...........................................138
   14.35.2    Range Retrieval Requests ..............................139
   14.36   Referer ..................................................140
   14.37   Retry-After ..............................................141
   14.38   Server ...................................................141
   14.39   TE .......................................................142
   14.40   Trailer ..................................................143
   14.41  Transfer-Encoding..........................................143
   14.42   Upgrade ..................................................144
   14.43   User-Agent ...............................................145
   14.44   Vary .....................................................145
   14.45   Via ......................................................146
   14.46   Warning ..................................................148
   14.47   WWW-Authenticate .........................................150
   15 Security Considerations .......................................150
   15.1      Personal Information....................................151
   15.1.1   Abuse of Server Log Information .........................151
   15.1.2   Transfer of Sensitive Information .......................151
   15.1.3   Encoding Sensitive Information in URI&#39;s .................152
   15.1.4   Privacy Issues Connected to Accept Headers ..............152
   15.2  Attacks Based On File and Path Names .......................153
   15.3  DNS Spoofing ...............................................154
   15.4  Location Headers and Spoofing ..............................154
   15.5  Content-Disposition Issues .................................154
   15.6  Authentication Credentials and Idle Clients ................155
   15.7  Proxies and Caching ........................................155
   15.7.1    Denial of Service Attacks on Proxies....................156
   16   Acknowledgments .............................................156
   17   References ..................................................158
   18   Authors&#39; Addresses ..........................................162
   19   Appendices ..................................................164
   19.1  Internet Media Type message/http and application/http ......164
   19.2  Internet Media Type multipart/byteranges ...................165
   19.3  Tolerant Applications ......................................166
   19.4  Differences Between HTTP Entities and RFC 2045 Entities ....167
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   19.4.1   MIME-Version ............................................167
   19.4.2   Conversion to Canonical Form ............................167
   19.4.3   Conversion of Date Formats ..............................168
   19.4.4   Introduction of Content-Encoding ........................168
   19.4.5   No Content-Transfer-Encoding ............................168
   19.4.6   Introduction of Transfer-Encoding .......................169
   19.4.7   MHTML and Line Length Limitations .......................169
   19.5  Additional Features ........................................169
   19.5.1   Content-Disposition .....................................170
   19.6  Compatibility with Previous Versions .......................170
   19.6.1   Changes from HTTP/1.0 ...................................171
   19.6.2   Compatibility with HTTP/1.0 Persistent Connections ......172
   19.6.3   Changes from RFC 2068 ...................................172
   20   Index .......................................................175
   21   Full Copyright Statement ....................................176
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1 Introduction
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1はじめに
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1 Purpose
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1目的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. HTTP has been in use by the World-Wide Web global information initiative since 1990. The first version of HTTP, referred to as HTTP/0.9, was a simple protocol for raw data transfer across the Internet. HTTP/1.0, as defined by RFC 1945 [6], improved the protocol by allowing messages to be in the format of MIME-like messages, containing metainformation about the data transferred and modifiers on the request/response semantics. However, HTTP/1.0 does not sufficiently take into consideration the effects of hierarchical proxies, caching, the need for persistent connections, or virtual hosts. In addition, the proliferation of incompletely-implemented applications calling themselves &#34;HTTP/1.0&#34; has necessitated a protocol version change in order for two communicating applications to determine each other&#39;s true capabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハイパーテキスト転送プロトコル（HTTP）は、分散、協調、ハイパーメディア情報システムのためのアプリケーションレベルのプロトコルです。 1990年HTTPの最初のバージョンは、HTTP / 0.9と呼ばれるので、HTTPは、World-Wide Webのグローバルな情報イニシアチブによって使用されている、インターネットを経由した生データ転送のための単純なプロトコルでした。 RFC 1945によって定義されるようにHTTP / 1.0は、[6]、要求/応答セマンティクスに転送されたデータと修飾に関するメタ情報を含む、メッセージがMIMEのようなメッセージの形式であるようにすることによってプロトコルを改善しました。しかし、HTTP / 1.0を十分に考慮した階層プロキシ、キャッシング、持続的な接続の必要性、または仮想ホストの効果を負いません。また、自分自身を呼び出す不完全に実装されたアプリケーションの急増は、「HTTP / 1.0は、」お互いの本当の能力を決定するために2つの通信アプリケーションのための順序でプロトコルバージョンの変更を必要としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification defines the protocol referred to as &#34;HTTP/1.1&#34;. This protocol includes more stringent requirements than HTTP/1.0 in order to ensure reliable implementation of its features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本明細書では、「HTTP / 1.1」と呼ばれるプロトコルを定義します。このプロトコルは、その機能の確実な実施を確保するために、HTTP / 1.0よりも厳しい要件が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Practical information systems require more functionality than simple retrieval, including search, front-end update, and annotation. HTTP allows an open-ended set of methods and headers that indicate the purpose of a request [47]. It builds on the discipline of reference provided by the Uniform Resource Identifier (URI) [3], as a location (URL) [4] or name (URN) [20], for indicating the resource to which a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実用的な情報システムは、検索、フロントエンドアップデート、および注釈を含め、簡易検索よりも多くの機能を必要とします。 HTTPリクエスト[47]の目的を示す方法およびヘッダのオープンエンドセットを可能にします。これは、[3]、場所（URL）[4]または名（URN）[20]のようにリソースを表示するためのURI（Uniform Resource Identifier）によって提供される基準の規律に基づいて構築します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
method is to be applied. Messages are passed in a format similar to that used by Internet mail [9] as defined by the Multipurpose Internet Mail Extensions (MIME) [7].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この方法は、適用されます。多目的インターネットメール拡張（MIME）によって定義されたメッセージは、[7] [9]インターネットメールで使用されるものと同様の形式で渡されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP is also used as a generic protocol for communication between user agents and proxies/gateways to other Internet systems, including those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2], and WAIS [10] protocols. In this way, HTTP allows basic hypermedia access to resources available from diverse applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPは、ユーザエージェントとプロキシ/ SMTP [16]、NNTP [13]、FTP [18]、ゴーファー[2]、及びWAIS [により支持されるものを含む他のインターネットシステムへのゲートウェイとの間の通信のための一般的なプロトコルとして使用されています10]のプロトコル。このように、HTTPは、多様なアプリケーションから利用可能なリソースへの基本的なハイパーメディアアクセスを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2 Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [34].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますRFC 2119 [34]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An implementation is not compliant if it fails to satisfy one or more of the MUST or REQUIRED level requirements for the protocols it implements. An implementation that satisfies all the MUST or REQUIRED level and all the SHOULD level requirements for its protocols is said to be &#34;unconditionally compliant&#34;; one that satisfies all the MUST level requirements but not all the SHOULD level requirements for its protocols is said to be &#34;conditionally compliant.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが実装されたプロトコルのためのMUSTまたはREQUIREDレベル要件の一つ以上を満たすために失敗した場合、実装は準拠していません。すべてのMUSTまたは必要なレベルとそのプロトコルのためのすべてのSHOULDレベルの要件を満たす実装は「無条件に準拠した」と言われて。すべてのMUSTレベルの要件を満たしているが、そのプロトコルのためではない、すべてのSHOULDレベルの要件があると言われて一つの「条件付きで準拠しています。」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3 Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification uses a number of terms to refer to the roles played by participants in, and objects of, the HTTP communication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様は、参加者によって果たされる役割を参照するために多くの用語を使用し、HTTP通信のオブジェクト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
connection A transport layer virtual circuit established between two programs for the purpose of communication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続通信のために二つのプログラム間に確立されたトランスポート層仮想回路。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
message The basic unit of HTTP communication, consisting of a structured sequence of octets matching the syntax defined in section 4 and transmitted via the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージセクション4で定義され、接続を介して送信されたシンタックスに一致オクテットの構造配列からなるHTTP通信の基本ユニット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
request An HTTP request message, as defined in section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション5で定義されるように、HTTPリクエストメッセージを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
response An HTTP response message, as defined in section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション6で定義されるように、HTTPレスポンスメッセージを応答。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
resource A network data object or service that can be identified by a URI, as defined in section 3.2. Resources may be available in multiple representations (e.g. multiple languages, data formats, size, and resolutions) or vary in other ways.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション3.2で定義されるように、URIによって識別することができるネットワーク・データ・オブジェクトまたはサービスリソース。リソースが複数の表現に利用可能である（例えば、複数の言語、データフォーマット、サイズ、解像度）、または他の方法で変えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
entity The information transferred as the payload of a request or response. An entity consists of metainformation in the form of entity-header fields and content in the form of an entity-body, as described in section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティ要求または応答のペイロードとして転送される情報。セクション7で説明したように、エンティティは、エンティティ - ヘッダフィールド及びエンティティ - 本体の形のコンテンツの形でメタ情報から構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
representation An entity included with a response that is subject to content negotiation, as described in section 12. There may exist multiple representations associated with a particular response status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表現エンティティは、セクション12で説明したように特定の応答ステータスに関連付けられた複数の表現が存在することができる、コンテンツネゴシエーションの対象となる応答に含ま。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
content negotiation The mechanism for selecting the appropriate representation when servicing a request, as described in section 12. The representation of entities in any response can be negotiated (including error responses).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求をサービスする際の任意の応答部12エンティティの表現で説明したように、適切な表現を選択するための機構（エラー応答を含む）コンテンツネゴシエーションをネゴシエートすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
variant A resource may have one, or more than one, representation(s) associated with it at any given instant. Each of these representations is termed a `varriant&#39;. Use of the term `variant&#39; does not necessarily imply that the resource is subject to content negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バリアントリソースは、1つ、または任意の所与の瞬間に、それに関連付けられた複数の、表現（単数または複数）を有していてもよいです。これらの表現はそれぞれ、 `varriant」と呼ばれています。用語 `バリアント」の使用は、必ずしもリソースが内容交渉の対象であることを意味するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client A program that establishes connections for the purpose of sending requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのリクエストを送信する目的のために接続を確立するプログラム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
user agent The client which initiates a request. These are often browsers, editors, spiders (web-traversing robots), or other end user tools.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザエージェント要求を開始するクライアント。これらは、しばしばブラウザ、エディタ、クモ（ウェブ横断ロボット）、または他のエンドユーザツールです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
server An application program that accepts connections in order to service requests by sending back responses. Any given program may be capable of being both a client and a server; our use of these terms refers only to the role being performed by the program for a particular connection, rather than to the program&#39;s capabilities in general. Likewise, any server may act as an origin server, proxy, gateway, or tunnel, switching behavior based on the nature of each request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーの応答を返送することにより、サービス要求に順に接続を受け入れるアプリケーションプログラム。任意のプログラムは、クライアントとサーバの両方であることの可能であってもよいです。私たちのこれらの用語の使用は、特定の接続のためのプログラムによって実行される役割にではなく、一般的には、プログラムの機能を指します。同様に、いずれかのサーバは、それぞれの要求の性質に基づいて動作を切り替える、オリジンサーバ、プロキシ、ゲートウェイ、またはトンネルとして作用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
origin server The server on which a given resource resides or is to be created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバ与えられたリソースが存在するか、作成されるサーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
proxy An intermediary program which acts as both a server and a client for the purpose of making requests on behalf of other clients. Requests are serviced internally or by passing them on, with possible translation, to other servers. A proxy MUST implement both the client and server requirements of this specification. A &#34;transparent proxy&#34; is a proxy that does not modify the request or response beyond what is required for proxy authentication and identification. A &#34;non-transparent proxy&#34; is a proxy that modifies the request or response in order to provide some added service to the user agent, such as group annotation services, media type transformation, protocol reduction, or anonymity filtering. Except where either transparent or non-transparent behavior is explicitly stated, the HTTP proxy requirements apply to both types of proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシ他のクライアントに代わってリクエストを作成する目的のために、サーバーとクライアントの両方として動作する仲介プログラム。要求は、他のサーバーに、可能な翻訳で、内部またはそれらを渡すことによってサービスされています。プロキシは、この仕様のクライアントとサーバの両方の要件を実装しなければなりません。 「透過型プロキシは」プロキシ認証と識別のために必要とされるものを超えて、要求または応答を変更しないプロキシです。 「非透過プロキシ」は、グループ注釈サービス、メディアタイプ変換、プロトコル低減、または匿名のフィルタリングなどのユーザエージェント、にいくつかの追加サービスを提供するために要求または応答を改変するプロキシです。透明または不透明な行動のいずれかを明示的に記述されている場合を除き、HTTPプロキシの要件は、プロキシの両方のタイプに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
gateway A server which acts as an intermediary for some other server. Unlike a proxy, a gateway receives requests as if it were the origin server for the requested resource; the requesting client may not be aware that it is communicating with a gateway.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの他のサーバの媒体として機能するサーバーゲートウェイ。それは要求されたリソースのためのオリジンサーバであるかのようにプロキシとは異なり、ゲートウェイは、要求を受け取り、要求しているクライアントは、それがゲートウェイと通信していることを認識していなくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
tunnel An intermediary program which is acting as a blind relay between two connections. Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel may have been initiated by an HTTP request. The tunnel ceases to exist when both ends of the relayed connections are closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トンネル2つの接続間のブラインドリレーとして動作している仲介プログラム。トンネルはHTTPリクエストによって開始されているかもしれませんが、アクティブたら、トンネルは、HTTP通信の当事者とはみなされません。トンネルは、中継接続の両端が閉じているときに存在しなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cache A program&#39;s local store of response messages and the subsystem that controls its message storage, retrieval, and deletion. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server may include a cache, though a cache cannot be used by a server that is acting as a tunnel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プログラムのローカル応答メッセージのストアとそのメッセージの保存、検索、および削除を制御するサブシステムをキャッシュします。キャッシュは、将来、同等の要求の応答時間とネットワーク帯域幅の消費量を削減するために、キャッシュ可能な応答を格納します。キャッシュはトンネルとして動作しているサーバーで使用することはできないものの、任意のクライアントまたはサーバは、キャッシュを備えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cacheable A response is cacheable if a cache is allowed to store a copy of the response message for use in answering subsequent requests. The rules for determining the cacheability of HTTP responses are defined in section 13. Even if a resource is cacheable, there may be additional constraints on whether a cache can use the cached copy for a particular request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュが後続の要求に答える中で使用するための応答メッセージのコピーを保存することが許可されている場合、レスポンスはキャッシュ可能であるキャッシュ可能。 HTTPレスポンスのキャッシュ可能性を決定するためのルールは、リソースがキャッシュ可能である場合でも、セクション13で定義され、キャッシュが特定の要求のためにキャッシュされたコピーを使用できるかどうかに追加の制約があってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
first-hand A response is first-hand if it comes directly and without unnecessary delay from the origin server, perhaps via one or more proxies. A response is also first-hand if its validity has just been checked directly with the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはおそらく、一の以上のプロキシを経由して、直接オリジンサーバから不要な遅延なしに来れば最初の手応答は、最初の手です。その有効性は、単にオリジンサーバと直接チェックされた場合、応答はまた、最初の手です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
explicit expiration time The time at which the origin server intends that an entity should no longer be returned by a cache without further validation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
明示的な有効期限オリジンサーバが実体は、もはやさらなる検証せずに、キャッシュによって返されるべきであることを意図していない時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
heuristic expiration time An expiration time assigned by a cache when no explicit expiration time is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヒューリスティックの有効期限明示的な有効期限が利用できないキャッシュによって割り当てられた有効期限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
age The age of a response is the time since it was sent by, or successfully validated with, the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
年齢はレスポンスの年齢はそれがによって送信され、または成功したオリジンサーバ、で検証されてからの時間です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
freshness lifetime The length of time between the generation of a response and its expiration time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鮮度寿命応答の生成とその有効期限の間の時間の長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fresh A response is fresh if its age has not yet exceeded its freshness lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その年齢がまだその新鮮寿命を超えていない場合は、新鮮なレスポンスが新鮮です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
stale A response is stale if its age has passed its freshness lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その年齢がその新鮮寿命を経過している場合、古いレスポンスが古くなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
semantically transparent A cache behaves in a &#34;semantically transparent&#34; manner, with respect to a particular response, when its use affects neither the requesting client nor the origin server, except to improve performance. When a cache is semantically transparent, the client receives exactly the same response (except for hop-by-hop headers) that it would have received had its request been handled directly by the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
意味的に透過キャッシュは、パフォーマンスを向上させるために除いて、その使用は、要求元のクライアントにもオリジンサーバのいずれも影響を与え、特定の応答を基準にして、「意味的に透明」ように動作します。キャッシュが意味的に透明である場合、クライアントは、その要求がオリジンサーバによって直接処理されていた、それが受け取ったであろう（ホップバイホップヘッダを除く）と全く同じ応答を受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
validator A protocol element (e.g., an entity tag or a Last-Modified time) that is used to find out whether a cache entry is an equivalent copy of an entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バリデータキャッシュのエントリは、エンティティの等価なコピーであるかどうかを調べるために使用されるプロトコル要素（例えば、エンティティタグや最終更新時刻）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
upstream/downstream Upstream and downstream describe the flow of a message: all messages flow from upstream to downstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上流/下流の上流及び下流には、メッセージの流れを説明：すべてのメッセージは、上流側から下流側に流れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
inbound/outbound Inbound and outbound refer to the request and response paths for messages: &#34;inbound&#34; means &#34;traveling toward the origin server&#34;, and &#34;outbound&#34; means &#34;traveling toward the user agent&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージの要求と応答のパスを参照し、インバウンド/アウトバウンドインバウンドとアウトバウンド：「インバウンド」とは、「オリジンサーバに向かう」を意味し、「アウトバウンド」「ユーザーエージェントへ向かう」という意味します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4 Overall Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4全体動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HTTP protocol is a request/response protocol. A client sends a request to the server in the form of a request method, URI, and protocol version, followed by a MIME-like message containing request modifiers, client information, and possible body content over a connection with a server. The server responds with a status line, including the message&#39;s protocol version and a success or error code, followed by a MIME-like message containing server information, entity metainformation, and possible entity-body content. The relationship between HTTP and MIME is described in appendix 19.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPプロトコルは、要求/応答プロトコルです。クライアントがサーバとの接続を介してMIME状要求修飾子を含むメッセージは、クライアント情報、および可能なボディ・コンテンツに続くリクエストメソッド、URI、プロトコルバージョンの形式でサーバに要求を送信します。サーバは、サーバ情報、エンティティメタ情報、および可能なエンティティボディコンテンツを含むMIMEのようなメッセージが続くメッセージのプロトコルバージョンと成功またはエラーコード、を含む、ステータス行で応答します。 HTTPとMIMEの関係は付録19.4に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Most HTTP communication is initiated by a user agent and consists of a request to be applied to a resource on some origin server. In the simplest case, this may be accomplished via a single connection (v) between the user agent (UA) and the origin server (O).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ほとんどのHTTP通信は、ユーザエージェントによって開始され、いくつかのオリジンサーバ上のリソースに適用するリクエストで構成されています。最も単純な場合、これはユーザエージェント（UA）とオリジンサーバ（O）との間の単一の接続（V）を介して達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          request chain ------------------------&gt;
       UA -------------------v------------------- O
          &lt;----------------------- response chain
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A more complicated situation occurs when one or more intermediaries are present in the request/response chain. There are three common forms of intermediary: proxy, gateway, and tunnel. A proxy is a forwarding agent, receiving requests for a URI in its absolute form, rewriting all or part of the message, and forwarding the reformatted request toward the server identified by the URI. A gateway is a receiving agent, acting as a layer above some other server(s) and, if necessary, translating the requests to the underlying server&#39;s protocol. A tunnel acts as a relay point between two connections without changing the messages; tunnels are used when the communication needs to pass through an intermediary (such as a firewall) even when the intermediary cannot understand the contents of the messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一つ以上の仲介者は、要求/応答鎖中に存在する場合、より複雑な状況が生じます。プロキシ、ゲートウェイ、およびトンネル：3つの一般的な中間の形態があります。プロキシは、その絶対的な形でURIに対する要求を受信し、メッセージの全部または一部を書き換え、およびURIによって識別されるサーバに向かって再フォーマットされた要求を転送する、転送エージェントです。ゲートウェイは、基礎となるサーバのプロトコルに要求を変換する、いくつかの他のサーバ（複数可）と、必要に応じて上記層として作用する、受信エージェントです。トンネルは、メッセージを変更せずに2つの接続間の中継点として機能します。トンネルは、通信仲介メッセージの内容を理解できない場合でも（ファイアウォールなど）の中間を通過する必要があるときに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          request chain --------------------------------------&gt;
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          &lt;------------------------------------- response chain
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The figure above shows three intermediaries (A, B, and C) between the user agent and origin server. A request or response message that travels the whole chain will pass through four separate connections. This distinction is important because some HTTP communication options may apply only to the connection with the nearest, non-tunnel neighbor, only to the end-points of the chain, or to all connections along the chain. Although the diagram is linear, each participant may be engaged in multiple, simultaneous communications. For example, B may be receiving requests from many clients other than A, and/or forwarding requests to servers other than C, at the same time that it is handling A&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上図は、ユーザエージェントとオリジンサーバ間の3人の仲介者（A、B、及びC）を示します。チェーン全体を移動要求または応答メッセージは、4つの別々の接続を通過することになります。いくつかのHTTP通信オプションは、又は鎖に沿ってすべての接続にのみチェーンのエンドポイントに最も近い、非トンネルネイバーとの接続にのみ適用することができるので、この区別は重要です。図は線形であるが、各参加者は、複数の同時通信に従事することができます。例えば、Bは、Aの要求を処理すると同時に、A以外の多くのクライアントからの要求を受信し、および/またはC以外のサーバに要求を転送することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any party to the communication which is not acting as a tunnel may employ an internal cache for handling requests. The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request. The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request which has not been cached by UA or A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トンネルとして動作していない通信の当事者は、要求を処理するための内部キャッシュを使用することができます。キャッシュの効果がチェーンに沿って参加者の1人がその要求に適用可能なキャッシュされた応答を持っている場合は、要求/応答チェーンが短縮されるということです。 Bは、UAまたはAによってキャッシュされていない要求の（Cを介して）Oからの以前の応答のキャッシュされたコピーを有する場合、以下が得られるチェーンを示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          request chain ----------&gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &lt;--------- response chain
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Not all responses are usefully cacheable, and some requests may contain modifiers which place special requirements on cache behavior. HTTP requirements for cache behavior and cacheable responses are defined in section 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いないすべての応答が有効にキャッシュ可能であり、いくつかの要求はキャッシュの動作に特別な要件を置く修飾を含むこともできます。キャッシュの動作やキャッシュ可能なレスポンスのHTTP要求は、セクション13で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In fact, there are a wide variety of architectures and configurations of caches and proxies currently being experimented with or deployed across the World Wide Web. These systems include national hierarchies of proxy caches to save transoceanic bandwidth, systems that broadcast or multicast cache entries, organizations that distribute subsets of cached data via CD-ROM, and so on. HTTP systems are used in corporate intranets over high-bandwidth links, and for access via PDAs with low-power radio links and intermittent connectivity. The goal of HTTP/1.1 is to support the wide diversity of configurations already deployed while introducing protocol constructs that meet the needs of those who build web applications that require high reliability and, failing that, at least reliable indications of failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実際には、アーキテクチャやキャッシュやプロキシの設定現在で実験やワールド・ワイド・ウェブ（WWW）に配備されているさまざまながあります。これらのシステムはように国家の大洋横断の帯域幅を節約するために、プロキシキャッシュの階層、ブロードキャストやマルチキャストのキャッシュエントリシステム、CD-ROMを経由して、キャッシュされたデータのサブセットを配布する組織などが含まれます。 HTTPシステムは高帯域幅のリンクを介して企業のイントラネットで使用され、低消費電力の無線リンクと断続的な接続とPDAなどを経由してアクセスするためにされています。 HTTP / 1.1の目標は、高い信頼性と、それを失敗し、失敗の少なくとも信頼性の高い表示を必要とするWebアプリケーションを構築する人々のニーズを満たすプロトコル構造を導入しながら、既に展開された構成の広い多様性をサポートすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP communication usually takes place over TCP/IP connections. The default port is TCP 80 [19], but other ports can be used. This does not preclude HTTP from being implemented on top of any other protocol on the Internet, or on other networks. HTTP only presumes a reliable transport; any protocol that provides such guarantees can be used; the mapping of the HTTP/1.1 request and response structures onto the transport data units of the protocol in question is outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP通信は、通常、TCP / IP接続を介して行われます。デフォルトポートはTCP 80 [19]であるが、他のポートを使用することができます。これは、インターネット上の、または他のネットワーク上の他のプロトコルの上に実装されてからHTTPを排除するものではありません。 HTTPは、唯一の信頼できる輸送を想定しています。そのような保証を提供する任意のプロトコルを使用することができます。当該プロトコルのトランスポート・データ・ユニットへのHTTP / 1.1リクエストとレスポンス構造のマッピングは、本明細書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In HTTP/1.0, most implementations used a new connection for each request/response exchange. In HTTP/1.1, a connection may be used for one or more request/response exchanges, although connections may be closed for a variety of reasons (see section 8.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.0では、ほとんどの実装では、各要求/応答交換のため新しい接続を使用します。接続は、様々な理由のため閉鎖されてもよいがHTTP / 1.1では、接続は（セクション8.1を参照）、1つまたは複数の要求/応答の交換のために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2 Notational Conventions and Generic Grammar
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2つの表記規則と一般的な文法
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1 Augmented BNF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1増補BNF
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All of the mechanisms specified in this document are described in both prose and an augmented Backus-Naur Form (BNF) similar to that used by RFC 822 [9]. Implementors will need to be familiar with the notation in order to understand this specification. The augmented BNF includes the following constructs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書で指定された機構の全ては、RFC 822によって使用されるものと同様の散文と拡張バッカスナウア記法（BNF）[9]の両方に記載されています。実装者はこの仕様を理解するために、表記法に精通している必要があります。増補BNFは、以下の構造が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
name = definition The name of a rule is simply the name itself (without any enclosing &#34;&lt;&#34; and &#34;&gt;&#34;) and is separated from its definition by the equal &#34;=&#34; character. White space is only significant in that indentation of continuation lines is used to indicate a rule definition that spans more than one line. Certain basic rules are in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle brackets are used within definitions whenever their presence will facilitate discerning the use of rule names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前ルールの名前は、単に名前自体である=定義（任意封入せずに「&lt;」と「&gt;」）と等しい「=」キャラクタによってその定義から分離されます。ホワイトスペースは、継続行のインデントが複数行にわたるルールの定義を示すために使用されている中で唯一重要です。特定の基本的なルールは、アングルブラケットは、その存在がルール名の使用を見分ける容易にするたびに定義内で使用される等SP、LWS、HT、CRLF、DIGIT、ALPHA、として、大文字です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;literal&#34; Quotation marks surround literal text. Unless stated otherwise, the text is case-insensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「リテラル」引用符はリテラルテキストを囲みます。特に明記しない限り、テキストは大文字と小文字を区別しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
rule1 | rule2 Elements separated by a bar (&#34;|&#34;) are alternatives, e.g., &#34;yes | no&#34; will accept yes or no.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルール1 |バーで区切らRULE2 Elementsは（「|」）の選択肢は、例えば、「はい|いいえ」はい受け入れる、あるいは全くます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(rule1 rule2) Elements enclosed in parentheses are treated as a single element. Thus, &#34;(elem (foo | bar) elem)&#34; allows the token sequences &#34;elem foo elem&#34; and &#34;elem bar elem&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（rule1 rule2）括弧で囲まれた要素は単一の要素として扱われます。したがって、 &#34;（elemは（FOO |バー）のelem）は、&#34; 可能にトークンシーケンス &#34;elemはfooというのelem&#34; と &#34;elem bar elem&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
*rule The character &#34;*&#34; preceding an element indicates repetition. The full form is &#34;&lt;n&gt;*&lt;m&gt;element&#34; indicating at least &lt;n&gt; and at most &lt;m&gt; occurrences of element. Default values are 0 and infinity so that &#34;*(element)&#34; allows any number, including zero; &#34;1*element&#34; requires at least one; and &#34;1*2element&#34; allows one or two.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*「*」要素に先行する繰り返しを示す文字を支配。完全形は素子の少なくとも&lt;N&gt;と高々&lt;M&gt;の発生を示す「&lt;N&gt; * &lt;M&gt;要素」です。 「*（要素）」はゼロを含む任意の数を、可能にするようにデフォルト値は0と無限大です。 「1 *要素」とは、少なくとも1つが必要です。そして「1 *の2element」は1か2を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[rule] Square brackets enclose optional elements; &#34;[foo bar]&#34; is equivalent to &#34;*1(foo bar)&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ルール]角括弧は、オプションの要素を囲みます。 &#34;[FOOバー]は&#34; &#34;* 1（FOOバー）&#34; に相当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
N rule Specific repetition: &#34;&lt;n&gt;(element)&#34; is equivalent to &#34;&lt;n&gt;*&lt;n&gt;(element)&#34;; that is, exactly &lt;n&gt; occurrences of (element). Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three alphabetic characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
N特定の繰り返しルール： &#34;&lt;N&gt;（要素）は&#34; &#34;&lt;N&gt; * &lt;N&gt;（要素）&#34; に相当します。つまり、正確に&lt;N&gt;（要素）の発生。したがって2DIGITは、2桁の数字であり、そして3ALPHAはアルファベット3文字の文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#rule A construct &#34;#&#34; is defined, similar to &#34;*&#34;, for defining lists of elements. The full form is &#34;&lt;n&gt;#&lt;m&gt;element&#34; indicating at least &lt;n&gt; and at most &lt;m&gt; elements, each separated by one or more commas (&#34;,&#34;) and OPTIONAL linear white space (LWS). This makes the usual form of lists very easy; a rule such as ( *LWS element *( *LWS &#34;,&#34; *LWS element )) can be shown as 1#element Wherever this construct is used, null elements are allowed, but do not contribute to the count of elements present. That is, &#34;(element), , (element) &#34; is permitted, but counts as only two elements. Therefore, where at least one element is required, at least one non-null element MUST be present. Default values are 0 and infinity so that &#34;#element&#34; allows any number, including zero; &#34;1#element&#34; requires at least one; and &#34;1#2element&#34; allows one or two.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#rule構築物「＃」の要素のリストを定義するために、「*」に似た、定義されます。完全形は（「」）それぞれが1つ以上のカンマで区切られた、少なくとも&lt;n&gt;は、ほとんど&lt;M&gt;要素に示す「&lt;N&gt;＃&lt;M&gt;要素」であり、任意の線形空白（LWS）。これは、リストの通常の形は非常に簡単になります。このような（* LWS要素*（* LWS「」* LWS要素））のようなルールは、この構築物が使用される場合はいつでも、null要素が許可されている1つの＃要素として示すことができるが、本要素の数に寄与しません。すなわち、「（要素）、（要素）」許可、2つだけの要素としてカウントされます。少なくとも一つの要素が必要とされるため、少なくとも一つの非ヌル要素が存在しなければなりません。 「#element」はゼロを含む、任意の数のを可能にするようにデフォルト値は0と無限大です。 「1＃要素」とは、少なくとも1つが必要です。そして「1つの＃の2element」は1か2を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
; comment A semi-colon, set off some distance to the right of rule text, starts a comment that continues to the end of line. This is a simple way of including useful notes in parallel with the specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
;セミコロンコメント、ルールテキストの右にある距離をオフに設定し、行の終わりまで続くコメントを開始します。これは仕様に対して有用な注釈をつけるための簡単な方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
implied *LWS The grammar described by this specification is word-based. Except where noted otherwise, linear white space (LWS) can be included between any two adjacent words (token or quoted-string), and between adjacent words and separators, without changing the interpretation of a field. At least one delimiter (LWS and/or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗示*この仕様で記述文法は単語ベースでLWS。特記する場合を除いて、線形空白（LWS）は、フィールドの解釈を変えることなく、任意の2つの隣接する単語（トークンまたは引用文字列）の間に、隣接する単語とセパレータとの間に含めることができます。少なくとも一つのデリミタ（LWS及び/又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
separators) MUST exist between any two tokens (for the definition of &#34;token&#34; below), since they would otherwise be interpreted as a single token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それらがそうでなければ、単一のトークンとして解釈されるので、セパレータ）は、以下の「トークン」の定義のための任意の2つのトークン（）間に存在しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2 Basic Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2基本ルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following rules are used throughout this specification to describe basic parsing constructs. The US-ASCII coded character set is defined by ANSI X3.4-1986 [21].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のルールは、基本的な構文解析構造を記述するために本明細書を通して使用されています。 US-ASCIIコード化文字セットはANSI X3.4-1986 [21]によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       OCTET          = &lt;any 8-bit sequence of data&gt;
       CHAR           = &lt;any US-ASCII character (octets 0 - 127)&gt;
       UPALPHA        = &lt;any US-ASCII uppercase letter &#34;A&#34;..&#34;Z&#34;&gt;
       LOALPHA        = &lt;any US-ASCII lowercase letter &#34;a&#34;..&#34;z&#34;&gt;
       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = &lt;any US-ASCII digit &#34;0&#34;..&#34;9&#34;&gt;
       CTL            = &lt;any US-ASCII control character
                        (octets 0 - 31) and DEL (127)&gt;
       CR             = &lt;US-ASCII CR, carriage return (13)&gt;
       LF             = &lt;US-ASCII LF, linefeed (10)&gt;
       SP             = &lt;US-ASCII SP, space (32)&gt;
       HT             = &lt;US-ASCII HT, horizontal-tab (9)&gt;
       &lt;&#34;&gt;            = &lt;US-ASCII double-quote mark (34)&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all protocol elements except the entity-body (see appendix 19.3 for tolerant applications). The end-of-line marker within an entity-body is defined by its associated media type, as described in section 3.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1（耐性用途のための付録19.3を参照）エンティティボディ以外のすべてのプロトコル要素のための行末マーカーとしてシーケンスCR LFを定義します。セクション3.7で説明したようにエンティティボディ内の行末マーカーは、その関連するメディアタイプによって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CRLF = CR LF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CRLF = CR LF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 header field values can be folded onto multiple lines if the continuation line begins with a space or horizontal tab. All linear white space, including folding, has the same semantics as SP. A recipient MAY replace any linear white space with a single SP before interpreting the field value or forwarding the message downstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
継続行はスペースまたは水平タブで始まる場合HTTP / 1.1ヘッダフィールドの値が複数行に折り畳むことができます。折りたたみを含むすべてのリニアホワイトスペースは、SPと同じ意味を持っています。受信者は、フィールドの値を解釈するか、下流のメッセージを転送する前に、単一のSPを持つ任意の線形空白を置き換えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LWS = [CRLF] 1*( SP | HT )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LWS = [CRLF] 1 *（SP | HT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TEXT rule is only used for descriptive field contents and values that are not intended to be interpreted by the message parser. Words of *TEXT MAY contain characters from character sets other than ISO-8859-1 [22] only when encoded according to the rules of RFC 2047 [14].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TEXTルールは、メッセージパーサによって解釈されることを意図するものではない記述フィールドの内容と値のために使用されます。 TEXT *の言葉は、文字から文字を含めることができ[14] RFC 2047の規則に従ってエンコードされた場合にのみ、[22] ISO-8859-1以外の設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       TEXT           = &lt;any OCTET except CTLs,
                        but including LWS&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A CRLF is allowed in the definition of TEXT only as part of a header field continuation. It is expected that the folding LWS will be replaced with a single SP before interpretation of the TEXT value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CRLFだけヘッダーフィールド継続の一部としてテキストの定義で許可されています。折りたたみLWSはTEXT値の解釈前に、単一のSPに置き換えされることが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hexadecimal numeric characters are used in several protocol elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
進数字は、いくつかのプロトコル要素で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HEX            = &#34;A&#34; | &#34;B&#34; | &#34;C&#34; | &#34;D&#34; | &#34;E&#34; | &#34;F&#34;
                      | &#34;a&#34; | &#34;b&#34; | &#34;c&#34; | &#34;d&#34; | &#34;e&#34; | &#34;f&#34; | DIGIT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many HTTP/1.1 header field values consist of words separated by LWS or special characters. These special characters MUST be in a quoted string to be used within a parameter value (as defined in section 3.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くのHTTP / 1.1ヘッダフィールドの値は、LWSまたは特殊文字で区切られた単語から成ります。これらの特殊文字は（セクション3.6で定義されるように）パラメータ値内で使用される引用符で囲まれた文字列でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       token          = 1*&lt;any CHAR except CTLs or separators&gt;
       separators     = &#34;(&#34; | &#34;)&#34; | &#34;&lt;&#34; | &#34;&gt;&#34; | &#34;@&#34;
                      | &#34;,&#34; | &#34;;&#34; | &#34;:&#34; | &#34;\&#34; | &lt;&#34;&gt;
                      | &#34;/&#34; | &#34;[&#34; | &#34;]&#34; | &#34;?&#34; | &#34;=&#34;
                      | &#34;{&#34; | &#34;}&#34; | SP | HT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Comments can be included in some HTTP header fields by surrounding the comment text with parentheses. Comments are only allowed in fields containing &#34;comment&#34; as part of their field value definition. In all other fields, parentheses are considered part of the field value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コメントは括弧とコメントテキストを囲むことにより、いくつかのHTTPヘッダフィールドに含めることができます。コメントは自分のフィールド値定義の一部として「コメント」を含むフィールドで許可されています。他のすべてのフィールドでは、括弧はフィールド値の一部とみなされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       comment        = &#34;(&#34; *( ctext | quoted-pair | comment ) &#34;)&#34;
       ctext          = &lt;any TEXT excluding &#34;(&#34; and &#34;)&#34;&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A string of text is parsed as a single word if it is quoted using double-quote marks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、二重引用符を使用して引用されている場合は、テキストの文字列は、単一の単語として解析されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       quoted-string  = ( &lt;&#34;&gt; *(qdtext | quoted-pair ) &lt;&#34;&gt; )
       qdtext         = &lt;any TEXT except &lt;&#34;&gt;&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The backslash character (&#34;\&#34;) MAY be used as a single-character quoting mechanism only within quoted-string and comment constructs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バックスラッシュ文字（「\」）は唯一の引用された文字列とコメント構文内の単一文字引用メカニズムとして使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
quoted-pair = &#34;\&#34; CHAR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引用されたペア=「\」CHAR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3 Protocol Parameters
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3つのプロトコルパラメータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 HTTP Version
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 HTTPバージョン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP uses a &#34;&lt;major&gt;.&lt;minor&gt;&#34; numbering scheme to indicate versions of the protocol. The protocol versioning policy is intended to allow the sender to indicate the format of a message and its capacity for understanding further HTTP communication, rather than the features obtained via that communication. No change is made to the version number for the addition of message components which do not affect communication behavior or which only add to extensible field values. The &lt;minor&gt; number is incremented when the changes made to the protocol add features which do not change the general message parsing algorithm, but which may add to the message semantics and imply additional capabilities of the sender. The &lt;major&gt; number is incremented when the format of a message within the protocol is changed. See RFC 2145 [36] for a fuller explanation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPプロトコルのバージョンを示すために、「&lt;主要な&gt;。&lt;マイナー&gt;」番号方式を使用しています。プロトコルのバージョン管理ポリシーは、メッセージのフォーマットおよび機能は、通信を介して取得するのではなく、さらにHTTP通信を理解するための能力を示すために、送信者を許可することを意図しています。変更なしは、通信動作に影響を与えるか、のみ拡張可能なフィールド値に追加されていないメッセージ成分の添加のためのバージョン番号に行われません。プロトコルに加えられた変更は、アルゴリズムを解析し、一般的なメッセージを変更しませんが、メッセージのセマンティクスに追加して、送信者の追加機能を暗示している機能を追加するとき、&lt;マイナー&gt;番号がインクリメントされます。プロトコル内のメッセージのフォーマットが変更された場合、&lt;メジャー&gt;数をインクリメントします。充実の説明については、RFC 2145 [36]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The version of an HTTP message is indicated by an HTTP-Version field in the first line of the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPメッセージのバージョンはメッセージの最初の行にHTTP-Versionフィールドで示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP-Version = &#34;HTTP&#34; &#34;/&#34; 1*DIGIT &#34;.&#34; 1*DIGIT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP-バージョン= &#34;HTTP&#34; &#34;/&#34; 1 * DIGIT &#34;&#34; 1 * DIGIT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the major and minor numbers MUST be treated as separate integers and that each MAY be incremented higher than a single digit. Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and MUST NOT be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メジャー番号とマイナー番号が別々の整数として扱われ、それぞれが一桁以上高い増分することができることをしなければならないことに注意してください。従って、HTTP / 2.4はHTTP / 2.13、今度はHTTP / 12.3未満であるよりも低いバージョンです。先頭のゼロは、受信者によって無視されなければならないと送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An application that sends a request or response message that includes HTTP-Version of &#34;HTTP/1.1&#34; MUST be at least conditionally compliant with this specification. Applications that are at least conditionally compliant with this specification SHOULD use an HTTP-Version of &#34;HTTP/1.1&#34; in their messages, and MUST do so for any message that is not compatible with HTTP/1.0. For more details on when to send specific HTTP-Version values, see RFC 2145 [36].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「HTTP / 1.1」のHTTP-バージョンを含む要求または応答メッセージを送信するアプリケーションは、本明細書と少なくとも条件に準拠しなければなりません。この仕様で少なくとも条件に準拠しているアプリケーションは、そのメッセージにHTTP-バージョン「HTTP / 1.1」のを使用すべきである、とHTTP / 1.0との互換性はありません任意のメッセージのためにそうしなければなりません。特定のHTTP-バージョン値を送信する際の詳細については、RFC 2145 [36]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HTTP version of an application is the highest HTTP version for which the application is at least conditionally compliant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションのHTTPバージョンはアプリケーションが少なくとも条件に準拠しているため、最も高いHTTPバージョンです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxy and gateway applications need to be careful when forwarding messages in protocol versions different from that of the application. Since the protocol version indicates the protocol capability of the sender, a proxy/gateway MUST NOT send a message with a version indicator which is greater than its actual version. If a higher version request is received, the proxy/gateway MUST either downgrade the request version, or respond with an error, or switch to tunnel behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシとゲートウェイアプリケーションは、アプリケーションとは異なるプロトコル・バージョンでメッセージを転送するときに注意する必要があります。プロトコルバージョンは、送信者のプロトコル能力を示すので、プロキシ/ゲートウェイは、実際のバージョンよりも大きいバージョンインジケータとメッセージを送ってはいけません。より高いバージョン要求が受信された場合、プロキシ/ゲートウェイは、リクエストのバージョンをダウングレード、あるいはエラーで応答、またはトンネル動作に切り替える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Due to interoperability problems with HTTP/1.0 proxies discovered since the publication of RFC 2068[33], caching proxies MUST, gateways MAY, and tunnels MUST NOT upgrade the request to the highest version they support. The proxy/gateway&#39;s response to that request MUST be in the same major version as the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPとの相互運用性の問題に/ 1.0プロキシがRFC 2068の出版以来、発見された[33]は、キャッシングプロキシは、ゲートウェイは、トンネルとは、サポートする最新のバージョンに要求をアップグレードしてはならないかもしれないしなければなりません。その要求へのプロキシ/ゲートウェイのレスポンスはリクエストと同じメジャーバージョンでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Converting between versions of HTTP may involve modification of header fields required or forbidden by the versions involved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：HTTPのバージョン間の変換は関与バージョンによって必要とされる又は禁止ヘッダフィールドの変更を伴ってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Uniform Resource Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2統一資源識別子
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIs have been known by many names: WWW addresses, Universal Document Identifiers, Universal Resource Identifiers [3], and finally the combination of Uniform Resource Locators (URL) [4] and Names (URN) [20]. As far as HTTP is concerned, Uniform Resource Identifiers are simply formatted strings which identify--via name, location, or any other characteristic--a resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[20] WWWアドレス、ユニバーサルドキュメント識別子、ユニバーサルリソース識別子[3]、及びユニフォームリソースロケータ（URL）の最後に組み合わせ[4]と名前（URN）：URIは多くの名前で知られています。リソース - 名前、場所、または他の任意の特徴を介して - 限りHTTPに関しては、ユニフォームリソース識別子は、単純に特定の文字列を書式設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1 General Syntax
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1一般的な構文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIs in HTTP can be represented in absolute form or relative to some known base URI [11], depending upon the context of their use. The two forms are differentiated by the fact that absolute URIs always begin with a scheme name followed by a colon. For definitive information on URL syntax and semantics, see &#34;Uniform Resource Identifiers (URI): Generic Syntax and Semantics,&#34; RFC 2396 [42] (which replaces RFCs 1738 [4] and RFC 1808 [11]). This specification adopts the definitions of &#34;URI-reference&#34;, &#34;absoluteURI&#34;, &#34;relativeURI&#34;, &#34;port&#34;, &#34;host&#34;,&#34;abs_path&#34;, &#34;rel_path&#34;, and &#34;authority&#34; from that specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPにおけるURIは、それらの使用状況に応じて、絶対的な形態またはいくつかの既知のベースURI [11]に対してで表すことができます。二つの形式は絶対URIが常にコロンスキーム名で開始しているという事実によって区別されます。 URLの構文およびセマンティクスに関する明確な情報については、 &#34;統一資源識別子（URI）：一般的な構文とセマンティクス、&#34; RFC 2396 [42]（RFCを置き換える1738 [4]およびRFC 1808 [11]）。この仕様はその仕様から「URI参照」、「absoluteURIで」、「relativeURI」、「ポート」、「ホスト」、「腹筋_経路」、「rel_path」、および「権威」の定義を採用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HTTP protocol does not place any a priori limit on the length of a URI. Servers MUST be able to handle the URI of any resource they serve, and SHOULD be able to handle URIs of unbounded length if they provide GET-based forms that could generate such URIs. A server SHOULD return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see section 10.4.15).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPプロトコルは、URIの長さに任意のアプリオリ制限を課しません。サーバは彼らが提供するリソースのURIを扱うことができなければならない、と彼らは、そのようなURIを生成することができGETベースのフォームを提供する場合、無制限の長さのURIを処理できる必要があります。 URIは、サーバーが（セクション10.4.15を参照）を扱うことができるよりも長い場合、サーバは414（要求URIが長すぎます）のステータスを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Servers ought to be cautious about depending on URI lengths above 255 bytes, because some older client or proxy implementations might not properly support these lengths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：サーバーは、一部の古いクライアントやプロキシ実装が適切にこれらの長さをサポートしていない可能性がありますので、255バイト以上のURIの長さに応じて、約慎重であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2 http URL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2 HTTPのURL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;http&#34; scheme is used to locate network resources via the HTTP protocol. This section defines the scheme-specific syntax and semantics for http URLs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「HTTP」スキームはHTTPプロトコルを介してネットワークリソースを検索するために使用されます。このセクションでは、HTTP URLのスキーム固有の構文およびセマンティクスを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
http_URL = &#34;http:&#34; &#34;//&#34; host [ &#34;:&#34; port ] [ abs_path [ &#34;?&#34; query ]]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP_URL = &#34;HTTP：&#34; &#34;//&#34; ホスト[ &#34;：&#34; ポート] [腹筋_経路の[ &#34;&#34;？クエリ]]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the port is empty or not given, port 80 is assumed. The semantics are that the identified resource is located at the server listening for TCP connections on that port of that host, and the Request-URI for the resource is abs_path (section 5.1.2). The use of IP addresses in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]). If the abs_path is not present in the URL, it MUST be given as &#34;/&#34; when used as a Request-URI for a resource (section 5.1.2). If a proxy receives a host name which is not a fully qualified domain name, it MAY add its domain to the host name it received. If a proxy receives a fully qualified domain name, the proxy MUST NOT change the host name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポートが指定された空またはされていない場合、ポート80が仮定されます。セマンティクスは、特定されたリソースは、そのホストのそのポートでTCP接続の待機サーバーに配置されていることであり、資源のためのRequest-URIが腹筋_経路（セクション5.1.2）です。 URLでIPアドレスの使用は、（RFC 1900 [24]参照）可能な限り避けるべきです。腹筋_経路がURLに存在しない場合は、「/」リソースの要求-URIとして使用（セクション5.1.2）のように与えられなければなりません。プロキシは完全修飾ドメイン名ではありませんホスト名を受信した場合、それが受信したホスト名にそのドメインを追加するかもしれません。プロキシは完全修飾ドメイン名を受信した場合、プロキシは、ホスト名を変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3 URI Comparison
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3 URIの比較
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When comparing two URIs to decide if they match or not, a client SHOULD use a case-sensitive octet-by-octet comparison of the entire URIs, with these exceptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それらが一致するかどうかを判断するために2つのURIを比較するか、しない場合、クライアントは、これらの例外を除いて、全体のURIの大文字と小文字を区別オクテットごとのオクテットの比較を、使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A port that is empty or not given is equivalent to the default port for that URI-reference;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 空であるか与えられていないポートは、URI参照のデフォルトのポートと等価です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Comparisons of host names MUST be case-insensitive;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ホスト名の比較は大文字と小文字を区別してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Comparisons of scheme names MUST be case-insensitive;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - スキーム名の比較は大文字と小文字を区別しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- An empty abs_path is equivalent to an abs_path of &#34;/&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 空の腹筋_経路は、「/」の腹筋_経路に相当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Characters other than those in the &#34;reserved&#34; and &#34;unsafe&#34; sets (see RFC 2396 [42]) are equivalent to their &#34;&#34;%&#34; HEX HEX&#34; encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「予約」と「安全でない」セット（RFC 2396 [42]参照）は「」％「HEX HEX」符号化に相当するもの以外の文字。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, the following three URIs are equivalent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、次の三つのURIは等価です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
http://abc.com:80/~smith/home.html http://ABC.com/%7Esmith/home.html http://ABC.com:/%7esmith/home.html
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ｈっｔｐ：／／あｂｃ。こｍ：８０／〜ｓみｔｈ／ほめ。ｈｔｍｌ ｈっｔｐ：／／あＢＣ。こｍ／％７えｓみｔｈ／ほめ。ｈｔｍｌ ｈっｔｐ：／／あＢＣ。こｍ：／％７えｓみｔｈ／ほめ。ｈｔｍｌ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 Date/Time Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3日付/時刻書式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1 Full Date
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1完全な日付
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP applications have historically allowed three different formats for the representation of date/time stamps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPアプリケーションは歴史的に、日付/タイムスタンプの表現のための3つの異なるフォーマットを許可しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sun, 06 Nov 1994 08:49:37 GMT ; RFC 822, updated by RFC 1123 Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036 Sun Nov 6 08:49:37 1994 ; ANSI C&#39;s asctime() format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
日、1994年11月6日午前8時49分37秒GMT。 RFC 822、日曜日RFC 1123によって更新、06  -  11月 -  94 8時49分37秒GMT。 RFC 1036日11月6日午前8時49分37秒1994で廃止R​​FC 850、。 ANSI Cの関数は、asctime（）フォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first format is preferred as an Internet standard and represents a fixed-length subset of that defined by RFC 1123 [8] (an update to RFC 822 [9]). The second format is in common use, but is based on the obsolete RFC 850 [12] date format and lacks a four-digit year. HTTP/1.1 clients and servers that parse the date value MUST accept all three formats (for compatibility with HTTP/1.0), though they MUST only generate the RFC 1123 format for representing HTTP-date values in header fields. See section 19.3 for further information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の形式は、（[9] RFC 822への更新）インターネット標準として好ましく、RFC 1123によって定義された固定長の部分集合[8]を示しています。第二の形式は、一般的に使用されているが、廃止されたRFC 850 [12]日付フォーマットに基づいており、4桁の年を欠いています。彼らは唯一のヘッダフィールドにHTTP-日付値を表すためのRFC 1123形式を生成しなければならないのにHTTP /日付値を解析1.1クライアントとサーバは、（HTTP / 1.0との互換性のための）3つのすべてのフォーマットを受け入れなければなりません。詳細については項19.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Recipients of date values are encouraged to be robust in accepting date values that may have been sent by non-HTTP applications, as is sometimes the case when retrieving or posting messages via proxies/gateways to SMTP or NNTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：日付値の受信者は、SMTPまたはNNTPへのプロキシ/ゲートウェイを介してメッセージを取得するか、投稿するときに時々そうであるように、非HTTPアプリケーションによって送信された可能性があり日付値を受け入れるに堅牢であることを奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All HTTP date/time stamps MUST be represented in Greenwich Mean Time (GMT), without exception. For the purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal Time). This is indicated in the first two formats by the inclusion of &#34;GMT&#34; as the three-letter abbreviation for time zone, and MUST be assumed when reading the asctime format. HTTP-date is case sensitive and MUST NOT include additional LWS beyond that specifically included as SP in the grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのHTTP日付/時刻スタンプは例外なく、グリニッジ標準時（GMT）で表されなければなりません。 HTTPの目的のために、GMTはUTC（協定世界時）に正確に等しいです。これは、タイムゾーンの3文字の省略形として「GMT」を含めることによって最初の2つの形式で示され、そしているasctimeフォーマットを読み取る場合に想定されなければなりません。 HTTP-日は、大文字と小文字が区別され、具体的文法でSPとして含まそれを超えて追加のLWSを含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP-date    = rfc1123-date | rfc850-date | asctime-date
       rfc1123-date = wkday &#34;,&#34; SP date1 SP time SP &#34;GMT&#34;
       rfc850-date  = weekday &#34;,&#34; SP date2 SP time SP &#34;GMT&#34;
       asctime-date = wkday SP date3 SP time SP 4DIGIT
       date1        = 2DIGIT SP month SP 4DIGIT
                      ; day month year (e.g., 02 Jun 1982)
       date2        = 2DIGIT &#34;-&#34; month &#34;-&#34; 2DIGIT
                      ; day-month-year (e.g., 02-Jun-82)
       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                      ; month day (e.g., Jun  2)
       time         = 2DIGIT &#34;:&#34; 2DIGIT &#34;:&#34; 2DIGIT
                      ; 00:00:00 - 23:59:59
       wkday        = &#34;Mon&#34; | &#34;Tue&#34; | &#34;Wed&#34;
                    | &#34;Thu&#34; | &#34;Fri&#34; | &#34;Sat&#34; | &#34;Sun&#34;
       weekday      = &#34;Monday&#34; | &#34;Tuesday&#34; | &#34;Wednesday&#34;
                    | &#34;Thursday&#34; | &#34;Friday&#34; | &#34;Saturday&#34; | &#34;Sunday&#34;
       month        = &#34;Jan&#34; | &#34;Feb&#34; | &#34;Mar&#34; | &#34;Apr&#34;
                    | &#34;May&#34; | &#34;Jun&#34; | &#34;Jul&#34; | &#34;Aug&#34;
                    | &#34;Sep&#34; | &#34;Oct&#34; | &#34;Nov&#34; | &#34;Dec&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: HTTP requirements for the date/time stamp format apply only to their usage within the protocol stream. Clients and servers are not required to use these formats for user presentation, request logging, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：HTTP日付/時刻スタンプ形式の要件は、プロトコルストリーム内のそれらの使用法にのみ適用されます。クライアントとサーバーは、ユーザーの提示、要求ロギングなどのために、これらのフォーマットを使用する必要はありません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2 Delta Seconds
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2デルタ秒
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some HTTP header fields allow a time value to be specified as an integer number of seconds, represented in decimal, after the time that the message was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのHTTPヘッダフィールドは、時間値は、メッセージが受信された時間の後に10進数で表される秒の整数として指定されることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
delta-seconds = 1*DIGIT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デルタ秒= 1 * DIGIT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 Character Sets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4文字セット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP uses the same definition of the term &#34;character set&#34; as that described for MIME:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPはMIMEのために記載されるような用語「文字セット」の同じ定義を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The term &#34;character set&#34; is used in this document to refer to a method used with one or more tables to convert a sequence of octets into a sequence of characters. Note that unconditional conversion in the other direction is not required, in that not all characters may be available in a given character set and a character set may provide more than one sequence of octets to represent a particular character. This definition is intended to allow various kinds of character encoding, from simple single-table mappings such as US-ASCII to complex table switching methods such as those that use ISO-2022&#39;s techniques. However, the definition associated with a MIME character set name MUST fully specify the mapping to be performed from octets to characters. In particular, use of external profiling information to determine the exact mapping is not permitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
用語「文字セット」は、文字のシーケンスにオクテットのシーケンスを変換するために、1つまたは複数のテーブルで使用する方法を参照するために、このドキュメントで使用されています。他の方向に無条件変換が必要とされないことが、その中のすべての文字が指定された文字セットと文字セットで利用可能なものがない注特定の文字を表すオクテットの複数のシーケンスを提供することができます。この定義は、ISO-2022の技術を使用するものなどの方法を切り替えるようにUS-ASCIIなどの簡単な単一テーブルマッピングから複雑なテーブルに、文字エンコーディングの様々な種類を許可するように意図されます。しかし、MIME文字セット名に関連付けられている定義は、完全に文字にオクテットから実行されるマッピングを指定する必要があります。特に、正確なマッピングを決定するために、外部のプロファイリング情報の使用が許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: This use of the term &#34;character set&#34; is more commonly referred to as a &#34;character encoding.&#34; However, since HTTP and MIME share the same registry, it is important that the terminology also be shared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：用語「文字セット」のこの使用は、より一般に呼ばれる「文字エンコーディング。」 HTTPとMIMEが同じレジストリを共有しているのでしかし、専門用語も共有することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP character sets are identified by case-insensitive tokens. The complete set of tokens is defined by the IANA Character Set registry [19].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP文字セットは大文字と小文字を区別しないトークンによって識別されます。トークンの完全なセットは、IANA文字セット登録[19]によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
charset = token
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文字セット=トークン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although HTTP allows an arbitrary token to be used as a charset value, any token that has a predefined value within the IANA Character Set registry [19] MUST represent the character set defined by that registry. Applications SHOULD limit their use of character sets to those defined by the IANA registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPはcharset値、IANA文字セットレジストリ内の予め定義された値を有する任意のトークンとして使用される任意のトークンを可能にするが[19]、そのレジストリで定義されている文字セットを表現しなければなりません。アプリケーションは、IANAレジストリで定義されたものに文字セットの使用を制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementors should be aware of IETF character set requirements [38] [41].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装者は、[38] [41] IETF文字セットの要件に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1 Missing Charset
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1不足している文字セット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some HTTP/1.0 software has interpreted a Content-Type header without charset parameter incorrectly to mean &#34;recipient should guess.&#34; Senders wishing to defeat this behavior MAY include a charset parameter even when the charset is ISO-8859-1 and SHOULD do so when it is known that it will not confuse the recipient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのHTTP / 1.0ソフトウェアが正しく意味するcharsetパラメータなしのContent-Typeヘッダを解釈した「受信者は推測する必要があります。」文字セットはISO-8859-1であると、受信者を混乱させないことが知られているときに行う必要があります場合でも、この動作を無効にしたい送信者は、charsetパラメータを含むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unfortunately, some older HTTP/1.0 clients did not deal properly with an explicit charset parameter. HTTP/1.1 recipients MUST respect the charset label provided by the sender; and those user agents that have a provision to &#34;guess&#34; a charset MUST use the charset from the content-type field if they support that charset, rather than the recipient&#39;s preference, when initially displaying a document. See section 3.7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
残念ながら、いくつかの古いHTTP / 1.0クライアントは、明示的なcharsetパラメータを適切に処理しませんでした。 HTTP / 1.1の受信者は、送信者が提供する文字セットのラベルを尊重しなければなりません。彼らはその文字セットをサポートしている場合、最初に文書を表示するときや文字セットを「推測」する規定を持って、それらのユーザーエージェントは、むしろ受信者の好みよりも、Content-Typeフィールドから文字セットを使用しなければなりません。セクション3.7.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5 Content Codings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5コンテンツコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content coding values indicate an encoding transformation that has been or can be applied to an entity. Content codings are primarily used to allow a document to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the entity is stored in coded form, transmitted directly, and only decoded by the recipient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ符号化値がされている、またはエンティティに適用することができる符号変換を示します。内容コーディングは、主に文書がその根底にあるメディアタイプのアイデンティティを失うことなく、情報の損失なしに圧縮されるか、またはそうでなければ有効に変換することができるようにするために使用されています。しばしば、エンティティは、符号化された形式で格納されている直接送信され、受信者だけによって復号されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
content-coding = token
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツコーディング=トークン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All content-coding values are case-insensitive. HTTP/1.1 uses content-coding values in the Accept-Encoding (section 14.3) and Content-Encoding (section 14.11) header fields. Although the value describes the content-coding, what is more important is that it indicates what decoding mechanism will be required to remove the encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのコンテンツコーディング値は、大文字と小文字を区別しません。 HTTP / 1.1は受け入れエンコード（セクション14.3）とContent-符号化（セクション14.11）ヘッダーフィールドのコンテンツ符号化値を使用します。値は、コンテンツの符号化を記載しているが、何より重要なことは、それが復号機構が符号化を除去するために必要とされるかを示すことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Internet Assigned Numbers Authority (IANA) acts as a registry for content-coding value tokens. Initially, the registry contains the following tokens:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA（Internet Assigned Numbers Authority）は、コンテンツコード値トークンのレジストリとして作用します。最初は、レジストリは次のトークンが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
gzip An encoding format produced by the file compression program &#34;gzip&#34; (GNU zip) as described in RFC 1952 [25]. This format is a Lempel-Ziv coding (LZ77) with a 32 bit CRC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 1952 [25]に記載されているように、ファイル圧縮プログラム「GZIP」（GNUのzip）によって生成された符号化形式をgzip。このフォーマットは、32ビットのCRCを有するLempel-Zivコーディング（LZ77）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
compress The encoding format produced by the common UNIX file compression program &#34;compress&#34;. This format is an adaptive Lempel-Ziv-Welch coding (LZW).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的なUNIXファイル圧縮プログラム「圧縮」によって生成エンコード形式を圧縮します。この形式は、適応符号化のLempel-Ziv符号-ウェルチ（LZW）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Use of program names for the identification of encoding formats
        is not desirable and is discouraged for future encodings. Their
        use here is representative of historical practice, not good
        design. For compatibility with previous implementations of HTTP,
        applications SHOULD consider &#34;x-gzip&#34; and &#34;x-compress&#34; to be
        equivalent to &#34;gzip&#34; and &#34;compress&#34; respectively.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
deflate The &#34;zlib&#34; format defined in RFC 1950 [31] in combination with the &#34;deflate&#34; compression mechanism described in RFC 1951 [29].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 1951 [29]に記載の「収縮」圧縮機構と組み合わせてRFC 1950 [31]で定義された「ZLIB」形式を収縮させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
identity The default (identity) encoding; the use of no transformation whatsoever. This content-coding is used only in the Accept-Encoding header, and SHOULD NOT be used in the Content-Encoding header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アイデンティティデフォルト（アイデンティティ）エンコーディング。一切の変換を使用します。このコンテンツコーディングは、唯一のAccept-Encodingヘッダで使用され、およびContent-Encodingヘッダーで使用すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
New content-coding value tokens SHOULD be registered; to allow interoperability between clients and servers, specifications of the content coding algorithms needed to implement a new value SHOULD be publicly available and adequate for independent implementation, and conform to the purpose of content coding defined in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新コンテンツコーディング値トークンを登録する必要があります。クライアントとサーバ間の相互運用性を可能にし、新たな価値を実現するために必要な符号化アルゴリズムコンテンツの仕様は、独立した実装のために公に利用可能と十分であり、このセクションで定義されたコンテンツの符号化の目的に合致すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6 Transfer Codings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6転送コーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transfer-coding values are used to indicate an encoding transformation that has been, can be, or may need to be applied to an entity-body in order to ensure &#34;safe transport&#34; through the network. This differs from a content coding in that the transfer-coding is a property of the message, not of the original entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送符号化値がされた符号化変換を示すために使用される、とすることができる、またはネットワークを介して「安全輸送」を確保するために、エンティティボディに適用される必要があるかもしれません。これは転送コーディングがメッセージのではなく、元のエンティティのプロパティであることを符号化コンテンツとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       transfer-coding         = &#34;chunked&#34; | transfer-extension
       transfer-extension      = token *( &#34;;&#34; parameter )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Parameters are in the form of attribute/value pairs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パラメータは、属性/値のペアの形です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       parameter               = attribute &#34;=&#34; value
       attribute               = token
       value                   = token | quoted-string
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All transfer-coding values are case-insensitive. HTTP/1.1 uses transfer-coding values in the TE header field (section 14.39) and in the Transfer-Encoding header field (section 14.41).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての転送コーディング値は、大文字と小文字を区別しません。 HTTP / 1.1は、TEヘッダフィールド（セクション14.39）および転送符号化ヘッダフィールド（セクション14.41）で転送コーディング値を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST include &#34;chunked&#34;, unless the message is terminated by closing the connection. When the &#34;chunked&#34; transfer-coding is used, it MUST be the last transfer-coding applied to the message-body. The &#34;chunked&#34; transfer-coding MUST NOT be applied more than once to a message-body. These rules allow the recipient to determine the transfer-length of the message (section 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送コーディングがメッセージボディに適用されたとき、転送コーディングのセットは、メッセージが接続を閉じることによって終了されない限り、「チャンク」を含まなければなりません。 「チャンク」転送符号化が使用される場合、それは最後の転送コーディングメッセージボディに適用されなければなりません。 「チャンク」転送コーディングは、メッセージ本文に複数回適用してはなりません。これらのルールは、受信者がメッセージ（セクション4.4）の転送長を決定することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transfer-codings are analogous to the Content-Transfer-Encoding values of MIME [7], which were designed to enable safe transport of binary data over a 7-bit transport service. However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP, the only unsafe characteristic of message-bodies is the difficulty in determining the exact body length (section 7.2.2), or the desire to encrypt data over a shared transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送コーディングは、7ビットのトランスポート・サービス上のバイナリデータの安全な輸送を可能にするために設計されたMIMEのコンテンツ転送エンコード値[7]に類似しています。しかし、安全な輸送は、8ビット・クリーンな転送プロトコルの異なる焦点を持っています。 HTTPでは、メッセージ体の唯一危険な特性は、正確な本体長さ（セクション7.2.2）、または共有トランスポートを介してデータを暗号化したいという要望を決定するのが困難なことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Internet Assigned Numbers Authority (IANA) acts as a registry for transfer-coding value tokens. Initially, the registry contains the following tokens: &#34;chunked&#34; (section 3.6.1), &#34;identity&#34; (section 3.6.2), &#34;gzip&#34; (section 3.5), &#34;compress&#34; (section 3.5), and &#34;deflate&#34; (section 3.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA（Internet Assigned Numbers Authority）は転送コーディング値トークンのレジストリとして作用します。最初は、レジストリは次のトークンが含まれています（セクション3.6.1）、 &#34;アイデンティティ&#34;（セクション3.6.2）、 &#34;GZIP&#34;（セクション3.5）、 &#34;チャンク&#34;、（セクション3.5） &#34;を圧縮&#34;、および &#34;収縮します&#34;（セクション3.5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
New transfer-coding value tokens SHOULD be registered in the same way as new content-coding value tokens (section 3.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい転送コーディング値トークンは、新しいコンテンツコーディング値トークン（セクション3.5）と同じ方法で登録する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server which receives an entity-body with a transfer-coding it does not understand SHOULD return 501 (Unimplemented), and close the connection. A server MUST NOT send transfer-codings to an HTTP/1.0 client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送コーディングそれが理解できないとエンティティボディを受信したサーバ501（未実装）を返し、接続を閉じる必要があります。サーバは、HTTP / 1.0クライアントに転送コーディングを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1 Chunked Transfer Coding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1チャンク転送コーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The chunked encoding modifies the body of a message in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing entity-header fields. This allows dynamically produced content to be transferred along with the information necessary for the recipient to verify that it has received the full message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
チャンク符号化は、エンティティヘッダフィールドを含むオプショントレーラが続くチャンクのシリーズ、独自のサイズインジケータと各、としてそれを転送するためにメッセージの本文を修正します。これは、完全なメッセージを受信したことを確認するために受信者に必要な情報とともに転送される動的に生成されるコンテンツを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Chunked-Body   = *chunk
                        last-chunk
                        trailer
                        CRLF
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
chunk = chunk-size [ chunk-extension ] CRLF chunk-data CRLF chunk-size = 1*HEX last-chunk = 1*(&#34;0&#34;) [ chunk-extension ] CRLF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= 1 * HEX最後のチャンク= 1 *（「0」）[チャンク・エクステンション] CRLFチャンク=チャンクサイズ[チャンク拡張] CRLFチャンクデータCRLFチャンクサイズ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
chunk-extension= *( &#34;;&#34; chunk-ext-name [ &#34;=&#34; chunk-ext-val ] ) chunk-ext-name = token chunk-ext-val = token | quoted-string chunk-data = chunk-size(OCTET) trailer = *(entity-header CRLF)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
チャンク拡張子= *（ &#34;;&#34; チャンク-EXT-名[ &#34;=&#34; チャンク-EXT-VAL]）チャンク-EXT-名=トークンチャンク-EXT-VAL =トークン|引用符で囲まれた文字列のチャンクデータ=チャンクサイズ（オクテット）トレーラー= *（エンティティヘッダCRLF）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The chunk-size field is a string of hex digits indicating the size of the chunk. The chunked encoding is ended by any chunk whose size is zero, followed by the trailer, which is terminated by an empty line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
チャンクサイズのフィールドは、チャンクのサイズを示す進数字の列です。チャンクエンコーディングは、その大きさがゼロである、空行で終了しトレーラー、続いて任意のチャンクによって終了されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The trailer allows the sender to include additional HTTP header fields at the end of the message. The Trailer header field can be used to indicate which header fields are included in a trailer (see section 14.40).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トレーラは、送信者がメッセージの最後に追加のHTTPヘッダフィールドを含めることができます。トレーラーヘッダフィールドは、ヘッダフィールドがトレーラに含まれるかを示すために使用することができる（セクション14.40を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server using chunked transfer-coding in a response MUST NOT use the trailer for any header fields unless at least one of the following is true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の少なくとも一つが真でなければ応答してチャンク転送符号化を使用して、サーバは、任意のヘッダフィールドのトレーラーを使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a)the request included a TE header field that indicates &#34;trailers&#34; is acceptable in the transfer-coding of the response, as described in section 14.39; or,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
a）リクエストは、セクション14.39に記載されているように「トレーラー」を示すTEヘッダフィールドは、応答の転送コーディングで許容含まれます。または、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b)the server is the origin server for the response, the trailer fields consist entirely of optional metadata, and the recipient could use the message (in a manner acceptable to the origin server) without receiving this metadata. In other words, the origin server is willing to accept the possibility that the trailer fields might be silently discarded along the path to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
b）は、サーバが応答するためのオリジンサーバであり、トレーラフィールドは、オプションのメタデータを完全に構成され、受信者はこのメタデータを受信することなく、オリジンサーバに許容されるようにメッセージ（）を使用することができます。言い換えれば、オリジンサーバは、トレーラーのフィールドは黙っクライアントへのパスに沿って捨てられるかもしれないという可能性を受け入れることを望んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This requirement prevents an interoperability failure when the message is being received by an HTTP/1.1 (or later) proxy and forwarded to an HTTP/1.0 recipient. It avoids a situation where compliance with the protocol would have necessitated a possibly infinite buffer on the proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この要件は、メッセージがHTTP / 1.1（またはそれ以降）プロキシによって受信され、HTTP / 1.0の受信者に転送されている相互運用性の障害を防止することができます。これは、プロトコルの遵守がプロキシ上の可能性が無限のバッファを必要としているでしょう事態を避けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example process for decoding a Chunked-Body is presented in appendix 19.4.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
チャンク・ボディを復号化するためのプロセス例は、付録19.4.6に提示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All HTTP/1.1 applications MUST be able to receive and decode the &#34;chunked&#34; transfer-coding, and MUST ignore chunk-extension extensions they do not understand.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのHTTP / 1.1のアプリケーションが受け取ると、「チャンク」転送コーディングをデコードできなければならない、と彼らは理解していないチャンクの拡張機能拡張を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7 Media Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7メディアタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP uses Internet Media Types [17] in the Content-Type (section 14.17) and Accept (section 14.1) header fields in order to provide open and extensible data typing and type negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPは、コンテンツタイプ（セクション14.17）、インターネットメディアタイプ[17]を使用し、オープンで拡張可能なデータタイプ及びタイプのネゴシエーションを提供するために（セクション14.1）ヘッダフィールドを受け入れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       media-type     = type &#34;/&#34; subtype *( &#34;;&#34; parameter )
       type           = token
       subtype        = token
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Parameters MAY follow the type/subtype in the form of attribute/value pairs (as defined in section 3.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（セクション3.6で定義されるように）パラメータは、属性/値のペアの形式でタイプ/サブタイプに従うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The type, subtype, and parameter attribute names are case-insensitive. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name. Linear white space (LWS) MUST NOT be used between the type and subtype, nor between an attribute and its value. The presence or absence of a parameter might be significant to the processing of a media-type, depending on its definition within the media type registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイプ、サブタイプ、およびパラメータ属性名は大文字と小文字を区別しません。パラメータ値は、パラメータ名のセマンティクスに応じて、大文字と小文字が区別されない場合があります。リニアホワイトスペース（LWS）はタイプとサブタイプの間で、また属性とその値の間で使用してはいけません。パラメータの有無メディアタイプレジストリ内のその定義に応じて、メディアタイプの処理に重要であるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that some older HTTP applications do not recognize media type parameters. When sending data to older HTTP applications, implementations SHOULD only use media type parameters when they are required by that type/subtype definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部の古いHTTPアプリケーションはメディアタイプパラメータを認識しないことに注意してください。古いHTTPアプリケーションにデータを送信するとき、彼らはそのタイプ/サブタイプの定義によって必要とされている場合、実装は唯一のメディアタイプパラメータを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Media-type values are registered with the Internet Assigned Number Authority (IANA [19]). The media type registration process is outlined in RFC 1590 [17]. Use of non-registered media types is discouraged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メディアタイプの値は、インターネット割り当て番号機関（IANA [19]）に登録されています。メディアタイプ登録処理は、RFC 1590 [17]に概説されています。非登録済みメディアタイプの使用は推奨されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7.1 Canonicalization and Text Defaults
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7.1正規化とテキストデフォルト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Internet media types are registered with a canonical form. An entity-body transferred via HTTP messages MUST be represented in the appropriate canonical form prior to its transmission except for &#34;text&#34; types, as defined in the next paragraph.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターネットメディアタイプは、標準的な形式で登録されています。次の段落で定義されるようにHTTPを介して転送されるエンティティボディは、メッセージは、「テキスト」タイプ以外の送信前に適切な標準形で表現されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When in canonical form, media subtypes of the &#34;text&#34; type use CRLF as the text line break. HTTP relaxes this requirement and allows the transport of text media with plain CR or LF alone representing a line break when it is done consistently for an entire entity-body. HTTP applications MUST accept CRLF, bare CR, and bare LF as being representative of a line break in text media received via HTTP. In addition, if the text is represented in a character set that does not use octets 13 and 10 for CR and LF respectively, as is the case for some multi-byte character sets, HTTP allows the use of whatever octet sequences are defined by that character set to represent the equivalent of CR and LF for line breaks. This flexibility regarding line breaks applies only to text media in the entity-body; a bare CR or LF MUST NOT be substituted for CRLF within any of the HTTP control structures (such as header fields and multipart boundaries).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
テキストの改行として「テキスト」タイプの利用CRLFの場合は正規の形式で、メディアサブタイプ。 HTTPは、この要件を緩和し、単独でそれが全体エンティティボディのために一貫して行われる改行を表す普通CRまたはLFのテキストメディアの輸送を可能にします。 HTTPアプリケーションはテキストメディアがHTTPを介して受信に改行の代表的なものとしてCRLF、むき出しのCR、およびむき出しのLFを受け入れなければなりません。また、テキストは、いくつかのマルチバイト文字セットの場合のように、HTTPは、配列がそのによって定義されるどんなオクテットを使用することができ、それぞれ、CRとLFのためのオクテット13と10を使用していない文字セットで表現されている場合文字は、改行のためのCRとLFと同等のものを表すように設定します。改行に関するこの柔軟性はエンティティボディのテキストメディアに適用されます。裸のCRまたはLFは、（ヘッダ・フィールドとマルチパート境界など）HTTP制御構造のいずれかの内にCRLFを置換してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an entity-body is encoded with a content-coding, the underlying data MUST be in a form defined above prior to being encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティボディは、コンテンツの符号化で符号化される場合、基礎となるデータは、符号化される前に上で定義された形態でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;charset&#34; parameter is used with some media types to define the character set (section 3.4) of the data. When no explicit charset parameter is provided by the sender, media subtypes of the &#34;text&#34; type are defined to have a default charset value of &#34;ISO-8859-1&#34; when received via HTTP. Data in character sets other than &#34;ISO-8859-1&#34; or its subsets MUST be labeled with an appropriate charset value. See section 3.4.1 for compatibility problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「文字セット」パラメータは、データの文字セット（セクション3.4）を定義するために、いくつかのメディアタイプで使用されています。明示的なcharsetパラメータが送信者によって提供されていない場合は、「テキスト」タイプのメディアサブタイプは、HTTPを介して受信されたとき、「ISO-8859-1」のデフォルトの文字セット値を持つように定義されています。キャラクターのデータは、「ISO-8859-1」以外の設定またはそのサブセットは、適切なcharset値でラベル付けされなければなりません。互換性の問題のためのセクション3.4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7.2 Multipart Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7.2マルチパートタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MIME provides for a number of &#34;multipart&#34; types -- encapsulations of one or more entities within a single message-body. All multipart types share a common syntax, as defined in section 5.1.1 of RFC 2046
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一メッセージボディ内の1つの以上のエンティティのカプセル化 -  MIMEは、「マルチパート」型の数を提供します。 RFC 2046のセクション5.1.1で定義されているすべてのマルチパートタイプは、共通の構文を共有します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[40], and MUST include a boundary parameter as part of the media type value. The message body is itself a protocol element and MUST therefore use only CRLF to represent line breaks between body-parts. Unlike in RFC 2046, the epilogue of any multipart message MUST be empty; HTTP applications MUST NOT transmit the epilogue (even if the original multipart contains an epilogue). These restrictions exist in order to preserve the self-delimiting nature of a multipart message-body, wherein the &#34;end&#34; of the message-body is indicated by the ending multipart boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[40]、およびメディアタイプ値の一部として境界パラメータを含まなければなりません。メッセージ本体は、プロトコル素子自体であり、したがって、身体部分との間の改行を表すためにのみCRLFを使用しなければなりません。 RFC 2046とは異なり、任意のマルチパートメッセージのエピローグが空でなければなりません。 HTTPアプリケーションは（元のマルチパートがエピローグが含まれていても）エピローグを送信してはなりません。これらの制限は、メッセージ本体の「終了」が終了マルチパート境界によって示されており、マルチパートメッセージボディの自己画定性質を維持するために存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, HTTP treats a multipart message-body no differently than any other media type: strictly as payload. The one exception is the &#34;multipart/byteranges&#34; type (appendix 19.2) when it appears in a 206 (Partial Content) response, which will be interpreted by some HTTP caching mechanisms as described in sections 13.5.4 and 14.16. In all other cases, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type. The MIME header fields within each body-part of a multipart message-body do not have any significance to HTTP beyond that defined by their MIME semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般に、HTTPは全く異なる他のメディアタイプよりもマルチパートメッセージボディを扱うない：厳密ペイロードとして。それはセクション13.5.4および14.16に記載されているように、いくつかのHTTPキャッシングメカニズムによって解釈される206（部分コンテンツ）応答に表示されたとき唯一の例外は、「マルチパート/ byteranges」タイプ（付録19.2）です。他のすべての場合において、HTTPユーザエージェントは、MIMEユーザエージェントと同一又は類似の挙動に従わなければならないだろうマルチタイプを受信します。マルチパートメッセージボディの各身体部分内のMIMEヘッダフィールドは、そのMIMEセマンティクスによって定義されたものを超えたHTTPのいずれかの意味を持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type. If an application receives an unrecognized multipart subtype, the application MUST treat it as being equivalent to &#34;multipart/mixed&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般に、HTTPユーザエージェントは、MIMEユーザエージェントと同一又は類似の挙動に従わなければならないだろうマルチタイプを受信します。アプリケーションが認識されないマルチパートサブタイプを受け取った場合、アプリケーションは「混合/マルチパート」と等価であるとして、それを扱わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The &#34;multipart/form-data&#34; type has been specifically defined for carrying form data suitable for processing via the POST request method, as described in RFC 1867 [15].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：RFC 1867年に記載されているように、「マルチパート/フォームデータ」型は、特に、POSTリクエストメソッドを介して処理に適した形式のデータを運ぶために定義されている[15]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8 Product Tokens
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8製品のトークン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Product tokens are used to allow communicating applications to identify themselves by software name and version. Most fields using product tokens also allow sub-products which form a significant part of the application to be listed, separated by white space. By convention, the products are listed in order of their significance for identifying the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
製品のトークンはソフトウェアの名前とバージョンによって自分自身を識別するために、アプリケーションを通信可能にするために使用されています。また、ホワイトスペースで区切られたリストするアプリケーションの重要な部分を形成する副生成物を、許可製品トークンを使用してほとんどのフィールド。慣例により、製品がアプリケーションを識別するためのその重要性の順に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       product         = token [&#34;/&#34; product-version]
       product-version = token
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Examples:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
       Server: Apache/0.8.4
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Product tokens SHOULD be short and to the point. They MUST NOT be used for advertising or other non-essential information. Although any token character MAY appear in a product-version, this token SHOULD only be used for a version identifier (i.e., successive versions of the same product SHOULD only differ in the product-version portion of the product value).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
製品トークンは短く、ポイントとすべきです。彼らは、広告や他の非必須情報のために使用してはいけません。任意のトークンの文字が製品バージョンに現れるかもしれないが、このトークンは唯一のバージョン識別子のために使用されるべきである（すなわち、同じ製品の連続的なバージョンは、製品価値の製品バージョン部分で異なるべきです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9 Quality Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9品質値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP content negotiation (section 12) uses short &#34;floating point&#34; numbers to indicate the relative importance (&#34;weight&#34;) of various negotiable parameters. A weight is normalized to a real number in the range 0 through 1, where 0 is the minimum and 1 the maximum value. If a parameter has a quality value of 0, then content with this parameter is `not acceptable&#39; for the client. HTTP/1.1 applications MUST NOT generate more than three digits after the decimal point. User configuration of these values SHOULD also be limited in this fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPコンテンツネゴシエーション（セクション12）は、様々な交渉パラメータの相対的重要度（「重量」）を示すために、短い「浮動小数点」番号を使用します。重みは0が最小値と最大値1である場合、1から0の範囲内の実数値に正規化されます。パラメータが0の品質値を持っている場合は、このパラメータを使用してコンテンツには、クライアントのための「`許容ではありません。 HTTP / 1.1のアプリケーションは、小数点以下3桁以上を生成してはなりません。これらの値のユーザ設定もこの方法で制限すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       qvalue         = ( &#34;0&#34; [ &#34;.&#34; 0*3DIGIT ] )
                      | ( &#34;1&#34; [ &#34;.&#34; 0*3(&#34;0&#34;) ] )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;Quality values&#34; is a misnomer, since these values merely represent relative degradation in desired quality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「品質値」は、これらの値は、単に、所望の品質の相対的な低下を表しているので、誤った名称です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10 Language Tags
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10言語タグ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A language tag identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded. HTTP uses language tags within the Accept-Language and Content-Language fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
言語タグが書き込まれ、またはそうでなければ他の人間への情報の通信のための人間によって運ば、発話自然言語を識別する。コンピュータ言語は明示的に除外されています。 HTTPは受け入れ言語とContent-言語フィールド内言語タグを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The syntax and registry of HTTP language tags is the same as that defined by RFC 1766 [1]. In summary, a language tag is composed of 1 or more parts: A primary language tag and a possibly empty series of subtags:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP言語タグの構文およびレジストリ[1] RFC 1766によって定義されたものと同じです。主言語タグとサブタグの空の場合シリーズ：要約すると、言語タグは1つの以上の部分から構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        language-tag  = primary-tag *( &#34;-&#34; subtag )
        primary-tag   = 1*8ALPHA
        subtag        = 1*8ALPHA
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
White space is not allowed within the tag and all tags are case-insensitive. The name space of language tags is administered by the IANA. Example tags include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホワイトスペースは、タグ内で許可されていないと、すべてのタグは大文字と小文字を区別しません。言語タグの名前空間はIANAによって管理されます。例タグが含まれます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
en, en-US, en-cockney, i-cherokee, x-pig-latin
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エン、EN-US、エンコックニー、I-チェロキー、X-豚 - ラテン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where any two-letter primary-tag is an ISO-639 language abbreviation and any two-letter initial subtag is an ISO-3166 country code. (The last three tags above are not registered tags; all but the last are examples of tags which could be registered in future.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意の2文字の主要タグはISO-639言語短縮形と任意の2文字の最初のサブタグですISO-3166国コードです。 （上記の最後の3つのタグは、タグが登録されていない、すべてが、最後には、将来的に登録することができるタグの例です。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.11 Entity Tags
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.11エンティティタグ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the ETag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. The definition of how they are used and compared as cache validators is in section 13.3.3. An entity tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグは同じ要求されたリソースからの二つ以上のエンティティを比較するために使用されています。 HTTP / 1.1のETag（セクション14.19）で、場合マッチ（セクション14.24）、（14.26部）なし - マッチした場合、及び場合レンジ（セクション14.27）ヘッダフィールドエンティティタグを使用します。彼らはキャッシュバリデータとして使用され、比較される方法の定義はセクション13.3.3です。エンティティタグは、おそらく弱インジケータで始まる不透明な引用符で囲まれた文字列で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
entity-tag = [ weak ] opaque-tag weak = &#34;W/&#34; opaque-tag = quoted-string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグ= [弱]不透明タグ弱=「W /」不透明タグ=引用符で囲まれた文字列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A &#34;strong entity tag&#34; MAY be shared by two entities of a resource only if they are equivalent by octet equality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「強いエンティティタグは」彼らはオクテットの平等によって同等である場合にのみ、リソースの2つのエンティティによって共有されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A &#34;weak entity tag,&#34; indicated by the &#34;W/&#34; prefix, MAY be shared by two entities of a resource only if the entities are equivalent and could be substituted for each other with no significant change in semantics. A weak entity tag can only be used for weak comparison.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「W /」接頭辞によって示され、「弱いエンティティタグ」は、エンティティが同等であり、意味論に有意な変化を用いて互いに置換することができた場合にのみ、リソースの2つのエンティティにより共有されてもよいです。弱いエンティティタグは、弱い比較のために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An entity tag MUST be unique across all versions of all entities associated with a particular resource. A given entity tag value MAY be used for entities obtained by requests on different URIs. The use of the same entity tag value in conjunction with entities obtained by requests on different URIs does not imply the equivalence of those entities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグは、特定のリソースに関連付けられているすべてのエンティティのすべてのバージョンで一意である必要があります。与えられたエンティティタグの値が異なるのURI上の要求によって得られるエンティティに対して使用されるかもしれません。別のURIでの要求によって得られるエンティティと一緒に同じエンティティタグ値の使用は、それらのエンティティの等価性を意味するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.12 Range Units
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.12レンジユニット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 allows a client to request that only part (a range of) the response entity be included within the response. HTTP/1.1 uses range units in the Range (section 14.35) and Content-Range (section 14.16) header fields. An entity can be broken down into subranges according to various structural units.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1クライアントは一部のみ（の範囲）応答エンティティが応答内に含まれることを要求することを可能にします。 HTTP / 1.1の用途の範囲内（セクション14.35）及びコンテンツレンジ（セクション14.16）ヘッダーフィールド単位の範囲です。エンティティは、種々の構成単位に係る部分的範囲に分解することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
range-unit = bytes-unit | other-range-unit bytes-unit = &#34;bytes&#34; other-range-unit = token
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レンジ・ユニット=バイト単位|他のレンジユニットのバイト単位は= =トークン他のレンジユニットを「バイト」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The only range unit defined by HTTP/1.1 is &#34;bytes&#34;. HTTP/1.1 implementations MAY ignore ranges specified using other units.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1によって定義された範囲のみの単位は「バイト」です。 HTTP / 1.1の実装は、他の単位を使用して、指定された範囲を無視してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 has been designed to allow implementations of applications that do not depend on knowledge of ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は、範囲の知識に依存しないアプリケーションの実装を許可するように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4 HTTP Message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4 HTTPメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 Message Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1メッセージタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP messages consist of requests from client to server and responses from server to client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPメッセージは、サーバーからクライアントへのクライアントからサーバーへの要求と応答で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP-message = Request | Response ; HTTP/1.1 messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPメッセージ=リクエスト|応答; HTTP / 1.1のメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Request (section 5) and Response (section 6) messages use the generic message format of RFC 822 [9] for transferring entities (the payload of the message). Both types of message consist of a start-line, zero or more header fields (also known as &#34;headers&#34;), an empty line (i.e., a line with nothing preceding the CRLF) indicating the end of the header fields, and possibly a message-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求（セクション5）と応答（セクション6）メッセージは、エンティティ（メッセージのペイロード）を転送するための[9] RFC 822の一般的なメッセージフォーマットを使用します。メッセージの両方のタイプは、スタートラインの（また、「ヘッダー」としても知られる）は、ゼロ以上のヘッダフィールド、ヘッダフィールドの終わりを示す空行（すなわち、CRLFの前に何もない線）からなり、おそらくはメッセージ本文。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        generic-message = start-line
                          *(message-header CRLF)
                          CRLF
                          [ message-body ]
        start-line      = Request-Line | Status-Line
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the interest of robustness, servers SHOULD ignore any empty line(s) received where a Request-Line is expected. In other words, if the server is reading the protocol stream at the beginning of a message and receives a CRLF first, it should ignore the CRLF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
堅牢性の関心では、サーバは要求ラインが期待されている（s）が受信したすべての空行を無視します。サーバは、メッセージの先頭にプロトコルストリームを読み取り、最初のCRLFを受信した場合、他の言葉では、それはCRLFを無視すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Certain buggy HTTP/1.0 client implementations generate extra CRLF&#39;s after a POST request. To restate what is explicitly forbidden by the BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an extra CRLF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定のバギーHTTP / 1.0クライアントの実装は、POSTリクエストの後に余分なCRLF年代を生成します。明示的BNFによって禁止されているものを言い換えるするには、HTTP / 1.1クライアントは、序文や余分なCRLFとの要求に従ってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 Message Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2メッセージヘッダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP header fields, which include general-header (section 4.5), request-header (section 5.3), response-header (section 6.2), and entity-header (section 7.1) fields, follow the same generic format as that given in Section 3.1 of RFC 822 [9]. Each header field consists of a name followed by a colon (&#34;:&#34;) and the field value. Field names are case-insensitive. The field value MAY be preceded by any amount of LWS, though a single SP is preferred. Header fields can be extended over multiple lines by preceding each extra line with at least one SP or HT. Applications ought to follow &#34;common form&#34;, where one is known or indicated, when generating HTTP constructs, since there might exist some implementations that fail to accept anything beyond the common forms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的なヘッダを含むHTTPヘッダフィールド、（セクション4.5）、リクエストヘッダ（セクション5.3）、応答ヘッダ（セクション6.2）、およびエンティティヘッダ（セクション7.1）フィールドは、セクションで与えられたものと同じ一般的なフォーマットに従いますRFC 822の3.1 [9]。フィールド値：各ヘッダフィールドは、コロン（「」）が続く名前で構成されています。フィールド名は大文字と小文字を区別しません。単一のSPが好ましいもののフィールド値は、LWSの任意の量によって先行されるかもしれません。ヘッダフィールドは、少なくとも1つのSPまたはHT各追加のラインを先行することによって、複数の行にわたって拡張することができます。アプリケーションは、1が知られているか、または一般的な形態を超えた何かを受け入れるように失敗するいくつかの実装が存在する可能性があるため、HTTP構造物を生成するとき、表示され、「一般的な形式」を、従うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       message-header = field-name &#34;:&#34; [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = &lt;the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The field-content does not include any leading or trailing LWS: linear white space occurring before the first non-whitespace character of the field-value or after the last non-whitespace character of the field-value. Such leading or trailing LWS MAY be removed without changing the semantics of the field value. Any LWS that occurs between field-content MAY be replaced with a single SP before interpreting the field value or forwarding the message downstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールド・コンテンツが先頭または末尾LWSが含まれていません：リニアホワイトスペースは、フィールド値の最初の非空白文字の前またはフィールド値の最後の非空白文字の後に発生します。そのような先頭または末尾LWSは、フィールド値のセマンティクスを変更することなく除去することができます。フィールド・コンテンツとの間に生じるいかなるLWSは、フィールド値を解釈または下流メッセージを転送する前に、単一のSPに置き換えてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The order in which header fields with differing field names are received is not significant. However, it is &#34;good practice&#34; to send general-header fields first, followed by request-header or response-header fields, and ending with the entity-header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
異なるフィールド名を持つヘッダフィールドが受信される順序は重要ではありません。しかし、リクエストヘッダやレスポンスヘッダフィールドに続く最初の一般的なヘッダフィールドを、送信するために「お勧め」であり、エンティティヘッダフィールドで終わります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one &#34;field-name: field-value&#34; pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じフィールド名を持つ複数のメッセージヘッダフィールドがあれば、メッセージ内に存在してもよく、そのヘッダフィールドの全体のフィールド値がカンマで区切られたリスト[すなわち、＃（値）]として定義されている場合にのみ。カンマで区切られ、最初に後続の各フィールド値を追加することによって、メッセージのセマンティクスを変更することなく、「フィールド値のフィールド名」ペア1つに複数のヘッダフィールドを組み合わせることが可能でなければなりません。同じフィールド名を持つヘッダフィールドが受信される順序は、結合フィールド値の解釈することが重要であり、メッセージが転送されるとき、したがって、プロキシは、これらのフィールドの値の順序を変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 Message Body
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3メッセージ本文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response. The message-body differs from the entity-body only when a transfer-coding has been applied, as indicated by the Transfer-Encoding header field (section 14.41).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPメッセージのメッセージボディには、（もしあれば）要求または応答に関連付けられたエンティティボディを搬送するために使用されます。メッセージ・ボディは、転送符号化ヘッダフィールド（14.41部）によって示されるように転送コーディングが適用された場合にのみ、エンティティボディと異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       message-body = entity-body
                    | &lt;entity-body encoded as per Transfer-Encoding&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transfer-Encoding MUST be used to indicate any transfer-codings applied by an application to ensure safe and proper transfer of the message. Transfer-Encoding is a property of the message, not of the entity, and thus MAY be added or removed by any application along the request/response chain. (However, section 3.6 places restrictions on when certain transfer-codings may be used.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送符号化は、メッセージの安全かつ適切な転送を保証するために、アプリケーションによって適用される任意の転送コーディングを示すために使用されなければなりません。転送符号化は、メッセージのではなく、エンティティのプロパティであるため、要求/応答チェーンに沿った任意のアプリケーションによって追加又は除去することができます。 （ただし、3.6節特定の転送コーディングを使用することができるときに場所の制限）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The rules for when a message-body is allowed in a message differ for requests and responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージボディがメッセージに許可されているときの規則は、要求と応答で異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The presence of a message-body in a request is signaled by the inclusion of a Content-Length or Transfer-Encoding header field in the request&#39;s message-headers. A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests. A server SHOULD read and forward a message-body on any request; if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求内のメッセージボディの存在はリクエストのメッセージ・ヘッダー内のContent-Lengthまたは転送符号化ヘッダフィールドを含めることによって通知されます。リクエストメソッド（セクション5.1.1）の仕様が要求にエンティティボディを送信する許可しない場合、メッセージボディは、要求に含まれてはいけません。サーバーはすべてのリクエストにメッセージボディを読み、転送すべきです。リクエストメソッドがエンティティボディのために定義された意味が含まれていない場合は、要求を処理する際に、そのメッセージボディは無視されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For response messages, whether or not a message-body is included with a message is dependent on both the request method and the response status code (section 6.1.1). All responses to the HEAD request method MUST NOT include a message-body, even though the presence of entity-header fields might lead one to believe they do. All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a message-body. All other responses do include a message-body, although it MAY be of zero length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答メッセージは、メッセージボディがメッセージに含まれているか否かをリクエストメソッドとレスポンスステータスコード（セクション6.1.1）の両方に依存します。 HEADリクエストメソッドへのすべての応答は、エンティティヘッダフィールドの存在は、彼らが信じるように1を招く可能性があるにもかかわらず、メッセージボディを含んではいけません。全ての1xx（情報）、204（コンテンツなし）、および304（変更されない）の応答は、メッセージボディを含めることはできません。他のすべての応答は、それがゼロの長さであり得るが、メッセージボディが含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4 Message Length
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4メッセージの長さ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The transfer-length of a message is the length of the message-body as it appears in the message; that is, after any transfer-codings have been applied. When a message-body is included with a message, the transfer-length of that body is determined by one of the following (in order of precedence):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージの転送長さは、それがメッセージに表示されるメッセージボディの長さです。すべての転送コーディングが適用された後、それは、あります。メッセージ本体がメッセージに含まれている場合に、その身体の転送長さは、（優先順位で）次のいずれかによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.Any response message which &#34;MUST NOT&#34; include a message-body (such as the 1xx, 204, and 304 responses and any response to a HEAD request) is always terminated by the first empty line after the header fields, regardless of the entity-header fields present in the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（例えば1XX、204、及び304個の応答とHEAD要求に対する応答として）メッセージ本体を含む「MUST NOT」1.Any応答メッセージは常にかかわらず、ヘッダフィールドの後の最初の空行で終了しますメッセージ中に存在するエンティティヘッダフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.If a Transfer-Encoding header field (section 14.41) is present and has any value other than &#34;identity&#34;, then the transfer-length is defined by use of the &#34;chunked&#34; transfer-coding (section 3.6), unless the message is terminated by closing the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送符号化ヘッダフィールド（セクション14.41）2.Ifは存在し、「同一性」以外の値を有し、その後、転送長は、メッセージがない限り、転送符号化（セクション3.6）を「チャンク」を用いて定義されます接続を閉じることで終了されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.If a Content-Length header field (section 14.13) is present, its decimal value in OCTETs represents both the entity-length and the transfer-length. The Content-Length header field MUST NOT be sent if these two lengths are different (i.e., if a Transfer-Encoding header field is present). If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Lengthヘッダフィールド（セクション14.13）3.Ifはオクテットで10進数は、エンティティ長と転送長さの両方を表し、存在します。これら2つの長さが異なる場合、Content-Lengthヘッダフィールドは、送信されてはいけません（すなわち、転送符号化ヘッダ・フィールドが存在する場合）。メッセージが転送エンコーディングヘッダフィールドおよびContent-Lengthヘッダフィールドの両方で受信される場合、後者は無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.If the message uses the media type &#34;multipart/byteranges&#34;, and the ransfer-length is not otherwise specified, then this self-elimiting media type defines the transfer-length. This media type UST NOT be used unless the sender knows that the recipient can arse it; the presence in a request of a Range header with ultiple byte-range specifiers from a 1.1 client implies that the lient can parse multipart/byteranges responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージ4.Ifメディアタイプ「マルチパート/ byteranges」を使用し、ransfer長が他に指定されていない場合、この自己elimitingメディアタイプは、転送長を規定します。送信者は受信者がそれをお尻ができることを知っていなければ、このメディアタイプUSTを使用するわけではありません。 1.1クライアントからultipleバイト範囲指定子とのRangeヘッダの要求における存在はlientマルチパート/ byteranges応答を解析することができることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       A range header might be forwarded by a 1.0 proxy that does not
       understand multipart/byteranges; in this case the server MUST
       delimit the message using methods defined in items 1,3 or 5 of
       this section.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.By the server closing the connection. (Closing the connection cannot be used to indicate the end of a request body, since that would leave no possibility for the server to send back a response.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続を閉じるサーバーを5.By。 （つまり、サーバがレスポンスを返送するための可能性を残していないことになるので、接続を閉じると、リクエストボディの終了を示すために使用できません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For compatibility with HTTP/1.0 applications, HTTP/1.1 requests containing a message-body MUST include a valid Content-Length header field unless the server is known to be HTTP/1.1 compliant. If a request contains a message-body and a Content-Length is not given, the server SHOULD respond with 400 (bad request) if it cannot determine the length of the message, or with 411 (length required) if it wishes to insist on receiving a valid Content-Length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、HTTP / 1.1準拠であることが知られていない限りHTTP / 1.0アプリケーションとの互換性のため、メッセージボディを含むHTTP / 1.1リクエストが有効なContent-Lengthヘッダフィールドを含まなければなりません。要求が含まれている場合は、メッセージ本体およびコンテンツ長が指定されていないそれが主張することを望む場合、サーバは、メッセージの長さを決定できない場合、400（悪い要求）で応答、または411（長さが必要）とすべきです有効なContent-Lengthを受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All HTTP/1.1 applications that receive entities MUST accept the &#34;chunked&#34; transfer-coding (section 3.6), thus allowing this mechanism to be used for messages when the message length cannot be determined in advance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティは受け入れなければならない受け取るすべてのHTTP / 1.1アプリケーションは、このようにメッセージの長さを事前に決定することができない場合、この機構は、メッセージのために使用することができるように、転送符号化（セクション3.6）を「チャンク」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Messages MUST NOT include both a Content-Length header field and a non-identity transfer-coding. If the message does include a non-identity transfer-coding, the Content-Length MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージは、Content-Lengthヘッダフィールドと非同一の転送コーディングの両方を含んではいけません。メッセージは非同一の転送コーディングを含まれている場合、コンテンツの長さを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a Content-Length is given in a message where a message-body is allowed, its field value MUST exactly match the number of OCTETs in the message-body. HTTP/1.1 user agents MUST notify the user when an invalid length is received and detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツの長さがメッセージボディが許可されているメッセージに与えられた場合、そのフィールドの値が正確にメッセージボディのオクテットの数と一致しなければなりません。無効な長さを受信し、検出されたときにHTTP / 1.1ユーザエージェントはユーザに通知しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5 General Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5一般ヘッダフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are a few header fields which have general applicability for both request and response messages, but which do not apply to the entity being transferred. These header fields apply only to the message being transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティが転送されているには適用されません両方の要求メッセージと応答メッセージのための一般的な適用性を持っているが、いくつかのヘッダフィールドがあります。これらのヘッダーフィールドは、送信されるメッセージに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       general-header = Cache-Control            ; Section 14.9
                      | Connection               ; Section 14.10
                      | Date                     ; Section 14.18
                      | Pragma                   ; Section 14.32
                      | Trailer                  ; Section 14.40
                      | Transfer-Encoding        ; Section 14.41
                      | Upgrade                  ; Section 14.42
                      | Via                      ; Section 14.45
                      | Warning                  ; Section 14.46
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
General-header field names can be extended reliably only in combination with a change in the protocol version. However, new or experimental header fields may be given the semantics of general header fields if all parties in the communication recognize them to be general-header fields. Unrecognized header fields are treated as entity-header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般ヘッダフィールド名は、プロトコルバージョンにおける変化と組み合わせて、確実に拡張することができます。通信のすべての当事者が一般ヘッダフィールドであることをそれらを認識場合は、新しいまたは実験ヘッダフィールドは、一般的なヘッダフィールドの意味論を与えてもよいです。認識されていないヘッダフィールドは、エンティティヘッダフィールドとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5 Request
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5リクエスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A request message from a client to a server includes, within the first line of that message, the method to be applied to the resource, the identifier of the resource, and the protocol version in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントからサーバへの要求メッセージは、そのメッセージの最初のライン内で、メソッドは、リソース、リソースの識別子、および使用中のプロトコル・バージョンに適用することを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Request       = Request-Line              ; Section 5.1
                        *(( general-header        ; Section 4.5
                         | request-header         ; Section 5.3
                         | entity-header ) CRLF)  ; Section 7.1
                        CRLF
                        [ message-body ]          ; Section 4.3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 Request-Line
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1リクエストライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Request-Line begins with a method token, followed by the Request-URI and the protocol version, and ending with CRLF. The elements are separated by SP characters. No CR or LF is allowed except in the final CRLF sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストラインは、Request-URIとプロトコルバージョンが続き、CRLFで終わる、メソッドトークンで始まります。要素はSP文字で区切られます。 CRまたはLF NOが最終のCRLFシーケンス以外で許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Request-Line = Method SP Request-URI SP HTTP-Version CRLF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストライン=メソッドのSPのRequest-URI SP HTTP-バージョンCRLF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1 Method
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1メソッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Method token indicates the method to be performed on the resource identified by the Request-URI. The method is case-sensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メソッドトークンは、Request-URIによって識別されたリソース上で実行される方法を示しています。この方法は、大文字と小文字が区別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Method         = &#34;OPTIONS&#34;                ; Section 9.2
                      | &#34;GET&#34;                    ; Section 9.3
                      | &#34;HEAD&#34;                   ; Section 9.4
                      | &#34;POST&#34;                   ; Section 9.5
                      | &#34;PUT&#34;                    ; Section 9.6
                      | &#34;DELETE&#34;                 ; Section 9.7
                      | &#34;TRACE&#34;                  ; Section 9.8
                      | &#34;CONNECT&#34;                ; Section 9.9
                      | extension-method
       extension-method = token
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The list of methods allowed by a resource can be specified in an Allow header field (section 14.7). The return code of the response always notifies the client whether a method is currently allowed on a resource, since the set of allowed methods can change dynamically. An origin server SHOULD return the status code 405 (Method Not Allowed) if the method is known by the origin server but not allowed for the requested resource, and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin server. The methods GET and HEAD MUST be supported by all general-purpose servers. All other methods are OPTIONAL; however, if the above methods are implemented, they MUST be implemented with the same semantics as those specified in section 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リソースが許可されるメソッドのリストは、許可ヘッダーフィールド（セクション14.7）で指定することができます。レスポンスのリターンコードは常に許可メソッドのセットを動的に変更することができますので、この方法は、現在、リソース上で許可されているかどうかをクライアントに通知します。この方法は、未認識またはオリジンサーバによって実装されていない場合メソッドがオリジンサーバによって知られているが、要求されたリソースのために許可されていない、及び501は、（実装されていない）されている場合、オリジンサーバは、（方法不可）ステータスコード405を返すべきです。メソッドはGETとHEADは、すべての汎用サーバでサポートしなければなりません。他のすべてのメソッドはオプションです。上記の方法が実装されている場合は、それらは、セクション9で指定されたものと同じ意味で実現されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2 Request-URI
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2要求URI
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Request-URI is a Uniform Resource Identifier (section 3.2) and identifies the resource upon which to apply the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストURIは、ユニフォームリソース識別子（セクション3.2）であり、要求を適用する際にリソースを識別する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Request-URI = &#34;*&#34; | absoluteURI | abs_path | authority
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Request-URI = &#34;*&#34; | absoluteURIで|腹筋_経路|権限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The four options for Request-URI are dependent on the nature of the request. The asterisk &#34;*&#34; means that the request does not apply to a particular resource, but to the server itself, and is only allowed when the method used does not necessarily apply to a resource. One example would be
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求URIのための4つのオプションはリクエストの性質に依存しています。アスタリスク「*」は、要求が特定のリソースに適用されますが、サーバー自体に、および使用方法は、必ずしもリソースには適用されない場合にのみ許可されていないことを意味します。一つの例は次のようになります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPTIONS * HTTP/1.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPTIONS * HTTP / 1.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The absoluteURI form is REQUIRED when the request is being made to a proxy. The proxy is requested to forward the request or service it from a valid cache, and return the response. Note that the proxy MAY forward the request on to another proxy or directly to the server specified by the absoluteURI. In order to avoid request loops, a proxy MUST be able to recognize all of its server names, including any aliases, local variations, and the numeric IP address. An example Request-Line would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求がプロキシになされているときabsoluteURIでフォームが必要とされます。プロキシが要求を転送するか、有効なキャッシュからそれにサービスを提供し、応答を返すように要求されています。プロキシが別のプロキシまたは直接absoluteURIでで指定されたサーバーに要求を転送することができることに注意してください。リクエストのループを避けるために、プロキシは任意のエイリアス、ローカルバリエーション、数値IPアドレスなど、そのサーバー名のすべてを認識できなければなりません。例えば、リクエストラインは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://www.w3.org/pub/WWW/TheProject.html HTTP / 1.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To allow for transition to absoluteURIs in all requests in future versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPの将来のバージョンですべての要求でabsoluteURIsへの移行を可能にするため、すべてのHTTP / 1.1サーバは、HTTP / 1.1クライアントにのみプロキシへの要求にそれらを生成しますにもかかわらず、要求でabsoluteURIでフォームを受け入れなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The authority form is only used by the CONNECT method (section 9.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
権限フォームは、CONNECTメソッド（セクション9.9）でのみ使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The most common form of Request-URI is that used to identify a resource on an origin server or gateway. In this case the absolute path of the URI MUST be transmitted (see section 3.2.1, abs_path) as the Request-URI, and the network location of the URI (authority) MUST be transmitted in a Host header field. For example, a client wishing to retrieve the resource above directly from the origin server would create a TCP connection to port 80 of the host &#34;www.w3.org&#34; and send the lines:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストURIの最も一般的な形態は、オリジンサーバやゲートウェイ上のリソースを識別するために使用されるということです。この場合、URIの絶対パスは、Request-URIとして（セクション3.2.1、腹筋_経路を参照）を送信しなければならない、およびURI（権限）のネットワーク位置は、Hostヘッダフィールドで送信されなければなりません。例えば、オリジンサーバから直接上記のリソースを取得したいクライアントはホスト「www.w3.org」のポート80へのTCP接続を作成し、行を送信します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
followed by the remainder of the Request. Note that the absolute path cannot be empty; if none is present in the original URI, it MUST be given as &#34;/&#34; (the server root).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストの残りの部分が続きます。絶対パスが空でないことに注意してください。いずれも、元のURIに存在しない場合、それは「/」（ルートサーバ）として与えられなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Request-URI is transmitted in the format specified in section 3.2.1. If the Request-URI is encoded using the &#34;% HEX HEX&#34; encoding [42], the origin server MUST decode the Request-URI in order to properly interpret the request. Servers SHOULD respond to invalid Request-URIs with an appropriate status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストURIはセクション3.2.1で指定された形式で送信されます。 Request-URIは「％HEX HEX」エンコーディング[42]を用いて符号化される場合、オリジンサーバは、リクエストを適切に解釈するために、リクエストURIをデコードしなければなりません。サーバは、適切なステータスコードで無効な要求-URIに応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A transparent proxy MUST NOT rewrite the &#34;abs_path&#34; part of the received Request-URI when forwarding it to the next inbound server, except as noted above to replace a null abs_path with &#34;/&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「/」でヌル腹筋_経路を交換するために、上述したよう除き、次のインバウンドサーバに転送する際に透過型プロキシは、受信したリクエスト-URIの「腹筋_経路」の部分を書き換えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The &#34;no rewrite&#34; rule prevents the proxy from changing the meaning of the request when the origin server is improperly using a non-reserved URI character for a reserved purpose. Implementors should be aware that some pre-HTTP/1.1 proxies have been known to rewrite the Request-URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：「いいえリライト」ルールはオリジンサーバが不正に予約された目的のために予約されていないURIの文字を使用している場合、要求の意味を変更プロキシを防ぐことができます。実装者は、いくつかの事前HTTP / 1.1プロキシが要求URIを書き換えることが知られていることに注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 The Resource Identified by a Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2リクエストで識別されるリソース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターネット要求によって識別正確な資源は、Request-URIとHostヘッダフィールドの両方を調べることによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An origin server that does not allow resources to differ by the requested host MAY ignore the Host header field value when determining the resource identified by an HTTP/1.1 request. (But see section 19.6.1.1 for other requirements on Host support in HTTP/1.1.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1リクエストによって識別されたリソースを決定する際のリソースが要求されたホストによって異なることはできませんオリジンサーバはHostヘッダフィールドの値を無視するかもしれません。 （しかし、HTTP / 1.1のホストサポートの他の要件については、セクション19.6.1.1を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An origin server that does differentiate resources based on the host requested (sometimes referred to as virtual hosts or vanity host names) MUST use the following rules for determining the requested resource on an HTTP/1.1 request:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求されたホストに基づいてリソースを区別し、オリジンサーバは、（時々、仮想ホストまたはバニティホスト名と呼ぶ）HTTP / 1.1リクエストで要求されたリソースを決定するための以下の規則を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. If Request-URI is an absoluteURI, the host is part of the Request-URI. Any Host header field value in the request MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1のRequest-URIがabsoluteURIである場合、ホストは、Request-URIの一部です。要求内の任意のホストヘッダーフィールドの値を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. If the Request-URI is not an absoluteURI, and the request includes a Host header field, the host is determined by the Host header field value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.リクエストURIがabsoluteURIでなく、リクエストがHostヘッダフィールドが含まれている場合、ホストは、ホストヘッダフィールド値によって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. If the host as determined by rule 1 or 2 is not a valid host on the server, the response MUST be a 400 (Bad Request) error message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.ルール1又は2によって決定されるように、ホストは、サーバ上で有効なホストでない場合、応答は400（悪いRequest）エラーメッセージでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Recipients of an HTTP/1.0 request that lacks a Host header field MAY attempt to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to determine what exact resource is being requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヒューリスティックを使用しようとする可能性のあるホストヘッダフィールドを欠いているHTTP / 1.0リクエストの受信者（例えば、特定のホストに固有のもののためのURIパスの検査）要求されている正確なものリソースを決定するためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 Request Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3リクエストヘッダフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The request-header fields allow the client to pass additional information about the request, and about the client itself, to the server. These fields act as request modifiers, with semantics equivalent to the parameters on a programming language method invocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエスト・ヘッダー・フィールドは、クライアントが要求に関する追加情報を渡すことができ、且つサーバへのクライアント自体、約。これらのフィールドは、プログラミング言語のメソッド呼び出しのパラメータと同等の意味を持つ、リクエスト修飾子として動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       request-header = Accept                   ; Section 14.1
                      | Accept-Charset           ; Section 14.2
                      | Accept-Encoding          ; Section 14.3
                      | Accept-Language          ; Section 14.4
                      | Authorization            ; Section 14.8
                      | Expect                   ; Section 14.20
                      | From                     ; Section 14.22
                      | Host                     ; Section 14.23
                      | If-Match                 ; Section 14.24
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      | If-Modified-Since        ; Section 14.25
                      | If-None-Match            ; Section 14.26
                      | If-Range                 ; Section 14.27
                      | If-Unmodified-Since      ; Section 14.28
                      | Max-Forwards             ; Section 14.31
                      | Proxy-Authorization      ; Section 14.34
                      | Range                    ; Section 14.35
                      | Referer                  ; Section 14.36
                      | TE                       ; Section 14.39
                      | User-Agent               ; Section 14.43
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Request-header field names can be extended reliably only in combination with a change in the protocol version. However, new or experimental header fields MAY be given the semantics of request-header fields if all parties in the communication recognize them to be request-header fields. Unrecognized header fields are treated as entity-header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストヘッダフィールド名はプロトコルバージョンにおける変化との組み合わせでのみ確実に拡張することができます。通信のすべての当事者がリクエストヘッダフィールドであることをそれらを認識場合は、新しいまたは実験ヘッダフィールドは、リクエストヘッダフィールドの意味論を与えてもよいです。認識されていないヘッダフィールドは、エンティティヘッダフィールドとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6 Response
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6レスポンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After receiving and interpreting a request message, a server responds with an HTTP response message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求メッセージを受信し、解釈した後、サーバはHTTP応答メッセージで応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Response      = Status-Line               ; Section 6.1
                       *(( general-header        ; Section 4.5
                        | response-header        ; Section 6.2
                        | entity-header ) CRLF)  ; Section 7.1
                       CRLF
                       [ message-body ]          ; Section 7.2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 Status-Line
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1ステータスライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first line of a Response message is the Status-Line, consisting of the protocol version followed by a numeric status code and its associated textual phrase, with each element separated by SP characters. No CR or LF is allowed except in the final CRLF sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答メッセージの最初の行は、数値ステータスコードとSPの文字で区切られた各要素とその関連テキストフレーズ、続くプロトコルバージョンからなる、ステータスラインです。 CRまたはLF NOが最終のCRLFシーケンス以外で許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータスライン= HTTP-バージョンSPステータスコードSP理由-フレーズCRLF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1 Status Code and Reason Phrase
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1ステータスコードおよび理由句
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Status-Code element is a 3-digit integer result code of the attempt to understand and satisfy the request. These codes are fully defined in section 10. The Reason-Phrase is intended to give a short textual description of the Status-Code. The Status-Code is intended for use by automata and the Reason-Phrase is intended for the human user. The client is not required to examine or display the Reason-Phrase.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータスコードエレメントは、理解し、要求を満足させる試みの3桁の整数の結果コードです。これらのコードが完全部10で定義されている理由、フレーズステータスコードの短いテキスト記述を与えることを意図しています。ステータスコードは、オートマトンによる使用を目的としており、理由-フレーズは人間のユーザを対象としています。クライアントが理由-フレーズを調べたり、表示するために必要とされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first digit of the Status-Code defines the class of response. The last two digits do not have any categorization role. There are 5 values for the first digit:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータスコードの最初の数字は応答のクラスを定義します。最後の2桁は任意の分類の役割を持っていません。最初の数字のための5つの値があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 1xx: Informational - Request received, continuing process
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - の1xx：情報 - リクエスト受け、継続的なプロセス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 2xx: Success - The action was successfully received, understood, and accepted
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - の2xx：成功 - アクションが成功し、受信理解し、受け入れられました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 3xx: Redirection - Further action must be taken in order to complete the request
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  300番台：リダイレクション - さらなるアクションが要求を完了するために取られなければなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 4xx: Client Error - The request contains bad syntax or cannot be fulfilled
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  4XX：クライアントエラー - 要求が不正な構文を含む、または満たすことができません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 5xx: Server Error - The server failed to fulfill an apparently valid request
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  5xxの：サーバーエラー - サーバーが明らかに有効な要求を満たすことができませんでした
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The individual values of the numeric status codes defined for HTTP/1.1, and an example set of corresponding Reason-Phrase&#39;s, are presented below. The reason phrases listed here are only recommendations -- they MAY be replaced by local equivalents without affecting the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1のために定義された数値ステータスコードの個々の値、および対応する理由-フレーズのセットの例は、以下に提示されています。ここに記載されている理由の句は推奨されている - 彼らはプロトコルに影響を与えることなく、地元の同等物に置き換えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status-Code = &#34;100&#34; ; Section 10.1.1: Continue | &#34;101&#34; ; Section 10.1.2: Switching Protocols | &#34;200&#34; ; Section 10.2.1: OK | &#34;201&#34; ; Section 10.2.2: Created | &#34;202&#34; ; Section 10.2.3: Accepted | &#34;203&#34; ; Section 10.2.4: Non-Authoritative Information | &#34;204&#34; ; Section 10.2.5: No Content | &#34;205&#34; ; Section 10.2.6: Reset Content | &#34;206&#34; ; Section 10.2.7: Partial Content | &#34;300&#34; ; Section 10.3.1: Multiple Choices | &#34;301&#34; ; Section 10.3.2: Moved Permanently | &#34;302&#34; ; Section 10.3.3: Found | &#34;303&#34; ; Section 10.3.4: See Other | &#34;304&#34; ; Section 10.3.5: Not Modified | &#34;305&#34; ; Section 10.3.6: Use Proxy | &#34;307&#34; ; Section 10.3.8: Temporary Redirect | &#34;400&#34; ; Section 10.4.1: Bad Request | &#34;401&#34; ; Section 10.4.2: Unauthorized | &#34;402&#34; ; Section 10.4.3: Payment Required | &#34;403&#34; ; Section 10.4.4: Forbidden | &#34;404&#34; ; Section 10.4.5: Not Found | &#34;405&#34; ; Section 10.4.6: Method Not Allowed | &#34;406&#34; ; Section 10.4.7: Not Acceptable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータスコード=「100」; 10.1.1項：続行| 「101」。 10.1.2項：プロトコルの切り替え| 「200」。 10.2.1項：OK | 「201」。 10.2.2項：作成しました| 「202」。 10.2.3：受理| 「203」。 10.2.4項：非信頼できる情報| 「204」。 10.2.5項：いいえコンテンツ| 「205」。 10.2.6項：コンテンツをリセット| 「206」。 10.2.7項​​：部分コンテンツ| 「300」。 10.3.1項：複数の選択肢| 「301」。 10.3.2項：恒久的に移動| 「302」。 10.3.3項：実測値| 「303」。セクション10.3.4：その他を見ます| 「304」。 10.3.5項：修正ません| 「305」。セクション10.3.6：プロキシを使用| 「307」。 10.3.8：一時的なリダイレクト| 「400」。セクション10.4.1：不正な要求| 「401」。 10.4.2項：無許可| 「402」。 10.4.3項：支払いが必要| 「403」。 10.4.4項：禁断| 「404」。セクション10.4.5：見つかりません| 「405」。セクション10.4.6：メソッドは許可されていません| 「406」。セクション10.4.7：許容できません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          | &#34;407&#34;  ; Section 10.4.8: Proxy Authentication Required
          | &#34;408&#34;  ; Section 10.4.9: Request Time-out
          | &#34;409&#34;  ; Section 10.4.10: Conflict
          | &#34;410&#34;  ; Section 10.4.11: Gone
          | &#34;411&#34;  ; Section 10.4.12: Length Required
          | &#34;412&#34;  ; Section 10.4.13: Precondition Failed
          | &#34;413&#34;  ; Section 10.4.14: Request Entity Too Large
          | &#34;414&#34;  ; Section 10.4.15: Request-URI Too Large
          | &#34;415&#34;  ; Section 10.4.16: Unsupported Media Type
          | &#34;416&#34;  ; Section 10.4.17: Requested range not satisfiable
          | &#34;417&#34;  ; Section 10.4.18: Expectation Failed
          | &#34;500&#34;  ; Section 10.5.1: Internal Server Error
          | &#34;501&#34;  ; Section 10.5.2: Not Implemented
          | &#34;502&#34;  ; Section 10.5.3: Bad Gateway
          | &#34;503&#34;  ; Section 10.5.4: Service Unavailable
          | &#34;504&#34;  ; Section 10.5.5: Gateway Time-out
          | &#34;505&#34;  ; Section 10.5.6: HTTP Version not supported
          | extension-code
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extension-code = 3DIGIT Reason-Phrase = *&lt;TEXT, excluding CR, LF&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張コード= 3DIGIT理由-フレーズ= * &lt;TEXT除くCR、LF&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP status codes are extensible. HTTP applications are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable. However, applications MUST understand the class of any status code, as indicated by the first digit, and treat any unrecognized response as being equivalent to the x00 status code of that class, with the exception that an unrecognized response MUST NOT be cached. For example, if an unrecognized status code of 431 is received by the client, it can safely assume that there was something wrong with its request and treat the response as if it had received a 400 status code. In such cases, user agents SHOULD present to the user the entity returned with the response, since that entity is likely to include human-readable information which will explain the unusual status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPステータスコードは、拡張可能です。そのような理解は明らかに望ましいですが、HTTPアプリケーションは、登録されているすべてのステータスコードの意味を理解する必要はありません。ただし、アプリケーションは最初の数字で示されるように、任意のステータスコードのクラスを理解し、認識されない応答をキャッシュしてはならないことを除いて、そのクラスのX00ステータスコードと同等のものとして認識されない応答を扱わなければなりません。例えば、431の認識されていないステータスコードがクライアントによって受信された場合、それは安全にその要求に何か問題があったと仮定することができますし、それが400のステータスコードを受け取ったかのように応答を扱います。そのエンティティが異常状態を説明する人間可読情報を含む可能性があるので、このような場合、ユーザエージェントは、エンティティが応答で返さユーザに提示しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 Response Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2レスポンスヘッダフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The response-header fields allow the server to pass additional information about the response which cannot be placed in the Status-Line. These header fields give information about the server and about further access to the resource identified by the Request-URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レスポンスヘッダフィールドは、サーバがステータスラインに配置することができない応答に関する追加情報を通過させます。これらのヘッダーフィールドは、サーバに関するとRequest-URIによって識別されたリソースへのさらなるアクセスについての情報を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       response-header = Accept-Ranges           ; Section 14.5
                       | Age                     ; Section 14.6
                       | ETag                    ; Section 14.19
                       | Location                ; Section 14.30
                       | Proxy-Authenticate      ; Section 14.33
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       | Retry-After             ; Section 14.37
                       | Server                  ; Section 14.38
                       | Vary                    ; Section 14.44
                       | WWW-Authenticate        ; Section 14.47
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Response-header field names can be extended reliably only in combination with a change in the protocol version. However, new or experimental header fields MAY be given the semantics of response-header fields if all parties in the communication recognize them to be response-header fields. Unrecognized header fields are treated as entity-header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レスポンスヘッダフィールド名はプロトコルバージョンにおける変化との組み合わせでのみ確実に拡張することができます。通信のすべての当事者がレスポンスヘッダフィールドであることをそれらを認識場合は、新しいまたは実験ヘッダフィールドは、レスポンスヘッダフィールドの意味論を与えてもよいです。認識されていないヘッダフィールドは、エンティティヘッダフィールドとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7 Entity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7エンティティ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Request and Response messages MAY transfer an entity if not otherwise restricted by the request method or response status code. An entity consists of entity-header fields and an entity-body, although some responses will only include the entity-headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうでない場合は、要求メソッドやレスポンスのステータスコードによって制限されていない場合は要求メッセージと応答メッセージは、エンティティを転送することができます。いくつかの応答のみエンティティヘッダを含むであろうが、エンティティは、エンティティ - ヘッダフィールド及びエンティティ - 本体から成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this section, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、送信者と受信者の両方を送信し、誰エンティティの受信者に応じて、クライアントまたはサーバのいずれかを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 Entity Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1エンティティヘッダフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Entity-header fields define metainformation about the entity-body or, if no body is present, about the resource identified by the request. Some of this metainformation is OPTIONAL; some might be REQUIRED by portions of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
全く体が存在しない場合、エンティティヘッダフィールドは、要求によって識別されたリソースについて、エンティティボディについてのメタ情報を定義しますか。このメタ情報の一部はオプションです。いくつかは、この仕様の部分で必要になることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       entity-header  = Allow                    ; Section 14.7
                      | Content-Encoding         ; Section 14.11
                      | Content-Language         ; Section 14.12
                      | Content-Length           ; Section 14.13
                      | Content-Location         ; Section 14.14
                      | Content-MD5              ; Section 14.15
                      | Content-Range            ; Section 14.16
                      | Content-Type             ; Section 14.17
                      | Expires                  ; Section 14.21
                      | Last-Modified            ; Section 14.29
                      | extension-header
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extension-header = message-header
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張ヘッダー=メッセージ・ヘッダ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The extension-header mechanism allows additional entity-header fields to be defined without changing the protocol, but these fields cannot be assumed to be recognizable by the recipient. Unrecognized header fields SHOULD be ignored by the recipient and MUST be forwarded by transparent proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張ヘッダメカニズムは、追加のエンティティヘッダフィールドは、プロトコルを変更せずに定義されるように、これらのフィールドは、受信者によって認識可能であると仮定することができない可能にします。認識されていないヘッダフィールドは、受信者によって無視されるべきであり、透明なプロキシによって転送されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 Entity Body
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2エンティティボディ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The entity-body (if any) sent with an HTTP request or response is in a format and encoding defined by the entity-header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP要求または応答と共に送信エンティティボディは、（もしあれば）エンティティヘッダフィールドによって定義されたフォーマット及び符号化です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
entity-body = *OCTET
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティボディ= * OCTET
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An entity-body is only present in a message when a message-body is present, as described in section 4.3. The entity-body is obtained from the message-body by decoding any Transfer-Encoding that might have been applied to ensure safe and proper transfer of the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージ本体が存在する場合のセクション4.3に記載したようにエンティティボディは、メッセージ中にのみ存在します。エンティティボディは、メッセージの安全かつ適切な転送を保証するために適用されている可能性のある転送エンコードをデコードして、メッセージボディから得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1 Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an entity-body is included with a message, the data type of that body is determined via the header fields Content-Type and Content-Encoding. These define a two-layer, ordered encoding model:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティボディがメッセージに含まれている場合に、その身体のデータ・タイプは、ヘッダフィールドのContent-TypeとContent-エンコーディングを介して決定されます。これらは、二層、注文したエンコーディングモデルを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
entity-body := Content-Encoding( Content-Type( data ) )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティボディ：=コンテンツのエンコーディング（Content-Typeの（データ））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Type specifies the media type of the underlying data. Content-Encoding may be used to indicate any additional content codings applied to the data, usually for the purpose of data compression, that are a property of the requested resource. There is no default encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツタイプは、基礎となるデータのメディアタイプを指定します。コンテンツのエンコーディングは要求されたリソースの所有物であり、通常はデータ圧縮の目的のために、データに適用された追加コンテンツのコーディングを示すために使用されてもよいです。デフォルトのエンコーディングはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any HTTP/1.1 message containing an entity-body SHOULD include a Content-Type header field defining the media type of that body. If and only if the media type is not given by a Content-Type field, the recipient MAY attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the resource. If the media type remains unknown, the recipient SHOULD treat it as type &#34;application/octet-stream&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティボディを含む任意のHTTP / 1.1メッセージは、そのボディのメディアタイプを定義するContent-Typeヘッダフィールドを含むべきです。メディアタイプは、Content-Typeフィールドで指定されていない場合にのみ、かつ、受信者はその内容および/またはURIの拡張子（S）の検査を経てメディアタイプを推測しようと可能性がある場合、リソースを識別するために使用されます。メディアタイプが不明のままである場合、受信者はタイプ「アプリケーション/オクテットストリーム」として扱うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2 Entity Length
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2エンティティの長さ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The entity-length of a message is the length of the message-body before any transfer-codings have been applied. Section 4.4 defines how the transfer-length of a message-body is determined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージの実体の長さの任意の転送コーディングが適用された前のメッセージボディの長さです。セクション4.4は、メッセージボディの転送長さが決定される方法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
8 Connections
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
8つの接続
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 Persistent Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1永続的な接続
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1 Purpose
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1目的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Prior to persistent connections, a separate TCP connection was established to fetch each URL, increasing the load on HTTP servers and causing congestion on the Internet. The use of inline images and other associated data often require a client to make multiple requests of the same server in a short amount of time. Analysis of these performance problems and results from a prototype implementation are available [26] [30]. Implementation experience and measurements of actual HTTP/1.1 (RFC 2068) implementations show good results [39]. Alternatives have also been explored, for example, T/TCP [27].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
持続的な接続に先立って、別々のTCP接続はHTTPサーバーの負荷を増加し、インターネット上の混雑を引き起こして、各URLを取得するために設立されました。インライン画像や他の関連するデータの使用は、多くの場合、短時間で同じサーバの複数の要求を行うために、クライアントが必要です。プロトタイプの実装のこれらの性能の問題と結果の解析が利用可能である[26] [30]。実装経験と実際のHTTP / 1.1（RFC 2068）の測定を実装する[39]良好な結果を示しています。代替はまた、例えば、検討されている、T / TCP [27]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Persistent HTTP connections have a number of advantages:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
永続的なHTTP接続は、多くの利点を持っています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - オープン少ないTCP接続を閉じることによって、CPU時間は、ルータとホスト（クライアント、サーバ、プロキシ、ゲートウェイ、トンネル、またはキャッシュ）に保存され、TCPプロトコル制御ブロックのために使用されるメモリは、ホストに保存することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTPリクエストとレスポンスは接続上でパイプライン化することができます。パイプラインは、はるかに低い経過時間で、はるかに効率的に使用するための単一のTCP接続を許可する、クライアントはそれぞれの応答を待たずに複数の要求を行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ネットワークの輻輳をTCPが開くことによって、引き起こされるパケットの数を減らすことによって、ネットワークの輻輳状態を決定するためにTCP十分な時間を可能にすることによって低減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Latency on subsequent requests is reduced since there is no time spent in TCP&#39;s connection opening handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  TCPの接続口握手で過ごした時間がないので、後続の要求の待ち時間が短縮されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old semantics after an error is reported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - エラーがTCP接続を閉じるのペナルティなしに報告することができますので、HTTPは、より優雅に進化させることができます。 HTTPの将来のバージョンを使用しているクライアントは、楽観的な新機能を試してみますが、古いサーバと通信する場合は、エラーが報告された後、古いセマンティクスを再試行することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP implementations SHOULD implement persistent connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP実装は、持続的な接続を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2 Overall Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2全体の動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A significant difference between HTTP/1.1 and earlier versions of HTTP is that persistent connections are the default behavior of any HTTP connection. That is, unless otherwise indicated, the client SHOULD assume that the server will maintain a persistent connection, even after error responses from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPのHTTP / 1.1およびそれ以前のバージョンとの間に有意な差は持続的な接続が任意のHTTP接続のデフォルトの動作であるということです。特に断らない限り、つまり、クライアントは、サーバでも、サーバーからエラー応答の後、持続的な接続を維持することを前提とすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Persistent connections provide a mechanism by which a client and a server can signal the close of a TCP connection. This signaling takes place using the Connection header field (section 14.10). Once a close has been signaled, the client MUST NOT send any more requests on that connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
持続的接続は、クライアントとサーバーは、TCPコネクションのクローズを知らせることができるメカニズムを提供します。このシグナリングは、Connectionヘッダフィールド（セクション14.10）を使用して行われます。近くには合図された後、クライアントはその接続上の任意のより多くのリクエストを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2.1 Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2.1交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to maintain a persistent connection unless a Connection header including the connection-token &#34;close&#34; was sent in the request. If the server chooses to close the connection immediately after sending the response, it SHOULD send a Connection header including the connection-token close.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1サーバは、HTTP / 1.1クライアントが要求で送信された「クローズ」接続トークンを含むConnectionヘッダない限り、永続的な接続を維持する意向であることを仮定してもよいです。サーバが応答を送信した後すぐに接続を閉じることを選択した場合、それは接続トークン近い含む接続ヘッダを送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An HTTP/1.1 client MAY expect a connection to remain open, but would decide to keep it open based on whether the response from a server contains a Connection header with the connection-token close. In case the client does not want to maintain a connection for more than that request, it SHOULD send a Connection header including the connection-token close.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1クライアントは、接続が開いたままに期待するかもしれないが、それは、サーバーからの応答は、接続トークン近いとの接続ヘッダーが含まれているかどうかに基づいて、開いたまますることを決定します。クライアントがそのリクエスト以上の接続を維持したくない場合は、接続トークンクローズ含むConnectionヘッダを送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If either the client or the server sends the close token in the Connection header, that request becomes the last one for the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントまたはサーバのどちらかがConnectionヘッダに近いトークンを送信する場合、その要求は、接続のための最後のものとなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients and servers SHOULD NOT assume that a persistent connection is maintained for HTTP versions less than 1.1 unless it is explicitly signaled. See section 19.6.2 for more information on backward compatibility with HTTP/1.0 clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバーは、それが明示的にシグナリングされない限り、永続的な接続が1.1未満HTTPのバージョンのために維持されていることを仮定するべきではありません。 HTTP / 1.0クライアントとの後方互換性の詳細については、セクション19.6.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to remain persistent, all messages on the connection MUST have a self-defined message length (i.e., one not defined by closure of the connection), as described in section 4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション4.4で説明したように、永続的維持するために、接続上のすべてのメッセージは、（すなわち、一方が接続の閉鎖によって定義されていない）の自己定義されたメッセージの長さを持たなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2.2 Pipelining
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2.2パイプライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client that supports persistent connections MAY &#34;pipeline&#34; its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
持続的接続をサポートするクライアントは、「パイプライン」の要求が（すなわち、各応答を待たずに複数のリクエストを送信）するかもしれません。サーバーは、要求が受け取られたのと同じ順序でこれらの要求への応答を送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients which assume persistent connections and pipeline immediately after connection establishment SHOULD be prepared to retry their connection if the first pipelined attempt fails. If a client does such a retry, it MUST NOT pipeline before it knows the connection is persistent. Clients MUST also be prepared to resend their requests if the server closes the connection before sending all of the corresponding responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続確立後すぐに持続的接続とパイプラインを想定してクライアントは、最初のパイプライン化の試行が失敗した場合、その接続を再試行するために準備する必要があります。クライアントは、このような再試行を行う場合は、接続が永続的であることを知っている前に、それは、パイプラインはいけません。また、クライアントは、サーバが対応するすべての応答を送信する前に、接続を閉じた場合、その要求を再送信するために準備しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients SHOULD NOT pipeline requests using non-idempotent methods or non-idempotent sequences of methods (see section 9.1.2). Otherwise, a premature termination of the transport connection could lead to indeterminate results. A client wishing to send a non-idempotent request SHOULD wait to send that request until it has received the response status for the previous request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非冪等の方法または方法の非冪等のシーケンスを（セクション9.1.2を参照）を使用しているクライアントがないはずのパイプラインを要求。それ以外の場合は、トランスポート接続の早期終了が不確定な結果につながる可能性があります。非べき等の要求を送信したいクライアントは、それが以前の要求に対する応答ステータスを受信するまで、その要求を送信するために待機しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.3 Proxy Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.3プロキシサーバ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is especially important that proxies correctly implement the properties of the Connection header field as specified in section 14.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション14.10で指定されたプロキシが正しく接続ヘッダフィールドのプロパティを実装することが特に重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The proxy server MUST signal persistent connections separately with its clients and the origin servers (or other proxy servers) that it connects to. Each persistent connection applies to only one transport link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシサーバは、それが接続する、クライアントとオリジンサーバ（または他のプロキシサーバ）とは別に、永続的な接続を通知しなければなりません。各永続的な接続は、唯一のトランスポートリンクに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy server MUST NOT establish a HTTP/1.1 persistent connection with an HTTP/1.0 client (but see RFC 2068 [33] for information and discussion of the problems with the Keep-Alive header implemented by many HTTP/1.0 clients).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシサーバは、HTTP / 1.0クライアントとHTTP / 1.1の永続的な接続を確立する（しかし、多くのHTTP / 1.0クライアントによって実装キープアライブヘッダーでの問題の情報と議論のためにRFC 2068 [33]を参照）してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.4 Practical Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.4実用的な考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers will usually have some time-out value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same server. The use of persistent connections places no requirements on the length (or existence) of this time-out for either the client or the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは通常、彼らはもはや非アクティブな接続を維持します、それを超えるいくつかのタイムアウト値を持つことになります。クライアントが同じサーバーを介して複数の接続を行うされる可能性があるため、プロキシサーバーは、この高い値になるかもしれません。持続的な接続を使用するには、クライアントまたはサーバーのいずれかのために、このタイムアウトの長さ（または存在）に何の要件を置きません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client or server wishes to time-out it SHOULD issue a graceful close on the transport connection. Clients and servers SHOULD both constantly watch for the other side of the transport close, and respond to it as appropriate. If a client or server does not detect the other side&#39;s close promptly it could cause unnecessary resource drain on the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントまたはサーバがタイムアウトすることを望むときには、トランスポート接続上の優雅なクローズを発行する必要があります。クライアントとサーバーは両方絶えず輸送の近くの他の側面を監視し、必要に応じてそれに応答する必要があります。クライアントまたはサーバーが他の側のクローズを検出しない場合、速やかには、ネットワーク上の不必要なリソース消耗を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the &#34;idle&#34; connection. From the server&#39;s point of view, the connection is being closed while it was idle, but from the client&#39;s point of view, a request is in progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント、サーバ、またはプロキシは、いつでも輸送接続を終えるかもしれません。例えば、クライアントは、サーバーが「アイドル」の接続をクローズすることを決定したと同時に、新しいリクエストを送信し始めているかもしれません。それがアイドル状態であったサーバの観点からは、接続が閉じられているが、クライアントの観点から、要求が進行中です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This means that clients, servers, and proxies MUST be able to recover from asynchronous close events. Client software SHOULD reopen the transport connection and retransmit the aborted sequence of requests without user interaction so long as the request sequence is idempotent (see section 9.1.2). Non-idempotent methods or sequences MUST NOT be automatically retried, although user agents MAY offer a human operator the choice of retrying the request(s). Confirmation by user-agent software with semantic understanding of the application MAY substitute for user confirmation. The automatic retry SHOULD NOT be repeated if the second sequence of requests fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、クライアント、サーバ、およびプロキシは非同期クローズイベントから回復できなければならないことを意味しています。クライアントソフトウェアは、（セクション9.1.2を参照）トランスポート接続を再オープンし、リクエストシーケンスが冪等である限り、ユーザーとの対話なしで要求の中止されたシーケンスを再送信すべきです。ユーザーエージェントが再試行の選択要求（複数可）人間のオペレータを提供することがありますが、非冪等メソッドやシーケンスは自動的に、再試行してはなりません。アプリケーションの意味理解を持つユーザー・エージェント・ソフトウェアによる確認は、ユーザーの確認を置換することができます。リクエストの第二の配列に失敗した場合に自動再試行が繰り返されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers SHOULD always respond to at least one request per connection, if at all possible. Servers SHOULD NOT close a connection in the middle of transmitting a response, unless a network or client failure is suspected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
可能で、すべての場合、サーバーは常に、接続ごとに少なくとも1つの要求に応答する必要があります。サーバーは、ネットワークやクライアントの障害が疑われる場合を除き、応答を送信の途中で接続をクローズすべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy. A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users. These guidelines are intended to improve HTTP response times and avoid congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
持続的接続を使用するクライアントは、彼らが特定のサーバーに維持する同時接続数を制限する必要があります。シングルユーザクライアントは、任意のサーバーまたはプロキシとの2つの以上の接続を維持すべきではありません。プロキシは、Nが同時にアクティブユーザの数であり、別のサーバまたはプロキシ、2つの* N接続まで使用すべきです。これらのガイドラインはHTTPレスポンスタイムを改善し、輻輳を回避することを意図しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 Message Transmission Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2メッセージ伝送要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1 Persistent Connections and Flow Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1永続的な接続とフローコントロール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 servers SHOULD maintain persistent connections and use TCP&#39;s flow control mechanisms to resolve temporary overloads, rather than terminating connections with the expectation that clients will retry. The latter technique can exacerbate network congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1サーバは、持続的な接続を維持し、むしろ、クライアントが再試行することを期待しての接続を終了するよりも、一時的な過負荷を解決するためにTCPのフロー制御メカニズムを使用すべきです。後者の技術は、ネットワークの輻輳を悪化させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2 Monitoring Connections for Error Status Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
エラーステータスメッセージの8.2.2モニタの接続
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An HTTP/1.1 (or later) client sending a message-body SHOULD monitor the network connection for an error status while it is transmitting the request. If the client sees an error status, it SHOULD immediately cease transmitting the body. If the body is being sent using a &#34;chunked&#34; encoding (section 3.6), a zero length chunk and empty trailer MAY be used to prematurely mark the end of the message. If the body was preceded by a Content-Length header, the client MUST close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、要求を送信している間、メッセージボディを送信するHTTP / 1.1（またはそれ以降）のクライアントは、エラー状態のためのネットワーク接続を監視する必要があります。クライアントがエラー状態を見れば、それはすぐに身体を送信中止すべきです。本体は、符号化（セクション3.6）、「チャンク」を使用して送信されている場合、長さゼロのチャンクと空のトレーラは、早期のメッセージの終わりをマークするために使用されるかもしれません。ボディがContent-Lengthヘッダが先行していた場合、クライアントは接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.3 Use of the 100 (Continue) Status
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
100（続行）ステータスの8.2.3を使用します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The purpose of the 100 (Continue) status (see section 10.1.1) is to allow a client that is sending a request message with a request body to determine if the origin server is willing to accept the request (based on the request headers) before the client sends the request body. In some cases, it might either be inappropriate or highly inefficient for the client to send the body if the server will reject the message without looking at the body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
100（続行）状態の目的は、オリジンサーバが要求を受け入れるかどうかを判断するためにリクエストボディに要求メッセージを送信しているクライアントを許可するようにされた（セクション10.1.1を参照してください）（リクエストヘッダに基づいて）クライアントがリクエストボディを送信する前に。サーバが身体を見ずにメッセージを拒否するかどうか、クライアントは身体を送信するためにいくつかのケースでは、それはどちらか不適切か、非常に非効率的であるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Requirements for HTTP/1.1 clients:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1クライアントの要件：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If a client will wait for a 100 (Continue) response before sending the request body, it MUST send an Expect request-header field (section 14.20) with the &#34;100-continue&#34; expectation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - クライアントがリクエストボディを送信する前に100（続行）応答を待機する場合は、「100-継続」を期待して期待リクエストヘッダフィールド（セクション14.20）を送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A client MUST NOT send an Expect request-header field (section 14.20) with the &#34;100-continue&#34; expectation if it does not intend to send a request body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - それはリクエストボディを送信することを意図していない場合、クライアントは「100続行」期待していリクエストヘッダフィールド（セクション14.20）を送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because of the presence of older implementations, the protocol allows ambiguous situations in which a client may send &#34;Expect: 100- continue&#34; without receiving either a 417 (Expectation Failed) status or a 100 (Continue) status. Therefore, when a client sends this header field to an origin server (possibly via a proxy) from which it has never seen a 100 (Continue) status, the client SHOULD NOT wait for an indefinite period before sending the request body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
417（期待は失敗）ステータスまたは100（続行）状態のいずれかを受信することなく、次の理由古い実装が存在する、プロトコルは、クライアントが「100-継続期待」送信できる、あいまいな状況を可能にします。クライアントが100（続行）の状態を見たことがなかったから、（おそらくプロキシ経由）オリジンサーバに、このヘッダフィールドを送信したときしたがって、クライアントがリクエストボディを送信する前に無期限に待つべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Requirements for HTTP/1.1 origin servers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1オリジンサーバの要件：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Upon receiving a request which includes an Expect request-header field with the &#34;100-continue&#34; expectation, an origin server MUST either respond with 100 (Continue) status and continue to read from the input stream, or respond with a final status code. The origin server MUST NOT wait for the request body before sending the 100 (Continue) response. If it responds with a final status code, it MAY close the transport connection or it MAY continue to read and discard the rest of the request. It MUST NOT perform the requested method if it returns a final status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 「100続行」期待していリクエストヘッダフィールドを含むリクエストを受信すると、オリジンサーバ100（続行）の状態で応答し、入力ストリームから読み込む、または最終状態コードで応答し続けなければならないのいずれかで。オリジンサーバは100（続行）応答を送信する前に、リクエストボディを待つてはなりません。それは、最終的なステータスコードで応答した場合、それはトランスポート接続を閉じたり、それが読み込まれ、要求の残りの部分を破棄し続けることができます。それは、最終的なステータスコードを返した場合には要求されたメソッドを実行してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- An origin server SHOULD NOT send a 100 (Continue) response if the request message does not include an Expect request-header field with the &#34;100-continue&#34; expectation, and MUST NOT send a 100 (Continue) response if such a request comes from an HTTP/1.0 (or earlier) client. There is an exception to this rule: for compatibility with RFC 2068, a server MAY send a 100 (Continue) status in response to an HTTP/1.1 PUT or POST request that does not include an Expect request-header field with the &#34;100- continue&#34; expectation. This exception, the purpose of which is to minimize any client processing delays associated with an undeclared wait for 100 (Continue) status, applies only to HTTP/1.1 requests, and not to requests with any other HTTP-version value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - オリジンサーバは、要求メッセージは、「100-継続」を期待して期待リクエストヘッダフィールドが含まれていない場合は100（続行）応答を送るべきではありませんし、そのような要求が来た場合に100（続行）応答を送ってはいけませんHTTP / 1.0（またはそれ以前）のクライアントから。この規則の例外があります：RFC 2068との互換性のために、サーバは「100-と期待リクエストヘッダフィールドが含まれていないHTTP / 1.1 PUTやPOSTリクエストに応じて、100（続行）のステータスを送信することができ「期待を続けます。この例外は、100（続行）ステータスを宣言されていない待機に関連付けられている任意のクライアント処理遅延を最小化することでその目的は、唯一のHTTP / 1.1リクエストにではなく、他のHTTP-バージョン値とのリクエストに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- An origin server MAY omit a 100 (Continue) response if it has already received some or all of the request body for the corresponding request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - それは、すでに対応する要求のためのリクエストボディの一部または全部を受信した場合、オリジンサーバは100（続行）応答を省略することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- An origin server that sends a 100 (Continue) response MUST ultimately send a final status code, once the request body is received and processed, unless it terminates the transport connection prematurely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 要求本体が受信され処理されると、それが途中でトランスポート接続を終了しない限り、100を送信オリジンサーバ（続行）応答は、最終的に、最終的なステータスコードを送信しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If an origin server receives a request that does not include an Expect request-header field with the &#34;100-continue&#34; expectation, the request includes a request body, and the server responds with a final status code before reading the entire request body from the transport connection, then the server SHOULD NOT close the transport connection until it has read the entire request, or until the client closes the connection. Otherwise, the client might not reliably receive the response message. However, this requirement is not be construed as preventing a server from defending itself against denial-of-service attacks, or from badly broken client implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - オリジンサーバが「100続行」期待していリクエスト・ヘッダー・フィールドが含まれていない要求を受信した場合、要求は、要求本体を含み、そしてサーバから全体の要求本体を読み取る前に、最終的なステータス・コードで応答それは全体の要求を読んだまで、トランスポート接続は、サーバーはトランスポート接続をクローズすべきではない、またはクライアントが接続を閉じるまで。そうでない場合、クライアントは確実に応答メッセージを受信しないことがあります。しかし、この要件は、サービス拒否攻撃から自身を守るから、またはひどく破損クライアント実装からサーバーを防止するように解釈されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Requirements for HTTP/1.1 proxies:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1プロキシの要件：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If a proxy receives a request that includes an Expect request-header field with the &#34;100-continue&#34; expectation, and the proxy either knows that the next-hop server complies with HTTP/1.1 or higher, or does not know the HTTP version of the next-hop server, it MUST forward the request, including the Expect header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プロキシは、「100続行」期待していリクエストヘッダフィールドを含むリクエストを受信すると、プロキシのいずれかネクストホップサーバがHTTP / 1.1以上に準拠していることを知っている、またはHTTPのバージョンがわからない場合ネクストホップサーバ、それが期待ヘッダフィールドを含む、要求を転送しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If the proxy knows that the version of the next-hop server is HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST respond with a 417 (Expectation Failed) status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プロキシがネクストホップサーバのバージョンはHTTP / 1.0以下であることを知っている場合は、その要求を転送してはならない、それは417（期待に失敗しました）状態で応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Proxies SHOULD maintain a cache recording the HTTP version numbers received from recently-referenced next-hop servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プロキシは、最近参照ネクストホップサーバから受信したHTTPのバージョン番号を記録するキャッシュを維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A proxy MUST NOT forward a 100 (Continue) response if the request message was received from an HTTP/1.0 (or earlier) client and did not include an Expect request-header field with the &#34;100-continue&#34; expectation. This requirement overrides the general rule for forwarding of 1xx responses (see section 10.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 要求メッセージがHTTP / 1.0（またはそれ以前）クライアントから受信し、「100-継続」期待してリクエストヘッダフィールドを期待含まれていない場合、プロキシは100（続行）応答を転送してはいけません。この要件は、の1xx応答（セクション10.1を参照）の転送のための一般的なルールを上書き。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.4 Client Behavior if Server Prematurely Closes Connection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
サーバーが途中で接続をクローズする場合は8.2.4クライアントの動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an HTTP/1.1 client sends a request which includes a request body, but which does not include an Expect request-header field with the &#34;100-continue&#34; expectation, and if the client is not directly connected to an HTTP/1.1 origin server, and if the client sees the connection close before receiving any status from the server, the client SHOULD retry the request. If the client does retry this request, it MAY use the following &#34;binary exponential backoff&#34; algorithm to be assured of obtaining a reliable response:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1クライアントは、要求本体を含む要求を送信するが、これは「100続行」期待していリクエスト・ヘッダー・フィールドが含まれていない、及びクライアントが直接HTTP / 1.1オリジンサーバに接続されていない場合場合クライアントがサーバーから任意のステータスを受け取る前に密接な関係を見た場合、および、クライアントが要求を再試行する必要があります。クライアントがこの要求を再試行しない場合、それは信頼性の高いレスポンスを得る保証するために、以下の「バイナリ指数バックオフ」のアルゴリズムを使用することがあります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Initiate a new connection to the server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.サーバーへの新しい接続を開始
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Transmit the request-headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.リクエストヘッダを送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Initialize a variable R to the estimated round-trip time to the server (e.g., based on the time it took to establish the connection), or to a constant value of 5 seconds if the round-trip time is not available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
往復時間が利用できない場合3.サーバへの推定ラウンドトリップ時間（例えば、それが接続を確立するのに要した時間に基づいて）、または5秒の一定値に変数Rを初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Compute T = R * (2**N), where N is the number of previous retries of this request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nは、この要求の前の再試行の回数である。4.計算T = R *（2 ** N）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. Wait either for an error response from the server, or for T seconds (whichever comes first)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.（いずれか早い方）のいずれかのサーバからエラー応答のために、又はT秒待ち
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. If no error response is received, after T seconds transmit the body of the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6.エラー応答が受信されない場合、T秒は、要求の本体を送信した後。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. If client sees that the connection is closed prematurely, repeat from step 1 until the request is accepted, an error response is received, or the user becomes impatient and terminates the retry process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、接続要求が受け付けられるまで、ステップ1から繰り返す、早期閉鎖されていることを認識した場合7.、エラー応答が受信されるか、またはユーザがせっかちになり、リトライ処理を終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If at any point an error status is received, the client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれかの時点でエラーステータスが受信された場合、クライアント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- SHOULD NOT continue and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 継続すべきではなく、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- SHOULD close the connection if it has not completed sending the request message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - それは要求メッセージを送信完了していない場合、接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
9 Method Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
9つのメソッド定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The set of common methods for HTTP/1.1 is defined below. Although this set can be expanded, additional methods cannot be assumed to share the same semantics for separately extended clients and servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1のための一般的な方法のセットが以下に定義されます。このセットを拡張することができますが、追加の方法は、個別に拡張クライアントとサーバで同じ意味を共有すると仮定することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Host request-header field (section 14.23) MUST accompany all HTTP/1.1 requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストリクエストヘッダフィールド（セクション14.23）は、すべてのHTTP / 1.1リクエストを添付しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1 Safe and Idempotent Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1安全でべき等のメソッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1 Safe Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1安全な方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementors should be aware that the software represents the user in their interactions over the Internet, and should be careful to allow the user to be aware of any actions they might take which may have an unexpected significance to themselves or others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装者は、ソフトウェアがインターネット上でそれらの相互作用でユーザーを表していることに注意する必要があり、ユーザーが自分自身や他人への予期せぬ意義を有していてもよく、彼らがかかる場合があります任意のアクションを認識することができるように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval. These methods ought to be considered &#34;safe&#34;. This allows user agents to represent other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特に、規則はGETとHEADメソッドは、検索以外の行動を取るの重要性を持つべきではないことが確立されてきました。これらのメソッドは「安全」とみなされるべきです。これは、ユーザエージェントは、例えばPOSTなどの他の方法を表すユーザはおそらく安全でないアクションが要求されているという事実を認識させられるように、特別な方法で、入れて削除することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Naturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a GET request; in fact, some dynamic resources consider that a feature. The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
当然、サーバがGET要求を実行した結果として副作用を生成しないことを保証することは不可能です。実際には、いくつかの動的なリソースが機能することを検討してください。ここでの重要な違いは、ユーザが副作用を要求しなかったので、したがって、彼らのために責任を負うことはできないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.2 Idempotent Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.2べき等のメソッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Methods can also have the property of &#34;idempotence&#34; in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request. The methods GET, HEAD, PUT and DELETE share this property. Also, the methods OPTIONS and TRACE SHOULD NOT have side effects, and so are inherently idempotent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
方法は、N&gt; 0の同一の要求の副作用が単一のリクエストと同じである（余談エラーまたは有効期限の問題から）という点で、「冪等性」の性質を有することができます。メソッドはGET、HEADは、PUTと共有して、このプロパティを削除します。また、メソッドのOPTIONSとTRACEは副作用を持つべきではない、ので、本質的に冪等です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, it is possible that a sequence of several requests is non-idempotent, even if all of the methods executed in that sequence are idempotent. (A sequence is idempotent if a single execution of the entire sequence always yields a result that is not changed by a reexecution of all, or part, of that sequence.) For example, a sequence is non-idempotent if its result depends on a value that is later modified in the same sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、いくつかの要求の順序は、その順序で実行されたメソッドのすべてが冪等であっても、非冪等であることも可能です。 （シーケンス全体の単一の実行が常にその配列の、全ての再実行、または一部によって変更されないという結果をもたらす場合シーケンスが冪等である。）その結果に依存する場合、例えば、配列が非冪等であります後で同じ順序で変更された値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A sequence that never has side effects is idempotent, by definition (provided that no concurrent operations are being executed on the same set of resources).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
副作用を持っていませんシーケンスは、定義（何の同時操作は、リソースの同じセット上で実行されていないことを提供する）、冪等です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2 OPTIONS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2 OPTIONS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI. This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPTIONSメソッドは、Request-URIによって識別される要求/応答チェーン上の利用可能な通信オプションについての情報の要求を表します。このメソッドは、リソースアクションを暗示するか、リソース検索を開始することなく、クライアントはオプションおよび/またはリソースに関連する要件、またはサーバーの能力を決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Responses to this method are not cacheable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメソッドのレスポンスはキャッシュ可能ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the OPTIONS request includes an entity-body (as indicated by the presence of Content-Length or Transfer-Encoding), then the media type MUST be indicated by a Content-Type field. Although this specification does not define any use for such a body, future extensions to HTTP might use the OPTIONS body to make more detailed queries on the server. A server that does not support such an extension MAY discard the request body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPTIONS要求は、エンティティボディを（コンテンツ長や転送エンコードの存在によって示されるように）含まれている場合、メディアタイプは、Content-Typeフィールドによって示さなければなりません。この仕様は、このような身体のための任意の使用を定義していませんが、HTTPの将来の拡張では、サーバー上のより詳細なクエリを作成するためにOPTIONS本体を使用する場合があります。そのような拡張機能をサポートしていないサーバがリクエストボディを捨てるかもしれ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the Request-URI is an asterisk (&#34;*&#34;), the OPTIONS request is intended to apply to the server in general rather than to a specific resource. Since a server&#39;s communication options typically depend on the resource, the &#34;*&#34; request is only useful as a &#34;ping&#34; or &#34;no-op&#34; type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 compliance (or lack thereof).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエスト-URIがアスタリスク（「*」）である場合は、OPTIONS要求は、一般的にではなく、特定のリソースへのサーバーに適用されるものとします。サーバの通信オプションは、典型的には、リソースに依存するので、「*」要求は、メソッドの「ピング」または「ノーオペレーション」タイプとしてのみ有用です。それは、クライアントがサーバの機能をテストすることができますを超えて何もしません。例えば、これはHTTP / 1.1コンプライアンス（またはその欠如）のプロキシをテストするために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the Request-URI is not an asterisk, the OPTIONS request applies only to the options that are available when communicating with that resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエスト-URIがアスタリスクでない場合は、OPTIONSリクエストはそのリソースと通信するときに利用可能なオプションにのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A 200 response SHOULD include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g., Allow), possibly including extensions not defined by this specification. The response body, if any, SHOULD also include information about the communication options. The format for such a body is not defined by this specification, but might be defined by future extensions to HTTP. Content negotiation MAY be used to select the appropriate response format. If no response body is included, the response MUST include a Content-Length field with a field-value of &#34;0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
200応答は、おそらくこの仕様で定義されていない拡張を含む、サーバとそのリソースに適用（例えば、許可）によって実装オプション機能を示す任意のヘッダフィールドを含むべきです。レスポンスボディは、いかなる場合も、通信オプションについての情報を含むべきです。そのようなボディのための形式は、この仕様で定義されていませんが、HTTPの将来の拡張によって定義される可能性があります。コンテンツネゴシエーションは適切な応答形式を選択するために使用されるかもしれません。何のレスポンスボディが含まれていない場合、応答が「0」のフィールド値でのContent-Lengthフィールドを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Max-Forwards request-header field MAY be used to target a specific proxy in the request chain. When a proxy receives an OPTIONS request on an absoluteURI for which request forwarding is permitted, the proxy MUST check for a Max-Forwards field. If the Max-Forwards field-value is zero (&#34;0&#34;), the proxy MUST NOT forward the message; instead, the proxy SHOULD respond with its own communication options. If the Max-Forwards field-value is an integer greater than zero, the proxy MUST decrement the field-value when it forwards the request. If no Max-Forwards field is present in the request, then the forwarded request MUST NOT include a Max-Forwards field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マックスを転送リクエストヘッダフィールドは、要求チェーン内の特定のプロキシを標的化するために使用されるかもしれません。プロキシは、要求の転送を許可するためにabsoluteURIでOPTIONS要求を受信すると、プロキシは、最大転送しフィールドをチェックしなければなりません。最大転送し、フィールド値がゼロ（「0」）である場合、プロキシはメッセージを転送してはいけません。代わりに、プロキシは、独自の通信オプションを使用して応答する必要があります。最大転送し、フィールド値がゼロよりも大きい整数である場合、それは要求を転送するとき、プロキシは、フィールドの値をデクリメントしなければなりません。何のマックス・フォワードフィールドがリクエストに存在しない場合は、転送された要求は、マックス・フォワード分野を含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3 GET
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3 GET
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETメソッドは、Request-URIによって識別されるどんな情報（エンティティの形で）を取得します。リクエストURIがデータ生成プロセスを指す場合、そのテキストがプロセスの出力であることを起こる場合を除き、それは、生成された応答内のエンティティとして返さなければならないデータはなく、プロセスのソーステキストです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The semantics of the GET method change to a &#34;conditional GET&#34; if the request message includes an If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field. A conditional GET method requests that the entity be transferred only under the circumstances described by the conditional header field(s). The conditional GET method is intended to reduce unnecessary network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring data already held by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求メッセージは、もし修飾-ので、場合非改変-ので、場合マッチ、なし、マッチした場合、または場合-Rangeヘッダフィールドを含む場合、「条件付きGET」にGETメソッド変化の意味論。条件付きGETメソッドは、エンティティが唯一の条件付きヘッダフィールド（複数可）に記載状況下で転送されることを要求します。条件付きGETメソッドは、キャッシュされたエンティティが複数の要求を必要とするか、すでにクライアントが保持するデータを転送せずにリフレッシュすることができるようにすることで、不要なネットワークの使用量を低減することを目的とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The semantics of the GET method change to a &#34;partial GET&#34; if the request message includes a Range header field. A partial GET requests that only part of the entity be transferred, as described in section 14.35. The partial GET method is intended to reduce unnecessary network usage by allowing partially-retrieved entities to be completed without transferring data already held by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求メッセージがRangeヘッダフィールドを含む場合に「部分GET」にGETメソッド変化の意味論。セクション14.35に記載されているように、エンティティの一部のみが、転送すべき部分GETリクエスト。部分的GETメソッドは、部分的に取り出されたエンティティはすでにクライアントが保持しているデータを転送せずに完了することができるようにすることで、不要なネットワークの使用量を低減することを目的とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The response to a GET request is cacheable if and only if it meets the requirements for HTTP caching described in section 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET要求に対する応答がキャッシュ可能な場合であり、それはセクション13で説明したHTTPキャッシングのための要件を満たしている場合のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See section 15.1.3 for security considerations when used for forms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フォームで使用する場合、セキュリティの考慮事項についてはセクション15.1.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4 HEAD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4 HEAD
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. This method is often used for testing hypertext links for validity, accessibility, and recent modification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HEADメソッドは、サーバが応答でメッセージボディを返してはならないことを除いて取得することと同じです。 HEADリクエストに応答して、HTTPヘッダに含まれるメタ情報は、GET要求に応答して送信された情報と同一であるべきです。この方法は、エンティティボディ自体を転送することなく要求によって暗示エンティティに関するメタ情報を取得するために使用することができます。この方法は、多くの場合、妥当性、アクセシビリティ、および最近の変更のためのハイパーテキストリンクをテストするために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The response to a HEAD request MAY be cacheable in the sense that the information contained in the response MAY be used to update a previously cached entity from that resource. If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), then the cache MUST treat the cache entry as stale.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HEAD要求に対する応答は、応答に含まれる情報は、そのリソースから、以前にキャッシュされたエンティティを更新するために使用され得るという意味でキャッシュ可能であるかもしれ。新しいフィールド値がキャッシュされたエンティティが現在のエンティティ（コンテンツ長の変化によって示されることになるよう、コンテンツ-MD5、ETagのかのLast-Modified）とは異なることを示している場合は、キャッシュが古いとキャッシュエントリを扱わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5 POST
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5 POST
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line. POST is designed to allow a uniform method to cover the following functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
POSTメソッドは、オリジンサーバがリクエストライン中のRequest-URIによって識別されるリソースの新しい従属として、リクエストに囲まれたエンティティを受け入れることを要求するために使用されます。 POSTは、以下の機能をカバーする均一な方法を可能にするように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Annotation of existing resources;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 既存のリソースの注釈。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 掲示板、ニュースグループ、メーリングリスト、または物品の類似のグループにメッセージを投稿。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Providing a block of data, such as the result of submitting a form, to a data-handling process;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - そのようなデータ処理プロセスに、フォームを送信した結果として、データのブロックを提供するステップと
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Extending a database through an append operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 追加操作を介してデータベースを拡張します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
POSTメソッドによって実行される実際の機能はサーバによって決定され、通常のRequest-URIに依存しています。掲載実体がファイルがそれを含むディレクトリに従属するのと同じ方法で、そのURIに従属する、ニュース記事は、それが掲載されているニュースグループに従属し、またはレコードがデータベースに従属します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
POSTメソッドによって実行されるアクションは、URIで識別できるリソースにつながるしない場合があります。この場合には、200（OK）または204（いいえコンテンツ）のいずれかが応答結果を記述するエンティティが含まれているか否かに応じて、適切な応答状態です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header (see section 14.30).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リソースがオリジンサーバ上に作成されている場合、応答は201（作成される）であると（セクション14.30を参照）要求のステータスを説明し、新たなリソースを指すエンティティ、およびLocationヘッダを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields. However, the 303 (See Other) response can be used to direct the user agent to retrieve a cacheable resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答が適切なキャッシュ・コントロールを含むまたはヘッダーフィールドを有効期限がない限り、このメソッドへの応答は、キャッシュ可能ではありません。しかし、303（参照その他）レスポンスはキャッシュ可能なリソースを取得するためにユーザーエージェントを指示するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
POST requests MUST obey the message transmission requirements set out in section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
POSTリクエストは、セクション8.2に記載されたメッセージの伝送要件に従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See section 15.1.3 for security considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティ上の考慮事項についてはセクション15.1.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6 PUT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6 PUT
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem. The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTメソッドは、囲まれたエンティティが供給されるのRequest-URIの下に格納されることを要求します。リクエストURIがすでに既存のリソースを参照する場合、囲まれたエンティティはオリジンサーバ上に存在する一方の変更バージョンとして考慮されるべきです。リクエスト-URIが既存のリソースを指していない、とURIが要求するユーザエージェントによって新しいリソースとして定義されることが可能であるとした場合、オリジンサーバはそのURIを持つリソースを作成することができます。新しいリソースが作成された場合、オリジンサーバは201（作成された）応答を介してユーザエージェントを通知しなければなりません。既存のリソースは、200（OK）または204のいずれかが変更された場合（NOコンテンツ）応答コードは、要求が正常に完了したことを示すために送信されるべきではありません。リソースが作成されたかのRequest-URIを変更することができなかった場合は、適切なエラー応答は、問題の性質を反映している与えられるべきです。エンティティの受信者は、それが理解したり実装し、このような場合には501（未実装）応答を返さなければなりませんしませんどんなのContent *（例えばコンテンツレンジ）ヘッダを無視してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求がキャッシュを通過し、要求URIが一つ以上の現在キャッシュされたエンティティを識別した場合、それらのエントリが古くなったとして扱われるべきです。このメソッドのレスポンスはキャッシュ可能ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI, it MUST send a 301 (Moved Permanently) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
POST及びPUT要求との間の根本的な違いは、リクエストURIの別の意味に反映されます。 POSTリクエストにおけるURIは同封の実体を処理するリソースを識別する。そのリソースは、データ受付処理、いくつかの他のプロトコル、または注釈を受け入れる別のエンティティへのゲートウェイであるかもしれません。これとは対照的に、PUT要求におけるURIは、要求に囲まれたエンティティを識別する - ユーザエージェントは、URIが意図されているものを知っていると、サーバは、いくつかの他のリソースへの要求を適用することを試みてはいけません。サーバが要求を異なるURIに適用されることを望む場合、それは、301（恒久的に移動）応答を送信しなければなりません。ユーザエージェントはその要求をリダイレクトするかどうかについて、独自の意思決定を行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A single resource MAY be identified by many different URIs. For example, an article might have a URI for identifying &#34;the current version&#34; which is separate from the URI identifying each particular version. In this case, a PUT request on a general URI might result in several other URIs being defined by the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一のリソースは、さまざまなURIによって識別することができます。例えば、物品は、それぞれの特定のバージョンを識別するURIから分離されている「現在のバージョン」を識別するためのURIを持っているかもしれません。この場合、一般的なURIにPUTリクエストはオリジンサーバによって定義されている他のいくつかのURIになる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 does not define how a PUT method affects the state of an origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は、PUTメソッドがオリジンサーバの状態をどのように影響するかを定義していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUT requests MUST obey the message transmission requirements set out in section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTリクエストは、セクション8.2に記載されたメッセージの伝送要件に従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request SHOULD be applied to the resource created or modified by the PUT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうでなければ特定のエンティティヘッダに指定されない限り、PUT要求内のエンティティヘッダはPUTによって作成または変更されたリソースに適用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7 DELETE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7 DELETE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server. The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DELETEメソッドは、オリジンサーバがRequest-URIによって識別されるリソースを削除するよう要求します。このメソッドは、オリジンサーバ上の人間の介入（または他の手段）によって上書きされることがあります。クライアントは、オリジンサーバから返されたステータスコードはアクションが正常に完了したことを示していても、操作が行われていることを保証するものではありません。しかし、サーバが応答が与えられた時点で、それはリソースを削除したりアクセスできない場所に移動する予定で、しない限り、成功を示すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) if the action has been enacted but the response does not include an entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功した応答は、応答のステータスを記述するエンティティを含む場合、アクションが制定されている場合、202（承認）アクションがまだ制定ないれていない場合、または204（コンテンツなし）200（OK）であるべきであるが、応答が含まれていませんエンティティ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求がキャッシュを通過し、要求URIが一つ以上の現在キャッシュされたエンティティを識別した場合、それらのエントリが古くなったとして扱われるべきです。このメソッドのレスポンスはキャッシュ可能ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8 TRACE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8 TRACE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TRACE method is used to invoke a remote, application-layer loop-back of the request message. The final recipient of the request SHOULD reflect the message received back to the client as the entity-body of a 200 (OK) response. The final recipient is either the origin server or the first proxy or gateway to receive a Max-Forwards value of zero (0) in the request (see section 14.31). A TRACE request MUST NOT include an entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRACEメソッドは、要求メッセージのリモート、アプリケーション層のループバックを呼び出すために使用されます。リクエストの最終的な受信者は、200（OK）応答のエンティティボディとしてクライアントに受信したメッセージを反映すべきです。最終受信者は、オリジンサーバまたは要求にゼロの最大転送した値を受信する最初のプロキシまたはゲートウェイ（0）（セクション14.31を参照）のいずれかです。 TRACE要求は実体を含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the Via header field (section 14.45) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRACEは、クライアントが要求チェーンの他方の端部に受信されているかを確認し、テストまたは診断情報のためにそのデータを使用することを可能にします。それは、要求チェーンのトレースとして作用するためのViaヘッダフィールド（セクション14.45）の値は、特に重要です。最大Forwardsヘッダーフィールドの使用は、クライアントが無限ループにメッセージを転送するプロキシの鎖を試験するために有用である要求鎖の長さを制限することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of &#34;message/http&#34;. Responses to this method MUST NOT be cached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求が有効である場合は、応答が「メッセージ/ HTTP」のコンテンツタイプと、エンティティボディ全体要求メッセージを含むべきです。このメソッドへの応答はキャッシュされてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9 CONNECT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9 CONNECT
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification reserves the method name CONNECT for use with a proxy that can dynamically switch to being a tunnel (e.g. SSL tunneling [44]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様は、動的トンネル（例えば、SSLトンネリング[44]）であることに切り替えることができ、プロキシで使用するためのメソッド名CONNECTを留保します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
10 Status Code Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
10のステータスコードの定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each Status-Code is described below, including a description of which method(s) it can follow and any metainformation required in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ステータスコードは、メソッド（複数可）が従うことができると応答して必要なメタ情報の記述を含む、以下に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1 Informational 1xx
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1情報の1xx
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This class of status code indicates a provisional response, consisting only of the Status-Line and optional headers, and is terminated by an empty line. There are no required headers for this class of status code. Since HTTP/1.0 did not define any 1xx status codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client except under experimental conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータスコードのこのクラスは、ステータスラインとオプションヘッダから成る、暫定的な応答を示し、空行で終了します。ステータスコードのこのクラスには、必要なヘッダはありません。 HTTP / 1.0はどんなの1xxステータスコードを定義していませんでしたので、サーバーは、実験条件の下で除き、HTTP / 1.0クライアントへの1xxレスポンスを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client MUST be prepared to accept one or more 1xx status responses prior to a regular response, even if the client does not expect a 100 (Continue) status message. Unexpected 1xx status responses MAY be ignored by a user agent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、クライアントが100（続行）ステータスメッセージを期待していない場合でも、定期的に応答する前に、一の以上の1xx状態応答を受け入れるように準備しなければなりません。予期しないの1xxステータス応答は、ユーザエージェントによって無視されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxies MUST forward 1xx responses, unless the connection between the proxy and its client has been closed, or unless the proxy itself requested the generation of the 1xx response. (For example, if a proxy adds a &#34;Expect: 100-continue&#34; field when it forwards a request, then it need not forward the corresponding 100 (Continue) response(s).)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシとそのクライアント間の接続が閉じられた場合を除き、またはプロキシ自体がの1xx応答の生成を要求した場合を除きます。プロキシは、の1xx応答を転送しなければなりません（プロキシが追加した場合たとえば、「期待：100-続ける」フィールドには、要求を転送するとき、それは、対応する100（続行）応答（複数可）を転送する必要はありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1.1 100 Continue
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1.1 100は続行します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client SHOULD continue with its request. This interim response is used to inform the client that the initial part of the request has been received and has not yet been rejected by the server. The client SHOULD continue by sending the remainder of the request or, if the request has already been completed, ignore this response. The server MUST send a final response after the request has been completed. See section 8.2.3 for detailed discussion of the use and handling of this status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは要求を継続する必要があり。この暫定応答は、要求の最初の部分が受信されていて、まだサーバーによって拒否されていないクライアントに通知するために使用されています。クライアントは、要求の残りを送信することにより続行するか、要求がすでに完了している場合は、この応答を無視します。要求が完了した後、サーバーは最終的な応答を送らなければなりません。このステータスコードの使用や取扱いの詳細な議論のためのセクション8.2.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1.2 101 Switching Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1.2 101スイッチングプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server understands and is willing to comply with the client&#39;s request, via the Upgrade message header field (section 14.42), for a change in the application protocol being used on this connection. The server will switch protocols to those defined by the response&#39;s Upgrade header field immediately after the empty line which terminates the 101 response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは理解し、この接続で使用されているアプリケーション・プロトコルの変化のために、アップグレードメッセージヘッダフィールド（セクション14.42）を介して、クライアントの要求を遵守する意志があります。サーバーは、すぐに101レスポンスを終了空行の後にレスポンスのUpgradeヘッダフィールドによって定義されたものにプロトコルを切り替えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The protocol SHOULD be switched only when it is advantageous to do so. For example, switching to a newer version of HTTP is advantageous over older versions, and switching to a real-time, synchronous protocol might be advantageous when delivering resources that use such features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうすることが有利である場合にのみ、プロトコルは、切り替えるべき。例えば、HTTPの新しいバージョンへの切り替えは、旧バージョンよりも有利であり、そのような機能を使用するリソースを配信する際にリアルタイムに切り替えることは、同期プロトコルが有利かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2 Successful 2xx
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2成功2XX
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This class of status code indicates that the client&#39;s request was successfully received, understood, and accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このクラスのステータスコードは、クライアントの要求が正常に受信されたことを示して理解し、受け入れられました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.1 200 OK
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.1 200 OK
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The request has succeeded. The information returned with the response is dependent on the method used in the request, for example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストが成功しました。応答で返された情報は、例えば、要求に使用される方法に依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET an entity corresponding to the requested resource is sent in the response;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答して送信される要求されたリソースに対応するエンティティを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HEAD the entity-header fields corresponding to the requested resource are sent in the response without any message-body;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求されたリソースに対応するエンティティヘッダフィールドは、任意のメッセージボディなしに応答して送信されているヘッド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
POST an entity describing or containing the result of the action;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
記述またはアクションの結果を含むエンティティをPOST。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRACE an entity containing the request message as received by the end server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンド・サーバによって受信されるよう要求メッセージを含むエンティティをトレース。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.2 201 Created
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.2 201初出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The request has been fulfilled and resulted in a new resource being created. The newly created resource can be referenced by the URI(s) returned in the entity of the response, with the most specific URI for the resource given by a Location header field. The response SHOULD include an entity containing a list of resource characteristics and location(s) from which the user or user agent can choose the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. The origin server MUST create the resource before returning the 201 status code. If the action cannot be carried out immediately, the server SHOULD respond with 202 (Accepted) response instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求が満たされ、新しいリソースが作成されているが生じてきました。新しく作成されたリソースは、URI（S）で参照することができるLocationヘッダフィールドで指定されたリソースのための最も特異的なURIと、応答のエンティティに返されます。応答は、ユーザーまたはユーザーエージェントが最も適切なものを選択することができ、そこからリソース特性および位置（単数または複数）のリストを含むエンティティを含むべきです。エンティティフォーマットはContent-Typeヘッダフィールドで指定されたメディアタイプによって指定されます。オリジンサーバは201のステータスコードを返す前にリソースを作成する必要があります。アクションがすぐに実行できない場合、サーバは代わりに202（受理）応答で応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A 201 response MAY contain an ETag response header field indicating the current value of the entity tag for the requested variant just created, see section 14.19.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
201応答は、セクション14.19を参照して、先ほど作成した要求されたバリアントのエンティティタグの現在の値を示すのETagレスポンスヘッダフィールドを含むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.3 202 Accepted
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.3 202受理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place. There is no facility for re-sending a status code from an asynchronous operation such as this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストが処理のために受け入れられているが、処理は完了していません。処理が実際に行われるとき、それは禁止されるかもしれないよう要求がまたは最終的には、作用されない場合があります。このような非同期動作からステータスコードを再送信するための機能はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 202 response is intentionally non-committal. Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent&#39;s connection to the server persist until the process is completed. The entity returned with this response SHOULD include an indication of the request&#39;s current status and either a pointer to a status monitor or some estimate of when the user can expect the request to be fulfilled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
202応答は、意図的に非コミットです。その目的は、サーバプロセスが完了するまで、サーバへのユーザエージェントの接続が存続することを必要とせず、他のプロセス（だけ1日1回実行され、おそらくバッチ指向プロセス）の要求を受け入れることを可能にすることです。エンティティは、リクエストの現在のステータスの表示といずれかの状態モニタへのポインタか、ユーザーが要求が満たされることを期待することができたときにいくつかの推定値を含むべきである。この応答で返さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.4 203 Non-Authoritative Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.4 203非信頼できる情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The returned metainformation in the entity-header is not the definitive set as available from the origin server, but is gathered from a local or a third-party copy. The set presented MAY be a subset or superset of the original version. For example, including local annotation information about the resource might result in a superset of the metainformation known by the origin server. Use of this response code is not required and is only appropriate when the response would otherwise be 200 (OK).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティヘッダーに戻されるメタ情報は、オリジンサーバから入手可能な最終的なセットではなく、ローカルまたはサードパーティコピーから集められています。提示セットは元のバージョンのサブセットまたはスーパーセットである場合があります。たとえば、リソースについてなど、地元の注釈情報は、オリジンサーバによって知られているメタ情報のスーパーセットになる可能性があります。この応答コードの使用が必要と応答が他の200（OK）であろう場合にのみ適切であるれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.5 204 No Content
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.5 204コンテンツなし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation. The response MAY include new or updated metainformation in the form of entity-headers, which if present SHOULD be associated with the requested variant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは要求を満たしていますが、エンティティボディを返す必要はありません。また、更新されたメタ情報を返すようにしたいかもしれません。応答が存在する場合に要求された変異体と関連付けられるべきエンティティヘッダの形で新しいまたは更新されたメタ情報を含むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client is a user agent, it SHOULD NOT change its document view from that which caused the request to be sent. This response is primarily intended to allow input for actions to take place without causing a change to the user agent&#39;s active document view, although any new or updated metainformation SHOULD be applied to the document currently in the user agent&#39;s active view.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはユーザエージェントである場合、それは、要求が送信される原因となったことから、そのドキュメントのビューを変更しないでください。この応答は、主に、任意の新しいまたは更新されたメタ情報は、ユーザエージェントのアクティブなビューで、現在の文書に適用されるべきであるが、ユーザエージェントのアクティブドキュメントビューに変更を生じさせることなく、場所を取るべきアクションのための入力を可能にすることを意図しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 204 response MUST NOT include a message-body, and thus is always terminated by the first empty line after the header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
204応答は、メッセージボディを含めることはできませんので、常にヘッダフィールドの後の最初の空行で終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.6 205 Reset Content
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.6 205リセットコンテンツ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server has fulfilled the request and the user agent SHOULD reset the document view which caused the request to be sent. This response is primarily intended to allow input for actions to take place via user input, followed by a clearing of the form in which the input is given so that the user can easily initiate another input action. The response MUST NOT include an entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは要求を満たしており、ユーザーエージェントは、要求の送信元となったドキュメントビューをリセットする必要があります。この応答は、主にアクションをユーザが容易に別の入力動作を開始できるように、入力が与えられた形のクリアに続くユーザ入力を介して行われるようにするための入力を可能にするように意図されています。レスポンスはエンティティを含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.7 206 Partial Content
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.7 206部分コンテンツ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server has fulfilled the partial GET request for the resource. The request MUST have included a Range header field (section 14.35) indicating the desired range, and MAY have included an If-Range header field (section 14.27) to make the request conditional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはリソースに対する部分的GET要求を満たしています。要求は、所望の範囲を示すRangeヘッダフィールド（セクション14.35）を含んでいなければなりません、そして要求を条件付きにする場合-Rangeヘッダフィールド（セクション14.27）が含まれている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The response MUST include the following header fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答は、次ヘッダフィールドを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Either a Content-Range header field (section 14.16) indicating the range included with this response, or a multipart/byteranges Content-Type including Content-Range fields for each part. If a Content-Length header field is present in the response, its value MUST match the actual number of OCTETs transmitted in the message-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 各部分のコンテンツレンジフィールドを含むこの応答、またはマルチパート/ byterangesのContent-Typeに含ま範囲を示すいずれかのContent-Rangeヘッダフィールド（セクション14.16）。 Content-Lengthヘッダフィールドは、応答中に存在する場合、その値は、メッセージ本文に送信されたオクテットの実際の数と一致しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Date
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 日
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  Etag及び/又はコンテンツの場所、ヘッダが同じリクエストに対して200応答して送信されたかどう
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous response for the same variant
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - は、のCache-Controlの有効期限、および/またはフィールド値が同じバリアントに対する以前の応答で送信されたものと異なる可能性がある場合、ヴァリ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the 206 response is the result of an If-Range request that used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers. If the response is the result of an If-Range request that used a weak validator, the response MUST NOT include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers. Otherwise, the response MUST include all of the entity-headers that would have been returned with a 200 (OK) response to the same request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
206応答は、強いキャッシュバリデータを使用した場合、Range要求の結果である場合には（セクション13.3.3を参照）、応答は、他のエンティティヘッダを含むべきではありません。応答が弱いバリデータを使用した場合、Range要求の結果である場合、応答は、他のエンティティヘッダを含めることはできません。これは、キャッシュされたエンティティボディと更新ヘッダーの間の不整合を防ぐことができます。そうでなければ、応答は同じ要求に対して200（OK）応答で返されたであろうエンティティヘッダのすべてを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A cache MUST NOT combine a 206 response with other previously cached content if the ETag or Last-Modified headers do not match exactly, see 13.5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ETagまたはLast-Modifiedのヘッダが正確に一致しない場合、キャッシュは、他の以前にキャッシュされたコンテンツと206応答を組み合わせてはならない、13.5.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial) responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レンジとContent-レンジヘッダをサポートしていないキャッシュは206（部分的な）レスポンスをキャッシュしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3 Redirection 3xx
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3リダイレクション3XX
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request. The action required MAY be carried out by the user agent without interaction with the user if and only if the method used in the second request is GET or HEAD. A client SHOULD detect infinite redirection loops, since such loops generate network traffic for each redirection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータスコードのこのクラスは、さらにアクションが要求を満たすためにユーザエージェントによってとられる必要があることを示しています。そして第2の要求に使用される方法である場合にのみ、GETまたはHEAD場合に必要なアクションは、ユーザとの対話なしでユーザエージェントによって行うことができます。このようなループは、各リダイレクト用のネットワークトラフィックを生成するので、クライアントは、無限のリダイレクトループを検出する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: previous versions of this specification recommended a maximum of five redirections. Content developers should be aware that there might be clients that implement such a fixed limitation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：この仕様の以前のバージョンでは、5つのリダイレクトの最大推奨。コンテンツ開発者は、このような一定の制限を実装するクライアントがあるかもしれないことに注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.1 300 Multiple Choices
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.1 300複数の選択肢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requested resource corresponds to any one of a set of representations, each with its own specific location, and agent-driven negotiation information (section 12) is being provided so that the user (or user agent) can select a preferred representation and redirect its request to that location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザ（又はユーザエージェント）が好ましい表現を選択し、リダイレクトすることができるように要求されたリソースは、それ自身の特定の位置、及びエージェント駆動型ネゴシエーション情報（セクション12）とのそれぞれが提供されている表現の集合のいずれかに対応し、そのその場所への要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unless it was a HEAD request, the response SHOULD include an entity containing a list of resource characteristics and location(s) from which the user or user agent can choose the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically. However, this specification does not define any standard for such automatic selection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それがHEAD要求でない限り、反応は、ユーザーまたはユーザーエージェントが最も適切なものを選択することができ、そこからリソース特性および位置（単数または複数）のリストを含むエンティティを含むべきです。エンティティフォーマットはContent-Typeヘッダフィールドで指定されたメディアタイプによって指定されます。フォーマットやユーザエージェントの能力に応じて、最も適切な選択の選択が自動的に実行することができます。しかし、この仕様書は、そのような自動選択のための任意の標準を定義していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server has a preferred choice of representation, it SHOULD include the specific URI for that representation in the Location field; user agents MAY use the Location field value for automatic redirection. This response is cacheable unless indicated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが表現の好ましい選択肢を持っている場合、それはLocationフィールドでその表現のための特定のURIを含むべきです。ユーザエージェントは、自動リダイレクトのための場所]フィールド値を使用するかもしれません。特に指示がない限り、このレスポンスはキャッシュ可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.2 301 Moved Permanently
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.2 301が永久的に移動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requested resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs. Clients with link editing capabilities ought to automatically re-link references to the Request-URI to one or more of the new references returned by the server, where possible. This response is cacheable unless indicated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求されたリソースは新しい恒久的なURIが割り当てられており、このリソースへの将来の参照が返されたURIのいずれかを使用すべきです。リンク編集機能を持つクライアントは、可能であれば、サーバによって返された新しい参照の一つ以上へのRequest-URIへと自動的に再リンクが参照するべきです。特に指示がない限り、このレスポンスはキャッシュ可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The new permanent URI SHOULD be given by the Location field in the response. Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい恒久的なURIは、応答でLocationフィールドによって与えられるべきです。リクエストメソッドがHEADだった場合を除き、レスポンスのエンティティは新しいURIへのハイパーリンクで短いハイパーテキストのメモを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the 301 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
301のステータスコードがGETやHEAD以外の要求に応答して受信された場合、それをユーザが確認できない限り、この要求が発行された条件を変更する可能性があるため、ユーザエージェントは自動的に、要求をリダイレクトしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: When automatically redirecting a POST request after receiving a 301 status code, some existing HTTP/1.0 user agents will erroneously change it into a GET request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：自動的に301のステータスコードを受信した後、POSTリクエストをリダイレクトすると、いくつかの既存のHTTP / 1.0ユーザエージェントが誤ってGETリクエストにそれを変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.3 302 Found
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.3 302が見つかりました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requested resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the client SHOULD continue to use the Request-URI for future requests. This response is only cacheable if indicated by a Cache-Control or Expires header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求されたリソースが一時的に別のURIに存在します。リダイレクトが機会に変更される可能性があるため、クライアントは将来のリクエストのためのRequest-URIを使い続けるべきです。この応答は、キャッシュコントロールによって示される場合にのみキャッシュ可能であるか、Expiresヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The temporary URI SHOULD be given by the Location field in the response. Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一時的なURIは、レスポンス内のLocationフィールドによって与えられるべきです。リクエストメソッドがHEADだった場合を除き、レスポンスのエンティティは新しいURIへのハイパーリンクで短いハイパーテキストのメモを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the 302 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
302のステータスコードがGETやHEAD以外の要求に応答して受信された場合、それをユーザが確認できない限り、この要求が発行された条件を変更する可能性があるため、ユーザエージェントは自動的に、要求をリダイレクトしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: RFC 1945 and RFC 2068 specify that the client is not allowed to change the method on the redirected request. However, most existing user agent implementations treat 302 as if it were a 303 response, performing a GET on the Location field-value regardless of the original request method. The status codes 303 and 307 have been added for servers that wish to make unambiguously clear which kind of reaction is expected of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：RFC 1945およびRFC 2068は、クライアントがリダイレクトされたリクエストのメソッドを変更することが許可されていないことを指定します。それは関係なく、元の要求メソッドのLocationフィールド値にGETを行う、303応答であるかのようしかし、ほとんどの既存のユーザエージェントの実装302を扱います。ステータスコード303および307は、クライアントの期待されている反応の種類を明確に明らかにすることを希望するサーバーに対して追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.4 303 See Other
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.4 303を参照してくださいその他
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The response to the request can be found under a different URI and SHOULD be retrieved using a GET method on that resource. This method exists primarily to allow the output of a POST-activated script to redirect the user agent to a selected resource. The new URI is not a substitute reference for the originally requested resource. The 303 response MUST NOT be cached, but the response to the second (redirected) request might be cacheable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求に対する応答が、異なるURIの下に見つけることができ、そのリソース上のGETメソッドを使用して取得されるべきです。この方法は、選択されたリソースへのユーザエージェントをリダイレクトするPOST活性化スクリプトの出力を可能にするために主に存在します。新しいURIは、最初に要求されたリソースの代わりの参照ではありません。 303レスポンスはキャッシュされてはならないが、2番目の（リダイレクト）要求に対する応答がキャッシュ可能であるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The different URI SHOULD be given by the Location field in the response. Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別のURIは、レスポンス内のLocationフィールドによって与えられるべきです。リクエストメソッドがHEADだった場合を除き、レスポンスのエンティティは新しいURIへのハイパーリンクで短いハイパーテキストのメモを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：多くの事前HTTP / 1.1ユーザエージェントは303のステータスを理解していません。そのようなクライアントとの相互運用性が問題である場合303のためにここに記載したように、ほとんどのユーザエージェントは、302応答に反応するので、302のステータスコードが、代わりに使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.5 304 Not Modified
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.5 304は変更されません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client has performed a conditional GET request and access is allowed, but the document has not been modified, the server SHOULD respond with this status code. The 304 response MUST NOT contain a message-body, and thus is always terminated by the first empty line after the header fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが条件付きGETリクエストを実行し、アクセスが許可されていますが、文書が変更されていない場合、サーバーはこのステータスコードで応答する必要があります。 304応答は、メッセージ本体を含んではならないので、常にヘッダフィールドの後の最初の空行で終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The response MUST include the following header fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答は、次ヘッダフィールドを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Date, unless its omission is required by section 14.18.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 日付、その省略はセクション14.18.1で必要とされない限り、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a clockless origin server obeys these rules, and proxies and clients add their own Date to any response received without one (as already specified by [RFC 2068], section 14.19), caches will operate correctly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（すでに[RFC 2068]、セクション14.19で指定）クロックレスオリジンサーバは、これらの規則に従うと、プロキシとクライアントが1ずに受信したレスポンスに自分の日を追加した場合、キャッシュは正しく動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  Etag及び/又はコンテンツの場所、ヘッダが同じリクエストに対して200応答して送信されたかどう
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous response for the same variant
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - は、のCache-Controlの有効期限、および/またはフィールド値が同じバリアントに対する以前の応答で送信されたものと異なる可能性がある場合、ヴァリ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the conditional GET used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers. Otherwise (i.e., the conditional GET used a weak validator), the response MUST NOT include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
条件付きGETが（セクション13.3.3を参照してください）強いキャッシュバリデータを使用した場合、レスポンスは他のエンティティヘッダを含めるべきではありません。そうでない場合（すなわち、条件付きGETが弱いバリデータを使用）、応答は、他のエンティティヘッダを含めることはできません。これは、キャッシュされたエンティティボディと更新ヘッダーの間の不整合を防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a 304 response indicates an entity not currently cached, then the cache MUST disregard the response and repeat the request without the conditional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
304レスポンスが現在キャッシュされていないエンティティを示している場合は、キャッシュはレスポンスを無視し、条件なしで要求を繰り返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a cache uses a received 304 response to update a cache entry, the cache MUST update the entry to reflect any new field values given in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、キャッシュエントリを更新するために受信された304レスポンスを使用している場合、キャッシュはレスポンスで与えられた任意の新しいフィールド値を反映するためにエントリを更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.6 305 Use Proxy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.6 305プロキシを使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requested resource MUST be accessed through the proxy given by the Location field. The Location field gives the URI of the proxy. The recipient is expected to repeat this single request via the proxy. 305 responses MUST only be generated by origin servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求されたリソースはLocationフィールドによって与えられるプロキシ経由でアクセスする必要があります。 LocationフィールドはプロキシのURIを提供します。受信者は、プロキシを経由してこの単一の要求を繰り返すことが予想されます。 305個の応答が唯一のオリジンサーバによって生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: RFC 2068 was not clear that 305 was intended to redirect a single request, and to be generated by origin servers only. Not observing these limitations has significant security consequences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：RFC 2068は、305が単一の要求をリダイレクトすることを意図していたことは明らかではなかった、とだけオリジンサーバによって生成されます。これらの制限を観察しないと、重大なセキュリティ上の影響があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.7 306 (Unused)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.7 306（未使用）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 306 status code was used in a previous version of the specification, is no longer used, and the code is reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
306のステータスコードは、もはや使用されている仕様の以前のバージョンで使用されなかった、そしてコードが予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.8 307 Temporary Redirect
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.8 307一時的なリダイレクト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requested resource resides temporarily under a different URI. Since the redirection MAY be altered on occasion, the client SHOULD continue to use the Request-URI for future requests. This response is only cacheable if indicated by a Cache-Control or Expires header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求されたリソースが一時的に別のURIに存在します。リダイレクトを機会に変えることができるので、クライアントは将来のリクエストのためのRequest-URIを使い続けるべきです。この応答は、キャッシュコントロールによって示される場合にのみキャッシュ可能であるか、Expiresヘッダーフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The temporary URI SHOULD be given by the Location field in the response. Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s) , since many pre-HTTP/1.1 user agents do not understand the 307 status. Therefore, the note SHOULD contain the information necessary for a user to repeat the original request on the new URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一時的なURIは、レスポンス内のLocationフィールドによって与えられるべきです。リクエストメソッドがHEADだった場合を除き、多くの事前HTTP / 1.1ユーザエージェントは307のステータスを理解していないことから、レスポンスのエンティティは、新しいURIへのハイパーリンクで短いハイパーテキストのメモを含むべきです。そのため、ノートは新しいURIに元の要求を繰り返すユーザーのために必要な情報を含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
307のステータスコードがGETやHEAD以外の要求に応答して受信された場合、それをユーザが確認できない限り、この要求が発行された条件を変更する可能性があるため、ユーザエージェントは自動的に、要求をリダイレクトしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4 Client Error 4xx
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4クライアントエラーの4xx
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 4xx class of status code is intended for cases in which the client seems to have erred. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition. These status codes are applicable to any request method. User agents SHOULD display any included entity to the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータスコードの4xxのクラスは、クライアントが誤りを犯しているようだここで例を対象としています。 HEADリクエストに応答するとき以外は、サーバはエラー状況の説明を含むエンティティを含むべきである、それは一時的または永久的な状態であるかどうか。これらのステータスコードはどんなリクエストメソッドに適用されます。ユーザーエージェントは、ユーザーに任意の含まれたエンティティが表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client is sending data, a server implementation using TCP SHOULD be careful to ensure that the client acknowledges receipt of the packet(s) containing the response, before the server closes the input connection. If the client continues sending data to the server after the close, the server&#39;s TCP stack will send a reset packet to the client, which may erase the client&#39;s unacknowledged input buffers before they can be read and interpreted by the HTTP application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがデータを送信している場合は、TCPを使用してサーバの実装では、サーバが入力接続を閉じる前に、クライアントは、応答を含むパケット（S）の受信を確認することを保証するために注意する必要があります。クライアントが終了後にデータをサーバーに送信し続けた場合は、サーバのTCPスタックは、彼らが読んで、HTTPアプリケーションによって解釈される前に、クライアントの未確認の入力バッファを消去する可能性がある、クライアントにリセットパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.1 400 Bad Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.1 400不正な要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストの文法が間違っているため、サーバで解釈することができませんでした。クライアントは修正して再度要求してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.2 401 Unauthorized
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.2 401権限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The request requires user authentication. The response MUST include a WWW-Authenticate header field (section 14.47) containing a challenge applicable to the requested resource. The client MAY repeat the request with a suitable Authorization header field (section 14.8). If the request already included Authorization credentials, then the 401 response indicates that authorization has been refused for those credentials. If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user SHOULD be presented the entity that was given in the response, since that entity might include relevant diagnostic information. HTTP access authentication is explained in &#34;HTTP Authentication: Basic and Digest Access Authentication&#34; [43].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求は、ユーザの認証が必要です。応答は、要求されたリソースに適用可能なチャレンジを含むWWW-Authenticateヘッダフィールド（セクション14.47）を含まなければなりません。クライアントは、適切なAuthorizationヘッダフィールド（セクション14.8）でリクエストを繰り返してもよいです。要求が既に認証資格情報が含まれている場合、401レスポンスは認証がこれらの資格情報のために拒否されたことを示しています。 401レスポンスが前の応答と同じ課題が含まれており、ユーザエージェントはすでに少なくとも一度認証を試みた場合、ユーザーはそのエンティティは、関連する診断情報を含めることがあるため、応答で与えられたエンティティーを提示されるべきです。 [43]：HTTPアクセス認証が「基本とダイジェストアクセス認証HTTP認証」で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.3 402 Payment Required
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.3 402支払いが必要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This code is reserved for future use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このコードは、将来の使用のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.4 403 Forbidden
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.4 403禁止
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server understood the request, but is refusing to fulfill it. Authorization will not help and the request SHOULD NOT be repeated. If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled, it SHOULD describe the reason for the refusal in the entity. If the server does not wish to make this information available to the client, the status code 404 (Not Found) can be used instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは要求を理解したが、それを実行することを拒否しています。承認は助けにはなりませんし、要求が繰り返されるべきではありません。リクエストメソッドがHEADではなかったとサーバが要求が満たされていない理由を公表することを希望する場合は、エンティティで拒否の理由を説明する必要があります。サーバはクライアントがこの情報を利用できるようにしたくない場合は、ステータスコード404（見つかりません）が代わりに使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.5 404 Not Found
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.5 404が見つかりません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent. The 410 (Gone) status code SHOULD be used if the server knows, through some internally configurable mechanism, that an old resource is permanently unavailable and has no forwarding address. This status code is commonly used when the server does not wish to reveal exactly why the request has been refused, or when no other response is applicable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、Request-URIに一致するものを見つけていません。表示なしは、条件が一時的または恒久的であるかどうかについて説明されていません。 410（ゴーン）ステータスコードは、サーバが知っている場合、古いリソースが恒久的に利用できないことを、いくつかの内部的に設定可能なメカニズムを介して、使用して何の転送アドレスを持っていてはなりません。サーバは、要求が拒否された理由を正確に明らかにすることを希望していないとき、または他の応答が適用されない場合は、このステータスコードは一般的に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.6 405 Method Not Allowed
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.6 405メソッドは許可されていません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The method specified in the Request-Line is not allowed for the resource identified by the Request-URI. The response MUST include an Allow header containing a list of valid methods for the requested resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストラインで指定されたメソッドは、Request-URIによって識別されるリソースに対して許可されていません。応答は、要求されたリソースのための有効な方法のリストを含む許可ヘッダを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.7 406 Not Acceptable
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.7 406受け入れられません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The resource identified by the request is only capable of generating response entities which have content characteristics not acceptable according to the accept headers sent in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストによって識別されたリソースは、リクエストで送信受け入れるヘッダによれば受け入れられないコンテンツ特性を持つ応答エンティティを生成することができるだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unless it was a HEAD request, the response SHOULD include an entity containing a list of available entity characteristics and location(s) from which the user or user agent can choose the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically. However, this specification does not define any standard for such automatic selection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それがHEAD要求でない限り、反応は、ユーザーまたはユーザーエージェントが最も適切なものを選択することができ、そこから入手可能なエンティティの特性及び位置（単数または複数）のリストを含むエンティティを含むべきです。エンティティフォーマットはContent-Typeヘッダフィールドで指定されたメディアタイプによって指定されます。フォーマットやユーザエージェントの能力に応じて、最も適切な選択の選択が自動的に実行することができます。しかし、この仕様書は、そのような自動選択のための任意の標準を定義していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: HTTP/1.1 servers are allowed to return responses which are not acceptable according to the accept headers sent in the request. In some cases, this may even be preferable to sending a 406 response. User agents are encouraged to inspect the headers of an incoming response to determine if it is acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：HTTP / 1.1サーバは要求で送信される受入れヘッダーに応じて受け入れられない応答を返すことが許可されています。いくつかのケースでは、これも406応答を送信することが好ましいかもしれません。ユーザエージェントは、それが許容可能であるかどうかを決定するために、着信応答のヘッダを検査することが奨励されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the response could be unacceptable, a user agent SHOULD temporarily stop receipt of more data and query the user for a decision on further actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レスポンスが受け入れられないことができれば、ユーザエージェントは一時的に、より多くのデータの受信を停止し、さらにアクションの決定のためにユーザに問い合わせるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.8 407 Proxy Authentication Required
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.8 407プロキシ認証が必要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This code is similar to 401 (Unauthorized), but indicates that the client must first authenticate itself with the proxy. The proxy MUST return a Proxy-Authenticate header field (section 14.33) containing a challenge applicable to the proxy for the requested resource. The client MAY repeat the request with a suitable Proxy-Authorization header field (section 14.34). HTTP access authentication is explained in &#34;HTTP Authentication: Basic and Digest Access Authentication&#34; [43].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このコードは401（Unauthorized）に似ていますが、クライアントはまず自分をプロキシで認証しなければならないことを示しています。プロキシは、要求されたリソースのプロキシに適用チャレンジを含むプロキシ認証ヘッダフィールド（セクション14.33）を返さなければなりません。クライアントは、適切なProxy-Authorizationヘッダフィールド（セクション14.34）でリクエストを繰り返してもよいです。 [43]：HTTPアクセス認証が「基本とダイジェストアクセス認証HTTP認証」で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.9 408 Request Timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.9 408リクエストタイムアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバが待機するように調製された時間内に要求を生成しませんでした。クライアントは、それ以降の時間に変更することなく、要求を繰り返してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.10 409 Conflict
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.10 409競合
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The request could not be completed due to a conflict with the current state of the resource. This code is only allowed in situations where it is expected that the user might be able to resolve the conflict and resubmit the request. The response body SHOULD include enough information for the user to recognize the source of the conflict. Ideally, the response entity would include enough information for the user or user agent to fix the problem; however, that might not be possible and is not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求は、リソースの現在の状態との競合に完了することができませんでした。このコードは、唯一のユーザが矛盾を解決し、要求を再送信することができるかもしれないことが予想される状況では許可されています。レスポンスボディはユーザが競合のソースを認識するための十分な情報を含むべきです。理想的には、応答エンティティは、問題を解決するために、ユーザやユーザエージェントのための十分な情報が含まれます。しかし、それは可能ではないかもしれませんし、必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the entity being PUT included changes to a resource which conflict with those made by an earlier (third-party) request, the server might use the 409 response to indicate that it can&#39;t complete the request. In this case, the response entity would likely contain a list of the differences between the two versions in a format defined by the response Content-Type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
競合は、PUT要求に応答して発生する可能性が最も高いです。例えば、バージョンが使用されたエンティティであるPUTは、サーバが要求を完了できないことを示すために、409応答を使用することがあり、以前の（サードパーティ）によって作られたものと矛盾要求リソースへの変更が含まれている場合。この場合、レスポンスエンティティは、おそらくレスポンスのContent-Typeで定義された形式の2つのバージョン間の相違点のリストが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.11 410 Gone
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.11 410ゴーン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requested resource is no longer available at the server and no forwarding address is known. This condition is expected to be considered permanent. Clients with link editing capabilities SHOULD delete references to the Request-URI after user approval. If the server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) SHOULD be used instead. This response is cacheable unless indicated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求されたリソースは、サーバーとなし、転送先アドレスが知られている時に使用できなくなりました。この状態は永久的と見なされることが予想されます。リンク編集機能を持つクライアントは、ユーザーの承認後のRequest-URIへの参照を削除する必要があります。サーバは状態が永久的であるかどうか、知っている、または決定するための施設を持っていないいない場合は、ステータスコード404（見つかりません）が代わりに使用する必要があります。特に指示がない限り、このレスポンスはキャッシュ可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer working at the server&#39;s site. It is not necessary to mark all permanently unavailable resources as &#34;gone&#34; or to keep the mark for any length of time -- that is left to the discretion of the server owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
410応答は、主にリソースが意図的に利用できない受信者に通知することによって、サーバーの所有者がそのリソースへのリモートリンクが削除されることを望んでいることをウェブメンテナンスの作業を支援するためのものです。このようなイベントは、期間限定、プロモーションサービスのために、サーバーのサイトで働いて、もはや個人に属するリソースのための一般的です。サーバーの所有者の裁量に任されている - 「ゴーン」として、すべての永久利用できないリソースをマークするか、時間の任意の長さのためのマークを維持する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.12 411 Length Required
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.12 411の長さは必須
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server refuses to accept the request without a defined Content-Length. The client MAY repeat the request if it adds a valid Content-Length header field containing the length of the message-body in the request message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、Content-Lengthが定義させずに要求を受け入れることを拒否します。それは要求メッセージにメッセージボディの長さを含む有効なContent-Lengthヘッダフィールドを追加する場合、クライアントはリクエストを繰り返す事ができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.13 412 Precondition Failed
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.13 412前提条件の失敗
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The precondition given in one or more of the request-header fields evaluated to false when it was tested on the server. This response code allows the client to place preconditions on the current resource metainformation (header field data) and thus prevent the requested method from being applied to a resource other than the one intended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはサーバで試験したときにリクエストヘッダフィールドの一つ以上で与えられた前提条件が偽に評価しました。この応答コードは、クライアントが現在のリソースメタ情報（ヘッダフィールドデータ）に前提条件を置き、従って意図以外のリソースに適用されることから、要求されたメソッドを防止することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.14 413 Request Entity Too Large
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.14 413要求エンティティが大きすぎます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server is refusing to process a request because the request entity is larger than the server is willing or able to process. The server MAY close the connection to prevent the client from continuing the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、要求エンティティが、サーバが喜んまたは処理することができるよりも大きいため、要求を処理するために拒否されます。サーバーは、クライアントがリクエストを継続することを防止するために、接続を閉じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the condition is temporary, the server SHOULD include a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
条件が一時的である場合、サーバはそれが一時的なもので、何時間後にクライアントが再試行してください可能性があることを示すために再試行-Afterヘッダフィールドを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.15 414 Request-URI Too Long
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.15 414のRequest-URIが長すぎます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server is refusing to service the request because the Request-URI is longer than the server is willing to interpret. This rare condition is only likely to occur when a client has improperly converted a POST request to a GET request with long query information, when the client has descended into a URI &#34;black hole&#34; of redirection (e.g., a redirected URI prefix that points to a suffix of itself), or when the server is under attack by a client attempting to exploit security holes present in some servers using fixed-length buffers for reading or manipulating the Request-URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、サーバが解釈していく所存ですよりも、リクエスト-URIが長くなるため、要求のサービスを拒否しています。このまれな状況では、クライアントがリダイレクションのURI「ブラックホール」（例えば、指すリダイレクトURI接頭辞に降りたときに、クライアントが正しく、長いクエリ情報をGETリクエストにPOSTリクエストを変換した場合、自身の接尾辞）、またはサーバが読み取りまたは要求URIを操作するための固定長のバッファを使用して、いくつかのサーバに存在するセキュリティホールを悪用しようとするクライアントによって攻撃を受けているとき。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.16 415 Unsupported Media Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.16 415サポートされていないメディアタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストのエンティティは、要求されたメソッドのために要求されたリソースによってサポートされていない形式であるため、サーバはリクエストのサービスを拒否しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.17 416 Requested Range Not Satisfiable
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.17 416要求された範囲に充足されません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server SHOULD return a response with this status code if a request included a Range request-header field (section 14.35), and none of the range-specifier values in this field overlap the current extent of the selected resource, and the request did not include an If-Range request-header field. (For byte-ranges, this means that the first-byte-pos of all of the byte-range-spec values were greater than the current length of the selected resource.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求がレンジリクエストヘッダフィールド（セクション14.35）が含まれており、この分野で範囲指定子値のいずれもが選択されたリソースの現在の範囲と重複しない、と要求がなかった場合、サーバは、このステータスコードで応答を返すべきですもしレンジリクエストヘッダフィールドを含みます。 （バイト範囲については、これはバイト範囲スペック値のすべての最初のバイト-posが選択されたリソースの現在の長さよりも大きかったことを意味します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this status code is returned for a byte-range request, the response SHOULD include a Content-Range entity-header field specifying the current length of the selected resource (see section 14.16). This response MUST NOT use the multipart/byteranges content-type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このステータスコードは、バイト範囲要求に対して返されたとき、応答が選択されたリソースの現在の長さを指定するコンテンツレンジエンティティヘッダフィールドを含むべきである（セクション14.16を参照）。この応答は、マルチパート/ byterangesのコンテンツタイプを使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.18 417 Expectation Failed
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.18 417期待に失敗しました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The expectation given in an Expect request-header field (see section 14.20) could not be met by this server, or, if the server is a proxy, the server has unambiguous evidence that the request could not be met by the next-hop server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
期待リクエストヘッダフィールドで与えられた期待値は、（セクション14.20を参照）、このサーバによって満たすことができなかった、または、サーバがプロキシである場合、サーバは、要求がネクストホップサーバによって満たされなかったことを明確な証拠を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5 Server Error 5xx
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5サーバーエラー5xxの
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Response status codes beginning with the digit &#34;5&#34; indicate cases in which the server is aware that it has erred or is incapable of performing the request. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition. User agents SHOULD display any included entity to the user. These response codes are applicable to any request method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
数字「5」から始まるレスポンスステータスコードは、サーバが、それが誤りを犯したり、要求を実行することができないしていることを認識している例を示しています。 HEADリクエストに応答するとき以外は、サーバはエラー状況の説明を含むエンティティを含むべきである、それは一時的または永久的な状態であるかどうか。ユーザーエージェントは、ユーザーに任意の含まれたエンティティが表示されます。これらの応答コードはどんなリクエストメソッドに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.1 500 Internal Server Error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.1 500内部サーバーエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server encountered an unexpected condition which prevented it from fulfilling the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、要求を満たすことを妨げる予期しない状態に遭遇しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.2 501 Not Implemented
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.2 501が実装されていません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは要求を満たすために必要な機能をサポートしていません。これは、サーバがリクエストメソッドを認識しないし、すべてのリソースに対して、それに対応する機能がない適切な対応です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.3 502 Bad Gateway
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.3 502不正なゲートウェイ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、ゲートウェイまたはプロキシとして動作しながら、それが要求を満たすためにしようとしてアクセスアップストリームサーバから無効な応答を受け取りました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.4 503 Service Unavailable
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.4 503サービスを使用できません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. The implication is that this is a temporary condition which will be alleviated after some delay. If known, the length of the delay MAY be indicated in a Retry-After header. If no Retry-After is given, the client SHOULD handle the response as it would for a 500 response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、現在サーバーの一時的な過負荷またはメンテナンスのためにリクエストを処理することができません。含意は、これはしばらく待つと緩和される一時的な状態であるということです。既知の場合、遅延の長さは、リトライ後ヘッダに示されてもよいです。何のリトライ後が指定されていない場合、クライアントは、応答それは500応答の場合と同じように処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The existence of the 503 status code does not imply that a server must use it when becoming overloaded. Some servers may wish to simply refuse the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：503のステータスコードの存在が過負荷になるときに、サーバがそれを使用しなければならないことを意味するものではありません。一部のサーバーは、単に接続を拒否することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.5 504 Gateway Timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.5 504ゲートウェイタイムアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server specified by the URI (e.g. HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed to access in attempting to complete the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、ゲートウェイまたはプロキシとして動作している間、それが完了しようとする中でのアクセスに必要なURI（例えばHTTP、FTP、LDAP）、またはいくつかの他の補助のサーバ（例えばDNS）で指定した上流サーバからタイムリーな応答を受信しませんでしたリクエスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Note to implementors: some deployed proxies are known to return 400 or 500 when DNS lookups time out.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：実装者への注意：いくつかの展開プロキシがDNSに時間をルックアップの時に400または500を返すことが知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.6 505 HTTP Version Not Supported
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.6 505 HTTPバージョンはサポートされません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server does not support, or refuses to support, the HTTP protocol version that was used in the request message. The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in section 3.1, other than with this error message. The response SHOULD contain an entity describing why that version is not supported and what other protocols are supported by that server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがサポートする、または、要求メッセージで使用されたHTTPプロトコルのバージョンをサポートすることを拒否していません。サーバーは、このエラーメッセージよりも他のセクション3.1に記載されているように、それができない、またはクライアントと同じメジャーバージョンを使用して要求を完了することが不本意であることを示しています。応答はそのバージョンがサポートされておらず、他のどのようなプロトコルは、そのサーバによってサポートされている理由を記述したエンティティを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
11 Access Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
11アクセス認証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP provides several OPTIONAL challenge-response authentication mechanisms which can be used by a server to challenge a client request and by a client to provide authentication information. The general framework for access authentication, and the specification of &#34;basic&#34; and &#34;digest&#34; authentication, are specified in &#34;HTTP Authentication: Basic and Digest Access Authentication&#34; [43]. This specification adopts the definitions of &#34;challenge&#34; and &#34;credentials&#34; from that specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPは認証情報を提供するために、クライアントの要求に挑戦するためにサーバーが使用すると、クライアントによることができるいくつかのオプションのチャレンジ・レスポンス認証メカニズムを提供します。 [43]：アクセス認証のための一般的なフレームワーク、および「ダイジェスト」「基本」と認証の仕様は、「基本とダイジェストアクセス認証HTTP認証」で指定されています。この仕様は、「挑戦」し、その仕様から「資格証明書」の定義を採用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
12 Content Negotiation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
12コンテントネゴシエーション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Most HTTP responses include an entity which contains information for interpretation by a human user. Naturally, it is desirable to supply the user with the &#34;best available&#34; entity corresponding to the request. Unfortunately for servers and caches, not all users have the same preferences for what is &#34;best,&#34; and not all user agents are equally capable of rendering all entity types. For that reason, HTTP has provisions for several mechanisms for &#34;content negotiation&#34; -- the process of selecting the best representation for a given response when there are multiple representations available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ほとんどのHTTP応答は人間のユーザによる解釈のための情報が含まれているエンティティが含まれます。当然、その要求に対応する「最良の利用可能な」エンティティをユーザに供給することが望ましいです。残念ながら、サーバやキャッシュのためではなく、すべてのユーザーが「最高」である何のために同じ嗜好を持っているし、すべてのユーザエージェントは、すべてのエンティティタイプをレンダリングも同様に実施可能わけではありません。利用可能な複数の表現がある与えられた応答のための最良の表現を選択するプロセス - そのため、HTTPは「コンテントネゴシエーション」のために、いくつかのメカニズムのための規定を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: This is not called &#34;format negotiation&#34; because the alternate representations may be of the same media type, but use different capabilities of that type, be in different languages, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：代替表現等、同じメディアタイプであるが、その種類の異なる機能を使用し、異なる言語であってもよいので、これは、「フォーマットネゴシエーション」と呼ばれていません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any response containing an entity-body MAY be subject to negotiation, including error responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティボディを含む任意の応答がエラー応答を含め、交渉の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two kinds of content negotiation which are possible in HTTP: server-driven and agent-driven negotiation. These two kinds of negotiation are orthogonal and thus may be used separately or in combination. One method of combination, referred to as transparent negotiation, occurs when a cache uses the agent-driven negotiation information provided by the origin server in order to provide server-driven negotiation for subsequent requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー主導型とエージェント駆動の交渉：HTTPで可能なコンテンツネゴシエーションの2種類があります。交渉のこれらの二つの種類が直交しているので、別々に又は組み合わせて使用​​することができます。キャッシュは後続の要求のためのサーバ主導型ネゴシエーションを提供するために、オリジンサーバによって提供されるエージェント駆動型ネゴシエーション情報を使用するときのような透明なネゴシエーションと呼ばれる組み合わせの一つの方法は、生じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1 Server-driven Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1サーバ駆動型ネゴシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the selection of the best representation for a response is made by an algorithm located at the server, it is called server-driven negotiation. Selection is based on the available representations of the response (the dimensions over which it can vary; e.g. language, content-coding, etc.) and the contents of particular header fields in the request message or on other information pertaining to the request (such as the network address of the client).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答のための最高の表現の選択がサーバにあるアルゴリズムによってなされた場合、それは、サーバ駆動折衝と呼ばれています。選択は、利用可能な応答の表現（それが変動し得るその上寸法、例えば言語、コンテンツコーディング、等）に基づいて、要求メッセージまたは要求に関連する他の情報に特定のヘッダフィールドの内容（例えば）クライアントのネットワークアドレスなど。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Server-driven negotiation is advantageous when the algorithm for selecting from among the available representations is difficult to describe to the user agent, or when the server desires to send its &#34;best guess&#34; to the client along with the first response (hoping to avoid the round-trip delay of a subsequent request if the &#34;best guess&#34; is good enough for the user). In order to improve the server&#39;s guess, the user agent MAY include request header fields (Accept, Accept-Language, Accept-Encoding, etc.) which describe its preferences for such a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
利用可能な表現の中から選択するためのアルゴリズムはユーザエージェントに記述することは困難である、またはサーバーが最初の応答と一緒にクライアントにその「最良の推測」を送信したいとき（避けるために、ご希望の場合、サーバ駆動型ネゴシエーションは有利であり、 「最良の推測」）は、ユーザーのために十分に良好であれば、後続の要求のラウンドトリップ遅延。サーバの推測を改善するために、ユーザエージェントは、応答に対するその選好を記載している（など、受け入れ受け入れ言語を受け入れるコードする）をリクエストヘッダのフィールドを含んでもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Server-driven negotiation has disadvantages:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー駆動型ネゴシエーションは欠点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. It is impossible for the server to accurately determine what might be &#34;best&#34; for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.サーバーが正確に任意のユーザーのための「最良」であるかもしれないものを判断するのは不可能であることは、ユーザエージェントと応答（例えば使用目的の両方の機能の完全な知識を必要とすることから、利用者が欲しいん画面上に表示したり、紙に印刷するには？）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential violation of the user&#39;s privacy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.ユーザエージェントはリクエストごとにその機能を説明持つこと（応答のわずかな割合は複数の表現を持っていることを考えると）両方の非常に非効率とユーザーのプライバシーの潜在的な侵害することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. It complicates the implementation of an origin server and the algorithms for generating responses to a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.それはオリジンサーバの実装と要求に対する応答を生成するためのアルゴリズムを複雑にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. It may limit a public cache&#39;s ability to use the same response for multiple user&#39;s requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.これは、複数のユーザーの要求に同じ応答を使用する公開キャッシュの能力を制限する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 includes the following request-header fields for enabling server-driven negotiation through description of user agent capabilities and user preferences: Accept (section 14.1), Accept-Charset (section 14.2), Accept-Encoding (section 14.3), Accept-Language (section 14.4), and User-Agent (section 14.43). However, an origin server is not limited to these dimensions and MAY vary the response based on any aspect of the request, including information outside the request-header fields or within extension header fields not defined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は、ユーザエージェントの能力とユーザ嗜好の説明を介して、サーバ・ドリブンネゴシエーションを可能にするため、次のリクエストヘッダフィールドを含む：（セクション14.1）を受け入れる（セクション14.2）・文字セットを受け入れ、受け入れエンコード（セクション14.3）、なAccept-言語（セクション14.4）、およびユーザエージェント（セクション14.43）。しかし、オリジンサーバはこれらの寸法に限定されるものではなく、リクエスト・ヘッダー・フィールド外部または本明細書で定義されていない拡張ヘッダフィールド内の情報を含む要求のいずれかの態様に基づいて、応答を変化させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Vary header field can be used to express the parameters the server uses to select a representation that is subject to server-driven negotiation. See section 13.6 for use of the Vary header field by caches and section 14.44 for use of the Vary header field by servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヴァリヘッダフィールドは、サーバがサーバ駆動型ネゴシエーションを受ける表現を選択するために使用するパラメータを発現するために使用することができます。キャッシュおよびサーバーによって異なるヘッダフィールドを使用するためのセクション14.44によって異なるヘッダフィールドを使用するためのセクション13.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2 Agent-driven Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2エージェント駆動の交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With agent-driven negotiation, selection of the best representation for a response is performed by the user agent after receiving an initial response from the origin server. Selection is based on a list of the available representations of the response included within the header fields or entity-body of the initial response, with each representation identified by its own URI. Selection from among the representations may be performed automatically (if the user agent is capable of doing so) or manually by the user selecting from a generated (possibly hypertext) menu.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エージェント駆動の交渉では、応答のための最高の表現の選択は、オリジンサーバからの初期応答を受け取った後、ユーザエージェントによって行われます。選択は、それ自身のURIによって識別される各表現に、初期応答のヘッダフィールドまたはエンティティボディ内に含まれる応答の利用可能な表現のリストに基づいています。または手動で生成された（おそらくハイパーテキスト）メニューからのユーザ選択によって（ユーザエージェントがそうすることが可能である場合）表現の中から選択を自動的に行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Agent-driven negotiation is advantageous when the response would vary over commonly-used dimensions (such as type, language, or encoding), when the origin server is unable to determine a user agent&#39;s capabilities from examining the request, and generally when public caches are used to distribute server load and reduce network usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
公共のキャッシュがある場合、応答は、一般に、オリジンサーバは、要求を検査からユーザエージェントの能力を決定することができない（例えば、タイプ、言語、または符号化のような）一般的に使用される大きさにわたって変化し、そしてなるとき、エージェント駆動型ネゴシエーションが有利ですサーバーの負荷を分散し、ネットワークの使用量を削減するために使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Agent-driven negotiation suffers from the disadvantage of needing a second request to obtain the best alternate representation. This second request is only efficient when caching is used. In addition, this specification does not define any mechanism for supporting automatic selection, though it also does not prevent any such mechanism from being developed as an extension and used within HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エージェント駆動型ネゴシエーションは、最良の代替表現を得るために第2の要求を必要とするという欠点があります。キャッシュが使用されている場合は、この2番目の要求にのみ効率的です。また、拡張として開発され、HTTP / 1.1内で使用されているから、そのような機構を妨げないもののほかに、本明細書では、自動選択をサポートするための任意のメカニズムを定義しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable) status codes for enabling agent-driven negotiation when the server is unwilling or unable to provide a varying response using server-driven negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1 300（複数の選択肢）及び406（許容できない）サーバがサーバ駆動型ネゴシエーションを使用して変化させる応答を提供したくないまたはできない場合、エージェント駆動型ネゴシエーションを可能にするためのステータスコードを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3 Transparent Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3透過的ネゴシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transparent negotiation is a combination of both server-driven and agent-driven negotiation. When a cache is supplied with a form of the list of available representations of the response (as in agent-driven negotiation) and the dimensions of variance are completely understood by the cache, then the cache becomes capable of performing server-driven negotiation on behalf of the origin server for subsequent requests on that resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
透明なネゴシエーションは、サーバー主導とエージェント駆動型ネゴシエーションの両方の組み合わせです。キャッシュが（エージェント駆動型ネゴシエーションにおけるように）応答の利用可能な表現のリストの形で供給され、分散の大きさが完全にキャッシュすることによって理解されている場合、キャッシュは、代わりにサーバ・ドリブンネゴシエーションを行うことが可能となりますそのリソースへの後続のリクエストのためにオリジンサーバの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transparent negotiation has the advantage of distributing the negotiation work that would otherwise be required of the origin server and also removing the second request delay of agent-driven negotiation when the cache is able to correctly guess the right response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
透明な交渉は、そうでない場合は、オリジンサーバーで必要とされるであろう交渉作業を配布し、キャッシュが正しく右の応答を推測できる場合も、エージェント駆動の交渉の第2の要求遅延を除去するという利点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification does not define any mechanism for transparent negotiation, though it also does not prevent any such mechanism from being developed as an extension that could be used within HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、HTTP / 1.1内で使用することができる拡張として開発されてから、このような機構を妨げないものの、本明細書では、透明なネゴシエーションのための任意のメカニズムを定義しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
13 Caching in HTTP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPで13キャッシング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP is typically used for distributed information systems, where performance can be improved by the use of response caches. The HTTP/1.1 protocol includes a number of elements intended to make caching work as well as possible. Because these elements are inextricable from other aspects of the protocol, and because they interact with each other, it is useful to describe the basic caching design of HTTP separately from the detailed descriptions of methods, headers, response codes, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPは、典型的には、性能が応答キャッシュを使用することによって改善することができる分散情報システムに使用されます。 HTTP / 1.1プロトコルが可能と同様にキャッシュを動作させるように意図要素の数を含みます。これらの要素はプロトコルの他の側面からほどけないあるので、それらが互いに相互作用しているため、それ等の方法、ヘッダ、応答コードの詳細な説明は別にHTTPの基本的なキャッシュ設計を記述するために有用です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Caching would be useless if it did not significantly improve performance. The goal of caching in HTTP/1.1 is to eliminate the need to send requests in many cases, and to eliminate the need to send full responses in many other cases. The former reduces the number of network round-trips required for many operations; we use an &#34;expiration&#34; mechanism for this purpose (see section 13.2). The latter reduces network bandwidth requirements; we use a &#34;validation&#34; mechanism for this purpose (see section 13.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはパフォーマンスを大幅に改善しなかった場合はキャッシングは役に立たないだろう。 HTTP / 1.1におけるキャッシングの目標は、多くの場合、要求を送信する必要性を排除するために、および他の多くの例では、完全な応答を送信する必要性を排除することです。前者は、多くの操作に必要なネットワーク・ラウンドトリップの回数を減らします。我々は、この目的のために「有効期限」のメカニズムを（セクション13.2を参照）を使用します。後者は、ネットワーク帯域幅の要件を低減します。我々は、この目的のための「検証」のメカニズムを（セクション13.3を参照）を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Requirements for performance, availability, and disconnected operation require us to be able to relax the goal of semantic transparency. The HTTP/1.1 protocol allows origin servers, caches, and clients to explicitly reduce transparency when necessary. However, because non-transparent operation may confuse non-expert users, and might be incompatible with certain server applications (such as those for ordering merchandise), the protocol requires that transparency be relaxed
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パフォーマンス、可用性、および切断操作のための要件は、意味の透明性の目標を緩和することができることを求めています。 HTTP / 1.1プロトコルは、必要なときにオリジンサーバ、キャッシュ、クライアントが明示的に透明性を減らすことができます。しかし、非透過的な操作は、非専門家のユーザーを混乱させ、そして（例えば発注商品のためのものなど）、特定のサーバアプリケーションとの互換性がない可能性があるため、プロトコルは、透明性が緩和されている必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- only by an explicit protocol-level request when relaxed by client or origin server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 唯一の明示的なプロトコルレベルの要求により、クライアントやオリジンサーバによって緩和するとき
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- only with an explicit warning to the end user when relaxed by cache or client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 専用キャッシュやクライアントによって緩和エンドユーザーへの明示的な警告と
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Therefore, the HTTP/1.1 protocol provides these important elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従って、HTTP / 1.1プロトコルは、これらの重要な要素を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Protocol features that provide full semantic transparency when this is required by all parties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これはすべての当事者によって要求されたときに、完全な意味的な透過性を提供1.プロトコル機能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Protocol features that allow an origin server or user agent to explicitly request and control non-transparent operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバやユーザエージェントが明示的に要求し、非透過的な操作を制御することを可能にする2プロトコル機能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Protocol features that allow a cache to attach warnings to responses that do not preserve the requested approximation of semantic transparency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、意味の透明性の要求された近似値を保存しない応答に警告を添付できるようにする3.プロトコル機能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A basic principle is that it must be possible for the clients to detect any potential relaxation of semantic transparency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
基本的な原理は、クライアントは、意味の透明性のいずれかの潜在的な緩和を検出することが可能でなければならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The server, cache, or client implementor might be faced with design decisions not explicitly discussed in this specification. If a decision might affect semantic transparency, the implementor ought to err on the side of maintaining transparency unless a careful and complete analysis shows significant benefits in breaking transparency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：サーバー、キャッシュ、またはクライアントの実装者は、明示的にこの仕様で説明されていないデザインの決定に直面するかもしれません。判決は、意味の透明性に影響を与える可能性がある場合、実装者は慎重かつ完全な分析は、透明性を壊すことで大きなメリットを示していない限り、透明性を維持するのに越しべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1 Cache Correctness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1キャッシュの正当性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A correct cache MUST respond to a request with the most up-to-date response held by the cache that is appropriate to the request (see sections 13.2.5, 13.2.6, and 13.12) which meets one of the following conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
正しいキャッシュは、次のいずれかの条件を満たしている要求に適したキャッシュに保持された最新の応答（セクション13.2.5、13.2.6を参照して、13.12）で要求に応答しなければなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. It has been checked for equivalence with what the origin server would have returned by revalidating the response with the origin server (section 13.3);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.これは、オリジンサーバがオリジンサーバ（セクション13.3）との応答を再検証によって返されていたものとの等価性をチェックされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. It is &#34;fresh enough&#34; (see section 13.2). In the default case, this means it meets the least restrictive freshness requirement of the client, origin server, and cache (see section 14.9); if the origin server so specifies, it is the freshness requirement of the origin server alone.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.それは「十分に新鮮」である（セクション13.2を参照してください）。デフォルトの場合、これは（セクション14.9を参照）、クライアント、オリジンサーバ、およびキャッシュの最も制限の新鮮さの要件を満たしていること。オリジンサーバがそう指定されている場合、それだけではオリジンサーバの鮮度要件です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a stored response is not &#34;fresh enough&#34; by the most restrictive freshness requirement of both the client and the origin server, in carefully considered circumstances the cache MAY still return the response with the appropriate Warning header (see section 13.1.5 and 14.46), unless such a response is prohibited (e.g., by a &#34;no-store&#34; cache-directive, or by a &#34;no-cache&#34; cache-request-directive; see section 14.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
保存された応答は、クライアントとオリジンサーバの両方の最も制限鮮度要件によって「十分に新鮮」でない場合は、慎重に検討の状況でキャッシュがまだ適切な警告ヘッダーを持つ応答を返してもよい（セクション13.1.5と14.46を参照してください） 、このような応答は禁止されていない限り（例えば、「無店舗」キャッシュ・ディレクティブによって、または「キャッシュなし」のキャッシュ・リクエスト・ディレクティブによって、セクション14.9を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect), or error (4xx or 5xx) response message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.これは、適切な304（変更されていません）、305（プロキシリダイレクト）、またはエラー（4XXまたは5xxの）応答メッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the cache can not communicate with the origin server, then a correct cache SHOULD respond as above if the response can be correctly served from the cache; if not it MUST return an error or warning indicating that there was a communication failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュはオリジンサーバと通信できない場合は、正しいキャッシュはレスポンスが正しくキャッシュから提供できるのであれば、上記のように対応すべきです。ない場合には、通信障害があったことを示すエラーまたは警告を返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a cache receives a response (either an entire response, or a 304 (Not Modified) response) that it would normally forward to the requesting client, and the received response is no longer fresh, the cache SHOULD forward it to the requesting client without adding a new Warning (but without removing any existing Warning headers). A cache SHOULD NOT attempt to revalidate a response simply because that response became stale in transit; this might lead to an infinite loop. A user agent that receives a stale response without a Warning MAY display a warning indication to the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、キャッシュがなくて要求元のクライアントに転送すべきで、それは通常、前方に要求しているクライアントへのだろう、と受け取ったレスポンスがもはや新鮮で​​ないこと（全体の応答、または304（未修正）応答のいずれか）を応答を受信した場合新しい警告を追加します（ただし、既存の警告ヘッダを削除せずに）。キャッシュは、そのレスポンスが輸送中の古くなったというだけの理由で応答を再検証を試みるべきではありません。これは無限ループにつながる可能性があります。警告なしに失効応答を受信するユーザエージェントは、ユーザに警告表示を表示してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2 Warnings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2警告
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever a cache returns a response that is neither first-hand nor &#34;fresh enough&#34; (in the sense of condition 2 in section 13.1.1), it MUST attach a warning to that effect, using a Warning general-header. The Warning header and the currently defined warnings are described in section 14.46. The warning allows clients to take appropriate action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、最初の手も（セクション13.1.1における条件2の意味で）「十分に新鮮」でもない応答を返すときはいつでも、それは警告一般的なヘッダを使用して、その旨の警告を添付しなければなりません。警告ヘッダと現在定義されている警告はセクション14.46に記載されています。警告はクライアントが適切な行動を取ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warnings MAY be used for other purposes, both cache-related and otherwise. The use of a warning, rather than an error status code, distinguish these responses from true failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告は、キャッシュ関連とそれ以外の両方の、他の目的に使用することができます。警告ではなく、エラーステータスコードの使用は、真の障害からこれらの応答を区別する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warnings are assigned three digit warn-codes. The first digit indicates whether the Warning MUST or MUST NOT be deleted from a stored cache entry after a successful revalidation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告は3桁の警告-コードが割り当てられています。最初の数字は、警告または成功した再検証した後、保存されたキャッシュエントリから削除してはならない必要があるかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1xx Warnings that describe the freshness or revalidation status of the response, and so MUST be deleted after a successful revalidation. 1XX warn-codes MAY be generated by a cache only when validating a cached entry. It MUST NOT be generated by clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これの1xx応答の鮮度や再検証のステータスを記述する警告し、成功した再検証後に削除されなければなりません。 1XXは警告-コードをキャッシュされたエントリを検証した場合にのみキャッシュすることによって生成することができます。これは、クライアントによって生成されてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2xx Warnings that describe some aspect of the entity body or entity headers that is not rectified by a revalidation (for example, a lossy compression of the entity bodies) and which MUST NOT be deleted after a successful revalidation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（例えば、エンティティ体の非可逆圧縮）再検証によって整流されておらず、成功した再検証後に削除してはいけませんどのエンティティ体またはエンティティヘッダのいくつかの態様を説明2XX警告。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See section 14.46 for the definitions of the codes themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コード自体の定義についてはセクション14.46を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.0 caches will cache all Warnings in responses, without deleting the ones in the first category. Warnings in responses that are passed to HTTP/1.0 caches carry an extra warning-date field, which prevents a future HTTP/1.1 recipient from believing an erroneously cached Warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.0キャッシュは、最初のカテゴリにものを削除することなく、応答のすべての警告をキャッシュします。 HTTP / 1.0のキャッシュに渡される応答の警告が誤ってキャッシュされた警告を信じるから、将来のHTTP / 1.1受信者を防ぎ、余分な警告日付フィールドを運びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warnings also carry a warning text. The text MAY be in any appropriate natural language (perhaps based on the client&#39;s Accept headers), and include an OPTIONAL indication of what character set is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告は、警告テキストを運びます。テキストは、任意の適切な自然言語であってもよい（多分クライアントのAcceptヘッダに基づいて）、および文字セットが使用されているもののオプション表示を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multiple warnings MAY be attached to a response (either by the origin server or by a cache), including multiple warnings with the same code number. For example, a server might provide the same warning with texts in both English and Basque.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の警告が同じコード番号を持つ複数の警告を含む応答（オリジンサーバによって、またはキャッシュのいずれかによって）に取り付けられてもよいです。例えば、サーバが英語とバスク語の両方のテキストと同じ警告を提供するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When multiple warnings are attached to a response, it might not be practical or reasonable to display all of them to the user. This version of HTTP does not specify strict priority rules for deciding which warnings to display and in what order, but does suggest some heuristics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の警告がレスポンスに添付されている場合は、ユーザーにそれらのすべてを表示するのは実用的または合理的ではないかもしれません。 HTTPのこのバージョンは、警告を表示するかを決めるために、どのような順序で完全優先規則を指定しませんが、いくつかのヒューリスティックを提案ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3 Cache-control Mechanisms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3キャッシュ制御メカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The basic cache mechanisms in HTTP/1.1 (server-specified expiration times and validators) are implicit directives to caches. In some cases, a server or client might need to provide explicit directives to the HTTP caches. We use the Cache-Control header for this purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1の基本的なキャッシュ・メカニズム（サーバー指定の有効期限とバリデータ）は、キャッシュへの暗黙のディレクティブです。いくつかのケースでは、サーバやクライアントはHTTPキャッシュに明示的な指示を提供する必要があるかもしれません。私たちは、この目的のためのCache-Controlヘッダーを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Cache-Control header allows a client or server to transmit a variety of directives in either requests or responses. These directives typically override the default caching algorithms. As a general rule, if there is any apparent conflict between header values, the most restrictive interpretation is applied (that is, the one that is most likely to preserve semantic transparency). However, in some cases, cache-control directives are explicitly specified as weakening the approximation of semantic transparency (for example, &#34;max-stale&#34; or &#34;public&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Controlヘッダは、クライアントまたはサーバが要求または応答のいずれかのディレクティブの様々なを送信することができます。これらのディレクティブは、通常、デフォルトのキャッシングアルゴリズムを上書きします。ヘッダ値の間に明らかな矛盾がある場合は、原則として、最も限定的な解釈が適用される（すなわち、意味論的透明性を維持する可能性が最も高いもの）。しかし、いくつかのケースでは、キャッシュ制御ディレクティブを明示的に意味の透明性の近似値を弱めるとして指定されている（例えば、「MAX-古い」または「パブリック」）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cache-control directives are described in detail in section 14.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュ制御指令はセクション14.9に詳細に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4 Explicit User Agent Warnings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4明示的なユーザーエージェントの警告
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many user agents make it possible for users to override the basic caching mechanisms. For example, the user agent might allow the user to specify that cached entities (even explicitly stale ones) are never validated. Or the user agent might habitually add &#34;Cache-Control: max-stale=3600&#34; to every request. The user agent SHOULD NOT default to either non-transparent behavior, or behavior that results in abnormally ineffective caching, but MAY be explicitly configured to do so by an explicit action of the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くのユーザエージェントは、それが可能なユーザーは、基本的なキャッシュメカニズムを無効にできるようにするため。例えば、ユーザーエージェントは、ユーザーがキャッシュされたエンティティ（でも、明示的に古いものは）検証されないことを指定することができる場合があります。すべてのリクエストに：またはユーザエージェントは、習慣的に「MAX-古い= 3600のCache-Control」を追加することがあります。ユーザーエージェントは、非透明行動、または異常無効キャッシュにつながる行動のいずれかをデフォルトとはならず、明示的にユーザーの明示的なアクションによってそうするように構成されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the user has overridden the basic caching mechanisms, the user agent SHOULD explicitly indicate to the user whenever this results in the display of information that might not meet the server&#39;s transparency requirements (in particular, if the displayed entity is known to be stale). Since the protocol normally allows the user agent to determine if responses are stale or not, this indication need only be displayed when this actually happens. The indication need not be a dialog box; it could be an icon (for example, a picture of a rotting fish) or some other indicator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーは基本的なキャッシュメカニズムをオーバーライドしている場合、これは（表示されたエンティティが陳腐であることが知られている場合は、特に）サーバーの透明性の要件を満たしていない可能性があり、情報の表示になりたび、ユーザーエージェントは、ユーザーに明示的に示す必要があります。プロトコルは、通常、応答が失効されているかどうか判定するためにユーザーエージェントを可能にするので、これは実際に発生したとき、この指示は、表示される必要があります。表示は、ダイアログボックスである必要はありません。それは（例えば、腐った魚の絵）アイコンまたはいくつかの他のインジケータとすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the user has overridden the caching mechanisms in a way that would abnormally reduce the effectiveness of caches, the user agent SHOULD continually indicate this state to the user (for example, by a display of a picture of currency in flames) so that the user does not inadvertently consume excess resources or suffer from excessive latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザが異常キャッシュの有効性を減少させる方法でキャッシングメカニズムをオーバーライドしている場合、ユーザエージェントはユーザにこの状態を示して継続すべきである（例えば、炎の通貨の画像の表示によって）ユーザよううっかり過剰なリソースを消費したり過度の待ち時間を患っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5 Exceptions to the Rules and Warnings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ルールと警告する13.1.5例外
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In some cases, the operator of a cache MAY choose to configure it to return stale responses even when not requested by clients. This decision ought not be made lightly, but may be necessary for reasons of availability or performance, especially when the cache is poorly connected to the origin server. Whenever a cache returns a stale response, it MUST mark it as such (using a Warning header) enabling the client software to alert the user that there might be a potential problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのケースでは、キャッシュのオペレータは、クライアントによって要求されていない場合でも、古くなったレスポンスを返すように設定することを選択するかもしれません。この決定は軽く作られるべきではないが、キャッシュが不十分オリジンサーバに接続している場合は特に、可用性やパフォーマンス上の理由から必要な場合があります。キャッシュが古くなったレスポンスを返すたびに、それは潜在的な問題があるかもしれないことをユーザに警告するために、クライアントソフトウェアを有効にする（警告ヘッダーを使用して）そのようにマークする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It also allows the user agent to take steps to obtain a first-hand or fresh response. For this reason, a cache SHOULD NOT return a stale response if the client explicitly requests a first-hand or fresh one, unless it is impossible to comply for technical or policy reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、ユーザエージェントが最初の手や新鮮な応答を取得するための措置をとることができます。クライアントが明示的に最初の手や新鮮なものを要求した場合、技術的または政策的な理由のために遵守することは不可能でない限り、このような理由から、キャッシュは、古くなったレスポンスを返すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6 Client-controlled Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6クライアント制御の挙動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the origin server (and to a lesser extent, intermediate caches, by their contribution to the age of a response) are the primary source of expiration information, in some cases the client might need to control a cache&#39;s decision about whether to return a cached response without validating it. Clients do this using several directives of the Cache-Control header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバ（およびより少ない程度に、中間キャッシュは、レスポンスの年齢への貢献により）有効期限情報の主要なソースですが、いくつかのケースでは、クライアントはキャッシュされたを返すかどうかについてのキャッシュの決定を制御する必要がある場合がありますそれを検証せずに応答。クライアントは、こののCache-Controlヘッダのいくつかのディレクティブを使用してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client&#39;s request MAY specify the maximum age it is willing to accept of an unvalidated response; specifying a value of zero forces the cache(s) to revalidate all responses. A client MAY also specify the minimum time remaining before a response expires. Both of these options increase constraints on the behavior of caches, and so cannot further relax the cache&#39;s approximation of semantic transparency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントの要求は、未検証応答を受け入れることを望んで最大の年齢を指定することもできます。ゼロの値を指定すると、すべての応答を再検証するためにキャッシュ（複数可）を強制します。また、クライアントは、応答の有効期限が切れる前に、残りの最小時間を指定してもよいです。これらのオプションのどちらも、キャッシュの行動に制約を延ばすため、さらに意味の透明性のキャッシュの近似値を緩和することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client MAY also specify that it will accept stale responses, up to some maximum amount of staleness. This loosens the constraints on the caches, and so might violate the origin server&#39;s specified constraints on semantic transparency, but might be necessary to support disconnected operation, or high availability in the face of poor connectivity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはまた、古さのいくつかの最大量までの古くなったレスポンスを、受け入れるように指定することができます。これは、キャッシュ上の制約を緩めると、その意味の透明性のオリジンサーバの指定された制約に違反するかもしれませんが、貧しい人々の接続の顔に切断操作、または高可用性をサポートする必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2 Expiration Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2有効期限モデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.1 Server-Specified Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.1サーバ指定の有効期限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP caching works best when caches can entirely avoid making requests to the origin server. The primary mechanism for avoiding requests is for an origin server to provide an explicit expiration time in the future, indicating that a response MAY be used to satisfy subsequent requests. In other words, a cache can return a fresh response without first contacting the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPキャッシュはキャッシュが完全にオリジンサーバへの要求を避けることができたときに最適に動作します。リクエストを回避するための主要なメカニズムは、応答が後続の要求を満たすために使用され得ることを示し、将来的に明示的な有効期限を提供するために、オリジンサーバのためのものです。言い換えれば、キャッシュが最初のサーバーに接触することなく、新鮮な応答を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Our expectation is that servers will assign future explicit expiration times to responses in the belief that the entity is not likely to change, in a semantically significant way, before the expiration time is reached. This normally preserves semantic transparency, as long as the server&#39;s expiration times are carefully chosen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちの期待はサーバが有効期限に達する前に、エンティティは、意味的に重要な方法で、変更される可能性はないという信念で応答に将来の明示的な有効期限を割り当てるということです。これは通常、サーバーの有効期限が慎重に選択されている限り、意味の透明性を維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The expiration mechanism applies only to responses taken from a cache and not to first-hand responses forwarded immediately to the requesting client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有効期限のメカニズムは、要求元のクライアントに即座に転送最初の手の応答にキャッシュから取られた応答にのみ適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an origin server wishes to force a semantically transparent cache to validate every request, it MAY assign an explicit expiration time in the past. This means that the response is always stale, and so the cache SHOULD validate it before using it for subsequent requests. See section 14.9.4 for a more restrictive way to force revalidation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバがすべての要求を検証するために意味的に透過キャッシュを強制したい場合、それは過去に明示的に有効期限を割り当てることができます。これは、応答は常に古いことを意味し、そのキャッシュが後続の要求のためにそれを使用する前にそれを検証する必要があります。再検証を強制するより限定的な方法については項14.9.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an origin server wishes to force any HTTP/1.1 cache, no matter how it is configured, to validate every request, it SHOULD use the &#34;must-revalidate&#34; cache-control directive (see section 14.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバがすべての要求を検証するために、関係なく、それがどのように構成されるか、任意のHTTP / 1.1キャッシュを強制しないことを望む場合、それは（セクション14.9を参照してください）「MUST-再検証」キャッシュ制御ディレクティブを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers specify explicit expiration times using either the Expires header, or the max-age directive of the Cache-Control header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは有効期限のヘッダー、またはのCache-Controlヘッダのmax-ageディレクティブのいずれかを使用して明示的に有効期限を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An expiration time cannot be used to force a user agent to refresh its display or reload a resource; its semantics apply only to caching mechanisms, and such mechanisms need only check a resource&#39;s expiration status when a new request for that resource is initiated. See section 13.13 for an explanation of the difference between caches and history mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有効期限は、その表示を更新したり、リソースを再ロードするためにユーザーエージェントを強制するために使用することはできません。そのセマンティクスはキャッシングメカニズムにのみ適用され、そしてそのようなメカニズムは、そのリソースに対する新しい要求が開始されたときに、リソースの有効期限の状態を確認するだけです。キャッシュと履歴メカニズムの違いの説明についてはセクション13.13を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.2 Heuristic Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.2ヒューリスティック有効期限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since origin servers do not always provide explicit expiration times, HTTP caches typically assign heuristic expiration times, employing algorithms that use other header values (such as the Last-Modified time) to estimate a plausible expiration time. The HTTP/1.1 specification does not provide specific algorithms, but does impose worst-case constraints on their results. Since heuristic expiration times might compromise semantic transparency, they ought to used cautiously, and we encourage origin servers to provide explicit expiration times as much as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバは常に明示的に有効期限を提供しないので、HTTPキャッシュは、典型的にもっともらしい有効期限を推定するために（例えば、最終更新時刻などの）他のヘッダ値を使用するアルゴリズムを採用し、ヒューリスティック有効期限を割り当てます。 HTTP / 1.1仕様では、特定のアルゴリズムを提供していませんが、その結果に最悪の場合の制約を課すん。ヒューリスティック有効期限は、意味の透明性を損なう可能性があるので、慎重に使用するべき、と私たちは可能な限り明示的に有効期限を提供するために、オリジンサーバを奨励します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.3 Age Calculations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.3年齢計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to know if a cached entry is fresh, a cache needs to know if its age exceeds its freshness lifetime. We discuss how to calculate the latter in section 13.2.4; this section describes how to calculate the age of a response or cache entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュされたエントリが新鮮であるかどうかを知るためには、キャッシュはその年齢がその新鮮寿命を超えたかどうかを知る必要があります。私たちは、セクション13.2.4で、後者の計算方法を話し合います。このセクションでは、レスポンスやキャッシュエントリの年齢を計算する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this discussion, we use the term &#34;now&#34; to mean &#34;the current value of the clock at the host performing the calculation.&#34; Hosts that use HTTP, but especially hosts running origin servers and caches, SHOULD use NTP [28] or some similar protocol to synchronize their clocks to a globally accurate time standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この議論では、我々は意味し、「今すぐ」という用語を使用して「計算を行うホストのクロックの現在の値を。」特にHTTPを使用するホストが、オリジンサーバとキャッシュを実行しているホストは、NTP [28]またはグローバル正確な時刻標準に自分のクロックを同期するためにいくつかの類似したプロトコルを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 requires origin servers to send a Date header, if possible, with every response, giving the time at which the response was generated (see section 14.18). We use the term &#34;date_value&#34; to denote the value of the Date header, in a form appropriate for arithmetic operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は、（セクション14.18を参照してください）応答が生成された時間を与えて、可能な場合は、すべての応答で、Dateヘッダを送信するためにオリジンサーバが必要です。我々は、算術演算のために適切な形で、日付ヘッダの値を表すために、用語「DATE_VALUE」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 uses the Age response-header to convey the estimated age of the response message when obtained from a cache. The Age field value is the cache&#39;s estimate of the amount of time since the response was generated or revalidated by the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は、キャッシュから取得したときに応答メッセージの推定年齢を伝えるため年齢レスポンスヘッダを使用します。 Ageフィールドの値は、応答が生成またはオリジンサーバで再検証してからの時間の量のキャッシュの推定値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In essence, the Age value is the sum of the time that the response has been resident in each of the caches along the path from the origin server, plus the amount of time it has been in transit along network paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本質的に、年齢の値は、応答がオリジンサーバから経路に沿ってキャッシュのそれぞれに常駐していた時間の合計、プラス、それは、ネットワーク経路に沿って走行していた時間の量です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We use the term &#34;age_value&#34; to denote the value of the Age header, in a form appropriate for arithmetic operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
我々は、算術演算のために適切な形で、年齢ヘッダの値を表すために、用語「age_value」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A response&#39;s age can be calculated in two entirely independent ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レスポンスの年齢は、二つの完全に独立した方法で計算することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. now minus date_value, if the local clock is reasonably well synchronized to the origin server&#39;s clock. If the result is negative, the result is replaced by zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.今マイナスDATE_VALUE、ローカルクロックが合理的にオリジンサーバのクロックに同期されている場合。結果が負の場合、結果はゼロに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. age_value, if all of the caches along the response path implement HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. age_value、応答経路に沿ったキャッシュのすべてがHTTP / 1.1実装する場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given that we have two independent ways to compute the age of a response when it is received, we can combine these as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
我々はそれを受信したときの応答の年齢を計算するための2つの独立した方法を持っていることを考えると、我々は、これらを組み合わせることができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
corrected_received_age = max(now - date_value, age_value)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
corrected_received_age = MAX（今 -  DATE_VALUE、age_value）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
and as long as we have either nearly synchronized clocks or all-HTTP/1.1 paths, one gets a reliable (conservative) result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そして限り、私たちはほぼ同期したクロックまたは全て-HTTP / 1.1のパスのいずれかを持っているように、一つは信頼性の高い（保守的な）結果を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because of network-imposed delays, some significant interval might pass between the time that a server generates a response and the time it is received at the next outbound cache or client. If uncorrected, this delay could result in improperly low ages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのため、ネットワークに課した遅延のため、いくつかの重要な間隔は、サーバーが応答を生成し、時間は、それが次のアウトバウンドのキャッシュやクライアントで受信された時間の間を通過することがあります。補正されていない場合は、この遅延は不適当に低い年齢層につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because the request that resulted in the returned Age value must have been initiated prior to that Age value&#39;s generation, we can correct for delays imposed by the network by recording the time at which the request was initiated. Then, when an Age value is received, it MUST be interpreted relative to the time the request was initiated, not the time that the response was received. This algorithm results in conservative behavior no matter how much delay is experienced. So, we compute:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
返さ年齢値になったリクエストはその年齢値の世代の前に開始されている必要があるため、私たちは、要求が開始された時刻を記録することにより、ネットワークによって課される遅延を補正することができます。年齢値が受信されたときに、その要求が開始された時刻ではなく、応答が受信された時刻に関連して解釈しなければなりません。このアルゴリズムは関係なく経験しているどのくらいの遅延保守的な行動になりません。そこで、我々は計算します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
corrected_initial_age = corrected_received_age + (now - request_time)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
corrected_initial_age = corrected_received_age +（今 -  REQUEST_TIME）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where &#34;request_time&#34; is the time (according to the local clock) when the request that elicited this response was sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、「REQUEST_TIME」は、この応答を誘発し、要求が送信された時刻（ローカルクロックに応じて）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Summary of age calculation algorithm, when a cache receives a response:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、応答を受け取る年齢計算アルゴリズムの概要：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /*
       * age_value
       *      is the value of Age: header received by the cache with
       *              this response.
       * date_value
       *      is the value of the origin server&#39;s Date: header
       * request_time
       *      is the (local) time when the cache made the request
       *              that resulted in this cached response
       * response_time
       *      is the (local) time when the cache received the
       *              response
       * now
       *      is the current (local) time
       */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      apparent_age = max(0, response_time - date_value);
      corrected_received_age = max(apparent_age, age_value);
      response_delay = response_time - request_time;
      corrected_initial_age = corrected_received_age + response_delay;
      resident_time = now - response_time;
      current_age   = corrected_initial_age + resident_time;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current_age of a cache entry is calculated by adding the amount of time (in seconds) since the cache entry was last validated by the origin server to the corrected_initial_age. When a response is generated from a cache entry, the cache MUST include a single Age header field in the response with a value equal to the cache entry&#39;s current_age.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュエントリのてcurrent_ageは、キャッシュエントリがcorrected_initial_ageにオリジンサーバによって最後に検証されてからの時間（秒数）を加算して算出されます。応答がキャッシュエントリから生成された場合、キャッシュは、キャッシュ・エントリのてcurrent_ageに等しい値に応じて、単一の年齢ヘッダーフィールドを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The presence of an Age header field in a response implies that a response is not first-hand. However, the converse is not true, since the lack of an Age header field in a response does not imply that the response is first-hand unless all caches along the request path are compliant with HTTP/1.1 (i.e., older HTTP caches did not implement the Age header field).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答における年齢ヘッダフィールドの存在は、応答が最初の手ではないことを意味します。応答における年齢ヘッダフィールドの欠如が要求パスに沿ってすべてのキャッシュがHTTP / 1.1（すなわちに準拠していない限り、応答は最初の手で、古いHTTPキャッシュがなかったことを意味するものではないので、逆は真ではありません）年齢ヘッダフィールドを実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.4 Expiration Calculations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.4有効期限の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to decide whether a response is fresh or stale, we need to compare its freshness lifetime to its age. The age is calculated as described in section 13.2.3; this section describes how to calculate the freshness lifetime, and to determine if a response has expired. In the discussion below, the values can be represented in any form appropriate for arithmetic operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答が新鮮か古いであるかどうかを決定するために、我々はその年齢にその新鮮寿命を比較する必要があります。セクション13.2.3に記載されているように、年齢が算出されます。このセクションでは、新鮮寿命を計算し、その応答の期限が切れているかどうかを判断する方法について説明します。以下の説明では、値は算術演算のために適切な任意の形態で表現することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We use the term &#34;expires_value&#34; to denote the value of the Expires header. We use the term &#34;max_age_value&#34; to denote an appropriate value of the number of seconds carried by the &#34;max-age&#34; directive of the Cache-Control header in a response (see section 14.9.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは、Expiresヘッダの値を示すために、用語「expires_value」を使用します。私たちは、（セクション14.9.3を参照してください）応答のCache-Controlヘッダの「最大エージング」ディレクティブによって運ばれた秒数の適切な値を示すために、用語「max_age_value」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The max-age directive takes priority over Expires, so if max-age is present in a response, the calculation is simply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAX-ageディレクティブは、max-年齢が応答に存在しているのであれば、計算は単純で、有効期限よりも優先されます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
freshness_lifetime = max_age_value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
freshness_lifetime = max_age_value
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Otherwise, if Expires is present in the response, the calculation is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答中に存在している有効期限が切れるとそうでない場合、計算は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
freshness_lifetime = expires_value - date_value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
freshness_lifetime = expires_value  -  DATE_VALUE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that neither of these calculations is vulnerable to clock skew, since all of the information comes from the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての情報は、オリジンサーバから来ているので、これらの計算のどちらも、クロック・スキューに対して脆弱であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If none of Expires, Cache-Control: max-age, or Cache-Control: s-maxage (see section 14.9.3) appears in the response, and the response does not include other restrictions on caching, the cache MAY compute a freshness lifetime using a heuristic. The cache MUST attach Warning 113 to any response whose age is more than 24 hours if such warning has not already been added.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAXAGE、またはのCache-Control：のいずれも、のCache-Control期限切れない場合は、S-MAXAGE（セクション14.9.3を参照してください）応答に表示され、応答はキャッシュ上の他の制限が含まれていない、新鮮さを計算することができるキャッシュヒューリスティックを使用して寿命。キャッシュは、その年齢、そのような警告がまだ追加されていない場合は24時間以上である任意の応答に113警告添付する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Also, if the response does have a Last-Modified time, the heuristic expiration value SHOULD be no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レスポンスがLast-Modifiedの時間を持っている場合も、ヒューリスティック有効期限の値はその時以来、間隔のある割合以下であってはなりません。この画分の典型的な設定は10％であるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The calculation to determine if a response has expired is quite simple:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答の期限が切れているかどうかを判断するための計算が非常に簡単です：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
response_is_fresh = (freshness_lifetime &gt; current_age)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
response_is_fresh =（鮮度寿命&gt; CURRENT_PAGE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.5 Disambiguating Expiration Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.5有効期限値を曖昧に
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because expiration values are assigned optimistically, it is possible for two caches to contain fresh values for the same resource that are different.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有効期限の値が楽観割り当てられているので2つのキャッシュが異なる同じリソースのための新鮮な値が含まれてすることが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a client performing a retrieval receives a non-first-hand response for a request that was already fresh in its own cache, and the Date header in its existing cache entry is newer than the Date on the new response, then the client MAY ignore the response. If so, it MAY retry the request with a &#34;Cache-Control: max-age=0&#34; directive (see section 14.9), to force a check with the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
検索を実行するクライアントは、すでに独自のキャッシュで新鮮でした要求に対する非最初の手の応答を受信して​​、その既存のキャッシュエントリ内のDateヘッダが新しいレスポンスの日付よりも新しい場合、クライアントは無視してもよい（MAY）応答。もしそうなら、それはして要求を再試行してもよい（MAY）「のCache-Control：最大エージング= 0」を指示し（セクション14.9を参照）、オリジンサーバとのチェックを強制します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a cache has two fresh responses for the same representation with different validators, it MUST use the one with the more recent Date header. This situation might arise because the cache is pooling responses from other caches, or because a client has asked for a reload or a revalidation of an apparently fresh cache entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは異なるバリデータと同じ表現のための2つの新鮮なレスポンスを持っている場合、それはより多くの最近のDateヘッダを持つものを使用しなければなりません。キャッシュが他のキャッシュからの応答をプールしているため、またはクライアントがリロードまたは明らかに新鮮なキャッシュエントリの再検証を求めているため、このような状況が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.6 Disambiguating Multiple Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.6複数の応答を曖昧に
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because a client might be receiving responses via multiple paths, so that some responses flow through one set of caches and other responses flow through a different set of caches, a client might receive responses in an order different from that in which the origin server sent them. We would like the client to use the most recently generated response, even if older responses are still apparently fresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの応答がキャッシュの1つのセットを通って流れ、他の応答がキャッシュの異なるセットを流れるように、クライアントが複数のパスを経由して応答を受信する可能性があるため、クライアントはオリジンサーバがそれらを送っているとは異なる順序で応答を受け取ることがあります。私たちは、古いレスポンスがまだ明らかに新鮮であっても、クライアントが最後に生成された応答を使用したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Neither the entity tag nor the expiration value can impose an ordering on responses, since it is possible that a later response intentionally carries an earlier expiration time. The Date values are ordered to a granularity of one second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
後に応答が意図的に以前の有効期限を運ぶことも可能であるため、エンティティタグや有効期限の値のいずれもが、応答に順序を課すことができます。日付値は、1秒の細かさに命じています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client tries to revalidate a cache entry, and the response it receives contains a Date header that appears to be older than the one for the existing entry, then the client SHOULD repeat the request unconditionally, and include
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがキャッシュエントリを再検証しようとし、それが受け取る応答は、既存のエントリの1よりも古いように見えるDateヘッダが含まれている場合、クライアントは無条件に要求を繰り返すと、含むべきです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control: max-age=0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control：最大エージング= 0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
to force any intermediate caches to validate their copies directly with the origin server, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバと直接自分のコピーを検証するために任意の中間キャッシュを強制する、またはします
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control: no-cache
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control：キャッシュなし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
to force any intermediate caches to obtain a new copy from the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバから新しいコピーを取得するために任意の中間キャッシュを強制します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the Date values are equal, then the client MAY use either response (or MAY, if it is being extremely prudent, request a new response). Servers MUST NOT depend on clients being able to choose deterministically between responses generated during the same second, if their expiration times overlap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
日付値が等しい場合、クライアントは、（新しい応答を要求し、それは非常に賢明されている場合、またはMAY）応答のいずれかを使用するかもしれません。サーバーは、クライアントがその満了時間が重なった場合、同じ秒の間に生成された応答の間で決定論的に選択することができることに依存してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3 Validation Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3検証モデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a cache has a stale entry that it would like to use as a response to a client&#39;s request, it first has to check with the origin server (or possibly an intermediate cache with a fresh response) to see if its cached entry is still usable. We call this &#34;validating&#34; the cache entry. Since we do not want to have to pay the overhead of retransmitting the full response if the cached entry is good, and we do not want to pay the overhead of an extra round trip if the cached entry is invalid, the HTTP/1.1 protocol supports the use of conditional methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、クライアントの要求に対する応答として使用したいという古いエントリを持っている場合、それは最初にキャッシュされたエントリがまだ使用可能かどうかを確認するためにオリジンサーバ（あるいは新鮮なレスポンスを持つ中間キャッシュ）に確認する必要があります。私たちは、この「有効」キャッシュエントリを呼び出します。私たちは、キャッシュされたエントリが良好であれば、完全な応答を再送するオーバーヘッドを支払うことをしたくない、とキャッシュされたエントリが無効な場合、私たちは余分なラウンドトリップのオーバーヘッドを支払うことをしたくない、HTTP / 1.1プロトコルがサポートするので、条件付きの方法の使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key protocol features for supporting conditional methods are those concerned with &#34;cache validators.&#34; When an origin server generates a full response, it attaches some sort of validator to it, which is kept with the cache entry. When a client (user agent or proxy cache) makes a conditional request for a resource for which it has a cache entry, it includes the associated validator in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
条件付きメソッドをサポートするための主要なプロトコル機能は、に関するものであり、「キャッシュバリデータ。」オリジンサーバが完全な応答を生成するときに、キャッシュエントリに保持され、それにバリデータのいくつかの並べ替えを添付します。クライアント（ユーザエージェントまたはプロキシキャッシュ）がキャッシュエントリを持っているリソースのための条件付き要求を行う際に、その要求に関連したバリデータを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server then checks that validator against the current validator for the entity, and, if they match (see section 13.3.3), it responds with a special status code (usually, 304 (Not Modified)) and no entity-body. Otherwise, it returns a full response (including entity-body). Thus, we avoid transmitting the full response if the validator matches, and we avoid an extra round trip if it does not match.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らは（セクション13.3.3を参照）と一致する場合、サーバは、その後、エンティティの現在のバリデータに対してそのバリデータをチェックし、そして、それは特別なステータスコード（通常、304（変更不可））と無エンティティボディで応答します。それ以外の場合は、（エンティティボディを含む）完全な応答を返します。したがって、我々は、バリデータが一致した場合、完全な応答を送信しないよう、それが一致しない場合、私たちは余分なラウンドトリップを避けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In HTTP/1.1, a conditional request looks exactly the same as a normal request for the same resource, except that it carries a special header (which includes the validator) that implicitly turns the method (usually, GET) into a conditional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1では、条件付き要求は、それが条件に暗黙的方法を回す特別なヘッダを（バリデータを含む）（通常、GET）を担持することを除いて、同じリソースに対する通常の要求と全く同じに見えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The protocol includes both positive and negative senses of cache-validating conditions. That is, it is possible to request either that a method be performed if and only if a validator matches or if and only if no validators match.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルは、キャッシュ検証条件の正および負の感覚の両方を含みます。すなわち、いずれかの方法があればのみバリデータと一致する場合、または場合行わないバリデータが一致しない場合にのみすることを要求することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: a response that lacks a validator may still be cached, and served from cache until it expires, unless this is explicitly prohibited by a cache-control directive. However, a cache cannot do a conditional retrieval if it does not have a validator for the entity, which means it will not be refreshable after it expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：バリデータが欠けている応答がまだキャッシュされ、これは明示的にキャッシュ制御ディレクティブで禁止されていない限り、それは、有効期限が切れるまでキャッシュから提供することができます。それが満了した後、それがリフレッシュされないことを意味するエンティティのためのバリデータを持っていない場合は、キャッシュは条件検索を行うことができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3.1 Last-Modified Dates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3.1のLast-Modified日付
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Last-Modified entity-header field value is often used as a cache validator. In simple terms, a cache entry is considered to be valid if the entity has not been modified since the Last-Modified value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Last-Modifiedエンティティヘッダフィールド値はしばしばキャッシュバリデータとして使用されています。簡単に言えば、キャッシュエントリは、エンティティがLast-Modifiedの値から変更されていない場合に有効であると考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3.2 Entity Tag Cache Validators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3.2エンティティタグのキャッシュバリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ETag response-header field value, an entity tag, provides for an &#34;opaque&#34; cache validator. This might allow more reliable validation in situations where it is inconvenient to store modification dates, where the one-second resolution of HTTP date values is not sufficient, or where the origin server wishes to avoid certain paradoxes that might arise from the use of modification dates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ETagレスポンスヘッダフィールド値、エンティティタグは、「不透明な」キャッシュ・バリデータを提供します。これは、HTTP日付値の1秒の解像度が十分でない、またはオリジンサーバは、変更日の使用から生じる可能性のある特定のパラドックスを避けたい場所、それが店の修正日に不便である状況で、より信頼性の検証を、許可するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Entity Tags are described in section 3.11. The headers used with entity tags are described in sections 14.19, 14.24, 14.26 and 14.44.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグは、セクション3.11で説明されています。エンティティタグと共に使用されるヘッダはセクション14.19、14.24、14.26及び14.44に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3.3 Weak and Strong Validators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3.3弱いと強いバリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since both origin servers and caches will compare two validators to decide if they represent the same or different entities, one normally would expect that if the entity (the entity-body or any entity-headers) changes in any way, then the associated validator would change as well. If this is true, then we call this validator a &#34;strong validator.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバとキャッシュの両方が、彼らは同じまたは異なるエンティティを表すかどうかを判断するために、2つのバリデータを比較しますので、一つは通常期待されるものであれば、エンティティ（エンティティボディまたは任意のエンティティヘッダ）どのような方法の変化、そして関連するバリデータは希望同様に変更します。これが本当であれば、私たちは「強いバリ。」このバリデータを呼び出します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, there might be cases when a server prefers to change the validator only on semantically significant changes, and not when insignificant aspects of the entity change. A validator that does not always change when the resource changes is a &#34;weak validator.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが唯一の意味的に重要な変更にバリデータを変更することを好む、といないとき、エンティティの変更の些細な側面しかし、ケースがあるかもしれません。リソースの変更は常に変化していないバリデータは「弱いバリデータ」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Entity tags are normally &#34;strong validators,&#34; but the protocol provides a mechanism to tag an entity tag as &#34;weak.&#34; One can think of a strong validator as one that changes whenever the bits of an entity changes, while a weak value changes whenever the meaning of an entity changes. Alternatively, one can think of a strong validator as part of an identifier for a specific entity, while a weak validator is part of an identifier for a set of semantically equivalent entities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグ「は、強力なバリデータ」は、通常であるが、プロトコルは、ASエンティティタグをタグ付けするためのメカニズムを提供「弱いです」。一つは、エンティティの意味が変更されるたびに、弱い値が変化しながら、エンティティの変更のたびビットを変更するものとして強いバリデータと考えることができます。弱いバリデータが意味的に等価なエンティティのセットのための識別子の一部である別の方法として、一つは、特定のエンティティの識別子の一部などの強力なバリデータと考えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: One example of a strong validator is an integer that is incremented in stable storage every time an entity is changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：強力なバリデータの一例は、安定したストレージにエンティティが変更されるたびに増分される整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An entity&#39;s modification time, if represented with one-second resolution, could be a weak validator, since it is possible that the resource might be modified twice during a single second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リソースが単一の第2中に2回変更される可能性があるということができるので、エンティティの変更時間は、1秒の分解能で表されている場合、弱いバリデータである可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Support for weak validators is optional. However, weak validators allow for more efficient caching of equivalent objects; for example, a hit counter on a site is probably good enough if it is updated every few days or weeks, and any value during that period is likely &#34;good enough&#34; to be equivalent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
弱いバリデータのサポートはオプションです。しかし、弱いバリデータは、同等のオブジェクトのより効率的なキャッシングを可能にします。それはすべての数日または数週間を更新し、その期間中の任意の値が同等である可能性が高い「十分」であるされている場合、たとえば、サイト上のヒットカウンタは、おそらく十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A &#34;use&#34; of a validator is either when a client generates a request and includes the validator in a validating header field, or when a server compares two validators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、2つのバリデータを比較したときにクライアントが要求を生成して検証ヘッダフィールドにバリデータを含む、またはいずれかのときにバリデータの「使用」があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Strong validators are usable in any context. Weak validators are only usable in contexts that do not depend on exact equality of an entity. For example, either kind is usable for a conditional GET of a full entity. However, only a strong validator is usable for a sub-range retrieval, since otherwise the client might end up with an internally inconsistent entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
強力なバリデータは、任意のコンテキストで使用可能です。弱いバリデータは、エンティティの正確な等価性に依存しないコンテキストでのみ使用可能です。例えば、いずれかの種類は、完全なエンティティの条件付きGETのために使用可能です。そうでない場合、クライアントが内部矛盾エンティティに終わるかもしれないので、唯一の強力なバリデータは、サブ範囲の検索のために使用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、単純な（非サブレンジ）を発行し、弱いバリデータや強いバリデータのいずれかとのリクエストを得ることができます。クライアントは、要求の他の形態で弱いバリデータを使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The only function that the HTTP/1.1 protocol defines on validators is comparison. There are two validator comparison functions, depending on whether the comparison context allows the use of weak validators or not:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1プロトコルは、バリデータに定義のみ機能は比較です。比較コンテキストが弱いバリデータかどうかの使用を許可するかどうかに応じて、2つのバリデータの比較機能は、あります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The strong comparison function: in order to be considered equal, both validators MUST be identical in every way, and both MUST NOT be weak.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 強い比較機能：等しいと見なされるためには、両方のバリデータはあらゆる方法で同じでなければならない、との両方が弱いしているはずがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The weak comparison function: in order to be considered equal, both validators MUST be identical in every way, but either or both of them MAY be tagged as &#34;weak&#34; without affecting the result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 弱い比較機能：等しいと見なされるためには、両方のバリデータは、あらゆる方法で同一でなければならないが、それらのいずれかまたは両方が結果に影響を与えることなく、「弱い」としてタグ付けすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An entity tag is strong unless it is explicitly tagged as weak. Section 3.11 gives the syntax for entity tags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが明示的に弱いとしてタグ付けされていない限り、エンティティタグは強いです。セクション3.11は、エンティティタグの構文を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最終更新時刻は、要求の中のバリデータとして使用した場合、次の規則を使用して、それが強いと推定することが可能である場合を除き、暗黙的に弱いです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The validator is being compared by an origin server to the actual current validator for the entity and,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - バリデータは、エンティティの実際の現在のバリデータにオリジンサーバによって比較しています、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- That origin server reliably knows that the associated entity did not change twice during the second covered by the presented validator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - それオリジンサーバは、確実に関連するエンティティが提示バリでカバー第二中に2回変更されていないことを知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The validator is about to be used by a client in an If-Modified-Since or If-Unmodified-Since header, because the client has a cache entry for the associated entity, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - バリデータは、クライアントが関連するエンティティのためのキャッシュエントリを有しているので、もし変性-ので場合、または非改変-ので、ヘッダにクライアントによって使用されようとしている、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- That cache entry includes a Date value, which gives the time when the origin server sent the original response, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - そのキャッシュエントリがオリジンサーバが元の応答を送信した時刻を与えるDate値を含み、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The presented Last-Modified time is at least 60 seconds before the Date value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 提示のLast-Modified時間が日付値前に、少なくとも60秒です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The validator is being compared by an intermediate cache to the validator stored in its cache entry for the entity, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - バリデータは、エンティティのキ​​ャッシュエントリに格納されたバリの中間キャッシュによって比較し、されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- That cache entry includes a Date value, which gives the time when the origin server sent the original response, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - そのキャッシュエントリがオリジンサーバが元の応答を送信した時刻を与えるDate値を含み、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The presented Last-Modified time is at least 60 seconds before the Date value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 提示のLast-Modified時間が日付値前に、少なくとも60秒です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified time. The arbitrary 60- second limit guards against the possibility that the Date and Last-Modified values are generated from different clocks, or at somewhat different times during the preparation of the response. An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この方法は、二つの異なるレスポンスが同じ秒の間、オリジンサーバによって送信されますが、両方が同じ最終更新時刻を持っていた場合、それらの応答の少なくとも一つはそのLast-Modifiedのと同じ日付値を持っているという事実に依存しています時間。日付およびLast-Modifiedの値が応答の調製中に異なるクロックから、または幾分異なる時間に生成される可能性に対して任意60-第二限界ガード。 60秒は短すぎると考えられている場合、実装は、60秒以上の値を使用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a client wishes to perform a sub-range retrieval on a value for which it has only a Last-Modified time and no opaque validator, it MAY do this only if the Last-Modified time is strong in the sense described here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、それが唯一のLast-Modified時間なし、不透明なバリデータを持っている値にサブ範囲検索を実行したい場合、それは最終更新時刻は、ここで説明した意味での強い場合にのみ、これを行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A cache or origin server receiving a conditional request, other than a full-body GET request, MUST use the strong comparison function to evaluate the condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フルボディGETリクエスト以外の条件付きリクエストを受信キャッシュやオリジンサーバは、条件を評価するために強い比較機能を使わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These rules allow HTTP/1.1 caches and clients to safely perform sub-range retrievals on values that have been obtained from HTTP/1.0 servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのルールは、HTTP / 1.1キャッシュやクライアントが安全にHTTP / 1.0サーバから得られた値にサブレンジ回収のを実行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3.4 Rules for When to Use Entity Tags and Last-Modified Dates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
エンティティタグとLast-Modifiedの日付を使用するときのための13.3.4のルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We adopt a set of rules and recommendations for origin servers, clients, and caches regarding when various validator types ought to be used, and for what purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは、さまざまなバリデータタイプが使用されるべき、と何の目的でに関するオリジンサーバ、クライアント、およびキャッシュのためのルールや推奨事項のセットを採用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 origin servers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1オリジンサーバ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- SHOULD send an entity tag validator unless it is not feasible to generate one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  1を生成することは不可能でない限り、エンティティタグバリデータを送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- MAY send a weak entity tag instead of a strong entity tag, if performance considerations support the use of weak entity tags, or if it is unfeasible to send a strong entity tag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - パフォーマンスの考慮が弱いエンティティタグの使用をサポートしている場合、強いエンティティタグの代わりに弱いエンティティタグを送ったり、強いエンティティタグを送信することは実現不可能である場合にしてもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- SHOULD send a Last-Modified value if it is feasible to send one, unless the risk of a breakdown in semantic transparency that could result from using this date in an If-Modified-Since header would lead to serious problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  1を送信することが可能であるならば、Last-Modifiedの値を送るべきでない限り、この日付を使用することから生じる可能性の意味的透明性の崩壊の危険場合 - 変更-Sinceヘッダが深刻な問題につながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In other words, the preferred behavior for an HTTP/1.1 origin server is to send both a strong entity tag and a Last-Modified value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
言い換えれば、HTTP / 1.1オリジンサーバのための好適な動作は、強いエンティティタグとLast-Modified値の両方を送信することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to be legal, a strong entity tag MUST change whenever the associated entity value changes in any way. A weak entity tag SHOULD change whenever the associated entity changes in a semantically significant way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
合法的であるために、強いエンティティタグは、何らかの方法でたびに関連付けられたエンティティ値の変更を変更しなければなりません。関連するエンティティを意味的に重要な方法で変更されるたびに弱いエンティティタグを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: in order to provide semantically transparent caching, an origin server must avoid reusing a specific strong entity tag value for two different entities, or reusing a specific weak entity tag value for two semantically different entities. Cache entries might persist for arbitrarily long periods, regardless of expiration times, so it might be inappropriate to expect that a cache will never again attempt to validate an entry using a validator that it obtained at some point in the past.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：意味的に透過キャッシングを提供するために、オリジンサーバは、二つの異なるエンティティのための特定の強いエンティティタグ値を再利用する、または2つの意味的に異なるエンティティのための特定の弱いエンティティタグ値の再利用を避けなければなりません。キャッシュエントリは関係なく、有効期限の、任意の長期間持続可能性があるので、キャッシュは再び、それは過去のある時点で取得したバリデータを使用してエントリを検証しようとしないことを期待するのは不適切かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 clients:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1クライアント：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If an entity tag has been provided by the origin server, MUST use that entity tag in any cache-conditional request (using If-Match or If-None-Match).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - エンティティタグがオリジンサーバによって提供されている場合、任意のキャッシュ条件付き要求にそのエンティティタグを使用しなければならない（もしマッチまたは場合-なしマッチ使用）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If only a Last-Modified value has been provided by the origin server, SHOULD use that value in non-subrange cache-conditional requests (using If-Modified-Since).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  Last-Modified値のみがオリジンサーバによって提供されている場合は、（変更される場合は--以来使用して）非サブレンジキャッシュ条件付きリクエストでその値を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If only a Last-Modified value has been provided by an HTTP/1.0 origin server, MAY use that value in subrange cache-conditional requests (using If-Unmodified-Since:). The user agent SHOULD provide a way to disable this, in case of difficulty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  Last-Modified値のみがHTTP / 1.0オリジンサーバによって提供されている場合は、サブレンジキャッシュ条件付きリクエスト（場合非改変-以来使用して:)でその値を使用するかもしれません。ユーザエージェントは、困難な場合には、これを無効にする方法を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If both an entity tag and a Last-Modified value have been provided by the origin server, SHOULD use both validators in cache-conditional requests. This allows both HTTP/1.0 and HTTP/1.1 caches to respond appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - エンティティタグとLast-Modified値の両方がオリジンサーバによって提供されている場合は、キャッシュ条件付きリクエストの両方のバリデータを使うべきです。これは、両方のHTTP / 1.0およびHTTP / 1.1キャッシュが適切に対応することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An HTTP/1.1 origin server, upon receiving a conditional request that includes both a Last-Modified date (e.g., in an If-Modified-Since or If-Unmodified-Since header field) and one or more entity tags (e.g., in an If-Match, If-None-Match, or If-Range header field) as cache validators, MUST NOT return a response status of 304 (Not Modified) unless doing so is consistent with all of the conditional header fields in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば（および1つまたは複数のエンティティタグに（もし修飾-ので又は場合-ので非改変ヘッダフィールドに、例えば）最終更新日時の両方を含む条件付きの要求を受信するHTTP / 1.1オリジンサーバ、場合 - なし - マッチキャッシュバリデータとして、304の応答ステータスを返してはならない場合はレンジヘッダフィールド）場合はマッチ、または（そうすることが要求における条件付きヘッダフィールドのすべてと一致していない限り）変更されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An HTTP/1.1 caching proxy, upon receiving a conditional request that includes both a Last-Modified date and one or more entity tags as cache validators, MUST NOT return a locally cached response to the client unless that cached response is consistent with all of the conditional header fields in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1キャッシュプロキシ、そのキャッシュされた応答は、すべてのと一致していない限りキャッシュバリデータとして最終更新日時と1つ以上のエンティティタグの両方が含ま条件付きリクエストを受信すると、クライアントにローカルにキャッシュされたレスポンスを返してはなりません要求の条件ヘッダフィールド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The general principle behind these rules is that HTTP/1.1 servers and clients should transmit as much non-redundant information as is available in their responses and requests. HTTP/1.1 systems receiving this information will make the most conservative assumptions about the validators they receive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：これらのルールの背後にある一般的な原則は、その応答やリクエストで利用可能であるとしてHTTP / 1.1サーバとクライアントが同じくらい非冗長情報を送信すべきであるということです。この情報を受信するHTTP / 1.1システムでは、彼らが受け取るバリデータについての最も保守的な仮定を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.0 clients and caches will ignore entity tags. Generally, last-modified values received or used by these systems will support transparent and efficient caching, and so HTTP/1.1 origin servers should provide Last-Modified values. In those rare cases where the use of a Last-Modified value as a validator by an HTTP/1.0 system could result in a serious problem, then HTTP/1.1 origin servers should not provide one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.0クライアントとキャッシュはエンティティタグを無視します。一般的に、最後に変更された値は、受信または透明で効率的なキャッシングをサポートするこれらのシステムで使用され、そのHTTP / 1.1オリジンサーバはLast-Modifiedの値を提供する必要があります。 HTTP / 1.0システムにより、バリなどのLast-Modified値の使用は深刻な問題につながる可能性があり、それらのまれなケースでは、その後、HTTP / 1.1オリジンサーバは、1を提供してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3.5 Non-validating Conditionals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3.5非検証を条件文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The principle behind entity tags is that only the service author knows the semantics of a resource well enough to select an appropriate cache validation mechanism, and the specification of any validator comparison function more complex than byte-equality would open up a can of worms. Thus, comparisons of any other headers (except Last-Modified, for compatibility with HTTP/1.0) are never used for purposes of validating a cache entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグの原理は、サービス作成者が適切なキャッシュ検証メカニズムを選択しても十分なリソース、およびワームの缶を開けるだろうバイト平等よりも複雑な任意のバリデータの比較機能の仕様の意味を知っているということです。このように、（HTTP / 1.0との互換性のため、-最終更新日を除く）他のヘッダの比較は、キャッシュエントリを検証する目的のために使用されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4 Response Cacheability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4レスポンスキャッシング可能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unless specifically constrained by a cache-control (section 14.9) directive, a caching system MAY always store a successful response (see section 13.8) as a cache entry, MAY return it without validation if it is fresh, and MAY return it after successful validation. If there is neither a cache validator nor an explicit expiration time associated with a response, we do not expect it to be cached, but certain caches MAY violate this expectation (for example, when little or no network connectivity is available). A client can usually detect that such a response was taken from a cache by comparing the Date header to the current time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特にキャッシュ制御（セクション14.9）指令によって制約されない限り、常に正常な応答を格納することができるキャッシュシステムは、キャッシュエントリとして（セクション13.8を参照）、それが新鮮であれば、検証せずにそれを返すことができ、検証が成功した後、それを返すかもしれません。キャッシュバリデータも応答に関連する明示的な有効期限もないがあれば、我々はそれがキャッシュされることを期待していないが、特定のキャッシュはこの期待に違反する可能性（例えば、ほとんど、あるいは全くネットワーク接続が利用可能な場合）。クライアントは通常、このような応答は、現在の時刻に日付ヘッダを比較することにより、キャッシュから取られたことを検出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: some HTTP/1.0 caches are known to violate this expectation without providing any Warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：一部のHTTP / 1.0キャッシュはどんな警告を提供せずに、この期待に違反することが知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, in some cases it might be inappropriate for a cache to retain an entity, or to return it in response to a subsequent request. This might be because absolute semantic transparency is deemed necessary by the service author, or because of security or privacy considerations. Certain cache-control directives are therefore provided so that the server can indicate that certain resource entities, or portions thereof, are not to be cached regardless of other considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、いくつかのケースでは、エンティティを保持するキャッシュには不適切かもしれない、または後続の要求に応答して、それを返すこと。これは絶対的な意味論的な透明性がサービスの著者によって必要と判断されたためである、か、セキュリティやプライバシーの配慮のかもしれません。サーバは、特定のリソースエンティティ、またはその一部は、関係なく、他の考慮事項のキャッシュされていないことを示すことができるように、特定のキャッシュ制御ディレクティブしたがって設けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that section 14.8 normally prevents a shared cache from saving and returning a response to a previous request if that request included an Authorization header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
14.8は、通常、その要求は、Authorizationヘッダが含まれている場合、以前の要求への応答を保存して戻るの共有キャッシュを防止する部分に留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A response received with a status code of 200, 203, 206, 300, 301 or 410 MAY be stored by a cache and used in reply to a subsequent request, subject to the expiration mechanism, unless a cache-control directive prohibits caching. However, a cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial Content) responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュ制御指令がキャッシングを禁止しない限り、200、203、206、300、301または410のステータスコードと受信した応答は、有効期限機構に従う、キャッシュによって記憶され、後続の要求に対する応答に使用されるかもしれません。しかし、レンジ及びコンテンツレンジヘッダをサポートしていないキャッシュは206（部分コンテンツ）レスポンスをキャッシュしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A response received with any other status code (e.g. status codes 302 and 307) MUST NOT be returned in a reply to a subsequent request unless there are cache-control directives or another header(s) that explicitly allow it. For example, these include the following: an Expires header (section 14.21); a &#34;max-age&#34;, &#34;s-maxage&#34;, &#34;must-revalidate&#34;, &#34;proxy-revalidate&#34;, &#34;public&#34; or &#34;private&#34; cache-control directive (section 14.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュ制御ディレクティブまたは明示的に許可し、別のヘッダ（単数または複数）がない限り（例えば、ステータスコード302及び307）、他のステータスコードと、受信した応答は、後続の要求に対する応答で返されてはいけません。例えば、これらは、以下を含む：Expiresヘッダ（セクション14.21）を、 &#34;MAXAGE&#34;、 &#34;S-MAXAGE&#34;、 &#34;MUST-再検証&#34;、 &#34;プロキシ再検証&#34;、 &#34;パブリック&#34; または &#34;プライベート&#34; キャッシュ制御ディレクティブ（セクション14.9）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5 Constructing Responses From Caches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
キャッシュからの13.5構築の回答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The purpose of an HTTP cache is to store information received in response to requests for use in responding to future requests. In many cases, a cache simply returns the appropriate parts of a response to the requester. However, if the cache holds a cache entry based on a previous response, it might have to combine parts of a new response with what is held in the cache entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPキャッシュの目的は、将来の要求に応答での使用のための要求に応じて受信した情報を格納することです。多くの場合、キャッシュは単に依頼者への応答の適切な部分を返します。キャッシュは、以前の応答に基づいて、キャッシュエントリを保持している場合は、それがキャッシュエントリに保持されているものを使用して新しい応答のパーツを組み合わせることが必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.1 End-to-end and Hop-by-hop Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.1エンドツーエンド・ツーとホップバイホップヘッダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the purpose of defining the behavior of caches and non-caching proxies, we divide HTTP headers into two categories:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュや非キャッシュプロキシの動作を定義する目的のために、我々は二つのカテゴリーにHTTPヘッダを分割します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- End-to-end headers, which are transmitted to the ultimate recipient of a request or response. End-to-end headers in responses MUST be stored as part of a cache entry and MUST be transmitted in any response formed from a cache entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 要求または応答の最終的な受信者に送信されるエンドツーエンドヘッダ。応答におけるエンドツーエンドヘッダはキャッシュエントリの一部として格納する必要があり、キャッシュエントリから形成される任意の応答で送信されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Hop-by-hop headers, which are meaningful only for a single transport-level connection, and are not stored by caches or forwarded by proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 単一のトランスポート・レベルの接続のために意味のあるホップバイホップヘッダ、およびキャッシュによって記憶またはプロキシによって転送されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following HTTP/1.1 headers are hop-by-hop headers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のHTTP / 1.1ヘッダはホップバイホップヘッダは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Connection - Keep-Alive - Proxy-Authenticate - Proxy-Authorization - TE - Trailers - Transfer-Encoding - Upgrade
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 接続 - キープアライブ - プロキシ認証 - プロキシ認証 -  TE  - トレーラー - 転送 - エンコード - アップグレード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All other headers defined by HTTP/1.1 are end-to-end headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1で定義された他のすべてのヘッダーは、エンドツーエンドのヘッダーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Other hop-by-hop headers MUST be listed in a Connection header, (section 14.10) to be introduced into HTTP/1.1 (or later).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他のホップバイホップヘッダは接続ヘッダ、HTTP / 1.1（またはそれ以降）に導入される（セクション14.10）にリストされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.2 Non-modifiable Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.2変更できないヘッダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some features of the HTTP/1.1 protocol, such as Digest Authentication, depend on the value of certain end-to-end headers. A transparent proxy SHOULD NOT modify an end-to-end header unless the definition of that header requires or specifically allows that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このようなダイジェスト認証などのHTTP / 1.1プロトコルのいくつかの特徴は、特定のエンド・ツー・エンドのヘッダの値に依存します。そのヘッダの定義が必要または特異ことを可能にしない限り、透過プロキシは、エンドツーエンドのヘッダを変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A transparent proxy MUST NOT modify any of the following fields in a request or response, and it MUST NOT add any of these fields if not already present:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
透過プロキシは、要求または応答で、次のいずれかのフィールドを変更してはいけませんし、まだ存在しない場合には、これらのフィールドのいずれかを追加しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Content-Location
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - コンテンツの場所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Content-MD5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - のContent-MD5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- ETag
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - のETag
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Last-Modified
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 最終更新日
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A transparent proxy MUST NOT modify any of the following fields in a response:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
透過プロキシは、応答で、次のいずれかのフィールドを変更してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Expires
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 有効期限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
but it MAY add any of these fields if not already present. If an Expires header is added, it MUST be given a field-value identical to that of the Date header in that response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
既に存在していない場合、それは、これらのフィールドのいずれかを追加するかもしれません。ヘッダが付加されている有効期限が切れた場合、その応答にDateヘッダと同じフィールド値を与えなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy MUST NOT modify or add any of the following fields in a message that contains the no-transform cache-control directive, or in any request:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシは、無変換キャッシュ制御ディレクティブを含むメッセージで、または任意の要求で、次のいずれかのフィールドを変更したり、追加してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Content-Encoding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - コンテンツのエンコーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Content-Range
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - コンテンツレンジ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Content-Type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - のContent-Type
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A non-transparent proxy MAY modify or add these fields to a message that does not include no-transform, but if it does so, it MUST add a Warning 214 (Transformation applied) if one does not already appear in the message (see section 14.46).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非透過プロキシは、無変換含まれませんが、それがそうする場合は、1つは、すでにメッセージに表示されていない場合、それは警告214（変換が適用される）を追加しなければならないメッセージにこれらのフィールドを変更したり、追加MAY（セクションを参照してください14.46）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warning: unnecessary modification of end-to-end headers might cause authentication failures if stronger authentication mechanisms are introduced in later versions of HTTP. Such authentication mechanisms MAY rely on the values of header fields not listed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告：強力な認証メカニズムは、HTTPのそれ以降のバージョンで導入されている場合は、エンドツーエンドのヘッダーの不要な変更は、認証の失敗の原因となることがあります。このような認証メカニズムは、ここに記載されていないヘッダフィールドの値に依存してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-Length field of a request or response is added or deleted according to the rules in section 4.4. A transparent proxy MUST preserve the entity-length (section 7.2.2) of the entity-body, although it MAY change the transfer-length (section 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求又は応答のコンテンツ長フィールドは、セクション4.4の規則に従って追加または削除されています。それは転送長（セクション4.4）を変更することができるが、透過プロキシは、エンティティボディのエンティティ長さ（セクション7.2.2）を保持しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.3 Combining Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.3組み合わせるヘッダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a cache makes a validating request to a server, and the server provides a 304 (Not Modified) response or a 206 (Partial Content) response, the cache then constructs a response to send to the requesting client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、サーバーへの検証要求を行い、サーバは304（未修正）応答または206（部分コンテンツ）応答を提供する場合、キャッシュは、要求しているクライアントに送信する応答を構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the status code is 304 (Not Modified), the cache uses the entity-body stored in the cache entry as the entity-body of this outgoing response. If the status code is 206 (Partial Content) and the ETag or Last-Modified headers match exactly, the cache MAY combine the contents stored in the cache entry with the new contents received in the response and use the result as the entity-body of this outgoing response, (see 13.5.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータスコードは304（未修正）された場合、キャッシュは、この発信応答のエンティティボディとしてキャッシュエントリに格納されたエンティティボディを使用します。ステータスコードが206（部分コンテンツ）であるとのETagまたはLast-Modifiedのヘッダが完全に一致した場合は、新しい内容でキャッシュエントリに格納されたコンテンツを組み合わせることができるキャッシュは応答して受信し、のエンティティボディとして結果を使用しますこの送信応答、（13.5.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The end-to-end headers stored in the cache entry are used for the constructed response, except that
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュエントリに格納されたエンド・ツー・エンドのヘッダはことを除いて、構築応答に使用されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- any stored Warning headers with warn-code 1xx (see section 14.46) MUST be deleted from the cache entry and the forwarded response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 警告コード1XX（セクション14.46を参照）を有する任意の格納された警告ヘッダはキャッシュエントリと転送応答から削除されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- any stored Warning headers with warn-code 2xx MUST be retained in the cache entry and the forwarded response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 警告コード2XXを有する任意の格納された警告ヘッダはキャッシュエントリと転送応答して保持されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- any end-to-end headers provided in the 304 or 206 response MUST replace the corresponding headers from the cache entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  304または206応答して提供される任意のエンド・ツー・エンドヘッダはキャッシュエントリから対応するヘッダーを交換しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unless the cache decides to remove the cache entry, it MUST also replace the end-to-end headers stored with the cache entry with corresponding headers received in the incoming response, except for Warning headers as described immediately above. If a header field-name in the incoming response matches more than one header in the cache entry, all such old headers MUST be replaced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、キャッシュエントリを削除することを決定しない限り、それはまた、対応するヘッダを持つキャッシュエントリに格納されたエンドツーエンドのヘッダを交換する必要があり、直ちに上記のようにヘッダ警告を除いて、着信応答して受信。入ってきたレスポンスのヘッダフィールド名がキャッシュエントリに複数のヘッダと一致する場合、そのようなすべての古いヘッダを交換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In other words, the set of end-to-end headers received in the incoming response overrides all corresponding end-to-end headers stored with the cache entry (except for stored Warning headers with warn-code 1xx, which are deleted even if not overridden).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
換言すれば、エンド・ツー・エンドのヘッダのセットは、着信応答して受信された削除されてもされていない警告コード1XXと格納された警告ヘッダを除いて（キャッシュエントリに格納されているすべての対応するエンドツーエンドのヘッダをオーバーライド上書き）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: this rule allows an origin server to use a 304 (Not Modified) or a 206 (Partial Content) response to update any header associated with a previous response for the same entity or sub-ranges thereof, although it might not always be meaningful or correct to do so. This rule does not allow an origin server to use a 304 (Not Modified) or a 206 (Partial Content) response to entirely delete a header that it had provided with a previous response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：このルールはオリジンサーバが同じエンティティまたはその部分範囲の以前の応答に関連する任意のヘッダを更新する304（変更せず）又は206（部分コンテンツ）応答を使用することができ、それは必ずしも意味がないかもしれないがあるいはそうすることが正しいです。この規則は、オリジンサーバが完全にそれが以前のレスポンスを提供していたヘッダを削除するには、304（変更不可）または206（部分コンテンツ）応答を使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.4 Combining Byte Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.4バイト範囲を組み合わせます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A response might transfer only a subrange of the bytes of an entity-body, either because the request included one or more Range specifications, or because a connection was broken prematurely. After several such transfers, a cache might have received several ranges of the same entity-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答は、要求は、1つ以上の範囲の仕様が含まれているため、または接続が早期に破壊されたためのいずれかで、エンティティボディのバイトのサブレンジのみを転送するかもしれません。いくつかのような転送の後、キャッシュは同じエンティティボディのいくつかの範囲を受け取っている場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a cache has a stored non-empty set of subranges for an entity, and an incoming response transfers another subrange, the cache MAY combine the new subrange with the existing set if both the following conditions are met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュがエンティティに対するサブレンジの保存された非空のセットを持って、着信応答が別のサブレンジを転送した場合は、次の両方の条件が満たされた場合、キャッシュは既存のセットと新しいサブレンジを組み合わせることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Both the incoming response and the cache entry have a cache validator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 受信応答とキャッシュエントリの両方がキャッシュバリデータを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The two cache validators match using the strong comparison function (see section 13.3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  2つのキャッシュバリデータは、強力な比較機能（セクション13.3.3を参照）を使用して一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If either requirement is not met, the cache MUST use only the most recent partial response (based on the Date values transmitted with every response, and using the incoming response if these values are equal or missing), and MUST discard the other partial information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれかの要件が満たされていない場合、キャッシュは、最新のパーシャルレスポンス（すべての応答で送信日付値に基づいて、これらの値が等しいか、不足している場合、着信応答を使用）を使用しなければならない、と他の部分的な情報を捨てなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6 Caching Negotiated Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6キャッシング交渉の回答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Use of server-driven content negotiation (section 12.1), as indicated by the presence of a Vary header field in a response, alters the conditions and procedure by which a cache can use the response for subsequent requests. See section 14.44 for use of the Vary header field by servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ主導型コンテンツネゴシエーション（セクション12.1）の使用は、応答が変化するヘッダフィールドの存在によって示されるように、キャッシュは後続の要求に対する応答を使用することが可能な条件及び手順を変更します。サーバによって異なるヘッダフィールドを使用するためのセクション14.44を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server SHOULD use the Vary header field to inform a cache of what request-header fields were used to select among multiple representations of a cacheable response subject to server-driven negotiation. The set of header fields named by the Vary field value is known as the &#34;selecting&#34; request-headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、ザ・リクエスト・ヘッダー・フィールドは、サーバ駆動型ネゴシエーションにキャッシュ可能な応答対象の複数の表現の間で選択するために使用されたもののキャッシュに通知するヘッダフィールドを変化使用すべきです。ヴァリフィールド値によって指定されたヘッダフィールドのセットは、「選択」リクエストヘッダとして知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the cache receives a subsequent request whose Request-URI specifies one or more cache entries including a Vary header field, the cache MUST NOT use such a cache entry to construct a response to the new request unless all of the selecting request-headers present in the new request match the corresponding stored request-headers in the original request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、そのリクエストURIヴァリヘッダフィールドを含む1つ以上のキャッシュエントリを指定する選択要求ヘッダーのすべてに存在しない限り、キャッシュが新しい要求に対する応答を構築するために、このようなキャッシュ・エントリを使用してはいけません、その後の要求を受信した場合新しいリクエストは、元の要求に対応する格納されたリクエストヘッダを一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The selecting request-headers from two requests are defined to match if and only if the selecting request-headers in the first request can be transformed to the selecting request-headers in the second request by adding or removing linear white space (LWS) at places where this is allowed by the corresponding BNF, and/or combining multiple message-header fields with the same field name following the rules about message headers in section 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2つの要求場合に一致するように定義され、最初の要求で選択要求ヘッダは場所に線形空白（LWS）を追加または削除することによって第2の要求で選択要求ヘッダーに変換することができる場合にのみ、から選択リクエストヘッダここで、これは、対応するBNFによって許可され、および/またはセクション4.2におけるメッセージヘッダに関する規則以下同じフィールド名を持つ複数のメッセージヘッダフィールドを組み合わせています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Vary header field-value of &#34;*&#34; always fails to match and subsequent requests on that resource can only be properly interpreted by the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aは、「*」のヘッダフィールド値が常に一致するように失敗し、そのリソース上の後続の要求のみを適切にオリジンサーバによって解釈することができます変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the selecting request header fields for the cached entry do not match the selecting request header fields of the new request, then the cache MUST NOT use a cached entry to satisfy the request unless it first relays the new request to the origin server in a conditional request and the server responds with 304 (Not Modified), including an entity tag or Content-Location that indicates the entity to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュされたエントリのための選択要求ヘッダフィールドは、新しい要求の選択要求ヘッダフィールドと一致しない場合は、最初の条件付きでオリジンサーバに新しい要求を中継しない限り、キャッシュは、要求を満たすためにキャッシュされたエントリを使用してはなりません要求とサーバが使用するエンティティを表すエンティティタグやコンテンツの場所を含め、（変更不可）304で応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an entity tag was assigned to a cached representation, the forwarded request SHOULD be conditional and include the entity tags in an If-None-Match header field from all its cache entries for the resource. This conveys to the server the set of entities currently held by the cache, so that if any one of these entities matches the requested entity, the server can use the ETag header field in its 304 (Not Modified) response to tell the cache which entry is appropriate. If the entity-tag of the new response matches that of an existing entry, the new response SHOULD be used to update the header fields of the existing entry, and the result MUST be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグがキャッシュされた表現に割り当てられている場合、転送された要求は、条件付きであるとリソースのすべてのキャッシュ・エントリからIf-None-Matchヘッダフィールドのエンティティタグを含むべきです。これらのエンティティのいずれかが要求されたエンティティと一致した場合、サーバはどのエントリキャッシュを伝えるためにその304（未修正）応答にETagヘッダフィールドを使用できるように、これは、サーバーに現在キャッシュに保持されているエンティティのセットを伝えます適切です。新しいレスポンスのエンティティタグが既存のエントリと一致する場合、新たな応答は、既存のエントリのヘッダ・フィールドを更新するために使用する必要があり、その結果がクライアントに返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If any of the existing cache entries contains only partial content for the associated entity, its entity-tag SHOULD NOT be included in the If-None-Match header field unless the request is for a range that would be fully satisfied by that entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
既存のキャッシュエントリのいずれかが関連するエンティティのための唯一の部分コンテンツが含まれている場合は、要求が完全にそのエントリによって満たされることになる範囲である場合を除き、そのエンティティタグはIf-None-Matchヘッダフィールドに含まれるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a cache receives a successful response whose Content-Location field matches that of an existing cache entry for the same Request-]URI, whose entity-tag differs from that of the existing entry, and whose Date is more recent than that of the existing entry, the existing entry SHOULD NOT be returned in response to future requests and SHOULD be deleted from the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュはその内容、場所フィールドと一致する正常な応答を受信した場合、エンティティタグ既存のエントリ、のとは異なり、その日に同じ要求 - ] URIのための既存のキャッシュエントリのそれは、既存のものよりも新しいですエントリは、既存のエントリは、将来の要求に応じて返されるべきではなく、キャッシュから削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.7 Shared and Non-Shared Caches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.7共有および非共有キャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For reasons of security and privacy, it is necessary to make a distinction between &#34;shared&#34; and &#34;non-shared&#34; caches. A non-shared cache is one that is accessible only to a single user. Accessibility in this case SHOULD be enforced by appropriate security mechanisms. All other caches are considered to be &#34;shared.&#34; Other sections of this specification place certain constraints on the operation of shared caches in order to prevent loss of privacy or failure of access controls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティとプライバシーの理由から、「共有」と「非共有」キャッシュ間の区別をする必要があります。非共有キャッシュは、単一のユーザにアクセス可能なものです。この場合、アクセシビリティは、適切なセキュリティメカニズムによって施行されるべきです。他のすべてのキャッシュは「共有」していると考えられます共有キャッシュの動作に一定の制約この仕様の場所の他のセクションプライバシーやアクセス制御の失敗の損失を防止するためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.8 Errors or Incomplete Response Cache Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.8エラーや不完全なレスポンスキャッシュの動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A cache that receives an incomplete response (for example, with fewer bytes of data than specified in a Content-Length header) MAY store the response. However, the cache MUST treat this as a partial response. Partial responses MAY be combined as described in section 13.5.4; the result might be a full response or might still be partial. A cache MUST NOT return a partial response to a client without explicitly marking it as such, using the 206 (Partial Content) status code. A cache MUST NOT return a partial response using a status code of 200 (OK).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（例えば、Content-Lengthヘッダで指定されたよりも、データの少ないバイトを有する）の不完全な応答を受信したキャッシュは、応答を格納することができます。しかし、キャッシュはパーシャルレスポンスとしてこれを扱わなければなりません。セクション13.5.4に記載されているように、部分的応答を組み合わせてもよいです。結果は完全なレスポンスかもしれませんか、まだ部分的かもしれません。キャッシュは206（部分コンテンツ）ステータスコードを使用して、明示的にそのようにマーキングすることなく、クライアントへの部分的な応答を返してはなりません。キャッシュは、200（OK）のステータスコードを使用して、部分的な応答を返してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a cache receives a 5xx response while attempting to revalidate an entry, it MAY either forward this response to the requesting client, or act as if the server failed to respond. In the latter case, it MAY return a previously received response unless the cached entry includes the &#34;must-revalidate&#34; cache-control directive (see section 14.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エントリを再検証しようとしたときにキャッシュが5xxの応答を受信した場合、要求元のクライアントにこのレスポンスを転送することができるのいずれか、またはサーバが応答に失敗したかのように行動します。キャッシュされたエントリが「マスト再検証」キャッシュ制御ディレクティブ（セクション14.9を参照）を備えていない限り、後者の場合には、以前に受信したレスポンスを返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.9 Side Effects of GET and HEAD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
GETとHEADの13.9副作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unless the origin server explicitly prohibits the caching of their responses, the application of GET and HEAD methods to any resources SHOULD NOT have side effects that would lead to erroneous behavior if these responses are taken from a cache. They MAY still have side effects, but a cache is not required to consider such side effects in its caching decisions. Caches are always expected to observe an origin server&#39;s explicit restrictions on caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバは明示的にその応答のキャッシュを禁止していない限り、すべてのリソースへのGETとHEADメソッドのアプリケーションは、これらの応答がキャッシュから取られている場合、誤った行動につながる副作用を持つべきではありません。彼らはまだ副作用があるかもしれませんが、キャッシュはそのキャッシング決定において、このような副作用を考慮することが必要とされていません。キャッシュは常にキャッシュ上のオリジンサーバの明示的な制限を遵守することが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We note one exception to this rule: since some applications have traditionally used GETs and HEADs with query URLs (those containing a &#34;?&#34; in the rel_path part) to perform operations with significant side effects, caches MUST NOT treat responses to such URIs as fresh unless the server provides an explicit expiration time. This specifically means that responses from HTTP/1.0 servers for such URIs SHOULD NOT be taken from a cache. See section 9.1.1 for related information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは、このルールに例外を注意：一部のアプリケーションでは、伝統的に使用しているので、（rel_pathの一部に含むもの「？」）をクエリのURLでGETおよびヘッド重大な副作用を使用して操作を実行するために、キャッシュが新鮮なようなURIに応答を扱うてはなりませんサーバーは、明示的な有効期限を提供していない限り。これは、具体的には、URIのHTTPからの応答/ 1.0のサーバーがキャッシュから取られるべきではないことを意味しています。関連情報については、セクション9.1.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.10 Invalidation After Updates or Deletions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
更新または削除した後、13.10の無効化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The effect of certain methods performed on a resource at the origin server might cause one or more existing cache entries to become non-transparently invalid. That is, although they might continue to be &#34;fresh,&#34; they do not accurately reflect what the origin server would return for a new request on that resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバのリソース上で実行される特定の方法の効果は、1つの以上の既存のキャッシュエントリが非透過無効になる場合があります。それは、彼らがであり続けるかもしれないが、「新鮮な、」彼らは正確にオリジンサーバはそのリソース上の新しい要求のために戻ってくるものを反映していない、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is no way for the HTTP protocol to guarantee that all such cache entries are marked invalid. For example, the request that caused the change at the origin server might not have gone through the proxy where a cache entry is stored. However, several rules help reduce the likelihood of erroneous behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPプロトコルでは、そのようなすべてのキャッシュエントリが無効とマークされることを保証する方法はありません。例えば、オリジンサーバに変更を生じたリクエストはキャッシュエントリが保存されているプロキシを経ていない可能性があります。しかし、いくつかのルールは誤った行動の可能性を減らすのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this section, the phrase &#34;invalidate an entity&#34; means that the cache will either remove all instances of that entity from its storage, or will mark these as &#34;invalid&#34; and in need of a mandatory revalidation before they can be returned in response to a subsequent request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、フレーズ「エンティティを無効には、」キャッシュがそのストレージからそのエンティティのすべてのインスタンスを削除するか、または、彼らはに応じて返すことができます前に、「無効」と必須の再検証の必要があるとして、これらをマークすることを意味します後続の要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some HTTP methods MUST cause a cache to invalidate an entity. This is either the entity referred to by the Request-URI, or by the Location or Content-Location headers (if present). These methods are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのHTTPメソッドは、エンティティを無効にするキャッシュを起こす必要があります。これは、いずれかのエンティティは、Request-URIによって参照される、又はロケーション若しくはコンテンツロケーションヘッダー（存在する場合）によります。これらのメソッドは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- PUT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  PUT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- DELETE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  DELETE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- POST
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 役職
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to prevent denial of service attacks, an invalidation based on the URI in a Location or Content-Location header MUST only be performed if the host part is the same as in the Request-URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホスト部分がRequest-URIと同じである場合、サービス拒否攻撃を防止するために、場所またはコンテンツロケーションヘッダにURIに基づいて、無効化のみを実行しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A cache that passes through requests for methods it does not understand SHOULD invalidate any entities referred to by the Request-URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは理解していないメソッドの要求を通過したキャッシュは、Request-URIで参照されるすべてのエンティティを無効にすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.11 Write-Through Mandatory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.11ライトスルー必須
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All methods that might be expected to cause modifications to the origin server&#39;s resources MUST be written through to the origin server. This currently includes all methods except for GET and HEAD. A cache MUST NOT reply to such a request from a client before having transmitted the request to the inbound server, and having received a corresponding response from the inbound server. This does not prevent a proxy cache from sending a 100 (Continue) response before the inbound server has sent its final reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバのリソースへの変更を引き起こすことが予想されるすべてのメソッドは、オリジンサーバに通じ書かなければなりません。これは現在GETとHEAD以外のすべての方法を含みます。インバウンドサーバにリクエストを送信した、と受信サーバーから対応する応答を受信した前にキャッシュは、クライアントから、このような要求に応答してはなりません。これは、受信サーバーがその最終的な返事を送った前に、100（続行）応答を送信プロキシキャッシュを防ぐことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The alternative (known as &#34;write-back&#34; or &#34;copy-back&#34; caching) is not allowed in HTTP/1.1, due to the difficulty of providing consistent updates and the problems arising from server, cache, or network failure prior to write-back.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（「ライトバック」または「コピー・バック」キャッシュとして知られている）の代替が原因書込み禁止する前に、一貫した更新と、サーバ、キャッシュ、またはネットワーク障害から生じる問題を提供することの難しさに、HTTP / 1.1で許可されていませんバック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.12 Cache Replacement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.12キャッシュ置換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a new cacheable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8) response is received from a resource while any existing responses for the same resource are cached, the cache SHOULD use the new response to reply to the current request. It MAY insert it into cache storage and MAY, if it meets all other requirements, use it to respond to any future requests that would previously have caused the old response to be returned. If it inserts the new response into cache storage the rules in section 13.5.3 apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じリソースに対する既存のレスポンスがキャッシュされている間に、新しいキャッシュ可能なレスポンスがリソースから受信される（セクション14.9.2、13.2.5、13.2.6および13.8を参照）した場合、キャッシュは現在に返信する新しいレスポンスを使用すべきです要求。それは他のすべての要件を満たしている場合は、以前の古いレスポンスが返される原因となったであろう将来の要求に応えるためにそれを使用して、キャッシュの保存およびMAYにそれを挿入することができます。それはキャッシュストレージに新しい応答を挿入した場合はセクション13.5.3のルールが適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: a new response that has an older Date header value than existing cached responses is not cacheable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：既存のキャッシュされた応答よりも古いDateヘッダ値を持つ新しいレスポンスはキャッシュ可能ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.13 History Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.13履歴リスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
User agents often have history mechanisms, such as &#34;Back&#34; buttons and history lists, which can be used to redisplay an entity retrieved earlier in a session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーエージェントは、多くの場合、このようなセッションで、以前取得したエンティティを再表示するために使用することができ、「戻る」ボタンと履歴リスト、など歴史メカニズムを、持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
History mechanisms and caches are different. In particular history mechanisms SHOULD NOT try to show a semantically transparent view of the current state of a resource. Rather, a history mechanism is meant to show exactly what the user saw at the time when the resource was retrieved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
履歴メカニズムとキャッシュは異なります。特に履歴メカニズムはリソースの現在の状態の意味的に透視図を表示しないようにしてください。むしろ、履歴メカニズムはリソースが取得されたときに、ユーザが一度に見て正確に何を表示するように意図されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By default, an expiration time does not apply to history mechanisms. If the entity is still in storage, a history mechanism SHOULD display it even if the entity has expired, unless the user has specifically configured the agent to refresh expired history documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デフォルトでは、有効期限は履歴メカニズムには適用されません。実体がストレージ内に残っている場合、ユーザーが期限切れの歴史文書を更新するエージェントを特に設定していない限り、履歴メカニズムは、エンティティが期限切れになった場合でも、それが表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is not to be construed to prohibit the history mechanism from telling the user that a view might be stale.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、ビューが古いかもしれないユーザーに伝えるから履歴メカニズムを禁止すると解釈されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: if history list mechanisms unnecessarily prevent users from viewing stale resources, this will tend to force service authors to avoid using HTTP expiration controls and cache controls when they would otherwise like to. Service authors may consider it important that users not be presented with error messages or warning messages when they use navigation controls (such as BACK) to view previously fetched resources. Even though sometimes such resources ought not to cached, or ought to expire quickly, user interface considerations may force service authors to resort to other means of preventing caching (e.g. &#34;once-only&#34; URLs) in order not to suffer the effects of improperly functioning history mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：履歴リストメカニズムが不必要に古くなったリソースを表示してからユーザーを防ぐならば、これは彼らがそうしたいとき、HTTPの有効期限コントロールとキャッシュコントロールを使用しないように、サービス作成者を強制する傾向があります。サービス作成者は、それが重要な彼らは、以前にフェッチされたリソースを表示する（例えばBACKなど）のナビゲーションコントロールを使用する場合、ユーザーがエラーメッセージや警告メッセージが提示されていないことを考えることができます。にもかかわらず、時にはそのようなリソースは、ユーザインタフェースの考慮が不適切機能の影響を受けないようにするためにキャッシュを防止する他の手段（例えば、「一度だけ」のURL）に頼るサービス著者を強制することがあり、キャッシュされた、またはすぐに期限切れにするべきであるべきではありません歴史・メカニズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
14 Header Field Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
14のヘッダーフィールドの定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section defines the syntax and semantics of all standard HTTP/1.1 header fields. For entity-header fields, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、すべての標準HTTP / 1.1ヘッダフィールドの構文と意味論を定義します。エンティティヘッダフィールドの場合、送信者と受信者の両方を送信し、誰エンティティの受信者に応じて、クライアントまたはサーバのいずれかを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1 Accept
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1受け入れます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受け入れリクエストヘッダフィールドは、応答のために許容される特定のメディアタイプを指定するために使用することができます。受け入れヘッダは、要求は、特にインライン画像要求の場合のように、所望の種類の小さなセットに限定されることを示すために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Accept         = &#34;Accept&#34; &#34;:&#34;
                        #( media-range [ accept-params ] )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       media-range    = ( &#34;*/*&#34;
                        | ( type &#34;/&#34; &#34;*&#34; )
                        | ( type &#34;/&#34; subtype )
                        ) *( &#34;;&#34; parameter )
       accept-params  = &#34;;&#34; &#34;q&#34; &#34;=&#34; qvalue *( accept-extension )
       accept-extension = &#34;;&#34; token [ &#34;=&#34; ( token | quoted-string ) ]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The asterisk &#34;*&#34; character is used to group media types into ranges,
   with &#34;*/*&#34; indicating all media types and &#34;type/*&#34; indicating all
   subtypes of that type. The media-range MAY include media type
   parameters that are applicable to that range.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each media-range MAY be followed by one or more accept-params, beginning with the &#34;q&#34; parameter for indicating a relative quality factor. The first &#34;q&#34; parameter (if any) separates the media-range parameter(s) from the accept-params. Quality factors allow the user or user agent to indicate the relative degree of preference for that media-range, using the qvalue scale from 0 to 1 (section 3.9). The default value is q=1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各メディア範囲は、相対品質係数を示すための「Q」パラメータで始まる、一つ以上の-paramsはを受け入れるが続いてもよいです。最初の「Q」パラメータは（もしあれば）を受け入れる-paramsはからメディア範囲パラメータ（単数または複数）を分離します。品質係数は0から1（セクション3.9）へのqvalue尺度を使用して、ユーザーまたはユーザーエージェントは、そのメディア範囲に対する嗜好の相対的な程度を示すことを可能にします。デフォルト値はq = 1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Use of the &#34;q&#34; parameter name to separate media type parameters from Accept extension parameters is due to historical practice. Although this prevents any media type parameter named &#34;q&#34; from being used with a media range, such an event is believed to be unlikely given the lack of any &#34;q&#34; parameters in the IANA media type registry and the rare usage of any media type parameters in Accept. Future media types are discouraged from registering any parameter named &#34;q&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：拡張パラメータを受け入れるとは別のメディアタイプパラメータを「Q」パラメータ名の使用は歴史的な練習によるものです。これは、メディアの範囲で使用されることから、「Q」という名前の任意のメディアタイプパラメータを防ぎますが、このようなイベントは、IANAメディアタイプレジストリと任意のメディアタイプのまれな使用方法のいずれかの「Q」のパラメータの欠如与えられたそうであると考えられています受け入れのパラメータ。将来のメディアタイプは、「Q」という名前の任意のパラメータを登録することは推奨されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Accept: audio/*; q=0.2, audio/basic
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHOULD be interpreted as &#34;I prefer audio/basic, but send me any audio type if it is the best available after an 80% mark-down in quality.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「私は基本/オーディオ好むが、それは品質に80％のマークダウン後に利用可能な最善のであれば私に任意のオーディオタイプを送信してください。」と解釈されるべきです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If no Accept header field is present, then it is assumed that the client accepts all media types. If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何のAcceptヘッダーフィールドが存在しない場合、クライアントはすべてのメディアタイプを受け入れることが想定されます。 Acceptヘッダフィールドが存在し、サーバが受け入れる合成フィールドの値に応じて許容される応答を送信できない場合、サーバは406（許容できない）応答を送信するかどう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A more elaborate example is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
より複雑な例があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Verbally, this would be interpreted as &#34;text/html and text/x-c are the preferred media types, but if they do not exist, then send the text/x-dvi entity, and if that does not exist, send the text/plain entity.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
口頭で、これはテキスト/ htmlとテキスト/ XC」として解釈される好適なメディアタイプがありますが、それらが存在しない場合は、テキスト/ X-DVIエンティティを送信し、それが存在しない場合は、テキスト/平野を送信エンティティ。&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies to a given type, the most specific reference has precedence. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メディアの範囲は、より具体的なメディアの範囲または特定のメディアタイプで上書きすることができます。複数のメディアの範囲が指定されたタイプに適用された場合は、最も具体的な言及が優先されます。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Accept: text/*, text/html, text/html;level=1, */*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
have the following precedence:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の優先順位があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The media type quality factor associated with a given type is determined by finding the media range with the highest precedence which matches that type. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
所与のタイプに関連付けられたメディアタイプの品質係数は、そのタイプに一致する最も高い優先順位を有するメディア範囲を見つけることによって決定されます。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
would cause the following values to be associated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の値が関連していることが原因となります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3 image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: A user agent might be provided with a default set of quality values for certain media ranges. However, unless the user agent is a closed system which cannot interact with other rendering agents, this default set ought to be configurable by the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：ユーザエージェントは、あるメディアレンジのための品質値のデフォルトセットで提供される可能性があります。ユーザエージェントが他のレンダリングエージェントと対話することはできませんクローズドシステムである場合を除きしかし、このデフォルトセットは、ユーザが設定可能であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2 Accept-Charset
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2のAccept-文字セット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. This field allows clients capable of understanding more comprehensive or special-purpose character sets to signal that capability to a server which is capable of representing documents in those character sets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受け入れ、文字セットリクエストヘッダフィールドは、応答のために許容されるどんな文字セットを示すために使用することができます。このフィールドは、より包括的なまたは特殊目的の文字を理解できるクライアントは、これらの文字セットでドキュメントを表現することのできるサーバにその機能を通知するために設定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept-Charset = &#34;Accept-Charset&#34; &#34;:&#34; 1#( ( charset | &#34;*&#34; )[ &#34;;&#34; &#34;q&#34; &#34;=&#34; qvalue ] )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= &#34;同意-文字セット&#34; &#34; - 文字セットを受け入れる：&#34; 1＃（（文字セット| &#34;*&#34;）[ &#34;;&#34; &#34;Q&#34; &#34;=&#34; のqvalue]）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Character set values are described in section 3.4. Each charset MAY be given an associated quality value which represents the user&#39;s preference for that charset. The default value is q=1. An example is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文字セットの値は、セクション3.4に記載されています。各文字セットは、その文字セットに対するユーザの嗜好を表す関連付けられた品質値を与えられてもよいです。デフォルト値はq = 1です。例があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受け入れ、文字セット：ISO-8859-5、ユニコード1-1; Qが= 0.8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The special value &#34;*&#34;, if present in the Accept-Charset field, matches every character set (including ISO-8859-1) which is not mentioned elsewhere in the Accept-Charset field. If no &#34;*&#34; is present in an Accept-Charset field, then all character sets not explicitly mentioned get a quality value of 0, except for ISO-8859-1, which gets a quality value of 1 if not explicitly mentioned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特殊な値「*」は、受け入れ-文字セットのフィールドに存在する場合、他の場所でのAccept-文字セットのフィールドに記載されていない（ISO-8859-1を含む）すべての文字セットと一致します。何の「*」は受け入れ-文字セットのフィールドに存在しない場合、すべての文字がない明示的に言及したが、明示的に言及されていない場合は1の品質値を取得ISO-8859-1、を除いて、0の品質値を取得設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If no Accept-Charset header is present, the default is that any character set is acceptable. If an Accept-Charset header is present, and if the server cannot send a response which is acceptable according to the Accept-Charset header, then the server SHOULD send an error response with the 406 (not acceptable) status code, though the sending of an unacceptable response is also allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何のAccept-文字セットヘッダが存在しない場合、デフォルトでは、任意の文字セットが許容可能であるということです。受け入れ、文字セットヘッダが存在し、サーバーが受け入れ、文字セットヘッダに応じて許容される応答を送信できない場合、サーバは、送信が、406（許容できない）ステータスコードとエラー応答を送信する必要がある場合容認できない応答も許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3 Accept-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3のAccept-エンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Accept-Encoding request-header field is similar to Accept, but restricts the content-codings (section 3.5) that are acceptable in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept-Encodingリクエスト・ヘッダー・フィールドは、そのまま使用することが同様であるが、応答に許容される内容コーディング（セクション3.5）を制限します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept-Encoding = &#34;Accept-Encoding&#34; &#34;:&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受け入れエンコード= &#34;にAccept-エンコーディングを&#34; &#34;：&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 1#( codings [ &#34;;&#34; &#34;q&#34; &#34;=&#34; qvalue ] ) codings = ( content-coding | &#34;*&#34; )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1＃（コーディング[ &#34;;&#34; &#34;Q&#34; &#34;=&#34; のqvalue]）コーディング=（| &#34;*&#34; コンテンツコーディング）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Examples of its use are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その使用の例は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server tests whether a content-coding is acceptable, according to an Accept-Encoding field, using these rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
：コンテンツ・コーディングはこれらのルールを使用して、受け入れをコードフィールドによれば、許容可能であるか否かをサーバ・テスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. If the content-coding is one of the content-codings listed in the Accept-Encoding field, then it is acceptable, unless it is accompanied by a qvalue of 0. (As defined in section 3.9, a qvalue of 0 means &#34;not acceptable.&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ符号化のAccept-Encodingフィールドに記載されている内容コーディングのいずれかである場合、それは0（のqvalueを伴うされていない限り、セクション3.9で定義されているように1、それは、許容される、0手段のqvalue &#34;受け付けできません。&#34;）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. The special &#34;*&#34; symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.特別には「*」にAccept-Encodingフィールド内のシンボルは、任意の利用可能なコンテンツコードを明示的ヘッダフィールドにリストされていないと一致しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数のコンテンツ・コーディングが許容される場合3.その後に許容されるコンテンツコーディング最高非ゼロのqvalueを有することが好ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. The &#34;identity&#34; content-coding is always acceptable, unless specifically refused because the Accept-Encoding field includes &#34;identity;q=0&#34;, or because the field includes &#34;*;q=0&#34; and does not explicitly include the &#34;identity&#34; content-coding. If the Accept-Encoding field-value is empty, then only the &#34;identity&#34; encoding is acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールドが含まれているため、「Q 0 =同一性」、または「*; q = 0で」と明示的に「含まれていません。4.「アイデンティティ」コンテンツコーディングが受け入れ-Encodingフィールドが含まれているため、特に拒否しない限り、常に受け入れられますアイデンティティ」コンテンツコーディング。受け入れエンコードフィールド値が空の場合、唯一の「アイデンティティ」エンコードが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an Accept-Encoding field is present in a request, and if the server cannot send a response which is acceptable according to the Accept-Encoding header, then the server SHOULD send an error response with the 406 (Not Acceptable) status code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし受け入れエンコーディングフィールドは要求に存在し、サーバが受け入れる-Encodingヘッダに従って許容される応答を送信できない場合、サーバは406（許容できない）ステータスコードとエラー応答を送信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If no Accept-Encoding field is present in a request, the server MAY assume that the client will accept any content coding. In this case, if &#34;identity&#34; is one of the available content-codings, then the server SHOULD use the &#34;identity&#34; content-coding, unless it has additional information that a different content-coding is meaningful to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何のAccept-Encodingフィールドがリクエストに存在しない場合、サーバーは、クライアントがどんな内容コーディングを受け入れることを仮定してもよいです。この場合、「同一性」は、それが異なるコンテンツコードは、クライアントにとって意味のあることを、追加情報を持っていない限り、サーバーは、「アイデンティティ」コンテンツコーディングを使用すべきである、可能な内容コーディングの一つです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: If the request does not include an Accept-Encoding field, and if the &#34;identity&#34; content-coding is unavailable, then content-codings commonly understood by HTTP/1.0 clients (i.e.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：（要求のAccept-Encodingフィールドが含まれていない場合、および「同一性」は、コンテンツコードが利用できない場合、その後、内容コーディングは、一般に、HTTP / 1.0クライアントによって理解される、すなわち、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;gzip&#34; and &#34;compress&#34;) are preferred; some older clients improperly display messages sent with other content-codings. The server might also make this decision based on information about the particular user-agent or client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「GZIP」および「圧縮」）が好ましいです。一部の古いクライアントは不適切な他の内容コーディングで送信されたメッセージを表示します。また、サーバは、特定のユーザーエージェントまたはクライアントの情報に基づいて、この決定を行う可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Most HTTP/1.0 applications do not recognize or obey qvalues associated with content-codings. This means that qvalues will not work and are not permitted with x-gzip or x-compress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：ほとんどのHTTP / 1.0アプリケーションは、内容コーディングに関連したqvaluesを認識したり従いません。これはqvaluesは動作しませんし、X-gzipやX-圧縮で許可されていないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4 Accept-Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4受け入れ言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. Language tags are defined in section 3.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept-Languageリクエストヘッダフィールドは、そのまま使用することが同様であるが、要求に対する応答として好ましい自然言語のセットを制限します。言語タグは、セクション3.10で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Accept-Language = &#34;Accept-Language&#34; &#34;:&#34;
                         1#( language-range [ &#34;;&#34; &#34;q&#34; &#34;=&#34; qvalue ] )
       language-range  = ( ( 1*8ALPHA *( &#34;-&#34; 1*8ALPHA ) ) | &#34;*&#34; )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each language-range MAY be given an associated quality value which represents an estimate of the user&#39;s preference for the languages specified by that range. The quality value defaults to &#34;q=1&#34;. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各言語範囲は、その範囲で指定された言語に対するユーザの嗜好の推定値を表す関連する品質値を与えられてもよいです。 「Q = 1」に品質値をデフォルトとします。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept-Language: da, en-gb;q=0.8, en;q=0.7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受け入れ-言語：DA、EN-GB; Q = 0.8、EN; Q = 0.7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
would mean: &#34;I prefer Danish, but will accept British English and other types of English.&#34; A language-range matches a language-tag if it exactly equals the tag, or if it exactly equals a prefix of the tag such that the first tag character following the prefix is &#34;-&#34;. The special range &#34;*&#34;, if present in the Accept-Language field, matches every tag not matched by any other range present in the Accept-Language field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
意味するだろう：「私はデンマークを好むが、イギリス英語と英語の他のタイプを受け入れます。」 「 - 」それは正確にタグを等しい場合、またはそれが正確に接頭辞に続く最初のタグ文字があるように、タグの接頭辞と等しい場合、言語の範囲は、言語タグに一致します。特別な範囲「*」は、にAccept-Languageフィールドに存在する場合、受け入れる言語をフィールドに存在する任意の他の範囲で一致していないすべてのタグに一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: This use of a prefix matching rule does not imply that language tags are assigned to languages in such a way that it is always true that if a user understands a language with a certain tag, then this user will also understand all languages with tags for which this tag is a prefix. The prefix rule simply allows the use of prefix tags if this is the case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：接頭辞の一致ルールの使用は、その言語タグは、ユーザが特定のタグが付けられた言語を理解している場合、このユーザーはまた、タグですべての言語を理解することは常に真であるように言語に割り当てられている意味するものではありません。そのため、このタグは、接頭辞です。このような場合には、プレフィックス規則は単にプレフィックスタグの使用を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The language quality factor assigned to a language-tag by the Accept-Language field is the quality value of the longest language-range in the field that matches the language-tag. If no language-range in the field matches the tag, the language quality factor assigned is 0. If no Accept-Language header is present in the request, the server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept-Languageフィールドによって言語タグに割り当てられた言語の品質係数は、言語タグに一致するフィールドの中で最も長い言語範囲の品質値です。フィールドには、言語範囲がタグと一致しない場合は何のAccept-Languageヘッダーは、サーバ要求に存在しない場合、割り当てられた言語の品質係数は0です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHOULD assume that all languages are equally acceptable. If an Accept-Language header is present, then all languages which are assigned a quality factor greater than 0 are acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての言語が等しく受け入れられることを前提とすべきです。受け入れ言語をヘッダが存在する場合、すべての言語0より大きいが、許容される品質係数を割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It might be contrary to the privacy expectations of the user to send an Accept-Language header with the complete linguistic preferences of the user in every request. For a discussion of this issue, see section 15.1.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのリクエストで、ユーザの完全な言語的な好みでのAccept-Languageヘッダを送信するために、ユーザーのプライバシーの期待に反するかもしれません。この問題の議論については、セクション15.1.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As intelligibility is highly dependent on the individual user, it is recommended that client applications make the choice of linguistic preference available to the user. If the choice is not made available, then the Accept-Language header field MUST NOT be given in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
明瞭度は、個々の利用者に大きく依存しているとして、クライアントアプリケーションは、ユーザへの言語の好みの選択が利用できるようにすることをお勧めします。選択が利用できるようにされていない場合は、たAccept-Languageヘッダフィールドは、リクエストに与えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: When making the choice of linguistic preference available to the user, we remind implementors of the fact that users are not familiar with the details of language matching as described above, and should provide appropriate guidance. As an example, users might assume that on selecting &#34;en-gb&#34;, they will be served any kind of English document if British English is not available. A user agent might suggest in such a case to add &#34;en&#34; to get the best matching behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：ユーザーへの言語の好みの選択肢を利用可能にするとき、私たちは、ユーザーが上記のように、言語マッチングの詳細に精通していない、と適切なガイダンスを提供するべきであるという事実の実装を思い出させます。例として、ユーザは、イギリス英語が利用できない場合、彼らは英語の文書のいずれかの種類を提供されます「EN-GB」を選択の上にそれを想定することがあります。ユーザエージェントはベストマッチングの動作を取得するには、「EN」を追加するような場合にはお勧めかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5 Accept-Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5のAccept-範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      The Accept-Ranges response-header field allows the server to
      indicate its acceptance of range requests for a resource:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          Accept-Ranges     = &#34;Accept-Ranges&#34; &#34;:&#34; acceptable-ranges
          acceptable-ranges = 1#range-unit | &#34;none&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Origin servers that accept byte-range requests MAY send
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト範囲要求を受け入れるオリジンサーバは送るかもしれません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept-Ranges: bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受け入れ-範囲：バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
but are not required to do so. Clients MAY generate byte-range requests without having received this header for the resource involved. Range units are defined in section 3.12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、その必要はありません。クライアントは、関連するリソースのためにこのヘッダーを受信せずに、バイト範囲要求を生成してもよいです。レンジユニットは、セクション3.12で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers that do not accept any kind of range request for a resource MAY send
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リソースの範囲要求のいずれかの種類を受け入れないサーバは送るかもしれません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept-Ranges: none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受け入れ-範囲：なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
to advise the client not to attempt a range request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
範囲要求を試みないクライアントに助言します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.6 Age
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
１４。６ あげ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      The Age response-header field conveys the sender&#39;s estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is &#34;fresh&#34; if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in section 13.2.3.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           Age = &#34;Age&#34; &#34;:&#34; age-value
           age-value = delta-seconds
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Age values are non-negative decimal integers, representing time in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
年齢値は、秒単位の時間を表す、負でない小数の整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a cache receives a value larger than the largest positive integer it can represent, or if any of its age calculations overflows, it MUST transmit an Age header with a value of 2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST include an Age header field in every response generated from its own cache. Caches SHOULD use an arithmetic type of at least 31 bits of range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、最大の正の整数よりも大きな値を受信した場合には表すことができ、又はその年齢計算オーバーフローのいずれかの場合には、2147483648（2 ^ 31）の値と年齢ヘッダを送信しなければなりません。キャッシュを含むHTTP / 1.1サーバは、自身のキャッシュから生成されたすべての応答に年齢ヘッダフィールドを含まなければなりません。キャッシュは、範囲の少なくとも31ビットの算術型を使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.7 Allow
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.7許可
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      The Allow entity-header field lists the set of methods supported
      by the resource identified by the Request-URI. The purpose of this
      field is strictly to inform the recipient of valid methods
      associated with the resource. An Allow header field MUST be
      present in a 405 (Method Not Allowed) response.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Allow = &#34;Allow&#34; &#34;:&#34; #Method
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= &#34;は &#34;許可&#34; 許可：&#34; #Method
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example of use:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
使用例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Allow: GET, HEAD, PUT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
許可：GET、HEAD、PUT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This field cannot prevent a client from trying other methods. However, the indications given by the Allow header field value SHOULD be followed. The actual set of allowed methods is defined by the origin server at the time of each request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このフィールドは、他の方法を試してからクライアントを防ぐことはできません。しかし、許可ヘッダフィールド値によって与えられた指示に従わされるべきです。許可された方法の実際のセットは、各要求時に、オリジンサーバによって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Allow header field MAY be provided with a PUT request to recommend the methods to be supported by the new or modified resource. The server is not required to support these methods and SHOULD include an Allow header in the response giving the actual supported methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
許可ヘッダフィールドは、新規または変更されたリソースによってサポートされる方法を推奨するPUT要求を設けてもよいです。サーバは、これらのメソッドをサポートするために必要とされず、実際にサポートされている方法を与える応答して許可ヘッダーを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy MUST NOT modify the Allow header field even if it does not understand all the methods specified, since the user agent might have other means of communicating with the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザエージェントがオリジンサーバとの通信の他の手段を持っているかもしれないので、それは、指定されたすべてのメソッドを理解していない場合でも、プロキシはAllowヘッダーフィールドを変更してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.8 Authorization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.8認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      A user agent that wishes to authenticate itself with a server--
      usually, but not necessarily, after receiving a 401 response--does
      so by including an Authorization request-header field with the
      request.  The Authorization field value consists of credentials
      containing the authentication information of the user agent for
      the realm of the resource being requested.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authorization = &#34;Authorization&#34; &#34;:&#34; credentials
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証=「認可」「：」の資格情報
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP access authentication is described in &#34;HTTP Authentication: Basic and Digest Access Authentication&#34; [43]. If a request is authenticated and a realm specified, the same credentials SHOULD be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[43]：HTTPアクセス認証は、「基本とダイジェストアクセス認証HTTP認証」に記載されています。要求が認証され、領域が指定されている場合は、同じ資格情報が（例えば、チャレンジ値に応じて、または同期したクロックを用いて変化資格情報として、認証方式自体が他を必要としないと仮定して）、この領域内の他のすべての要求に対して有効である必要があり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a shared cache (see section 13.7) receives a request containing an Authorization field, it MUST NOT return the corresponding response as a reply to any other request, unless one of the following specific exceptions holds:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
共有キャッシュは（セクション13.7を参照）Authorizationフィールドを含むリクエストを受信すると、以下の特定の例外のいずれかが成立しない限り、それは、他の要求に対する応答として、対応する応答を返してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. If the response includes the &#34;s-maxage&#34; cache-control directive, the cache MAY use that response in replying to a subsequent request. But (if the specified maximum age has passed) a proxy cache MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request. (This is the defined behavior for s-maxage.) If the response includes &#34;s-maxage=0&#34;, the proxy MUST always revalidate it before re-using it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.応答は、「S-MAXAGE」キャッシュ制御ディレクティブが含まれている場合、キャッシュは、後続の要求に応答してその応答を使用するかもしれません。 （指定された最大年齢が経過している場合）でも、プロキシキャッシュは、最初のオリジンサーバが新しい要求を認証できるようにするために、新たなリクエストからリクエストヘッダを使用して、オリジンサーバでそれを再検証しなければなりません。応答が「= 0 S-MAXAGE」が含まれている場合（これは、S-MAXAGEための定義された動作である。）、プロキシは常にそれを再使用する前にそれを再検証しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. If the response includes the &#34;must-revalidate&#34; cache-control directive, the cache MAY use that response in replying to a subsequent request. But if the response is stale, all caches MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.応答が「MUST-再検証」キャッシュ制御ディレクティブが含まれている場合、キャッシュは、後続の要求に応答してその応答を使用するかもしれません。レスポンスが古くなっている場合でも、すべてのキャッシュは、最初のオリジンサーバが新しい要求を認証できるようにするために、新たなリクエストからリクエストヘッダを使用して、オリジンサーバでそれを再検証しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. If the response includes the &#34;public&#34; cache-control directive, it MAY be returned in reply to any subsequent request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.応答が「公共」キャッシュ制御ディレクティブが含まれている場合、それはそれ以降の要求に対する応答で返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9 Cache-Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9のCache-Control
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. The directives specify behavior intended to prevent caches from adversely interfering with the request or response. These directives typically override the default caching algorithms. Cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is to be given in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control一般ヘッダフィールドは、要求/応答チェーンに沿ったすべてのキャッシングメカニズムが従わなければならないディレクティブを指定するために使用されます。ディレクティブは、要求または応答に悪影響を及ぼすからキャッシュを行わないようにするための動作を指定します。これらのディレクティブは、通常、デフォルトのキャッシングアルゴリズムを上書きします。リクエスト内のディレクティブの存在は同じディレクティブは対応して与えられることにあることを意味するものではないという点で、キャッシュのディレクティブは単方向です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that HTTP/1.0 caches might not implement Cache-Control and might only implement Pragma: no-cache (see section 14.32).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュなし（項14.32を参照してください）：1.0キャッシュがのCache-Controlを実装していない可能性がありますとだけプラグマを実装するかもしれない/そのHTTPに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a cache-directive for a specific cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディレクティブは、要求/応答チェーンに沿ってすべての受信者に適用可能であるかもしれないので、キャッシュディレクティブは関係なく、そのアプリケーションに対するそれらの重要性の、プロキシまたはゲートウェイアプリケーションが通過しなければなりません。特定のキャッシュのキャッシュ・ディレクティブを指定することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control = &#34;Cache-Control&#34; &#34;:&#34; 1#cache-directive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control = &#34;のCache-Control&#34; &#34;：&#34; 1つの＃キャッシュディレクティブ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cache-directive = cache-request-directive | cache-response-directive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュ・ディレクティブ=キャッシュ要求ディレクティブ|キャッシュ・レスポンスディレクティブ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cache-request-directive = &#34;no-cache&#34; ; Section 14.9.1 | &#34;no-store&#34; ; Section 14.9.2 | &#34;max-age&#34; &#34;=&#34; delta-seconds ; Section 14.9.3, 14.9.4 | &#34;max-stale&#34; [ &#34;=&#34; delta-seconds ] ; Section 14.9.3 | &#34;min-fresh&#34; &#34;=&#34; delta-seconds ; Section 14.9.3 | &#34;no-transform&#34; ; Section 14.9.5 | &#34;only-if-cached&#34; ; Section 14.9.4 | cache-extension ; Section 14.9.6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュ・リクエスト・ディレクティブ=「キャッシュなし」。セクション14.9.1 | 「無店舗ません」。セクション14.9.2 | 「MAX-年齢」「=」デルタ - 秒。セクション14.9.3、14.9.4 | &#34;MAX-古い&#34; [ &#34;=&#34; デルタ秒];セクション14.9.3 | 「MIN-新鮮」「=」デルタ - 秒。セクション14.9.3 | 「無変換ありません」。セクション14.9.5 | 「キャッシュされただけ-場合、」;セクション14.9.4 |キャッシュの拡張;セクション14.9.6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cache-response-directive = &#34;public&#34; ; Section 14.9.1 | &#34;private&#34; [ &#34;=&#34; &lt;&#34;&gt; 1#field-name &lt;&#34;&gt; ] ; Section 14.9.1 | &#34;no-cache&#34; [ &#34;=&#34; &lt;&#34;&gt; 1#field-name &lt;&#34;&gt; ]; Section 14.9.1 | &#34;no-store&#34; ; Section 14.9.2 | &#34;no-transform&#34; ; Section 14.9.5 | &#34;must-revalidate&#34; ; Section 14.9.4 | &#34;proxy-revalidate&#34; ; Section 14.9.4 | &#34;max-age&#34; &#34;=&#34; delta-seconds ; Section 14.9.3 | &#34;s-maxage&#34; &#34;=&#34; delta-seconds ; Section 14.9.3 | cache-extension ; Section 14.9.6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュ・レスポンス・ディレクティブ=「公共」。セクション14.9.1 | &#34;プライベート&#34; [ &#34;=&#34; &lt; &#34;&gt; 1＃フィールド名&lt;&#34;&gt;];セクション14.9.1 | &#34;ノーキャッシュ&#34; [ &#34;=&#34; &lt; &#34;&gt; 1＃フィールド名&lt;&#34;&gt;]。セクション14.9.1 | 「無店舗ません」。セクション14.9.2 | 「無変換ありません」。セクション14.9.5 | 「-再検証しなければなりません」。セクション14.9.4 | 「プロキシ再検証」。セクション14.9.4 | 「MAX-年齢」「=」デルタ - 秒。セクション14.9.3 | &#34;S-MAXAGE&#34; &#34;=&#34; デルタ - 秒。セクション14.9.3 |キャッシュの拡張;セクション14.9.6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cache-extension = token [ &#34;=&#34; ( token | quoted-string ) ]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュ延長=トークン[「=」（トークン|引用符で囲まれた文字列）]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a directive appears without any 1#field-name parameter, the directive applies to the entire request or response. When such a directive appears with a 1#field-name parameter, it applies only to the named field or fields, and not to the rest of the request or response. This mechanism supports extensibility; implementations of future versions of the HTTP protocol might apply these directives to header fields not defined in HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディレクティブは任意の1＃フィールド名パラメータなしで表示された場合、ディレクティブは全体の要求または応答に適用されます。そのようなディレクティブは1＃フィールド名パラメーターを指定して表示されたら、それは要求または応答の残りの部分にのみ名前のフィールドまたはフィールドに適用され、そしてません。このメカニズムは、拡張性をサポートしています。 HTTPプロトコルの将来のバージョンの実装では、HTTP / 1.1で定義されていないフィールドをヘッダにこれらのディレクティブを適用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cache-control directives can be broken down into these general categories:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュ制御ディレクティブは、これらの一般的なカテゴリに分けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Restrictions on what are cacheable; these may only be imposed by the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - キャッシュ可能であるかの制限。これらはオリジンサーバによって課される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Restrictions on what may be stored by a cache; these may be imposed by either the origin server or the user agent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - キャッシュによって格納することができるものに制限。これらはオリジンサーバやユーザエージェントのどちらかによって課せられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Modifications of the basic expiration mechanism; these may be imposed by either the origin server or the user agent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 基本的な満期メカニズムの修正;これらはオリジンサーバやユーザエージェントのどちらかによって課せられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Controls over cache revalidation and reload; these may only be imposed by a user agent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - キャッシュ再検証とリロード統制。これらは、ユーザーエージェントによって課される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Control over transformation of entities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - エンティティの変換に対する制御。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Extensions to the caching system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - キャッシュシステムへの拡張。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.1 What is Cacheable
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.1キャッシュ可能とは何か
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By default, a response is cacheable if the requirements of the request method, request header fields, and the response status indicate that it is cacheable. Section 13.4 summarizes these defaults for cacheability. The following Cache-Control response directives allow an origin server to override the default cacheability of a response:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストメソッド、リクエストヘッダフィールド、応答ステータスの要件は、それがキャッシュ可能であることを示している場合、デフォルトで、応答がキャッシュ可能です。 13.4節は、キャッシュ可能性のために、これらのデフォルト値をまとめたもの。以下のCache-Controlレスポンス・ディレクティブは、オリジンサーバが応答のデフォルトのキャッシュ可能性を上書きすることができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
public Indicates that the response MAY be cached by any cache, even if it would normally be non-cacheable or cacheable only within a non-shared cache. (See also Authorization, section 14.8, for additional details.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
国民は応答が、それは通常、唯一の非共有キャッシュ内のキャッシュ不能またはキャッシュ可能だろうしても、任意のキャッシュによってキャッシュされることを示しています。 （詳細については、また許可、セクション14.8を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
private Indicates that all or part of the response message is intended for a single user and MUST NOT be cached by a shared cache. This allows an origin server to state that the specified parts of the response are intended for only one user and are not a valid response for requests by other users. A private (non-shared) cache MAY cache the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私的には、全部または応答メッセージの一部は、単一のユーザーを対象とし、共有キャッシュでキャッシュされてはならないことを示します。これは、オリジンサーバが応答の指定された部分が一つだけのユーザーを対象としており、他のユーザーによるリクエストに対する有効な応答ではありませんされていることを述べることができます。プライベート（非共有）キャッシュはレスポンスをキャッシュしてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Note: This usage of the word private only controls where the
       response may be cached, and cannot ensure the privacy of the
       message content.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
no-cache If the no-cache directive does not specify a field-name, then a cache MUST NOT use the response to satisfy a subsequent request without successful revalidation with the origin server. This allows an origin server to prevent caching even by caches that have been configured to return stale responses to client requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ノーキャッシュノーキャッシュディレクティブは、フィールド名を指定していない場合は、キャッシュがオリジンサーバに成功した再検証せずに後続の要求を満たすために応答を使用してはなりません。これも、クライアントの要求に古くなったレスポンスを返すように設定されているキャッシュによるキャッシングを防ぐために、オリジンサーバが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the no-cache directive does specify one or more field-names, then a cache MAY use the response to satisfy a subsequent request, subject to any other restrictions on caching. However, the specified field-name(s) MUST NOT be sent in the response to a subsequent request without successful revalidation with the origin server. This allows an origin server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュなしディレクティブは、1つまたは複数のフィールド名を指定しない場合、キャッシュは、キャッシュ上の他の制限を受ける後続の要求を満たすために応答を使用するかもしれません。ただし、指定したフィールド名（複数可）オリジンサーバで成功した再検証せずに次の要求に応答して送ってはいけません。これは、まだ応答の残りのキャッシングを可能にしながら、応答における特定のヘッダフィールドの再使用を防止するために、オリジンサーバが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Most HTTP/1.0 caches will not recognize or obey this directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：ほとんどのHTTP / 1.0キャッシュはこのディレクティブを認識したり従わないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.2 What May be Stored by Caches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.2キャッシュによって保存することができるどのような
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
no-store The purpose of the no-store directive is to prevent the inadvertent release or retention of sensitive information (for example, on backup tapes). The no-store directive applies to the entire message, and MAY be sent either in a response or in a request. If sent in a request, a cache MUST NOT store any part of either this request or any response to it. If sent in a response, a cache MUST NOT store any part of either this response or the request that elicited it. This directive applies to both non-shared and shared caches. &#34;MUST NOT store&#34; in this context means that the cache MUST NOT intentionally store the information in non-volatile storage, and MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無店舗ディレクティブの目的を無保管していない（例えば、バックアップテープ上の）機密情報の不注意な解放または保持を防ぐためです。無店舗ディレクティブはメッセージ全体に適用され、それに応答して、または要求のいずれかで送信されるかもしれません。リクエストで送信した場合、キャッシュはこのリクエストかそれへの応答のいずれかの任意の部分を格納してはなりません。応答で送信された場合、キャッシュはこのレスポンスやそれを誘発し、要求のいずれかの任意の部分を格納してはなりません。このディレクティブは非共有と共有の両方のキャッシュに適用されます。この文脈で「保存てはならない」キャッシュが意図的に不揮発性ストレージに情報を格納してはいけませんし、それを転送した後、できるだけ速やかに揮発性の記憶装置から情報を削除するにはベストエフォート型試みを作る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Even when this directive is associated with a response, users might explicitly store such a response outside of the caching system (e.g., with a &#34;Save As&#34; dialog). History buffers MAY store such responses as part of their normal operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このディレクティブは、応答に関連付けられている場合でも、ユーザーが明示的に（ダイアログ「名前を付けて保存」で、例えば）キャッシュシステムの外にそのような応答を保存することがあります。履歴バッファは、それらの通常の操作の一部として、このような応答を格納することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The purpose of this directive is to meet the stated requirements of certain users and service authors who are concerned about accidental releases of information via unanticipated accesses to cache data structures. While the use of this directive might improve privacy in some cases, we caution that it is NOT in any way a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このディレクティブの目的は、データ構造をキャッシュする予期せぬアクセスを介した情報の不慮のリリースを懸念している特定のユーザーとサービス作者の述べた要件を満たすことです。このディレクティブを使用すると、いくつかのケースでは、プライバシーを向上させるかもしれませんが、我々はそれがどのような方法で、プライバシーを確​​保するための信頼できるか、十分なメカニズムではないことを警告します。特に、悪意のあるまたは妥協キャッシュは認識したり、このディレクティブを遵守し、通信ネットワークは盗聴に対して脆弱であるかもしれないではないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.3 Modifications of the Basic Expiration Mechanism
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
基本的な有効期限機構の14.9.3変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The expiration time of an entity MAY be specified by the origin server using the Expires header (see section 14.21). Alternatively, it MAY be specified using the max-age directive in a response. When the max-age cache-control directive is present in a cached response, the response is stale if its current age is greater than the age value given (in seconds) at the time of a new request for that resource. The max-age directive on a response implies that the response is cacheable (i.e., &#34;public&#34;) unless some other, more restrictive cache directive is also present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティの有効期限は、有効期限ヘッダを使用して、オリジンサーバによって指定することができる（セクション14.21を参照）。また、それは応答のmax-ageディレクティブを使用して指定することができます。最大エージングキャッシュ制御ディレクティブは、キャッシュされたレスポンスに存在している場合は、その現在の年齢がそのリソースに対する新しい要求時に（秒）与えられた年齢値よりも大きい場合、レスポンスは古いです。応答上のmax-ageディレクティブは、他のいくつかの、より制限のキャッシュディレクティブも存在しない限り、応答が（すなわち、「パブリック」）キャッシュ可能であることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a response includes both an Expires header and a max-age directive, the max-age directive overrides the Expires header, even if the Expires header is more restrictive. This rule allows an origin server to provide, for a given response, a longer expiration time to an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be useful if certain HTTP/1.0 caches improperly calculate ages or expiration times, perhaps due to desynchronized clocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答は両方を含むヘッダとmax-ageディレクティブを満了した場合、ヘッダは、より限定的である有効期限も、最大エージングディレクティブは、Expiresヘッダを上書きします。このルールは、HTTP / 1.1（以降）に、与えられた応答のために、HTTP / 1.0キャッシュよりもキャッシュを長い有効期限を提供するために、オリジンサーバが可能になります。特定のHTTP / 1.0キャッシュが不適切おそらく非同期クロックに、年齢や有効期限を計算する場合に便利かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many HTTP/1.0 cache implementations will treat an Expires value that is less than or equal to the response Date value as being equivalent to the Cache-Control response directive &#34;no-cache&#34;. If an HTTP/1.1 cache receives such a response, and the response does not include a Cache-Control header field, it SHOULD consider the response to be non-cacheable in order to retain compatibility with HTTP/1.0 servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くのHTTP / 1.0キャッシュ実装はキャッシュ制御応答指令「キャッシュなし」と同等であるとして応答日付値以下の値を期限切れに扱います。 HTTP / 1.1キャッシュは、このような応答を受信し、応答がCache-Controlヘッダフィールドが含まれていない場合は、HTTP / 1.0のサーバとの互換性を保持するためにキャッシュ不能であることを応答を検討すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Note: An origin server might wish to use a relatively new HTTP
       cache control feature, such as the &#34;private&#34; directive, on a
       network including older caches that do not understand that
       feature. The origin server will need to combine the new feature
       with an Expires field whose value is less than or equal to the
       Date value. This will prevent older caches from improperly
       caching the response.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
s-maxage If a response includes an s-maxage directive, then for a shared cache (but not for a private cache), the maximum age specified by this directive overrides the maximum age specified by either the max-age directive or the Expires header. The s-maxage directive also implies the semantics of the proxy-revalidate directive (see section 14.9.4), i.e., that the shared cache must not use the entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server. The s-maxage directive is always ignored by a private cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
S-MAXAGE応答をS-MAXAGE指令が含まれている場合、（ただし、プライベートキャッシュの）共有キャッシュのために、このディレクティブによって指定された最大年齢はMAXAGEディレクティブまたは有効期限ヘッダのいずれかによって指定された最大年齢をオーバーライド。 S-MAXAGEディレクティブはまた、プロキシ再検証ディレクティブの意味を暗示し、それがその後の要求に応答するために古くなった後に共有キャッシュは最初にそれを再確認なしのエントリを使用してはならないこと、すなわち、（セクション14.9.4を参照してください）オリジンサーバ。 S-MAXAGEディレクティブは常に民間キャッシュによって無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that most older caches, not compliant with this specification, do not implement any cache-control directives. An origin server wishing to use a cache-control directive that restricts, but does not prevent, caching by an HTTP/1.1-compliant cache MAY exploit the requirement that the max-age directive overrides the Expires header, and the fact that pre-HTTP/1.1-compliant caches do not observe the max-age directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最も古いキャッシュは、この仕様に準拠していない、任意のキャッシュ制御ディレクティブを実装していないことに注意してください。オリジンサーバが制限キャッシュ制御ディレクティブを使用したいが、MAX-ageディレクティブはExpiresヘッダを上書きします要件を利用することができるHTTP / 1.1準拠のキャッシュにより、キャッシュを防ぐことはできませんし、実際にその前のHTTP /1.1-compliantキャッシュは、max-ageディレクティブを観察していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Other directives allow a user agent to modify the basic expiration mechanism. These directives MAY be specified on a request:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他のディレクティブは、ユーザエージェントが基本満期メカニズムを修正することができます。これらのディレクティブは、リクエストに応じて指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
max-age Indicates that the client is willing to accept a response whose age is no greater than the specified time in seconds. Unless max-stale directive is also included, the client is not willing to accept a stale response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最大エージングは​​、クライアントがその年齢秒で指定した時間よりも大きくない応答を受け入れることを望んでいることを示します。 MAX-古いディレクティブも含まれていない限り、クライアントは古くなったレスポンスを受け入れることを望んでいません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
min-fresh Indicates that the client is willing to accept a response whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
分-フレッシュは、クライアントがその新鮮生涯その現在の年齢プラス秒で指定された時間以上である応答を受け入れることを望んでいることを示します。これは、クライアントがまだ秒の少なくとも指定された数のために新鮮になります応答を望んでいる、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
max-stale Indicates that the client is willing to accept a response that has exceeded its expiration time. If max-stale is assigned a value, then the client is willing to accept a response that has exceeded its expiration time by no more than the specified number of seconds. If no value is assigned to max-stale, then the client is willing to accept a stale response of any age.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAX-古いは、クライアントがその有効期限を超過した応答を受け入れる用意があることを示します。 MAX-古いに値が割り当てられている場合、クライアントは、指定された秒数を超えないことによって、その有効期限を超過した応答を受け入れていく所存です。値がMAX-陳腐に割り当てられていない場合は、クライアントはすべての年齢の古い応答を受け入れていく所存です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a cache returns a stale response, either because of a max-stale directive on a request, or because the cache is configured to override the expiration time of a response, the cache MUST attach a Warning header to the stale response, using Warning 110 (Response is stale).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、いずれかのための要求にMAX-失効指示の失効応答を返した場合、キャッシュは、応答の有効期限を無効にするように構成されているため、あるいは、キャッシュが警告110を使用して、古くなった応答に警告ヘッダを添付しなければなりません（レスポンスは古くなっています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A cache MAY be configured to return stale responses without validation, but only if this does not conflict with any &#34;MUST&#34;-level requirements concerning cache validation (e.g., a &#34;must-revalidate&#34; cache-control directive).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、検証されずに古くなったレスポンスを返すように設定することができるが、これはキャッシュの検証（例えば、「MUST-再検証」キャッシュ制御ディレクティブ）に関する任意の「MUST」レベルの要件と競合しない場合にのみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If both the new request and the cached entry include &#34;max-age&#34; directives, then the lesser of the two values is used for determining the freshness of the cached entry for that request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい要求とキャッシュされたエントリの両方が「最大エージング」ディレクティブが含まれている場合、2つの値の小さい方がその要求のためにキャッシュされたエントリの鮮度を決定するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.4 Cache Revalidation and Reload Controls
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.4キャッシュの再検証と再読み込みコントロール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sometimes a user agent might want or need to insist that a cache revalidate its cache entry with the origin server (and not just with the next cache along the path to the origin server), or to reload its cache entry from the origin server. End-to-end revalidation might be necessary if either the cache or the origin server has overestimated the expiration time of the cached response. End-to-end reload may be necessary if the cache entry has become corrupted for some reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時には、ユーザーエージェントが欲しいかキャッシュがオリジンサーバ（だけでなく、オリジンサーバーへのパスに沿って次キャッシュを持つ）とのキャッシュエントリを再検証することを主張するために、またはオリジンサーバからそのキャッシュエントリをリロードする必要がある場合があります。キャッシュやオリジンサーバのどちらかがキャッシュされたレスポンスの有効期限を過大評価した場合、エンド・ツー・エンドの再検証が必要になる場合があります。キャッシュエントリが何らかの理由で破損した場合、エンド・ツー・エンドのリロードが必要になることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
End-to-end revalidation may be requested either when the client does not have its own local cached copy, in which case we call it &#34;unspecified end-to-end revalidation&#34;, or when the client does have a local cached copy, in which case we call it &#34;specific end-to-end revalidation.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、私たちは「不特定のエンド・ツー・エンドの再検証」と呼んで、その場合には、独自のローカルにキャッシュされたコピーを持っていない場合、エンドツーエンドの再検証は、いずれかを要求することができる、またはクライアントがローカルにキャッシュされたコピーを持っていたときに、中その場合、我々はそれを呼び出す「特定のエンド・ツー・エンドの再検証。」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client can specify these three kinds of action using Cache-Control request directives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはのCache-Control要求ディレクティブを使用して、アクションのこれらの3種類の指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
End-to-end reload The request includes a &#34;no-cache&#34; cache-control directive or, for compatibility with HTTP/1.0 clients, &#34;Pragma: no-cache&#34;. Field names MUST NOT be included with the no-cache directive in a request. The server MUST NOT use a cached copy when responding to such a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンドツーエンドの要求は「キャッシュなし」キャッシュ制御ディレクティブが含まれたり、HTTP / 1.0クライアントとの互換性のために、「プラグマ：キャッシュなし」リロード。フィールド名は、要求におけるキャッシュなしディレクティブに含んではいけません。そのような要求に応答するとき、サーバは、キャッシュされたコピーを使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Specific end-to-end revalidation The request includes a &#34;max-age=0&#34; cache-control directive, which forces each cache along the path to the origin server to revalidate its own entry, if any, with the next cache or server. The initial request includes a cache-validating conditional with the client&#39;s current validator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定のエンド・ツー・エンドの再検証要求があれば次のキャッシュまたはサーバーに、独自のエントリを再検証するために、オリジンサーバーへのパスに沿って各キャッシュを強制的に「MAX-年齢= 0」キャッシュ制御ディレクティブが含まれています。最初のリクエストは、キャッシュ・検証し、クライアントの現在のバリデータとの条件付き。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unspecified end-to-end revalidation The request includes &#34;max-age=0&#34; cache-control directive, which forces each cache along the path to the origin server to revalidate its own entry, if any, with the next cache or server. The initial request does not include a cache-validating conditional; the first cache along the path (if any) that holds a cache entry for this resource includes a cache-validating conditional with its current validator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
未指定のエンドツーエンド再検証要求があれば次のキャッシュまたはサーバーに、独自のエントリを再検証するために、オリジンサーバーへのパスに沿って各キャッシュを強制的に「MAX-年齢= 0」キャッシュ制御ディレクティブが含まれています。最初のリクエストは、キャッシュの検証の条件が含まれていません。このリソースのキャッシュ・エントリを保持するパス（もしあれば）に沿った第1のキャッシュは、キャッシュ検証現在のバリと条件を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
max-age When an intermediate cache is forced, by means of a max-age=0 directive, to revalidate its own cache entry, and the client has supplied its own validator in the request, the supplied validator might differ from the validator currently stored with the cache entry. In this case, the cache MAY use either validator in making its own request without affecting semantic transparency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最大エージング中間キャッシュが独自のキャッシュエントリを再検証するために、最大エージング= 0ディレクティブによって、強制され、そしてクライアントが要求して、独自のバリデータを提供してきました、供給バリデータは、現在保存されたバリデータと異なる場合がありますキャッシュエントリを持ちます。この場合、キャッシュは、意味の透明性に影響を与えることなく、独自の要求を行うことでバリデータのいずれかを使用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, the choice of validator might affect performance. The best approach is for the intermediate cache to use its own validator when making its request. If the server replies with 304 (Not Modified), then the cache can return its now validated copy to the client with a 200 (OK) response. If the server replies with a new entity and cache validator, however, the intermediate cache can compare the returned validator with the one provided in the client&#39;s request, using the strong comparison function. If the client&#39;s validator is equal to the origin server&#39;s, then the intermediate cache simply returns 304 (Not Modified). Otherwise, it returns the new entity with a 200 (OK) response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、バリデータの選択がパフォーマンスに影響を与える可能性があります。最善のアプローチは、その要求を行う際に、独自のバリデータを使用するための中間キャッシュのためです。サーバは304（変更不可）で応答した場合、キャッシュは200（OK）応答をクライアントに今、検証のコピーを返すことができます。サーバが新しいエンティティとキャッシュバリデータで応答した場合は、しかし、中間キャッシュは強い比較機能を使用して、クライアントの要求に提供される一つで返されたバリデータを比較することができます。クライアントのバリデータがオリジンサーバのと同じであれば、中間キャッシュは単純に304（変更されていない）を返します。それ以外の場合は、200（OK）応答で新しいエンティティを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a request includes the no-cache directive, it SHOULD NOT include min-fresh, max-stale, or max-age.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求はキャッシュなしのディレクティブが含まれている場合、それは、新鮮な最小最大 - 古い、または最大エージングを含めないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
only-if-cached In some cases, such as times of extremely poor network connectivity, a client may want a cache to return only those responses that it currently has stored, and not to reload or revalidate with the origin server. To do this, the client may include the only-if-cached directive in a request. If it receives this directive, a cache SHOULD either respond using a cached entry that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status. However, if a group of caches is being operated as a unified system with good internal connectivity, such a request MAY be forwarded within that group of caches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのケースでは、キャッシュされた場合にのみ、このような極めて悪いネットワーク接続の時間として、クライアントはキャッシュが現在保存されたことのみ応答を返すようにしたいことがあり、かつリロードまたはオリジンサーバで再検証しません。これを行うには、クライアントはリクエストでのみ-IF-キャッシュされたディレクティブを含むことができます。それはこの指令を受信した場合、キャッシュは、いずれかの要求の他の制約と一致しているキャッシュされたエントリを使用して応答する、または504（ゲートウェイタイムアウト）ステータスで応答する必要があります。キャッシュのグループが良好な内部接続で統一されたシステムとして動作している場合は、そのような要求は、キャッシュのそのグループ内で転送されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
must-revalidate Because a cache MAY be configured to ignore a server&#39;s specified expiration time, and because a client request MAY include a max-stale directive (which has a similar effect), the protocol also includes a mechanism for the origin server to require revalidation of a cache entry on any subsequent use. When the must-revalidate directive is present in a response received by a cache, that cache MUST NOT use the entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server. (I.e., the cache MUST do an end-to-end revalidation every time, if, based solely on the origin server&#39;s Expires or max-age value, the cached response is stale.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、サーバーの指定された有効期限を無視するように構成することができ、クライアントの要求は（同様の効果を持っている）MAX-古いディレクティブが含まれる可能性があるため、プロトコルはまた、再検証を要求するオリジンサーバのための機構を備えているため、再検証する必要があります任意のその後の使用上のキャッシュエントリの。必携再検証ディレクティブは、キャッシュが受信した応答中に存在する場合、それは最初にオリジンサーバとそれを再検証せずに、後続の要求に応答するために古くなった後、そのキャッシュエントリを使用してはなりません。 （のみに基づいて、場合つまり、キャッシュは、エンド・ツー・エンドの再検証を毎回行う必要がありますオリジンサーバの有効期限や最大エージング値は、キャッシュされたレスポンスが古くなっています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The must-revalidate directive is necessary to support reliable operation for certain protocol features. In all circumstances an HTTP/1.1 cache MUST obey the must-revalidate directive; in particular, if the cache cannot reach the origin server for any reason, it MUST generate a 504 (Gateway Timeout) response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必携再検証ディレクティブは、特定のプロトコル機能の信頼性の高い動作をサポートするために必要です。すべての状況ではHTTP / 1.1キャッシュは必見-再検証指示に従わなければなりません。キャッシュが何らかの理由でオリジンサーバに到達できない場合は特に、それは504（ゲートウェイタイムアウト）応答を生成しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers SHOULD send the must-revalidate directive if and only if failure to revalidate a request on the entity could result in incorrect operation, such as a silently unexecuted financial transaction. Recipients MUST NOT take any automated action that violates this directive, and MUST NOT automatically provide an unvalidated copy of the entity if revalidation fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは必見再検証指示を送るべきである場合に限り、そのような静かに未実行の金融取引として正しくない動作になる可能性が実体上の要求を再検証に失敗。受信者はこの指示に違反する自動化された行動を取るてはならない、と再検証が失敗した場合、自動的にエンティティの未検証のコピーを提供してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although this is not recommended, user agents operating under severe connectivity constraints MAY violate this directive but, if so, MUST explicitly warn the user that an unvalidated response has been provided. The warning MUST be provided on each unvalidated access, and SHOULD require explicit user confirmation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これはお勧めしませんが、厳しい接続制約の下で操作するユーザエージェントは、このディレクティブに違反するかもしれませんが、もしそうであれば、明示的に未検証のレスポンスが提供されたことをユーザーに警告しなければなりません。警告は、各未検証のアクセスに提供されなければならない、と明示的なユーザの確認を要求する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
proxy-revalidate The proxy-revalidate directive has the same meaning as the must-revalidate directive, except that it does not apply to non-shared user agent caches. It can be used on a response to an authenticated request to permit the user&#39;s cache to store and later return the response without needing to revalidate it (since it has already been authenticated once by that user), while still requiring proxies that service many users to revalidate each time (in order to make sure that each user has been authenticated). Note that such authenticated responses also need the public cache control directive in order to allow them to be cached at all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシ再検証ディレクティブをプロキシ再検証、非共有ユーザエージェントキャッシュには適用されないことを除いて、必見再検証ディレクティブと同じ意味を持っています。まだ必要としながら、プロキシはに多くのユーザー、サービス、保存し、後で（それはすでにそのユーザが一度認証されたので）それを再検証する必要なしに応答を返すために、ユーザーのキャッシュを可能にするために、認証要求への応答に使用することができます（各ユーザーが認証されていることを確認するために）毎回再検証。このように認証応答はまた、彼らはまったくキャッシュされることを可能にするために公共のキャッシュ制御ディレクティブが必要であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.5 No-Transform Directive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.5無変換指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
no-transform Implementors of intermediate caches (proxies) have found it useful to convert the media type of certain entity bodies. A non-transparent proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
中間キャッシュ（プロキシ）の無変換実装者は、それが有用な特定のエンティティボディのメディアタイプを変換することが分かってきました。非透過プロキシは、例えば、キャッシュスペースを節約するか、低速リンク上のトラフィックの量を削減するために、画像フォーマット間の変換可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Serious operational problems occur, however, when these transformations are applied to entity bodies intended for certain kinds of applications. For example, applications for medical imaging, scientific data analysis and those using end-to-end authentication, all depend on receiving an entity body that is bit for bit identical to the original entity-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの変換は、アプリケーションの特定の種類のために意図されたエンティティボディに適用した場合、深刻な操作上の問題は、しかし、起こります。例えば、医療用画像、科学的データ分析とエンドツーエンド認証を使用してそれらのためのアプリケーションは、すべての元のエンティティボディと同一ビットのビットであるエンティティボディを受信するに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Therefore, if a message includes the no-transform directive, an intermediate cache or proxy MUST NOT change those headers that are listed in section 13.5.2 as being subject to the no-transform directive. This implies that the cache or proxy MUST NOT change any aspect of the entity-body that is specified by these headers, including the value of the entity-body itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージが無変換命令を含む場合したがって、中間キャッシュまたはプロキシは、無変換指令を受けることとして、セクション13.5.2に記載されているこれらのヘッダを変更しないでください。これは、キャッシュまたはプロキシは、エンティティボディ自体の値を含むこれらのヘッダによって指定されるエンティティボディの任意の態様を変更してはいけませんことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.6 Cache Control Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9.6キャッシュ制御拡張機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Cache-Control header field can be extended through the use of one or more cache-extension tokens, each with an optional assigned value. Informational extensions (those which do not require a change in cache behavior) MAY be added without changing the semantics of other directives. Behavioral extensions are designed to work by acting as modifiers to the existing base of cache directives. Both the new directive and the standard directive are supplied, such that applications which do not understand the new directive will default to the behavior specified by the standard directive, and those that understand the new directive will recognize it as modifying the requirements associated with the standard directive. In this way, extensions to the cache-control directives can be made without requiring changes to the base protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュ制御ヘッダフィールドは、オプションの割り当てられた値を有する1つ以上のキャッシュ拡張トークン、それぞれの使用を通じて拡張することができます。情報の拡張（キャッシュの振る舞いの変更を必要としないもの）は、他のディレクティブの意味を変えずに追加される場合があります。行動拡張がキャッシュディレクティブの既存のベースへの修飾子として作用することによって動作するように設計されています。どちらも新しいディレクティブと標準ディレクティブは、新しいディレクティブを理解していないアプリケーションは、標準のディレクティブで指定された動作がデフォルトになりますように、供給され、新しいディレクティブを理解しているものは、標準的に関連付けられている要件を変更すると、それを認識します指令。このように、キャッシュ制御指令への拡張は、ベースプロトコルへの変更を必要とせずに行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This extension mechanism depends on an HTTP cache obeying all of the cache-control directives defined for its native HTTP-version, obeying certain extensions, and ignoring all directives that it does not understand.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この拡張メカニズムは、特定の拡張子に従うと、それは理解していないすべてのディレクティブを無視して、そのネイティブHTTP-バージョン用に定義されたキャッシュ制御ディレクティブのすべてに従うHTTPキャッシュに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, consider a hypothetical new response directive called community which acts as a modifier to the private directive. We define this new directive to mean that, in addition to any non-shared cache, any cache which is shared only by members of the community named within its value may cache the response. An origin server wishing to allow the UCI community to use an otherwise private response in their shared cache(s) could do so by including
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、プライベートディレクティブの修飾子として機能し、コミュニティと呼ばれる架空の新しい応答ディレクティブを考えます。私たちは、任意の非共有キャッシュに加えて、唯一のその値の範囲内という名前のコミュニティのメンバーによって共有されているすべてのキャッシュがレスポンスをキャッシュしてもよい、ということを意味するために、この新しいディレクティブを定義します。 UCIコミュニティは彼らの共有キャッシュ（複数可）で特に民間応答を使用できるようにしたいオリジンサーバは、以下を含むことによって行うことができ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control: private, community=&#34;UCI&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control：プライベート、コミュニティ= &#34;UCI&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A cache seeing this header field will act correctly even if the cache does not understand the community cache-extension, since it will also see and understand the private directive and thus default to the safe behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュはコミュニティのキャッシュ拡張を理解していない場合でも、それはまた、参照とプライベートディレクティブを理解し、したがって、安全な振る舞いをデフォルトとしますので、このヘッダフィールドを見キャッシュは、正しく動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unrecognized cache-directives MUST be ignored; it is assumed that any cache-directive likely to be unrecognized by an HTTP/1.1 cache will be combined with standard directives (or the response&#39;s default cacheability) such that the cache behavior will remain minimally correct even if the cache does not understand the extension(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認識できないキャッシュ・ディレクティブを無視しなければなりません。それが想定されているすべてのキャッシュ・ディレクティブキャッシュ動作は、キャッシュが拡張を理解していない場合でも、最小限正しいままにするような標準ディレクティブ（または応答のデフォルトのキャッシュ可能）と組み合わされるHTTP / 1.1キャッシュで認識できない可能性が高いです（秒）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.10 Connection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.10接続
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続一般的なヘッダフィールドは、送信者がその特定の接続のために所望され、さらに接続を介してプロキシによって通信されてはいけませんオプションを指定することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Connection header has the following grammar:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続ヘッダは、次の文法を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Connection = &#34;Connection&#34; &#34;:&#34; 1#(connection-token)
       connection-token  = token
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1プロキシはメッセージが転送される前に、接続ヘッダフィールドを解析して、各接続トークンは、この分野では、接続トークンと同じ名前を持つメッセージから任意のヘッダフィールド（複数可）を削除する必要があります。その接続オプションに関連付けられたパラメータがない場合は、追加ヘッダフィールドは送信されないかもしれないので、接続オプションは、接続ヘッダフィールドではなく、任意の対応する追加のヘッダフィールド（複数可）によって接続トークンの存在によってシグナリングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Message headers listed in the Connection header MUST NOT include end-to-end headers, such as Cache-Control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続ヘッダに記載されているメッセージヘッダーは、キャッシュ・コントロールのようなエンド・ツー・エンドのヘッダを含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 defines the &#34;close&#34; connection option for the sender to signal that the connection will be closed after completion of the response. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1接続が応答が完了した後に閉鎖されることを知らせるために、送信者のための「クローズ」接続オプションを定義します。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Connection: close
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続：近いです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
in either the request or the response header fields indicates that the connection SHOULD NOT be considered `persistent&#39; (section 8.1) after the current request/response is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求又は応答ヘッダフィールドのいずれかに現在の要求/応答が完了した後、接続が `永続」（セクション8.1）とみなされるべきではないことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 applications that do not support persistent connections MUST include the &#34;close&#34; connection option in every message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
持続的な接続をサポートしていないHTTP / 1.1のアプリケーションは、すべてのメッセージで「クローズ」接続オプションを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A system receiving an HTTP/1.0 (or lower-version) message that includes a Connection header MUST, for each connection-token in this field, remove and ignore any header field(s) from the message with the same name as the connection-token. This protects against mistaken forwarding of such header fields by pre-HTTP/1.1 proxies. See section 19.6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このフィールドの各接続トークン、connection-と同じ名前を持つメッセージから任意のヘッダフィールド（複数可）を削除し、無視しなければならない接続ヘッダを含むHTTP / 1.0（以下バージョン）メッセージを受信するシステムトークン。これは、事前HTTP / 1.1プロキシによって、このようなヘッダフィールドの誤った転送から保護します。セクション19.6.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.11 Content-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.11コンテンツのエンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a document to be compressed without losing the identity of its underlying media type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ符号化エンティティ - ヘッダフィールドはメディアタイプの修飾子として使用されます。存在する場合、その値は、追加のコンテンツコーディングが復号メカニズムはContent-Typeヘッダフィールドによって参照されるメディアタイプを得るために適用されなければならないもの、したがってエンティティボディに適用されてきたものを示しています。コンテンツのエンコーディングは、主に文書がその根底にあるメディアタイプのアイデンティティを失わずに圧縮することができるようにするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Encoding = &#34;Content-Encoding&#34; &#34;:&#34; 1#content-coding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツのエンコード=「コンテンツエンコード」「：」1＃内容コーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content codings are defined in section 3.5. An example of its use is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
内容コーディングはセクション3.5で定義されています。その使用の例があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Encoding: gzip
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツエンコード：gzipで
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The content-coding is a characteristic of the entity identified by the Request-URI. Typically, the entity-body is stored with this encoding and is only decoded before rendering or analogous usage. However, a non-transparent proxy MAY modify the content-coding if the new coding is known to be acceptable to the recipient, unless the &#34;no-transform&#34; cache-control directive is present in the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツコードは、Request-URIによって識別されるエンティティの特性です。典型的には、エンティティボディはこのエンコーディングで記​​憶されるのみレンダリングまたは類似の使用の前に復号されます。しかし、新たなコーディングが受信者に許容可能であることが知られている場合は非透過プロキシは、コンテンツコードを修正することができ、「無変換」キャッシュ制御ディレクティブない限り、メッセージ中に存在しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the content-coding of an entity is not &#34;identity&#34;, then the response MUST include a Content-Encoding entity-header (section 14.11) that lists the non-identity content-coding(s) used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティの内容コーディングは「同一」でない場合、応答は、使用される非同一（S）コンテンツコードを一覧表示し、コンテンツ符号化エンティティヘッダ（セクション14.11）を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the content-coding of an entity in a request message is not acceptable to the origin server, the server SHOULD respond with a status code of 415 (Unsupported Media Type).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求メッセージ内のエンティティの内容コーディングがオリジンサーバに対して許容できない場合、サーバは415（サポートされていないメディアタイプ）のステータスコードで応答すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If multiple encodings have been applied to an entity, the content codings MUST be listed in the order in which they were applied. Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数のエンコーディングがエンティティに適用されている場合は、コンテンツのコーディングは、それらが適用された順にリストされなければなりません。符号化パラメータに関する追加情報は、本明細書で定義されていない他のエンティティヘッダフィールドによって提供されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.12 Content-Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.12コンテンツの言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ言語エンティティヘッダフィールドは、同封のエンティティの対象読者の自然言語（複数可）を記述する。これは、エンティティボディ内で使用されるすべての言語と同等ではないかもしれないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Language = &#34;Content-Language&#34; &#34;:&#34; 1#language-tag
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ言語=の &#34;Content-言語&#34; &#34;：&#34; 1＃言語タグ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Language tags are defined in section 3.10. The primary purpose of Content-Language is to allow a user to identify and differentiate entities according to the user&#39;s own preferred language. Thus, if the body content is intended only for a Danish-literate audience, the appropriate field is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
言語タグは、セクション3.10で定義されています。コンテンツ言語の主な目的は、ユーザーがユーザー自身の好みの言語に応じて、エンティティを識別し、区別できるようにすることです。本文の内容のみデンマーク読み書き聴衆のために意図されている場合このように、適切なフィールドがあります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Language: da
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ言語：ダ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何のContent-言語が指定されていない場合、デフォルトでは、コンテンツは、すべての言語の視聴者のために意図されていることです。これは、送信者が、それは任意の自然言語に固有であると考えて、または送信者は、それが意図されている言語用の知らないことをしないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multiple languages MAY be listed for content that is intended for multiple audiences. For example, a rendition of the &#34;Treaty of Waitangi,&#34; presented simultaneously in the original Maori and English versions, would call for
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の言語では、複数の聴衆のために意図されているコンテンツのために表示されることがあります。たとえば、オリジナルのマオリ語版と英語版に同時に提示の演出「ワイタンギ条約は、」、のために呼び出します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Language: mi, en
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ言語：私、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, just because multiple languages are present within an entity does not mean that it is intended for multiple linguistic audiences. An example would be a beginner&#39;s language primer, such as &#34;A First Lesson in Latin,&#34; which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include &#34;en&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、複数の言語がエンティティ内に存在しているという理由だけで、それが複数の言語の聴衆のために意図されていることを意味するものではありません。例は明らかに英語を読み書き聴衆が使用することを意図しているような初心者の言語プライマー、「ラテン語で最初のレッスン、」だろう。この場合、コンテンツ言語が適切にのみ「EN」が含まれるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Language MAY be applied to any media type -- it is not limited to textual documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ言語は、任意のメディアタイプにも適用することができる - それは、テキスト文書に限定されるものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.13 Content-Length
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.13コンテンツの長さ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Lengthエンティティヘッダフィールドは、受信者に送信されるか、または、HEADメソッドの場合には、送信されたであろうエンティティボディのサイズを持っていた、オクテットの10進数で、エンティティボディのサイズを示しますリクエストはGETして。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Length = &#34;Content-Length&#34; &#34;:&#34; 1*DIGIT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Length = &#34;のContent-Length&#34; &#34;：&#34; 1 * DIGIT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Length: 3495
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツの長さ：3495
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Applications SHOULD use this field to indicate the transfer-length of the message-body, unless this is prohibited by the rules in section 4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これはセクション4.4の規則によって禁止されない限り、アプリケーションは、メッセージボディの転送長さを示すためにこのフィールドを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any Content-Length greater than or equal to zero is a valid value. Section 4.4 describes how to determine the length of a message-body if a Content-Length is not given.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0以上の任意のContent-Lengthは有効な値です。 4.4節は、コンテンツの長さが指定されていない場合はメッセージボディの長さを決定する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the meaning of this field is significantly different from the corresponding definition in MIME, where it is an optional field used within the &#34;message/external-body&#34; content-type. In HTTP, it SHOULD be sent whenever the message&#39;s length can be determined prior to being transferred, unless this is prohibited by the rules in section 4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このフィールドの意味は、それが「message / external-body」というコンテンツ・タイプ内で使用されるオプションのフィールドであるMIME、に対応する定義とは有意に異なることに注意してください。メッセージの長さは、前に転送されることに決定することができるときはいつでも、これはセクション4.4の規則によって禁止されない限り、HTTPにおいては、送信されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.14 Content-Location
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.14コンテンツの場所
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource&#39;s URI. A server SHOULD provide a Content-Location for the variant corresponding to the response entity; especially in the case where a resource has multiple entities associated with it, and those entities actually have separate locations by which they might be individually accessed, the server SHOULD provide a Content-Location for the particular variant which is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツロケーションエンティティヘッダフィールドは、そのエンティティは、要求されたリソースのURIから離れた場所からアクセス可能である場合、メッセージで囲まれたエンティティのリソースの場所を供給するために使用され得ます。サーバは、応答エンティティに対応する変異体のためのコンテンツの場所を提供すべきです。特に、リソースがそれに関連付けられた複数のエンティティを持っており、それらのエンティティは、実際に彼らは個別にアクセスされるかもしれないことで、別の場所を持っている場合には、サーバが返され、特定の変異体のためのContent-場所を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Content-Location = &#34;Content-Location&#34; &#34;:&#34;
                         ( absoluteURI | relativeURI )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The value of Content-Location also defines the base URI for the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツロケーションの値はまた、エンティティのベースURIを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-Location value is not a replacement for the original requested URI; it is only a statement of the location of the resource corresponding to this particular entity at the time of the request. Future requests MAY specify the Content-Location URI as the request-URI if the desire is to identify the source of that particular entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツの場所の値は、元の要求されたURIに代わるものではありません。それは、要求時に、この特定のエンティティに対応するリソースの場所の唯一の文です。欲求がその特定のエンティティのソースを特定することである場合には、将来の要求は、要求URIとしてContent-場所URIを指定するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A cache cannot assume that an entity with a Content-Location different from the URI used to retrieve it can be used to respond to later requests on that Content-Location URI. However, the Content-Location can be used to differentiate between multiple entities retrieved from a single requested resource, as described in section 13.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、URIは異なるコンテンツの場所を持つエンティティは、そのコンテンツの場所URIの後のリクエストに応答するために使用することができます取得するために使用されることを想定することはできません。しかし、コンテンツの場所は、セクション13.6で説明したように、単一の要求されたリソースから取得複数のエンティティを区別するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the Content-Location is a relative URI, the relative URI is interpreted relative to the Request-URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツの場所が相対URIであれば、相対URIは、Request-URIに関連して解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The meaning of the Content-Location header in PUT or POST requests is undefined; servers are free to ignore it in those cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTやPOSTリクエストのContent-Locationヘッダーの意味は定義されていません。サーバーは、これらのケースではそれを無視するのは自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15 Content-MD5
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15のContent-MD5
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-MD5 entity-header field, as defined in RFC 1864 [23], is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ-MD5エンティティヘッダフィールドは、[23] RFC 1864で定義されるように、エンティティボディのエンドツーエンドのメッセージ完全性チェック（MIC）を提供する目的のためにエンティティボディのMD5ダイジェストです。 （注意：MICは、輸送中のエンティティボディの偶発変更を検出するための良いですが、悪意のある攻撃に対する証拠ではありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Content-MD5   = &#34;Content-MD5&#34; &#34;:&#34; md5-digest
        md5-digest   = &lt;base64 of 128 bit MD5 digest as per RFC 1864&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-MD5 header field MAY be generated by an origin server or client to function as an integrity check of the entity-body. Only origin servers or clients MAY generate the Content-MD5 header field; proxies and gateways MUST NOT generate it, as this would defeat its value as an end-to-end integrity check. Any recipient of the entity-body, including gateways and proxies, MAY check that the digest value in this header field matches that of the entity-body as received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-MD5ヘッダフィールドはエンティティボディの整合性チェックとして機能するようにオリジンサーバやクライアントによって生成されてもよいです。唯一のオリジンサーバまたはクライアントがコンテンツ-MD5ヘッダフィールドを生成するかもしれません。これは、エンドツーエンドの整合性チェックとしての価値を台無しにしてしまうようプロキシやゲートウェイは、それを生成してはなりません。ゲートウェイやプロキシを含むエンティティボディの受信者は、受信したこのヘッダフィールドのダイジェスト値がエンティティボディのものと一致することを確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The MD5 digest is computed based on the content of the entity-body, including any content-coding that has been applied, but not including any transfer-encoding applied to the message-body. If the message is received with a transfer-encoding, that encoding MUST be removed prior to checking the Content-MD5 value against the received entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MD5ダイジェストは、メッセージボディに適用される転送符号化を含む、適用された任意のコンテンツの符号化を含むエンティティボディの内容に基づいて計算され、しかしされていません。メッセージが転送エンコーディングで受信された場合、その符号化は、受信エンティティに対してコンテンツ-MD5値をチェックする前に除去しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This has the result that the digest is computed on the octets of the entity-body exactly as, and in the order that, they would be sent if no transfer-encoding were being applied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、ダイジェストが正確、及びNO転送符号化が適用されないされていた場合、それらが送信される、ようにするためのようにエンティティボディのオクテットに計算されるという結果を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   HTTP extends RFC 1864 to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are several consequences of this. The entity-body for composite types MAY contain many body-parts, each with its own MIME and HTTP headers (including Content-MD5, Content-Transfer-Encoding, and Content-Encoding headers). If a body-part has a Content-Transfer-Encoding or Content-Encoding header, it is assumed that the content of the body-part has had the encoding applied, and the body-part is included in the Content-MD5 digest as is -- i.e., after the application. The Transfer-Encoding header field is not allowed within body-parts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これのいくつかの影響があります。複合タイプのエンティティボディは、多くの身体部分を含んでいてもよく、（コンテンツ-MD5、コンテンツ転送エンコード、およびコンテンツ符号化ヘッダを含む）それ自身のMIMEとHTTPヘッダをそれぞれ。本体部分は、コンテンツ転送エンコードまたはContent-Encodingヘッダーを持っている場合、身体部分の含有量は、符号化が適用されてきた、となるように本体部分がContent-MD5ダイジェストに含まれるものとします - すなわち、塗布した後。転送符号化ヘッダフィールドは、本体部分内に許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Conversion of all line breaks to CRLF MUST NOT be done before computing or checking the digest: the line break convention used in the text actually transmitted MUST be left unaltered when computing the digest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CRLFにすべての改行の変換は、コンピューティングの前に行うか、ダイジェストをチェックしてはならない：ダイジェストを計算するときに実際に送信されたテキストで使用される改行規則が変更されないままにされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: while the definition of Content-MD5 is exactly the same for HTTP as in RFC 1864 for MIME entity-bodies, there are several ways in which the application of Content-MD5 to HTTP entity-bodies differs from its application to MIME entity-bodies. One is that HTTP, unlike MIME, does not use Content-Transfer-Encoding, and does use Transfer-Encoding and Content-Encoding. Another is that HTTP more frequently uses binary content types than MIME, so it is worth noting that, in such cases, the byte order used to compute the digest is the transmission byte order defined for the type. Lastly, HTTP allows transmission of text types with any of several line break conventions and not just the canonical form using CRLF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：コンテンツ-MD5の定義は、MIMEエンティティ・ボディのためのRFC 1864のようにHTTPのためのまったく同じである一方で、HTTPエンティティ・ボディへのContent-MD5のアプリケーションは、MIME ENTITY-への応用と異なっているいくつかの方法がありますボディ。一つはHTTPは、MIMEとは異なり、コンテンツ転送エンコードを使用して、転送エンコードおよびContent-encodingを使用していないということです。別のHTTPがより頻繁MIMEよりバイナリコンテンツタイプを使用することであるので、そのようなケースでは、ダイジェストを計算するために使用されるバイト順序がタイプに対して定義された送信バイトオーダーである、ことは注目に値します。最後に、HTTPは、いくつかの改行規則のいずれかとしませCRLFを使用して、単に標準的な形式とテキストタイプの伝送を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.16 Content-Range
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.16コンテンツレンジ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-Range entity-header is sent with a partial entity-body to specify where in the full entity-body the partial body should be applied. Range units are defined in section 3.12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツ範囲エンティティヘッダは、完全エンティティボディに身体部分が適用されるべき場所を指定する部分エンティティボディで送信されます。レンジユニットは、セクション3.12で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Range = &#34;Content-Range&#34; &#34;:&#34; content-range-spec
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツレンジ=の &#34;Content-レンジ&#34; &#34;：&#34; コンテンツレンジスペック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
content-range-spec = byte-content-range-spec byte-content-range-spec = bytes-unit SP byte-range-resp-spec &#34;/&#34; ( instance-length | &#34;*&#34; )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツレンジ仕様=バイトコンテンツレンジ仕様バイトコンテンツレンジ仕様=バイトユニットSPのバイト範囲-RESP仕様 &#34;/&#34;（例えば、長さ| &#34;*&#34;）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
byte-range-resp-spec = (first-byte-pos &#34;-&#34; last-byte-pos) | &#34;*&#34; instance-length = 1*DIGIT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト範囲-RESP-スペック=（最初のバイト-POS &#34; - &#34; 最後のバイト-POS）| &#34;*&#34; インスタンス長= 1 * DIGIT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The header SHOULD indicate the total length of the full entity-body, unless this length is unknown or difficult to determine. The asterisk &#34;*&#34; character means that the instance-length is unknown at the time when the response was generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この長さは未知又は決定することは困難である場合を除き、ヘッダは、完全なエンティティボディの全長を示すべきです。アスタリスク「*」の文字は、インスタンスの長さは、応答が生成された時点では不明であることを意味しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unlike byte-ranges-specifier values (see section 14.35.1), a byte-range-resp-spec MUST only specify one range, and MUST contain absolute byte positions for both the first and last byte of the range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト範囲指定子値（セクション14.35.1を参照）とは異なり、バイト範囲-RESP仕様は、1つの範囲を指定しなければならない、そして範囲の最初と最後のバイトの両方の絶対バイト位置を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A byte-content-range-spec with a byte-range-resp-spec whose last-byte-pos value is less than its first-byte-pos value, or whose instance-length value is less than or equal to its last-byte-pos value, is invalid. The recipient of an invalid byte-content-range-spec MUST ignore it and any content transferred along with it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後のバイト-POS値は、その最初のバイト-POS値未満であるか、またはそのインスタンス長の値より小さいかまたはその直前に入っに等しいバイト範囲-RESP仕様のバイト・コンテンツレンジスペックバイト-POS値は、無効です。無効なバイトコンテンツレンジ仕様の受信者は、それに沿って転送されるコンテンツを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server sending a response with status code 416 (Requested range not satisfiable) SHOULD include a Content-Range field with a byte-range-resp-spec of &#34;*&#34;. The instance-length specifies the current length of the selected resource. A response with status code 206 (Partial Content) MUST NOT include a Content-Range field with a byte-range-resp-spec of &#34;*&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（要求された範囲にない）ステータスコード416で応答を送信するサーバは、「*」のバイト範囲-RESP-スペックでのContent-Rangeフィールドを含むべきです。例えば、長さが選択されたリソースの現在の長さを指定します。ステータスコード206（部分コンテンツ）との回答は、「*」のバイト範囲-RESP-スペックでのContent-Rangeフィールドを含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Examples of byte-content-range-spec values, assuming that the entity contains a total of 1234 bytes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティ1234バイトの合計が含まれていることを仮定バイトコンテンツレンジスペック値の例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
. The first 500 bytes: bytes 0-499/1234
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。最初の500バイト：0から499/1234バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
. The second 500 bytes: bytes 500-999/1234
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。第500バイト：500-999 / 1234バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
. All except for the first 500 bytes: bytes 500-1233/1234
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。バイト500-1233 / 1234：すべての最初の500のバイトを除きます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
. The last 500 bytes: bytes 734-1233/1234
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。最後の500バイト：バイト734から1233/1234
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an HTTP message includes the content of a single range (for example, a response to a request for a single range, or to a request for a set of ranges that overlap without any holes), this content is transmitted with a Content-Range header, and a Content-Length header showing the number of bytes actually transferred. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPメッセージが単一の範囲（単一の範囲について、または任意の孔なし重複範囲の一連の要求への要求に対して、例えば、応答）の内容を含む場合、このコンテンツは、コンテンツレンジで送信されますヘッダ、実際に転送されたバイトの数を示すContent-Lengthヘッダ。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an HTTP message includes the content of multiple ranges (for example, a response to a request for multiple non-overlapping ranges), these are transmitted as a multipart message. The multipart media type used for this purpose is &#34;multipart/byteranges&#34; as defined in appendix 19.2. See appendix 19.6.3 for a compatibility issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPメッセージが複数の範囲の内容を含む場合（例えば、複数の非重複範囲の要求への応答）が、これらはマルチパートメッセージとして送信されます。この目的のために使用されるマルチメディアタイプは、付録19.2で定義された「マルチパート/ byteranges」です。互換性の問題については、付録19.6.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A response to a request for a single range MUST NOT be sent using the multipart/byteranges media type. A response to a request for multiple ranges, whose result is a single range, MAY be sent as a multipart/byteranges media type with one part. A client that cannot decode a multipart/byteranges message MUST NOT ask for multiple byte-ranges in a single request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一範囲要求に対する応答は、マルチパート/ byterangesメディアタイプを使用して送信してはいけません。その結果、単一の範囲である複数の範囲に対する要求に対する応答は、一部で、マルチパート/ byterangesメディアタイプとして送信されても​​よいです。マルチパートをデコードすることができないクライアントは/メッセージは、単一の要求で複数のbyterangesをお願いしてはならないbyteranges。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client requests multiple byte-ranges in one request, the server SHOULD return them in the order that they appeared in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが一つのリクエストで複数のバイトレンジを要求すると、サーバーは、彼らが要求に登場した順序でそれらを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist. (Normally, this means return a 200 response containing the full entity).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは構文的に無効であるため、サーバーはバイト範囲スペックを無視した場合、サーバーは、無効なR​​angeヘッダフィールドが存在しなかったかのようにリクエストを扱うべきです。 （通常、これは、完全なエンティティを含む200応答を返すことを意味します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server receives a request (other than one including an If-Range request-header field) with an unsatisfiable Range request-header field (that is, all of whose byte-range-spec values have a first-byte-pos value greater than the current length of the selected resource), it SHOULD return a response code of 416 (Requested range not satisfiable) (section 10.4.17).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが充足不可能な範囲リクエスト・ヘッダー・フィールドで要求を（もしレンジリクエストヘッダフィールドを含む以外）（受信した場合つまり、そのバイト範囲仕様値の全ては、より大きな最初のバイト-POS値を有します選択されたリソースの現在の長さ）よりも、要求された（416の応答コードを返すべきで充足しない範囲で）（セクション10.4.17）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: clients cannot depend on servers to send a 416 (Requested range not satisfiable) response instead of a 200 (OK) response for an unsatisfiable Range request-header, since not all servers implement this request-header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：いないすべてのサーバがこのリクエスト・ヘッダーを実装するためのクライアントは、416（リクエストを充足しない範囲）の代わりに充足不能レンジリクエストヘッダ200（OK）応答の応答を送信するためにサーバに依存することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17 Content-Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17のContent-Type
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Typeエンティティヘッダフィールドは、受信者に送信されたエンティティボディのメディアタイプを示し、または、HEADメソッドの場合には、送信されたであろうメディアタイプがGETされリクエストがありました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Type = &#34;Content-Type&#34; &#34;:&#34; media-type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Typeの= &#34;Content-Typeの&#34; &#34;：&#34; メディアタイプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Media types are defined in section 3.7. An example of the field is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メディアタイプは、セクション3.7で定義されています。フィールドの例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Type: text/html; charset=ISO-8859-4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツタイプ：text / htmlの。文字セット= ISO-8859-4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Further discussion of methods for identifying the media type of an entity is provided in section 7.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティのメディアタイプを同定するための方法のさらなる議論は、セクション7.2.1に設けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.18 Date
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.18日
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. The field value is an HTTP-date, as described in section 3.3.1; it MUST be sent in RFC 1123 [8]-date format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション3.3.1に記載したように日一般ヘッダフィールドは、フィールドの値はHTTP-日付であるRFC 822にORIG-日付と同じセマンティクスを有する、メッセージが発信された日時を表します。これは、RFC 1123 [8] -date形式で送信されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Date = &#34;Date&#34; &#34;:&#34; HTTP-date
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
日付= &#34;日&#34; &#34;：&#34; HTTP-日
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Date: Tue, 15 Nov 1994 08:12:31 GMT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
日付：火曜、1994年11月15日午前8時12分31秒GMT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Origin servers MUST include a Date header field in all responses, except in these cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバは、これらの場合を除いて、すべての応答にDateヘッダフィールドを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. If the response status code is 100 (Continue) or 101 (Switching Protocols), the response MAY include a Date header field, at the server&#39;s option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.応答ステータスコードが100（続行）または101である場合には（プロトコルの切り替え）、応答がサーバのオプションで、Dateヘッダフィールドを含んでいてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. If the response status code conveys a server error, e.g. 500 (Internal Server Error) or 503 (Service Unavailable), and it is inconvenient or impossible to generate a valid Date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.レスポンスステータスコードは、サーバエラーを搬送する場合、例えば500（内部サーバーエラー）または503（サービスを使用できません）、有効な日付を生成するために、不便または不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. If the server does not have a clock that can provide a reasonable approximation of the current time, its responses MUST NOT include a Date header field. In this case, the rules in section 14.18.1 MUST be followed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.サーバーは、現在の時間の合理的な近似を提供することができます時計を持っていない場合、その応答はDateヘッダフィールドを含んではいけません。この場合、セクション14.18.1のルールに従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A received message that does not have a Date header field MUST be assigned one by the recipient if the message will be cached by that recipient or gatewayed via a protocol which requires a Date. An HTTP implementation without a clock MUST NOT cache responses without revalidating them on every use. An HTTP cache, especially a shared cache, SHOULD use a mechanism, such as NTP [28], to synchronize its clock with a reliable external standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージは、その受信者によってキャッシュまたは日を要するプロトコルを介してゲートウェイ処理される場合日ヘッダーフィールドを持っていない受信メッセージは、受信者によっていずれかを割り当てなければなりません。時計のないHTTPの実装は、すべての使用にそれらを再確認せずにレスポンスをキャッシュしてはなりません。 HTTPキャッシュ、特に共有キャッシュは、信頼性の高い外部標準とそのクロックを同期させるためには、そのようなNTP [28]として、メカニズムを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients SHOULD only send a Date header field in messages that include an entity-body, as in the case of the PUT and POST requests, and even then it is optional. A client without a clock MUST NOT send a Date header field in a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、唯一のPUTやPOSTリクエストの場合のように、エンティティボディを含むメッセージにDateヘッダフィールドを送るべきである、とさえ、それはオプションです。時計のないクライアントがリクエストにDateヘッダフィールドを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HTTP-date sent in a Date header SHOULD NOT represent a date and time subsequent to the generation of the message. It SHOULD represent the best available approximation of the date and time of message generation, unless the implementation has no means of generating a reasonably accurate date and time. In theory, the date ought to represent the moment just before the entity is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
日付ヘッダーで送信されるHTTP日付はメッセージの生成に続いて、日付と時刻を表すべきではありません。実装が合理的に正確な日付と時刻を生成する手段がない場合を除きこれは、メッセージの発生日時の利用可能な最善の近似を表現して下さい。理論的には、日付はエンティティが生成される直前の瞬間を表すべきです。実際には、日付はその意味値に影響を与えることなく、メッセージの発信時にいつでも生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.18.1 Clockless Origin Server Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.18.1クロックレスオリジナル・サーバーの運用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some origin server implementations might not have a clock available. An origin server without a clock MUST NOT assign Expires or Last-Modified values to a response, unless these values were associated with the resource by a system or user with a reliable clock. It MAY assign an Expires value that is known, at or before server configuration time, to be in the past (this allows &#34;pre-expiration&#34; of responses without storing separate Expires values for each resource).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのオリジンサーバの実装が可能なクロックを持っていない可能性があります。時計のないオリジンサーバは、これらの値は信頼性の高いクロックを持つシステムまたはユーザーによってリソースに関連付けられた場合を除き、応答に値を期限切れになるかのLast-Modified割り当ててはなりません。それは（これは、別個の記憶せず応答の「前有効期限」を可能にする、各リソースの値を有効期限）は、過去にあると、サーバーの構成時またはそれ以前に、知られている有効期限の値を割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.19 ETag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.19のETag
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ETag response-header field provides the current value of the entity tag for the requested variant. The headers used with entity tags are described in sections 14.24, 14.26 and 14.44. The entity tag MAY be used for comparison with other entities from the same resource (see section 13.3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ETagレスポンス・ヘッダー・フィールドは、要求されたバリアントのエンティティタグの現在の値を提供します。エンティティタグと共に使用されるヘッダはセクション14.24、14.26及び14.44に記載されています。エンティティタグは、同じリソース（セクション13.3.3を参照）から他のエンティティとの比較のために使用されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ETag = &#34;ETag&#34; &#34;:&#34; entity-tag
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ETag = &#34;ETagを&#34; &#34;：&#34; エンティティタグ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Examples:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ETag: &#34;xyzzy&#34; ETag: W/&#34;xyzzy&#34; ETag: &#34;&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ETag： &#34;XYZZY&#34; のETag：W / &#34;XYZZY&#34; のETag： &#34;&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.20 Expect
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.20期待
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Expect request-header field is used to indicate that particular server behaviors are required by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
期待リクエストヘッダフィールドは、特定のサーバビヘイビアがクライアントによって要求されていることを示すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Expect = &#34;Expect&#34; &#34;:&#34; 1#expectation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= &#34; &#34;期待&#34; 期待：&#34; 1つの＃期待
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
expectation = &#34;100-continue&#34; | expectation-extension expectation-extension = token [ &#34;=&#34; ( token | quoted-string ) *expect-params ] expect-params = &#34;;&#34; token [ &#34;=&#34; ( token | quoted-string ) ]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
期待= &#34;100-続けます&#34; |期待-延長期待-延長=トークン[ &#34;=&#34;（トークン|引用符で囲まれた文字列）*期待-のparams]期待-のparams = &#34;;&#34;トークン[ &#34;=&#34;（トークン|引用符で囲まれた文字列）]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server that does not understand or is unable to comply with any of the expectation values in the Expect field of a request MUST respond with appropriate error status. The server MUST respond with a 417 (Expectation Failed) status if any of the expectations cannot be met or, if there are other problems with the request, some other 4xx status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
理解したり、適切なエラー状態で応答しなければならない要求の期待分野での期待値のいずれかを順守することができませんしないサーバー。期待のいずれかの場合、サーバは417（期待に失敗しました）状態で応じなければなりませんリクエスト、いくつかの他の4xxのステータスを持つ他の問題がある場合は、会ったりすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This header field is defined with extensible syntax to allow for future extensions. If a server receives a request containing an Expect field that includes an expectation-extension that it does not support, it MUST respond with a 417 (Expectation Failed) status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このヘッダーフィールドは、将来の拡張を可能にする拡張可能な構文で定義されています。サーバーがサポートしていないことを期待-拡張子を含む期待フィールドを含む要求を受信した場合、それは417（期待に失敗しました）状態で応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Comparison of expectation values is case-insensitive for unquoted tokens (including the 100-continue token), and is case-sensitive for quoted-string expectation-extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
期待値の比較は（100-継続トークンを含む）引用符で囲まれていないトークンの大文字と小文字が区別され、そして引用文字列の期待値の拡張のための大文字と小文字が区別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST return a 417 (Expectation Failed) status if it receives a request with an expectation that it cannot meet. However, the Expect request-header itself is end-to-end; it MUST be forwarded if the request is forwarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
期待機構は、ホップバイホップである：それは満たすことができないことを見込んで要求を受信した場合、すなわち、HTTP / 1.1プロキシが417（期待失敗）ステータスを返さなければなりません。しかし、期待リクエストヘッダ自体は、エンドツーエンドです。要求が転送されている場合、それは転送されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many older HTTP/1.0 and HTTP/1.1 applications do not understand the Expect header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くの古いHTTP / 1.0とHTTP / 1.1のアプリケーションが期待ヘッダを理解していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See section 8.2.3 for the use of the 100 (continue) status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
100（継続）状態を使用するためのセクション8.2.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.21 Expires
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.21有効期限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache (either a proxy cache or a user agent cache) unless it is first validated with the origin server (or with an intermediate cache that has a fresh copy of the entity). See section 13.2 for further discussion of the expiration model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティヘッダフィールドは、応答が古くなったとみなされた後の日付/時間を与える有効期限。それが最初のオリジンサーバ（またはエンティティの新しいコピーを持っている中間キャッシュを有する）で検証されていない限り、古いキャッシュエントリは、通常、キャッシュ（プロキシキャッシュまたはユーザー・エージェント・キャッシュのいずれか）によって返さなくてもよいです。期限モデルのさらなる議論についてはセクション13.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有効期限フィールドの存在は、元のリソースを変更したりする前に、またはその時間の後、に存在しなくなることを意味するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The format is an absolute date and time as defined by HTTP-date in section 3.3.1; it MUST be in RFC 1123 date format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フォーマットは、セクション3.3.1にHTTP-日付によって定義される絶対日付と時刻です。それは、RFC 1123の日付フォーマットでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Expires = &#34;Expires&#34; &#34;:&#34; HTTP-date
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;HTTP-日付：=&#34; &#34;有効期限&#34; 有効期限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example of its use is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その使用の例があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Expires: Thu, 01 Dec 1994 16:00:00 GMT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有効期限：木、1994年12月1日16時00分00秒GMT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: if a response includes a Cache-Control field with the max-age directive (see section 14.9.3), that directive overrides the Expires field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：応答が（セクション14.9.3を参照）のmax-ageディレクティブとのCache-Controlフィールドが含まれている場合、そのディレクティブは、フィールドを有効期限よりも優先されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 clients and caches MUST treat other invalid date formats, especially including the value &#34;0&#34;, as in the past (i.e., &#34;already expired&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1クライアントとキャッシュは過去の（すなわち、「すでに期限切れ」）のように、特に値が「0」を含め、他の不正な日付形式を扱わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To mark a response as &#34;already expired,&#34; an origin server sends an Expires date that is equal to the Date header value. (See the rules for expiration calculations in section 13.2.4.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答をマークするには、「すでに期限切れ、」オリジンサーバはDateヘッダの値に等しい日付を有効期限送信します。 （セクション13.2.4における有効期限の計算のための規則を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To mark a response as &#34;never expires,&#34; an origin server sends an Expires date approximately one year from the time the response is sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答をマークするには、「無期限に、」オリジンサーバは、応答が送信された時点から約1年の日付を有効期限送信します。 HTTP / 1.1サーバは、将来的には一年以上の日付を有効期限送るべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The presence of an Expires header field with a date value of some time in the future on a response that otherwise would by default be non-cacheable indicates that the response is cacheable, unless indicated otherwise by a Cache-Control header field (section 14.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうでない場合は、デフォルトで非キャッシュ可能であろうことを応答に将来のある時点の日付値とExpiresヘッダーフィールドの存在は、キャッシュ制御ヘッダフィールド（セクション14.9）によって、特に断らない限り応答は、キャッシュ可能であることを示し。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.22 From
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.22から
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The From request-header field, if given, SHOULD contain an Internet e-mail address for the human user who controls the requesting user agent. The address SHOULD be machine-usable, as defined by &#34;mailbox&#34; in RFC 822 [9] as updated by RFC 1123 [8]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストヘッダフィールドから、与えられた場合には、要求元のユーザエージェントを制御し、人間のユーザのためのインターネット電子メールアドレスを含むべきです。 RFC 822の「メールボックス」によって定義されるアドレスは、機械使用可能であるべきである[9] RFC 1123によって更新される[8]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
From = &#34;From&#34; &#34;:&#34; mailbox
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「メールボックス：」「から」=から
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
From: webmaster@w3.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
投稿者：webmaster@w3.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This header field MAY be used for logging purposes and as a means for identifying the source of invalid or unwanted requests. It SHOULD NOT be used as an insecure form of access protection. The interpretation of this field is that the request is being performed on behalf of the person given, who accepts responsibility for the method performed. In particular, robot agents SHOULD include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このヘッダーフィールドは、ロギングのために、無効または不要なリクエストの送信元を識別するための手段として使用することができます。これは、アクセス保護の安全でない形として使用しないでください。このフィールドの解釈は、要求が実行される方法のために責任を負う与えられた人に代わって行われていることです。問題は、受信側で発生した場合、ロボットを動作させるための責任者に連絡することができるように、特に、ロボットエージェントは、このヘッダを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Internet e-mail address in this field MAY be separate from the Internet host which issued the request. For example, when a request is passed through a proxy the original issuer&#39;s address SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この分野では、インターネットの電子メールアドレスは、要求を発行したインターネットホストから分離することができます。要求がプロキシを通過するときたとえば、元の発行者のアドレスを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client SHOULD NOT send the From header field without the user&#39;s approval, as it might conflict with the user&#39;s privacy interests or their site&#39;s security policy. It is strongly recommended that the user be able to disable, enable, and modify the value of this field at any time prior to a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、ユーザーのプライバシーの利益や自分のサイトのセキュリティポリシーと競合する可能性がありますように、クライアントは、ユーザーの承認なしFromヘッダーフィールド送るべきではありません。強く、ユーザーが要求する前に、任意の時点で、無効化、有効化、およびこのフィールドの値を変更することができることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.23 Host
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.23ホスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Host request-header field specifies the Internet host and port number of the resource being requested, as obtained from the original URI given by the user or referring resource (generally an HTTP URL, as described in section 3.2.2). The Host field value MUST represent the naming authority of the origin server or gateway given by the original URL. This allows the origin server or gateway to differentiate between internally-ambiguous URLs, such as the root &#34;/&#34; URL of a server for multiple host names on a single IP address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
元のURIから得られるホストリクエストヘッダフィールドは、ユーザによって与えられるまたは（セクション3.2.2で説明したように、一般にHTTPのURL）リソースを参照し、要求されたリソースのインターネットホストとポート番号を指定します。 Hostフィールド値は、元のURLで指定したオリジンサーバやゲートウェイの命名機関を表現しなければなりません。これは、オリジンサーバやゲートウェイは、単一のIPアドレスに複数のホスト名のために、ルートなどの内部であいまいなURLを、サーバーの「/」URLを区別することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Host = &#34;Host&#34; &#34;:&#34; host [ &#34;:&#34; port ] ; Section 3.2.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホスト= &#34;ホスト&#34; &#34;：&#34; ホスト[ &#34;：&#34; ポート]; 3.2.2項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A &#34;host&#34; without any trailing port information implies the default port for the service requested (e.g., &#34;80&#34; for an HTTP URL). For example, a request on the origin server for &lt;http://www.w3.org/pub/WWW/&gt; would properly include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
後続のポート情報なしに「ホスト」とは、（HTTPのURLのために、例えば、「80」）、要求されたサービスのためのデフォルトのポートを意味しています。たとえば、&lt;http://www.w3.org/pub/WWW/&gt;のためのオリジンサーバ上の要求が適切に含まれます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client MUST include a Host header field in all HTTP/1.1 request messages . If the requested URI does not include an Internet host name for the service being requested, then the Host header field MUST be given with an empty value. An HTTP/1.1 proxy MUST ensure that any request message it forwards does contain an appropriate Host header field that identifies the service being requested by the proxy. All Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message which lacks a Host header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、すべてのHTTP / 1.1リクエストメッセージにHostヘッダフィールドを含まなければなりません。要求されたURIが要求されたサービスのためのインターネットホスト名が含まれていない場合、Hostヘッダフィールドが空の値を指定する必要があります。 HTTP / 1.1プロキシは、それが転送し、任意の要求メッセージがプロキシによって要求されたサービスを識別する適切なホストヘッダーフィールドが含まれていることを確実にしなければなりません。すべてのインターネットベースのHTTP / 1.1サーバは、Hostヘッダフィールドを持たない任意のHTTP / 1.1リクエストメッセージに400（不正な要求）ステータスコードで応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See sections 5.2 and 19.6.1.1 for other requirements relating to Host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストに関連する他の要件については、セクション5.2および19.6.1.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.24 If-Match
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.24もしマッチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The If-Match request-header field is used with a method to make it conditional. A client that has one or more entities previously obtained from the resource can verify that one of those entities is current by including a list of their associated entity tags in the If-Match header field. Entity tags are defined in section 3.11. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. It is also used, on updating requests, to prevent inadvertent modification of the wrong version of a resource. As a special case, the value &#34;*&#34; matches any current entity of the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もしマッチリクエストヘッダフィールドは、条件付きにする方法に使用されます。以前資源から得られた1つまたは複数のエンティティを持っているクライアントは、これらのエンティティの一つがIf-Matchヘッダフィールドでそれに関連するエンティティタグのリストを含むことにより、現在であることを確認することができます。エンティティタグは、セクション3.11で定義されています。この機能の目的は最小のトランザクションオーバーヘッドでキャッシュされた情報の効率的な更新を可能にすることです。また、リソースの間違ったバージョンの不注意な変更を防ぐために、更新要求に、使用されています。特別な場合として、値「*」はリソースのいずれかの現在のエンティティと一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If-Match = &#34;If-Match&#34; &#34;:&#34; ( &#34;*&#34; | 1#entity-tag )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もしマッチ=「もしマッチ」「：」（「*」| 1＃エンティティタグ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-Match header) on that resource, or if &#34;*&#34; is given and any current entity exists for that resource, then the server MAY perform the requested method as if the If-Match header field did not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグのいずれかがそのリソース上の（もしマッチヘッダなし）同様のGET要求に応答して返されたであろうエンティティのエンティティタグと一致する場合、「*」は、所与の任意の現在のエンティティが存在する場合、またはIf-Matchヘッダフィールドが存在しなかったかのようにそのリソースのために、サーバは要求されたメソッドを実行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server MUST use the strong comparison function (see section 13.3.3) to compare the entity tags in If-Match.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、もしマッチにエンティティタグを比較すること（セクション13.3.3を参照してください）強い比較機能を使わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If none of the entity tags match, or if &#34;*&#34; is given and no current entity exists, the server MUST NOT perform the requested method, and MUST return a 412 (Precondition Failed) response. This behavior is most useful when the client wants to prevent an updating method, such as PUT, from modifying a resource that has changed since the client last retrieved it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「*」与えられた場合、またはエンティティのいずれも試合をタグおよびno現在のエンティティが存在しない場合、サーバは要求されたメソッドを実行してはならない、と412（前提条件が失敗した）応答を返さなければなりません。クライアントは、クライアントが最後にそれを取得した後に変更されたリソースを変更するのは、そのようなPUTなど、更新方法を阻止しようとすると、この現象が最も有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the request would, without the If-Match header field, result in anything other than a 2xx or 412 status, then the If-Match header MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求は、If-Matchヘッダフィールドなしで、2XXまたは412ステータス以外をもたらす場合、もしマッチヘッダは無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The meaning of &#34;If-Match: *&#34; is that the method SHOULD be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section 14.44) exists, and MUST NOT be performed if the representation does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
意味は、「場合マッチ：*」メソッドがオリジンサーバによって選択された表現が存在する（またはキャッシュによって、おそらくセクション14.44を参照してください、ヴァリメカニズムを使用して）場合に実行されるべきであり、場合に実行されてはならないことです表現は存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A request intended to update a resource (e.g., a PUT) MAY include an If-Match header field to signal that the request method MUST NOT be applied if the entity corresponding to the If-Match value (a single entity tag) is no longer a representation of that resource. This allows the user to indicate that they do not wish the request to be successful if the resource has been changed without their knowledge. Examples:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし一致値（単一のエンティティタグ）に対応するエンティティがもはやない場合、要求メソッドを適用してはならないことを知らせるためにIf-Matchヘッダフィールドを含むかもしれリソース（例えば、PUT）を更新することを意図要求そのリソースの表現。これにより、ユーザーは、リソースが彼らの知識がなくても変更されている場合、彼らが成功するために要求を希望していないことを示すことができます。例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       If-Match: &#34;xyzzy&#34;
       If-Match: &#34;xyzzy&#34;, &#34;r2d2xxxx&#34;, &#34;c3piozzzz&#34;
       If-Match: *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The result of a request having both an If-Match header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
If-Matchヘッダフィールドの両方を有する要求の結果のいずれかは、IF-なしマッチ場合、または修飾-ためのヘッダフィールドはこの仕様書で定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.25 If-Modified-Since
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.25変更 - 開始
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The If-Modified-Since request-header field is used with a method to make it conditional: if the requested variant has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし修飾-のでリクエストヘッダフィールドを条件付きそれを作るための方法で使用される：要求された変異体は、このフィールドで指定された時間以降に変更されていない場合、エンティティはサーバから返されないであろう。代わりに、304（変更されない）応答は、任意のメッセージボディなしに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If-Modified-Since = &#34;If-Modified-Since&#34; &#34;:&#34; HTTP-date
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変更 - 開始= &#34;場合 - 変更 - ので&#34; &#34;：&#34; HTTP-日
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example of the field is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールドの例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変更 - 開始：土、1994年10月29日午後7時43分31秒GMT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A GET method with an If-Modified-Since header and no Range header requests that the identified entity be transferred only if it has been modified since the date given by the If-Modified-Since header. The algorithm for determining this includes the following cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヘッダ場合-ので修飾とを有するGETメソッドがあれば修飾-ので、ヘッダにより指定された日付以降に変更された場合に識別されたエンティティにのみ転送されないRangeヘッダを要求します。これを決定するためのアルゴリズムは、以下の例が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a) If the request would normally result in anything other than a 200 (OK) status, or if the passed If-Modified-Since date is invalid, the response is exactly the same as for a normal GET. A date which is later than the server&#39;s current time is invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
a）の要求は、通常は200（OK）ステータス以外の何かにつながる、または変更された場合は、-ので日付渡されたが無効である場合、レスポンスは通常のGETとまったく同じである。場合後でサーバーの現在時刻よりも日付が無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b) If the variant has been modified since the If-Modified-Since date, the response is exactly the same as for a normal GET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変異体は、以降に変更された場合b）の場合は修飾-ので日付、応答が正確に通常GETの場合と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c) If the variant has not been modified since a valid If-Modified-Since date, the server SHOULD return a 304 (Not Modified) response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バリアントが変更された場合は、-ので、有効開始日以降に変更されていない場合c）に、サーバは304（未修正）応答を返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この機能の目的は最小のトランザクションオーバーヘッドでキャッシュされた情報の効率的な更新を可能にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The Range request-header field modifies the meaning of If-Modified-Since; see section 14.35 for full details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：範囲リクエストヘッダフィールドが変更した場合-以来の意味を変更します。完全な詳細についてはセクション14.35を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: If-Modified-Since times are interpreted by the server, whose clock might not be synchronized with the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：変更した場合は-ので時間がそのクロッククライアントと同期されない可能性があり、サーバーによって解釈されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: When handling an If-Modified-Since header field, some servers will use an exact date comparison function, rather than a less-than function, for deciding whether to send a 304 (Not Modified) response. To get best results when sending an If-Modified-Since header field for cache validation, clients are advised to use the exact date string received in a previous Last-Modified header field whenever possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：もし-Modified-Sinceヘッダー・フィールドを扱うときは、いくつかのサーバは304（未修正）応答を送信するかどうかを決定するために、というより少なくより機能よりも、正確な日付の比較関数を使用します。キャッシュ検証のためであれば-Modified-Sinceヘッダー・フィールドを送信する際に最良の結果を得るために、クライアントは以前のLast-Modifiedヘッダフィールド可能な限りで受信し、正確な日付文字列を使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: If a client uses an arbitrary date in the If-Modified-Since header instead of a date taken from the Last-Modified header for the same request, the client should be aware of the fact that this date is interpreted in the server&#39;s understanding of time. The client should consider unsynchronized clocks and rounding problems due to the different encodings of time between the client and server. This includes the possibility of race conditions if the document has changed between the time it was first requested and the If-Modified-Since date of a subsequent request, and the possibility of clock-skew-related problems if the If-Modified-Since date is derived from the client&#39;s clock without correction to the server&#39;s clock. Corrections for different time bases between client and server are at best approximate due to network latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：クライアントは、If-Modifiedの-Sinceヘッダの代わりに同じ要求のためのLast-Modifiedヘッダから撮影日の内の任意の日付を使用している場合、クライアントはこの日付がサーバの理解で解釈されているという事実を認識しておく必要があり時間の。クライアントは非同期のクロックと、クライアントとサーバの間の時間の異なるエンコーディングによる丸めの問題を考慮する必要があります。文書は、それが最初に要求された時間との間で変更された場合、これは競合状態の可能性を含む後続の要求の日付場合-ため修飾、およびクロック・スキューに関連する問題の可能性があれば修飾-ので、場合日付サーバのクロックに補正することなく、クライアントのクロックから導出されます。クライアントとサーバの間の異なる時間基準の補正はネットワークの遅延によるせいぜい近似しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The result of a request having both an If-Modified-Since header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストの結果は、ヘッダフィールド場合-ため修飾した両方の場合マッチ場合、または非改変-のでヘッダーフィールドのいずれかは、本明細書によって定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.26 If-None-Match
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.26もし-なしマッチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The If-None-Match request-header field is used with a method to make it conditional. A client that has one or more entities previously obtained from the resource can verify that none of those entities is current by including a list of their associated entity tags in the If-None-Match header field. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. It is also used to prevent a method (e.g. PUT) from inadvertently modifying an existing resource when the client believes that the resource does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし-なしマッチリクエストヘッダフィールドは、条件付きにする方法に使用されます。以前資源から得られた1つまたは複数のエンティティを持っているクライアントは、これらのエンティティのいずれもIf-None-Matchヘッダフィールド内のそれに関連するエンティティタグのリストを含むことにより、現在ではないことを確認することができます。この機能の目的は最小のトランザクションオーバーヘッドでキャッシュされた情報の効率的な更新を可能にすることです。また、クライアントは、リソースが存在しないと考えているときに誤って既存のリソースを変更することから（例えばPUT）メソッドを防止するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a special case, the value &#34;*&#34; matches any current entity of the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別な場合として、値「*」はリソースのいずれかの現在のエンティティと一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If-None-Match = &#34;If-None-Match&#34; &#34;:&#34; ( &#34;*&#34; | 1#entity-tag )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし-なしマッチ= &#34;もし-なし - マッチ&#34; &#34;：&#34;（ &#34;*&#34; | 1＃エンティティタグ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-None-Match header) on that resource, or if &#34;*&#34; is given and any current entity exists for that resource, then the server MUST NOT perform the requested method, unless required to do so because the resource&#39;s modification date fails to match that supplied in an If-Modified-Since header field in the request. Instead, if the request method was GET or HEAD, the server SHOULD respond with a 304 (Not Modified) response, including the cache-related header fields (particularly ETag) of one of the entities that matched. For all other request methods, the server MUST respond with a status of 412 (Precondition Failed).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグのいずれかが「*」が与えられた場合、そのリソース上（If-None-Matchヘッダなし）と同様のGET要求に応答して返送、またはされていたであろうエンティティと任意の現在のエンティティタグが一致した場合リソースの変更日はリクエストであれば-Modified-Sinceヘッダー・フィールドで供給されるものと一致しなかったので、そうするために必要な場合を除き、エンティティは、そのリソースのために存在し、その後、サーバは要求されたメソッドを実行してはなりません。リクエストメソッドがGETまたはHEADであった場合、代わりに、サーバは、一致したエンティティのいずれのキャッシュに関連するヘッダフィールド（特にETagの）を含む、304（変更されていません）応答で応答すべきです。他のすべてのリクエストメソッドの場合、サーバは412の状態で応じなければなりません（前提条件に失敗しました）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See section 13.3.3 for rules on how to determine if two entities tags match. The weak comparison function can only be used with GET or HEAD requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2つのエンティティが試合をタグかどうかを確認する方法に関する規則のためのセクション13.3.3を参照してください。弱い比較機能は、GETやHEADリクエストで使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If none of the entity tags match, then the server MAY perform the requested method as if the If-None-Match header field did not exist, but MUST also ignore any If-Modified-Since header field(s) in the request. That is, if no entity tags match, then the server MUST NOT return a 304 (Not Modified) response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティタグの一致のいずれも、If-None-Matchヘッダフィールドが存在しなかったかのように、サーバは、要求されたメソッドを実行しなくてもよいが、また変更した場合-ので要求内のヘッダフィールド（複数可）は、任意の無視しなければならない場合。それは何のエンティティタグが一致しない場合、サーバは304（未修正）応答を返してはならない、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the If-None-Match header MUST be ignored. (See section 13.3.4 for a discussion of server behavior when both If-Modified-Since and If-None-Match appear in the same request.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストは、If-None-Matchヘッダフィールドなし、の2xxまたは304ステータス以外の何かにつながる場合は、If-None-Matchヘッダは無視しなければなりません。 （変更した場合は-ので両方となし、マッチした場合、同じ要求に表示され、サーバの動作についての説明は、セクション13.3.4を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The meaning of &#34;If-None-Match: *&#34; is that the method MUST NOT be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section 14.44) exists, and SHOULD be performed if the representation does not exist. This feature is intended to be useful in preventing races between PUT operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表現はオリジンサーバによって選択された場合、このメソッドは（またはキャッシュでのセクション14.44を参照してください、おそらくヴァリメカニズムを使用して、）を行ってはならないことで存在し、実行する必要があります。「*場合 - なし - マッチ」の意味表現が存在しない場合。この機能は、PUT操作間レースを予防するのに有用であることを意図しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Examples:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       If-None-Match: &#34;xyzzy&#34;
       If-None-Match: W/&#34;xyzzy&#34;
       If-None-Match: &#34;xyzzy&#34;, &#34;r2d2xxxx&#34;, &#34;c3piozzzz&#34;
       If-None-Match: W/&#34;xyzzy&#34;, W/&#34;r2d2xxxx&#34;, W/&#34;c3piozzzz&#34;
       If-None-Match: *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The result of a request having both an If-None-Match header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
If-None-Matchヘッダフィールドの両方ともしマッチ場合、または非改変-のでヘッダフィールドこの仕様によって定義されていないのいずれかを有する要求の結果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.27 If-Range
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.27もしレンジ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a client has a partial copy of an entity in its cache, and wishes to have an up-to-date copy of the entire entity in its cache, it could use the Range request-header with a conditional GET (using either or both of If-Unmodified-Since and If-Match.) However, if the condition fails because the entity has been modified, the client would then have to make a second request to obtain the entire current entity-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがそのキャッシュにエンティティの部分的なコピーを持っており、そのキャッシュにエンティティ全体の最新のコピーを持っているしたい場合は、いずれかまたは両方を使用して（条件付きGETでレンジリクエストヘッダを使用することができますエンティティが変更されているので、条件が失敗した場合の場合、未修飾-以来とIF-マッチ。）ただし、クライアントは、全体の現在のエンティティボディを取得するために第2の要求を行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The If-Range header allows a client to &#34;short-circuit&#34; the second request. Informally, its meaning is `if the entity is unchanged, send me the part(s) that I am missing; otherwise, send me the entire new entity&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし-Rangeヘッダは「短絡」第2の要求にクライアントを可能にします。非公式に、その意味は、エンティティが変更されなかった場合は、私が行方不明だ部分（複数可）を送る `です。そうでない場合は、私の全体の新しいエンティティ」を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If-Range = &#34;If-Range&#34; &#34;:&#34; ( entity-tag | HTTP-date )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もしレンジ= &#34;IF-範囲&#34; &#34;：&#34;（エンティティタグ| HTTP-日）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client has no entity tag for an entity, but does have a Last-Modified date, it MAY use that date in an If-Range header. (The server can distinguish between a valid HTTP-date and any form of entity-tag by examining no more than two characters.) The If-Range header SHOULD only be used together with a Range header, and MUST be ignored if the request does not include a Range header, or if the server does not support the sub-range operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、エンティティのエンティティタグがありませんが、最終更新日時を持っている場合、それは、If-Rangeヘッダにその日付を使用するかもしれません。 （サーバは、有効なHTTP日付と2つ以下の文字を調べることによって、エンティティタグの任意の形式を区別することができる。）の場合、RangeヘッダのみRangeヘッダと一緒に使用する必要があり、要求がない場合は無視しなければなりませんサーバは、サブ範囲の動作をサポートしていない場合、Rangeヘッダを含むか、またはしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the entity tag given in the If-Range header matches the current entity tag for the entity, then the server SHOULD provide the specified sub-range of the entity using a 206 (Partial content) response. If the entity tag does not match, then the server SHOULD return the entire entity using a 200 (OK) response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし-Rangeヘッダで与えられたエンティティタグは、エンティティの現在のエンティティタグと一致する場合、サーバは206（部分コンテンツ）応答を使用して、エンティティの指定されたサブ範囲を提供すべきです。エンティティタグが一致しない場合、サーバは200（OK）応答を使用してエンティティ全体を返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.28 If-Unmodified-Since
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.28の場合、変更されていない、ので、
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The If-Unmodified-Since request-header field is used with a method to make it conditional. If the requested resource has not been modified since the time specified in this field, the server SHOULD perform the requested operation as if the If-Unmodified-Since header were not present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし非改変-のでリクエストヘッダフィールドは、条件付きにする方法に使用されます。要求されたリソースがこのフィールドに指定された時間以降に変更されていない場合、サーバがあるかのように要求された操作を実行する必要がある場合、未修飾-ので、ヘッダが存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the requested variant has been modified since the specified time, the server MUST NOT perform the requested operation, and MUST return a 412 (Precondition Failed).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求されたバリアントが指定した時刻以降に変更された場合、サーバは要求された操作を実行してはならない、と412（前提条件が失敗した）を返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If-Unmodified-Since = &#34;If-Unmodified-Since&#34; &#34;:&#34; HTTP-date
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし非改変-以来= &#34; &#34;の場合、未修飾-以来&#34;：&#34; HTTP-日
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example of the field is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールドの例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし非改変-以降：土、1994年10月29日午前19時43分31秒GMT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the request normally (i.e., without the If-Unmodified-Since header) would result in anything other than a 2xx or 412 status, the If-Unmodified-Since header SHOULD be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求が正常に（即ち、もし非改変-のでヘッダなし）の2xxまたは412ステータス以外をもたらす場合、もし非改変-ので、ヘッダは無視されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the specified date is invalid, the header is ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定された日付が無効である場合、ヘッダは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The result of a request having both an If-Unmodified-Since header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストの結果は、もし非改変-ので、両方のヘッダフィールドを有するとIF-なしマッチ場合、または修飾-ためのヘッダーフィールドのいずれかは、本明細書によって定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.29 Last-Modified
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.29のLast-Modified
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Last-Modifiedエンティティヘッダフィールドは、オリジンサーバがバリアントが最後に変更されたと考えていた日付と時刻を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Last-Modified = &#34;Last-Modified&#34; &#34;:&#34; HTTP-date
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= &#34;Last-Modifiedの&#34; &#34;のLast-Modified：&#34; HTTP-日
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example of its use is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その使用の例があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最終更新：火、1994年12時45分26秒GMT 11月15日
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The exact meaning of this header field depends on the implementation of the origin server and the nature of the original resource. For files, it may be just the file system last-modified time. For entities with dynamically included parts, it may be the most recent of the set of last-modify times for its component parts. For database gateways, it may be the last-update time stamp of the record. For virtual objects, it may be the last time the internal state changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このヘッダフィールドの正確な意味はオリジンサーバの実装と、元のリソースの性質に依存します。ファイルの場合、それは最終更新時刻だけで、ファイルシステムであってもよいです。動的に含まれる部品を持つエンティティの場合は、その構成部品のための最後の変更時間のセットの最新のかもしれません。データベース・ゲートウェイの場合は、レコードの最後の更新のタイムスタンプかもしれません。仮想オブジェクトの場合、それは、内部状態が変更された最後の時間がかかるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An origin server MUST NOT send a Last-Modified date which is later than the server&#39;s time of message origination. In such cases, where the resource&#39;s last modification would indicate some time in the future, the server MUST replace that date with the message origination date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバは、メッセージ発信のサーバの時刻より後の最終更新日時を送ってはいけません。リソースの最後の変更が将来のある時点を示すことになるような場合では、サーバーは、メッセージの発信日付で、その日付を交換しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An origin server SHOULD obtain the Last-Modified value of the entity as close as possible to the time that it generates the Date value of its response. This allows a recipient to make an accurate assessment of the entity&#39;s modification time, especially if the entity changes near the time that the response is generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバは、その応答の日付値を生成し、時間にできるだけ近いエンティティのLast-Modifiedの値を取得する必要があります。これは、企業が、応答が生成された時間の近くに変わる場合は特に、受信者がエンティティの更新時刻の正確な評価を行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1サーバは、Last-Modifiedの実現可能な時はいつでも送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.30 Location
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.30場所
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. For 201 (Created) responses, the Location is that of the new resource which was created by the request. For 3xx responses, the location SHOULD indicate the server&#39;s preferred URI for automatic redirection to the resource. The field value consists of a single absolute URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロケーションレスポンスヘッダフィールドは、新しいリソースの要求または識別を完了するためのRequest-URI以外の場所に受信者をリダイレクトするために使用されます。 201（作成された）応答のために、場所は要求によって作成された新しいリソースのものです。 3XX応答の場合、場所は、リソースへの自動リダイレクトするために、サーバーの優先URIを示すべきです。フィールドの値は、単一の絶対URIから成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Location = &#34;Location&#34; &#34;:&#34; absoluteURI
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場所= &#34;場所&#34; &#34;：&#34; absoluteURIで
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Location: http://www.w3.org/pub/WWW/People.html
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場所：http://www.w3.org/pub/WWW/People.html
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The Content-Location header field (section 14.14) differs from Location in that the Content-Location identifies the original location of the entity enclosed in the request. It is therefore possible for a response to contain header fields for both Location and Content-Location. Also see section 13.10 for cache requirements of some methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：コンテンツロケーション要求で囲まれたエンティティの元の位置を識別するのContent-Locationヘッダフィールド（セクション14.14）は、ロケーションとは異なります。応答は、ロケーションおよびコンテンツの場所の両方のためのヘッダーフィールドを含むことがことが可能です。また、いくつかのメソッドのキャッシュ要件についてはセクション13.10を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.31 Max-Forwards
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.31マックス・フォワード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Max-Forwards request-header field provides a mechanism with the TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit the number of proxies or gateways that can forward the request to the next inbound server. This can be useful when the client is attempting to trace a request chain which appears to be failing or looping in mid-chain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マックスを転送リクエストヘッダフィールドは、次のインバウンドサーバに要求を転送することができるプロキシまたはゲートウェイの数を制限するTRACE（セクション9.8）とオプション（セクション9.2）の方法とメカニズムを提供します。クライアントは、中鎖に失敗またはループしているように見えるリクエストチェーンをトレースしようとしている場合に便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Max-Forwards = &#34;Max-Forwards&#34; &#34;:&#34; 1*DIGIT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マックス・フォワード=「マックス・フォワード」「：」1 * DIGIT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Max-Forwards value is a decimal integer indicating the remaining number of times this request message may be forwarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最大転送した値は、この要求メッセージが転送される残り回数を示す10進整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each proxy or gateway recipient of a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request. If the received value is zero (0), the recipient MUST NOT forward the request; instead, it MUST respond as the final recipient. If the received Max-Forwards value is greater than zero, then the forwarded message MUST contain an updated Max-Forwards field with a value decremented by one (1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Max-Forwardsヘッダーフィールドを含むTRACEまたはOPTIONS要求の各プロキシまたはゲートウェイ受信者は、要求を転送する前にその値を確認して更新しなければなりません。受信された値がゼロ（0）である場合、受信者は、要求を転送してはいけません。その代わり、それは最終的に受信者として応答しなければなりません。受信された最大転送した値がゼロよりも大きい場合、転送されたメッセージは、一（1）だけ減分値で更新最大転送しフィールドを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Max-Forwards header field MAY be ignored for all other methods defined by this specification and for any extension methods for which it is not explicitly referred to as part of that method definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最大Forwardsヘッダフィールドはこの仕様で定義されたすべての他の方法のために、それが明示的メソッド定義の一部と呼ばされていない任意の拡張メソッドのために無視することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.32 Pragma
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.x2プラグマ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プラグマ一般ヘッダフィールドは、要求/応答チェーンに沿った任意の受信者に適用される可能性のある実装固有のディレクティブを含めるために使用されます。すべてのプラグマ指令はプロトコルの観点から任意の動作を指定します。しかし、いくつかのシステムは、その行動がディレクティブと一致している必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Pragma            = &#34;Pragma&#34; &#34;:&#34; 1#pragma-directive
       pragma-directive  = &#34;no-cache&#34; | extension-pragma
       extension-pragma  = token [ &#34;=&#34; ( token | quoted-string ) ]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the no-cache directive is present in a request message, an application SHOULD forward the request toward the origin server even if it has a cached copy of what is being requested. This pragma directive has the same semantics as the no-cache cache-directive (see section 14.9) and is defined here for backward compatibility with HTTP/1.0. Clients SHOULD include both header fields when a no-cache request is sent to a server not known to be HTTP/1.1 compliant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュなしのディレクティブが要求メッセージ中に存在する場合、それは要求されているもののキャッシュされたコピーを持っている場合でも、アプリケーションがオリジンサーバに向けて要求を転送する必要があります。このプラグマディレクティブは、キャッシュなしのキャッシュ・ディレクティブ（セクション14.9を参照）と同じ意味を持っており、HTTP / 1.0との後方互換性のためにここで定義されています。キャッシュなしの要求が準拠したHTTP / 1.1であることが知られていないサーバーに送信されたときにクライアントが両方のヘッダフィールドを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Pragma directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient SHOULD be ignored by that recipient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディレクティブは、要求/応答チェーンに沿ってすべての受信者に適用可能であるかもしれないので、プラグマ指令は関係なく、そのアプリケーションに対するそれらの重要性の、プロキシまたはゲートウェイアプリケーションが通過しなければなりません。特定の受信者のためのプラグマを指定することはできません。ただし、受信者に関係のない任意のプラグマディレクティブは、その受信者によって無視されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 caches SHOULD treat &#34;Pragma: no-cache&#34; as if the client had sent &#34;Cache-Control: no-cache&#34;. No new Pragma directives will be defined in HTTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1扱うべきキャッシュ &#34;プラグマ：キャッシュなし&#34; クライアントが &#34;：キャッシュなしのCache-Control&#34; 送られたかのように。新しいプラグマディレクティブは、HTTPで定義されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: because the meaning of &#34;Pragma: no-cache as a response header field is not actually specified, it does not provide a reliable replacement for &#34;Cache-Control: no-cache&#34; in a response
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：応答でキャッシュなし 『：のCache-Control：「キャッシュなしレスポンスヘッダフィールドは、実際に指定されていないとして、それは信頼性の高い代替を提供していないプラグマ』の意味ので、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.33 Proxy-Authenticate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.33プロキシ認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Proxy-Authenticate response-header field MUST be included as part of a 407 (Proxy Authentication Required) response. The field value consists of a challenge that indicates the authentication scheme and parameters applicable to the proxy for this Request-URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシ認証レスポンス・ヘッダー・フィールドは、407（プロキシ認証が必要）応答の一部として含まれなければなりません。フィールド値はこのRequest-URIに対してプロキシに適用できる認証スキームとパラメータを示し挑戦で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxy-Authenticate = &#34;Proxy-Authenticate&#34; &#34;:&#34; 1#challenge
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシ認証は=「プロキシ認証」「：」1つの＃挑戦
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HTTP access authentication process is described in &#34;HTTP Authentication: Basic and Digest Access Authentication&#34; [43]. Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the current connection and SHOULD NOT be passed on to downstream clients. However, an intermediate proxy might need to obtain its own credentials by requesting them from the downstream client, which in some circumstances will appear as if the proxy is forwarding the Proxy-Authenticate header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[43]：HTTPアクセス認証プロセスは、「基本とダイジェストアクセス認証HTTP認証」に記載されています。 WWW認証とは異なり、Proxy-Authenticateヘッダフィールドは現在の接続にのみ適用され、下流のクライアントに渡されるべきではありません。しかし、中間プロキシはプロキシがProxy-Authenticateヘッダフィールドを転送しているかのように、いくつかの状況で表示される、下流のクライアントからそれらを要求することにより、独自の資格情報を取得する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.34 Proxy-Authorization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.34プロキシ認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Proxy-Authorization request-header field allows the client to identify itself (or its user) to a proxy which requires authentication. The Proxy-Authorization field value consists of credentials containing the authentication information of the user agent for the proxy and/or realm of the resource being requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシ認証リクエストヘッダフィールドは、クライアントが認証を必要とするプロキシにそれ自体（又はそのユーザ）を識別することを可能にします。プロキシ認証フィールド値は、プロキシおよび/または要求されたリソースのレルムのユーザエージェントの認証情報を含む資格情報から成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxy-Authorization = &#34;Proxy-Authorization&#34; &#34;:&#34; credentials
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシ認証=「プロキシ認証」「：」の資格情報
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HTTP access authentication process is described in &#34;HTTP Authentication: Basic and Digest Access Authentication&#34; [43] . Unlike Authorization, the Proxy-Authorization header field applies only to the next outbound proxy that demanded authentication using the Proxy-Authenticate field. When multiple proxies are used in a chain, the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[43]：HTTPアクセス認証プロセスは、「基本とダイジェストアクセス認証HTTP認証」に記載されています。許可とは異なり、Proxy-Authorizationヘッダフィールドは、プロキシ認証フィールドを使用して認証を要求し、次のアウトバウンドプロキシに適用されます。複数のプロキシがチェーンで使用される場合、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxy-Authorization header field is consumed by the first outbound proxy that was expecting to receive credentials. A proxy MAY relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively authenticate a given request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxy-Authorizationヘッダフィールドは、認証情報を受信するように期待していた最初のアウトバウンドプロキシによって消費されます。それはプロキシが協調与えられた要求を認証するメカニズムがある場合、プロキシは、次のプロキシにクライアント要求から資格情報を中継することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.35 Range
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.35レンジ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.35.1 Byte Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.35.1バイト範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since all HTTP entities are represented in HTTP messages as sequences of bytes, the concept of a byte range is meaningful for any HTTP entity. (However, not all clients and servers need to support byte-range operations.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのHTTPエンティティがバイトの配列のようなHTTPメッセージで表現されているので、バイト範囲の概念は、任意のHTTPエンティティの意味があります。 （ただし、すべてのクライアントとサーバーは、バイト範囲操作をサポートする必要はありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Byte range specifications in HTTP apply to the sequence of bytes in the entity-body (not necessarily the same as the message-body).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPにおけるバイト範囲仕様は、エンティティボディのバイトのシーケンス（メッセージボディとして必ずしも同じではない）に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A byte range operation MAY specify a single range of bytes, or a set of ranges within a single entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト範囲の動作はバイトの単一の範囲、または単一のエンティティ内の範囲のセットを指定するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ranges-specifier = byte-ranges-specifier
       byte-ranges-specifier = bytes-unit &#34;=&#34; byte-range-set
       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )
       byte-range-spec = first-byte-pos &#34;-&#34; [last-byte-pos]
       first-byte-pos  = 1*DIGIT
       last-byte-pos   = 1*DIGIT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first-byte-pos value in a byte-range-spec gives the byte-offset of the first byte in a range. The last-byte-pos value gives the byte-offset of the last byte in the range; that is, the byte positions specified are inclusive. Byte offsets start at zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト範囲仕様の最初のバイト-POS値は、バイトオフセット範囲内の最初のバイトを与えます。最後のバイト-POS値は、バイト・オフセットの範囲内の最後のバイトのを与えます。つまり、指定されたバイト位置が含まれています。バイト・オフセットはゼロから始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the last-byte-pos value is present, it MUST be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte-range-spec is syntactically invalid. The recipient of a byte-range-set that includes one or more syntactically invalid byte-range-spec values MUST ignore the header field that includes that byte-range-set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後のバイト-POS値が存在する場合、そのバイト範囲仕様の最初のバイト-POS以上である必要があり、またはバイト範囲仕様は、構文的に無効です。そのバイト範囲設定含むヘッダフィールドを無視しなければならない一つ以上の構文的に無効なバイト範囲仕様値を含むバイト範囲セットの受取人。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the last-byte-pos value is absent, or if the value is greater than or equal to the current length of the entity-body, last-byte-pos is taken to be equal to one less than the current length of the entity-body in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後のバイト-POS値は存在しないか、または値がより大きいまたはエンティティボディの現在の長さと等しい場合、最後のバイト-POSは、エンティティの現在の長さよりも小さいものと同じであるとみなされる場合バイトで-body。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By its choice of last-byte-pos, a client can limit the number of bytes retrieved without knowing the size of the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後のバイト-POSのその選択により、クライアントは、エンティティのサイズを知らなくても、検索したバイト数を制限することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       suffix-byte-range-spec = &#34;-&#34; suffix-length
       suffix-length = 1*DIGIT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A suffix-byte-range-spec is used to specify the suffix of the entity-body, of a length given by the suffix-length value. (That is, this form specifies the last N bytes of an entity-body.) If the entity is shorter than the specified suffix-length, the entire entity-body is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サフィックス・バイト範囲仕様は、接尾語長の値によって指定された長さの、エンティティボディのサフィックスを指定するために使用されます。 （すなわち、このフォームは、エンティティボディの最後のNバイトを指定する。）エンティティは、指定された接尾語長より短い場合、全体のエンティティボディが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a syntactically valid byte-range-set includes at least one byte-range-spec whose first-byte-pos is less than the current length of the entity-body, or at least one suffix-byte-range-spec with a non-zero suffix-length, then the byte-range-set is satisfiable. Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set is unsatisfiable, the server SHOULD return a response with a status of 416 (Requested range not satisfiable). Otherwise, the server SHOULD return a response with a status of 206 (Partial Content) containing the satisfiable ranges of the entity-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構文的に有効なバイト範囲セットは、少なくとも一つのバイト範囲仕様が含まれている場合、その最初のバイト-POSは、エンティティボディの現在の長さよりも小さい、または非有する少なくとも一つのサフィックス・バイト範囲仕様-zeroサフィックス長は、次いで、バイト範囲セットが充足可能です。それ以外の場合は、バイト範囲-セットが充足不能です。バイト範囲セットが充足不能である場合、サーバーは416の状態（要求された範囲に充足しない）との応答を返すべきです。そうしないと、サーバはエンティティボディの満足できる範囲を含む206（部分コンテンツ）の状態に応答を返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Examples of byte-ranges-specifier values (assuming an entity-body of length 10000):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（長さ10000のエンティティボディと仮定）バイト範囲指定子値の例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The first 500 bytes (byte offsets 0-499, inclusive): bytes=0- 499
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 最初の500バイト（バイトオフセット0から499までの範囲）：バイト= 0〜499
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The second 500 bytes (byte offsets 500-999, inclusive): bytes=500-999
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 第500バイト（バイトオフセット500-999、包括的）：バイト= 500-999
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The final 500 bytes (byte offsets 9500-9999, inclusive): bytes=-500
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 最終的な500バイト（バイトオフセット9500から9999までの範囲）：バイト= -500
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Or bytes=9500-
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - またはバイト= 9500-
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The first and last bytes only (bytes 0 and 9999): bytes=0-0,-1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 最初と最後のバイトのみ（バイト0及び9999）：バイト= 0-0、-1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Several legal but not canonical specifications of the second 500 bytes (byte offsets 500-999, inclusive): bytes=500-600,601-999 bytes=500-700,601-999
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  2番目の500バイト（バイトオフセット500-999、包括的）のいくつかの法的しかし正規のない仕様：バイト= 500-600,601-999バイト= 500-700,601-999
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.35.2 Range Retrieval Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.35.2範囲検索要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP retrieval requests using conditional or unconditional GET methods MAY request one or more sub-ranges of the entity, instead of the entire entity, using the Range request header, which applies to the entity returned as the result of the request:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティに適用され、条件付き又は無条件のGETメソッドがRange要求ヘッダーを使用して、全体ではなく、エンティティのエンティティの1つ以上のサブ範囲を、要求することができる使用して、HTTP検索要求は、要求の結果として返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Range = &#34;Range&#34; &#34;:&#34; ranges-specifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レンジ=「範囲」「：」範囲指定子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server MAY ignore the Range header. However, HTTP/1.1 origin servers and intermediate caches ought to support byte ranges when possible, since Range supports efficient recovery from partially failed transfers, and supports efficient partial retrieval of large entities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、Rangeヘッダを無視するかもしれません。範囲が部分的に失敗した転送の効率的な回収をサポートし、大規模な事業体の効率的な部分的な検索をサポートしているので、HTTP / 1.1オリジンサーバと中間キャッシュは、可能な場合はバイト範囲をサポートするべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server supports the Range header and the specified range or ranges are appropriate for the entity:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがRangeヘッダをサポートしている場合、指定された範囲または範囲は、エンティティのために適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The presence of a Range header in an unconditional GET modifies what is returned if the GET is otherwise successful. In other words, the response carries a status code of 206 (Partial Content) instead of 200 (OK).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 無条件GETにおけるRangeヘッダの存在はGETが他の成功した場合に返されるものを変更します。換言すれば、応答は、代わりに200（OK）206のステータスコード（部分コンテンツ）を運びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The presence of a Range header in a conditional GET (a request using one or both of If-Modified-Since and If-None-Match, or one or both of If-Unmodified-Since and If-Match) modifies what is returned if the GET is otherwise successful and the condition is true. It does not affect the 304 (Not Modified) response returned if the conditional is false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 条件付きGETにおけるRangeヘッダの存在（一方または両方使用して要求した場合は、以来修飾及び場合-なしマッチ、または1つまたは両方の場合、未修飾-ため及び場合マッチ）が返されるものを変更しますGETは、そうでない場合は成功し、条件がtrueの場合。これは、条件付きがfalseの場合に返さ304（未修正）応答には影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In some cases, it might be more appropriate to use the If-Range header (see section 14.27) in addition to the Range header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場合によっては、Rangeヘッダに加えたIf-Rangeヘッダ（セクション14.27を参照）を使用する方が適切かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a proxy that supports ranges receives a Range request, forwards the request to an inbound server, and receives an entire entity in reply, it SHOULD only return the requested range to its client. It SHOULD store the entire received response in its cache if that is consistent with its cache allocation policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
範囲をサポートしているプロキシが範囲要求を受信した場合、インバウンドサーバに要求を転送し、応答にエンティティ全体を受信し、それだけでそのクライアントに要求された範囲を返すべきです。それは、そのキャッシュの割り当てポリシーと一致している場合は、そのキャッシュに全体受信した応答を格納する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.36 Referer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.36リファラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Referer[sic] request-header field allows the client to specify, for the server&#39;s benefit, the address (URI) of the resource from which the Request-URI was obtained (the &#34;referrer&#34;, although the header field is misspelled.) The Referer request-header allows a server to generate lists of back-links to resources for interest, logging, optimized caching, etc. It also allows obsolete or mistyped links to be traced for maintenance. The Referer field MUST NOT be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リファラーの[sic]リクエストヘッダフィールドは、クライアントが、サーバの利益のために、リクエストURIが取得されたリソースのアドレス（URI）を指定することを可能にする（ヘッダフィールドをスペルミスしているが、「リファラー」と。）リファラーリクエストヘッダには、サーバがそれはまた時代遅れやタイプミスのリンクがメンテナンスのためにトレースすることを可能にするなど関心、ロギング、最適化されたキャッシュのためのリソースへのバックリンクのリストを生成することができます。リクエストURIは、ユーザのキーボードからの入力として、それ自身のURIを持たないソースから入手した場合リファラーフィールドを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Referer = &#34;Referer&#34; &#34;:&#34; ( absoluteURI | relativeURI )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リファラー= &#34;リファラー&#34; &#34;：&#34;（absoluteURIで| relativeURI）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Referer: http://www.w3.org/hypertext/DataSources/Overview.html
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リファラー：http://www.w3.org/hypertext/DataSources/Overview.html
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the field value is a relative URI, it SHOULD be interpreted relative to the Request-URI. The URI MUST NOT include a fragment. See section 15.1.3 for security considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールド値が相対URIである場合、それは、Request-URIに対して解釈されるべきです。 URIには、フラグメントを含んではいけません。セキュリティ上の考慮事項についてはセクション15.1.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.37 Retry-After
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.37リトライした後、
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. This field MAY also be used with any 3xx (Redirection) response to indicate the minimum time the user-agent is asked wait before issuing the redirected request. The value of this field can be either an HTTP-date or an integer number of seconds (in decimal) after the time of the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リトライ後レスポンスヘッダフィールドは、サービスを要求しているクライアントに利用できないと予想される時間の長さを示すために503（サービス利用不可）応答と共に使用することができます。このフィールドは、ユーザーエージェントがリダイレクトされたリクエストを発行する前に待機を依頼される最小時間を示すために、任意の300番台（リダイレクト）応答で使用されるかもしれません。このフィールドの値は、応答の時間後にHTTP-日付または（10進数）秒の整数のいずれかであり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Retry-After = &#34;Retry-After&#34; &#34;:&#34; ( HTTP-date | delta-seconds )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リトライ後= &#34;再試行-後&#34; &#34;：&#34;（HTTP-日|デルタ秒）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Two examples of its use are
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その使用の2つの例は、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the latter example, the delay is 2 minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
後者の例では、遅延は2分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.38 Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.38サーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Server response-header field contains information about the software used by the origin server to handle the request. The field can contain multiple product tokens (section 3.8) and comments identifying the server and any significant subproducts. The product tokens are listed in order of their significance for identifying the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーレスポンスヘッダフィールドは、リクエストを処理するためにオリジンサーバによって使用されているソフトウェアに関する情報が含まれています。フィールドは、サーバと、任意の有意なサブプロダクトを識別する複数の製品トークン（セクション3.8）とコメントを含むことができます。製品トークンはアプリケーションを識別するためのその重要性の順に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Server = &#34;Server&#34; &#34;:&#34; 1*( product | comment )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー= &#34;サーバー&#34; &#34;：&#34; 1 *（製品|コメント）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Server: CERN/3.0 libwww/2.17
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー：CERN / 3.0のlibwww / 2.17
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the response is being forwarded through a proxy, the proxy application MUST NOT modify the Server response-header. Instead, it SHOULD include a Via field (as described in section 14.45).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答がプロキシを介して転送されている場合は、プロキシ・アプリケーションは、サーバーの応答ヘッダを変更してはいけません。 （セクション14.45で説明したように）代わりに、Viaフィールドを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Revealing the specific software version of the server might allow the server machine to become more vulnerable to attacks against software that is known to contain security holes. Server implementors are encouraged to make this field a configurable option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：サーバーの特定のソフトウェアバージョンを明らかにすることは、サーバー・マシンがセキュリティホールを含むことが知られているソフトウェアに対する攻撃に対してより脆弱になることを許可することがあります。サーバーの実装者は、このフィールド設定可能なオプションにすることが奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.39 TE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
１４。３９ て
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TE request-header field indicates what extension transfer-codings it is willing to accept in the response and whether or not it is willing to accept trailer fields in a chunked transfer-coding. Its value may consist of the keyword &#34;trailers&#34; and/or a comma-separated list of extension transfer-coding names with optional accept parameters (as described in section 3.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TEリクエストヘッダフィールドは、応答して、チャンク転送符号化におけるトレーラフィールドを受け入れる意志があるか否かを受け入れる意志があるもの拡張転送コーディングを示します。その値は、キーワード「予告編」および/または任意受け入れるパラメータ（セクション3.6で説明したように）を有する拡張転送コーディング名のカンマ区切りリストから構成されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       TE        = &#34;TE&#34; &#34;:&#34; #( t-codings )
       t-codings = &#34;trailers&#34; | ( transfer-extension [ accept-params ] )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The presence of the keyword &#34;trailers&#34; indicates that the client is willing to accept trailer fields in a chunked transfer-coding, as defined in section 3.6.1. This keyword is reserved for use with transfer-coding values even though it does not itself represent a transfer-coding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キーワード「トレーラー」の存在は、クライアントがセクション3.6.1で定義されているように、チャンク転送コーディングでトレーラーフィールドを受け入れることを望んでいることを示しています。このキーワードは、それ自体が転送コーディングを示すものではありませんが転送コーディング値を使用するために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Examples of its use are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その使用の例は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TE header field only applies to the immediate connection. Therefore, the keyword MUST be supplied within a Connection header field (section 14.10) whenever TE is present in an HTTP/1.1 message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TEヘッダフィールドは直接の接続に適用されます。 TEは、HTTP / 1.1メッセージに存在しているときはいつでもそのため、キーワードは、Connectionヘッダフィールド（セクション14.10）内に供給されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server tests whether a transfer-coding is acceptable, according to a TE field, using these rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ・テスト転送コーディングは、これらのルールを使用して、TEフィールドに従って、許容可能であるかどうか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. The &#34;chunked&#34; transfer-coding is always acceptable. If the keyword &#34;trailers&#34; is listed, the client indicates that it is willing to accept trailer fields in the chunked response on behalf of itself and any downstream clients. The implication is that, if given, the client is stating that either all downstream clients are willing to accept trailer fields in the forwarded response, or that it will attempt to buffer the response on behalf of downstream recipients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.「チャンク」転送コーディングは常に可能です。キーワード「トレーラー」が表示されている場合、クライアントは、それ自体の代理と任意のダウンストリームクライアント上のチャンク応じて、トレーラーのフィールドを受け入れることを望んでいることを示しています。含意は与えられた場合、クライアントはすべてのダウンストリームのクライアントのいずれかが転送応答トレーラーフィールドを受け入れて喜んでであることを示す、またはそれは下流の受信者に代わって応答をバッファリングしようとすることです、ということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: HTTP/1.1 does not define any means to limit the size of a chunked response such that a client can be assured of buffering the entire response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：HTTP / 1.1クライアントが応答全体をバッファリングを保証することができるようなチャンク応答の大きさを制限するいかなる手段を定義していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. If the transfer-coding being tested is one of the transfer-codings listed in the TE field, then it is acceptable unless it is accompanied by a qvalue of 0. (As defined in section 3.9, a qvalue of 0 means &#34;not acceptable.&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.転送コーディングテストされ、セクション3.9で定義されるように、それが0ののqvalue（伴うされていない限り、それが許容されるTEフィールドにリストされた転送コーディングの1つは、0手段のqvalue「でない場合許容できます。」）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. If multiple transfer-codings are acceptable, then the acceptable transfer-coding with the highest non-zero qvalue is preferred. The &#34;chunked&#34; transfer-coding always has a qvalue of 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の転送コーディングが許容される場合3.その後に許容される転送コーディング最高非ゼロのqvalueを有することが好ましいです。転送コーディングは常に1ののqvalueを持つ「チャンク」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the TE field-value is empty or if no TE field is present, the only transfer-coding is &#34;chunked&#34;. A message with no transfer-coding is always acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TEフィールド値が空であるか、何のTEフィールドが存在しない場合は、専用の転送コーディングがある場合は、「チャンク」。無転送コーディングのメッセージは常に許容されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.40 Trailer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.40トレーラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Trailer general field value indicates that the given set of header fields is present in the trailer of a message encoded with chunked transfer-coding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トレーラー一般的なフィールド値は、ヘッダフィールドの所定のセットは、チャンク転送符号化で符号化されたメッセージのトレーラーに存在することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Trailer = &#34;Trailer&#34; &#34;:&#34; 1#field-name
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トレーラー=「予告編」「：」1＃フィールド名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An HTTP/1.1 message SHOULD include a Trailer header field in a message using chunked transfer-coding with a non-empty trailer. Doing so allows the recipient to know which header fields to expect in the trailer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1メッセージは、チャンク転送符号化の非空のトレーラとを使用して、メッセージトレーラーヘッダフィールドを含むべきです。そうすることで、受信者がトレーラーに期待しているヘッダフィールドを知ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If no Trailer header field is present, the trailer SHOULD NOT include any header fields. See section 3.6.1 for restrictions on the use of trailer fields in a &#34;chunked&#34; transfer-coding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何のトレーラーヘッダーフィールドが存在しない場合は、トレーラーは、任意のヘッダフィールドを含むべきではありません。 「チャンク」転送コーディングでトレーラーフィールドの使用上の制限については、セクション3.6.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Message header fields listed in the Trailer header field MUST NOT include the following header fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トレーラーヘッダーフィールドにリストされたメッセージヘッダーフィールドは、以下のヘッダフィールドを含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
. Transfer-Encoding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。転送エンコーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
. Content-Length
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。コンテンツの長さ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
. Trailer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。トレーラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.41 Transfer-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.41転送エンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Transfer-Encoding general-header field indicates what (if any) type of transformation has been applied to the message body in order to safely transfer it between the sender and the recipient. This differs from the content-coding in that the transfer-coding is a property of the message, not of the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変換の種類安全に送信者と受信者の間に転送するためにメッセージボディに適用されている（存在する場合）は、転送エンコード一般的なヘッダフィールドは何を示しています。これは転送コーディングがメッセージのではなく、エンティティのプロパティであることを符号化コンテンツとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transfer-Encoding = &#34;Transfer-Encoding&#34; &#34;:&#34; 1#transfer-coding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送エンコード=「転送エンコーディング」「：」1つの＃転送コーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transfer-codings are defined in section 3.6. An example is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送コーディングは、セクション3.6で定義されています。例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transfer-Encoding: chunked
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送エンコード：チャンク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If multiple encodings have been applied to an entity, the transfer-codings MUST be listed in the order in which they were applied. Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数のエンコーディングがエンティティに適用されている場合は、転送コーディングは、それらが適用された順にリストされなければなりません。符号化パラメータに関する追加情報は、本明細書で定義されていない他のエンティティヘッダフィールドによって提供されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many older HTTP/1.0 applications do not understand the Transfer-Encoding header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くの古いHTTP / 1.0のアプリケーションは、転送-Encodingヘッダを理解していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.42 Upgrade
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.42アップグレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Upgrade general-header allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols. The server MUST use the Upgrade header field within a 101 (Switching Protocols) response to indicate which protocol(s) are being switched.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アップグレードの一般ヘッダは、クライアントがサポートしている追加の通信プロトコルを指定することができますし、サーバーがプロトコルをスイッチすることが適当であると認める場合に使用したいと思います。サーバは、どのプロトコル（単数または複数）に切り替えられていることを示すために101（スイッチングプロトコル）応答内のアップグレードヘッダーフィールドを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upgrade = &#34;Upgrade&#34; &#34;:&#34; 1#product
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= &#34; &#34;アップグレード&#34; アップグレード：&#34; 1つの＃製品
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 2.0 / 1.3 SHTTP、IRC / 6.9、RTA / X11：アップグレード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Upgrade header field is intended to provide a simple mechanism for transition from HTTP/1.1 to some other, incompatible protocol. It does so by allowing the client to advertise its desire to use another protocol, such as a later version of HTTP with a higher major version number, even though the current request has been made using HTTP/1.1. This eases the difficult transition between incompatible protocols by allowing the client to initiate a request in the more commonly supported protocol while indicating to the server that it would like to use a &#34;better&#34; protocol if available (where &#34;better&#34; is determined by the server, possibly according to the nature of the method and/or resource being requested).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アップグレードヘッダフィールドは、いくつかの他の、互換性のないプロトコルにHTTP / 1.1から移行するための簡単なメカニズムを提供することを意図しています。これは、現在のリクエストがHTTP / 1.1を使用して作られているにもかかわらず、そのような高いメジャーバージョン番号を持つHTTPの以降のバージョンとして、クライアントが別のプロトコルを使用するという願望を宣伝できるようにすることで、そうします。利用できる（ここで「良好」サーバによって判定された場合、それは「より良い」プロトコルを使用したいサーバーに示しているが、これは、より一般的にサポートされるプロトコルで要求を開始するクライアントを可能にすることにより、互換性のないプロトコル間困難な遷移を容易におそらく方法及び/又はリソースの性質に応じて）要求されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Upgrade header field only applies to switching application-layer protocols upon the existing transport-layer connection. Upgrade cannot be used to insist on a protocol change; its acceptance and use by the server is optional. The capabilities and nature of the application-layer communication after the protocol change is entirely dependent upon the new protocol chosen, although the first action after changing the protocol MUST be a response to the initial HTTP request containing the Upgrade header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アップグレードヘッダフィールドは、既存のトランスポート層接続時にアプリケーション層プロトコルの切り替えにも適用されます。アップグレードは、プロトコルの変更を主張するために使用することはできません。サーバによるその受諾と使用は任意です。プロトコルを変更した後の最初のアクションは、アップグレードヘッダフィールドを含む最初のHTTP要求に応答しなければならないが、プロトコル変更後のアプリケーション層通信の能力および性質は、選択された新しいプロトコルに完全に依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Upgrade header field only applies to the immediate connection. Therefore, the upgrade keyword MUST be supplied within a Connection header field (section 14.10) whenever Upgrade is present in an HTTP/1.1 message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upgradeヘッダフィールドは直接の接続に適用されます。したがって、アップグレード・キーワードは、アップグレードがHTTP / 1.1メッセージに存在しているときはいつでも接続ヘッダフィールド（セクション14.10）内に供給されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Upgrade header field cannot be used to indicate a switch to a protocol on a different connection. For that purpose, it is more appropriate to use a 301, 302, 303, or 305 redirection response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upgradeヘッダフィールドは異なる接続でプロトコルへの切り替えを指示するために使用することができません。そのためには、301、302、303、または305リダイレクト応答を使用することがより適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification only defines the protocol name &#34;HTTP&#34; for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of section 3.1 and future updates to this specification. Any token can be used as a protocol name; however, it will only be useful if both the client and server associate the name with the same protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本明細書のセクション3.1および将来のアップデートのHTTPバージョンルールによって定義されるように、この仕様は、ハイパーテキスト転送プロトコルのファミリが使用するプロトコル名「HTTP」を定義します。任意のトークンは、プロトコル名として使用することができます。クライアントとサーバーの両方が同じプロトコルに名前を関連付ける場合しかし、それだけで有用であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.43 User-Agent
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.43のUser-Agent
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The User-Agent request-header field contains information about the user agent originating the request. This is for statistical purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses to avoid particular user agent limitations. User agents SHOULD include this field with requests. The field can contain multiple product tokens (section 3.8) and comments identifying the agent and any subproducts which form a significant part of the user agent. By convention, the product tokens are listed in order of their significance for identifying the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
User-Agentリクエストヘッダフィールドは、リクエストを発信するユーザエージェントに関する情報が含まれています。これは、統計目的、プロトコル違反の追跡、および特定のユーザエージェントの制限を回避するために応答を調整するためにユーザエージェントの自動化された認識のためです。ユーザエージェントはリクエストにこのフィールドを含むべきです。フィールドは、複数の製品トークン（セクション3.8）とする薬剤を同定するコメントやユーザエージェントの重要な部分を形成する任意のサブプロダクトを含むことができます。慣例により、製品トークンはアプリケーションを識別するためのその重要性の順に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
User-Agent = &#34;User-Agent&#34; &#34;:&#34; 1*( product | comment )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
User-Agent = &#34;ユーザエージェント&#34; &#34;：&#34; 1 *（製品|コメント）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
User-Agent: CERN-LineMode/2.15 libwww/2.17b3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
User-Agent：CERN-ラインモード（LineMode！）/ 2.15のlibwww / 2.17b3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.44 Vary
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.44はヴァリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. For uncacheable or stale responses, the Vary field value advises the user agent about the criteria that were used to select the representation. A Vary field value of &#34;*&#34; implies that a cache cannot determine from the request headers of a subsequent request whether this response is the appropriate representation. See section 13.6 for use of the Vary header field by caches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヴァリフィールドの値は、応答がキャッシュを再検証することなく、後続の要求に応答するために応答を使用することが許可されているか否かを、新鮮であるが、完全に、決定リクエスト・ヘッダー・フィールドの集合を示します。キャッシュ不可または古い応答のために、ヴァリフィールド値は、表現を選択するために使用された基準について、ユーザーエージェントを助言します。 Aは、「*」のフィールドの値を変化キャッシュは、この応答が適切であるかどうかを後続リクエストのリクエストヘッダから決定することができないことを意味します。キャッシュによって異なるヘッダフィールドの使用のためのセクション13.6を参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Vary = &#34;Vary&#34; &#34;:&#34; ( &#34;*&#34; | 1#field-name )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= &#34; &#34;異なる&#34; ヴァリ：&#34;（ &#34;*&#34; | 1＃フィールド名）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An HTTP/1.1 server SHOULD include a Vary header field with any cacheable response that is subject to server-driven negotiation. Doing so allows a cache to properly interpret future requests on that resource and informs the user agent about the presence of negotiation on that resource. A server MAY include a Vary header field with a non-cacheable response that is subject to server-driven negotiation, since this might provide the user agent with useful information about the dimensions over which the response varies at the time of the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1サーバは、サーバ駆動の交渉の対象となる任意のキャッシュ可能な応答に応じて変動ヘッダフィールドを含むべきです。そうすることでキャッシュが適切にそのリソースに今後の要求を解釈することを可能にし、そのリソース上の交渉の存在についてユーザエージェントに通知します。サーバーは、この応答は、応答時に変化する上に寸法に関する有用な情報をユーザエージェントを提供するかもしれないので、サーバ駆動型ネゴシエーションを受けるキャッシュ不可能な応答とともに変化するヘッダ・フィールドを含んでいてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Vary field value consisting of a list of field-names signals that the representation selected for the response is based on a selection algorithm which considers ONLY the listed request-header field values in selecting the most appropriate representation. A cache MAY assume that the same selection will be made for future requests with the same values for the listed field names, for the duration of time for which the response is fresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aは、応答のために選択された表現が最も適切な表現を選択することでのみ記載されているリクエスト・ヘッダー・フィールドの値を考慮した選択アルゴリズムに基づいてフィールド名信号のリストからなるフィールド値を変更します。キャッシュは、同じ選択が応答が新鮮である時間の長さのために記載されているフィールド名、値が同じである、今後の要求のために作られることを仮定してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The field-names given are not limited to the set of standard request-header fields defined by this specification. Field names are case-insensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
与えられたフィールド名は、本明細書で定義されている標準リクエストヘッダフィールドのセットに限定されません。フィールド名は大文字と小文字を区別しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Vary field value of &#34;*&#34; signals that unspecified parameters not limited to the request-headers (e.g., the network address of the client), play a role in the selection of the response representation. The &#34;*&#34; value MUST NOT be generated by a proxy server; it may only be generated by an origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aは、不特定のパラメータは、リクエストヘッダ（例えば、クライアントのネットワーク・アドレス）に限定されるものではなく、「*」信号のフィールドの値を変え、応答表現の選択において役割を果たす。 「*」の値は、プロキシサーバによって生成されてはなりません。それだけでオリジンサーバによって生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.45 Via
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.45経由
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Via general-header field MUST be used by gateways and proxies to indicate the intermediate protocols and recipients between the user agent and the server on requests, and between the origin server and the client on responses. It is analogous to the &#34;Received&#34; field of RFC 822 [9] and is intended to be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of all senders along the request/response chain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
経由一般ヘッダフィールドは、ユーザエージェントとのリクエストでサーバーとの間の中間プロトコルと受信者を示すためにゲートウェイやプロキシによって使用され、オリジンサーバと応答上のクライアントの間でなければなりません。これは、[9] RFC 822の「受信」フィールドに類似していると、メッセージの転送を追跡要求ループを回避し、そして要求/応答チェーンに沿ってすべての送信者のプロトコル能力を識別するために使用されることが意図されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Via = &#34;Via&#34; &#34;:&#34; 1#( received-protocol received-by [ comment ] ) received-protocol = [ protocol-name &#34;/&#34; ] protocol-version protocol-name = token protocol-version = token received-by = ( host [ &#34;:&#34; port ] ) | pseudonym pseudonym = token
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「1＃（受信プロトコルで受信することにより[コメント]）を受信プロトコル= [プロトコル名「/」]プロトコルバージョンプロトコル名=トークンプロトコルバージョン=トークンが受信されたバイ=：=「を介して」」を介して（ホスト[ &#34;：&#34; ポート]）|仮名仮名=トークン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The received-protocol indicates the protocol version of the message received by the server or client along each segment of the request/response chain. The received-protocol version is appended to the Via field value when the message is forwarded so that information about the protocol capabilities of upstream applications remains visible to all recipients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信プロトコルは、要求/応答チェーンの各セグメントに沿って、サーバまたはクライアントによって受信されたメッセージのプロトコルバージョンを示しています。メッセージが転送されたときに上流のアプリケーションのプロトコル能力に関する情報がすべての受信者に表示されたままとなるよう受信プロトコルバージョンは、Viaフィールドの値に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The protocol-name is optional if and only if it would be &#34;HTTP&#34;. The received-by field is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, it MAY be replaced by a pseudonym. If the port is not given, it MAY be assumed to be the default port of the received-protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、「HTTP」だろうと場合にのみ場合、プロトコル名はオプションです。受信して、フィールドは、通常は、その後、メッセージを転送し、受信者のサーバーまたはクライアントのホストおよびオプションのポート番号です。本物のホストは機密情報であるとみなされた場合しかし、それは仮名で置き換えてもよいです。ポートが指定されていない場合は、受信したプロトコルのデフォルトポートであると仮定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multiple Via field values represents each proxy or gateway that has forwarded the message. Each recipient MUST append its information such that the end result is ordered according to the sequence of forwarding applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールド値を介して複数のメッセージを転送した各プロキシまたはゲートウェイを表します。各受信者は、最終的な結果は、転送アプリケーションの順序に従って順序付けされるように、その情報を追加しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Comments MAY be used in the Via header field to identify the software of the recipient proxy or gateway, analogous to the User-Agent and Server header fields. However, all comments in the Via field are optional and MAY be removed by any recipient prior to forwarding the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コメントは、ユーザエージェントとサーバのヘッダフィールドに類似し、受信者プロキシまたはゲートウェイのソフトウェアを識別するためにViaヘッダーフィールドで使用されるかもしれません。しかし、Viaフィールド内のすべてのコメントはオプションであり、メッセージを転送する前に受信者によって除去することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named &#34;fred&#34;, which uses HTTP/1.1 to forward the request to a public proxy at nowhere.com, which completes the request by forwarding it to the origin server at www.ics.uci.edu. The request received by www.ics.uci.edu would then have the following Via header field:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、要求メッセージは、内部プロキシコードネーム「フレッド」によって要求を完了nowhere.comで公衆プロキシに要求を転送するHTTP / 1.1を使用するHTTP / 1.0ユーザエージェントから送信することができますwww.ics.uci.eduでオリジンサーバに転送します。 www.ics.uci.eduで受信した要求は、Viaヘッダーフィールド以下があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビア：1.0フレッド、1.1 nowhere.com（アパッチ/ 1.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxies and gateways used as a portal through a network firewall SHOULD NOT, by default, forward the names and ports of hosts within the firewall region. This information SHOULD only be propagated if explicitly enabled. If not enabled, the received-by host of any host behind the firewall SHOULD be replaced by an appropriate pseudonym for that host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークファイアウォール経由のポータルとして使用するプロキシとゲートウェイは、デフォルトでは、ファイアウォール領域内のホストの名前とポートを転送すべきではありません。明示的に有効にした場合、この情報にのみ伝搬されるべきです。有効でない場合は、受信して、ファイアウォールの背後にある任意のホストのホスト、そのホストのための適切なペンネームで交換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For organizations that have strong privacy requirements for hiding internal structures, a proxy MAY combine an ordered subsequence of Via header field entries with identical received-protocol values into a single such entry. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
内部構造を隠蔽するための強力なプライバシー要件を持っている組織では、プロキシは、そのような単一のエントリに、同一の受信プロトコル値を持つViaヘッダーフィールドエントリの順序付きサブシーケンスを組み合わせることができます。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビア：1.0リッキー、1.1エセル、1.1フレッド、1.0ルーシー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
could be collapsed to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
に折りたたむことができ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビア：1.0リッキー、1.1メルツ、1.0ルーシー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Applications SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms. Applications MUST NOT combine entries which have different received-protocol values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らはすべて同じ組織の管理下にあり、ホストが既に偽名に置き換えられていない限り、アプリケーションは、複数のエントリを結合すべきではありません。アプリケーションは、異なる受信プロトコル値を持つエントリを組み合わせてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.46 Warning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.46警告
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Warning general-header field is used to carry additional information about the status or transformation of a message which might not be reflected in the message. This information is typically used to warn about a possible lack of semantic transparency from caching operations or transformations applied to the entity body of the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告一般的なヘッダフィールドは、メッセージに反映されないかもしれないメッセージのステータスまたは変換に関する追加情報を搬送するために使用されます。この情報は、典型的には、メッセージのエンティティボディに適用される操作または変換をキャッシュから意味の透明性の可能性の欠如について警告するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warning headers are sent with responses using:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告ヘッダは使用して応答して送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warning = &#34;Warning&#34; &#34;:&#34; 1#warning-value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告=「警告」「：」1＃警告値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
warning-value = warn-code SP warn-agent SP warn-text [SP warn-date]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告値=警告コードSP警告エージェントSP警告テキスト[SP警告日付]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
warn-code = 3DIGIT warn-agent = ( host [ &#34;:&#34; port ] ) | pseudonym ; the name or pseudonym of the server adding ; the Warning header, for use in debugging warn-text = quoted-string warn-date = &lt;&#34;&gt; HTTP-date &lt;&#34;&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告コード= 3DIGIT警告エージェント=（ホスト[ &#34;：&#34; ポート]）|ペンネーム;追加するサーバーの名前または仮名。警告ヘッダー、デバッグでの使用がために警告するテキスト=引用符で囲まれた文字列を警告日付= &lt;「&gt; HTTP-日&lt;」&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A response MAY carry more than one Warning header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答は、複数の警告ヘッダを搬送することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The warn-text SHOULD be in a natural language and character set that is most likely to be intelligible to the human user receiving the response. This decision MAY be based on any available knowledge, such as the location of the cache or user, the Accept-Language field in a request, the Content-Language field in a response, etc. The default language is English and the default character set is ISO-8859-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告テキストは、応答を受け取る人間のユーザに理解できる可能性が最も高い自然言語と文字セットにする必要があります。この決定は、このようなキャッシュやユーザの場所として、任意の利用可能な知識に基づくことができる、などのデフォルト言語要求内のAccept-言語フィールド、レスポンスのContent-Languageフィールドには、英語とデフォルトの文字セットですISO-8859-1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a character set other than ISO-8859-1 is used, it MUST be encoded in the warn-text using the method described in RFC 2047 [14].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文字は、ISO-8859-1以外が使用されて設定されている場合、それは、RFC 2047 [14]に記載の方法を用いて、警告テキストにエンコードされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warning headers can in general be applied to any message, however some specific warn-codes are specific to caches and can only be applied to response messages. New Warning headers SHOULD be added after any existing Warning headers. A cache MUST NOT delete any Warning header that it received with a message. However, if a cache successfully validates a cache entry, it SHOULD remove any Warning headers previously attached to that entry except as specified for specific Warning codes. It MUST then add any Warning headers received in the validating response. In other words, Warning headers are those that would be attached to the most recent relevant response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告ヘッダは一般に、しかし、いくつかの特定は、警告・コードがキャッシュに特異的であるとのみ応答メッセージに適用することができる、任意のメッセージにも適用することができます。新しい警告ヘッダは、既存の警告ヘッダーの後に追加する必要があります。キャッシュは、それがメッセージを受け取ったすべての警告ヘッダを削除してはなりません。キャッシュがうまくキャッシュエントリを検証する場合は、それは以前に特定の警告コードのために指定された場合を除き、そのエントリに接続されているすべての警告ヘッダを削除する必要があります。その後、検証を受けて受信したすべての警告ヘッダを追加しなければなりません。言い換えれば、警告ヘッダは、関連する最新の応答に取り付けられるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When multiple Warning headers are attached to a response, the user agent ought to inform the user of as many of them as possible, in the order that they appear in the response. If it is not possible to inform the user of all of the warnings, the user agent SHOULD follow these heuristics:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の警告ヘッダーが応答に添付されている場合、ユーザーエージェントは、彼らが応答に表示されるためには、それらの可能な限り多くのユーザーに知らせるべきです。それは警告のすべてのユーザに知らせることができない場合、ユーザエージェントは、これらの経験則に従ってください：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Warnings that appear early in the response take priority over those appearing later in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 初期応答で表示される警告が応答の後半で登場するものを優先します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Warnings in the user&#39;s preferred character set take priority over warnings in other character sets but with identical warn-codes and warn-agents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ユーザの好みの文字で警告が他の文字セットに警告よりも優先しているが同一で、コードを警告して、薬を警告しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Systems that generate multiple Warning headers SHOULD order them with this user agent behavior in mind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の警告ヘッダを生成するシステムは念頭に置いて、このユーザエージェントの行動でそれらを注文する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Requirements for the behavior of caches with respect to Warnings are stated in section 13.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告に関するキャッシュの振る舞いの要件は、セクション13.1.2に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is a list of the currently-defined warn-codes, each with a recommended warn-text in English, and a description of its meaning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、現在定義されて警告する - コードのリストである、お勧めとのそれぞれは英語でテキストを警告し、その意味の説明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
110 Response is stale MUST be included whenever the returned response is stale.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
110応答返される応答が失効しているときはいつでも含まなければならない陳腐です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
111 Revalidation failed MUST be included if a cache returns a stale response because an attempt to revalidate the response failed, due to an inability to reach the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答を再確認しようとする試みが失敗したため、キャッシュが原因のサーバーに到達することができないため、古くなったレスポンスを返す場合、再検証が失敗した111を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
112 Disconnected operation SHOULD be included if the cache is intentionally disconnected from the rest of the network for a period of time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュが意図時間の期間のためのネットワークの残りの部分から切断された場合112切断動作が含まれるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
113 Heuristic expiration MUST be included if the cache heuristically chose a freshness lifetime greater than 24 hours and the response&#39;s age is greater than 24 hours.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュが発見的に24時間よりも大きいとレスポンスの年齢が24時間以上である新鮮寿命を選択した場合は113ヒューリスティック有効期限が含まれなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
199 Miscellaneous warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告文は、任意の情報を含んでいてもよい199その他の警告が人間のユーザに提示、または記録されています。この警告を受けたシステムは、ユーザに警告を提示するほか、任意の自動化された行動をしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
214 Transformation applied MUST be added by an intermediate cache or proxy if it applies any transformation changing the content-coding (as specified in the Content-Encoding header) or media-type (as specified in the Content-Type header) of the response, or the entity-body of the response, unless this Warning code already appears in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
214形質転換は、それが応答の任意のコンテンツコードを変更変換（コンテンツエンコードヘッダで指定されるように）、またはメディアタイプ（Content-Typeヘッダで指定されるように）適用される場合、中間キャッシュまたはプロキシによって追加されなければならない適用しましたまたは応答のエンティティボディは、この警告コードはすでに対応して表示されていない限り。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
299 Miscellaneous persistent warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告文は、任意の情報を含んでいてもよい299その他の永続的な警告が人間のユーザに提示、または記録されています。この警告を受けたシステムは、任意の自動化された行動をしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an implementation sends a message with one or more Warning headers whose version is HTTP/1.0 or lower, then the sender MUST include in each warning-value a warn-date that matches the date in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装バージョンHTTP / 1.0以下である一つ以上の警告ヘッダを持つメッセージを送信する場合、送信者は、各警告値に応答して、日付と一致警告日付を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an implementation receives a message with a warning-value that includes a warn-date, and that warn-date is different from the Date value in the response, then that warning-value MUST be deleted from the message before storing, forwarding, or using it. (This prevents bad consequences of naive caching of Warning header fields.) If all of the warning-values are deleted for this reason, the Warning header MUST be deleted as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は警告日付を含む警告値を持つメッセージを受信し、その警告日付は、応答の日付値と異なる場合、その警告値は、格納、転送、または前にメッセージから削除する必要がありますそれを使用。 （これは、ヘッダフィールドを警告のナイーブキャッシングの悪い影響を防止する。）警報値の全てが、この理由のために削除された場合、警告ヘッダも削除しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.47 WWW-Authenticate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.47 WWW認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The WWW-Authenticate response-header field MUST be included in 401 (Unauthorized) response messages. The field value consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the Request-URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WWW認証応答ヘッダフィールドは401（不正な）応答メッセージに含まれなければなりません。フィールドの値は、Request-URIに適用可能な認証方式（S）とパラメータを示す少なくとも一つのチャレンジから成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
WWW-Authenticate = &#34;WWW-Authenticate&#34; &#34;:&#34; 1#challenge
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WWW認証は= &#34;WWW認証&#34; &#34;：&#34; 1つの＃挑戦
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HTTP access authentication process is described in &#34;HTTP Authentication: Basic and Digest Access Authentication&#34; [43]. User agents are advised to take special care in parsing the WWW-Authenticate field value as it might contain more than one challenge, or if more than one WWW-Authenticate header field is provided, the contents of a challenge itself can contain a comma-separated list of authentication parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[43]：HTTPアクセス認証プロセスは、「基本とダイジェストアクセス認証HTTP認証」に記載されています。ユーザエージェントは、それが複数の課題が含まれている可能性がある、または複数のWWW-Authenticateヘッダフィールドが用意されている場合、挑戦自体の内容がカンマ区切りを含めることができるようWWW認証フィールド値を解析するには、特別な注意を払うことをお勧めします認証パラメータのリスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
15 Security Considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
15のセキュリティの考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section is meant to inform application developers, information providers, and users of the security limitations in HTTP/1.1 as described by this document. The discussion does not include definitive solutions to the problems revealed, though it does make some suggestions for reducing security risks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、この文書で説明するように、アプリケーション開発者、情報提供者、およびHTTP / 1.1でのセキュリティ制限をユーザーに知らせるためのものです。それはセキュリティリスクを軽減するためのいくつかの提案を行いんが議論は、明らかに問題の決定的な解決策が含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1 Personal Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1個人情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP clients are often privy to large amounts of personal information (e.g. the user&#39;s name, location, mail address, passwords, encryption keys, etc.), and SHOULD be very careful to prevent unintentional leakage of this information via the HTTP protocol to other sources. We very strongly recommend that a convenient interface be provided for the user to control dissemination of such information, and that designers and implementors be particularly careful in this area. History shows that errors in this area often create serious security and/or privacy problems and generate highly adverse publicity for the implementor&#39;s company.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPクライアントは、多くの場合、個人情報を大量に関与している（例えば、ユーザの名前、場所、メールアドレス、パスワード、暗号化キーなど）、および他のソースへのHTTPプロトコルを介して、この意図しない情報の漏洩を防ぐために非常に注意する必要があります。我々は非常に強く便利なインターフェイスは、このような情報の普及を制御するためにユーザに提供することをお勧めします、そしてデザイナーと実装者は、この分野では特に注意すること。歴史は、この分野でのエラーは、多くの場合、深刻なセキュリティおよび/またはプライバシーの問題を作成し、実装者の会社にとって非常に不利な広報を生成することを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1 Abuse of Server Log Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
サーバーログ情報の乱用15.1.1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server is in the position to save personal data about a user&#39;s requests which might identify their reading patterns or subjects of interest. This information is clearly confidential in nature and its handling can be constrained by law in certain countries. People using the HTTP protocol to provide data are responsible for ensuring that such material is not distributed without the permission of any individuals that are identifiable by the published results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、自分の読書パターンや興味の対象を特定する可能性があるユーザーの要求に関する個人データを保存する立場にあります。この情報は、自然の中で明確に機密であり、その取り扱いが特定の国の法律で制約することができます。データを提供するために、HTTPプロトコルを使っている人は、このような材料が公開された結果によって特定されているすべての人の許可なしに配布されていないことを確実にする責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2 Transfer of Sensitive Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
機密情報の15.1.2転送
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Like any generic data transfer protocol, HTTP cannot regulate the content of the data that is transferred, nor is there any a priori method of determining the sensitivity of any particular piece of information within the context of any given request. Therefore, applications SHOULD supply as much control over this information as possible to the provider of that information. Four header fields are worth special mention in this context: Server, Via, Referer and From.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意の汎用データ転送プロトコルと同様に、HTTPは、転送されるデータの内容を規制することができない、またそこには、任意の所与の要求のコンテキスト内の情報の任意の特定の部分の感度を決定するための任意の先験的な方法です。したがって、アプリケーションは、情報の提供者に可能なこの情報上にできるだけ多くの制御を提供する必要があります。 4つのヘッダーフィールドは、この文脈で特に言及する価値がある：サーバー、経由、リファラーやから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Revealing the specific software version of the server might allow the server machine to become more vulnerable to attacks against software that is known to contain security holes. Implementors SHOULD make the Server header field a configurable option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーの特定のソフトウェアバージョンを明らかにすることは、サーバー・マシンは、セキュリティホールを含むことが知られているソフトウェアに対する攻撃に対してより脆弱になることを許可することがあります。実装者は、Serverヘッダフィールド設定可能なオプションにするべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxies which serve as a portal through a network firewall SHOULD take special precautions regarding the transfer of header information that identifies the hosts behind the firewall. In particular, they SHOULD remove, or replace with sanitized versions, any Via fields generated behind the firewall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークファイアウォールを介してポータルとして機能するプロキシは、ファイアウォールの背後のホストを識別するヘッダ情報の転送に関する特別な予防措置を取るべきです。特に、それらは削除すべきである、または消毒のバージョン、ファイアウォールの背後に生成されたのViaフィールドと交換してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Referer header allows reading patterns to be studied and reverse links drawn. Although it can be very useful, its power can be abused if user details are not separated from the information contained in the Referer. Even when the personal information has been removed, the Referer header might indicate a private document&#39;s URI whose publication would be inappropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Refererヘッダは、読取パターンが研究と描か逆方向リンクすることを可能にします。それは非常に便利ですが、ユーザーの詳細がリファラーに含まれる情報から分離されていない場合は、その力を悪用される可能性が。個人情報が削除された場合でも、Refererヘッダは、その出版不適切であるプライベート文書のURIを示している可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The information sent in the From field might conflict with the user&#39;s privacy interests or their site&#39;s security policy, and hence it SHOULD NOT be transmitted without the user being able to disable, enable, and modify the contents of the field. The user MUST be able to set the contents of this field within a user preference or application defaults configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fromフィールドで送られる情報は、ユーザーのプライバシーの利益や自分のサイトのセキュリティポリシーと競合する可能性があります、したがって、それは、ユーザが、無効化、有効化、およびフィールドの内容を変更できずに送信されるべきではありません。ユーザは、ユーザの嗜好やアプリケーションのデフォルト構成内のこのフィールドの内容を設定できなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We suggest, though do not require, that a convenient toggle interface be provided for the user to enable or disable the sending of From and Referer information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは便利なトグルインターフェースはからの送信とリファラー情報を有効または無効にするユーザーのために提供されることを必要としないものの、示唆しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The User-Agent (section 14.43) or Server (section 14.38) header fields can sometimes be used to determine that a specific client or server have a particular security hole which might be exploited. Unfortunately, this same information is often used for other valuable purposes for which HTTP currently has no better mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザエージェント（セクション14.43）またはサーバ（セクション14.38）ヘッダフィールドは、時々、特定のクライアントまたはサーバが悪用される可能性がある特定のセキュリティホールを有することを決定するために使用することができます。残念ながら、これと同じ情報は、多くの場合、HTTPには現在、より良い仕組みを持っている他の貴重な目的のために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3 Encoding Sensitive Information in URI&#39;s
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3 URIの中に機密情報を符号化します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because the source of a link might be private information or might reveal an otherwise private information source, it is strongly recommended that the user be able to select whether or not the Referer field is sent. For example, a browser client could have a toggle switch for browsing openly/anonymously, which would respectively enable/disable the sending of Referer and From information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リンクのソースは、個人情報であるかもしれない、あるいは民間の情報源を明らかにする可能性があるため、強く、ユーザがリファラーフィールドが送信されたかどうかを選択できるようにすることをお勧めします。たとえば、ブラウザクライアントは、それぞれのRefererを送信し、情報から有効/無効にすることになる、公然/匿名で閲覧するためのトグルスイッチを持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients SHOULD NOT include a Referer header field in a (non-secure) HTTP request if the referring page was transferred with a secure protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照ページがセキュアプロトコルで転送されていた場合、クライアントは、（非セキュア）HTTPリクエストにRefererヘッダフィールドを含むべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors of services which use the HTTP protocol SHOULD NOT use GET based forms for the submission of sensitive data, because this will cause this data to be encoded in the Request-URI. Many existing servers, proxies, and user agents will log the request URI in some place where it might be visible to third parties. Servers can use POST-based form submission instead
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、このデータが要求URIでエンコードされるようになりますので、HTTPプロトコルを使用するサービスの作成者は、機密データの提出をベースGETフォームを使用しないでください。多くの既存のサーバ、プロキシ、ユーザエージェントは、それが第三者に見えるかもしれないいくつかの場所でリクエストURIを記録します。サーバーは、代わりにPOSTベースのフォーム送信を使用することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4 Privacy Issues Connected to Accept Headers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ヘッダを受け入れるに接続15.1.4プライバシー問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accept request-headers can reveal information about the user to all servers which are accessed. The Accept-Language header in particular can reveal information the user would consider to be of a private nature, because the understanding of particular languages is often strongly correlated to the membership of a particular ethnic group. User agents which offer the option to configure the contents of an Accept-Language header to be sent in every request are strongly encouraged to let the configuration process include a message which makes the user aware of the loss of privacy involved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アクセスされたすべてのサーバーにユーザーに関する情報を明らかにすることができリクエストヘッダを受け入れます。具体的には受け入れ言語をヘッダには、ユーザが特定の言語の理解がしばしば強く特定の民族グループのメンバーシップに相関しているので、プライベートな性質のものであると考えるでしょう情報を明らかにすることができます。リクエストごとに送信されるのAccept-Languageヘッダの内容を設定するオプションを提供するユーザエージェントは強く設定プロセスが関与プライバシーの損失を認識して、ユーザを作成、メッセージを含めるようにすることが奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An approach that limits the loss of privacy would be for a user agent to omit the sending of Accept-Language headers by default, and to ask the user whether or not to start sending Accept-Language headers to a server if it detects, by looking for any Vary response-header fields generated by the server, that such sending could improve the quality of service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーエージェントは、デフォルトでは、送信のたAccept-Languageヘッダを省略すると、それが検出された場合見ることで、サーバにたAccept-Languageヘッダの送信を開始するかどうかをユーザーに依頼するため、プライバシーの損失を制限アプローチは次のようになりますいずれかのそのような送信は、サービスの品質を向上させることができることを、サーバによって生成された応答ヘッダフィールドを変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Elaborate user-customized accept header fields sent in every request, in particular if these include quality values, can be used by servers as relatively reliable and long-lived user identifiers. Such user identifiers would allow content providers to do click-trail tracking, and would allow collaborating content providers to match cross-server click-trails or form submissions of individual users. Note that for many users not behind a proxy, the network address of the host running the user agent will also serve as a long-lived user identifier. In environments where proxies are used to enhance privacy, user agents ought to be conservative in offering accept header configuration options to end users. As an extreme privacy measure, proxies could filter the accept headers in relayed requests. General purpose user agents which provide a high degree of header configurability SHOULD warn users about the loss of privacy which can be involved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
精巧なユーザカスタマイズは、これらが品質値を含む場合、比較的信頼性が高く長寿命のユーザ識別子として、サーバで使用することができ、特に、すべての要求で送信されたヘッダフィールドを受け入れます。このようなユーザ識別子は、コンテンツプロバイダーがクリック道の追跡を行うことができるようになる、とクロスサーバクリックトレイルや個々のユーザーのフォームの送信に一致するように、コンテンツプロバイダを共同で可能になります。ないプロキシの背後にある多くのユーザーのために、ユーザエージェントを実行しているホストのネットワークアドレスも長命のユーザ識別子として機能することに注意してください。プロキシがプライバシーを強化するために使用されている環境では、ユーザエージェントは、エンドユーザに、ヘッダの構成オプションを受け入れる提供に保守的であるべきです。極端なプライバシー対策として、プロキシが中継された要求で受け入れるヘッダをフィルタリングすることができます。ヘッダ設定機能の高度を提供汎用ユーザエージェントが関与することができ、プライバシーの喪失についてユーザーに警告すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2 Attacks Based On File and Path Names
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ファイルとパス名に基づいて15.2攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations of HTTP origin servers SHOULD be careful to restrict the documents returned by HTTP requests to be only those that were intended by the server administrators. If an HTTP server translates HTTP URIs directly into file system calls, the server MUST take special care not to serve files that were not intended to be delivered to HTTP clients. For example, UNIX, Microsoft Windows, and other operating systems use &#34;..&#34; as a path component to indicate a directory level above the current one. On such a system, an HTTP server MUST disallow any such construct in the Request-URI if it would otherwise allow access to a resource outside those intended to be accessible via the HTTP server. Similarly, files intended for reference only internally to the server (such as access control files, configuration files, and script code) MUST be protected from inappropriate retrieval, since they might contain sensitive information. Experience has shown that minor bugs in such HTTP server implementations have turned into security risks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPオリジンサーバの実装はサーバー管理者のみが意図したものであることをHTTPリクエストによって返された文書を制限することに注意する必要があります。 HTTPサーバがファイルシステムコールに直接HTTP URIを変換した場合、サーバはHTTPクライアントに配信されることを意図していなかったファイルを提供していない特別な注意を払わなければなりません。たとえば、UNIX、Microsoft Windowsの、および他のオペレーティングシステムは、現在の1以上のディレクトリレベルを示すために「..」パスコンポーネントとして使用します。それはそうでない場合はHTTPサーバを経由してアクセスできるようにすることを意図したもの外のリソースへのアクセスを可能にする場合、このようなシステムでは、HTTPサーバは、Request-URIのいずれかのような構築物を禁止しなければなりません。同様に、ファイルがサーバーにのみ内部参照のために意図さ彼らは機密情報が含まれているかもしれないので（例えば、アクセス制御ファイル、構成ファイル、およびスクリプトコードなど）、不適切な検索から保護されなければなりません。経験は、このようなHTTPサーバ実装におけるマイナーなバグはセキュリティリスクになっていることが示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3 DNS Spoofing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3 DNSスプーフィング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients using HTTP rely heavily on the Domain Name Service, and are thus generally prone to security attacks based on the deliberate mis-association of IP addresses and DNS names. Clients need to be cautious in assuming the continuing validity of an IP number/DNS name association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPを使用しているクライアントは、ドメインネームサービスに大きく依存しているため、IPアドレスとDNS名の故意の誤関連付けに基づいてセキュリティ攻撃に対する一般的傾向があります。クライアントは、IP番号/ DNS名協会の継続的な妥当性を仮定して慎重にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In particular, HTTP clients SHOULD rely on their name resolver for confirmation of an IP number/DNS name association, rather than caching the result of previous host name lookups. Many platforms already can cache host name lookups locally when appropriate, and they SHOULD be configured to do so. It is proper for these lookups to be cached, however, only when the TTL (Time To Live) information reported by the name server makes it likely that the cached information will remain useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
具体的には、HTTPクライアントではなく、以前のホスト名ルックアップの結果をキャッシュするよりも、IP数/ DNS名協会の確認のために自分の名前リゾルバに頼るべきです。適切な場合、多くのプラットフォームでは、すでにローカルホスト名のルックアップをキャッシュすることができ、そして彼らがそうするように設定する必要があります。これらの検索がキャッシュされることはネームサーバによって報告されたTTL（生存時間）の情報が、それはおそらく、キャッシュされた情報が有用残ることになりときにのみ、しかし、適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If HTTP clients cache the results of host name lookups in order to achieve a performance improvement, they MUST observe the TTL information reported by DNS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPクライアントがパフォーマンスの向上を実現するために、ホスト名ルックアップの結果をキャッシュする場合は、DNSによって報告されたTTL情報を守らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If HTTP clients do not observe this rule, they could be spoofed when a previously-accessed server&#39;s IP address changes. As network renumbering is expected to become increasingly common [24], the possibility of this form of attack will grow. Observing this requirement thus reduces this potential security vulnerability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPクライアントがこのルールを守らない場合、彼らは時に以前にアクセスしたサーバのIPアドレスの変更を詐称することができます。ネットワークリナンバリングが[24]、ますます一般的になることが予想されるので、この形式の攻撃の可能性が大きくなります。この要件を観察するため、この潜在的なセキュリティ上の脆弱性を低減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This requirement also improves the load-balancing behavior of clients for replicated servers using the same DNS name and reduces the likelihood of a user&#39;s experiencing failure in accessing sites which use that strategy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この要件は、同じDNS名を使用して複製サーバー用のクライアントのロードバランシングの動作を改善し、その戦略を使用してサイトにアクセスするには、ユーザーの経験故障の可能性を低減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4 Location Headers and Spoofing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4場所ヘッダーおよびなりすまし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a single server supports multiple organizations that do not trust one another, then it MUST check the values of Location and Content-Location headers in responses that are generated under control of said organizations to make sure that they do not attempt to invalidate resources over which they have no authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一のサーバーが相互に信頼していない複数の組織をサポートしている場合、それは、彼らがその上のリソースを無効にしようとしないことを確認すると、組織の制御下で生成された応答における位置の値とContent-場所ヘッダをチェックしなければなりません彼らは何の権限を持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5 Content-Disposition Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5コンテンツの処分問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 1806 [35], from which the often implemented Content-Disposition (see section 19.5.1) header in HTTP is derived, has a number of very serious security considerations. Content-Disposition is not part of the HTTP standard, but since it is widely implemented, we are documenting its use and risks for implementors. See RFC 2183 [49] (which updates RFC 1806) for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPでしばしば実施コンテンツの廃棄（セクション19.5.1を参照）ヘッダが由来するRFC 1806 [35]は、非常に深刻なセキュリティ問題の数を有しています。コンテンツ配置はHTTP標準の一部ではありませんが、それは広く実装されているので、我々は、実装のためのその使用とリスクを文書化しています。詳細については、（RFC 1806に更新）[49] RFC 2183を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6 Authentication Credentials and Idle Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6認証資格とアイドル状態のクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Existing HTTP clients and user agents typically retain authentication information indefinitely. HTTP/1.1. does not provide a method for a server to direct clients to discard these cached credentials. This is a significant defect that requires further extensions to HTTP. Circumstances under which credential caching can interfere with the application&#39;s security model include but are not limited to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
既存のHTTPクライアントとユーザエージェントは、一般的に無期限に認証情報を保持します。 HTTP / 1.1。これらのキャッシュされた資格情報を破棄し、直接クライアントにサーバーのための方法を提供していません。これは、HTTPへのさらなる拡張が必要重要な欠陥です。資格情報のキャッシュは、アプリケーションのセキュリティモデルに干渉する可能性がある状況には、これらに限定されません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Clients which have been idle for an extended period following which the server might wish to cause the client to reprompt the user for credentials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - サーバは、クライアントが資格情報をユーザーに求めるプロンプトは表示させたいかもしれない次の拡張期間アイドル状態になっているクライアント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Applications which include a session termination indication (such as a `logout&#39; or `commit&#39; button on a page) after which the server side of the application `knows&#39; that there is no further reason for the client to retain the credentials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - アプリケーションの `のサーバ側は、クライアントが認証情報を保持するためのさらなる理由がないことを知っているの後に（例えば`ログアウト「や `コミット」のページ上のボタンなど）セッション終了表示を含むアプリケーション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is currently under separate study. There are a number of work-arounds to parts of this problem, and we encourage the use of password protection in screen savers, idle time-outs, and other methods which mitigate the security problems inherent in this problem. In particular, user agents which cache credentials are encouraged to provide a readily accessible mechanism for discarding cached credentials under user control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、別の研究中です。そこ回避策の数は、この問題の部分にあり、我々はスクリーンセーバー、アイドルタイムアウト、およびこの問題に固有のセキュリティ上の問題を軽減する他の方法でパスワード保護を使用することを奨励します。具体的には、資格情報をキャッシュするユーザエージェントは、ユーザの管理下にキャッシュされた資格情報を破棄するために容易にアクセスできる仕組みを提供することが奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7 Proxies and Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7プロキシとキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By their very nature, HTTP proxies are men-in-the-middle, and represent an opportunity for man-in-the-middle attacks. Compromise of the systems on which the proxies run can result in serious security and privacy problems. Proxies have access to security-related information, personal information about individual users and organizations, and proprietary information belonging to users and content providers. A compromised proxy, or a proxy implemented or configured without regard to security and privacy considerations, might be used in the commission of a wide range of potential attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その性質上、HTTPプロキシは、男性・イン・ザ・ミドルであり、man-in-the-middle攻撃の機会を表しています。システムの妥協は、どのプロキシの実行は、深刻なセキュリティとプライバシーの問題をもたらす可能性があります。プロキシは、セキュリティ関連の情報、個々のユーザーや組織、およびユーザーやコンテンツプロバイダに属する専有情報について、個人情報へのアクセス権を持っています。妥協プロキシ、またはセキュリティやプライバシーの配慮に関係なく実装または設定されたプロキシは、潜在的な攻撃の広い範囲の手数料で使用される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxy operators should protect the systems on which proxies run as they would protect any system that contains or transports sensitive information. In particular, log information gathered at proxies often contains highly sensitive personal information, and/or information about organizations. Log information should be carefully guarded, and appropriate guidelines for use developed and followed. (Section 15.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシ事業者は、彼らが含まれている情報や機密情報を輸送する任意のシステムを保護するようプロキシが実行されているシステムを保護する必要があります。具体的には、プロキシで収集した情報は、多くの場合、機密性の高い個人情報が含まれている、および/または組織に関する情報ログ。ログ情報は、慎重に守られるべき、との使用のために適切なガイドラインが開発され、続きます。 （15.1.1項）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Caching proxies provide additional potential vulnerabilities, since the contents of the cache represent an attractive target for malicious exploitation. Because cache contents persist after an HTTP request is complete, an attack on the cache can reveal information long after a user believes that the information has been removed from the network. Therefore, cache contents should be protected as sensitive information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュの内容が悪質な搾取のための魅力的な標的を表すため、キャッシュプロキシは、追加の潜在的な脆弱性を提供します。 HTTPリクエストが完了した後でキャッシュの内容が持続するので、キャッシュへの攻撃は、ユーザーが情報をネットワークから削除されたことを信じてずっと後に情報を明らかにすることができます。そのため、キャッシュの内容は、機密情報として保護しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxy implementors should consider the privacy and security implications of their design and coding decisions, and of the configuration options they provide to proxy operators (especially the default configuration).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシの実装は、その設計やコーディングの意思決定のプライバシーとセキュリティの影響を考慮すべきである、と設定オプションの彼らは、代理事業者（特にデフォルトの設定）に提供しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Users of a proxy need to be aware that they are no trustworthier than the people who run the proxy; HTTP itself cannot solve this problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシのユーザーは、プロキシを実行する人よりもtrustworthierされないことに注意する必要があります。 HTTP自体は、この問題を解決することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The judicious use of cryptography, when appropriate, may suffice to protect against a broad range of security and privacy attacks. Such cryptography is beyond the scope of the HTTP/1.1 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号の賢明な使用は、適切な場合、セキュリティとプライバシー広範囲の攻撃から保護するために十分です。このような暗号は、HTTP / 1.1仕様の範囲を超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.1 Denial of Service Attacks on Proxies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
プロキシ上のサービス攻撃の拒否15.7.1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
They exist. They are hard to defend against. Research continues. Beware.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らは存在します。彼らは身を守るのは難しいです。研究は継続されます。注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
16 Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
16の謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification makes heavy use of the augmented BNF and generic constructs defined by David H. Crocker for RFC 822 [9]. Similarly, it reuses many of the definitions provided by Nathaniel Borenstein and Ned Freed for MIME [7]. We hope that their inclusion in this specification will help reduce past confusion over the relationship between HTTP and Internet mail message formats.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様はRFC 822のためのデビッド・H.クロッカーによって定義され、拡張BNFを多用し、一般的な構造を作る[9]。同様に、MIME [7]のためのナサニエル・ボレンスタインとネッドフリードによって提供される定義の多くを再利用します。私たちは、この仕様での包含はHTTPとインターネットメールメッセージ形式の関係上、過去の混乱を減らすのに役立つことを願っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HTTP protocol has evolved considerably over the years. It has benefited from a large and active developer community--the many people who have participated on the www-talk mailing list--and it is that community which has been most responsible for the success of HTTP and of the World-Wide Web in general. Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc VanHeyningen deserve special recognition for their efforts in defining early aspects of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPプロトコルでは、年間で大幅に進化してきました。 WWWトークメーリングリストに参加した多くの人々 -   - それは、大規模かつ活発な開発者コミュニティの恩恵を受けており、それがでHTTPのワールド・ワイド・ウェブの成功のために最も責任のコミュニティとなっていたということです一般的。マーク・アンドリーセン、ロバート・カイリュー、ダニエル・W・コノリー、ボブ・デニー、ジョン・フランクス、ジャン=フランソワ・Groffの、フィリップM.ハラム - ベイカー、ホーコンW.リー、アリ・ルオトナン、ロブ・マックール、ルー・モントゥリ、デイブ・ラゲット、トニー・サンダース、およびマルク・VanHeyningenは、プロトコルの初期の側面を定義する際に彼らの努力のための特別な認識に値します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document has benefited greatly from the comments of all those participating in the HTTP-WG. In addition to those already mentioned, the following individuals have contributed to this specification:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントでは、HTTP-WGに参加するすべての者のコメントから大きな恩恵を受けています。すでに述べたものに加えて、以下の個人はこの仕様に貢献しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Gary Adams                  Ross Patterson
       Harald Tveit Alvestrand     Albert Lunde
       Keith Ball                  John C. Mallery
       Brian Behlendorf            Jean-Philippe Martin-Flatin
       Paul Burchard               Mitra
       Maurizio Codogno            David Morris
       Mike Cowlishaw              Gavin Nicol
       Roman Czyborra              Bill Perry
       Michael A. Dolan            Jeffrey Perry
       David J. Fiander            Scott Powers
       Alan Freier                 Owen Rees
       Marc Hedlund                Luigi Rizzo
       Greg Herlihy                David Robinson
       Koen Holtman                Marc Salomon
       Alex Hopmann                Rich Salz
       Bob Jernigan                Allan M. Schiffman
       Shel Kaphan                 Jim Seidman
       Rohit Khare                 Chuck Shotton
       John Klensin                Eric W. Sink
       Martijn Koster              Simon E. Spero
       Alexei Kosut                Richard N. Taylor
       David M. Kristol            Robert S. Thau
       Daniel LaLiberte            Bill (BearHeart) Weinman
       Ben Laurie                  Francois Yergeau
       Paul J. Leach               Mary Ellen Zurko
       Daniel DuBois               Josh Cohen
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Much of the content and presentation of the caching design is due to suggestions and comments from individuals including: Shel Kaphan, Paul Leach, Koen Holtman, David Morris, and Larry Masinter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHEL Kaphan、ポールリーチ、公園Holtman、デビッド・モリス、およびラリーMasinter：キャッシュ設計の内容とプレゼンテーションの多くは、以下を含む個人からの提案やコメントによるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Most of the specification of ranges is based on work originally done by Ari Luotonen and John Franks, with additional input from Steve Zilles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
範囲の仕様のほとんどは、もともとスティーブZillesからの追加入力で、アリ・ルオトナンとジョン・フランクスによって行われた作業に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thanks to the &#34;cave men&#34; of Palo Alto. You know who you are.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パロアルトの「洞窟の男性」に感謝します。あなたはあなたが誰であるか知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jim Gettys (the current editor of this document) wishes particularly to thank Roy Fielding, the previous editor of this document, along with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and Larry Masinter for their help. And thanks go particularly to Jeff Mogul and Scott Lawrence for performing the &#34;MUST/MAY/SHOULD&#34; audit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジム・ゲティーズ（このドキュメントの現在のエディタ）は、特にジョン・クレンシン、ジェフムガール人、ポール・リーチ、デイブ・クリストル、公園Holtman、ジョン・フランクス、ジョシュ・コーエン、アレックスHopmannとともに、ロイ・フィールディング、この文書の前の編集者に感謝したいです、彼らの助けのためのスコット・ローレンス、およびラリーMasinter。そして、おかげで「MUST / MAY / SHOULD」監査を行うために、特にジェフムガール人とスコット・ローレンスに行きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik Frystyk implemented RFC 2068 early, and we wish to thank them for the discovery of many of the problems that this document attempts to rectify.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Apacheグループ、アンセルムベアード・スミス、ジグソーパズルの著者、とヘンリクFrystykは早期RFC 2068を実装し、そして私たちは、この文書が是正しようとする問題の多くの発見のためにそれらに感謝したいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
17 References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
17の参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1] Alvestrand, H., &#34;Tags for the Identification of Languages&#34;, RFC 1766, March 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1] Alvestrand、H.、 &#34;言語識別のためのタグ&#34;、RFC 1766、1995年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey, D. and B. Alberti, &#34;The Internet Gopher Protocol (a distributed document search and retrieval protocol)&#34;, RFC 1436, March 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2] Anklesaria、F.、McCahill、M.、リンドナー、P.、ジョンソン、D.、トーリー、D.およびB.アルベルティ、 &#34;インターネットゴーファープロトコル（分散文書検索及び検索プロトコル）&#34;、RFC 1436 、1993年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3] Berners-Lee, T., &#34;Universal Resource Identifiers in WWW&#34;, RFC 1630, June 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3]バーナーズ=リー、T.、 &#34;WWWにおけるユニバーサルリソース識別子&#34;、RFC 1630、1994年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4] Berners-Lee, T., Masinter, L. and M. McCahill, &#34;Uniform Resource Locators (URL)&#34;, RFC 1738, December 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4]バーナーズ=リー、T.、Masinter、LとM. McCahill、 &#34;ユニフォームリソースロケータ（URL）&#34;、RFC 1738、1994年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5] Berners-Lee, T. and D. Connolly, &#34;Hypertext Markup Language - 2.0&#34;, RFC 1866, November 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5]バーナーズ=リー、T.、およびD.コノリー、 &#34;ハイパーテキストマークアップ言語 -  2.0&#34;、RFC 1866、1995年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[6] Berners-Lee, T., Fielding, R. and H. Frystyk, &#34;Hypertext Transfer Protocol -- HTTP/1.0&#34;, RFC 1945, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[6]バーナーズ=リー、T.、フィールディング、R.、およびH. Frystyk、 &#34;ハイパーテキスト転送プロトコル -  HTTP / 1.0&#34;、RFC 1945、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[7] Freed, N. and N. Borenstein, &#34;Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies&#34;, RFC 2045, November 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[7]フリード、N.とN. Borenstein、 &#34;マルチパーパスインターネットメールエクステンション（MIME）第一部：インターネットメッセージ本体のフォーマット&#34;、RFC 2045、1996年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[8] Braden, R., &#34;Requirements for Internet Hosts -- Communication Layers&#34;, STD 3, RFC 1123, October 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[8]ブレーデン、R.、 &#34;インターネットホストのための要件 - 通信層&#34;、STD 3、RFC 1123、1989年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[9] Crocker, D., &#34;Standard for The Format of ARPA Internet Text Messages&#34;, STD 11, RFC 822, August 1982.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[9]クロッカー、D.、 &#34;ARPAインターネットテキストメッセージの形式の規格&#34;、STD 11、RFC 822、1982年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R., Sui, J., and M. Grinbaum, &#34;WAIS Interface Protocol Prototype Functional Specification,&#34; (v1.5), Thinking Machines Corporation, April 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[10]デイビス、F.、カーレ、B.、モリス、H.、セーラム、J.、シェン、T.、王、R.、隋、J.、およびM. Grinbaum、「WAISインタフェースプロトコルプロトタイプ機能仕様、」（V1.5）、Machines社、1990年4月を考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[11] Fielding, R., &#34;Relative Uniform Resource Locators&#34;, RFC 1808, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[11]フィールディング、R.、 &#34;相対的なユニフォームリソースロケータ&#34;、RFC 1808、1995年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[12] Horton, M. and R. Adams, &#34;Standard for Interchange of USENET Messages&#34;, RFC 1036, December 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[12]ホートン、M.およびR.アダムス、 &#34;USENETメッセージの交換のための標準的な&#34;、RFC 1036、1987年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[13] Kantor, B. and P. Lapsley, &#34;Network News Transfer Protocol&#34;, RFC 977, February 1986.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[13]カンター、B.およびP.ラプスリー、 &#34;ネットワークニュース転送プロトコル&#34;、RFC 977、1986年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[14] Moore, K., &#34;MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text&#34;, RFC 2047, November 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[14]ムーア、K.、 &#34;MIME（多目的インターネットメール拡張）パート3：非ASCIIテキストのためのメッセージヘッダの拡張&#34;、RFC 2047、1996年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[15] Nebel, E. and L. Masinter, &#34;Form-based File Upload in HTML&#34;, RFC 1867, November 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[15]ネーベル、E.およびL. Masinter、 &#34;HTMLでフォームベースのファイルアップロード&#34;、RFC 1867、1995年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[16] Postel, J., &#34;Simple Mail Transfer Protocol&#34;, STD 10, RFC 821, August 1982.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[16]ポステル、J.、 &#34;簡易メール転送プロトコル&#34;、STD 10、RFC 821、1982年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[17] Postel, J., &#34;Media Type Registration Procedure&#34;, RFC 1590, November 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[17]ポステル、J.、 &#34;メディアタイプの登録手順&#34;、RFC 1590、1996年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[18] Postel, J. and J. Reynolds, &#34;File Transfer Protocol&#34;, STD 9, RFC 959, October 1985.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[18]ポステル、J.、およびJ.レイノルズ、 &#34;ファイル転送プロトコル&#34;、STD 9、RFC 959、1985年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[19] Reynolds, J. and J. Postel, &#34;Assigned Numbers&#34;, STD 2, RFC 1700, October 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[19]レイノルズ、J.およびJ.ポステル、 &#34;割り当て番号&#34;、STD 2、RFC 1700、1994年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[20] Sollins, K. and L. Masinter, &#34;Functional Requirements for Uniform Resource Names&#34;, RFC 1737, December 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[20] Sollins、K.とL. Masinter、 &#34;統一リソース名のための機能要件&#34;、RFC 1737、1994年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[21] US-ASCII。コード化文字セット - 情報交換のための7ビットの米国標準コード。標準ANSI X3.4-1986、ANSI、1986。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[22] ISO-8859. International Standard -- Information Processing -- 8-bit Single-Byte Coded Graphic Character Sets -- Part 1: Latin alphabet No. 1, ISO-8859-1:1987. Part 2: Latin alphabet No. 2, ISO-8859-2, 1987. Part 3: Latin alphabet No. 3, ISO-8859-3, 1988. Part 4: Latin alphabet No. 4, ISO-8859-4, 1988. Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988. Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987. Part 7: Latin/Greek alphabet, ISO-8859-7, 1987. Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988. Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[22] ISO-8859。国際規格 - 情報処理 -  8ビット・シングルバイト・コード化図形文字セット - パート1：ラテンアルファベット1号、ISO-8859-1：1987。パート2：ラテンアルファベット番号2、ISO-8859-2、1987パート3：ラテンアルファベット3号、ISO-8859-3、1988パート4：ラテンアルファベット番号4、ISO-8859-4、1988その5：ラテン/キリル文字、ISO-8859-5、1988パート6：ラテン/アラビア文字、ISO-8859-6、1987パート7：ラテン/ギリシャ語のアルファベット、ISO-8859-7、1987年パート8：ラテン/ヘブライ語のアルファベット、ISO-8859-8、1988年パート9：ラテンアルファベット5号、ISO-8859-9、1990。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[23] Meyers, J. and M. Rose, &#34;The Content-MD5 Header Field&#34;, RFC 1864, October 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[23]マイヤーズ、J.とM.ローズ、 &#34;コンテンツ-MD5ヘッダーフィールド&#34;、RFC 1864、1995年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[24] Carpenter, B. and Y. Rekhter, &#34;Renumbering Needs Work&#34;, RFC 1900, February 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[24]大工、B.およびY. Rekhter、 &#34;リナンバリングは作業が必要&#34;、RFC 1900、1996年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[25] Deutsch, P., &#34;GZIP file format specification version 4.3&#34;, RFC 1952, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[25]ドイツ、P.、 &#34;GZIPファイル形式の仕様バージョン4.3&#34;、RFC 1952、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[26] Venkata N. Padmanabhan, and Jeffrey C. Mogul. &#34;Improving HTTP Latency&#34;, Computer Networks and ISDN Systems, v. 28, pp. 25-35, Dec. 1995. Slightly revised version of paper in Proc. 2nd International WWW Conference &#39;94: Mosaic and the Web, Oct. 1994, which is available at http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat ency.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[26]ヴェンカタN. Padmanabhan、およびジェフリーC.モーグル。 、コンピュータネットワークとISDNシステム、V。28頁。25-35「HTTPレイテンシの改善」、12月1995年は少しPROCで紙のバージョンを改訂します。第2回国際WWW会議&#39;94：モザイクとhttp://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat ency.htmlで利用できるウェブ、1994年10月、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[27] Joe Touch, John Heidemann, and Katia Obraczka. &#34;Analysis of HTTP Performance&#34;, &lt;URL: http://www.isi.edu/touch/pubs/http-perf96/&gt;, ISI Research Report ISI/RR-98-463, (original report dated Aug. 1996), USC/Information Sciences Institute, August 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[27]ジョー・タッチ、ジョンHeidemann、およびカティアObraczka。 &#34;HTTPパフォーマンスの分析&#34;、&lt;URL：http://www.isi.edu/touch/pubs/http-perf96/&gt;、ISI研究報告ISI / RR-98から463、（1996年8月日付で元のレポート）、 USC /情報科学研究所、1998年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[28] Mills, D., &#34;Network Time Protocol (Version 3) Specification, Implementation and Analysis&#34;, RFC 1305, March 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[28]ミルズ、D.、 &#34;ネットワーク時間プロトコル（バージョン3）仕様、実装と分析&#34;、RFC 1305、1992年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[29] Deutsch, P., &#34;DEFLATE Compressed Data Format Specification version 1.3&#34;, RFC 1951, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[29]ドイツ、P.、 &#34;DEFLATE圧縮データフォーマット仕様バージョン1.3&#34;、RFC 1951、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[30] S. Spero, &#34;Analysis of HTTP Performance Problems,&#34; http://sunsite.unc.edu/mdma-release/http-prob.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[30] S.スペロ、 &#34;HTTPパフォーマンスの問題の分析、&#34; http://sunsite.unc.edu/mdma-release/http-prob.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[31] Deutsch, P. and J. Gailly, &#34;ZLIB Compressed Data Format Specification version 3.3&#34;, RFC 1950, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[31]ドイツ、P。及びJ. Gailly氏、 &#34;ZLIB圧縮データフォーマット仕様バージョン3.3&#34;、RFC 1950、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[32] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P., Luotonen, A., Sink, E. and L. Stewart, &#34;An Extension to HTTP: Digest Access Authentication&#34;, RFC 2069, January 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[32]フランクス、J.、ハラム・ベイカー、P.、Hostetler、J.、リーチ、P.、Luotonen、A.、シンク、E.およびL.スチュワート、 &#34;HTTPへの拡張：ダイジェストアクセス認証&#34;、 RFC 2069、1997年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[33] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T. Berners-Lee, &#34;Hypertext Transfer Protocol -- HTTP/1.1&#34;, RFC 2068, January 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[33]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、およびT.バーナーズ - リー、 &#34;ハイパーテキスト転送プロトコル -  HTTP / 1.1&#34;、RFC 2068、1997年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[34] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[34]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[35] Troost, R. and Dorner, S., &#34;Communicating Presentation Information in Internet Messages: The Content-Disposition Header&#34;, RFC 1806, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[35] Troost、R.とドルナー、S.、 &#34;インターネット・メッセージでプレゼンテーション情報を伝える：のContent-Dispositionヘッダー&#34;、RFC 1806、1995年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[36] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, &#34;Use and Interpretation of HTTP Version Numbers&#34;, RFC 2145, May 1997. [jg639]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[36]モーグル、J.、フィールディング、R.、ゲティス、J.及びH. Frystyk、 &#34;使用とHTTPバージョン番号の解釈&#34;、RFC 2145、1997年5月[jg639]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[37] Palme, J., &#34;Common Internet Message Headers&#34;, RFC 2076, February 1997. [jg640]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[37]パルメ、J.、 &#34;一般的なインターネットメッセージヘッダ&#34;、RFC 2076、1997年2月[jg640]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[38] Yergeau, F., &#34;UTF-8, a transformation format of Unicode and ISO-10646&#34;, RFC 2279, January 1998. [jg641]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[38] Yergeau、F.、 &#34;UTF-8、UnicodeとISO-10646の変換フォーマット&#34;、RFC 2279、1998年1月[jg641]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[39] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud&#39;hommeaux, E., Lie, H., and C. Lilley. &#34;Network Performance Effects of HTTP/1.1, CSS1, and PNG,&#34; Proceedings of ACM SIGCOMM &#39;97, Cannes France, September 1997.[jg642]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[39]ニールセン、H。F.、ゲティス、J.、ベアード - スミス、A.、Prud&#39;hommeaux、E.、リー、H.、およびC.リリー。 &#34;HTTP / 1.1、CSS1、およびPNGのネットワークパフォーマンスの影響、&#34; ACMのSIGCOMM &#39;97の議事録、カンヌ、フランス、1997年9月[jg642]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[40] Freed, N. and N. Borenstein, &#34;Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types&#34;, RFC 2046, November 1996. [jg643]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[40]解放され、N.とN. Borenstein、 &#34;マルチパーパスインターネットメールエクステンション（MIME）パート2：メディアタイプ&#34;、RFC 2046、1996年11月[jg643]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[41] Alvestrand, H., &#34;IETF Policy on Character Sets and Languages&#34;, BCP 18, RFC 2277, January 1998. [jg644]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[41] Alvestrand、H.、 &#34;文字セットと言語のIETF方針&#34;、BCP 18、RFC 2277、1998年1月[jg644]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[42] Berners-Lee, T., Fielding, R. and L. Masinter, &#34;Uniform Resource Identifiers (URI): Generic Syntax and Semantics&#34;, RFC 2396, August 1998. [jg645]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[42]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 &#34;ユニフォームリソース識別子（URI）：一般的な構文及びセマンティクス&#34;、RFC 2396、1998年8月[jg645]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[43] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., Sink, E. and L. Stewart, &#34;HTTP Authentication: Basic and Digest Access Authentication&#34;, RFC 2617, June 1999. [jg646]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[43]フランクス、J.、ハラム・ベイカー、P.、Hostetler、J.、ローレンス、S.、リーチ、P.、Luotonen、A.、シンク、E.およびL.スチュワート、「HTTP認証：基本とダイジェストアクセス認証」、RFC 2617、1999年6月[jg646]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[44] Luotonen, A., &#34;Tunneling TCP based protocols through Web proxy servers,&#34; Work in Progress. [jg647]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
進行中[44] Luotonen、A.、 &#34;Webプロキシサーバー経由でトンネリングTCPベースのプロトコル、&#34; ワーク。 [jg647]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[45] Palme, J. and A. Hopmann, &#34;MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)&#34;, RFC 2110, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[45]パルメ、J.及びA. Hopmann、RFC 2110、1997年3月 &#34;は、HTML（MHTML）として集約文書のMIME電子メールカプセル化&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[46] Bradner, S., &#34;The Internet Standards Process -- Revision 3&#34;, BCP 9, RFC 2026, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[46]ブラドナーの、S.、 &#34;インターネット標準化プロセス - リビジョン3&#34;、BCP 9、RFC 2026、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[47] Masinter, L., &#34;Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)&#34;, RFC 2324, 1 April 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[47] Masinter、L.、 &#34;ハイパーテキストコーヒーポット制御プロトコル（HTCPCP / 1.0）&#34;、RFC 2324、1998年4月1日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[48] Freed, N. and N. Borenstein, &#34;Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples&#34;, RFC 2049, November 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[48]フリード、N.とN. Borenstein、 &#34;マルチパーパスインターネットメールエクステンション（MIME）パート5：適合基準と例&#34;、RFC 2049、1996年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[49] Troost, R., Dorner, S. and K. Moore, &#34;Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field&#34;, RFC 2183, August 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[49] Troost、R.、ドルナー、S.とK.ムーア、 &#34;インターネット・メッセージでプレゼンテーション情報を伝える：コンテンツ-Dispositionヘッダーフィールド&#34;、RFC 2183、1997年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
18 Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
18本の著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Roy T. Fielding Information and Computer Science University of California, Irvine Irvine, CA 92697-3425, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロイT.フィールディング情報とカリフォルニアのコンピュータサイエンス大学、アーヴァイン、CA 92697-3425、USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fax: +1 (949) 824-1715 EMail: fielding@ics.uci.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファックス：+1（949）824-1715 Eメール：fielding@ics.uci.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
James Gettys World Wide Web Consortium MIT Laboratory for Computer Science 545 Technology Square Cambridge, MA 02139, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンピュータサイエンス545技術正方形のケンブリッジ、MA 02139、USAジェームスゲティスワールド・ワイド・ウェブ・コンソーシアムMIT研究所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fax: +1 (617) 258 8682 EMail: jg@w3.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファックス：+1（617）258 8682 Eメール：jg@w3.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jeffrey C. Mogul Western Research Laboratory Compaq Computer Corporation 250 University Avenue Palo Alto, California, 94305, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジェフリーC.モーグル西研究所コンパックコンピュータ株式会社250大学アベニューパロアルト、カリフォルニア、94305、USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: mogul@wrl.dec.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：mogul@wrl.dec.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Henrik Frystyk Nielsen World Wide Web Consortium MIT Laboratory for Computer Science 545 Technology Square Cambridge, MA 02139, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヘンリック・フリスティック・ニールセンのWorld Wide Web ConsortiumのMITコンピュータサイエンス研究所545テクノロジー・スクエアケンブリッジ、MA 02139、USAについて
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fax: +1 (617) 258 8682 EMail: frystyk@w3.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファックス：+1（617）258 8682 Eメール：frystyk@w3.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Larry Masinter Xerox Corporation 3333 Coyote Hill Road Palo Alto, CA 94034, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ラリーMasinterゼロックス・コーポレーション3333コヨーテヒルロードパロアルト、CA 94034、USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: masinter@parc.xerox.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：masinter@parc.xerox.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Paul J. Leach Microsoft Corporation 1 Microsoft Way Redmond, WA 98052, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポール・J.リーチマイクロソフト社1マイクロソフト道レドモンド、WA 98052、USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: paulle@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：paulle@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tim Berners-Lee Director, World Wide Web Consortium MIT Laboratory for Computer Science 545 Technology Square Cambridge, MA 02139, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ティム・バーナーズ=リー・ディレクター、コンピュータサイエンス545技術正方形のケンブリッジ、MA 02139、USAのためのWorld Wide Web ConsortiumのMIT研究所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fax: +1 (617) 258 8682 EMail: timbl@w3.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファックス：+1（617）258 8682 Eメール：timbl@w3.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
19 Appendices
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
19本の付録
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1 Internet Media Type message/http and application/http
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1インターネットメディアタイプのメッセージ/ httpおよびアプリケーション/ HTTP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to defining the HTTP/1.1 protocol, this document serves as the specification for the Internet media type &#34;message/http&#34; and &#34;application/http&#34;. The message/http type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all &#34;message&#34; types regarding line length and encodings. The application/http type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed). The following is to be registered with IANA [17].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1プロトコルを定義することに加えて、この文書は、インターネットメディアタイプ「メッセージ/ HTTP」および「アプリケーション/ HTTP」の仕様として機能します。メッセージ/ HTTPタイプは、それが行の長さ及び符号化に関するすべての「メッセージ」タイプのMIMEの制限に従うことを条件とする、単一のHTTP要求または応答メッセージを囲むために使用することができます。アプリケーション/ HTTPタイプは、1つ以上のHTTP要求または応答メッセージのパイプラインを囲むために使用することができる（混合しません）。以下は、IANA [17]に登録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Media Type name:         message
       Media subtype name:      http
       Required parameters:     none
       Optional parameters:     version, msgtype
        version: The HTTP-Version number of the enclosed message
                 (e.g., &#34;1.1&#34;). If not present, the version can be
                 determined from the first line of the body.
        msgtype: The message type -- &#34;request&#34; or &#34;response&#34;. If not
                 present, the type can be determined from the first
                 line of the body.
       Encoding considerations: only &#34;7bit&#34;, &#34;8bit&#34;, or &#34;binary&#34; are
                                permitted
       Security considerations: none
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Media Type name: application Media subtype name: http Required parameters: none Optional parameters: version, msgtype version: The HTTP-Version number of the enclosed messages (e.g., &#34;1.1&#34;). If not present, the version can be determined from the first line of the body. msgtype: The message type -- &#34;request&#34; or &#34;response&#34;. If not present, the type can be determined from the first line of the body. Encoding considerations: HTTP messages enclosed by this type are in &#34;binary&#34; format; use of an appropriate Content-Transfer-Encoding is required when transmitted via E-mail. Security considerations: none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メディアタイプ名：アプリケーションメディアサブタイプ名：HTTP必須パラメータ：なしオプションのパラメータ：バージョン、MSGTYPEバージョン：同封のメッセージのHTTP-バージョン番号（例えば、「1.1」）。存在しない場合、バージョンは、本体の最初の行から決定することができます。 MSGTYPE：メッセージタイプ - 「要求」または「応答」。存在しない場合は、タイプは、本体の最初の行から決定することができます。エンコードの考慮事項：このタイプで囲まれたHTTPメッセージは、「バイナリ」形式になっています。 Eメールを介して送信時に適切なコンテンツ転送エンコードの使用が必要とされます。セキュリティの考慮事項：なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2 Internet Media Type multipart/byteranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2インターネットメディアタイプマルチパート/ byteranges
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an HTTP 206 (Partial Content) response message includes the content of multiple ranges (a response to a request for multiple non-overlapping ranges), these are transmitted as a multipart message-body. The media type for this purpose is called &#34;multipart/byteranges&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP 206（部分コンテンツ）応答メッセージが複数の範囲（複数の非重複範囲要求に対する応答）の内容を含む場合、これらはマルチパートメッセージボディとして送信されます。この目的のためにメディアタイプは「マルチパート/ byteranges」と呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The multipart/byteranges media type includes two or more parts, each with its own Content-Type and Content-Range fields. The required boundary parameter specifies the boundary string used to separate each body-part.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチパートは/メディアタイプは、独自のContent-TypeとContent-レンジフィールドを持つ2つ以上の部品、それぞれが含まれてbyteranges。必要な境界パラメータは、各身体部分を分離するために使用された境界文字列を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Media Type name:         multipart
       Media subtype name:      byteranges
       Required parameters:     boundary
       Optional parameters:     none
       Encoding considerations: only &#34;7bit&#34;, &#34;8bit&#34;, or &#34;binary&#34; are
                                permitted
       Security considerations: none
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 206 Partial Content Date: Wed, 15 Nov 1995 06:25:24 GMT Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1 206部分コンテンツ日：水曜日、1995年11月15日午前6時25分24秒GMTのLast-Modified：水曜日、1995年11月15日午前4時58分08秒GMTのコンテンツタイプ：マルチパート/ byteranges。境界= THIS_STRING_SEPARATES
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
--THIS_STRING_SEPARATES Content-type: application/pdf Content-range: bytes 500-999/8000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション/ PDFコンテンツ-範囲：500-999 / 8000バイトのContent-typeが--THIS_STRING_SEPARATES
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...the first range... --THIS_STRING_SEPARATES Content-type: application/pdf Content-range: bytes 7000-7999/8000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション/ PDFコンテンツ-範囲：...最初の範囲...には、Content-typeを--THIS_STRING_SEPARATESバイト7000から7999/8000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...the second range --THIS_STRING_SEPARATES--
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
... 2番目の範囲--THIS_STRING_SEPARATES--
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Notes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ノート：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) Additional CRLFs may precede the first boundary string in the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）追加のCRLFは、エンティティの最初の境界文字列の前にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) Although RFC 2046 [40] permits the boundary string to be quoted, some existing implementations handle a quoted boundary string incorrectly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）RFC 2046 [40]は、境界文字列は引用することを可能にするが、いくつかの既存の実装が誤って引用された境界文字列を扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) A number of browsers and servers were coded to an early draft of the byteranges specification to use a media type of multipart/x-byteranges, which is almost, but not quite compatible with the version documented in HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3）ブラウザおよびサーバの数はほぼであるマルチパート/ X-byterangesのメディアタイプを使用するbyteranges仕様の初期ドラフトに符号化されたが、HTTP / 1.1で文書バージョンと非常に互換性がなかったです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.3 Tolerant Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.3トレラントアプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although this document specifies the requirements for the generation of HTTP/1.1 messages, not all applications will be correct in their implementation. We therefore recommend that operational applications be tolerant of deviations whenever those deviations can be interpreted unambiguously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書はHTTP / 1.1メッセージの生成のための要求事項を規定していますが、必ずしもすべてのアプリケーションがその実施に正しくなります。そこで我々は、これらのずれが明確に解釈することができますいつでも業務アプリケーションは、偏差の許容性にすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients SHOULD be tolerant in parsing the Status-Line and servers tolerant when parsing the Request-Line. In particular, they SHOULD accept any amount of SP or HT characters between fields, even though only a single SP is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがリクエストラインの解析時にステータスラインとサーバ寛容を解析するには寛容であるべきです。特に、それらはただ一つのSPが必要とされていても、フィールド間のSPやHTの文字の任意の量を受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The line terminator for message-header fields is the sequence CRLF. However, we recommend that applications, when parsing such headers, recognize a single LF as a line terminator and ignore the leading CR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージヘッダフィールドのラインターミネータは、配列CRLFです。しかし、我々はそのようなヘッダを解析するとき、アプリケーションが、行終端として単一のLFを認識し、主要なCRを無視することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The character set of an entity-body SHOULD be labeled as the lowest common denominator of the character codes used within that body, with the exception that not labeling the entity is preferred over labeling the entity with the labels US-ASCII or ISO-8859-1. See section 3.7.1 and 3.4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンティティボディの文字セットは、エンティティを標識しませラベルUS-ASCIIまたはISO-8859-1でエンティティを標識するよりも好ましいことを除いて、その体内で使用される文字コードの最小公分母としてラベル付けされるべき1。セクション3.7.1と3.4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Additional rules for requirements on parsing and encoding of dates and other potential problems with date encodings include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
日付と日付のエンコーディングを持つ他の潜在的な問題の解析とエンコーディングに関する要件のための追加ルールは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- HTTP/1.1 clients and caches SHOULD assume that an RFC-850 date which appears to be more than 50 years in the future is in fact in the past (this helps solve the &#34;year 2000&#34; problem).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTP / 1.1クライアントとキャッシュは将来的には50年以上であるように思われるRFC-850日付が（これは「2000年」の問題を解決するのに役立ちます）過去の事実であることを前提とすべきです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- An HTTP/1.1 implementation MAY internally represent a parsed Expires date as earlier than the proper value, but MUST NOT internally represent a parsed Expires date as later than the proper value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTP / 1.1の実装は、内部的に解析されたが適正値よりも早いと日付を有効期限が、内部的に解析されたが、後に適切な値よりも日付を期限切れに表現してはならない表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- All expiration-related calculations MUST be done in GMT. The local time zone MUST NOT influence the calculation or comparison of an age or expiration time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - すべての有効期限に関連する計算は、GMTで行わなければなりません。ローカルタイムゾーンは、年齢や有効期限の計算や比較に影響を及ぼしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If an HTTP header incorrectly carries a date value with a time zone other than GMT, it MUST be converted into GMT using the most conservative possible conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTPヘッダが誤ってGMT以外の時間帯と日付の値を搬送する場合、それは最も保守的な可能変換を使用してGMTに変換されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4 Differences Between HTTP Entities and Entities
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
HTTPエンティティとエンティティ間の19.4違い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 uses many of the constructs defined for Internet Mail (RFC 822 [9]) and the Multipurpose Internet Mail Extensions (MIME [7]) to allow entities to be transmitted in an open variety of representations and with extensible mechanisms. However, RFC 2045 discusses mail, and HTTP has a few features that are different from those described in RFC 2045. These differences were carefully chosen to optimize performance over binary connections, to allow greater freedom in the use of new media types, to make date comparisons easier, and to acknowledge the practice of some early HTTP servers and clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は、インターネットメール用に定義された構築物の多くを使用する（RFC 822 [9]）および多目的インターネットメール拡張（MIME [7]）エンティティが表現のオープン多様でかつ拡張可能なメカニズムを用いて送信されることを可能にします。ただし、RFC 2045には、メールを論じ、およびHTTPは、これらの違いは慎重に日付を作るために、新しいメディアタイプを使用することでより大きな自由を可能にするために、バイナリ接続でのパフォーマンスを最適化するために選択されたRFC 2045に記載されたものと異なっているいくつかの機能を持っています比較が簡単に、そしていくつかの初期のHTTPサーバおよびクライアントの練習を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix describes specific areas where HTTP differs from RFC 2045. Proxies and gateways to strict MIME environments SHOULD be aware of these differences and provide the appropriate conversions where necessary. Proxies and gateways from MIME environments to HTTP also need to be aware of the differences because some conversions might be required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録では、HTTPは、厳密なMIME環境へのRFC 2045プロキシやゲートウェイとは異なり、特定の領域は、これらの違いを認識し、必要に応じ適切な変換を提供すべきで記述する。 MIME環境からHTTPへのプロキシやゲートウェイはまた、いくつかの変換が必要になる場合がありますので、違いを認識する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.1 MIME-Version
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.1 MIME-バージョン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY include a single MIME-Version general-header field to indicate what version of the MIME protocol was used to construct the message. Use of the MIME-Version header field indicates that the message is in full compliance with the MIME protocol (as defined in RFC 2045[7]). Proxies/gateways are responsible for ensuring full compliance (where possible) when exporting HTTP messages to strict MIME environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPは、MIME準拠のプロトコルではありません。しかしながら、HTTP / 1.1のメッセージは、メッセージを構成するために使用されたMIMEプロトコルのバージョンを示すために、単一のMIME-版一般的なヘッダフィールドを含んでいてもよいです。 MIMEバージョンのヘッダフィールドの使用は、（RFC 2045で定義されている[7]）メッセージは、MIMEプロトコルに完全に準拠していることを示しています。プロキシ/ゲートウェイは、厳密なMIME環境へのHTTPメッセージをエクスポートするときに（可能な場合）の完全遵守を確保する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MIME-Version = &#34;MIME-Version&#34; &#34;:&#34; 1*DIGIT &#34;.&#34; 1*DIGIT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MIME-バージョン= &#34;MIME-バージョン&#34; &#34;：&#34; 1 * DIGIT &#34;&#34;。 1 * DIGIT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MIME version &#34;1.0&#34; is the default for use in HTTP/1.1. However, HTTP/1.1 message parsing and semantics are defined by this document and not the MIME specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MIMEバージョン「1.0」HTTP / 1.1で使用するためのデフォルトです。しかし、HTTP / 1.1メッセージの解析と意味については、このドキュメントではなくMIME仕様で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.2 Conversion to Canonical Form
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Canonicalはフォームへの変換19.4.2
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 2045 [7] requires that an Internet mail entity be converted to canonical form prior to being transferred, as described in section 4 of RFC 2049 [48]. Section 3.7.1 of this document describes the forms allowed for subtypes of the &#34;text&#34; media type when transmitted over HTTP. RFC 2046 requires that content with a type of &#34;text&#34; represent line breaks as CRLF and forbids the use of CR or LF outside of line break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a line break within text content when a message is transmitted over HTTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 2045 [7] RFC 2049 [48]のセクション4で説明したように、インターネット・メール・エンティティは、前に転送されることに標準形に変換することを必要とします。このドキュメントのセクション3.7.1には、HTTPを介して送信時に「テキスト」メディアタイプのサブタイプのために許可されている形式について説明します。 RFC 2046には、「テキスト」の種類と内容はCRLFとしてラインブレイクを表すことが必要と改行シーケンスの外でCRまたはLFの使用を禁止します。 HTTPは、メッセージがHTTPを介して送信されるとき、テキストコンテンツ内の改行を示すためにCRLF、むき出しのCR、およびむき出しのLFを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where it is possible, a proxy or gateway from HTTP to a strict MIME environment SHOULD translate all line breaks within the text media types described in section 3.7.1 of this document to the RFC 2049 canonical form of CRLF. Note, however, that this might be complicated by the presence of a Content-Encoding and by the fact that HTTP allows the use of some character sets which do not use octets 13 and 10 to represent CR and LF, as is the case for some multi-byte character sets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが可能な場合、HTTPから厳密なMIME環境へのプロキシやゲートウェイは、CRLFのRFC 2049標準的な形式に、この文書のセクション3.7.1に記述されたテキストメディアタイプ内のすべての改行を変換すべきです。これはコンテンツのエンコードの存在によっておよびHTTPは、いくつかの場合のように、CRとLFを表現するためにオクテット13と10を使用していないいくつかの文字セットを使用することができますという事実によって複雑になるかもしれないこと、しかし、注意してくださいマルチバイト文字セット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementors should note that conversion will break any cryptographic checksums applied to the original content unless the original content is already in canonical form. Therefore, the canonical form is recommended for any content that uses such checksums in HTTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装者は、元のコンテンツが正規の形式で既にある場合を除き、変換は、オリジナルのコンテンツに適用されるすべての暗号チェックサムを破るだろうことに注意してください。したがって、正規の形式はHTTPで、このようなチェックサムを使用するすべてのコンテンツに対して推奨されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.3 Conversion of Date Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
日付の書式の変換19.4.3
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 uses a restricted set of date formats (section 3.3.1) to simplify the process of date comparison. Proxies and gateways from other protocols SHOULD ensure that any Date header field present in a message conforms to one of the HTTP/1.1 formats and rewrite the date if necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は日付比較の処理を簡単にするために、日付形式（セクション3.3.1）の制限されたセットを使用します。他のプロトコルからのプロキシ及びゲートウェイは、メッセージ中に存在する任意の日付ヘッダフィールドは、HTTP / 1.1のいずれかの形式に準拠していることを確認し、必要に応じて日付を書き換えるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.4 Introduction of Content-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
コンテンツエンコーディングの19.4.4はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 2045 does not include any concept equivalent to HTTP/1.1&#39;s Content-Encoding header field. Since this acts as a modifier on the media type, proxies and gateways from HTTP to MIME-compliant protocols MUST either change the value of the Content-Type header field or decode the entity-body before forwarding the message. (Some experimental applications of Content-Type for Internet mail have used a media-type parameter of &#34;;conversions=&lt;content-coding&gt;&#34; to perform a function equivalent to Content-Encoding. However, this parameter is not part of RFC 2045.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 2045は、HTTP / 1.1のContent-Encodingヘッダフィールドに任意の概念相当が含まれていません。これは、メディアタイプの修飾として作用するため、HTTPからMIME準拠のプロトコルにプロキシ及びゲートウェイは、Content-Typeヘッダフィールドの値を変更したり、メッセージを転送する前に、エンティティボディをデコードする必要があります。インターネットメール用のContent-Typeの（いくつかの実験的なアプリケーションは、のメディアタイプパラメータを使用している「;変換は= &lt;コンテンツコーディング&gt;」コンテンツ・エンコードと同等の機能を実行するためにしかし、このパラメータはRFC 2045の一部ではありません。 ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.5 No Content-Transfer-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.5ノーコンテンツ転送エンコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC 2045. Proxies and gateways from MIME-compliant protocols to HTTP MUST remove any non-identity CTE (&#34;quoted-printable&#34; or &#34;base64&#34;) encoding prior to delivering the response message to an HTTP client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前提供にエンコードする（「quoted-printable形式」または「BASE64」）以外のアイデンティティCTEを削除する必要がありますHTTPは、HTTPにRFCのコンテンツ転送エンコード（CTE）フィールド2045プロキシとMIME準拠のプロトコルからのゲートウェイを使用していませんHTTPクライアントへの応答メッセージ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where &#34;safe transport&#34; is defined by the limitations of the protocol being used. Such a proxy or gateway SHOULD label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPからMIME準拠のプロトコルにプロキシ及びゲートウェイは、メッセージが「安全輸送」が使用されているプロトコルの制限によって定義されるプロトコルの安全な輸送のための正しいフォーマット及び符号化であることを保証する責任があります。そうすることは先のプロトコル上で、安全な輸送の可能性を向上させる場合には、このようなプロキシやゲートウェイは、適切なコンテンツ転送エンコードを使用してデータにラベルを付けるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.6 Introduction of Transfer-Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
転送エンコードの19.4.6はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 introduces the Transfer-Encoding header field (section 14.41). Proxies/gateways MUST remove any transfer-coding prior to forwarding a message via a MIME-compliant protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は、転送エンコードヘッダーフィールド（セクション14.41）を導入します。プロキシ/ゲートウェイは、任意の転送コーディング前MIME準拠のプロトコルを介してメッセージを転送するのを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A process for decoding the &#34;chunked&#34; transfer-coding (section 3.6) can be represented in pseudo-code as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
：転送符号化（セクション3.6）のように疑似コードで表すことができる「チャンク」をデコードするためのプロセス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       length := 0
       read chunk-size, chunk-extension (if any) and CRLF
       while (chunk-size &gt; 0) {
          read chunk-data and CRLF
          append chunk-data to entity-body
          length := length + chunk-size
          read chunk-size and CRLF
       }
       read entity-header
       while (entity-header not empty) {
          append entity-header to existing header fields
          read entity-header
       }
       Content-Length := length
       Remove &#34;chunked&#34; from Transfer-Encoding
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.7 MHTML and Line Length Limitations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4.7 MHTMLとライン長さの制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP implementations which share code with MHTML [45] implementations need to be aware of MIME line length limitations. Since HTTP does not have this limitation, HTTP does not fold long lines. MHTML messages being transported by HTTP follow all conventions of MHTML, including line length limitations and folding, canonicalization, etc., since HTTP transports all message-bodies as payload (see section 3.7.2) and does not interpret the content or any MIME header lines that might be contained therein.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MHTMLでコードを共有するHTTP実装は、[45]の実装は、MIME行の長さの制限に注意する必要があります。 HTTPは、この制限はありませんので、HTTPは長い行を折り畳まれていません。 HTTPは、ペイロードとして、すべてのメッセージ・ボディを搬送するためMHTMLメッセージは、HTTPによって搬送され、等線路長の制限と折り、正規化を含む、MHTMLのすべての規則に従う（セクション3.7.2参照）、コンテンツまたは任意のMIMEヘッダを解釈することはありませんそこに含まれている可能性のあるライン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.5 Additional Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.5その他の機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 1945 and RFC 2068 document protocol elements used by some existing HTTP implementations, but not consistently and correctly across most HTTP/1.1 applications. Implementors are advised to be aware of these features, but cannot rely upon their presence in, or interoperability with, other HTTP/1.1 applications. Some of these describe proposed experimental features, and some describe features that experimental deployment found lacking that are now addressed in the base HTTP/1.1 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 1945およびいくつかの既存のHTTP実装で使用されるRFC 2068文書プロトコル要素ではなく、一貫して正しくほとんどのHTTP / 1.1のアプリケーション間。実装者は、これらの機能を意識することをお勧めしますが、その中に存在する、または他のHTTP / 1.1アプリケーションとの相互運用性に頼ることはできません。これらのいくつかは、提案された実験的な機能について説明し、いくつかの実験的な展開は、今ベースHTTP / 1.1の仕様で対処される欠けた機能について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A number of other headers, such as Content-Disposition and Title, from SMTP and MIME are also often implemented (see RFC 2076 [37]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SMTPとMIMEからそのようなコンテンツの廃棄やタイトルなどの他のヘッダの数は、しばしば（RFC 2076 [37]参照）が実装されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.5.1 Content-Disposition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.5.1コンテンツ処分
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Content-Disposition response-header field has been proposed as a means for the origin server to suggest a default filename if the user requests that the content is saved to a file. This usage is derived from the definition of Content-Disposition in RFC 1806 [35].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツディスポジションレスポンスヘッダフィールドは、ユーザがコンテンツをファイルに保存されていることを要求した場合、デフォルトのファイル名を示唆するためにオリジンサーバのための手段として提案されています。この用法は、RFC 1806 [35]にコンテンツの廃棄の定義から導出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        content-disposition = &#34;Content-Disposition&#34; &#34;:&#34;
                              disposition-type *( &#34;;&#34; disposition-parm )
        disposition-type = &#34;attachment&#34; | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = &#34;filename&#34; &#34;=&#34; quoted-string
        disp-extension-token = token
        disp-extension-parm = token &#34;=&#34; ( token | quoted-string )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Disposition: attachment; filename=&#34;fname.ext&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツディスポジション：添付ファイル;ファイル名= &#34;fname.ext&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The receiving user agent SHOULD NOT respect any directory path information present in the filename-parm parameter, which is the only parameter believed to apply to HTTP implementations at this time. The filename SHOULD be treated as a terminal component only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信ユーザエージェントは、この時点でHTTPの実装に適用すると考えられる唯一のパラメータであるファイル名PARMパラメーター、中に存在する任意のディレクトリのパス情報を尊重すべきではありません。ファイル名は、末端構成要素として扱われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If this header is used in a response with the application/octet-stream content-type, the implied suggestion is that the user agent should not display the response, but directly enter a `save response as...&#39; dialog.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このヘッダは、アプリケーション/オクテットストリームコンテンツタイプと応答で使用されている場合、暗黙の提案は、ユーザエージェントが応答を表示するが、直接 `として応答を保存...」ダイアログに入るべきではないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See section 15.5 for Content-Disposition security issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツディスポジションのセキュリティ問題のためのセクション15.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.6 Compatibility with Previous Versions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
以前のバージョンとの互換性19.6
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is beyond the scope of a protocol specification to mandate compliance with previous versions. HTTP/1.1 was deliberately designed, however, to make supporting previous versions easy. It is worth noting that, at the time of composing this specification (1996), we would expect commercial HTTP/1.1 servers to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、以前のバージョンの遵守を強制するために、プロトコル仕様の範囲を超えています。 HTTP / 1.1が故意に設計された、しかし、簡単に以前のバージョンをサポートするようにします。なお、本明細書（1996）を構成する時に、私たちは、商業HTTP / 1.1サーバへの期待、ということは注目に値します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- recognize the format of the Request-Line for HTTP/0.9, 1.0, and 1.1 requests;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTP / 0.9、1.0の要求ラインのフォーマットを認識し、そして1.1リクエスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- understand any valid request in the format of HTTP/0.9, 1.0, or 1.1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTP / 0.9、1.0、または1.1の形式であらゆる有効な要求を理解します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- respond appropriately with a message in the same major version used by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - クライアントによって使用されるのと同じメジャーバージョンでのメッセージで適切に対応。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
And we would expect HTTP/1.1 clients to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そして、我々は、HTTP / 1.1クライアントへの期待します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- recognize the format of the Status-Line for HTTP/1.0 and 1.1 responses;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTP / 1.0と1.1レスポンスのステータスラインのフォーマットを認識し、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- understand any valid response in the format of HTTP/0.9, 1.0, or 1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTP / 0.9、1.0、または1.1の形式で任意の有効な応答を理解しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For most implementations of HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response. Some implementations implement the Keep-Alive version of persistent connections described in section 19.7.1 of RFC 2068 [33].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.0のほとんどの実装では、各接続を要求する前に、応答を送信した後に、サーバーによって閉じられ、クライアントによって確立されています。いくつかの実装は、RFC 2068 [33]のセクション19.7.1に記載の永続的な接続のキープアライブバージョンを実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.6.1 Changes from HTTP/1.0
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
HTTP / 1.0からの変更点19.6.1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section summarizes major differences between versions HTTP/1.0 and HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、バージョンHTTP / 1.0とHTTP / 1.1の主な違いをまとめたもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
19.6.1.1 Changes to Simplify Multi-homed Web Servers and Conserve IP Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
19.6.1.1変更は、マルチホームWebサーバーと節約IPアドレスを簡単にするために
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requirements that clients and servers support the Host request-header, report an error if the Host request-header (section 14.23) is missing from an HTTP/1.1 request, and accept absolute URIs (section 5.1.2) are among the most important changes defined by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバがホストリクエストヘッダ（セクション14.23）はHTTP / 1.1リクエストから欠落している場合、エラーを報告し、ホストリクエストヘッダをサポートし、絶対的なURI（セクション5.1.2）を受け入れるの要件は、最も重要なの一つですこの仕様で定義された変更。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no other established mechanism for distinguishing the intended server of a request than the IP address to which that request was directed. The changes outlined above will allow the Internet, once older HTTP clients are no longer common, to support multiple Web sites from a single IP address, greatly simplifying large operational Web servers, where allocation of many IP addresses to a single host has created serious problems. The Internet will also be able to recover the IP addresses that have been allocated for the sole purpose of allowing special-purpose domain names to be used in root-level HTTP URLs. Given the rate of growth of the Web, and the number of servers already deployed, it is extremely important that all implementations of HTTP (including updates to existing HTTP/1.0 applications) correctly implement these requirements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
古いHTTP / 1.0クライアントは、IPアドレスやサーバの1対1の関係を仮定しました。その要求が向けられた先のIPアドレスより要求の意図したサーバーを区別するための他の確立されたメカニズムがありませんでした。上記で概説した変更が大幅に単一のホストに多くのIPアドレスの割り当てが深刻な問題を作成している大規模な運用Webサーバーを、簡素化し、単一のIPアドレスからの複数のWebサイトをサポートするために、一度古いHTTPクライアントはもはや共通している、インターネットを許可しません。インターネットはまた、専用のドメイン名は、ルートレベルのHTTP URLで使用できるようにすることを唯一の目的のために割り当てられているIPアドレスを回復することができます。 Web、およびすでに展開されたサーバーの数の成長率を考えると、（既存のHTTP / 1.0アプリケーションのアップデートを含む）HTTPのすべての実装が正しくこれらの要件を実装することが非常に重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Both clients and servers MUST support the Host request-header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - クライアントとサーバの両方がホストリクエストヘッダをサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A client that sends an HTTP/1.1 request MUST send a Host header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTP / 1.1リクエストを送信するクライアントは、Hostヘッダを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Servers MUST report a 400 (Bad Request) error if an HTTP/1.1 request does not include a Host request-header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  HTTP / 1.1リクエストがHostリクエストヘッダが含まれていない場合、サーバーは400（不正な要求）エラーを報告しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Servers MUST accept absolute URIs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - サーバは絶対URIを受け入れなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.6.2 Compatibility with HTTP/1.0 Persistent Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
HTTP / 1.0永続接続で19.6.2の互換性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some clients and servers might wish to be compatible with some previous implementations of persistent connections in HTTP/1.0 clients and servers. Persistent connections in HTTP/1.0 are explicitly negotiated as they are not the default behavior. HTTP/1.0 experimental implementations of persistent connections are faulty, and the new facilities in HTTP/1.1 are designed to rectify these problems. The problem was that some existing 1.0 clients may be sending Keep-Alive to a proxy server that doesn&#39;t understand Connection, which would then erroneously forward it to the next inbound server, which would establish the Keep-Alive connection and result in a hung HTTP/1.0 proxy waiting for the close on the response. The result is that HTTP/1.0 clients must be prevented from using Keep-Alive when talking to proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのクライアントとサーバは、HTTP / 1.0のクライアントとサーバーでの持続的な接続のいくつかの以前の実装と互換性があることを望むかもしれません。彼らはデフォルトの動作ではないので、HTTP / 1.0での持続的な接続を明示的に交渉されています。 HTTP /持続的接続の1.0実験的な実装が故障しており、HTTP / 1.1での新施設は、これらの問題を是正するために設計されています。問題は、いくつかの既存の1.0のクライアントは、その後誤ってキープアライブ接続を確立し、ハングアップにつながる次のインバウンドサーバに転送します接続を理解していないプロキシサーバにキープアライブ送信することができるということでしたHTTP / 1.0プロキシが応答に近いのを待っています。結果は、HTTP / 1.0クライアントはキープアライブプロキシに話したときに使用しないようにしなければならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, talking to proxies is the most important use of persistent connections, so that prohibition is clearly unacceptable. Therefore, we need some other mechanism for indicating a persistent connection is desired, which is safe to use even when talking to an old proxy that ignores Connection. Persistent connections are the default for HTTP/1.1 messages; we introduce a new keyword (Connection: close) for declaring non-persistence. See section 14.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、プロキシに話をすることは持続的な接続の最も重要な用途であるので、その禁止は明らかに受け入れられません。したがって、我々はコネクションを無視し、古いプロキシに話をするときにも使用しても安全であることが望まれる永続的な接続を示すための他のいくつかのメカニズムが必要です。持続的接続はHTTP / 1.1メッセージのデフォルトです。非永続性を宣言するために：私たちは、新しいキーワード（クローズ接続）を導入します。セクション14.10を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The original HTTP/1.0 form of persistent connections (the Connection: Keep-Alive and Keep-Alive header) is documented in RFC 2068. [33]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
永続的な接続の元のHTTP / 1.0形式（接続：キープアライブとキープアライブヘッダ）は、RFC 2068 [33]に記載されて
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.6.3 Changes from
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
から19.6.3の変更点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification has been carefully audited to correct and disambiguate key word usage; RFC 2068 had many problems in respect to the conventions laid out in RFC 2119 [34].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様は、慎重にキーワードの使用法を修正し、明確にするために監査を受けてきました。 RFC 2068は、RFC 2119 [34]でレイアウト規則に関しての多くの問題を抱えていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clarified which error code should be used for inbound server failures (e.g. DNS failures). (Section 10.5.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インバウンドサーバの障害（例えば、DNS障害）のために使用すべきエラーコードを明らかにしました。 （10.5.5項）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATE had a race that required an Etag be sent when a resource is first created. (Section 10.2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATEリソースが最初に作成されたときに送信されたEtagを必要とレースを持っていました。 （10.2.2項）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Content-Base was deleted from the specification: it was not implemented widely, and there is no simple, safe way to introduce it without a robust extension mechanism. In addition, it is used in a similar, but not identical fashion in MHTML [45].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは広く実装されていなかった、堅牢な拡張機構なしにそれを導入する簡単な、安全な方法はありません：コンテンツ・ベースは仕様から削除されました。加えて、MHTML [45]に類似するが、同一でない方法で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transfer-coding and message lengths all interact in ways that required fixing exactly when chunked encoding is used (to allow for transfer encoding that may not be self delimiting); it was important to straighten out exactly how message lengths are computed. (Sections 3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送符号化およびメッセージは、すべてのチャンクエンコーディングが（自己区切りではないかもしれない転送符号化を可能にするために）使用さを正確に固定する必要の方法で相互作用長さ;メッセージの長さが計算されている正確にどのようにまっすぐにすることが重要でした。 （セクション3.6、4.4、7.2.2、13.5.2、14.13、14.16）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A content-coding of &#34;identity&#34; was introduced, to solve problems discovered in caching. (section 3.5)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「アイデンティティ」の内容コーディングは、キャッシングで発見された問題を解決するために、導入されました。 （セクション3.5）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Quality Values of zero should indicate that &#34;I don&#39;t want something&#34; to allow clients to refuse a representation. (Section 3.9)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゼロの品質値は、クライアントが表現を拒否できるようにする「私が何かを望んでいない」ことを示す必要があります。 （3.9節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The use and interpretation of HTTP version numbers has been clarified by RFC 2145. Require proxies to upgrade requests to highest protocol version they support to deal with problems discovered in HTTP/1.0 implementations (Section 3.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPのバージョン番号の使用及び解釈は、RFC 2145で明らかにされている彼らはHTTP / 1.0の実装（3.1節）で発見された問題に対処するためにサポートする最上位のプロトコルバージョンに要求をアップグレードするためにプロキシを要求
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Charset wildcarding is introduced to avoid explosion of character set names in accept headers. (Section 14.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文字セットのワイルドカードを受け入れるヘッダーに文字セット名の爆発を避けるために導入されます。 （14.2節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A case was missed in the Cache-Control model of HTTP/1.1; s-maxage was introduced to add this missing case. (Sections 13.4, 14.8, 14.9, 14.9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場合は、HTTP / 1.1ののCache-Controlモデルで逃しました。 S-MAXAGEは、この不足している場合を追加するために導入されました。 （セクション13.4、14.8、14.9、14.9.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Cache-Control: max-age directive was not properly defined for responses. (Section 14.9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cache-Control：MAX-ageディレクティブが適切に応答するために定義されていませんでした。 （セクション14.9.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are situations where a server (especially a proxy) does not know the full length of a response but is capable of serving a byterange request. We therefore need a mechanism to allow byteranges with a content-range not indicating the full length of the message. (Section 14.16)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー（特に代理）は、応答の全長を知っているが、バイトレンジ要求にサービスを提供することができない状況があります。したがって、我々は、メッセージの全長を示していないコンテンツの範囲とbyteranges可能にするメカニズムを必要とします。 （セクション14.16）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Range request responses would become very verbose if all meta-data were always returned; by allowing the server to only send needed headers in a 206 response, this problem can be avoided. (Section 10.2.7, 13.5.3, and 14.27)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのメタデータが常に返された場合、範囲要求応答が非常に冗長になります。サーバが唯一の206応答に必要なヘッダーを送信できるようにすることで、この問題を回避することができます。 （セクション10.2.7、13.5.3、および14.27）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fix problem with unsatisfiable range requests; there are two cases: syntactic problems, and range doesn&#39;t exist in the document. The 416 status code was needed to resolve this ambiguity needed to indicate an error for a byte range request that falls outside of the actual contents of a document. (Section 10.4.17, 14.16)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
充足不能範囲要求と問題を修正しました。そこに2例ある：構文上の問題は、その範囲は、文書内に存在しません。 416のステータスコードは、文書の実際の内容の外にあるバイト範囲要求のエラーを示すために必要な、この曖昧さを解決するために必要でした。 （セクション10.4.17、14.16）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rewrite of message transmission requirements to make it much harder for implementors to get it wrong, as the consequences of errors here can have significant impact on the Internet, and to deal with the following problems:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでのエラーの結果は、インターネット上で大きな影響を与える可能性があり、かつ、次のような問題に対処するためとして、それははるかに困難実装者はそれが間違って取得するために作るためのメッセージの送信要件の書き換え：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Changing &#34;HTTP/1.1 or later&#34; to &#34;HTTP/1.1&#34;, in contexts where this was incorrectly placing a requirement on the behavior of an implementation of a future version of HTTP/1.x
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.これは間違ってHTTP / 1.1の将来のバージョンの実装の振る舞いに要件を置きました文脈で、「HTTP / 1.1」に「HTTP / 1.1以降の変更」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Made it clear that user-agents should retry requests, not &#34;clients&#34; in general.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.は、それが明確なユーザーエージェントがリクエストではなく、一般的には、「クライアント」を再試行することを作りました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Converted requirements for clients to ignore unexpected 100 (Continue) responses, and for proxies to forward 100 responses, into a general requirement for 1xx responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
予期しない100（続行）応答を無視するクライアントのために、との1xx応答のための一般的な要件に、100の応答を転送するためのプロキシ3.変換された要件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Modified some TCP-specific language, to make it clearer that non-TCP transports are possible for HTTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.非TCPトランスポートは、HTTPのために可能であることは、それをより明確にするために、いくつかのTCP固有の言語を変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. Require that the origin server MUST NOT wait for the request body before it sends a required 100 (Continue) response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.は、それが必要な100（続行）応答を送信する前に、オリジンサーバがリクエストボディを待つてはならないことを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. Allow, rather than require, a server to omit 100 (Continue) if it has already seen some of the request body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはすでにリクエストボディのいくつかを見ている場合6.許可、必要ではなく、サーバは100（続行）を省略します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. Allow servers to defend against denial-of-service attacks and broken clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7.サーバは、サービス拒否攻撃や壊れたクライアントを防御することを許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This change adds the Expect header and 417 status code. The message transmission requirements fixes are in sections 8.2, 10.4.18, 8.1.2.2, 13.11, and 14.20.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この変化は期待ヘッダと417ステータスコードを付加します。メッセージ伝送要件の修正は、セクション8.2、10.4.18、8.1.2.2、13.11、および14.20です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxies should be able to add Content-Length when appropriate. (Section 13.5.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシは、適切な場合のContent-Lengthを追加することができるはずです。 （13.5.2項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clean up confusion between 403 and 404 responses. (Section 10.4.4, 10.4.5, and 10.4.11)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
403と404応答の間に混乱をクリーンアップします。 （セクション10.4.4、10.4.5、および10.4.11）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Warnings could be cached incorrectly, or not updated appropriately. (Section 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning also needed to be a general header, as PUT or other methods may have need for it in requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
警告は間違ってキャッシュされた、または適切に更新されていないことでした。 （セクション13.1.2、13.2.4、13.5.2、13.5.3、14.9.3、及び14.46）PUTまたは他の方法が要求でそれを必要とするかもしれませんが、また、一般的なヘッダであることを必要と警告。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transfer-coding had significant problems, particularly with interactions with chunked encoding. The solution is that transfer-codings become as full fledged as content-codings. This involves adding an IANA registry for transfer-codings (separate from content codings), a new header field (TE) and enabling trailer headers in the future. Transfer encoding is a major performance benefit, so it was worth fixing [39]. TE also solves another, obscure, downward interoperability problem that could have occurred due to interactions between authentication trailers, chunked encoding and HTTP/1.0 clients.(Section 3.6, 3.6.1, and 14.39)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送コーディングは、特にチャンクエンコーディングとの相互作用で、重大な問題を抱えていました。ソリューションは、内容コーディングなどの本格的なようになっている転送コーディングです。これは、（コンテンツコーディングとは別の）転送コーディングのためのIANAレジストリ、新しいヘッダフィールド（TE）を添加し、将来的にトレーラヘッダを有効にすることを含みます。転送符号化は、主要なパフォーマンス上の利点であり、それは[39]固定価値がありました。 TEはまた、原因認証トレーラとの間の相互作用に発生したかもしれない別の、不明瞭、下方に相互運用性の問題を解決し、符号化及びHTTP / 1.0クライアントをチャンク（3.6節、3.6.1、および14.39）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PATCH, LINK, UNLINK methods were defined but not commonly implemented in previous versions of this specification. See RFC 2068 [33].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PATCH、LINKは、メソッドが定義されているが、一般的に、本明細書の以前のバージョンで実装されなかったリンクを解除します。 RFC 2068 [33]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Alternates, Content-Version, Derived-From, Link, URI, Public and Content-Base header fields were defined in previous versions of this specification, but not commonly implemented. See RFC 2068 [33].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
派生-からのリンク、URI、公共およびContent-基本ヘッダフィールド、代替デバイス、コンテンツのバージョンは、この仕様の以前のバージョンで定義されていますが、一般的に実装されていませんでした。 RFC 2068 [33]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
20 Index
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
20インデックス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Please see the PostScript version of this RFC for the INDEX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
INDEXのため、このRFCのPostScript版を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.完全な著作権声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（1999）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
