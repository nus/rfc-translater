<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 3492 - Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3492</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 3492 - Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc3492">
              https://tools.ietf.org/html/rfc3492
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 3492 - ピュニコード：アプリケーションにおける国際化ドメイン名のUnicodeのブートストリングのエンコード（IDNA）</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                        A. Costello
Request for Comments: 3492                 Univ. of California, Berkeley
Category: Standards Track                                     March 2003
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Punycode: A Bootstring encoding of Unicode
       for Internationalized Domain Names in Applications (IDNA)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode is a simple and efficient transfer encoding syntax designed for use with Internationalized Domain Names in Applications (IDNA). It uniquely and reversibly transforms a Unicode string into an ASCII string. ASCII characters in the Unicode string are represented literally, and non-ASCII characters are represented by ASCII characters that are allowed in host name labels (letters, digits, and hyphens). This document defines a general algorithm called Bootstring that allows a string of basic code points to uniquely represent any string of code points drawn from a larger set. Punycode is an instance of Bootstring that uses particular parameter values specified by this document, appropriate for IDNA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピュニコードは、アプリケーション（IDNA）で国際化ドメイン名で使用するために設計されたシンプルかつ効率的な転送エンコードの構文です。それはユニークかつ可逆ASCII文字列にUnicode文字列を変換します。 Unicode文字列内のASCII文字は、文字通り表現され、非ASCII文字は、ホスト名のラベル（文字、数字、およびハイフン）で許可されているASCII文字で表現されています。この文書は、基本的なコードポイントの列を一意により大きなセットから引き出されたコードポイントの任意の文字列を表現することを可能にするブートストリングと呼ばれる一般的なアルゴリズムを定義します。ピュニコードはIDNAのために適切な本文書で指定された特定のパラメータ値を使用してブートストリングのインスタンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction...............................................2
       1.1 Features..............................................2
       1.2 Interaction of protocol parts.........................3
   2. Terminology................................................3
   3. Bootstring description.....................................4
       3.1 Basic code point segregation..........................4
       3.2 Insertion unsort coding...............................4
       3.3 Generalized variable-length integers..................5
       3.4 Bias adaptation.......................................7
   4. Bootstring parameters......................................8
   5. Parameter values for Punycode..............................8
   6. Bootstring algorithms......................................9
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       6.1 Bias adaptation function.............................10
       6.2 Decoding procedure...................................11
       6.3 Encoding procedure...................................12
       6.4 Overflow handling....................................13
   7. Punycode examples.........................................14
       7.1 Sample strings.......................................14
       7.2 Decoding traces......................................17
       7.3 Encoding traces......................................19
   8. Security Considerations...................................20
   9. References................................................21
       9.1 Normative References.................................21
       9.2 Informative References...............................21
   A. Mixed-case annotation.....................................22
   B. Disclaimer and license....................................22
   C. Punycode sample implementation............................23
   Author&#39;s Address.............................................34
   Full Copyright Statement.....................................35
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDNA] describes an architecture for supporting internationalized domain names. Labels containing non-ASCII characters can be represented by ACE labels, which begin with a special ACE prefix and contain only ASCII characters. The remainder of the label after the prefix is a Punycode encoding of a Unicode string satisfying certain constraints. For the details of the prefix and constraints, see [IDNA] and [NAMEPREP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDNA]国際化ドメイン名をサポートするためのアーキテクチャについて説明します。非ASCII文字を含むラベルは、特別なACEプレフィックスで始まり、ASCII文字のみが含まれているACEラベル、で表すことができます。接頭後にラベルの残りの部分は、特定の制約を満たすUnicode文字列のピュニコードエンコーディングです。プレフィックスと制約の詳細については、[NAMEPREP] [IDNA]を参照して。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode is an instance of a more general algorithm called Bootstring, which allows strings composed from a small set of &#34;basic&#34; code points to uniquely represent any string of code points drawn from a larger set. Punycode is Bootstring with particular parameter values appropriate for IDNA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピュニコードは、「基本」コードポイントの小さい集合からなる文字列を一意により大きなセットから引き出されたコードポイントの任意の文字列を表現することを可能にするブートストリングと呼ばれるより一般的なアルゴリズムの例です。ピュニコードはIDNAに適した特定のパラメータ値を用いてブートストリングれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1特長
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstring has been designed to have the following features:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブートストリングは、次のような特徴を持つように設計されています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Completeness: Every extended string (sequence of arbitrary code points) can be represented by a basic string (sequence of basic code points). Restrictions on what strings are allowed, and on length, can be imposed by higher layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*完全性：すべての拡張文字列（任意のコード・ポイントのシーケンス）を基本文字列（基本コードポイントのシーケンス）で表すことができます。どのような文字列の制限が許可され、そして長さに、上位層によって課すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Uniqueness: There is at most one basic string that represents a given extended string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*一意性：指定した拡張文字列を表し、最大1つの基本的な文字列があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Reversibility: Any extended string mapped to a basic string can be recovered from that basic string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*可逆性：基本的な文字列にマッピングされた任意の拡張文字列は、その基本的な文字列から回収することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Efficient encoding: The ratio of basic string length to extended string length is small. This is important in the context of domain names because RFC 1034 [RFC1034] restricts the length of a domain label to 63 characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*効率的な符号化：拡張された文字列の長さに基本的な文字列の長さの比が小さいです。 RFC 1034 [RFC1034]は63個の文字にドメインラベルの長さを制限しているためこれは、ドメイン名の文脈で重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Simplicity: The encoding and decoding algorithms are reasonably simple to implement. The goals of efficiency and simplicity are at odds; Bootstring aims at a good balance between them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*シンプル：符号化と復号化アルゴリズムは、合理的に実現するのは簡単です。効率性とシンプルさの目標は対立しています。ブートストリングは、それらの間の良好なバランスを目指しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Readability: Basic code points appearing in the extended string are represented as themselves in the basic string (although the main purpose is to improve efficiency, not readability).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*可読性：（主な目的は、効率ではなく、読みやすさを改善することであるが）、拡張文字列に現れる基本的なコードポイントは基本文字列でそれ自体として表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode can also support an additional feature that is not used by the ToASCII and ToUnicode operations of [IDNA]. When extended strings are case-folded prior to encoding, the basic string can use mixed case to tell how to convert the folded string into a mixed-case string. See appendix A &#34;Mixed-case annotation&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピュニコードまた、[IDNA]のもしToASCIIとのToUnicode操作で使用されていない追加の機能をサポートすることができます。拡張文字列は、大文字小文字が変換符号化の前にあるときは、基本的な文字列は、大文字と小文字の文字列に折りたたまれた文字列を変換する方法を教えて大文字と小文字を使用することができます。 「混合ケース注釈を」付録を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2 Interaction of protocol parts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
プロトコル部品の1.2インタラクション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode is used by the IDNA protocol [IDNA] for converting domain labels into ASCII; it is not designed for any other purpose. It is explicitly not designed for processing arbitrary free text.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピュニコードは、ASCIIにドメインラベルを変換するIDNAプロトコル[IDNA]で使用されます。それは、他の目的のために設計されていません。これは、明示的に任意のフリーテキストを処理するために設計されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14, RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますBCP 14、RFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A code point is an integral value associated with a character in a coded character set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コード・ポイントは、符号化された文字セット内の文字に関連付けられた積分値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As in the Unicode Standard [UNICODE], Unicode code points are denoted by &#34;U+&#34; followed by four to six hexadecimal digits, while a range of code points is denoted by two hexadecimal numbers separated by &#34;..&#34;, with no prefixes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードポイントの範囲はないプレフィックスと、「..」で区切られた2つの16進数で表されている間Unicode標準[UNICODE]のように、Unicodeコードポイントは、4〜6桁の16進数字が続く「U +」で示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operators div and mod perform integer division; (x div y) is the quotient of x divided by y, discarding the remainder, and (x mod y) is the remainder, so (x div y) * y + (x mod y) == x. Bootstring uses these operators only with nonnegative operands, so the quotient and remainder are always nonnegative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
演算子DIVとMODは整数除算を実行します。 （XのDIVのY）x ==残りを廃棄、yで割ったXの商であり、（MOD Y x）の余りであるので、（MOD Y X）（Xのdiv Y）*のY +。ブートストリングは、非負オペランドでこれらの演算子を使用するため、商と余りは常に非負です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The break statement jumps out of the innermost loop (as in C).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
break文は、（Cのように）最内ループの外にジャンプします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An overflow is an attempt to compute a value that exceeds the maximum value of an integer variable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーフローは、整数変数の最大値を超える値を計算しようとする試みです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Bootstring description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.ブートストリングの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstring represents an arbitrary sequence of code points (the &#34;extended string&#34;) as a sequence of basic code points (the &#34;basic string&#34;). This section describes the representation. Section 6 &#34;Bootstring algorithms&#34; presents the algorithms as pseudocode. Sections 7.1 &#34;Decoding traces&#34; and 7.2 &#34;Encoding traces&#34; trace the algorithms for sample inputs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブートストリングは、基本コード・ポイント（「基本的な文字列」）のシーケンスとしてコード・ポイントの任意の配列（「拡張文字列」）を表します。このセクションでは、表現を記述します。第6章「ブートストリングアルゴリズムは」擬似コードなどのアルゴリズムを提示します。セクション7.1「デコード・トレース」と7.2のサンプル入力のためのアルゴリズムをたどる「エンコーディングはトレース」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe the four techniques used in Bootstring. &#34;Basic code point segregation&#34; is a very simple and efficient encoding for basic code points occurring in the extended string: they are simply copied all at once. &#34;Insertion unsort coding&#34; encodes the non-basic code points as deltas, and processes the code points in numerical order rather than in order of appearance, which typically results in smaller deltas. The deltas are represented as &#34;generalized variable-length integers&#34;, which use basic code points to represent nonnegative integers. The parameters of this integer representation are dynamically adjusted using &#34;bias adaptation&#34;, to improve efficiency when consecutive deltas have similar magnitudes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、ブートストリングに使用される4つのテクニックについて説明します。 「基本的なコードポイントの分離は、」拡張された文字列で発生した基本的なコードポイントのための非常にシンプルかつ効率的な符号化である：彼らは単にすべてを一度にコピーされます。 「コーディングソート解除挿入」は、典型的には、より小さなデルタをもたらす、デルタのような非基本コードポイントを符号化し、番号順ではなく、出現順にコードポイントを処理します。デルタは、非負整数を表すために、基本的なコードポイントを使用して、「一般化可変長整数」として表されます。この整数表現のパラメータを動的に連続デルタは同様の大きさを有するとき、効率を改善するために、「バイアス適応」を使用して調整されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 Basic code point segregation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 Basicのコードポイントの分離
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All basic code points appearing in the extended string are represented literally at the beginning of the basic string, in their original order, followed by a delimiter if (and only if) the number of basic code points is nonzero. The delimiter is a particular basic code point, which never appears in the remainder of the basic string. The decoder can therefore find the end of the literal portion (if there is one) by scanning for the last delimiter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張された文字列に現れるすべての基本コードポイントは、基本的なコードポイントの数がゼロでない（そして場合のみ）場合デリミタ続いて、元の順序で、基本的な文字列の先頭に文字通り表されます。デリミタは、基本的な文字列の残りの部分に表示されません特定の基本的なコード・ポイントです。最後のデリミタのスキャンによって（存在する場合）、デコーダは、したがって、リテラル部分の終わりを見つけることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Insertion unsort coding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2挿入ソート解除コーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remainder of the basic string (after the last delimiter if there is one) represents a sequence of nonnegative integral deltas as generalized variable-length integers, described in section 3.3. The meaning of the deltas is best understood in terms of the decoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（存在する場合、最後のデリミタの後に）基本的な文字列の残りの部分は、セクション3.3で説明した一般化可変長整数として非負積分デルタの配列を表します。デルタの意味は、最高のデコーダの観点で理解されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder builds the extended string incrementally. Initially, the extended string is a copy of the literal portion of the basic string (excluding the last delimiter). The decoder inserts non-basic code points, one for each delta, into the extended string, ultimately arriving at the final decoded string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダは、増分拡張文字列を構築します。最初に、拡張された文字列は、（最後の区切り文字を除く）の基本的な文字列リテラルの一部のコピーです。デコーダは、最終的に最終的なデコードされた文字列に到着し、拡張された文字列に、非基本コードポイント、各デルタのための1つを挿入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the heart of this process is a state machine with two state variables: an index i and a counter n. The index i refers to a position in the extended string; it ranges from 0 (the first position) to the current length of the extended string (which refers to a potential position beyond the current end). If the current state is &lt;n,i&gt;, the next state is &lt;n,i+1&gt; if i is less than the length of the extended string, or &lt;n+1,0&gt; if i equals the length of the extended string. In other words, each state change causes i to increment, wrapping around to zero if necessary, and n counts the number of wrap-arounds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インデックスiとカウンタn：このプロセスの心臓部には2つの状態変数とステートマシンがあります。インデックスiは、拡張文字列内の位置を指します。それが0（最初の位置）から（現在の端を越えて潜在的位置を意味する）、拡張文字列の現在の長さの範囲です。現在の状態である場合には&lt;N、i&gt;は、次の状態は、&lt;N、I + 1&gt; iは、拡張文字列の長さよりも小さい場合、または&lt;N + 1,0&gt; iは、拡張の長さと等しい場合文字列。換言すれば、各状態変化が必要な場合、ゼロにラップアラウンド、iをインクリメントさせ、そしてnはラップアラウンドの数をカウントします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notice that the state always advances monotonically (there is no way for the decoder to return to an earlier state). At each state, an insertion is either performed or not performed. At most one insertion is performed in a given state. An insertion inserts the value of n at position i in the extended string. The deltas are a run-length encoding of this sequence of events: they are the lengths of the runs of non-insertion states preceeding the insertion states. Hence, for each delta, the decoder performs delta state changes, then an insertion, and then one more state change. (An implementation need not perform each state change individually, but can instead use division and remainder calculations to compute the next insertion state directly.) It is an error if the inserted code point is a basic code point (because basic code points were supposed to be segregated as described in section 3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態は常に単調に進んでいること（デコーダが以前の状態に戻す方法はありません）に注意してください。各状態で、挿入を行うか、行わないのいずれか。せいぜい1つの挿入が与えられた状態で行われます。挿入は、拡張文字列内の位置iにおけるnの値を挿入します。デルタは、この一連のイベントのランレングス符号化されている：彼らは、挿入状態に先行する非挿入状態のランの長さです。したがって、各デルタのために、デコーダは、デルタ状態の変更、挿入、次いでもう一つの状態変化を行います。 （実装は、個々の状態の変更を行う必要はなく、代わりに、直接次の挿入状態を計算する除算と剰余演算を使用することができる。）基本的なコードポイントがになっていたので、挿入されたコードポイント（基本コード・ポイントである場合は、エラーでありますセクション3.1で説明したように）分離します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encoder&#39;s main task is to derive the sequence of deltas that will cause the decoder to construct the desired string. It can do this by repeatedly scanning the extended string for the next code point that the decoder would need to insert, and counting the number of state changes the decoder would need to perform, mindful of the fact that the decoder&#39;s extended string will include only those code points that have already been inserted. Section 6.3 &#34;Encoding procedure&#34; gives a precise algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーダの主なタスクは、デコーダが目的の文字列を構築するようになりますデルタのシーケンスを導出することです。これは、デコーダは、デコーダの拡張文字列だけのものが挙げられるだろうという事実を、意識実行する必要があります変わり繰り返しデコーダを挿入するために必要となる次のコード・ポイントのために拡張された文字列をスキャンし、状態の数をカウントすることによって、これを行うことができます既に挿入されたコードポイント。 6.3節「符号化手順は、」正確なアルゴリズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 Generalized variable-length integers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3一般化可変長整数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a conventional integer representation the base is the number of distinct symbols for digits, whose values are 0 through base-1. Let digit_0 denote the least significant digit, digit_1 the next least significant, and so on. The value represented is the sum over j of digit_j * w(j), where w(j) = base^j is the weight (scale factor) for position j. For example, in the base 8 integer 437, the digits are 7, 3, and 4, and the weights are 1, 8, and 64, so the value is 7 + 3*8 + 4*64 = 287. This representation has two disadvantages: First, there are multiple encodings of each value (because there can be extra zeros in the most significant positions), which is inconvenient when unique encodings are needed. Second, the integer is not self-delimiting, so if multiple integers are concatenated the boundaries between them are lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従来の整数表現のベースは、値ベース-1を介して0である数字のための別個のシンボルの数です。 digit_0最下位桁を示すものと、その次の最下位、およびdigit_1。示される値は、位置jについてW（J）=ベース^ jは重み（スケールファクタ）である（J）、W digit_j *のJにわたる和です。値は、この表現が有する7 + 3 * 8 + 4×64 = 287であるので、例えば、基数8の整数437で、数字は7,3、および4であり、重みは、1~8であり、そして64 2つの欠点は：まず、ユニークなエンコーディングが必要な場合には不便である各値（最上位の位置に余分なゼロが存在する可能性があるため）、複数の符号化方式があります。第二に、整数は自己区切りではないので、複数の整数が連結されている場合は、それらの間の境界が失われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The generalized variable-length representation solves these two problems. The digit values are still 0 through base-1, but now the integer is self-delimiting by means of thresholds t(j), each of which is in the range 0 through base-1. Exactly one digit, the most significant, satisfies digit_j &lt; t(j). Therefore, if several integers are concatenated, it is easy to separate them, starting with the first if they are little-endian (least significant digit first), or starting with the last if they are big-endian (most significant digit first). As before, the value is the sum over j of digit_j * w(j), but the weights are different:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般可変長表現は、この2つの問題を解決します。桁の値は、ベース1を介して依然として0であるが、今整数は、ベース1を介して範囲0であり、各々が閾値T（j）は、によって自己区切りです。正確に1桁、最も重要な、満足しdigit_j &lt;T（J）。いくつかの整数が連結されている場合したがって、彼らが（最初の最下位桁）リトルエンディアンであれば最初から始まる、または、彼らは（最初の最上位桁）ビッグエンディアンであれば最後から開始して、それらを分離することは容易です。前と同じように、値（J）w * digit_jのJにわたって和が、重みが異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
w(0) = 1 w(j) = w(j-1) * (base - t(j-1)) for j &gt; 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
J&gt; 0  - （0）= 1、W（J）= W（J-1）*（T（J-1）塩基）w
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider the little-endian sequence of base 8 digits 734251... Suppose the thresholds are 2, 3, 5, 5, 5, 5... This implies that the weights are 1, 1*(8-2) = 6, 6*(8-3) = 30, 30*(8-5) = 90, 90*(8-5) = 270, and so on. 7 is not less than 2, and 3 is not less than 3, but 4 is less than 5, so 4 is the last digit. The value of 734 is 7*1 + 3*6 + 4*30 = 145. The next integer is 251, with value 2*1 + 5*6 + 1*30 = 62. Decoding this representation is very similar to decoding a conventional integer: Start with a current value of N = 0 and a weight w = 1. Fetch the next digit d and increase N by d * w. If d is less than the current threshold (t) then stop, otherwise increase w by a factor of (base - t), update t for the next position, and repeat.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、閾値は2、3、5、5、5、5であると仮定...ベースのリトルエンディアンシーケンスを8桁734251を考える...これは、重みが1、1 *（8-2）であることを意味します= 6,6 *（8-3）= 30、30 *（8-5）= 90、90 *（8-5）= 270、など。図7は、2以上であり、3は3以上であるが、4 SO 4を最後の桁であり、5未満です。 734の値は、7×1 + 3 * 6 + 4×30 = 145次の整数値で、251は2 * 1 + 5 * 6 + 1×30 = 62この表現を復号化する復号化することは非常に類似しています従来の整数：次の桁dを取得し、D * WによりNを増やす1. = N = 0の電流値と重みwから開始します。 dが電流閾値（T）よりも小さい場合、停止し、そうでない場合（ベース -  t）の係数でwが増加、次の位置tを更新し、繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding this representation is similar to encoding a conventional integer: If N &lt; t then output one digit for N and stop, otherwise output the digit for t + ((N - t) mod (base - t)), then replace N with (N - t) div (base - t), update t for the next position, and repeat.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この表現を符号化することは、従来の整数を符号化に類似している：NのためのN &lt;T、出力一桁場合や停止、そうでなければ出力のT +ため桁（（N  -  T）MOD（ベース -  T））、次いで（とNを置き換えますN  -  T）DIV（ベース -  t）は、次の位置、及び繰り返しの更新T。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any particular set of values of t(j), there is exactly one generalized variable-length representation of each nonnegative integral value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
T（j）の値の任意の特定のセットについて、各非負整数値の正確に一つの一般化された可変長表現があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstring uses little-endian ordering so that the deltas can be separated starting with the first. The t(j) values are defined in terms of the constants base, tmin, and tmax, and a state variable called bias:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブートストリングは、デルタが最初から始まる分離することができるようにリトルエンディアン順序付けを使用しています。 T（j）の値は定数ベース、TMINとTMAX、および状態変数と呼ばれるバイアスの観点で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
t(j) = base * (j + 1) - bias, clamped to the range tmin through tmax
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
T（J）=ベース*（J + 1） - バイアスは、TMAXを介し範囲TMINにクランプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The clamping means that if the formula yields a value less than tmin or greater than tmax, then t(j) = tmin or tmax, respectively. (In the pseudocode in section 6 &#34;Bootstring algorithms&#34;, the expression base * (j + 1) is denoted by k for performance reasons.) These t(j) values cause the representation to favor integers within a particular range determined by the bias.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クランプ式はそれぞれ、次にT（J）= TMINまたはTMAX、TMAXよりTMINよりも小さいか大きい値が得られる場合、その意味します。 （セクション6の擬似コード「ブートストリングアルゴリズム」は、式ベース*（J + 1）は、パフォーマンス上の理由Kによって示される。）これらのT（j）の値が表現はバイアスによって決定される特定の範囲内の整数を支持させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 Bias adaptation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4バイアスの適応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After each delta is encoded or decoded, bias is set for the next delta as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各差分が符号化又は復号化された後に、次のように、バイアスは次のデルタのために設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Delta is scaled in order to avoid overflow in the next step:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.デルタは、次のステップでオーバーフローを防止するためにスケーリングされています。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
let delta = delta div 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
デルタ=デルタのdiv 2を聞かせて
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
But when this is the very first delta, the divisor is not 2, but instead a constant called damp. This compensates for the fact that the second delta is usually much smaller than the first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは非常に最初のデルタであるときしかし、除数が2ではなく、定数が湿っと呼ばれます。これは、第2のデルタは通常、最初のものよりはるかに小さいという事実を補償します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Delta is increased to compensate for the fact that the next delta will be inserting into a longer string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.デルタは次のデルタが長い文字列に挿入されるという事実を補うために増加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
let delta = delta + (delta div numpoints)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
聞かせデルタ=デルタ+（デルタのdiv numpoints）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
numpoints is the total number of code points encoded/decoded so far (including the one corresponding to this delta itself, and including the basic code points).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
numpoints（このデルタ自身に対応するもの、及び基本的なコードポイントなどを含む）これまでに符号化/復号化コードポイントの総数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Delta is repeatedly divided until it falls within a threshold, to predict the minimum number of digits needed to represent the next delta:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.それは次のデルタを表すのに必要な最小桁数を予測するために、閾値内に入るまで、デルタが繰り返し分割されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         while delta &gt; ((base - tmin) * tmax) div 2
         do let delta = delta div (base - tmin)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. The bias is set:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.バイアスが設定されます。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         let bias =
           (base * the number of divisions performed in step 3) +
           (((base - tmin + 1) * delta) div (delta + skew))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The motivation for this procedure is that the current delta provides a hint about the likely size of the next delta, and so t(j) is set to tmax for the more significant digits starting with the one expected to be last, tmin for the less significant digits up through the one expected to be third-last, and somewhere between tmin and tmax for the digit expected to be second-last (balancing the hope of the expected-last digit being unnecessary against the danger of it being insufficient).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この手順のための動機は、現在のデルタは、次のデルタのありそうな大きさについてのヒントを提供することであり、したがってT（j）が最後であることが期待1から始まるより有効数字のためのT maxに設定されている、以下のためにTMIN重要なサード最後であることが予想1の数字アップ、そしてどこかTMINとTMAXの間に第二の最後であることが予想数字のために（期待-最後の数字は、それが不十分であることの危険性に対する不必要であることの希望を均衡）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Bootstring parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.ブートストリングパラメータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given a set of basic code points, one needs to be designated as the delimiter. The base cannot be greater than the number of distinguishable basic code points remaining. The digit-values in the range 0 through base-1 need to be associated with distinct non-delimiter basic code points. In some cases multiple code points need to have the same digit-value; for example, uppercase and lowercase versions of the same letter need to be equivalent if basic strings are case-insensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的なコードポイントの集合与えられ、一つは区切り文字として指定する必要があります。塩基は、残りの識別可能な基本的なコードポイントの数を超えることはできません。ベース1を介して範囲0で桁の値が異なる非区切り基本コード・ポイントに関連付けする必要があります。いくつかのケースでは、複数のコード・ポイントは、同じ桁値を有する必要があります。例えば、同じ文字の大文字と小文字のバージョンでは、基本的な文字列は大文字と小文字を区別しない場合と同等にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial value of n cannot be greater than the minimum non-basic code point that could appear in extended strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nの初期値は、拡張文字列に表示される可能性が最小の非基本コードポイントを超えることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining five parameters (tmin, tmax, skew, damp, and the initial value of bias) need to satisfy the following constraints:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りの5つのパラメータ（TMIN、TMAX、スキュー、湿気、及びバイアスの初期値）は、以下の制約を満たす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0 &lt;= tmin &lt;= tmax &lt;= base-1 skew &gt;= 1 damp &gt;= 2 initial_bias mod base &lt;= base - tmin
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0 &lt;= TMIN &lt;= TMAX &lt;=ベース1スキュー&gt; = 1減衰&gt; = 2 initial_bias MOD基地&lt;=ベース -  TMIN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Provided the constraints are satisfied, these five parameters affect efficiency but not correctness. They are best chosen empirically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約条件が満たされて設けられて、これらの5つのパラメータは、効率性ではなく、正確さに影響を与えます。彼らは最高の経験的に選択されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If support for mixed-case annotation is desired (see appendix A), make sure that the code points corresponding to 0 through tmax-1 all have both uppercase and lowercase forms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
混在ケース注釈のサポートが（付録Aを参照）が所望される場合、コードポイントは、すべてTMAX-1を介して0に対応する両方の大文字と小文字の形態を有することを確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Parameter values for Punycode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ピュニコード5.パラメータ値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode uses the following Bootstring parameter values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピュニコードには、以下のブートストリングパラメータ値を使用しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
base = 36 tmin = 1 tmax = 26 skew = 38 damp = 700 initial_bias = 72 initial_n = 128 = 0x80
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
基地= 36 TMIN = 1 TMAX = 26スキュー= 38減衰= 700 initial_bias = 72 initial_n = 128 = 0x80と
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the only restriction Punycode imposes on the input integers is that they be nonnegative, these parameters are especially designed to work well with Unicode [UNICODE] code points, which are integers in the range 0..10FFFF (but not D800..DFFF, which are reserved for use by the UTF-16 encoding of Unicode). The basic code points are the ASCII [ASCII] code points (0..7F), of which U+002D (-) is the delimiter, and some of the others have digit-values as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピュニコード入力整数に課す唯一の制限は、それらが非負であることがあるが、これらのパラメータは、特に範囲0..10FFFF（ただしD800..DFFFの整数であるユニコード[UNICODE]コードポイント、とうまく動作するように設計され、これは、UnicodeのUTF-16符号化）による使用のために予約されています。 ：（ - ）区切り文字であり、次のように、他の一部は、桁値を有する基本コードポイントはU + 002Dは、そのASCII [ASCII]コードポイント（0..7F）、あります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      code points    digit-values
      ------------   ----------------------
      41..5A (A-Z) =  0 to 25, respectively
      61..7A (a-z) =  0 to 25, respectively
      30..39 (0-9) = 26 to 35, respectively
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using hyphen-minus as the delimiter implies that the encoded string can end with a hyphen-minus only if the Unicode string consists entirely of basic code points, but IDNA forbids such strings from being encoded. The encoded string can begin with a hyphen-minus, but IDNA prepends a prefix. Therefore IDNA using Punycode conforms to the RFC 952 rule that host name labels neither begin nor end with a hyphen-minus [RFC952].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
区切り文字としてハイフンマイナスを使用してエンコードされた文字列は、Unicode文字列は、基本的なコードポイントの全体からなるが、IDNAは、符号化されているから、そのような文字列を禁止した場合にのみハイフンマイナスで終了することができることを意味します。エンコードされた文字列は、ハイフンマイナスで始めることができますが、IDNAは、接頭辞を付加します。したがってIDNA使用ピュニコードは、ホスト名がどちらも始まりもなく、ハイフン、マイナス[RFC952]で終わるラベルRFC 952の規則に準拠しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A decoder MUST recognize the letters in both uppercase and lowercase forms (including mixtures of both forms). An encoder SHOULD output only uppercase forms or only lowercase forms, unless it uses mixed-case annotation (see appendix A).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダは、（両方の形の混合物を含む）の両方の大文字と小文字の形態で文字を認識しなければなりません。エンコーダは、それが混在する場合のアノテーションを使用しない限り（付録A参照）、出力のみ大文字フォームまたは小文字のみの形態をすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Presumably most users will not manually write or type encoded strings (as opposed to cutting and pasting them), but those who do will need to be alert to the potential visual ambiguity between the following sets of characters:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
おそらく、ほとんどのユーザーは、手動で書いたり、入力エンコードされた文字列を（それらをカット＆ペーストではなく）、しかし行う者は、以下の文字の集合との間の潜在的な視覚的なあいまいさへの警戒が必要になりますしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
G 6 I l 1 O 0 S 5 U V Z 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
G 6 I L 1 O 0 S 5 U V Z 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such ambiguities are usually resolved by context, but in a Punycode encoded string there is no context apparent to humans.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような曖昧さは、通常、文脈によって解決が、ピュニコードエンコードされた文字列で、人間には明らか何のコンテキストがありませんされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Bootstring algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.ブートストリングアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some parts of the pseudocode can be omitted if the parameters satisfy certain conditions (for which Punycode qualifies). These parts are enclosed in {braces}, and notes immediately following the pseudocode explain the conditions under which they can be omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメータは、（ピュニコードが資格れる）特定の条件を満たした場合に擬似コードの一部を省略することができます。これらの部品は、中括弧{}で囲まれ、そして直ちに擬似コードを以下の注意事項は、それらが省略できる条件を説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Formally, code points are integers, and hence the pseudocode assumes that arithmetic operations can be performed directly on code points. In some programming languages, explicit conversion between code points and integers might be necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正式に、コードポイントは整数であるので、擬似コードは算術演算がコードポイント上で直接行うことができることを想定しています。一部のプログラミング言語では、コードポイントと整数間の明示的な変換が必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 Bias adaptation function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1バイアス適応機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
function adapt(delta,numpoints,firsttime): if firsttime then let delta = delta div damp else let delta = delta div 2 let delta = delta + (delta div numpoints) let k = 0 while delta &gt; ((base - tmin) * tmax) div 2 do begin let delta = delta div (base - tmin) let k = k + base end return k + (((base - tmin + 1) * delta) div (delta + skew))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数は（デルタ、numpoints、FIRSTTIME）を適応させる：FIRSTTIMEはその後、他のデルタ=デルタのdiv湿ったデルタ=デルタのdiv 2は、デルタ=デルタ+（デルタのdiv numpoints）はデルタ&gt;（（ベースながら、K = 0を聞かせて聞かせて聞かせて聞かせている場合 -  TMIN）* TMAX）デルタ=デルタDIVせ始めるないDIV 2（塩基 -  TMIN）を聞かせて、K = K +ベース端リターンK +（（（ベース -  TMIN + 1）*デルタ）DIV（デルタ+スキュー））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It does not matter whether the modifications to delta and k inside adapt() affect variables of the same name inside the encoding/decoding procedures, because after calling adapt() the caller does not read those variables before overwriting them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、デルタに変更するかどうかは問題と適応内部K（）ので、それらを上書きする前にこれらの変数を読み取りません（）適応発信者を呼び出した後、エンコーディング/デコーディング手順の内側に同じ名前の変数には影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 Decoding procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2復号化手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
let n = initial_n let i = 0 let bias = initial_bias let output = an empty string indexed from 0 consume all code points before the last delimiter (if there is one) and copy them to output, fail on any non-basic code point if more than zero code points were consumed then consume one more (which will be the last delimiter) while the input is not exhausted do begin let oldi = i let w = 1 for k = base to infinity in steps of base do begin consume a code point, or fail if there was none to consume let digit = the code point&#39;s digit-value, fail if it has none let i = i + digit * w, fail on overflow let t = tmin if k &lt;= bias {+ tmin}, or tmax if k &gt;= bias + tmax, or k - bias otherwise if digit &lt; t then break let w = w * (base - t), fail on overflow end let bias = adapt(i - oldi, length(output) + 1, test oldi is 0?) let n = n + i div (length(output) + 1), fail on overflow let i = i mod (length(output) + 1) {if n is a basic code point then fail} insert n into output at position i increment i end
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N = initial_n 0は任意の非基本コードポイント場合に失敗し、（存在する場合）、最後の区切りの前のすべてのコードポイントを消費し、出力にコピーから、私は=バイアス= initial_bias出力をさせましょう0 =空の文字列がインデックスさせましょう以上のゼロ・コード・ポイントは、次に=入力が使い果たされていない間（最後のデリミタであろう）もう一つはoldiを聞かせ始めるか消費iはコードを消費し始めるんベースのステップで無限=ベースWせ= kの1を消費しましたポイントは、またはそれがどれもが私を聞かせていない場合に失敗し、桁=コードポイントの桁値をせ消費する何がなかった場合に失敗= iは、W桁*を+ T = TMINを聞かせてオーバーフローに失敗した場合、K &lt;=バイアス{+ TMIN} 、またはTMAX K&gt; =バイアス+ TMAX、またはK場合 - バイアスは、そうでなければ桁が&lt;T、次いで、W = W *（ベース -  T）させ破る場合、オーバーフロー端に失敗バイアス=適応（Iせ -  oldi、長さ（出力） + 1、試験oldiが0？）私は（長さ（出力）+ 1）DIV N = N +せ、オーバーフローに失敗nが、基本的なコード・ポイントである場合、私は= iは{）（長さ（出力）+ 1国防省せフェイル}私はENを増分位置の出力にN挿入D
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The full statement enclosed in braces (checking whether n is a basic code point) can be omitted if initial_n exceeds all basic code points (which is true for Punycode), because n is never less than initial_n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initial_nは（ピュニコードも同様である）すべての基本コードポイントを超えている場合、nはinitial_nより少ないことはないので（nは基本コード・ポイントであるかどうかをチェック）中括弧で囲まれた完全なステートメントは、省略することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the assignment of t, where t is clamped to the range tmin through tmax, &#34;+ tmin&#34; can always be omitted. This makes the clamping calculation incorrect when bias &lt; k &lt; bias + tmin, but that cannot happen because of the way bias is computed and because of the constraints on the parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TがTMAX、「+ TMIN」を介し範囲TMINにクランプされているTの割り当て、常に省略することができます。これは、バイアス&lt;K &lt;バイアス+ TMIN、それが原因で、バイアスが計算されている方法のため、およびパラメータの制約により起こることができないとき、クランプ計算が間違ってます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the decoder state can only advance monotonically, and there is only one representation of any delta, there is therefore only one encoded string that can represent a given sequence of integers. The only error conditions are invalid code points, unexpected end-of-input, overflow, and basic code points encoded using deltas instead of appearing literally. If the decoder fails on these errors as shown above, then it cannot produce the same output for two distinct inputs. Without this property it would have been necessary to re- encode the output and verify that it matches the input in order to guarantee the uniqueness of the encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デコーダ状態のみ単調に前進することができ、任意のデルタのいずれか一方のみの表現があるため、整数の所定のシーケンスを表すことができる唯一のエンコードされた文字列が存在します。唯一のエラー状態は、無効なコード・ポイント、予期しない終了の入力、オーバーフロー、およびデルタを使用して代わりに文字通りに現れる符号化された基本コード・ポイントです。上記のように、デコーダは、これらのエラーで失敗した場合、それは、2つの異なる入力に対して同じ出力を生成することができません。このプロパティがなければ、エンコードした出力を再し、それがエンコーディングの一意性を保証するために、入力と一致することを確認する必要があったであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 Encoding procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3符号化手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
let n = initial_n let delta = 0 let bias = initial_bias let h = b = the number of basic code points in the input copy them to the output in order, followed by a delimiter if b &gt; 0 {if the input contains a non-basic code point &lt; n then fail} while h &lt; length(input) do begin let m = the minimum {non-basic} code point &gt;= n in the input let delta = delta + (m - n) * (h + 1), fail on overflow let n = m for each code point c in the input (in order) do begin if c &lt; n {or c is basic} then increment delta, fail on overflow if c == n then begin let q = delta for k = base to infinity in steps of base do begin let t = tmin if k &lt;= bias {+ tmin}, or tmax if k &gt;= bias + tmax, or k - bias otherwise if q &lt; t then break output the code point for digit t + ((q - t) mod (base - t)) let q = (q - t) div (base - t) end output the code point for digit q let bias = adapt(delta, h + 1, test h equals b?) let delta = 0 increment h end end increment delta and n end
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
せ、N =せinitial_nデルタ= 0 LETバイアス= initial_bias時間= bが=入力における基本的なコードポイントの数は、区切り文字が続く順序で出力にコピー許可すれば、入力が非を含む場合、B&gt; 0 {基本コードポイントH &lt;長さ（入力）入力で、M =最小{非塩基}コードポイント&gt; = nはせせ始めるかながら&lt;N次いで}失敗デルタ=デルタ+（M  -  N）*（H + 1 ）、cは&lt;N =次いで、デルタをインクリメントC ==場合オーバーフローに失敗N次いでQをさせ始める{又はCが塩基性である}場合ために入力（）内の各コードポイントCのため= M Nせ始めるかオーバーフローに失敗デルタ開始ない塩基のステップで無限にK =ベースについてのT = TMINを許可すれば、K &lt;=バイアス{+ TMIN}、またはTMAXであれば、K&gt; =バイアス+ TMAX、またはK  -  qは&lt;T、出力破るそうでない場合にバイアス（ -  T）MOD（ベース - （Q T））桁T +のコード点Q =（Q  -  T）とするDIV（ベース -  T）エンド出力桁Qのコードポイントは、バイアスを聞かせ=（デルタ、時間+を適応させます図1は、試験h）は？Bに等しいデルタ= 0インクリメントH末端端増分デルタ及びN末端を聞かせ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The full statement enclosed in braces (checking whether the input contains a non-basic code point less than n) can be omitted if all code points less than initial_n are basic code points (which is true for Punycode if code points are unsigned).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initial_n未満のすべてのコードポイントが（コードポイントが符号なしである場合ピュニコードについても同様である）基本コード・ポイントである場合（入力がnよりも非基本コードポイント未満含まれているかどうかをチェックする）中括弧で囲まれた完全な文を省略することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The brace-enclosed conditions &#34;non-basic&#34; and &#34;or c is basic&#34; can be omitted if initial_n exceeds all basic code points (which is true for Punycode), because the code point being tested is never less than initial_n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initial_nは（ピュニコードも同様である）すべての基本コードポイントを超えた場合に試験されているコード・ポイントがinitial_nより少ないことはないので、ブレースで囲まれた条件「非塩基性」及び「又はC塩基性である」は、省略することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the assignment of t, where t is clamped to the range tmin through tmax, &#34;+ tmin&#34; can always be omitted. This makes the clamping calculation incorrect when bias &lt; k &lt; bias + tmin, but that cannot happen because of the way bias is computed and because of the constraints on the parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TがTMAX、「+ TMIN」を介し範囲TMINにクランプされているTの割り当て、常に省略することができます。これは、バイアス&lt;K &lt;バイアス+ TMIN、それが原因で、バイアスが計算されている方法のため、およびパラメータの制約により起こることができないとき、クランプ計算が間違ってます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The checks for overflow are necessary to avoid producing invalid output when the input contains very large values or is very long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーフローをチェックし、入力が非常に大きな値が含まれているか、非常に長い場合、無効な出力を生成する避けるために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The increment of delta at the bottom of the outer loop cannot overflow because delta &lt; length(input) before the increment, and length(input) is already assumed to be representable. The increment of n could overflow, but only if h == length(input), in which case the procedure is finished anyway.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アウターループできないオーバーフローの底部のデルタの増分デルタ&lt;インクリメント前の長さ（入力）、および長さ（入力）が既に表現であると仮定されるからです。 Nの増加はオーバーフローだけ手順がとにかく終了した場合に時間==長（入力）、もし可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4 Overflow handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4オーバーフロー取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For IDNA, 26-bit unsigned integers are sufficient to handle all valid IDNA labels without overflow, because any string that needed a 27-bit delta would have to exceed either the code point limit (0..10FFFF) or the label length limit (63 characters). However, overflow handling is necessary because the inputs are not necessarily valid IDNA labels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
27ビットのデルタを必要な文字列がコードポイントリミット（0..10FFFF）またはラベルの長さ制限（いずれかを超過しなければならないのでIDNAのために、26ビットの符号なし整数は、オーバーフローなしですべての有効IDNAラベルを処理するのに十分です63文字）。入力が必ずしも有効なIDNAラベルではありませんので、しかし、オーバーフロー処理が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the programming language does not provide overflow detection, the following technique can be used. Suppose A, B, and C are representable nonnegative integers and C is nonzero. Then A + B overflows if and only if B &gt; maxint - A, and A + (B * C) overflows if and only if B &gt; (maxint - A) div C, where maxint is the greatest integer for which maxint + 1 cannot be represented. Refer to appendix C &#34;Punycode sample implementation&#34; for demonstrations of this technique in the C language.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プログラミング言語は、オーバーフロー検出を提供していない場合は、以下の技術を使用することができます。 A、B、およびCを仮定する表現非負整数であり、Cは非ゼロです。 MAXINTがMAXINT + 1ができないための最大の整数であるDIV C、 - （A MAXINT）&gt;場合にのみB場合A、及びA +（のB * C）オーバーフロー - 次いで、A + Bは、B&gt; MAXINTは場合にのみオーバフロー表現すること。 C言語でこの技術のデモンストレーションのためのC「ピュニコードのサンプル実装を」付録を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoding and encoding algorithms shown in sections 6.2 and 6.3 handle overflow by detecting it whenever it happens. Another approach is to enforce limits on the inputs that prevent overflow from happening. For example, if the encoder were to verify that no input code points exceed M and that the input length does not exceed L, then no delta could ever exceed (M - initial_n) * (L + 1), and hence no overflow could occur if integer variables were capable of representing values that large. This prevention approach would impose more restrictions on the input than the detection approach does, but might be considered simpler in some programming languages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが起こるたびに、それを検出することによって、セクション6.2および6.3ハンドルオーバーフローに示す復号および符号化アルゴリズム。別のアプローチは、起こってからのオーバーフローを防止入力に制限を強制することです。エンコーダはない入力コードポイントがMを超えていないことと、入力の長さがLを超えていないことを確認した場合、例えば、次に何デルタはこれまで（M  -  initial_n）を超えることができなかった*（L + 1）、従ってオーバーフローが発生することができませんでした整数変数が大きな値を示すことができた場合。この予防的なアプローチは、検出アプローチよりも入力に多くの制限を課すだろうが、いくつかのプログラミング言語でシンプルな考えられるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In theory, the decoder could use an analogous approach, limiting the number of digits in a variable-length integer (that is, limiting the number of iterations in the innermost loop). However, the number of digits that suffice to represent a given delta can sometimes represent much larger deltas (because of the adaptation), and hence this approach would probably need integers wider than 32 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理論的には、デコーダは、（最も内側のループ内で反復の数を制限する、つまり）可変長整数の桁数を制限し、類似のアプローチを使用することができます。しかし、所与のデルタを表すのに十分で桁数が時々（なぜなら適応の）はるかに大きなデルタを表すことができ、従ってこのアプローチは、おそらく32ビットより広い整数を必要とするであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yet another approach for the decoder is to allow overflow to occur, but to check the final output string by re-encoding it and comparing to the decoder input. If and only if they do not match (using a case-insensitive ASCII comparison) overflow has occurred. This delayed-detection approach would not impose any more restrictions on the input than the immediate-detection approach does, and might be considered simpler in some programming languages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まだデコーダのための別のアプローチは、オーバーフローが発生し、それを再エンコードし、デコーダ入力と比較することによって、最終的な出力文字列をチェックできるようにすることです。彼らは（大文字と小文字を区別しないASCII比較を使用して）一致しない場合にのみ場合は、オーバーフローが発生しました。この遅延検出アプローチは、即時検出アプローチはよりも、入力上の任意のより多くの制限を課すことはない、といくつかのプログラミング言語で単純な考えられるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In fact, if the decoder is used only inside the IDNA ToUnicode operation [IDNA], then it need not check for overflow at all, because ToUnicode performs a higher level re-encoding and comparison, and a mismatch has the same consequence as if the Punycode decoder had failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際には、デコーダは、のToUnicodeは、より高いレベルの再エンコードおよび比較を行うため、それは、全くオーバーフローをチェックする必要がないだけIDNAのToUnicode動作[IDNA]内で使用、および不整合があれば同じ結果を有している場合ピュニコードデコーダは失敗していました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Punycode examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.ピュニコード例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 Sample strings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1サンプルの文字列
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the Punycode encodings below, the ACE prefix is not shown. Backslashes show where line breaks have been inserted in strings too long for one line.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下ピュニコードエンコーディングでは、ACEプレフィックスは表示されません。バックスラッシュは、改行が1行にはあまりにも長い文字列に挿入されている場所を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first several examples are all translations of the sentence &#34;Why can&#39;t they just speak in &lt;language&gt;?&#34; (courtesy of Michael Kaplan&#39;s &#34;provincial&#34; page [PROVINCIAL]). Word breaks and punctuation have been removed, as is often done in domain names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のいくつかの例には、文のすべての翻訳は「なぜ彼らはただ、&lt;言語&gt;で話すことができないのですか？」 （マイケル・カプランの「地方」ページ[地方]の礼儀）。多くの場合、ドメイン名において行われるように単語の切れ目や句読点は、削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(A) Arabic (Egyptian): u+0644 u+064A u+0647 u+0645 u+0627 u+0628 u+062A u+0643 u+0644 u+0645 u+0648 u+0634 u+0639 u+0631 u+0628 u+064A u+061F Punycode: egbpdaj6bu4bxfgehfvwxn
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（A）アラビア語（エジプト）：U + 0644に+ 064A + 0647に+ 0645に+ 0627に+ 0628への+ 062A + 0643に+ 0644に+ 0645に+ 0648に+ 0634に+ 0639に+ 0631へ0628で+ + + 061Fピュニコードに064Aで：egbpdaj6bu4bxfgehfvwxn
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(B) Chinese (simplified): u+4ED6 u+4EEC u+4E3A u+4EC0 u+4E48 u+4E0D u+8BF4 u+4E2D u+6587 Punycode: ihqwcrb4cv8a8dqg056pqjye
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（B）中国語（簡体字）：U + 4ED6 U + 4EEC U + 4E3A U + 4EC0 U + 4E48 U + 4E0D U + 8BF4 U + 4E2D U + 6587ピュニコード：ihqwcrb4cv8a8dqg056pqjye
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(C) Chinese (traditional): u+4ED6 u+5011 u+7232 u+4EC0 u+9EBD u+4E0D u+8AAA u+4E2D u+6587 Punycode: ihqwctvzc91f659drss3x8bo0yb
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8AAA +のU + Uで4EC0 + + + 4E0D 9EBDで7232へ（C）+ + + 5011 4ED6で中国語（繁体字）+ 4E2D 6587ピュニコード：ihqwctvzc91f659drss3x8bo0yb
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(D) Czech: Pro&lt;ccaron&gt;prost&lt;ecaron&gt;nemluv&lt;iacute&gt;&lt;ccaron&gt;esky U+0050 u+0072 u+006F u+010D u+0070 u+0072 u+006F u+0073 u+0074 u+011B u+006E u+0065 u+006D u+006C u+0075 u+0076 u+00ED u+010D u+0065 u+0073 u+006B u+0079 Punycode: Proprostnemluvesky-uyb24dma41a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（D）チェコ語：プロ&lt;ccaron&gt;無料&lt;ecaron&gt;Nemluvím&lt;iacute&gt; &lt;ccaron&gt; ESKY U + 0050に+ 0072に+ 006Fまで+ 0074に+ 0073で+ 006Fまで+ 0072に+ 0070で+ 010Dに+ Proprostnemluvesky-uyb24dma41a：+ 006Cに+ + + 0065の006Eへ011Bはピュニコードに+ 0079 + 006Bに+ 0073に+ 0065で0075 + + + 0076 +に00ED 010Dに006Dします
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(E) Hebrew: u+05DC u+05DE u+05D4 u+05D4 u+05DD u+05E4 u+05E9 u+05D5 u+05D8 u+05DC u+05D0 u+05DE u+05D3 u+05D1 u+05E8 u+05D9 u+05DD u+05E2 u+05D1 u+05E8 u+05D9 u+05EA Punycode: 4dbcagdahymbxekheh6e0a7fei0b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（E）ヘブライ語iが+ 05D3 U + 05D1 U + 05E8で+ 05D0 U + 05DEにおける+ 05DCに+ 05D4 U + 05D4 U + 05DD U + 05E4 U + 05E9 U + 05D5 U + 05D8で+ 05DEで05DCを+ 4dbcagdahymbxekheh6e0a7fei0b：05EAピュニコードで+ + + 05D9で05E8に+ U + 05DD + 05D1 05E2で+ 05D9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(F) Hindi (Devanagari): u+092F u+0939 u+0932 u+094B u+0917 u+0939 u+093F u+0928 u+094D u+0926 u+0940 u+0915 u+094D u+092F u+094B u+0902 u+0928 u+0939 u+0940 u+0902 u+092C u+094B u+0932 u+0938 u+0915 u+0924 u+0947 u+0939 u+0948 u+0902 Punycode: i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（F）ヒンディー語（デバナーガリ）：uは+ 092F + 0939に+ 0932に+ 094Bへの+ 0917に+ 0939 + 093Fに+ 0928 + 0915に+ 0940に+ 0926 + 094D Uへの+ 094D + 092FへのU + + 0938に+ 0915に+ 0924に+ 0947に+ 0939に+ 0948に+ 0902ピュニコードに0902 +へ+ 0928に+ 0939に+ 0940に+ 0902に+ 092Cに+ 094Bと094B 0932 +へ： i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(G) Japanese (kanji and hiragana): u+306A u+305C u+307F u+3093 u+306A u+65E5 u+672C u+8A9E u+3092 u+8A71 u+3057 u+3066 u+304F u+308C u+306A u+3044 u+306E u+304B Punycode: n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
+ 8A71に+ 3057に+ 3066までで+ 304Fに+ 3092で+ 8A9Eに+の672Cで+ 3093に+ 306Aに+ 65E5の+ 305Cで（G）日本人（漢字とひらがな）、I + 306A 307F +に+ + 306E + 304Bピュニコード中に+ 3044で+ 306Aへの308C：n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(H) Korean (Hangul syllables): u+C138 u+ACC4 u+C758 u+BAA8 u+B4E0 u+C0AC u+B78C u+B4E4 u+C774 u+D55C u+AD6D u+C5B4 u+B97C u+C774 u+D574 u+D55C u+B2E4 u+BA74 u+C5BC u+B9C8 u+B098 u+C88B u+C744 u+AE4C Punycode: 989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j\ psd879ccm6fea98c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（H）、韓国語（ハングル音節）iは+ BAA8で+ C758 + B4E0 + C0AC + B78C + B4E4 + D55Cで+ C774 ACC4 +でC138を+ + + B97Cで+ C5B4 +をAD6D 989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5jの\のpsd879ccm6fea98c：B9C8で+ + B098 +ピュニコードで+ C744 + AE4CにC88B中で+ C5BCでBA74の+中+ B2E4でD55Cの+でC774 + D574
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(I) Russian (Cyrillic): U+043F u+043E u+0447 u+0435 u+043C u+0443 u+0436 u+0435 u+043E u+043D u+0438 u+043D u+0435 u+0433 u+043E u+0432 u+043E u+0440 u+044F u+0442 u+043F u+043E u+0440 u+0443 u+0441 u+0441 u+043A u+0438 Punycode: b1abfaaepdrnnbgefbaDotcwatmq2g4l
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（I）ロシア語（ラテン）：+ 043E U + 0447にU + 043F + 0435に+ 043Cに0443 +へ+ 0436に+ 0435に+ 043E U + 043D U + 0438に+ 043D U + 0435に+ 0433へ043Eに+ + + 0432 + 0440 043Eの内の044F + + + 0442 + 0440 + 0441 + 0443 + + + 043A 0438でピュニコードに0441に043Eに+ 043Fに：b1abfaaepdrnnbgefbaDotcwatmq2g4l
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(J) Spanish: Porqu&lt;eacute&gt;nopuedensimplementehablarenEspa&lt;ntilde&gt;ol U+0050 u+006F u+0072 u+0071 u+0075 u+00E9 u+006E u+006F u+0070 u+0075 u+0065 u+0064 u+0065 u+006E u+0073 u+0069 u+006D u+0070 u+006C u+0065 u+006D u+0065 u+006E u+0074 u+0065 u+0068 u+0061 u+0062 u+006C u+0061 u+0072 u+0065 u+006E U+0045 u+0073 u+0070 u+0061 u+00F1 u+006F u+006C Punycode: PorqunopuedensimplementehablarenEspaol-fmd56a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（J）スペイン語：porque &lt;eacute&gt; nopuedensimplementehablarenEspa &lt;Ntilde&gt;オール+ 0050に+ 00E9 Uに+ 0075 + 0071への+ 0072に+ 006F + 006Eに+ 006Fに+ 0070 + 0064 + 0065への+ 0075へU + 0065 + 006EへのU + 0073に+ 0069 + 006DにU + 0070 + 006Dに+ 006Cに+ 0065にU + 0065に+ 0062に+ 0061に+ 0068に+ 0065に+ 006E U + 0074に+で006C U + 006E + 0045 + 0070 + 0073への+ 006Cピュニコードで+ 006F + 00F1に+ 0061までで+ 0072 + 0065 + 0061：PorqunopuedensimplementehablarenEspaol-fmd56a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(K) Vietnamese: T&lt;adotbelow&gt;isaoh&lt;odotbelow&gt;kh&lt;ocirc&gt;ngth&lt;ecirchookabove&gt;ch\ &lt;ihookabove&gt;n&lt;oacute&gt;iti&lt;ecircacute&gt;ngVi&lt;ecircdotbelow&gt;t U+0054 u+1EA1 u+0069 u+0073 u+0061 u+006F u+0068 u+1ECD u+006B u+0068 u+00F4 u+006E u+0067 u+0074 u+0068 u+1EC3 u+0063 u+0068 u+1EC9 u+006E u+00F3 u+0069 u+0074 u+0069 u+1EBF u+006E u+0067 U+0056 u+0069 u+1EC7 u+0074 Punycode: TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（K）ベトナム：T &lt;adotbelow&gt; isaoh &lt;odotbelow&gt; KH &lt;ocirc&gt; ngth &lt;ecirchookabove&gt; CH \ &lt;ihookabove&gt; N &lt;oacute&gt;移動&lt;ecircacute&gt; ngVi &lt;ecircdotbelow&gt; T U + 0054に+ 1EA1に+ 0069に+ 0073に+ 0061に+ 006F + 006B + 1ECDに+ 0068への+ 0068 + 00F4へ006E +でuは+ 0067 + 0068に+ 1EC3に+ 0063に+ 0068に+ 0074に+ 1EC9 + 006Eの中に00F3 + 0074 + U + U + 0069 + 0069に1EBF 006E + + 0067におけるU + 0056に+ 0069にピュニコードに+ 0074 + 1EC7に：TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next several examples are all names of Japanese music artists, song titles, and TV programs, just because the author happens to have them handy (but Japanese is useful for providing examples of single-row text, two-row text, ideographic text, and various mixtures thereof).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のいくつかの例では、著者は彼らが手元にたまたま（しかし、日本人は単一行のテキスト、2行のテキスト、表意文字の例を提供するために有用であるという理由だけで、すべての日本の音楽アーティスト、曲のタイトル、およびテレビ番組の名前ですおよびそれらの種々の混合物）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(L) 3&lt;nen&gt;B&lt;gumi&gt;&lt;kinpachi&gt;&lt;sensei&gt; u+0033 u+5E74 U+0042 u+7D44 u+91D1 u+516B u+5148 u+751F Punycode: 3B-ww4c5e180e575a65lsy2b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（L）3 &lt;NEN&gt; B &lt;グミ&gt; &lt;kinpachi&gt; &lt;先生&gt; U + 0033 U + 5E74 U + 0042 U + 7D44 U + 91D1 U + 516B U + 5148 U + 751Fピュニコード：3B-ww4c5e180e575a65lsy2b
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(M) &lt;amuro&gt;&lt;namie&gt;-with-SUPER-MONKEYS u+5B89 u+5BA4 u+5948 u+7F8E u+6075 u+002D u+0077 u+0069 u+0074 u+0068 u+002D U+0053 U+0055 U+0050 U+0045 U+0052 u+002D U+004D U+004F U+004E U+004B U+0045 U+0059 U+0053 Punycode: -with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（M）&lt;アムロ&gt; &lt;奈美恵&gt; -with-SUPER-MONKEYS U + 5B89 U + 5BA4 U + 5948 U + 7F8E U + 6075 U + 002D U + 0077 U + 0069 U + 0074 U + 0068 U + 002D + U 0053 U + 0055 U + 0050 U + 0045 U + 0052 U + 002D U + 004D U + 004F U + 004E U + 004B U + 0045 U + 0059 U + 0053ピュニコード：-with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(N) Hello-Another-Way-&lt;sorezore&gt;&lt;no&gt;&lt;basho&gt; U+0048 u+0065 u+006C u+006C u+006F u+002D U+0041 u+006E u+006F u+0074 u+0068 u+0065 u+0072 u+002D U+0057 u+0061 u+0079 u+002D u+305D u+308C u+305E u+308C u+306E u+5834 u+6240 Punycode: Hello-Another-Way--fc4qua05auwb3674vfr0b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（N）ハロー-別-way- &lt;Sorezore&gt; &lt;なし&gt; &lt;芭蕉&gt; U + 0048 + 0065の+ 006Cの+ 006Cに+ 006F + U + 002D U + 0041に+ 006Fに0074 + +で006Eします0068 + 0065 + 0072 +へ002D U + 0057に+ 5834で+ 306Eに+の308Cにおける+ 305Eに+ 0061 + 0079 +へ002D U + 305Dに+で308Cに6240 +のピュニコードに：こんにちは、別の方法--fc4qua05auwb3674vfr0b
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(O) &lt;hitotsu&gt;&lt;yane&gt;&lt;no&gt;&lt;shita&gt;2 u+3072 u+3068 u+3064 u+5C4B u+6839 u+306E u+4E0B u+0032 Punycode: 2-u9tlzr9756bt3uc0v
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（O）&lt;ひとつ&gt; &lt;yane&gt; &lt;なし&gt; &lt;shita&gt; 2 U + 3072 U + 3068 U + 3064 U + 5C4B U + 6839 U + 306E U + 4E0B U + 0032ピュニコード：2- u9tlzr9756bt3uc0v
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(P) Maji&lt;de&gt;Koi&lt;suru&gt;5&lt;byou&gt;&lt;mae&gt; U+004D u+0061 u+006A u+0069 u+3067 U+004B u+006F u+0069 u+3059 u+308B u+0035 u+79D2 u+524D Punycode: MajiKoi5-783gue6qz075azm5e
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（P）マジ&lt;脱&gt;恋&lt;suru&gt; 5 &lt;ビョウ&gt; &lt;メイ&gt; U + 004D + 0061で+ 0069で+ 006Aに+ 3067 U + 004Bへの+ 006F + 0069でで+ 308Bに+ 3059に+ + 524Dピュニコードで0035 + 79D2：MajiKoi5-783gue6qz075azm5e
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Q) &lt;pafii&gt;de&lt;runba&gt; u+30D1 u+30D5 u+30A3 u+30FC u+0064 u+0065 u+30EB u+30F3 u+30D0 Punycode: de-jg4avhby1noc0d
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（Q）&lt;pafii&gt;ド&lt;runba&gt; U + 30D1 U + 30D5 U + 30A3、U + 30FC U + 0064 U + 0065 U + 30EB U + 30F3 U + 30D0ピュニコード：脱jg4avhby1noc0d
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(R) &lt;sono&gt;&lt;supiido&gt;&lt;de&gt; u+305D u+306E u+30B9 u+30D4 u+30FC u+30C9 u+3067 Punycode: d9juau41awczczp
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（R）&lt;ソノ&gt; &lt;supiido&gt; &lt;脱&gt; U + 305D U + 306E U + 30B9、U + 30D4 U + 30FC U + 30C9 U + 3067ピュニコード：d9juau41awczczp
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last example is an ASCII string that breaks the existing rules for host name labels. (It is not a realistic example for IDNA, because IDNA never encodes pure ASCII labels.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の例では、ホスト名のラベルのための既存のルールを破るASCII文字列です。 （IDNAは、純粋なASCIIラベルをエンコードすることはありませんので、IDNAのための現実的な例ではありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(S) -&gt; $1.00 &lt;- u+002D u+003E u+0020 u+0024 u+0031 u+002E u+0030 u+0030 u+0020 u+003C u+002D Punycode: -&gt; $1.00 &lt;--
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S） - &gt; $ 1.00 &lt; -  U + 002D U + 003Eで+ 0020ピュニコード002D +へ003C +に対して+ 0020に+ 0030に+ 0030で+ 002Eに+ 0031に+ 0024に： - &gt; $ 1.00 &lt; - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 Decoding traces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2デコード・トレース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following traces, the evolving state of the decoder is shown as a sequence of hexadecimal values, representing the code points in the extended string. An asterisk appears just after the most recently inserted code point, indicating both n (the value preceeding the asterisk) and i (the position of the value just after the asterisk). Other numerical values are decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のトレースでは、デコーダの進化状態は、拡張文字列内のコードポイントを表す16進値のシーケンスとして示されています。アスタリスクは、単に最も最近挿入されたコードポイントの後に表示され、両方のN（アスタリスクを先行値）を示すと、I（単にアスタリスク後の値の位置）。その他の数値は小数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding trace of example B from section 7.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1から例Bのトレースをデコード：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n is 128, i is 0, bias is 72 input is &#34;ihqwcrb4cv8a8dqg056pqjye&#34; there is no delimiter, so extended string starts empty delta &#34;ihq&#34; decodes to 19853 bias becomes 21 4E0D * delta &#34;wc&#34; decodes to 64 bias becomes 20 4E0D 4E2D * delta &#34;rb&#34; decodes to 37 bias becomes 13 4E3A * 4E0D 4E2D delta &#34;4c&#34; decodes to 56 bias becomes 17 4E3A 4E48 * 4E0D 4E2D delta &#34;v8a&#34; decodes to 599 bias becomes 32 4E3A 4EC0 * 4E48 4E0D 4E2D delta &#34;8d&#34; decodes to 130 bias becomes 23 4ED6 * 4E3A 4EC0 4E48 4E0D 4E2D delta &#34;qg&#34; decodes to 154 bias becomes 25 4ED6 4EEC * 4E3A 4EC0 4E48 4E0D 4E2D delta &#34;056p&#34; decodes to 46301 bias becomes 84 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 4E2D 6587 * delta &#34;qjye&#34; decodes to 88531 bias becomes 90 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 * 4E2D 6587
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nが128であり、iはバイアスが72入力され、0でない区切り文字が存在しない「ihqwcrb4cv8a8dqg056pqjye」は、そう拡張文字列が空のデルタを開始する19853にデコード「IHQ」バイアスは21 4E0D *デルタ「WC」と64件のバイアスにデコードが20 4E0D 4E2Dなりなります*デルタ &#34;RB&#34; は、37件のバイアスにデコード13 4E3A * 4E0D 4E2Dデルタ &#34;4cは&#34; 56のバイアス17 4E3A 4E48 * 4E0D 4E2Dデルタ &#34;v8aは&#34; 599件のバイアスに復号なる32 4E3A 4EC0 * 4E48 4E0D 4E2Dデルタなる &#34;8D&#34; に復号なります130のバイアスをデコードなる23 4ED6 * 154のバイアス46301のバイアスが6587 84 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 4E2Dとなり、25 4ED6 4EEC * 4E3A 4EC0 4E48 4E0D 4E2Dデルタ &#34;056p&#34; は復号なるに4E3A 4EC0 4E48 4E0D 4E2Dデルタ &#34;QG&#34; がデコード*デルタ &#34;qjyeは&#34; 88531のバイアスにデコード90 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 * 4E2D 6587となり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding trace of example L from section 7.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1から例Lのトレースをデコード：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n is 128, i is 0, bias is 72 input is &#34;3B-ww4c5e180e575a65lsy2b&#34; literal portion is &#34;3B-&#34;, so extended string starts as: 0033 0042 delta &#34;ww4c&#34; decodes to 62042 bias becomes 27 0033 0042 5148 * delta &#34;5e&#34; decodes to 139 bias becomes 24 0033 0042 516B * 5148 delta &#34;180e&#34; decodes to 16683 bias becomes 67 0033 5E74 * 0042 516B 5148 delta &#34;575a&#34; decodes to 34821 bias becomes 82 0033 5E74 0042 516B 5148 751F * delta &#34;65l&#34; decodes to 14592 bias becomes 67 0033 5E74 0042 7D44 * 516B 5148 751F delta &#34;sy2b&#34; decodes to 42088 bias becomes 84 0033 5E74 0042 7D44 91D1 * 516B 5148 751F
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N iは0である、128で、バイアスは、72入力が「3B-ww4c5e180e575a65lsy2b」はリテラル部分「3B-」であるので、拡張文字列として開始：0033 0042デルタ「ww4cは」62042のバイアスにデコード「デルタ* 27 0033 0042 5148となります図5Eは、」139のバイアスにデコード24 0033 0042 516B * 5148デルタが &#34;65リットル &#34;575A &#34;34821のバイアス82 0033 5E74 0042 516B 5148 751F *デルタなるに復号&#34; 180E&#34; は16683のバイアス67 0033 5E74 * 0042 516B 5148デルタなるにデコード&#34; 14592のバイアスが84 0033 5E74 0042 7D44 91D1 * 516B 5148 751Fとなり67 0033 5E74 0042 7D44 * 516B 5148 751Fデルタ &#34;sy2bは&#34; 42088のバイアスにデコードなりにデコードします
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3 Encoding traces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3エンコーディングトレース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following traces, code point values are hexadecimal, while other numerical values are decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の数値は、小数点であるときには、次のトレースでは、コードポイント値が16進数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding trace of example B from section 7.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1から例Bのトレースをコードします：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bias is 72 input is: 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 4E2D 6587 there are no basic code points, so no literal portion next code point to insert is 4E0D needed delta is 19853, encodes as &#34;ihq&#34; bias becomes 21 next code point to insert is 4E2D needed delta is 64, encodes as &#34;wc&#34; bias becomes 20 next code point to insert is 4E3A needed delta is 37, encodes as &#34;rb&#34; bias becomes 13 next code point to insert is 4E48 needed delta is 56, encodes as &#34;4c&#34; bias becomes 17 next code point to insert is 4EC0 needed delta is 599, encodes as &#34;v8a&#34; bias becomes 32 next code point to insert is 4ED6 needed delta is 130, encodes as &#34;8d&#34; bias becomes 23 next code point to insert is 4EEC needed delta is 154, encodes as &#34;qg&#34; bias becomes 25 next code point to insert is 6587 needed delta is 46301, encodes as &#34;056p&#34; bias becomes 84 next code point to insert is 8BF4 needed delta is 88531, encodes as &#34;qjye&#34; bias becomes 90 output is &#34;ihqwcrb4cv8a8dqg056pqjye&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイアス72が入力されている：4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 4E2D 6587ない基本的なコードポイント、そうないリテラル部次のコード・ポイントが存在しない挿入する4E0Dデルタを必要とされ19853で、「IHQ」バイアスに21次のコードポイントとなるように符号化しますインサートは、4E2Dデルタが64である必要は「WC」バイアスを挿入するために20次のコードポイントとなるようにコード4E3Aデルタを必要とされ、37である「RB」バイアス挿入する13次のコードポイントとなるようにコード4E48デルタを必要とされ、56のように符号化します「v8a」バイアス挿入する32次のコードポイントとなるように、「4C」バイアスを挿入するために17次のコードポイントとなる4EC0デルタが599で必要とされるが、コード4ED6は「8D」バイアスは23次のコードポイントとなるように符号化し、デルタは130であり、必要とされますインサートは、4EECデルタが154である必要で挿入する「QG」バイアスが25となる次のコード・ポイントとしてコード6587はデルタ46301で必要とされる、「056p」バイアスを挿入するために84次のコードポイントとなるようにコード8BF4として符号化し、デルタは88531であり、必要とされます「qjye」はバイアス90の出力が「ihqwcrb4cv8a8dqg056pqjye」でなります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding trace of example L from section 7.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1から例Lのトレースをコードします：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bias is 72 input is: 0033 5E74 0042 7D44 91D1 516B 5148 751F basic code points (0033, 0042) are copied to literal portion: &#34;3B-&#34; next code point to insert is 5148 needed delta is 62042, encodes as &#34;ww4c&#34; bias becomes 27 next code point to insert is 516B needed delta is 139, encodes as &#34;5e&#34; bias becomes 24 next code point to insert is 5E74 needed delta is 16683, encodes as &#34;180e&#34; bias becomes 67 next code point to insert is 751F needed delta is 34821, encodes as &#34;575a&#34; bias becomes 82 next code point to insert is 7D44 needed delta is 14592, encodes as &#34;65l&#34; bias becomes 67 next code point to insert is 91D1 needed delta is 42088, encodes as &#34;sy2b&#34; bias becomes 84 output is &#34;3B-ww4c5e180e575a65lsy2b&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイアスは、72入力される：0033 5E74 0042 7D44 91D1 516B 5148個の751F基本コード・ポイント（0042 0033）リテラル部分にコピーされる：、挿入する「3B-」次のコードポイント5148は、デルタが62042である必要が「ww4c」バイアスとして符号化します挿入する27次のコード・ポイントになり516Bは、デルタを必要とされ、139で「5E」バイアス挿入する24次のコードポイントとなるようにコード5E74は751Fが必要とされる「180E」バイアス挿入する67次のコードポイントとなるように符号化し、デルタは16683であり、必要とされますデルタは、34821である「575A」バイアスを挿入するために82次のコードポイントとなるようにコード7D44デルタを必要とされ、14592であり、「65リットル」バイアス挿入する67次のコードポイントとなるようにコード91D1はデルタ42088で必要とされる、「sy2b」バイアスとして符号化しますとなり84の出力は、 &#34;3B-ww4c5e180e575a65lsy2b&#34; であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Users expect each domain name in DNS to be controlled by a single authority. If a Unicode string intended for use as a domain label could map to multiple ACE labels, then an internationalized domain name could map to multiple ASCII domain names, each controlled by a different authority, some of which could be spoofs that hijack service requests intended for another. Therefore Punycode is designed so that each Unicode string has a unique encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーがDNS内の各ドメイン名は、単一の権限によって制御されることを期待しています。ドメインラベルとして使用することを意図したUnicode文字列は、複数のACEラベルにマッピングすることができれば、その後、国際化ドメイン名は、それぞれそのうちのいくつかは、のために意図したサービス要求を乗っ取るなりすまし可能性があり、異なる権限によって制御、複数のASCIIドメイン名にマップすることができ別の。各Unicode文字列は、固有の符号化を有するようしたがってピュニコードに設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, there can still be multiple Unicode representations of the &#34;same&#34; text, for various definitions of &#34;same&#34;. This problem is addressed to some extent by the Unicode standard under the topic of canonicalization, and this work is leveraged for domain names by Nameprep [NAMEPREP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、それでも「同じ」の様々な定義については、「同じ」テキストの複数のUnicode表現が存在し得ます。この問題は、正規のトピックの下Unicode標準である程度対処され、そしてこの作品は[NAMEPREP] NAMEPREPによるドメイン名のために活用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1 Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2 Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC952] Harrenstien, K., Stahl, M. and E. Feinler, &#34;DOD Internet Host Table Specification&#34;, RFC 952, October 1985.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC952] Harrenstien、K.、スタール、M.およびE. Feinler、 &#34;DODインターネットホストテーブル仕様&#34;、RFC 952、1985年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris, P., &#34;Domain Names - Concepts and Facilities&#34;, STD 13, RFC 1034, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris、P.、 &#34;ドメイン名 - 概念および機能&#34;、STD 13、RFC 1034、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDNA] Faltstrom, P., Hoffman, P. and A. Costello, &#34;Internationalizing Domain Names in Applications (IDNA)&#34;, RFC 3490, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDNA] Faltstrom、P.、ホフマン、P.およびA.コステロ、 &#34;アプリケーションにおける国際化ドメイン名（IDNA）&#34;、RFC 3490、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NAMEPREP] Hoffman, P. and M. Blanchet, &#34;Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)&#34;, RFC 3491, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NAMEPREP]ホフマン、P.とM.ブランシェ、 &#34;NAMEPREP：国際化ドメイン名のためのstringprepプロフィール（IDN）&#34;、RFC 3491、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASCII] Cerf, V., &#34;ASCII format for Network Interchange&#34;, RFC 20, October 1969.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASCII]サーフ、V.、 &#34;ネットワークの交換のためのASCIIフォーマット&#34;、RFC 20、1969年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PROVINCIAL] Kaplan, M., &#34;The &#39;anyone can be provincial!&#39; page&#34;, http://www.trigeminal.com/samples/provincial.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[地方]カプラン、M.、「『誰でも地方のことができます！』ページ」、http://www.trigeminal.com/samples/provincial.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE] The Unicode Consortium, &#34;The Unicode Standard&#34;, http://www.unicode.org/unicode/standard/standard.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE]ユニコードコンソーシアム、 &#34;Unicode規格&#34;、http://www.unicode.org/unicode/standard/standard.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A. Mixed-case annotation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.混在ケース注釈
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to use Punycode to represent case-insensitive strings, higher layers need to case-fold the strings prior to Punycode encoding. The encoded string can use mixed case as an annotation telling how to convert the folded string into a mixed-case string for display purposes. Note, however, that mixed-case annotation is not used by the ToASCII and ToUnicode operations specified in [IDNA], and therefore implementors of IDNA can disregard this appendix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大文字と小文字を区別しない文字列を表すのにピュニコードを使用するために、上位層はピュニコードエンコーディングの前の文字列を大文字倍にする必要があります。エンコードされた文字列は、表示目的のために混在ケース列に折り畳まれた文字列を変換する方法を伝える注釈として混在ケースを使用することができます。混在ケース注釈は[IDNA]で指定もしToASCIIとのToUnicode操作で使用されていないこと、しかし、注意、したがってIDNAを実装は、この付録を無視することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Basic code points can use mixed case directly, because the decoder copies them verbatim, leaving lowercase code points lowercase, and leaving uppercase code points uppercase. Each non-basic code point is represented by a delta, which is represented by a sequence of basic code points, the last of which provides the annotation. If it is uppercase, it is a suggestion to map the non-basic code point to uppercase (if possible); if it is lowercase, it is a suggestion to map the non-basic code point to lowercase (if possible).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的なコードポイントは小文字小文字コードポイントを残し、そして大文字大文字のコードポイントを残し、それらをそのままデコーダコピーので、直接混合ケースを使用することができます。各非基本コードポイントは、アノテーションを提供最後にその基本的なコードポイントの配列で表されるデルタ、で表されます。それが大文字である場合、（可能な場合）大文字に非基本コードポイントをマッピングするための提案です。それは小文字である場合には（可能な場合）、小文字に非基本コードポイントをマップするための提案です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These annotations do not alter the code points returned by decoders; the annotations are returned separately, for the caller to use or ignore. Encoders can accept annotations in addition to code points, but the annotations do not alter the output, except to influence the uppercase/lowercase form of ASCII letters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのアノテーションは、デコーダによって返されるコードポイントを変更しません。注釈を使用するか、無視する、発信者のために、個別に返されます。エンコーダは、コード・ポイントに加えて、注釈を受け入れることができますが、ASCII文字の大文字/小文字のフォームに影響を与えるため以外のアノテーションは、出力を変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Punycode encoders and decoders need not support these annotations, and higher layers need not use them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピュニコードエンコーダおよびデコーダは、これらのアノテーションをサポートする必要はありませんし、上位層は、それらを使用する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B. Disclaimer and license
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.免責事項およびライセンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regarding this entire document or any portion of it (including the pseudocode and C code), the author makes no guarantees and is not responsible for any damage resulting from its use. The author grants irrevocable permission to anyone to use, modify, and distribute it in any way that does not diminish the rights of anyone else to use, modify, and distribute it, provided that redistributed derivative works do not contain misleading author or version information. Derivative works need not be licensed under similar terms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書全体または（擬似コードとCコードを含む）、それのいずれかの部分について、著者は保証を行わず、その使用に起因する損害の原因ではありません。派生作品を再配布提供し、それを使用、変更、および、使用変更する他の誰の権利を損なわない任意の方法でそれを配布し、配布するための誰にも著者の補助金取消不能の許可は、著作者またはバージョンの情報が誤解を招く含まれていません。派生作品は、同様の条件の下でライセンスされる必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
C. Punycode sample implementation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
C.ピュニコードのサンプル実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
punycode.c from RFC 3492
http://www.nicemice.net/idn/
Adam M. Costello
http://www.nicemice.net/amc/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
This is ANSI C code (C89) implementing Punycode (RFC 3492).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
これはピュニコード（RFC 3492）を実装ANSI Cコード（C89）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
*/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
＊／
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/************************************************************/
/* Public interface (would normally go in its own .h file): */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#include &lt;limits.h&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
書式#include &lt;limits.hに&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
enum punycode_status {
  punycode_success,
  punycode_bad_input,   /* Input is invalid.                       */
  punycode_big_output,  /* Output would exceed the space provided. */
  punycode_overflow     /* Input needs wider integers to process.  */
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#if UINT_MAX &gt;= (1 &lt;&lt; 26) - 1
typedef unsigned int punycode_uint;
#else
typedef unsigned long punycode_uint;
#endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_encode( punycode_uint input_length, const punycode_uint input[], const unsigned char case_flags[], punycode_uint *output_length, char output[] );
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
列挙punycode_status punycode_encode（punycode_uintのinput_length、CONST punycode_uint入力[]、CONST unsigned char型のcase_flags []、punycode_uint * OUTPUT_LENGTH、CHAR出力[]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* punycode_encode() converts Unicode to Punycode.  The input     */
    /* is represented as an array of Unicode code points (not code    */
    /* units; surrogate pairs are not allowed), and the output        */
    /* will be represented as an array of ASCII code points.  The     */
    /* output string is *not* null-terminated; it will contain        */
    /* zeros if and only if the input contains zeros.  (Of course     */
    /* the caller can leave room for a terminator and add one if      */
    /* needed.)  The input_length is the number of code points in     */
    /* the input.  The output_length is an in/out argument: the       */
    /* caller passes in the maximum number of code points that it     */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* can receive, and on successful return it will contain the      */
    /* number of code points actually output.  The case_flags array   */
    /* holds input_length boolean values, where nonzero suggests that */
    /* the corresponding Unicode character be forced to uppercase     */
    /* after being decoded (if possible), and zero suggests that      */
    /* it be forced to lowercase (if possible).  ASCII code points    */
    /* are encoded literally, except that ASCII letters are forced    */
    /* to uppercase or lowercase according to the corresponding       */
    /* uppercase flags.  If case_flags is a null pointer then ASCII   */
    /* letters are left as they are, and other code points are        */
    /* treated as if their uppercase flags were zero.  The return     */
    /* value can be any of the punycode_status values defined above   */
    /* except punycode_bad_input; if not punycode_success, then       */
    /* output_size and output might contain garbage.                  */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_decode( punycode_uint input_length, const char input[], punycode_uint *output_length, punycode_uint output[], unsigned char case_flags[] );
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
列挙punycode_status punycode_decode（punycode_uintのinput_length、CONST文字入力[]、punycode_uint * OUTPUT_LENGTH、punycode_uint出力は[]、unsigned char型のcase_flags []）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* punycode_decode() converts Punycode to Unicode.  The input is  */
    /* represented as an array of ASCII code points, and the output   */
    /* will be represented as an array of Unicode code points.  The   */
    /* input_length is the number of code points in the input.  The   */
    /* output_length is an in/out argument: the caller passes in      */
    /* the maximum number of code points that it can receive, and     */
    /* on successful return it will contain the actual number of      */
    /* code points output.  The case_flags array needs room for at    */
    /* least output_length values, or it can be a null pointer if the */
    /* case information is not needed.  A nonzero flag suggests that  */
    /* the corresponding Unicode character be forced to uppercase     */
    /* by the caller (if possible), while zero suggests that it be    */
    /* forced to lowercase (if possible).  ASCII code points are      */
    /* output already in the proper case, but their flags will be set */
    /* appropriately so that applying the flags would be harmless.    */
    /* The return value can be any of the punycode_status values      */
    /* defined above; if not punycode_success, then output_length,    */
    /* output, and case_flags might contain garbage.  On success, the */
    /* decoder will never need to write an output_length greater than */
    /* input_length, because of how the encoding is defined.          */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**********************************************************/
/* Implementation (would normally go in its own .c file): */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#include &lt;string.h&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
書式#include &lt;string.hの&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Bootstring parameters for Punycode ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
enum { base = 36, tmin = 1, tmax = 26, skew = 38, damp = 700,
       initial_bias = 72, initial_n = 0x80, delimiter = 0x2D };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* basic(cp) tests whether cp is a basic code point: */
#define basic(cp) ((punycode_uint)(cp) &lt; 0x80)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* delim(cp) tests whether cp is a delimiter: */
#define delim(cp) ((cp) == delimiter)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* decode_digit(cp) returns the numeric value of a basic code */
/* point (for use in representing integers) in the range 0 to */
/* base-1, or base if cp is does not represent a value.       */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static punycode_uint decode_digit(punycode_uint cp) { return cp - 48 &lt; 10 ? cp - 22 : cp - 65 &lt; 26 ? cp - 65 : cp - 97 &lt; 26 ? cp - 97 : base; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
静的punycode_uintのdecode_digit（punycode_uintのCP）{戻りCP  -  48 &lt;10？ CP  -  65 &lt;26：22  -  CP？ CP  -  97 &lt;26：65  -  CP？ CP  -  97：ベース; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* encode_digit(d,flag) returns the basic code point whose value      */
/* (when used for representing integers) is d, which needs to be in   */
/* the range 0 to base-1.  The lowercase form is used unless flag is  */
/* nonzero, in which case the uppercase form is used.  The behavior   */
/* is undefined if flag is nonzero and digit d has no uppercase form. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static char encode_digit(punycode_uint d, int flag)
{
  return d + 22 + 75 * (d &lt; 26) - ((flag != 0) &lt;&lt; 5);
  /*  0..25 map to ASCII a..z or A..Z */
  /* 26..35 map to ASCII 0..9         */
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* flagged(bcp) tests whether a basic code point is flagged */
/* (uppercase).  The behavior is undefined if bcp is not a  */
/* basic code point.                                        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define flagged(bcp) ((punycode_uint)(bcp) - 65 &lt; 26)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#defineは、フラグが立てられ（BCP）（（punycode_uint）（BCP） -  65 &lt;26）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* encode_basic(bcp,flag) forces a basic code point to lowercase */
/* if flag is zero, uppercase if flag is nonzero, and returns    */
/* the resulting code point.  The code point is unchanged if it  */
/* is caseless.  The behavior is undefined if bcp is not a basic */
/* code point.                                                   */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static char encode_basic(punycode_uint bcp, int flag) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
静的チャーencode_basic（punycode_uintのBCP、INTフラグ）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  bcp -= (bcp - 97 &lt; 26) &lt;&lt; 5;
  return bcp + ((!flag &amp;&amp; (bcp - 65 &lt; 26)) &lt;&lt; 5);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Platform-specific constants ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* maxint is the maximum value of a punycode_uint variable: */
static const punycode_uint maxint = -1;
/* Because maxint is unsigned, -1 becomes the maximum value. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Bias adaptation function ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static punycode_uint adapt( punycode_uint delta, punycode_uint numpoints, int firsttime ) { punycode_uint k;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
静的punycode_uint（punycode_uintデルタ、punycode_uint numpoints、INT FIRSTTIME）{punycode_uint kを適応させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  delta = firsttime ? delta / damp : delta &gt;&gt; 1;
  /* delta &gt;&gt; 1 is a faster way of doing delta / 2 */
  delta += delta / numpoints;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
for (k = 0; delta &gt; ((base - tmin) * tmax) / 2; k += base) { delta /= base - tmin; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
（;  -  TMIN）* TMAX）/ 2デルタ&gt;（（ベース; K + =ベースK = 0）{デルタ/ =ベース -  TMINため、 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 return k + (base - tmin + 1) * delta / (delta + skew); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
戻りK +（ベース -  TMIN + 1）*デルタ/（デルタ+スキュー）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Main encode function ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_encode( punycode_uint input_length, const punycode_uint input[], const unsigned char case_flags[], punycode_uint *output_length, char output[] ) { punycode_uint n, delta, h, b, out, max_out, bias, j, m, q, k, t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
列挙punycode_status punycode_encode（punycode_uintのinput_length、CONST punycode_uint入力[]、CONST unsigned char型のcase_flags []、punycode_uint * OUTPUT_LENGTH、チャー出力は[]）{punycode_uint N、デルタ、H、B、アウト、max_out、バイアス、J、M、Q 、K、T。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Initialize the state: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  n = initial_n;
  delta = out = 0;
  max_out = *output_length;
  bias = initial_bias;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Handle the basic code points: */ for (j = 0;  j &lt; input_length;  ++j) {
    if (basic(input[j])) {
      if (max_out - out &lt; 2) return punycode_big_output;
      output[out++] =
        case_flags ?  encode_basic(input[j], case_flags[j]) : input[j];
    }
    /* else if (input[j] &lt; n) return punycode_bad_input; */
    /* (not needed for Punycode with unsigned code points) */
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
h = b = out;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
H = B =うち。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* h is the number of code points that have been handled, b is the  */
  /* number of basic code points, and out is the number of characters */
  /* that have been output.                                           */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
if (b &gt; 0) output[out++] = delimiter;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
IF（B&gt; 0）出力[OUT ++] =デリミタ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Main encoding loop: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  while (h &lt; input_length) {
    /* All non-basic code points &lt; n have been     */
    /* handled already.  Find the next larger one: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (m = maxint, j = 0;  j &lt; input_length;  ++j) {
      /* if (basic(input[j])) continue; */
      /* (not needed for Punycode) */
      if (input[j] &gt;= n &amp;&amp; input[j] &lt; m) m = input[j];
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Increase delta enough to advance the decoder&#39;s    */
    /* &lt;n,i&gt; state to &lt;m,0&gt;, but guard against overflow: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (m - n &gt; (maxint - delta) / (h + 1)) return punycode_overflow;
    delta += (m - n) * (h + 1);
    n = m;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (j = 0;  j &lt; input_length;  ++j) {
      /* Punycode does not need to check whether input[j] is basic: */
      if (input[j] &lt; n /* || basic(input[j]) */ ) {
        if (++delta == 0) return punycode_overflow;
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (input[j] == n) {
        /* Represent delta as a generalized variable-length integer: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
for (q = delta, k = base; ; k += base) { if (out &gt;= max_out) return punycode_big_output;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
{IF（&gt; = max_out OUT）戻りpunycode_big_output;（; K + =ベースQ =デルタ、K =ベース）のために、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          t = k &lt;= bias /* + tmin */ ? tmin :     /* +tmin not needed */
              k &gt;= bias + tmax ? tmax : k - bias;
          if (q &lt; t) break;
          output[out++] = encode_digit(t + (q - t) % (base - t), 0);
          q = (q - t) / (base - t);
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        output[out++] = encode_digit(q, case_flags &amp;&amp; case_flags[j]);
        bias = adapt(delta, h + 1, h == b);
        delta = 0;
        ++h;
      }
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
 ++delta, ++n; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
デルタ++、++ nは、 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  *output_length = out;
  return punycode_success;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*** Main decode function ***/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
enum punycode_status punycode_decode( punycode_uint input_length, const char input[], punycode_uint *output_length, punycode_uint output[], unsigned char case_flags[] ) { punycode_uint n, out, i, max_out, bias, b, j, in, oldi, w, k, digit, t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
列挙punycode_status punycode_decode（punycode_uintのinput_length、CONST文字入力[]、punycode_uint * OUTPUT_LENGTH、punycode_uint出力[]、unsigned char型のcase_flags []）{punycode_uintのN、アウト、I、max_out、バイアス、B、J、で、oldi、W、 K、数字、T。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Initialize the state: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  n = initial_n;
  out = i = 0;
  max_out = *output_length;
  bias = initial_bias;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Handle the basic code points:  Let b be the number of input code */
  /* points before the last delimiter, or 0 if there is none, then    */
  /* copy the first b code points to the output.                      */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (b = j = 0;  j &lt; input_length;  ++j) if (delim(input[j])) b = j;
  if (b &gt; max_out) return punycode_big_output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
for (j = 0; j &lt; b; ++j) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
{（; J &lt;B ++ J、J = 0）のための
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (case_flags) case_flags[out] = flagged(input[j]);
    if (!basic(input[j])) return punycode_bad_input;
    output[out++] = input[j];
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Main decoding loop:  Start just after the last delimiter if any  */
  /* basic code points were copied; start at the beginning otherwise. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
for (in = b &gt; 0 ? b + 1 : 0; in &lt; input_length; ++out) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
用（IN = B&gt; 0、B + 1：0; &lt;input_lengthに、アウト++）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* in is the index of the next character to be consumed, and */
    /* out is the number of code points in the output array.     */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Decode a generalized variable-length integer into delta,  */
    /* which gets added to i.  The overflow checking is easier   */
    /* if we increase i as we go, then subtract off its starting */
    /* value at the end to obtain delta.                         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (oldi = i, w = 1, k = base;  ;  k += base) {
      if (in &gt;= input_length) return punycode_bad_input;
      digit = decode_digit(input[in++]);
      if (digit &gt;= base) return punycode_bad_input;
      if (digit &gt; (maxint - i) / w) return punycode_overflow;
      i += digit * w;
      t = k &lt;= bias /* + tmin */ ? tmin :     /* +tmin not needed */
          k &gt;= bias + tmax ? tmax : k - bias;
      if (digit &lt; t) break;
      if (w &gt; maxint / (base - t)) return punycode_overflow;
      w *= (base - t);
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
bias = adapt(i - oldi, out + 1, oldi == 0);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
（バイアス= I + 1 == 0を取り出した適応）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* i was supposed to wrap around from out+1 to 0,   */
    /* incrementing n each time, so we&#39;ll fix that now: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (i / (out + 1) &gt; maxint - n) return punycode_overflow;
    n += i / (out + 1);
    i %= (out + 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Insert n at position i of the output: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* not needed for Punycode: */
    /* if (decode_digit(n) &lt;= base) return punycode_invalid_input; */
    if (out &gt;= max_out) return punycode_big_output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
if (case_flags) { memmove(case_flags + i + 1, case_flags + i, out - i);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
IF（case_flags）{MEMMOVE（case_flags + I + 1、case_flags OUT + I  -  I）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Case of last character determines uppercase flag: */
      case_flags[i] = flagged(input[in - 1]);
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    memmove(output + i + 1, output + i, (out - i) * sizeof *output);
    output[i++] = n;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  *output_length = out;
  return punycode_success;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/******************************************************************/
/* Wrapper for testing (would normally go in a separate .c file): */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#include &lt;assert.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#include &lt;assert.h&gt;の#include &lt;stdio.hに&gt;する#include &lt;stdlib.h&gt;に含ま書式#include &lt;string.hの&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* For testing, we&#39;ll just set some compile-time limits rather than */
/* use malloc(), and set a compile-time option rather than using a  */
/* command-line option.                                             */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
enum {
  unicode_max_length = 256,
  ace_max_length = 256
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static void usage(char **argv)
{
  fprintf(stderr,
    &#34;\n&#34;
    &#34;%s -e reads code points and writes a Punycode string.\n&#34;
    &#34;%s -d reads a Punycode string and writes code points.\n&#34;
    &#34;\n&#34;
    &#34;Input and output are plain text in the native character set.\n&#34;
    &#34;Code points are in the form u+hex separated by whitespace.\n&#34;
    &#34;Although the specification allows Punycode strings to contain\n&#34;
    &#34;any characters from the ASCII repertoire, this test code\n&#34;
    &#34;supports only the printable characters, and needs the Punycode\n&#34;
    &#34;string to be followed by a newline.\n&#34;
    &#34;The case of the u in u+hex is the force-to-uppercase flag.\n&#34;
    , argv[0], argv[0]);
  exit(EXIT_FAILURE);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static void fail(const char *msg)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
静的な無効た（constのchar *のMSGを）失敗します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
{
  fputs(msg,stderr);
  exit(EXIT_FAILURE);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static const char too_big[] =
  &#34;input or output is too large, recompile with larger limits\n&#34;;
static const char invalid_input[] = &#34;invalid input\n&#34;;
static const char overflow[] = &#34;arithmetic overflow\n&#34;;
static const char io_error[] = &#34;I/O error\n&#34;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* The following string is used to convert printable */
/* characters between ASCII and the native charset:  */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
static const char print_ascii[] = &#34;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#34; &#34;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#34; &#34; !\&#34;#$%&amp;&#39;()*+,-./&#34; &#34;0123456789:;&lt;=&gt;?&#34; &#34;@ABCDEFGHIJKLMNO&#34; &#34;PQRSTUVWXYZ[\\]^_&#34; &#34;`abcdefghijklmno&#34; &#34;pqrstuvwxyz{|}~\n&#34;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
静的定数チャーprint_ascii [] = &#34;\ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n&#34; は「\ n \ n \ n \ nは\ N \ N \ N \ N \ N \ N \ N \ N \ N \ N \ N \ N」 &#34;\！&#34; ＃$％＆ &#39;（）* +、 -  /」「0123456789：; &lt;=&gt; ？」 &#34;@ABCDEFGHIJKLMNO&#34; &#34;pQRSTUVWXYZ [\\] ^ _&#34; &#34;` ABCDEFGHIJKLMNO&#34; &#34;pqrstuvwxyz {|}〜\ nを&#34;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
int main(int argc, char **argv)
{
  enum punycode_status status;
  int r;
  unsigned int input_length, output_length, j;
  unsigned char case_flags[unicode_max_length];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (argc != 2) usage(argv);
  if (argv[1][0] != &#39;-&#39;) usage(argv);
  if (argv[1][2] != 0) usage(argv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (argv[1][1] == &#39;e&#39;) {
    punycode_uint input[unicode_max_length];
    unsigned long codept;
    char output[ace_max_length+1], uplus[3];
    int c;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Read the input code points: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
input_length = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
input_length = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (;;) {
      r = scanf(&#34;%2s%lx&#34;, uplus, &amp;codept);
      if (ferror(stdin)) fail(io_error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
if (r == EOF || r == 0) break;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
もし（R == EOF || R == 0）ブレーク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
if (r != 2 || uplus[1] != &#39;+&#39; || codept &gt; (punycode_uint)-1) { fail(invalid_input); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IF（R = 2 || uplus [1] = &#39;+&#39; || codept&gt;（punycode_uint）-1！）{（INVALID_INPUT）失敗。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
if (input_length == unicode_max_length) fail(too_big);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
もし（input_length == unicode_max_length）（too_big）は失敗。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (uplus[0] == &#39;u&#39;) case_flags[input_length] = 0;
      else if (uplus[0] == &#39;U&#39;) case_flags[input_length] = 1;
      else fail(invalid_input);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 input[input_length++] = codept; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
入力【input_length ++] = codept。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Encode: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    output_length = ace_max_length;
    status = punycode_encode(input_length, input, case_flags,
                             &amp;output_length, output);
    if (status == punycode_bad_input) fail(invalid_input);
    if (status == punycode_big_output) fail(too_big);
    if (status == punycode_overflow) fail(overflow);
    assert(status == punycode_success);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Convert to native charset and output: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (j = 0;  j &lt; output_length;  ++j) {
      c = output[j];
      assert(c &gt;= 0 &amp;&amp; c &lt;= 127);
      if (print_ascii[c] == 0) fail(invalid_input);
      output[j] = print_ascii[c];
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    output[j] = 0;
    r = puts(output);
    if (r == EOF) fail(io_error);
    return EXIT_SUCCESS;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (argv[1][1] == &#39;d&#39;) {
    char input[ace_max_length+2], *p, *pp;
    punycode_uint output[unicode_max_length];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Read the Punycode input string and convert to ASCII: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    fgets(input, ace_max_length+2, stdin);
    if (ferror(stdin)) fail(io_error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    if (feof(stdin)) fail(invalid_input);
    input_length = strlen(input) - 1;
    if (input[input_length] != &#39;\n&#39;) fail(too_big);
    input[input_length] = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (p = input;  *p != 0;  ++p) {
      pp = strchr(print_ascii, *p);
      if (pp == 0) fail(invalid_input);
      *p = pp - print_ascii;
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Decode: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    output_length = unicode_max_length;
    status = punycode_decode(input_length, input, &amp;output_length,
                             output, case_flags);
    if (status == punycode_bad_input) fail(invalid_input);
    if (status == punycode_big_output) fail(too_big);
    if (status == punycode_overflow) fail(overflow);
    assert(status == punycode_success);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Output the result: */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (j = 0;  j &lt; output_length;  ++j) {
      r = printf(&#34;%s+%04lX\n&#34;,
                 case_flags[j] ? &#34;U&#34; : &#34;u&#34;,
                 (unsigned long) output[j] );
      if (r &lt; 0) fail(io_error);
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
 return EXIT_SUCCESS; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
EXIT_SUCCESSを返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  usage(argv);
  return EXIT_SUCCESS;  /* not reached, but quiets compiler warning */
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Adam M. Costello University of California, Berkeley http://www.nicemice.net/amc/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カリフォルニア大学バークレー校のアダム・M.コステロ大学http://www.nicemice.net/amc/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
