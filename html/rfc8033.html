<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8033 - Proportional Integral Controller Enhanced (PIE): A Lightweight Control Scheme to Address the Bufferbloat Problem 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8033 - Proportional Integral Controller Enhanced (PIE): A Lightweight Control Scheme to Address the Bufferbloat Problem 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8033">
              https://tools.ietf.org/html/rfc8033
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8033 - 強化された比例積分制御（PIE）：軽量制御方式Bufferbloat問題に対処するために</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                            R. Pan
Request for Comments: 8033                                  P. Natarajan
Category: Experimental                                     Cisco Systems
ISSN: 2070-1721                                                 F. Baker
                                                            Unaffiliated
                                                                G. White
                                                               CableLabs
                                                           February 2017
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            Proportional Integral Controller Enhanced (PIE):
    A Lightweight Control Scheme to Address the Bufferbloat Problem
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bufferbloat is a phenomenon in which excess buffers in the network cause high latency and latency variation. As more and more interactive applications (e.g., voice over IP, real-time video streaming, and financial transactions) run in the Internet, high latency and latency variation degrade application performance. There is a pressing need to design intelligent queue management schemes that can control latency and latency variation, and hence provide desirable quality of service to users.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bufferbloatは、ネットワーク内の過剰バッファが高遅延と遅延変動を引き起こす現象です。インターネットで実行され、より多くの対話型アプリケーション（例えば、ボイスオーバーIP、リアルタイムのビデオストリーミング、および金融取引）として、高遅延と遅延変動は、アプリケーションのパフォーマンスを低下させます。レイテンシと、レイテンシの変動を制御し、ひいてはユーザーへのサービスの望ましい品質を提供することができますインテリジェントキュー管理スキームを設計する差し迫った必要性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document presents a lightweight active queue management design called &#34;PIE&#34; (Proportional Integral controller Enhanced) that can effectively control the average queuing latency to a target value. Simulation results, theoretical analysis, and Linux testbed results have shown that PIE can ensure low latency and achieve high link utilization under various congestion situations. The design does not require per-packet timestamps, so it incurs very little overhead and is simple enough to implement in both hardware and software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、「PIE」効果的に目標値に平均キューイング遅延を制御することができます（拡張比例積分コントローラ）と呼ばれる軽量なアクティブキュー管理設計を提示します。シミュレーションの結果、理論解析、およびLinuxのテストベッドの結果はPIEは、低レイテンシーを確保し、様々な混雑状況の下で、高いリンク利用率を達成できることを示しました。デザインは、パケットごとのタイムスタンプを必要としないので、非常に少ないオーバーヘッドが発生し、ハードウェアとソフトウェアの両方で実装するのに十分に簡単です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8033.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8033で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................3
   2. Terminology .....................................................5
   3. Design Goals ....................................................5
   4. The Basic PIE Scheme ............................................6
      4.1. Random Dropping ............................................7
      4.2. Drop Probability Calculation ...............................7
      4.3. Latency Calculation ........................................9
      4.4. Burst Tolerance ...........................................10
   5. Optional Design Elements of PIE ................................11
      5.1. ECN Support ...............................................11
      5.2. Dequeue Rate Estimation ...................................11
      5.3. Setting PIE Active and Inactive ...........................13
      5.4. Derandomization ...........................................14
      5.5. Cap Drop Adjustment .......................................15
   6. Implementation Cost ............................................15
   7. Scope of Experimentation .......................................17
   8. Incremental Deployment .........................................17
   9. Security Considerations ........................................18
   10. References ....................................................18
      10.1. Normative References .....................................18
      10.2. Informative References ...................................18
   Appendix A. The Basic PIE Pseudocode ..............................21
   Appendix B. Pseudocode for PIE with Optional Enhancement ..........24
   Contributors ......................................................29
   Authors&#39; Addresses ................................................30
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The explosion of smart phones, tablets, and video traffic in the Internet brings about a unique set of challenges for congestion control. To avoid packet drops, many service providers or data-center operators require vendors to put in as much buffer as possible. Because of the rapid decrease in memory chip prices, these requests are easily accommodated to keep customers happy. While this solution succeeds in assuring low packet loss and high TCP throughput, it suffers from a major downside. TCP continuously increases its sending rate and causes network buffers to fill up. TCP cuts its rate only when it receives a packet drop or mark that is interpreted as a congestion signal. However, drops and marks usually occur when network buffers are full or almost full. As a result, excess buffers, initially designed to avoid packet drops, would lead to highly elevated queuing latency and latency variation. Designing a queue management scheme is a delicate balancing act: it not only should allow short-term bursts to smoothly pass but also should control the average latency in the presence of long-running greedy flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターネットでのスマートフォン、タブレット、およびビデオトラフィックの爆発は、輻輳制御のための課題の独自のセットをもたらします。パケットドロップを回避するために、多くのサービスプロバイダーやデータセンター事業者は、できるだけ多くのバッファを中に入れて、ベンダーが必要です。そのため、メモリチップ価格の急激な減少により、これらの要求は簡単に幸せな顧客を維持するために収容されています。このソリューションは、低パケット損失と高いTCPスループットを確保することに成功したが、それは大きな欠点に苦しんでいます。 TCPは、継続的に送信レートを増加し、埋めるためにネットワークバッファの原因となります。 TCPは、輻輳信号として解釈されるパケットドロップまたはマークを受信した場合にのみ、その速度を切断します。しかし、落下してネットワーク・バッファがフルまたはほとんどいっぱいになるとマークが通常発生します。その結果、最初にパケットドロップを回避するように設計された過剰のバッファは、非常に高いキューイング遅延やレイテンシの変動につながります。キュー管理スキームを設計することは、微妙なバランスをとる行為である：それは短期的なバーストがスムーズに合格するだけでなく、長時間実行貪欲フローの存在下での平均待ち時間を制御する必要があります許可しなければならないだけではなく。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Active Queue Management (AQM) schemes could potentially solve the aforementioned problem. AQM schemes, such as Random Early Detection (RED) [RED] as suggested in [RFC2309] (which is now obsoleted by [RFC7567]), have been around for well over a decade. RED is implemented in a wide variety of network devices, both in hardware and software. Unfortunately, due to the fact that RED needs careful tuning of its parameters for various network conditions, most network operators don&#39;t turn RED on. In addition, RED is designed to control the queue length, which would affect latency implicitly. It does not control latency directly. Hence, the Internet today still lacks an effective design that can control buffer latency to improve the quality of experience to latency-sensitive applications. The more recently published RFC 7567 calls for new methods of controlling network latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アクティブキュー管理（AQM）方式は、潜在的に、前述の問題を解決することができます。 [RFC2309]で提案されているようなランダム早期検出（RED）[赤]とAQM方式、（今では廃止されている[RFC7567]）は、ウェル10年以上使用されてきました。 REDは、ハードウェアとソフトウェアの両方で、ネットワークデバイスの広範囲で実施されます。残念ながら、REDは、さまざまなネットワーク条件のためにそのパラメータを慎重にチューニングを必要とするという事実のために、ほとんどのネットワークオペレータは、上のREDをオンにしないでください。また、REDは、暗黙のうちに、待ち時間影響するキューの長さを、制御するように設計されています。これは、直接、待ち時間を制御しません。したがって、インターネットは、今日はまだ遅延に敏感なアプリケーションへの体験の質を向上させるために、バッファ待ち時間を制御することができます効果的なデザインを欠いています。ネットワークの遅延を制御するための新しい方法のためのより多くの最近発表されたRFC 7567のコール。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
New algorithms are beginning to emerge to control queuing latency directly to address the bufferbloat problem [CoDel]. Along these lines, Proportional Integral controller Enhanced (PIE) also aims to keep the benefits of RED, including easy implementation and scalability to high speeds. Similar to RED, PIE randomly drops an incoming packet at the onset of congestion. Congestion detection, however, is based on the queuing latency instead of the queue length (as with RED). Furthermore, PIE also uses the derivative (rate of change) of the queuing latency to help determine congestion levels and an appropriate response. The design parameters of PIE are chosen via control theory stability analysis. While these parameters can be fixed to work in various traffic conditions, they could be made self-tuning to optimize system performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいアルゴリズムはbufferbloat問題[CODEL]に対処するために、直接の待ち時間をキューイング制御することが出現し始めています。これらの線に沿って、（PIE）強化された比例積分コントローラも高速に簡単に実装およびスケーラビリティを含め、REDの利益を維持することを目指しています。 REDと同様に、PIEは、ランダムに輻輳の開始時に、着信パケットをドロップします。輻輳検出は、しかしながら、キューイング待ち時間の代わりに（REDと同様に）キュー長に基づいています。また、PIEはまた、渋滞度と適切な応答を判断するためにキューイング遅延の導関数（変化率）を使用します。 PIEの設計パラメータは、制御理論の安定性解析を経て選ばれています。これらのパラメータは、様々な交通状況で動作するように固定することができますが、それらはシステムのパフォーマンスを最適化するために、セルフチューニング作ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Separately, it is assumed that any latency-based AQM scheme would be applied over a Fair Queuing (FQ) structure or one of its approximate designs, Flow Queuing or Class-Based Queuing (CBQ). FQ is one of the most studied scheduling algorithms since it was first proposed in 1985 [RFC970]. CBQ has been a standard feature in most network devices today [CBQ]. Any AQM scheme that is built on top of FQ or CBQ could benefit from these advantages. Furthermore, these advantages, such as per-flow or per-class fairness, are orthogonal to the AQM design whose primary goal is to control latency for a given queue. For flows that are classified into the same class and put into the same queue, one needs to ensure that their latency is better controlled and that their fairness is not worse than those under the standard DropTail or RED design. More details about the relationship between FQ and AQM can be found in [RFC7806].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別々に、任意の待ち時間に基づくAQM方式が均等化キューイング（FQ）構造又はその近似設計、フローイングまたはクラスベースキューイング（CBQ）の1つの上に適用されることが想定されます。 FQは、それが最初の[RFC970] 1985年に提案されて以来最も研究スケジューリングアルゴリズムの一つです。 CBQは、ほとんどのネットワーク機器に標準搭載今日[CBQ]となっています。 FQまたはCBQの上に構築されているすべてのAQM方式は、これらの利点から利益を得ることができます。さらに、そのようなフローごとまたはクラスごとの公平性などのこれらの利点は、その主な目的指定されたキューのための待ち時間を制御することであるAQM設計に直交しています。同じクラスに分類し、同じキューに入れているフローの場合、人は自分の待ち時間がより良好に制御されていることを確認する必要があり、その公平性が標準DropTailまたはRED設計中のものより悪くないであること。 FQとAQMの間の関係についての詳細は、[RFC7806]に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In October 2013, CableLabs&#39; Data-Over-Cable Service Interface Specification 3.1 (DOCSIS 3.1) specification [DOCSIS_3.1] mandated that cable modems implement a specific variant of the PIE design as the active queue management algorithm. In addition to cable-specific improvements, the PIE design in DOCSIS 3.1 [RFC8034] has improved the original design in several areas, including derandomization of coin tosses and enhanced burst protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2013年10月には、CableLabsのデータオーバーケーブルサービスインターフェース仕様3.1（DOCSIS 3.1）仕様では、[DOCSIS_3.1]ケーブルモデムは、アクティブキュー管理アルゴリズムとしてPIEの設計の特定のバリアントを実装することを義務付け。ケーブル固有の改善に加えて、DOCSIS 3.1 [RFC8034]でPIE設計は、コイン投げのderandomizationと拡張バースト保護を含む、いくつかの分野でオリジナルデザインを改善しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes the design of PIE and separates it into basic elements and optional components that may be implemented to enhance the performance of PIE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、PIEの設計について説明し、基本的な要素とPIEの性能を向上させるために実施されてもよい任意の成分に分離します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますRFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Design Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.設計目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A queue management framework is designed to improve the performance of interactive and latency-sensitive applications. It should follow the general guidelines set by the AQM working group document &#34;IETF Recommendations Regarding Active Queue Management&#34; [RFC7567]. More specifically, the PIE design has the following basic criteria.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キュー管理フレームワークは、対話とレイテンシの影響を受けやすいアプリケーションのパフォーマンスを向上させるために設計されています。これは、AQMワーキンググループ文書「アクティブキュー管理に関するIETF勧告」[RFC7567]で設定された一般的なガイドラインに従ってください。具体的には、PIEの設計は、以下の基本的な基準を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* First, queuing latency, instead of queue length, is controlled. Queue sizes change with queue draining rates and various flows&#39; round-trip times. Latency bloat is the real issue that needs to be addressed, as it impairs real-time applications. If latency can be controlled, bufferbloat is not an issue. In fact, once latency is under control, it frees up buffers for sporadic bursts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*まず、代わりにキューの長さの待ち時間が、キューイング、制御されています。キューのサイズは、キュー排出率と様々なフロー往復時間で変化します。待ち時間肥大化は、それがリアルタイムアプリケーションを損なうとして、対処する必要がある本当の問題です。待ち時間が制御することができれば、bufferbloatは問題ではありません。レイテンシが制御下にある一度実際に、それは散発的なバーストのためのバッファを解放します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Secondly, PIE aims to attain high link utilization. The goal of low latency shall be achieved without suffering link underutilization or losing network efficiency. An early congestion signal could cause TCP to back off and avoid queue buildup. On the other hand, however, TCP&#39;s rate reduction could result in link underutilization. There is a delicate balance between achieving high link utilization and low latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*第二に、PIEが高いリンク利用率を達成することを目指しています。低レイテンシーの目標は、リンクの不十分な利用を苦しみやネットワーク効率を損なうことなく達成されなければなりません。早期輻輳信号は、バックオフとキューの蓄積を避けるために、TCPを引き起こす可能性があります。一方、しかし、TCPの速度低下は、リンク不十分な利用につながる可能性があります。高いリンク利用率と低遅延を実現するとの微妙なバランスがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Furthermore, the scheme should be simple to implement and easily scalable in both hardware and software. PIE strives to maintain design simplicity similar to that of RED, which has been implemented in a wide variety of network devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*さらに、スキームは、ハードウェアとソフトウェアの両方で実装が簡単かつ容易に拡張する必要があります。 PIEは、ネットワーク機器に幅広く実装されているREDと同様のシンプルデザインを、維持に努めています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Finally, the scheme should ensure system stability for various network topologies and scale well across an arbitrary number of streams. Design parameters shall be set automatically. Users only need to set performance-related parameters such as target queue latency, not design parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*最後に、スキームは、様々なネットワークトポロジのシステムの安定性を確保すべきであり、ストリームの任意の数を横切っうまくスケール。設計パラメータが自動的に設定されなければなりません。ユーザーは、パラメータを設計し、そのようなターゲット・キューの待ち時間などのパフォーマンス関連のパラメータを設定する必要がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the following text, the design of PIE and its operation are described in detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のテキストでは、PIEの設計及びその動作について詳細に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. The Basic PIE Scheme
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.基本的なPIEスキーム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As illustrated in Figure 1, PIE is comprised of three simple basic components: a) random dropping at enqueuing, b) periodic drop probability updates, and c) latency calculation. When a packet arrives, a random decision is made regarding whether to drop the packet. The drop probability is updated periodically based on how far the current latency is away from the target value and whether the queuing latency is currently trending up or down. The queuing latency can be obtained using direct measurements or using estimations calculated from the queue length and the dequeue rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンキューにおけるA）ランダム滴下し、b）周期的な廃棄確率の更新、およびc）待ち時間の計算：図1に示すように、PIEは、3つの単純な基本的な構成要素から構成されています。パケットが到着すると、ランダムな決定は、パケットをドロップするかどうかについて行われます。ドロップ確率は、現在の待ち時間が離れた目標値からおよびキューイングの待ち時間が現在上昇傾向または下降されるかどうかどれだけ離れているかに基づいて定期的に更新されます。キューイング遅延は直接測定を使用して、またはキューの長さおよびデキュー速度から算出さ推定を使用して得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The detailed definition of parameters can be found in Appendix A of this document (&#34;The Basic PIE Pseudocode&#34;). Any state variables that PIE maintains are noted using &#34;PIE-&gt;&#34;. For a full description of the algorithm, one can refer to the full paper [HPSR-PIE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パラメータの詳細な定義は、このドキュメントの付録A（「基本PIE擬似コード」）に記載されています。 PIEは維持する任意の状態変数が「&gt; PIE-」を使用して指摘されています。アルゴリズムの詳細については、一方が完全な紙[HPSR-PIE]を参照することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Random Drop
              /               --------------
      -------/  --------------&gt;    | | | | | --------------&gt;
             /|\                   | | | | |
              |               --------------
              |             Queue Buffer   \
              |                     |       \
              |                     |Queue   \
              |                     |Length   \
              |                     |          \
              |                    \|/         \/
              |          -----------------    -------------------
              |          |     Drop      |    |                 |
              -----&lt;-----|  Probability  |&lt;---| Latency         |
                         |  Calculation  |    | Calculation     |
                         -----------------    -------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1: The PIE Structure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1：PIEの構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Random Dropping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。ランダムドロップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE randomly drops a packet upon its arrival to a queue according to a drop probability, PIE-&gt;drop_prob_, that is obtained from the drop-probability-calculation component. The random drop is triggered by a packet&#39;s arrival before enqueuing into a queue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEは、ランダムにドロップ確率計算コンポーネントから得られる廃棄確率、PIE-&gt; drop_prob_に記載のキューへの到着時にパケットをドロップ。ランダムドロップはキューにエンキューする前に、パケットの到着によってトリガされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Upon a packet enqueue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*パケットのエンキュー時：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
randomly drop the packet with a probability of PIE-&gt;drop_prob_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ランダムPIE-&gt; drop_prob_の確率でパケットをドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To ensure that PIE is &#34;work conserving&#34;, we bypass the random drop if the latency sample, PIE-&gt;qdelay_old_, is smaller than half of the target latency value (QDELAY_REF) when the drop probability is not too high (i.e., PIE-&gt;drop_prob_ &lt; 0.2), or if the queue has less than a couple of packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドロップ確率は（すなわち、PIE-あまり高くない場合、待ち時間サンプル、PIE-&gt; qdelay_old_は、ターゲットのレイテンシ値（QDELAY_REF）の半分よりも小さい場合にPIEは「作業節約」であることを確認するために、我々はランダムドロップをバイパス&gt; drop_prob_ &lt;0.2）、またはキューは、パケットのカップル未満を有する場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Upon a packet enqueue, PIE does the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*パケットエンキュー時には、PIEは、次の処理を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//Safeguard PIE to be work conserving if ( (PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2 &amp;&amp; PIE-&gt;drop_prob_ &lt; 0.2) || (queue_.byte_length() &lt;= 2 * MEAN_PKTSIZE) ) return ENQUE; else randomly drop the packet with a probability of PIE-&gt;drop_prob_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
// IF（（PIE-&gt; qdelay_old_ &lt;QDELAY_REF / 2 &amp;&amp; PIE-&gt; drop_prob_ &lt;0.2）||（queue_.byte_length（）&lt;= 2 * MEAN_PKTSIZE））戻りENQUEを節約する作業であることがPIEを守ります。他のランダムPIE-&gt; drop_prob_の確率でパケットをドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE optionally supports Explicit Congestion Notification (ECN); see Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEは、必要に応じて明示的輻輳通知（ECN）をサポートします。セクション5.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Drop Probability Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。ドロップ確率の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PIE algorithm periodically updates the drop probability based on the latency samples -- not only the current latency sample but also whether the latency is trending up or down. This is the classical Proportional Integral (PI) controller method, which is known for eliminating steady-state errors. This type of controller has been studied before for controlling the queue length [PI] [QCN]. PIE adopts the PI controller for controlling latency. The algorithm also auto-adjusts the control parameters based on how heavy the congestion is, which is reflected in the current drop probability. Note that the current drop probability is a direct measure of the current congestion level; there is no need to measure the arrival rate and dequeue rate mismatches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在の待ち時間のサンプルだけでなく、レイテンシが上昇傾向か下降されているかどうかだけではなく -  PIEアルゴリズムは、定期的に待ち時間のサンプルに基づいて、ドロップ確率を更新します。これは、定常誤差を除去するために知られている古典的な比例積分（PI）制御方法、です。コントローラこのタイプのキューの長さ[PI] [QCN]を制御する前に研究されてきました。 PIEは、待ち時間を制御するためのPIコントローラを採用しています。アルゴリズムは、輻輳が現在のドロップ確率に反映され、どのように重いに基づいて制御パラメータを自動調整します。現在のドロップ確率が現在の輻輳レベルの直接的な尺度であることに留意されたいです。到着率とデキュー率のミスマッチを測定する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a congestion period ends, we might be left with a high drop probability with light packet arrivals. Hence, the PIE algorithm includes a mechanism by which the drop probability decays exponentially (rather than linearly) when the system is not congested. This would help the drop probability converge to 0 more quickly, while the PI controller ensures that it would eventually reach zero. The decay parameter of 2% gives us a time constant around 50 * T_UPDATE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳期間が終了すると、我々は、光パケットの到着と高ドロップ確率が残ることがあります。したがって、PIEアルゴリズムは、システムが混雑していない場合、ドロップ確率が指数関数的に（というより直線的）に減衰するメカニズムを含みます。これは、PIコントローラは、それが最終的にゼロに到達することを保証しながら、ドロップ確率は、より迅速に0に収束役立つだろう。 2％の減衰パラメータは、私たちの周りの50 *のT_UPDATE一定の時間を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Specifically, the PIE algorithm periodically adjusts the drop probability every T_UPDATE interval:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
具体的には、PIEアルゴリズムは、定期的にドロップ確率ごとT_UPDATE間隔を調整します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* calculate drop probability PIE-&gt;drop_prob_, and autotune it as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*計算のドロップ確率PIE-&gt; drop_prob_、そして次のように自動チューニングを：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         p = alpha * (current_qdelay - QDELAY_REF) +
                beta * (current_qdelay - PIE-&gt;qdelay_old_);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (PIE-&gt;drop_prob_ &lt; 0.000001) {
             p /= 2048;
         } else if (PIE-&gt;drop_prob_ &lt; 0.00001) {
             p /= 512;
         } else if (PIE-&gt;drop_prob_ &lt; 0.0001) {
             p /= 128;
         } else if (PIE-&gt;drop_prob_ &lt; 0.001) {
             p /= 32;
         } else if (PIE-&gt;drop_prob_ &lt; 0.01) {
             p /= 8;
         } else if (PIE-&gt;drop_prob_ &lt; 0.1) {
             p /= 2;
         } else {
             p = p;
         }
         PIE-&gt;drop_prob_ += p;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* decay the drop probability exponentially:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*指数関数的にドロップ確率を減衰：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (current_qdelay == 0 &amp;&amp; PIE-&gt;qdelay_old_ == 0) {
             PIE-&gt;drop_prob_ = PIE-&gt;drop_prob_ * 0.98;
                                                 //1 - 1/64 is
                                                 //sufficient
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* bound the drop probability:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*ドロップ確率をバインド：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (PIE-&gt;drop_prob_ &lt; 0)
                  PIE-&gt;drop_prob_ = 0.0
         if (PIE-&gt;drop_prob_ &gt; 1)
                  PIE-&gt;drop_prob_ = 1.0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* store the current latency value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*現在のレイテンシ値を格納します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt;qdelay_old_ = current_qdelay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt; qdelay_old_ = current_qdelay。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The update interval, T_UPDATE, is defaulted to be 15 milliseconds. It MAY be reduced on high-speed links in order to provide smoother response. The target latency value, QDELAY_REF, SHOULD be set to 15 milliseconds. The variables current_qdelay and PIE-&gt;qdelay_old_ represent the current and previous samples of the queuing latency, which are calculated by the &#34;latency calculation&#34; component (see Section 4.3). The variable current_qdelay is actually a temporary variable, while PIE-&gt;qdelay_old_ is a state variable that PIE keeps. The drop probability is a value between 0 and 1. However, implementations can certainly use integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
更新間隔、T_UPDATEは、15ミリ秒であることをデフォルトに設定されています。これは、スムーズなレスポンスを提供するために、高速リンクに低減することができます。ターゲットのレイテンシ値、QDELAY_REFは、15ミリ秒に設定する必要があります。変数はcurrent_qdelayとPIE-&gt;は「レイテンシ計算」コンポーネント（4.3節を参照）によって計算されるキューイング遅延、現在および以前のサンプルを表しqdelay_old_。 PIE-&gt; qdelay_old_は、PIEが保持状態変数である一方、変数current_qdelayは、実際には、一時的な変数です。ドロップ確率は、実装は確かに整数を使用することができ、しかし、0と1の間の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The controller parameters, alpha and beta (expressed in Hz), are designed using feedback loop analysis, where TCP&#39;s behaviors are modeled using the results from well-studied prior art [TCP-Models]. Note that the above adjustment of &#39;p&#39; effectively scales the alpha and beta parameters based on the current congestion level indicated by the drop probability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（Hzで表す）コントローラパラメータ、αおよびβは、TCPの挙動をよく研究先行技術[TCP-モデル]からの結果を使用してモデル化されたフィードバックループ分析を使用して設計されています。 「P」の上記調整を効果的に廃棄確率によって示される現在の輻輳レベルに基づいて、αおよびβパラメータをスケーリングすることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The theoretical analysis of PIE can be found in [HPSR-PIE]. As a rule of thumb, to keep the same feedback loop dynamics, if we cut T_UPDATE in half, we should also cut alpha by half and increase beta by alpha/4. If the target latency is reduced, e.g., for data-center use, the values of alpha and beta should be increased by the same order of magnitude by which the target latency is reduced. For example, if QDELAY_REF is reduced and changed from 15 milliseconds to 150 microseconds -- a reduction of two orders of magnitude -- then alpha and beta values should be increased to alpha * 100 and beta * 100.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEの理論的な分析は、[HPSR-PIE]で見つけることができます。我々は半分にT_UPDATEを切った場合、親指のルールとして、同じフィードバックループのダイナミクスを維持するために、我々はまた、半分にアルファをカットし、アルファ/ 4でベータ版を増やす必要があります。目標待ち時間が減少する場合、例えば、データ・センターで使用するために、α及びβの値は、目標待ち時間が低減される大きさの同じ順序によって増加されるべきです。例えば、QDELAY_REFが低減されている場合、150マイクロ秒に15ミリ秒から変更 - 二桁の減少 - 次いで、αおよびβの値は、α* 100およびβ×100に増加されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Latency Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。レイテンシ計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PIE algorithm uses latency to calculate drop probability in one of two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEアルゴリズムは、2つの方法のいずれかでドロップ確率を計算するために、待ち時間を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* It estimates the current queuing latency using Little&#39;s law (see Section 5.2 for details):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*これは、リトルの法則を（詳細はセクション5.2を参照）を使用して、現在のキューイングの待ち時間を推定します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
current_qdelay = queue_.byte_length()/dequeue_rate;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
current_qdelay = queue_.byte_length（）/ dequeue_rate。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* It may use other techniques for calculating queuing latency, e.g., time-stamp the packets at enqueue, and use the timestamps to calculate latency during dequeue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*これは、例えば、エンキューでパケットをタイムスタンプ、およびデキューの間の待ち時間を計算するためにタイムスタンプを使用して、キューイング遅延を計算するための他の技術を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Burst Tolerance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4。バースト公差
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE does not penalize short-term packet bursts as suggested in [RFC7567]. PIE allows bursts of traffic that create finite-duration events in which current queuing latency exceeds QDELAY_REF without triggering packet drops. This document introduces a parameter called &#34;MAX_BURST&#34;; MAX_BURST defines the burst duration that will be protected. By default, the parameter SHOULD be set to 150 milliseconds. For simplicity, the PIE algorithm MAY effectively round MAX_BURST up to an integer multiple of T_UPDATE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7567]で提案されているようにPIEは、短期パケットバーストを処罰しません。 PIEは、現在のキューイング遅延がパケットを廃棄せずにトリガーQDELAY_REFを超えた有限時間イベントを作成し、トラフィックのバーストを可能にします。この文書は、「MAX_BURST」と呼ばれるパラメータを導入し、 MAX_BURSTが保護されるバースト期間を定義します。デフォルトでは、パラメータは150ミリ秒に設定する必要があります。簡単のため、PIEアルゴリズム月効果MAX_BURSTラウンドT_UPDATEの整数倍まで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To implement the burst tolerance function, two basic components of PIE are involved: &#34;random dropping&#34; and &#34;drop probability calculation&#34;. The PIE algorithm does the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バーストトレランス機能を実装するには、PIEの2つの基本的な構成要素が含まれている：「ランダムドロップ」と「ドロップ確率計算」。 PIEアルゴリズムは、次のことを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* In the &#34;random dropping&#34; block and upon packet arrival, PIE checks the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*「ランダムドロップ」ブロックでは、パケットの到着時に、PIEは、次のことをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon a packet enqueue: if PIE-&gt;burst_allowance_ &gt; 0 enqueue packet; else randomly drop a packet with a probability of PIE-&gt;drop_prob_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットのエンキュー時：PIE-&gt; burst_allowance_&gt; 0エンキューパケットであれば、他のランダムPIE-&gt; drop_prob_の確率でパケットをドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (PIE-&gt;drop_prob_ == 0 and current_qdelay &lt; QDELAY_REF/2 and PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2) PIE-&gt;burst_allowance_ = MAX_BURST;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IF（PIE-&gt; == 0とdrop_prob_ current_qdelay &lt;QDELAY_REF / 2とPIE-&gt; qdelay_old_ &lt;QDELAY_REF / 2）PIE-&gt; burst_allowance_ = MAX_BURST。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* In the &#34;drop probability calculation&#34; block, PIE additionally calculates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*「ドロップ確率計算」ブロックでは、PIEは、さらに計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt;burst_allowance_ = max(0,PIE-&gt;burst_allowance_ - T_UPDATE);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt; burst_allowance_ = MAX（0、PIE-&gt; burst_allowance_  -  T_UPDATE）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The burst allowance, noted by PIE-&gt;burst_allowance_, is initialized to MAX_BURST. As long as PIE-&gt;burst_allowance_ is above zero, an incoming packet will be enqueued, bypassing the random drop process. During each update instance, the value of PIE-&gt;burst_allowance_ is decremented by the update period, T_UPDATE, and is bottomed at 0. When the congestion goes away -- defined here as PIE-&gt;drop_prob_ equals 0 and both the current and previous samples of estimated latency are less than half of QDELAY_REF -- PIE-&gt;burst_allowance_ is reset to MAX_BURST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt; burst_allowance_によって指摘バースト引当金は、MAX_BURSTに初期化されます。限りPIE-&gt; burst_allowance_がゼロ以上であるように、入ってくるパケットは、ランダムドロッププロセスをバイパスし、エンキューされるであろう。各更新インスタンス中、PIE-&gt; burst_allowance_の値は、更新期間、T_UPDATEだけデクリメントされ、輻輳がなくなったとき0に底される -  PIE-として定義&gt; drop_prob_は0と現在および以前のサンプルに等しいです。推定の待ち時間のQDELAY_REFの半分以下である -  PIE-&gt; burst_allowance_はMAX_BURSTにリセットされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Optional Design Elements of PIE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
PIEの5.オプション設計要素
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are several enhancements that are added to further augment the performance of the basic algorithm. For purposes of clarity, they are included in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、基本的なアルゴリズムの性能を強化するために追加されたいくつかの拡張機能があります。明確にするために、彼らは、このセクションに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. ECN Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。 ECNのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE MAY support ECN by marking (rather than dropping) ECN-capable packets [ECN]. This document introduces an additional threshold called &#34;mark_ecnth&#34;, which acts as a safeguard: if the calculated drop probability exceeds mark_ecnth, PIE reverts to packet-dropping for ECN-capable packets. The variable mark_ecnth SHOULD be set to 0.1 (10%).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEは、[ECN]マーキング（よりむしろ落下）によりECN対応のパケットをECNをサポートするかもしれません。この文書では、セーフガードとして機能する「mark_ecnth」と呼ばれる追加のしきい値を、導入：計算ドロップ確率がmark_ecnthを超える場合、PIEは、パケットドロップするECN-可能なパケットに対して戻ります。変数mark_ecnthは0.1（10％）に設定されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* To support ECN, the &#34;random drop with a probability of PIE-&gt;drop_prob_&#34; function in the &#34;random dropping&#34; block is changed to the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* ECNをサポートするには、「ランダムドロップ」ブロック内の関数「PIE-&gt; drop_prob_の確率でランダムドロップ」は、以下のように変更されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Upon a packet enqueue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*パケットのエンキュー時：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if rand() &lt; PIE-&gt;drop_prob_:
          if PIE-&gt;drop_prob_ &lt; mark_ecnth &amp;&amp; ecn_capable_packet == TRUE:
             mark packet;
          else
             drop packet;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Dequeue Rate Estimation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。デキュー率推定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using timestamps, a latency sample can only be obtained when a packet reaches the head of a queue. When a quick response time is desired or a direct latency sample is not available, one may obtain latency through measuring the dequeue rate. The draining rate of a queue in the network often varies either because other queues are sharing the same link or because the link capacity fluctuates. Rate fluctuation is particularly common in wireless networks. One may measure directly at the dequeue operation. Short, non-persistent bursts of packets result in empty queues from time to time; this would make the measurement less accurate. PIE only measures latency when there is sufficient data in the buffer, i.e., when the queue length is over a certain threshold (DQ_THRESHOLD). PIE measures how long it takes to drain DQ_THRESHOLD packets. More specifically, the rate estimation can be implemented as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットがキューの先頭に達したときにタイムスタンプを使用して、待ち時間のサンプルのみを取得することができます。迅速な応答時間が望まれるまたは直接待ち時間サンプルが利用可能でない場合、一方がデキュー率を測定を通しての待ち時間を取得してもよいです。ネットワーク内のキューの排出率は、多くの場合、他のキューが同じリンクを共有しているためか、リンク容量が変動するので、どちらかによって異なります。レート変動は、ワイヤレスネットワークで特に一般的です。一つは、デキュー操作で直接測定することができます。パケットのショート、非永続的なバーストは時々空のキューにつながります。これは、測定値が低い精度になるだろう。キューの長さが特定の閾値（DQ_THRESHOLD）上にあるとき、すなわち、バッファ内に十分なデータがある場合PIEのみ遅延を測定します。それはDQ_THRESHOLDパケットを排出するためにかかる時間PIE対策。具体的には、次のようレート推定を実現することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
current_qdelay = queue_.byte_length() * PIE-&gt;avg_dq_time_/DQ_THRESHOLD;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
current_qdelay = queue_.byte_length（）* PIE-&gt; avg_dq_time_ / DQ_THRESHOLD。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Upon a packet dequeue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*パケットのデキュー時：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if PIE-&gt;in_measurement_ == FALSE and queue.byte_length() &gt;=
      DQ_THRESHOLD:
         PIE-&gt;in_measurement_ = TRUE;
         PIE-&gt;measurement_start_ = now;
         PIE-&gt;dq_count_ = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if PIE-&gt;in_measurement_ == TRUE:
         PIE-&gt;dq_count_ = PIE-&gt;dq_count_ + deque_pkt_size;
         if PIE-&gt;dq_count_ &gt;= DQ_THRESHOLD then
            weight = DQ_THRESHOLD/2^16
            PIE-&gt;avg_dq_time_ = (now - PIE-&gt;measurement_start_) *
                                weight + PIE-&gt;avg_dq_time_ *
                                (1 - weight);
            PIE-&gt;dq_count_ = 0;
            PIE-&gt;measurement_start_ = now
         else
            PIE-&gt;in_measurement_ = FALSE;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The parameter PIE-&gt;dq_count_ represents the number of bytes departed since the last measurement. Once PIE-&gt;dq_count_ is over DQ_THRESHOLD, a measurement sample is obtained. It is recommended that the threshold be set to 16 KB, assuming a typical packet size of around 1 KB or 1.5 KB. This threshold would allow sufficient data to obtain an average draining rate but would also be fast enough (&lt; 64 KB) to reflect sudden changes in the draining rate. If DQ_THRESHOLD is smaller than 64 KB, a small weight is used to smooth out the dequeue time and obtain PIE-&gt;avg_dq_time_. The dequeue rate is simply DQ_THRESHOLD divided by PIE-&gt;avg_dq_time_. This threshold is not crucial for the system&#39;s stability. Please note that the update interval for calculating the drop probability is different from the rate measurement cycle. The drop probability calculation is done periodically per Section 4.2, and it is done even when the algorithm is not in a measurement cycle; in this case, the previously latched value of PIE-&gt;avg_dq_time_ is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パラメータPIE-&gt; dq_count_は、最後の測定以来出発したバイトの数を表します。 PIE-&gt; dq_count_がDQ_THRESHOLD上になると、測定試料が得られます。約1キロバイト又は1.5キロバイトの典型的なパケットサイズを仮定すると、しきい値を16 KBに設定することが推奨されます。このしきい値は、十分なデータが平均排出速度を得ることができるようになるだけでなく、排出速度の急激な変化を反映するために（&lt;64キロバイト）十分に速くなるであろう。 DQ_THRESHOLDが64 KBよりも小さい場合、小さな重みがデキュー時間を平滑化し、PIE-&gt; avg_dq_time_を得るために使用されます。デキュー率は、単にDQ_THRESHOLD PIE-&gt; avg_dq_time_によって分割されています。このしきい値は、システムの安定のために重要ではありません。ドロップ確率を計算するための更新間隔は、速度測定サイクルとは異なることに注意してください。ドロップ確率の計算は、セクション4.2ごと定期的に行われ、アルゴリズムは、測定サイクルにないときにも行われます。この場合、PIE-&gt; avg_dq_time_の以前にラッチされた値が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            Random Drop
                /                     --------------
        -------/  --------------------&gt;    | | | | | --------------&gt;
               /|\             |           | | | | |
                |              |      --------------
                |              |       Queue Buffer
                |              |             |
                |              |             |Queue
                |              |             |Length
                |              |             |
                |             \|/           \|/
                |          ------------------------------
                |          |     Dequeue Rate           |
                -----&lt;-----|  &amp; Drop Probability        |
                           |        Calculation         |
                           ------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 2: The Enqueue-Based PIE Structure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図2：エンキューベースPIE構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In some platforms, enqueuing and dequeuing functions belong to different modules that are independent of each other. In such situations, a pure enqueue-based design can be developed. An enqueue-based design is depicted in Figure 2. The dequeue rate is deduced from the number of packets enqueued and the queue length. The design is based on the following key observation: over a certain time interval, the number of dequeued packets = the number of enqueued packets minus the number of remaining packets in the queue. In this design, everything can be triggered by packet arrival, including the background update process. The design complexity here is similar to the original design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのプラットフォームでは、エンキューおよびデキュー機能は、互いに独立して異なるモジュールに属しています。このような状況では、純粋なエンキューベースの設計を開発することができます。エンキューベースの設計は、デキュー速度がエンキューされたパケットの数とキュー長から推定されている図2に示されています。設計は、以下のキー観察に基づいている：一定時間間隔で、デキューパケット数=キューに入れられたパケットの数を引いキューに残っているパケットの数。この設計では、すべてのものは、バックグラウンド更新プロセスを含め、パケットの到着によってトリガすることができます。ここでは、設計の複雑さは、元のデザインに似ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Setting PIE Active and Inactive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。設定PIEアクティブおよび非アクティブ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Traffic naturally fluctuates in a network. It would be preferable not to unnecessarily drop packets due to a spurious uptick in queuing latency. PIE has an optional feature of automatically becoming active/inactive. To implement this feature, PIE may choose to only become active (from inactive) when the buffer occupancy is over a certain threshold, which may be set to 1/3 of the tail drop threshold. PIE becomes inactive when congestion ends; i.e., when the drop probability reaches 0, current and previous latency samples are all below half of QDELAY_REF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トラフィックは当然ネットワークで変動します。不必要に起因する待ち時間をキューイングにおけるスプリアス景気改善にパケットをドロップしないことが好ましいであろう。 PIEは、自動的にアクティブ/非アクティブになるのオプション機能があります。この機能を実装するために、PIEは、バッファ占有は、テールドロップしきい値の1/3に設定することができる特定の閾値を超えている場合にのみ（非アクティブから）アクティブになることを選択することができます。輻輳が終了したときにPIEは非アクティブになり、即ち、ドロップ確率が0に達したときに、現在および前の待ち時間サンプルは全てQDELAY_REFの半分以下です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ideally, PIE should become active/inactive based on latency. However, calculating latency when PIE is inactive would introduce unnecessary packet-processing overhead. Weighing the trade-offs, we decided to compare against the tail drop threshold to keep things simple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
理想的には、PIEは、待ち時間に基づいて、アクティブ/非アクティブになる必要があります。しかし、PIEがアクティブでないときの待ち時間を計算することは、不必要なパケット処理のオーバーヘッドをご紹介します。トレードオフを計量、我々は物事をシンプルに保つために、テールドロップしきい値と比較することにしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When PIE optionally becomes active/inactive, the burst protection logic described in Section 4.4 is modified as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEは、必要に応じてアクティブ/非アクティブになると、次のように、セクション4.4に記載バースト保護ロジックが変更されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* &#34;Random dropping&#34; block: PIE adds the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*「ランダムドロップ」ブロック：PIEは、以下を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon packet arrival:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケット到着すると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if PIE-&gt;active_ == FALSE &amp;&amp; queue_length &gt;= TAIL_DROP/3:
         PIE-&gt;active_ = TRUE;
         PIE-&gt;burst_allowance_ = MAX_BURST;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if PIE-&gt;burst_allowance_ &gt; 0 enqueue packet; else randomly drop a packet with a probability of PIE-&gt;drop_prob_.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt; burst_allowance_&gt; 0エンキューパケットであれば、他のランダムPIE-&gt; drop_prob_の確率でパケットをドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      if (PIE-&gt;drop_prob_ == 0 and current_qdelay &lt; QDELAY_REF/2 and
          PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2)
          PIE-&gt;active_ = FALSE;
          PIE-&gt;burst_allowance_ = MAX_BURST;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* &#34;Drop probability calculation&#34; block: PIE does the following: if PIE-&gt;active_ == TRUE: PIE-&gt;burst_allowance_ = max(0,PIE-&gt;burst_allowance_ - T_UPDATE);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* &#34;ドロップ確率計算&#34; ブロック：もしPIE-&gt; active_ == TRUE：PIEは、次の処理を行いPIE-&gt; burst_allowance_ = MAX（0、PIE-&gt; burst_allowance_  -  T_UPDATE）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Derandomization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。 Derandomization
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although PIE adopts random dropping to achieve latency control, independent coin tosses could introduce outlier situations where packets are dropped too close to each other or too far from each other. This would cause the real drop percentage to temporarily deviate from the intended value PIE-&gt;drop_prob_. In certain scenarios, such as a small number of simultaneous TCP flows, these deviations can cause significant deviations in link utilization and queuing latency. PIE may use a derandomization mechanism to avoid such situations. A parameter called &#34;PIE-&gt;accu_prob_&#34; is reset to 0 after a drop. Upon packet arrival, PIE-&gt;accu_prob_ is incremented by the amount of drop probability, PIE-&gt;drop_prob_. If PIE-&gt;accu_prob_ is less than a low threshold, e.g., 0.85, the arriving packet is enqueued; on the other hand, if PIE-&gt;accu_prob_ is more than a high threshold, e.g., 8.5, and the queue is congested, the arrival packet is forced to be dropped. A packet is only randomly dropped if PIE-&gt;accu_prob_ falls between the two thresholds. Since PIE-&gt;accu_prob_ is reset to 0 after a drop, another drop will not happen until 0.85/PIE-&gt;drop_prob_ packets later. This avoids packets being dropped too close to each other. In the other extreme case where 8.5/PIE-&gt;drop_prob_ packets have been enqueued without incurring a drop, PIE would force a drop in order to prevent the drops from being spaced too far apart. Further analysis can be found in [RFC8034].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEは、レイテンシ制御を実現するためにランダムドロップを採用していますが、独立したコイン投げは、パケットがお互いに近すぎるまたは遠すぎる互いからドロップされる外れ値の状況を紹介することができます。これは、一時的に意図した値PIE-&gt; drop_prob_から逸脱し、実際のドロップ率を引き起こします。こうした同時TCPフローの数が少ないなどの特定のシナリオでは、これらの偏差は、リンクの利用率とキューイングの待ち時間が大幅に逸脱を引き起こす可能性があります。 PIEは、このような状況を避けるために、derandomizationメカニズムを使用することができます。 「accu_prob_ PIE-&gt;」と呼ばれるパラメータが低下した後、0にリセットされます。パケット到着時、PIE-&gt; accu_prob_はPIE-&gt; drop_prob_、廃棄確率の量だけインクリメントされます。 PIE-&gt; accu_prob_が低閾値未満である場合、例えば、0.85、到着パケットがエンキューされます。 PIE-&gt; accu_prob_は、例えば、8.5高い閾値以上であり、キューが輻輳している一方、到着パケットがドロップされることを余儀なくされます。 PIE-&gt; accu_prob_が2つの閾値の間に低下した場合、パケットはランダムに廃棄されます。 PIE-ため&gt; accu_prob_ドロップ後に0にリセットされ、別の低下は0.85 / PIE-&gt; drop_prob_パケット後まで起こらないであろう。これはお互いに近すぎてドロップされるパケットを回避することができます。 8.5 / PIE-&gt; drop_prob_パケットが低下を招くことなくエンキューされている他の極端な場合では、PIEはあまりにも遠くに離間されることから液滴を防止するために、ドロップを強制することになります。さらなる分析は、[RFC8034]に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Cap Drop Adjustment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。キャップドロップ調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of a single TCP flow, during the slow-start phase the queue could quickly increase, which could result in a very rapid increase in drop probability. In order to prevent an excessive ramp-up that could negatively impact the throughput in this scenario, PIE can cap the maximum drop probability increase in each step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一のTCPフローの場合は、スロースタートフェーズの間にキューはすぐにドロップ確率の非常に急速な増加につながる可能性がある、増加する可能性があります。負このシナリオではスループットに影響を与える可能性が過剰なランプアップを防止するために、PIEは、各ステップにおける最大廃棄確率の増加をキャップすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* &#34;Drop probability calculation&#34; block: PIE adds the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*「ドロップ確率計算」ブロック：PIEは以下を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (PIE-&gt;drop_prob_ &gt;= 0.1 &amp;&amp; p &gt; 0.02) { p = 0.02; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IF（PIE-&gt; drop_prob_&gt; = 0.1 &amp;&amp; P&gt; 0.02）{P = 0.02。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Implementation Cost
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.実装コスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE can be applied to existing hardware or software solutions. There are three steps involved in PIE, as discussed in Section 4. Their complexities are examined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEは、既存のハードウェアやソフトウェアのソリューションに適用することができます。彼らの複雑さを以下に検討されている第4節で述べたように、PIEに関わる3つのステップがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon packet arrival, the algorithm simply drops a packet randomly, based on the drop probability. This step is straightforward and requires no packet header examination and manipulation. If the implementation doesn&#39;t rely on packet timestamps for calculating latency, PIE does not require extra memory. Furthermore, the input side of a queue is typically under software control while the output side of a queue is hardware based. Hence, a drop at enqueuing can be readily retrofitted into existing or software implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットの到着時に、アルゴリズムは、単に廃棄確率に基づいて、ランダムにパケットをドロップ。このステップは単純で、何のパケットヘッダの検査や操作を必要としません。実装は、待ち時間を計算するためのパケットのタイムスタンプに依存していない場合は、PIEは、余分なメモリを必要としません。キューの出力側は、ハードウェアベースでありながら、さらに、キューの入力側は、ソフトウェアの制御下にあるのが典型的です。従って、エンキューのドロップを容易に既存のまたはソフトウェア実装に改造することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The drop probability calculation is done in the background, and it occurs every T_UPDATE interval. Given modern high-speed links, this period translates into once every tens, hundreds, or even thousands of packets. Hence, the calculation occurs at a much slower time scale than the packet-processing time -- at least an order of magnitude slower. The calculation of drop probability involves multiplications using alpha and beta. Since PIE&#39;s control law is robust to minor changes in alpha and beta values, an implementation MAY choose these values to the closest multiples of 2 or 1/2 (e.g., alpha = 1/8, beta = 1 + 1/4) such that the multiplications can be done using simple adds and shifts. As no complicated functions are required, PIE can be easily implemented in both hardware and software. The state requirement is only three variables per queue: burst_allowance_, PIE-&gt;drop_prob_, and PIE-&gt;qdelay_old_. Hence, the memory overhead is small.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドロップ確率の計算は、バックグラウンドで行われ、それがすべてのT_UPDATE間隔を発生しています。現代の高速リンクを考えると、この期間は、パケットの回数十、数百、あるいは数千に変換されます。少なくとも一桁遅い - したがって、計算は、パケット処理時間よりもはるかに遅い時間スケールで発生します。ドロップ確率の計算は、アルファおよびベータを使用して乗算することを含みます。 PIEの制御則は、アルファとベータ値の小さな変化に対してロバストであるので、実装は2または1/2の最も近い倍数にこれらの値を選択する（例えば、アルファ= 1/8、ベータ= 1 + 1/4）ことができるように、乗算は加算とシフトの簡単な使用して行うことができます。複雑な機能が必要とされないように、PIEが容易ハードウェアとソフトウェアの両方で実施することができます。 burst_allowance_、PIE-&gt; drop_prob_、およびPIE-&gt; qdelay_old_：状態の要件は、キューごとに3つだけの変数です。したがって、メモリのオーバーヘッドは小さいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If one chooses to implement the departure rate estimation, PIE uses a counter to keep track of the number of bytes departed for the current interval. This counter is incremented per packet departure. Every T_UPDATE, PIE calculates latency using the departure rate, which can be implemented using a single multiply operation. Note that many network devices keep track of an interface&#39;s departure rate. In this case, PIE might be able to reuse this information and simply skip the third step of the algorithm; hence, it would incur no extra cost. If a platform already leverages packet timestamps for other purposes, PIE can make use of these packet timestamps for latency calculation instead of estimating the departure rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1出発率の推定を実施することを選択した場合、PIEは、現在の間隔のために出発したバイト数を追跡​​するためにカウンタを使用しています。このカウンタは、パケットの出発ごとにインクリメントされます。すべてのT_UPDATEは、PIEは、待ち時間は、単一の乗算演算を用いて実現することができる出発率を、使用して計算します。多くのネットワーク機器は、インタフェースの出発率を追跡することに注意してください。この場合、PIEは、この情報を再利用し、単にアルゴリズムの第3工程を省略することができるかもしれません。したがって、それは余分なコストが発生しないだろう。プラットフォームはすでに他の目的のためにパケットのタイムスタンプを利用した場合、PIEは、代わりに出発率を推定レイテンシ計算のために、これらのパケットのタイムスタンプを利用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Flow queuing can also be combined with PIE to provide isolation between flows. In this case, it is preferable to have an independent value of drop probability per queue. This allows each flow to receive the most appropriate level of congestion signal and ensures that sparse flows are protected from experiencing packet drops. However, running the entire PIE algorithm independently on each queue in order to calculate the drop probability may be overkill. Furthermore, in the case where departure rate estimation is used to predict queuing latency, it is not possible to calculate an accurate per-queue departure rate upon which to implement the PIE drop probability calculation. Instead, it has been proposed [DOCSIS-AQM] that a single implementation of the PIE drop probability calculation based on the overall latency estimate be used, followed by a per-queue scaling of drop probability based on the ratio of queue depth between the queue in question and the current largest queue. This scaling is reasonably simple and has a couple of nice properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フローイングはまた、フロー間のアイソレーションを提供するために、PIEと組み合わせることができます。この場合には、キューごとの廃棄確率の独立した値を有することが好ましいです。これは、各フローが輻輳信号の最も適切なレベルを受信することを可能にし、疎なフローがパケットドロップを経験から保護されることを保証します。しかし、ドロップ確率を計算するために、各キューに独立して全体PIEアルゴリズムを実行することは行き過ぎかもしれません。さらに、出発率推定がキューイング遅延を予測するために使用される場合には、PIEドロップ確率の計算を実施するため、その上に正確あたりキュー出発率を算出することは不可能です。代わりに、キュー間のキューの深さの比率に基づいて、廃棄確率の当たりキュースケーリング続いて、全体的な待ち時間推定値に基づいてPIEドロップ確率計算の単一の実装を使用すること[DOCSIS-AQM]提案されています問題の現在の最大のキュー。このスケーリングは、合理的に単純で、素敵な性質のカップルを持っています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* If a packet is arriving to an empty queue, it is given immunity from packet drops altogether, regardless of the state of the other queues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットが空のキューに到着された場合*、それは関係なく、他のキューの状態の、完全にパケットドロップから免疫力を与えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* In the situation where only a single queue is in use, the algorithm behaves exactly like the single-queue PIE algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*唯一の単一のキューが使用されている状況では、このアルゴリズムは、正確に、単一のキューPIEアルゴリズムのように振る舞います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In summary, PIE is simple enough to be implemented in both software and hardware.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要約すると、PIEは、ソフトウェアとハ​​ードウェアの両方に実装されるのに十分に簡単です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Scope of Experimentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
実験の7範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The design of the PIE algorithm is presented in this document. The PIE algorithm effectively controls the average queuing latency to a target value. The following areas can be used for further study and experimentation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEアルゴリズムの設計は、この文書に提示されています。 PIEアルゴリズムは効果的に目標値に平均キューイング遅延を制御します。以下の分野ではさらなる研究と実験のために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Autotuning of target latency without losing utilization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*利用を失うことなく、ターゲットの待ち時間のオートチューニング。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Autotuning for the average round-trip time of traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*トラフィックの平均往復時間のためにオートチューニング。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* The proper threshold to transition smoothly between ECN marking and dropping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*適切な閾値がECNマーキングおよび滴下の間で円滑に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* The enhancements described in Section 5, which can be used in experiments to see if they would be of more value in the real world. If so, they will be incorporated into the basic PIE algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*彼らは現実の世界でより多くの価値があるかどうかを確認するために実験に使用することができ、セクション5で説明した機能強化、。もしそうなら、彼らは基本的なPIEアルゴリズムに組み込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* The PIE design, which is separated into the data path and the control path. The control path can be implemented in software. Field tests of other control laws can be performed to experiment with further improvements to PIE&#39;s performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*データ経路と制御経路とに分離されるPIE設計、。制御パスは、ソフトウェアで実現することができます。他の制御法のフィールドテストでは、PIEのパフォーマンスにさらなる改善を試してみるために行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although all network nodes cannot be changed altogether to adopt latency-based AQM schemes such as PIE, a gradual adoption would eventually lead to end-to-end low-latency service for all applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのネットワーク・ノードは、PIEなどの待ち時間に基づくAQM方式を採用することを完全に変更することはできないものの、緩やかな採用は、最終的にすべてのアプリケーションのエンドツーエンドの低遅延のサービスにつながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Incremental Deployment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.増分の展開
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
From testbed experiments and large-scale simulations of PIE so far, PIE has been shown to be effective across a diverse range of network scenarios. There is no indication that PIE would be harmful to deploy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
テストベッド実験とこれまでのPIEの大規模シミュレーションからは、PIEは、ネットワークシナリオの多様な範囲で有効であることが示されています。 PIEが展開する有害だろう兆候はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PIE scheme can be independently deployed and managed without a need for interoperability between different network devices. In addition, any individual buffer queue can be incrementally upgraded to PIE, as it can coexist with existing AQM schemes such as Weighted RED (WRED).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE方式は、独立して異なるネットワークデバイス間の相互運用性を必要とせずに展開し、管理することができます。そのような重み付けRED（WRED）などの既存AQM方式と共存できるように加えて、任意の個々のバッファ・キューは、増分、PIEにアップグレードすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE is intended to be self-configuring. Users should not need to configure any design parameters. Upon installation, the two user-configurable parameters -- QDELAY_REF and MAX_BURST -- will be defaulted to 15 milliseconds and 150 milliseconds for non-data-center network devices and to 15 microseconds and 150 microseconds for data-center switches, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIEは、自己構成であることを意図しています。ユーザーは任意の設計パラメータを設定する必要はありません。インストール時に、2つのユーザ設定可能なパラメータ -  QDELAY_REFとMAX_BURST  - は、それぞれ、非データセンタネットワーク装置のための15ミリ秒と150ミリ秒と15ミリ秒とデータセンタースイッチ150マイクロ秒にデフォルト設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the data path of the algorithm needs only a simple coin toss and the control-path calculation happens in a much slower time scale, we don&#39;t foresee any scaling issues associated with the algorithm as the link speed scales up.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アルゴリズムのデータパスだけなので、簡単なコイントスを必要とし、コントロール・パスの計算がはるかに遅い時間スケールで起こるリンク速度がスケールアップとして、我々は、アルゴリズムに関連付けられた任意のスケーリングの問題を予見していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes PIE, an active queue management algorithm based on implementations in different products. The PIE algorithm introduces no specific security exposures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、PIE、さまざまな製品の実装に基づいて、アクティブキュー管理アルゴリズムを記述しています。 PIEアルゴリズムには、特定のセキュリティ・エクスポージャーを紹介しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC970] Nagle, J., &#34;On Packet Switches With Infinite Storage&#34;, RFC 970, DOI 10.17487/RFC0970, December 1985, &lt;http://www.rfc-editor.org/info/rfc970&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC970]ネーグル、J.、 &#34;無限のストレージを持つパケットスイッチオン&#34;、RFC 970、DOI 10.17487 / RFC0970、1985年12月、&lt;http://www.rfc-editor.org/info/rfc970&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, &#34;Recommendations on Queue Management and Congestion Avoidance in the Internet&#34;, RFC 2309, DOI 10.17487/RFC2309, April 1998, &lt;http://www.rfc-editor.org/info/rfc2309&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2309]ブレーデン、B.、クラーク、D.、クロウクロフト、J.、デイビー、B.、デアリング、S.、Estrin、D.、フロイド、S.、ヤコブソン、V.、Minshall、G.、ヤマウズラ、 C.、ピーターソン、L.、ラマクリシュナン、K.、Shenker、S.、Wroclawski、J.、およびL.チャン、 &#34;インターネットの待ち行列管理と輻輳回避に関する提言&#34;、RFC 2309、DOI 10.17487 / RFC2309、4月1998年、&lt;http://www.rfc-editor.org/info/rfc2309&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7567] Baker, F., Ed., and G. Fairhurst, Ed., &#34;IETF Recommendations Regarding Active Queue Management&#34;, BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, &lt;http://www.rfc-editor.org/info/rfc7567&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7567]ベイカー、F.、エド、およびG. Fairhurst、エド、 &#34;アクティブキュー管理についてIETF勧告&#34;、BCP 197、RFC 7567、DOI 10.17487 / RFC7567、2015年7月、&lt;のhttp：。。//www.rfc -editor.org/info/rfc7567&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7806] Baker, F. and R. Pan, &#34;On Queuing, Marking, and Dropping&#34;, RFC 7806, DOI 10.17487/RFC7806, April 2016, &lt;http://www.rfc-editor.org/info/rfc7806&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7806]ベーカー、F. R.及びパン、 &#34;キューに、マーキング、および削除&#34;、RFC 7806、DOI 10.17487 / RFC7806、2016年4月、&lt;http://www.rfc-editor.org/info/rfc7806&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8034] White, G. and R. Pan, &#34;Active Queue Management (AQM) Based on Proportional Integral Controller Enhanced (PIE) for Data-Over-Cable Service Interface Specifications (DOCSIS) Cable Modems&#34;, RFC 8034, DOI 10.17487/RFC8034, February 2017, &lt;http://www.rfc-editor.org/info/rfc8034&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8034]ホワイト、G.およびR.パン、「アクティブキュー管理（AQM）データオーバーケーブルサービスインターフェイス仕様のための比例積分制御の拡張（PIE）に基づいて（DOCSIS）ケーブルモデム」、RFC 8034、DOI 10.17487 / RFC8034、2017年2月、&lt;http://www.rfc-editor.org/info/rfc8034&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CBQ] Cisco, &#34;Class-Based Weighted Fair Queueing&#34;, &lt;http://www.cisco.com/en/US/docs/ios/12_0t/12_0t5/ feature/guide/cbwfq.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CBQ]シスコ、 &#34;クラスベース均等化キューイング&#34;、&lt;http://www.cisco.com/en/US/docs/ios/12_0t/12_0t5/機能/ガイド/ cbwfq.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CoDel] Nichols, K. and V. Jacobson, &#34;Controlling Queue Delay&#34;, Communications of the ACM, Volume 55, Issue 7, pp. 42-50, DOI 10.1145/2209249.2209264, July 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【CODEL]ニコルズ、K.およびV. Jacobsonの &#34;制御しているキューの遅延&#34;、ACMのコミュニケーション、55巻、7号、PP。42-50、DOI 10.1145 / 2209249.2209264、2012年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DOCSIS_3.1] CableLabs, &#34;MAC and Upper Layer Protocols Interface Specification&#34;, DOCSIS 3.1, January 2017, &lt;https://apps.cablelabs.com/specification/ CM-SP-MULPIv3.1&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DOCSIS_3.1] CableLabsの、 &#34;MAC上位層プロトコルインタフェース仕様&#34;、DOCSIS 3.1、2017年1月、&lt;https://apps.cablelabs.com/specification/ CM-SP-MULPIv3.1&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DOCSIS-AQM] White, G., &#34;Active Queue Management in DOCSIS 3.x Cable Modems&#34;, May 2014, &lt;http://www.cablelabs.com/wp-content/ uploads/2014/06/DOCSIS-AQM_May2014.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DOCSIS-AQM]ホワイト、G.、 &#34;DOCSIS 3.xのケーブルモデムでのアクティブキュー管理&#34;、2014年5月、&lt;http://www.cablelabs.com/wp-content/アップロード/ 2014/06 / DOCSIS-AQM_May2014 .PDF&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ECN] Briscoe, B., Kaippallimalil, J., and P. Thaler, &#34;Guidelines for Adding Congestion Notification to Protocols that Encapsulate IP&#34;, Work in Progress, draft-ietf-tsvwg-ecn-encap-guidelines-07, July 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ECN]ブリスコウ、B.、Kaippallimalil、J.、およびP.ターラー、進行中で働いて、ドラフトIETF-TSVWG-ECN-ENCAP-ガイドライン-07、2011 &#34;そのカプセル化IPのプロトコルに輻輳通知を追加するためのガイドライン&#34; 2016。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HPSR-PIE] Pan, R., Natarajan, P., Piglione, C., Prabhu, M.S., Subramanian, V., Baker, F., and B. Ver Steeg, &#34;PIE: A lightweight control scheme to address the bufferbloat problem&#34;, IEEE HPSR, DOI 10.1109/HPSR.2013.6602305, 2013, &lt;https://www.researchgate.net/publication/ 261134127_PIE_A_lightweight_control_scheme_to_address_ the_bufferbloat_problem?origin=mail&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HPSR-PIE]パン、R.、Natarajan、P.、Piglione、C.、プラブー、MS、スブラマニアン、V.、ベイカー、F.、およびB.版シュテーク、「PIE：対処するための軽量制御方式bufferbloat問題」、IEEE HPSR、DOI 10.1109 / HPSR.2013.6602305、2013年、&lt;https://www.researchgate.net/publication/ 261134127_PIE_A_lightweight_control_scheme_to_address_ the_bufferbloat_problem？起源=メール&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PI] Hollot, C.V., Misra, V., Towsley, D., and W. Gong, &#34;On designing improved controllers for AQM routers supporting TCP flows&#34;, INFOCOM 2001, DOI 10.1109/INFCOM.2001.916670, April 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、インフォコム2001、DOI 10.1109 / INFCOM.2001.916670、2001年4月 &#34;TCPフローをサポートするAQMルータのための改良されたコントローラを設計する上で&#34; [PI] Hollot、C.V.、ミスラ、V.、Towsley、D.、およびW.ゴング、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[QCN] IEEE, &#34;IEEE Standard for Local and Metropolitan Area Networks--Virtual Bridged Local Area Networks - Amendment: 10: Congestion Notification&#34;, IEEE 802.1Qau, &lt;http://www.ieee802.org/1/pages/802.1au.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[QCN] IEEE、 &#34;地方とメトロポリタンエリアネットワークのIEEE標準 - 仮想ブリッジローカルエリアネットワーク - 修正：10：輻輳通知&#34;、IEEE 802.1Qau、&lt;http://www.ieee802.org/1/pages/802.1 au.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RED] Floyd, S. and V. Jacobson, &#34;Random Early Detection (RED) Gateways for Congestion Avoidance&#34;, IEEE/ACM Transactions on Networking, Volume 1, Issue 4, DOI 10.1109/90.251892, August 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[赤]フロイド、S.およびV. Jacobsonの &#34;ランダム早期検出（RED）ゲートウェイ輻輳回避のための&#34;、ネットワーク上のIEEE / ACMトランザクション、第1巻、第4号、DOI 10.1109 / 90.251892、1993年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TCP-Models] Misra, V., Gong, W., and D. Towsley, &#34;Fluid-based analysis of a network of AQM routers supporting TCP flows with an application to RED&#34;, SIGCOMM 2000, Volume 30, Issue 4, pp. 151-160, DOI 10.1145/347057.347421, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TCP-モデル] Misraの、V.、ゴング、W.、およびD. Towsley、SIGCOMM 2000、30巻、第4号 &#34;TCPは、REDのアプリケーションに流れる支持AQMルータのネットワークの流体ベースの解析&#34;、 PP。151-160、DOI 10.1145 / 347057.347421、2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. The Basic PIE Pseudocode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A.基本的なPIE擬似コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Configurable parameters: - QDELAY_REF. AQM Latency Target (default: 15 milliseconds) - MAX_BURST. AQM Max Burst Allowance (default: 150 milliseconds)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
設定可能なパラメータ： -  QDELAY_REF。 AQMレイテンシターゲット（デフォルト：15ミリ秒） -  MAX_BURST。 AQMマックスは、手当をバースト（デフォルト：150ミリ秒）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Internal parameters: - Weights in the drop probability calculation (1/s): alpha (default: 1/8), beta (default: 1 + 1/4) - T_UPDATE: a period to calculate drop probability (default: 15 milliseconds)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
内部パラメータ： - ドロップ確率計算（1 /秒）における重み：アルファ（デフォルト：1/8）、ベータ（デフォルト：1 + 1/4） -  T_UPDATE：廃棄確率を算出する期間（デフォルト：15ミリ秒）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table that stores status variables (ending with &#34;_&#34;): - burst_allowance_: current burst allowance - drop_prob_: The current packet drop probability. Reset to 0 - qdelay_old_: The previous queue delay. Reset to 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータス変数を格納する表（「_」で終わる）： -  burst_allowance_：現在のバースト手当 -  drop_prob_：現在のパケットドロップ確率。 0にリセット -  qdelay_old_：以前のキュー遅延。 0にリセット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Public/system functions: - queue_. Holds the pending packets - drop(packet). Drops/discards a packet - now(). Returns the current time - random(). Returns a uniform r.v. in the range 0 ~ 1 - queue_.byte_length(). Returns current queue_ length in bytes - queue_.enque(packet). Adds packet to tail of queue_ - queue_.deque(). Returns the packet from the head of queue_ - packet.size(). Returns size of packet - packet.timestamp_delay(). Returns timestamped packet latency
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
公開/システムの機能： -  queue_。ドロップ（パケット） - 保留中のパケットを保持します。ドロップス/パケットを破棄する - 今（）。現在の時刻を返します - ランダム（）。均一r.v.を返します。範囲は0〜1  -  queue_.byte_length（）。 queue_.enque（パケット） - 現在のqueue_の長さをバイト単位で返します。 queue_の末尾にパケットを追加 -  queue_.dequeを（）。 queue_の先頭からパケットを返します -  packet.sizeは（）。パケットのサイズを返す -  packet.timestamp_delay（）。タイムスタンプ付きパケットの遅延を返します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   //Called on each packet arrival
     enque(Packet packet) {
          if (PIE-&gt;drop_prob_ == 0 &amp;&amp; current_qdelay &lt; QDELAY_REF/2
              &amp;&amp; PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2) {
              PIE-&gt;burst_allowance_ = MAX_BURST;
          }
          if (PIE-&gt;burst_allowance_ == 0 &amp;&amp; drop_early() == DROP) {
                   drop(packet);
          } else {
                   queue_.enque(packet);
          }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
drop_early() {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
drop_early（）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         //Safeguard PIE to be work conserving
         if ( (PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2 &amp;&amp; PIE-&gt;drop_prob_ &lt; 0.2)
               || (queue_.byte_length() &lt;= 2 * MEAN_PKTSIZE) ) {
              return ENQUE;
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         double u = random();
         if (u &lt; PIE-&gt;drop_prob_) {
              return DROP;
         } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return ENQUE; } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ENQUEUEを返します。 }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//We choose the timestamp option of obtaining latency for clarity //Rate estimation method can be found in the extended PIE pseudocode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//私たちは、拡張PIEの擬似コードで見つけることができますレート推定法//明確にするための待ち時間を取得するタイムスタンプオプションを選択してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
deque(Packet packet) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
及び（パケットパケット）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 current_qdelay = packet.timestamp_delay(); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
current_qdelay = packet.timestamp_delay（）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//Update periodically, T_UPDATE = 15 milliseconds
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//更新定期的に、T_UPDATE = 15ミリ秒
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
calculate_drop_prob() {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
calculate_drop_prob（）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//Can be implemented using integer multiply
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//は、整数乗算を使用して実装することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
p = alpha * (current_qdelay - QDELAY_REF) + \ beta * (current_qdelay - PIE-&gt;qdelay_old_);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
P =アルファ*（current_qdelay  -  QDELAY_REF）+ \ベータ*（current_qdelay  -  PIE-&gt; qdelay_old_）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          if (PIE-&gt;drop_prob_ &lt; 0.000001) {
              p /= 2048;
          } else if (PIE-&gt;drop_prob_ &lt; 0.00001) {
              p /= 512;
          } else if (PIE-&gt;drop_prob_ &lt; 0.0001) {
              p /= 128;
          } else if (PIE-&gt;drop_prob_ &lt; 0.001) {
              p /= 32;
          } else if (PIE-&gt;drop_prob_ &lt; 0.01) {
              p /= 8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          } else if (PIE-&gt;drop_prob_ &lt; 0.1) {
              p /= 2;
          } else {
              p = p;
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt;drop_prob_ += p;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt; drop_prob_ + = P;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//Exponentially decay drop prob when congestion goes away if (current_qdelay == 0 &amp;&amp; PIE-&gt;qdelay_old_ == 0) { PIE-&gt;drop_prob_ *= 0.98; //1 - 1/64 is //sufficient }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳がなくなったときに指数関数的に減衰ドロップPROB // IF（current_qdelay == 0 &amp;&amp; PIE-&gt; qdelay_old_ == 0）{PIE-&gt; drop_prob_ * = 0.98。 // 1  -  1/64} //十分です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//Bound drop probability if (PIE-&gt;drop_prob_ &lt; 0) PIE-&gt;drop_prob_ = 0.0 if (PIE-&gt;drop_prob_ &gt; 1) PIE-&gt;drop_prob_ = 1.0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//バウンドドロップ確率IF（PIE-&gt; drop_prob_ &lt;0）PIE-&gt; drop_prob_ = 0.0であれば（PIE-&gt; drop_prob_&gt; 1）PIE-&gt; drop_prob_ = 1.0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt;qdelay_old_ = current_qdelay;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt; qdelay_old_ = current_qdelay。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 PIE-&gt;burst_allowance_ = max(0,PIE-&gt;burst_allowance_ - T_UPDATE); } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIE-&gt; burst_allowance_ = MAX（0、PIE-&gt; burst_allowance_  -  T_UPDATE）。 }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B. Pseudocode for PIE with Optional Enhancement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションの強化とPIE付録B.擬似コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Configurable parameters: - QDELAY_REF. AQM Latency Target (default: 15 milliseconds) - MAX_BURST. AQM Max Burst Allowance (default: 150 milliseconds) - MAX_ECNTH. AQM Max ECN Marking Threshold (default: 10%)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
設定可能なパラメータ： -  QDELAY_REF。 AQMレイテンシターゲット（デフォルト：15ミリ秒） -  MAX_BURST。 AQMマックスは、手当（デフォルト：150ミリ秒）バースト -  MAX_ECNTHを。しきい値をマーキングAQMマックスECN（デフォルト：10％）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Internal parameters: - Weights in the drop probability calculation (1/s): alpha (default: 1/8), beta (default: 1 + 1/4) - DQ_THRESHOLD: (in bytes, default: 2^14 (in a power of 2) ) - T_UPDATE: a period to calculate drop probability (default: 15 milliseconds) - TAIL_DROP: the tail drop threshold (max allowed queue depth) for the queue
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
内部パラメータ： - ドロップ確率計算（1 /秒）における重み：アルファ（デフォルト：1/8）、ベータ（デフォルト：1 + 1/4） -  DQ_THRESHOLD：（バイト、デフォルト：2 ^ 14（INドロップ確率を計算するための期間（デフォルト：15ミリ秒） -  TAIL_DROP：テールドロップしきい値（最大許容されるキューの深さ）キューのT_UPDATE  -  2））のパワー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table that stores status variables (ending with &#34;_&#34;): - active_: INACTIVE/ACTIVE - burst_allowance_: current burst allowance - drop_prob_: The current packet drop probability. Reset to 0 - accu_prob_: Accumulated drop probability. Reset to 0 - qdelay_old_: The previous queue delay estimate. Reset to 0 - last_timestamp_: Timestamp of previous status update - dq_count_, measurement_start_, in_measurement_, avg_dq_time_. Variables for measuring average dequeue rate
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
状態変数を格納するテーブル（で終わる &#34;_&#34;）： -  active_：INACTIVE / ACTIVE  -  burst_allowance_：現在のバースト手当 -  drop_prob_：現在のパケットドロップ確率。 0にリセット -  accu_prob_：累積ドロップ確率を。 0にリセット -  qdelay_old_：以前のキュー遅延推定。 0にリセット -  last_timestamp_：前回のステータス更新のタイムスタンプ -  dq_count_、measurement_start_、in_measurement_、avg_dq_time_。平均デキュー率を測定するための変数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Public/system functions: - queue_. Holds the pending packets - drop(packet). Drops/discards a packet - mark(packet). Marks ECN for a packet - now(). Returns the current time - random(). Returns a uniform r.v. in the range 0 ~ 1 - queue_.byte_length(). Returns current queue_ length in bytes - queue_.enque(packet). Adds packet to tail of queue_ - queue_.deque(). Returns the packet from the head of queue_ - packet.size(). Returns size of packet - packet.ecn(). Returns whether packet is ECN capable or not
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
公開/システムの機能： -  queue_。ドロップ（パケット） - 保留中のパケットを保持します。マーク（パケット） - ドロップ/パケットを破棄する。 ECNは、パケット用のマーク - 今（）。現在の時刻を返します - ランダム（）。均一r.v.を返します。範囲は0〜1  -  queue_.byte_length（）。 queue_.enque（パケット） - 現在のqueue_の長さをバイト単位で返します。 queue_の末尾にパケットを追加 -  queue_.dequeを（）。 queue_の先頭からパケットを返します -  packet.sizeは（）。パケットのサイズを返す -  packet.ecn（）。パケットがECN対応であるかどうかを返します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   //Called on each packet arrival
     enque(Packet packet) {
          if (queue_.byte_length() + packet.size() &gt; TAIL_DROP) {
                 drop(packet);
                 PIE-&gt;accu_prob_ = 0;
          } else if (PIE-&gt;active_ == TRUE &amp;&amp; drop_early() == DROP
                     &amp;&amp; PIE-&gt;burst_allowance_ == 0) {
                 if (PIE-&gt;drop_prob_ &lt; MAX_ECNTH &amp;&amp; packet.ecn() ==
                     TRUE)
                       mark(packet);
                 else
                       drop(packet);
                       PIE-&gt;accu_prob_ = 0;
          } else {
                 queue_.enque(packet);
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //If the queue is over a certain threshold, turn on PIE
          if (PIE-&gt;active_ == INACTIVE
              &amp;&amp; queue_.byte_length() &gt;= TAIL_DROP/3) {
               PIE-&gt;active_ = ACTIVE;
               PIE-&gt;qdelay_old_ = 0;
               PIE-&gt;drop_prob_ = 0;
               PIE-&gt;in_measurement_ = TRUE;
               PIE-&gt;dq_count_ = 0;
               PIE-&gt;avg_dq_time_ = 0;
               PIE-&gt;last_timestamp_ = now;
               PIE-&gt;burst_allowance_ = MAX_BURST;
               PIE-&gt;accu_prob_ = 0;
               PIE-&gt;measurement_start_ = now;
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //If the queue has been idle for a while, turn off PIE
          //Reset counters when accessing the queue after some idle
          //period if PIE was active before
          if ( PIE-&gt;drop_prob_ == 0 &amp;&amp; PIE-&gt;qdelay_old_ == 0
               &amp;&amp; current_qdelay == 0) {
               PIE-&gt;active_ = INACTIVE;
               PIE-&gt;in_measurement_ = FALSE;
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
drop_early() {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
drop_early（）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         //PIE is active but the queue is not congested: return ENQUE
         if ( (PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2 &amp;&amp; PIE-&gt;drop_prob_ &lt; 0.2)
               || (queue_.byte_length() &lt;= 2 * MEAN_PKTSIZE) ) {
              return ENQUE;
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (PIE-&gt;drop_prob_ == 0) { PIE-&gt;accu_prob_ = 0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（PIE-&gt; drop_prob_ == 0）{PIE-&gt; accu_prob_ = 0の場合。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//For practical reasons, drop probability can be further scaled //according to packet size, but one needs to set a bound to //avoid unnecessary bias
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//は、実用的な理由から、廃棄確率はさらに、パケットサイズに従って//スケーリングすることができるが、一方は不要バイアスを避ける//にバインド設定する必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         //Random drop
         PIE-&gt;accu_prob_ += PIE-&gt;drop_prob_;
         if (PIE-&gt;accu_prob_ &lt; 0.85)
             return ENQUE;
         if (PIE-&gt;accu_prob_ &gt;= 8.5)
             return DROP;
                 double u = random();
         if (u &lt; PIE-&gt;drop_prob_) {
                      PIE-&gt;accu_prob_ = 0;
                      return DROP;
         } else {
                      return ENQUE;
         }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//Update periodically, T_UPDATE = 15 milliseconds calculate_drop_prob() { if ( (now - PIE-&gt;last_timestamp_) &gt;= T_UPDATE &amp;&amp; PIE-&gt;active_ == ACTIVE) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//更新周期的に、T_UPDATE = 15ミリ秒calculate_drop_prob（）{IF（（現在 -  PIE-&gt; last_timestamp_）&gt; = T_UPDATE &amp;&amp; PIE-&gt; active_ == ACTIVE）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          //Can be implemented using integer multiply
          //DQ_THRESHOLD is power of 2 value
          current_qdelay = queue_.byte_length() *
          PIE-&gt;avg_dq_time_/DQ_THRESHOLD;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
p = alpha * (current_qdelay - QDELAY_REF) + \ beta * (current_qdelay - PIE-&gt;qdelay_old_);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
P =アルファ*（current_qdelay  -  QDELAY_REF）+ \ベータ*（current_qdelay  -  PIE-&gt; qdelay_old_）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          if (PIE-&gt;drop_prob_ &lt; 0.000001) {
              p /= 2048;
          } else if (PIE-&gt;drop_prob_ &lt; 0.00001) {
              p /= 512;
          } else if (PIE-&gt;drop_prob_ &lt; 0.0001) {
              p /= 128;
          } else if (PIE-&gt;drop_prob_ &lt; 0.001) {
              p /= 32;
          } else if (PIE-&gt;drop_prob_ &lt; 0.01) {
              p /= 8;
          } else if (PIE-&gt;drop_prob_ &lt; 0.1) {
              p /= 2;
          } else {
              p = p;
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          if (PIE-&gt;drop_prob_ &gt;= 0.1 &amp;&amp; p &gt; 0.02) {
              p = 0.02;
          }
          PIE-&gt;drop_prob_ += p;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//Exponentially decay drop prob when congestion goes away if (current_qdelay &lt; QDELAY_REF/2 &amp;&amp; PIE-&gt;qdelay_old_ &lt; QDELAY_REF/2) { PIE-&gt;drop_prob_ *= 0.98; //1 - 1/64 is //sufficient }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//指数関数的に減衰ドロップPROB輻輳が（current_qdelay &lt;QDELAY_REF / 2 &amp;&amp; PIE-&gt; qdelay_old_ &lt;QDELAY_REF / 2）{PIE-&gt; drop_prob_場合消える* = 0.98。 // 1  -  1/64} //十分です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//Bound drop probability if (PIE-&gt;drop_prob_ &lt; 0) PIE-&gt;drop_prob_ = 0 if (PIE-&gt;drop_prob_ &gt; 1) PIE-&gt;drop_prob_ = 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//バウンドドロップ確率（PIE-&gt; drop_prob_ &lt;0）PIE-&gt; drop_prob_ = 0の場合（PIE-&gt; drop_prob_&gt; 1）であればPIE-&gt; drop_prob_ = 1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          PIE-&gt;qdelay_old_ = current_qdelay;
          PIE-&gt;last_timestamp_ = now;
          PIE-&gt;burst_allowance_ = max(0,PIE-&gt;burst_allowance_ -
             T_UPDATE);
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ============================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
//Called on each packet departure deque(Packet packet) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
//各パケット出発両端キューに呼び出され（パケットパケット）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        //Dequeue rate estimation
        if (PIE-&gt;in_measurement_ == TRUE) {
             PIE-&gt;dq_count_ = packet.size() + PIE-&gt;dq_count_;
             //Start a new measurement cycle if we have enough packets
             if ( PIE-&gt;dq_count_ &gt;= DQ_THRESHOLD) {
               dq_time = now - PIE-&gt;measurement_start_;
               if (PIE-&gt;avg_dq_time_ == 0) {
                   PIE-&gt;avg_dq_time_ = dq_time;
               } else {
                   weight = DQ_THRESHOLD/2^16
                   PIE-&gt;avg_dq_time_ = dq_time * weight +
                      PIE-&gt;avg_dq_time_ * (1 - weight);
               }
               PIE-&gt;in_measurement_ = FALSE;
             }
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        //Start a measurement if we have enough data in the queue
        if (queue_.byte_length() &gt;= DQ_THRESHOLD &amp;&amp;
            PIE-&gt;in_measurement_ == FALSE) {
               PIE-&gt;in_measurement_ = TRUE;
               PIE-&gt;measurement_start_ = now;
               PIE-&gt;dq_count_ = 0;
        }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
協力者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bill Ver Steeg Comcast Cable Email: William_VerSteeg@comcast.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビル版シュテークComcastのケーブルEメール：William_VerSteeg@comcast.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mythili Prabhu* Akamai Technologies 3355 Scott Blvd. Santa Clara, CA 95054 United States of America Email: mythili@akamai.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デューク* 3355スコット・テクノロジーズは、マイティリーキャンプを内蔵します。サンタクララ、DC OP Q unitetu 95054 USA電子メール：மைதிலி@முகாமை.கம
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Chiara Piglione* Broadcom Corporation 3151 Zanker Road San Jose, CA 95134 United States of America Email: chiara@broadcom.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キアラPiglione *ブロードコム・コーポレーション3151 Zanker道サンノゼ、CA 95134アメリカ合衆国Eメール：chiara@broadcom.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Vijay Subramanian* PLUMgrid, Inc. 350 Oakmead Parkway Suite 250 Sunnyvale, CA 94085 United States of America Email: vns@plumgrid.com * Formerly at Cisco Systems
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シスコシステムズでは以前vns@plumgrid.com *：ビジェイサブラマニアン* PLUMgrid、Inc.の350 Oakmeadパークウェイスイート250サニーベール、カリフォルニアアメリカメールの94085米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rong Pan Cisco Systems 3625 Cisco Way San Jose, CA 95134 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
栄パンシスコシステムズ3625のCiscoウェイサンノゼ、CAアメリカの95134米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Email: ropan@cisco.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メール：ropan@cisco.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Preethi Natarajan Cisco Systems 725 Alder Drive Milpitas, CA 95035 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プリシーNatarajanシスコシステムズ725アルダードライブミルピタス、CAアメリカの95035米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Email: prenatar@cisco.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メール：prenatar@cisco.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fred Baker Santa Barbara, CA 93117 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フレッド・ベイカーサンタバーバラ、カリフォルニア州アメリカの93117米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Email: FredBaker.IETF@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メール：FredBaker.IETF@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Greg White CableLabs 858 Coal Creek Circle Louisville, CO 80027 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グレッグ・ホワイトCableLabsの858コールクリークサークルルイビル、アメリカのCO 80027米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Email: g.white@cablelabs.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メール：g.white@cablelabs.com
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
