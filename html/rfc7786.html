<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7786 - TCP Modifications for Congestion Exposure (ConEx) 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
    <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7786 - TCP Modifications for Congestion Exposure (ConEx) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7786">
              https://tools.ietf.org/html/rfc7786
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7786 - 輻輳露出のためのTCPの変更（コーネックス）</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                M. Kuehlewind, Ed.
Request for Comments: 7786                                    ETH Zurich
Category: Experimental                                  R. Scheffenegger
ISSN: 2070-1721                                             NetApp, Inc.
                                                                May 2016
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           TCP Modifications for Congestion Exposure (ConEx)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Congestion Exposure (ConEx) is a mechanism by which senders inform the network about expected congestion based on congestion feedback from previous packets in the same flow. This document describes the necessary modifications to use ConEx with the Transmission Control Protocol (TCP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳露光（コーネックス）が送信者が同じフロー内の前のパケットから輻輳フィードバックに基づいて予想される混雑についてネットワークに通知するメカニズムです。この文書は、伝送制御プロトコル（TCP）とコーネックスを使用するために必要な変更を記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7786.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7786で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   4
   2.  Sender-Side Modifications . . . . . . . . . . . . . . . . . .   4
   3.  Counting Congestion . . . . . . . . . . . . . . . . . . . . .   5
     3.1.  Loss Detection  . . . . . . . . . . . . . . . . . . . . .   6
       3.1.1.  Without SACK Support  . . . . . . . . . . . . . . . .   7
     3.2.  Explicit Congestion Notification (ECN)  . . . . . . . . .   8
       3.2.1.  Accurate ECN Feedback . . . . . . . . . . . . . . . .  10
       3.2.2.  Classic ECN Support . . . . . . . . . . . . . . . . .  10
   4.  Setting the ConEx Flags . . . . . . . . . . . . . . . . . . .  11
     4.1.  Setting the E or the L Flag . . . . . . . . . . . . . . .  11
     4.2.  Setting the Credit Flag . . . . . . . . . . . . . . . . .  11
   5.  Loss of ConEx Information . . . . . . . . . . . . . . . . . .  14
   6.  Timeliness of the ConEx Signals . . . . . . . . . . . . . . .  14
   7.  Open Areas for Experimentation  . . . . . . . . . . . . . . .  15
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  17
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  18
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  18
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  19
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  20
   Authors&#39; Addresses  . . . . . . . . . . . . . . . . . . . . . . .  20
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Congestion Exposure (ConEx) is a mechanism by which senders inform the network about expected congestion based on congestion feedback from previous packets in the same flow. ConEx concepts and use cases are further explained in [RFC6789]. The abstract ConEx mechanism is explained in [RFC7713]. This document describes the necessary modifications to use ConEx with the Transmission Control Protocol (TCP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳露光（コーネックス）が送信者が同じフロー内の前のパケットから輻輳フィードバックに基づいて予想される混雑についてネットワークに通知するメカニズムです。コーネックス概念とユースケースは、さらに、[RFC6789]で説明されています。抽象コーネックス機構は[RFC7713]で説明されています。この文書は、伝送制御プロトコル（TCP）とコーネックスを使用するために必要な変更を記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The markings for ConEx signaling are defined in the ConEx Destination Option (CDO) for IPv6 [RFC7837]. Specifically, the use of four flags is defined: X (ConEx-capable), L (loss experienced), E (ECN experienced), and C (credit).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コーネックスシグナリングのためのマーキングは、IPv6 [RFC7837]のためのコーネックス宛先オプション（CDO）で定義されています。具体的には、4つのフラグの使用が定義され：X（CONEX対応）、L（損失が経験）、E（経験豊富なECN）、およびC（クレジット）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ConEx signaling is based on the use of either loss or Explicit Congestion Notification (ECN) marks [RFC3168] as congestion indication. The sender collects this congestion information based on existing TCP feedback mechanisms from the receiver to the sender. No changes are needed at the receiver side to implement ConEx signaling. Therefore, no additional negotiation is needed to implement and use ConEx at the sender side. This document specifies the sender&#39;s actions that are needed to provide meaningful ConEx information to the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コーネックスシグナリングが紛失又は輻輳表示として明示的輻輳通知（ECN）マーク[RFC3168]のいずれかの使用に基づいています。送信側は受信側から送信側への既存のTCPのフィードバックメカニズムに基づいて、この渋滞情報を収集します。変更はコーネックスシグナリングを実装するために、受信機側では必要ありません。そのため、追加の交渉は、送信側でコーネックスを実装して使用する必要はありません。この文書では、ネットワークに意味のあるコーネックス情報を提供するために必要とされる送信者のアクションを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 2 provides an overview of the modifications needed for TCP senders to implement ConEx. First, congestion information has to be extracted from TCP&#39;s loss or ECN feedback as described in Section 3. Section 4 details how to set the CDO marking based on this congestion information. Section 5 discusses the loss of packets carrying ConEx information. Section 6 discusses the timeliness of the ConEx feedback signal, given that congestion is a temporary state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第2節では、コーネックスを実装するためにTCPの送信者のために必要な変更の概要を説明します。まず、渋滞情報は、セクション3節では、この渋滞情報に基づいてマーキングCDOを設定する方法4件の詳細を説明するようにTCPの損失やECNフィードバックから抽出する必要があります。第5節では、コネックス情報を運ぶパケットの損失を説明します。セクション6は、輻輳が一時的な状態であることを考えると、コーネックスフィードバック信号の適時性を論じています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes congestion accounting for TCP with and without the Selective Acknowledgement (SACK) extension [RFC2018] (in Section 3.1). However, ConEx benefits from the more accurate information that SACK provides about the number of bytes dropped in the network, and it is therefore preferable to use the SACK extension when using TCP with ConEx. The detailed mechanism to set the L flag in response to the loss-based congestion feedback signal is given in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は（3.1節で）選択確認応答（SACK）拡張[RFC2018]でとせずにTCPを占め混雑を説明しています。しかし、バイト数に関するそのSACKが提供するより正確な情報から、コーネックスの利点は、ネットワークに滴下し、それ故、コーネックスでTCPを使用する場合SACK拡張を使用することが好ましいです。損失ベースの輻輳フィードバック信号に応答して、Lフラグを設定するための詳細なメカニズムは、セクション4.1で与えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While loss has to be minimized, ECN can provide more fine-grained feedback information. ConEx-based traffic measurement or management mechanisms could benefit from this. Unfortunately, the current ECN feedback mechanism does not reflect multiple congestion markings if they occur within the same Round-Trip Time (RTT). A more accurate feedback extension to ECN (AccECN) is proposed in a separate document [ACCURATE], as this is also useful for other mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
損失を最小限にする必要がありますが、ECNは、よりきめ細かいフィードバック情報を提供することができます。 CONEXベースのトラフィック測定や管理メカニズムがこの恩恵を受けることができます。彼らは同じラウンドトリップ時間（RTT）内で発生する場合は残念ながら、現在のECNのフィードバック機構は、複数の輻輳のマーキングを反映するものではありません。これはまた、他の機構のために有用であるとしてECN（AccECN）に、より正確なフィードバック拡張は、別の文書[ACCURATE]で提案されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Congestion accounting for both classic ECN feedback and AccECN feedback is explained in detail in Section 3.2. Setting the E flag in response to ECN-based congestion feedback is again detailed in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
古典的なECNフィードバックとAccECNフィードバックの両方を占め輻輳は3.2節で詳しく説明されています。 ECNベース輻輳フィードバックに応答してEフラグを設定すると、セクション4.1に再度詳細に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります[RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Sender-Side Modifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.送信側の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section gives an overview of actions that need to be taken by a TCP sender modified to use ConEx signaling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、コーネックスシグナリングを使用するように変更されたTCPの送信者によって行われる必要があるアクションの概要を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the TCP handshake, a ConEx sender MUST negotiate for SACK and ECN preferably with AccECN feedback. Therefore, a ConEx sender MUST also implement SACK and ECN. Depending on the capability of the receiver, the following operation modes exist:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPハンドシェイクでは、コーネックスの送信者は、好ましくは、AccECNフィードバックでSACKとECNを交渉しなければなりません。そのため、コーネックスの送信者はまた、SACKとECNを実装しなければなりません。受信機の能力に応じて、次の動作モードが存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o SACK-accECN-ConEx (SACK and accurate ECN feedback)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O SACK-accECN  - コーネックス（SACKと正確ECNフィードバック）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o SACK-ECN-ConEx (SACK and classic instead of accurate ECN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O SACK-ECN-CONEX（SACK、代わりに正確ECNの古典）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o accECN-ConEx (no SACK but accurate ECN feedback)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oアクセントコーネックス（無SACが、正確なECNフィードバック）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o ECN-ConEx (no SACK and no accurate ECN feedback, but classic ECN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ECN-CONEX（NO SACKなし正確ECNフィードバックが、古典的なECN）O-
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o SACK-ConEx (SACK but no ECN at all)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O SACK-コーネックス（SACKが、まったくECN）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Basic-ConEx (neither SACK nor ECN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oベーシック・コーネックス（いずれもSACKやECN）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A ConEx sender MUST expose all congestion information to the network according to the congestion information received by ECN or based on loss information provided by the TCP feedback loop. A TCP sender SHOULD count congestion byte-wise (rather than packet-wise; see next paragraph). After any congestion notification, a sender MUST mark subsequent packets with the appropriate ConEx flag in the IP header. Furthermore, a ConEx sender must send enough credit to cover all experienced congestion for the connection so far, as well as the risk of congestion for the current transmission (see Section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コーネックス送信者は、ECNによって受信またはTCPフィードバックループによって提供される損失情報に基づいて渋滞情報に応じて、ネットワークへのすべての輻輳情報を公開しなければなりません。 TCPの送信者は、バイト単位の輻輳を数えるべきである（というよりも、パケット単位;次の段落を参照します）。任意の輻輳通知後、送信者は、IPヘッダ内の適切なコーネックスフラグを後続のパケットをマークしなければなりません。さらに、コーネックスの送信者は、これまでの接続のためのすべての経験豊富な渋滞だけでなく、現在の送信のための輻輳のリスクをカバーするのに十分な信用を送信する必要があります（4.2節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With SACK the number of lost payload bytes is known, but not the number of packets carrying these bytes. With classic ECN only an indication is given that a marking occurred, but not the exact number of payload bytes nor packets. As network congestion is usually byte-congestion [RFC7141], the byte-size of a packet marked with a CDO flag is defined to represent that number of bytes of congestion signaling [RFC7837]. Therefore, the exact number of bytes should be taken into account, if available, to make the ConEx Signal as exact as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SACKで失われたペイロードバイトの数は、これらのバイトを運ぶパケットの数を知られていないが、。古典ECNでのみ表示がペイロードバイトやパケットの正確な数を発生してマーキングすることを考えると、しかしされません。ネットワーク輻輳が通常バイト輻輳[RFC7141]であるように、CDOフラグでマークされたパケットのバイトサイズが輻輳シグナリング[RFC7837]のバイトの数を表すように定義されています。そのため、正確なバイト数は、できるだけ正確コーネックスの信号を作るために、利用可能な場合、考慮すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Detailed mechanisms for congestion counting in each operation mode are described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各動作モードにおける輻輳計数の詳細な機構は、次のセクションに記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Counting Congestion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.カウント輻輳
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A ConEx TCP sender maintains two counters: one that counts congestion based on the information retrieved by loss detection, and a second that accounts for ECN-based congestion feedback. These counters hold the number of outstanding bytes that should be ConEx-Marked with, respectively, the E flag or the L flag in subsequent packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
損失検出、およびECNベースの輻輳フィードバックを占め秒で取得した情報に基づいて渋滞をカウント1：コーネックスTCPの送信者は、二つのカウンタを維持します。これらのカウンタは、それぞれ、とCONEX-マークされるべき未処理のバイト数、Eフラグまたは後続のパケットにおけるLフラグを保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The outstanding bytes for congestion indications based on loss are maintained in the Loss Exposure Gauge (LEG), as explained in Section 3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.1節で説明したように損失に基づいて、輻輳適応症に未処理のバイトは、損失エクスポージャーゲージ（LEG）に維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The outstanding bytes counted based on ECN feedback information are maintained in the Congestion Exposure Gauge (CEG), as explained in Section 3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.2節で説明したようにECNフィードバック情報に基づいてカウント未処理のバイトは、輻輳露出計（CEG）に維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the sender sends a ConEx-capable packet with the E or L flag set, it reduces the respective counter by the byte-size of the packet. This is explained for both counters in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者がEまたはLフラグが設定されたCONEX可能なパケットを送信するとき、パケットのバイトサイズによってそれぞれのカウンタを減少させます。これは、4.1節では、両方のカウンタのために説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that all bytes of an IP packet must be counted in the LEG or CEG to capture the right number of bytes that should be marked. Therefore, the sender SHOULD take the payload and headers into account, up to and including the IP header. However, in TCP the information regarding how large the headers of a lost or marked packet were is usually not available, as only payload data will be acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPパケットのすべてのバイトがマークされるべきバイトの正しい数をキャプチャするためにLEGまたはCEGでカウントされなければならないことに注意してください。したがって、送信者は、IPヘッダなどに、最大、考慮ペイロードとヘッダを取るべきです。ペイロードデータのみが認められるようにしかし、TCPに紛失またはマークされたパケットのヘッダがあったか、大きなに関する情報は、通常は使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If equal-sized packets, or at least equally distributed packet sizes, can be assumed, the sender MAY only add and subtract TCP payload bytes. In this case, there should be about the same number of ConEx-Marked packets as the original packets that were causing the congestion. Thus, both contain about the same number of header bytes so they will cancel out. This case is assumed for simplicity in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
等しいサイズのパケット、又は少なくとも等しく分布パケットサイズは、想定できる場合、送信側は、TCPペイロードバイトを追加し、減算してもよいです。この場合には、輻輳を引き起こした元のパケットとしてCONEX-マーキングされたパケットのほぼ同数があるべきです。それらは相殺されますこれにより、両方のヘッダバイトのほぼ同数含みます。この場合は、次のセクションで簡単にするために想定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Otherwise, if a sender sends different sized packets (with unequally distributed packet sizes), the sender needs to memorize or estimate the number of lost or ECN-marked packets. If the sender has sufficient memory available, the most accurate way to reconstruct the number of lost or marked packets is to remember the sequence number of all sent but not acknowledged packets. In this case, a sender is able to reconstruct the number of packets, and thus the header bytes that were sent during the last RTT. Otherwise (e.g., if not enough memory is available), the sender would need to estimate the packet size. The average packet size can be estimated if the distribution pattern of packet sizes in the last RTT is known; alternatively, the minimum packet size seen in the last RTT can be used as the most conservative estimate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者は（不均等に分布するパケットサイズで）異なるサイズのパケットを送信する場合それ以外の場合は、送信者が覚えたり失われたり、ECN-マークされたパケットの数を推定する必要があります。送信者が利用可能な十分なメモリを持っている場合は、紛失したり、マークされたパケットの数を再構築するための最も正確な方法はすべて送信されますが確認されないパケットのシーケンス番号を覚えておくことです。この場合、送信者は、このようにパケットの数、および最後のRTTの間に送信されたヘッダバイトを再構築することが可能です。そうでない場合（例えば、メモリが足りない場合）、送信者は、パケットサイズを推定する必要があります。最後のRTTにおけるパケットサイズの分布パターンが既知である場合の平均パケットサイズを推定することができます。あるいは、最後のRTTに見られる最小パケットサイズは、最も保守的な推定値として使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the number of newly sent-out packets with the ConEx L or E flag set is smaller (or larger) than this estimated number of lost/ECN-marked packets, the additional header bytes should be added to (or can be subtracted from) the respective gauge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コーネックスLまたはEフラグが設定された新たに送り出されたパケットの数が失わ/ ECN-マーキングされたパケットのこの推定された数よりも小さい（またはそれ以上）である場合、追加のヘッダバイトはに追加されるべきである（又はから減算することができます）それぞれのゲージ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Loss Detection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。損失検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section applies whether or not SACK support is available. The following subsection (Section 3.1.1) handles the case when SACK is not available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、SACKのサポートが利用可能であるか否かが適用されます。 SACKが利用できない場合は、次のサブセクション（セクション3.1.1）ケースを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A TCP sender detects losses and subsequently retransmits the lost data. Therefore, the ConEx sender can simply set the ConEx L flag on all retransmissions in order to at least cover the amount of bytes lost. If this approach is taken, no LEG is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPの送信者は損失を検出し、その後、失われたデータを再送します。したがって、コーネックスの送信者は、単に、少なくとも失われたバイトの量をカバーするためにすべての再送に対するコーネックスLフラグを設定することができます。このアプローチが取られている場合、LEGは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, any retransmission may be spurious. In this case, more bytes have been marked than necessary. To compensate for this effect, a ConEx sender can maintain a local signed counter (the LEG) that indicates the number of outstanding bytes to be sent with the ConEx L flag and also can become negative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、いずれの再送信は偽かもしれません。この場合は、より多くのバイトが必要以上にマークされています。この効果を補償するために、コーネックス送信側が負になることができ、またコーネックスのLフラグが送信される未処理のバイト数を示すとローカル符号付きカウンター（LEG）を維持することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using the LEG, when a TCP sender decides that a data segment needs to be retransmitted, it will increase the LEG by the size of the TCP payload bytes in the retransmission (assuming equal sized segments such that the retransmitted packet will have the same number of header bytes as the original ones):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP送信者は、データセグメントを再送信する必要がある、それは再送におけるTCPペイロードバイトのサイズによってLEGを増加させると判断したとき、LEGを使用して（再送パケットが同じ数を有するように等しいサイズのセグメントを仮定ヘッダ）は、元のものとしてバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For each retransmission:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各再送信の場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEG += payload
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEG + =ペイロード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note how the LEG is reduced when the ConEx L marking is set as described in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション4で説明したようにマーキングコーネックスLが設定されているときにLEGが低減される方法に注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Further, to accommodate spurious retransmissions, a ConEx sender SHOULD make use of heuristics to detect such spurious retransmissions (e.g., F-RTO [RFC5682], DSACK [RFC3708], and Eifel [RFC3522], [RFC4015]), if already available in a given implementation. If no mechanism for detecting spurious retransmissions is available, the ConEx sender MAY chose to implement one of the mechanisms stated above. However, given the inaccuracy that ConEx may have anyway and the timeliness of ConEx information, a ConEx MAY also chose not to compensate for spurious retransmission. In this case, if spurious retransmissions occur, the ConEx sender has simply sent too many ConEx Signals which, e.g., would decrease the congestion allowance in a ConEx policer unnecessarily.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、偽の再送信に対応するために、コーネックスの送信者は、このような偽の再送信を検出するヒューリスティックの使用をしなければならない（例えば、F-RTO [RFC5682]、DSACK [RFC3708]、およびアイフェル[RFC3522]、[RFC4015]）、ですでに利用可能な場合所与の実装。スプリアス再送を検出するためのメカニズムが利用できない場合、コーネックスの送信者は、上記のメカニズムの一つを実施することを選択することができます。しかし、コーネックスはとにかく持っていることが不正確とコネックス情報の適時与えられ、コーネックスはまた、スプリアス再送を補うしないことを選んだかもしれません。スプリアス再送が発生した場合この場合は、コネックス送信者は、単に、例えば、不必要コネックスポリサーで混雑手当を減少させる、あまりにも多くのコーネックス信号を送信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a heuristic method is used to detect spurious retransmission and has determined that a certain number of packets were retransmitted erroneously, the ConEx sender subtracts the payload size of these TCP packets from LEG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
発見的方法は、スプリアス再送を検出するために使用されるパケットの特定の数が誤って再送信されたと判定された場合、コーネックスの送信者は、脚から、これらのTCPパケットのペイロードサイズを減算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a spurious retransmission is detected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スプリアス再送が検出された場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEG -= payload
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEG  -  =ペイロード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that LEG can become negative if too many L markings have already been sent. This case is further discussed in Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
あまりにも多くのLマークが既に送信されている場合LEGがマイナスになることに注意してください。この場合には、さらに第6節で議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Without SACK Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1。 SACKのサポートなし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If multiple losses occur within one RTT and SACK is not used, it may take several RTTs until all lost data is retransmitted. With the scheme described above, the ConEx information will be delayed considerably, but timeliness is important for ConEx. For ConEx, it is important to know how much data was lost; it is not important to know what data is lost. During the first RTT after the initial loss detection, the amount of received data, and thus also the amount of lost data, can be estimated based on the number of received ACKs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の損失は1 RTT内で発生し、SACKが使用されていない場合は、すべての失われたデータを再送されるまで、それはいくつかのRTTがかかる場合があります。上記の方式では、コネックス情報が大幅に遅れることになるが、適時性はコーネックスのために重要です。コーネックスの場合は、失われたデータ量を知ることが重要です。失われたどのデータを知ることは重要ではありません。初期損失検出、受信されたデータの量、および従ってまた失われたデータの量の後の最初のRTTの間に、受信されたACKの数に基づいて推定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Therefore, a ConEx sender can use the following algorithm to estimated the number of lost bytes with an additional delay of one RTT using an additional Loss Estimation Counter (LEC):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
したがって、コーネックスの送信者が追加損失推定カウンタ（LEC）を用いたものRTTの追加の遅延と、失われたバイトの数を推定するために、次のアルゴリズムを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
flight_bytes: current flight size in bytes retransmit_bytes: payload size of the retransmission
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
flight_bytes：バイトretransmit_bytesにおける現在の飛行サイズ：再送信のペイロードサイズ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At the first retransmission in a congestion event, LEC is set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳イベントの最初の再送では、LECが設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEC = flight_bytes - 3*SMSS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEC = flight_bytes  -  3 * SMSS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(At this point in the transmission, in the worst case, all packets in flight minus three that triggered the dupACks could have been lost.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（伝送のこの時点で、最悪の場合には、dupACksをトリガー3マイナス飛行中のすべてのパケットが失われた可能性があります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Then, during the first RTT of the congestion event:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その後、輻輳イベントの最初のRTT中：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For each retransmission: LEG += retransmit_bytes LEC -= retransmit_bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各再送信の場合：LEG + = retransmit_bytes LEC  -  = retransmit_bytes
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For each ACK: LEC -= SMSS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ACKの場合：LEC  -  = SMSS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After one RTT:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1 RTT後：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEG += LEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEG + = LEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(The LEC now estimates the number of outstanding bytes that should be ConEx L-marked.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（LECは現在、コーネックスL-マークする必要があります未処理のバイト数を推定します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After the first RTT for each following retransmissions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の各再送信のための最初のRTT後：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (LEC &gt; 0): LEC -= retransmit_bytes else if (LEC==0): LEG += retransmit_bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし（LEC&gt; 0）：LEC  - 他= retransmit_bytes（LEC == 0）の場合：LEG + = retransmit_bytes
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (LEC &lt; 0): LEG += -LEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEG + = -LEC：（LEC &lt;0）であれば
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(The LEG is not increased for those bytes that were already counted.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（LEGは、既にカウントしたものバイトで増加されません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Explicit Congestion Notification (ECN)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。明示的輻輳通知（ECN）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ECN [RFC3168] is an IP/TCP mechanism that allows network nodes to mark packets with the Congestion Experienced (CE) mark instead of dropping them when congestion occurs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ECN [RFC3168]は、ネットワークノードが代わりに輻輳が発生したときにそれらを落とすの混雑経験（CE）マークがパケットをマークすることを可能にするIP / TCP機構です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A receiver might support classic ECN, the more accurate ECN feedback scheme (AccECN), or neither. In the case that ECN is not supported for a connection, of course no ECN marks will occur; thus, the sender will never set the E flag. Otherwise, a ConEx sender needs to maintain a signed counter, the Congestion Exposure Gauge (CEG), for the number of outstanding bytes that have to be ConEx-Marked with the E flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機は、古典的なECN、より正確なECNのフィードバック方式（AccECN）、またはどちらをサポートする場合があります。 ECNは、接続のためにサポートされていない場合には、もちろん全くECNマークが発生しません。したがって、送信者は、Eフラグを設定することはありません。そうでない場合は、コーネックスの送信者は、コーネックスマークEフラグとなる必要があり未処理のバイト数の符号付きカウンタ、輻輳露出計（CEG）を、維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CEG is increased when ECN information is received from an ECN-capable receiver supporting the classic ECN scheme or the accurate ECN feedback scheme. When the ConEx sender receives an ACK indicating one or more segments were received with a CE mark, CEG is increased by the appropriate number of bytes as described further below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ECN情報が古典ECN方式や正確ECNフィードバック方式をサポートECN-可能な受信機から受信されたときにCEGが増加します。コーネックス送信者は、CEマークが受信された1つ以上のセグメントを示すACKを受信した場合、さらに以下に説明するように、CEGは、適切なバイト数だけ増加させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unfortunately, in case of duplicate acknowledgements, the number of newly acknowledged bytes will be zero even though (CE-marked) data has been received. Therefore, we increase the CEG by DeliveredData, as defined below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
残念ながら、重複確認応答の場合には、新たに認めたバイト数は、（CEマーク付き）のデータが受信されているにもかかわらず、ゼロになります。以下に定義するために、我々は、DeliveredDataによってCEGを増やします：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DeliveredData = acked_bytes + SACK_diff + (is_dup)*1SMSS - (is_after_dup)*num_dup*1SMSS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DeliveredData = acked_bytes + SACK_diff +（is_dup）* 1SMSS  - （is_after_dup）* num_dup * 1SMSS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DeliveredData covers the number of bytes that has been newly delivered to the receiver. Therefore, on each arrival of an ACK, DeliveredData will be increased by the newly acknowledged bytes (acked_bytes) as indicated by the current ACK, relative to all past ACKs. The formula depends on whether SACK is available: if SACK is not available, SACK_diff is always zero, whereas if ACK information is available, is_dup and is_after_dup are always zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DeliveredDataは、新たに受信機に配信されたバイト数をカバーしています。現在のACKによって示されるように、したがって、ACKの各到着時に、DeliveredDataはすべて過去のACKに対して、新たに認めバイト（acked_bytes）増加します。式はSACKが利用可能であるかどうかに依存する：SACKが利用できない場合、ACK情報が利用可能である場合、is_dupとis_after_dupは常にゼロであるのに対し、SACK_diffは、常にゼロです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With SACK, DeliveredData is increased by the number of bytes provided by (new) SACK information (SACK_diff). Note that if less unacknowledged bytes are announced in the new SACK information than in the previous ACK, SACK_diff can be negative. In this case, data is newly acknowledged (in acked_bytes) that was previously accumulated into DeliveredData, based on SACK information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SACKと、DeliveredDataは（新しい）SACK情報（SACK_diff）によって提供されるバイト数だけ増加されます。以下未確認のバイトは、前のACKよりも新しいSACK情報に発表されている場合、SACK_diffは負になることに注意してください。この場合、データは、新たに以前にSACK情報に基づいて、DeliveredDataに蓄積したこと（acked_bytesに）認められています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Otherwise without SACK, DeliveredData is increased by 1 Sender Maximum Segment Size (SMSS) on duplicate acknowledgements because duplicate acknowledgements do not acknowledge any new data (and acked_bytes will be zero). For the subsequent partial or full ACK, acked_bytes cover all newly acknowledged bytes including those already accounted for with the receipt of any duplicate acknowledgement. Therefore, DeliveredData is reduced by one SMSS for each preceding duplicate ACK. Consequently, is_dup is one if the current ACK is a duplicated ACK without SACK, and zero otherwise. is_after_dup is only one for the next full or partial ACK after a number of duplicated ACKs without SACK and num_dup counts the number of duplicated ACKs in a row (which usually is 3 or more).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それ以外の場合はSACKなし、重複確認応答が新たなデータを確認していないので、DeliveredDataは、重複確認応答に1つの送信側最大セグメントサイズ（SMSS）によって増加する（とacked_bytesはゼロになります）。その後の部分的または完全なACKの場合は、acked_bytesはすでに任意の重複確認応答の受信を占めものも含め、すべての新しく認めバイトをカバーしています。したがって、DeliveredData各先行重複ACKための一SMSSによって低減されます。現在のACKは、さもなければ重複SACKなしでACK、ゼロであれば、結果として、is_dupは1です。 is_after_dupはSACKなしの重複ACKの数の後の次の完全または部分的なACKのための唯一のものであるとnum_dup（通常は3以上である）行の重複ACKの数をカウントします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With classic ECN, one congestion-marked packet causes continuous congestion feedback for a whole round trip, thus hiding the arrival of any further congestion-marked packets during that round trip. A more accurate ECN feedback scheme (AccECN) is needed to ensure that feedback properly reflects the extent of congestion marking. The two cases, with and without a receiver capable of AccECN, are discussed in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
古典的なECNでは、1輻輳マーク付きのパケットは、このようにその往復中のいずれかのさらなる混雑マークパケットの到着を隠し、全体の往復のための継続的な輻輳フィードバックの原因となります。より正確なECNフィードバックスキーム（AccECN）は、フィードバックが適切にマーキング渋滞の程度を反映することを確実にするために必要とされます。 2つのケースは、AccECN可能な受信機とすることなく、次のセクションで説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. Accurate ECN Feedback
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1。正確なECNフィードバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With a more accurate ECN feedback scheme (AccECN) that is supported by the receiver, either the number of marked packets or the number of marked bytes will be fed back from the receiver to the sender and, therefore is known at the sender side. In the latter case, the CEG can be increased directly by the number of marked bytes. Otherwise if D is assumed to be the number of marks, the gauge (CEG) will be conservatively increased by one SMSS for each marking or, at the maximum, the number of newly acknowledged bytes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機によってサポートされ、より正確なECNフィードバックスキーム（AccECN）、いずれかのマーキングされたパケットの数又は著しいバイトの数と、したがって、送信者側で知られ、送信側に受信機からフィードバックされます。後者の場合、CEGは、マークされたバイトの数によって直接増加させることができます。 Dは、マークの数であると仮定される場合にそうでない場合、ゲージ（CEG）は控えめ各マーキング1 SMSSだけ増加されるか、最大でも、新たに受け付けたバイトの数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CEG += min(SMSS*D, DeliveredData)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEZ +、=偶数（SMS *人形、deliverddata）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. Classic ECN Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2。クラシックECNのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With classic ECN, as soon as a CE mark is seen at the receiver side, it will feed this information back to the sender by setting the Echo Congestion Experienced (ECE) flag in the TCP header of subsequent ACKs. Once the sender receives the first ECE of a congestion notification, it sets the Congestion Window Reduced (CWR) flag in the TCP header once. When this packet with the CWR flag in the TCP header arrives at the receiver side acknowledging its first ECE feedback, the receiver stops setting the ECE flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
古典ECNと、できるだけ早くCEマークは、受信機側で見られるように、それは後続のACKのTCPヘッダにエコー輻輳経験（ECE）フラグを設定することによって、送信者にこの情報を供給します。送信者が輻輳通知の最初のECEを受信すると、一旦TCPヘッダに（CWR）フラグ減少輻輳ウィンドウを設定します。 TCPヘッダーのCWRフラグと、このパケットは、その最初のECEフィードバックを認める受信側に到着すると、受信機は、ECEフラグを設定することを停止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the ConEx sender fully conforms to the semantics of ECN signaling as defined by [RFC3168], it will receive one full RTT of ACKs with the ECE flag set whenever at least one CE mark was received by the receiver. As the sender cannot estimate how many packets have actually been CE-marked during this RTT, the most conservative assumption MAY be taken, namely assuming that all packets were marked. This can be achieved by increasing the CEG by DeliveredData for each ACK with the ECE flag:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3168]で定義されるようにコーネックス送信者が完全ECNシグナルのセマンティクスに準拠している場合、少なくとも1つのCEマークが受信機によって受信されたときはいつでも、それはECEフラグを設定してACKの完全な一RTTを受信することになります。送信者が実際にCEマーク付きこのRTTの間にされているどのように多くのパケットを推定することができないとして、最も保守的な仮定、すなわち、すべてのパケットがマークされていたと仮定して、取ることができます。これは、ECEフラグと各ACKためDeliveredDataによってCEGを増加させることによって達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CEG += DeliveredData
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEZ、+ = deliverddata
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Optionally, a ConEx sender could implement the following technique (that does not conform to [RFC3168]), called &#34;advanced compatibility mode&#34;, to considerably improve its estimate of the number of ECN-marked packets:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必要に応じて、コーネックスの送信者は、以下の技術を実装することができ（すなわち、に準拠していない[RFC3168]）、かなりECN-マーキングされたパケットの数のその推定値を改善するために、「高度な互換モード」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To extract more than one ECE indication per RTT, a ConEx sender could set the CWR flag continuously to force the receiver to signal only one ECE per CE mark. Unfortunately, the use of delayed ACKs [RFC5681] (which is common) will prevent feedback of every CE mark; if a CWR confirmation is received before the ECE can be sent out on the next ACK, ECN feedback information could get lost (depending on the actual receiver implementation). Thus, a sender SHOULD set CWR only on those data segments that will presumably trigger a (delayed) ACK. The sender would need an additional control loop to estimate which data segments will trigger an ACK in order to extract more timely congestion notifications. Still, the CEG SHOULD be increased by DeliveredData, as one or more CE-marked packets could be acknowledged by one delayed ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTTごとに複数のECE指示を抽出するために、コーネックス送信者は、CEマークごとに1つだけECEを知らせるために受信機を強制的に連続CWRフラグを設定することができました。残念ながら、遅延ACKを使用する[RFC5681]（一般的である）すべてのCEマークのフィードバックを防止します。 ECEは、次のACKで送信することができます前に、CWR確認が受信された場合、ECNフィードバック情報は、（実際の受信機の実装に依存する）失われ得ることができます。したがって、送信者は、おそらく（遅延）ACKをトリガするそれらのデータセグメントにCWRを設定する必要があります。送信者は、データ・セグメントは、よりタイムリーな輻輳通知を抽出するためにACKをトリガする推定するために、追加の制御ループが必要になります。それでも、CEGは1遅延ACKによって確認することができ一つ以上のCEマーク付きパケットとして、DeliveredDataによって増加されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Setting the ConEx Flags
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.コーネックスフラグを設定します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By setting the X flag, a packet is marked as ConEx-capable. All packets carrying payload MUST be marked with the X flag set, including retransmissions. Only if no congestion feedback information is (currently) available, SHOULD the X flag be zero (e.g., for control packets on a connection that has not sent any user data for some time and, therefore is sending only pure ACKs that are not carrying any payload).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Xフラグを設定することによって、パケットがCONEX-可能としてマークされています。ペイロードを運ぶすべてのパケットは、再送信を含むXフラグがセットでマークされなければなりません。輻輳フィードバック情報は、（現在）利用可能でない場合にのみ、Xフラグは、しばらくの間、任意のユーザーデータを送信していないと、したがっていずれかを担持されていない純粋なACKを送信して接続上の制御パケットのためにゼロ（例えば、あるべきですペイロード）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Setting the E or the L Flag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。 EまたはLフラグを設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described in Section 3.1, the sender needs to maintain a CEG counter and might also maintain a LEG counter. If no LEG is used, all retransmission will be marked with the L flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.1節で述べたように、送信者はCEGカウンタを維持する必要があるともLEGカウンタを維持する可能性があります。何LEGが使用されていない場合は、すべての再送がLフラグでマークされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Further, as long as the LEG or CEG counter is positive, the sender marks each ConEx-capable packet with L or E respectively, and decreases the LEG or CEG counter by the TCP payload bytes carried in the marked packet (assuming headers are not being counted because packet sizes are regular). No matter how small the value of LEG or CEG, if the value is positive the sender MUST NOT defer packet marking; this ensures that ConEx Signals are timely. Therefore, the value of LEG and CEG will commonly be negative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、限りLEGまたはCEGカウンタが正であるように、送信者マークLまたはEで各CONEX対応のパケットは、それぞれ、とマークされたパケットで運ばれるTCPペイロードバイトLEGまたはCEGカウンタを減少させる（仮定ヘッダがされていませんパケットサイズが通常であるため）カウント。値が正の場合、送信側がパケットマーキングを延期てはなりませんどのように小さなLEGまたはCEGの値は関係ありません。これは、コーネックス信号がタイムリーであることを保証します。したがって、LEGおよびCEGの値は、一般的に負となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If both the LEG and CEG are positive, the sender MUST mark each ConEx-capable packet with both L and E. If a credit signal is also pending (see the next section), the C flag can be set as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LEGとCEG両方が正である場合にクレジット信号はまた、（次のセクションを参照）保留されている場合、送信者はLおよびEの両方で各CONEX対応のパケットをマークする必要があり、Cフラグも設定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Setting the Credit Flag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。クレジットフラグを設定します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ConEx abstract mechanism [RFC7713] requires that sufficient credit MUST be signaled in advance to cover the expected congestion during the feedback delay of one RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CONEX抽象メカニズム[RFC7713]は、十分なクレジットが1 RTTのフィードバック遅延中に予想される混雑を覆うように、事前に知らされなければならないことを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To monitor the credit state at the audit, a ConEx sender needs to maintain a Credit State Counter (CSC) in bytes. If congestion occurs, credits will be consumed and the CSC is reduced by the number of bytes that were lost or estimated to be ECN-marked. If the risk of congestion was estimated wrongly, and thus too few credits were sent, the CSC becomes zero but cannot go negative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
監査での信用状態を監視するには、コーネックスの送信者は、バイト単位での信用状態カウンタ（CSC）を維持する必要があります。輻輳が発生した場合は、クレジットが消費され、CSCが失われたり、ECN-マークと推定されたバイト数だけ低減されます。混雑のリスクが誤って推定されたので、数が少なすぎるのクレジットが送信された場合は、CSCはゼロになるが、負行くことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To be sure that the credit state in the audit never reaches zero, the number of credits should always equal the number of bytes in flight as all packets could potentially get lost or congestion-marked. In this case, a ConEx sender also monitors the number of bytes in flight F. If F ever becomes larger than the CSC, the ConEx sender sets the C flag on each ConEx-capable packet and increases the CSC by the payload size of each marked packet until the CSC is no less than F again. However, a ConEx sender might also be less conservative and send fewer credits if it, e.g., assumes that the congestion will be low on a certain path based on previous experience.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのパケットが潜在的に失われたり、輻輳マークを取得可能性があるので、監査の信用状態がゼロになることはありませんことを確認するために、クレジットの数は、常に飛行中のバイト数に等しくなければなりません。この場合には、コーネックス送信者はまた、Fが今までCSCより大きくなると、飛行F.内のバイト数を監視し、コーネックスの送信者は、各CONEX可能なパケットにCフラグを設定し、各マークのペイロードサイズでCSCを増加させますCSCまでのパケットが再びF以上です。しかし、コネックス送信者も少なく保守的で、それは、例えば、輻輳が以前の経験に基づいて、特定のパスに低くなることを前提とした場合、より少ないクレジットを送信することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Recall that the CSC will be decreased whenever congestion occurs; therefore the CSC will need to be replenished as soon as the CSC drops below F. Also recall that the sender can set the C flag on a ConEx-capable packet whether or not the E or L flags are also set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳が発生したときCSCが低下することを思い出してください。 CSCはF.を下回っしたがってCSCはまた、送信者がEまたはLフラグも設定されているか否かをCONEX可能なパケットにCフラグを設定することができることを思い出すとすぐに補充する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In TCP Slow Start, the congestion window might grow much larger than during the rest of the transmission. Likely, a sender could consider sending fewer than F credits but risking being penalized by an audit function. However, the credits should at least cover the increase in sending rate. Given the exponential increase as implemented in the TCP Slow Start algorithm, which means that the sending rate doubles every RTT, a ConEx sender should at least cover half the number of packets in flight by credits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPスロースタートでは、輻輳ウィンドウは、伝送の残りの部分中よりもはるかに大きくなる可能性があります。おそらく、Fクレジットよりも少ない送るが、危険にさらして検討することもでき、送信者は、監査機能により罰せされています。しかし、クレジットは、少なくとも率を送るの増加をカバーする必要があります。送信レートは、すべてのRTTを倍増、コーネックスの送信者は、少なくとも単位で飛行中のパケット数の半分をカバーしなければならないことを意味TCPスロースタートアルゴリズムで実装されている指数関数的な増加を考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the number of losses or markings within one RTT does not depend solely on the sender&#39;s actions. In general, the behavior of the cross traffic, whether Active Queue Management (AQM) is used and how it is parameterized influence how many packets might be dropped or marked. As long as any AQM encountered is not overly aggressive with ECN marking, sending half the flight size as credits should be sufficient whether congestion is signaled by loss or ECN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1 RTT内の損失またはマーキングの数は、送信者の行動だけに依存しないことに注意してください。一般的には、クロストラフィックの挙動は、アクティブキュー管理するかどうか（AQM）が使用され、それは多くのパケットが廃棄またはマークされる可能性がありますどのようにパラメータ化の影響がありますか。限り、任意のAQMが発生したとしてクレジットが輻輳が損失やECNによって通知されているかどうかを十分なものでなければならないとして、半分の飛行サイズを送信、ECNマーキングと過度に積極的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To maintain half of the packets in flight as credits, half of the packet of the initial window must also be C-marked. In Slow Start marking, every fourth packet introduces the correct amount of credit as can be seen in Figure 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クレジットなど、飛行中のパケットの半分を維持するために、最初のウィンドウのパケットの半分もC-マークしなければなりません。図1に見られるようにマーキングスロースタートでは、すべての4番目のパケットは、クレジットの正しい量を紹介します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                        in_flight  credits
                RTT1  |------XC------&gt;|     1         1
                      |------X-------&gt;|     2         1
                      |------XC------&gt;|     3         2
                      |               |
                RTT2  |------X-------&gt;|     3         2
                      |------X-------&gt;|     4         2
                      |------X-------&gt;|     4         2
                      |------XC------&gt;|     5         3
                      |------X-------&gt;|     5         3
                      |------X-------&gt;|     6         3
                      |               |
                RTT3  |------X-------&gt;|     6         3
                      |------XC------&gt;|     7         4
                      |------X-------&gt;|     7         4
                      |------X-------&gt;|     8         4
                      |------X-------&gt;|     8         4
                      |------XC------&gt;|     9         5
                      |------X-------&gt;|     9         5
                      |------X-------&gt;|    10         5
                      |------X-------&gt;|    10         5
                      |------XC------&gt;|    11         6
                      |------X-------&gt;|    11         6
                      |------X-------&gt;|    12         6
                      |      .        |
                      |      :        |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1: Credits in Slow Start (with an initial window of 3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1：（3の最初のウィンドウで）スロースタートでクレジット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is possible that a TCP flow will encounter an audit function without relevant flow state due to, e.g., rerouting or memory limitations. Therefore, the sender needs to detect this case and resend credits. A ConEx sender might reset the credit counter CSC to zero if losses occur in subsequent RTTs (assuming that the sending rate was correctly reduced based on the received congestion signal and using a conservatively large RTT estimation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPフローが再ルーティングまたはメモリの制限、例えば、原因に関連するフロー状態なしで監査機能に遭遇する可能性があります。したがって、送信者はこのケースを検出し、クレジットを再送信する必要があります。損失が後続のRTT（送信レートが正しく受信された輻輳信号に基づいて、還元および保存的に大きいRTT推定を使用していたと仮定して）で発生した場合コーネックス送信者はゼロにクレジットカウンタCSCをリセットするかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section proposes a concrete algorithm for determining how much credit to signal (with a separate approach used for Slow Start). However, experimentation in credit setting algorithms is expected and encouraged. The wider goal of ConEx is to reflect the &#34;cost&#34; of the risk of causing congestion on those that contribute most to it. Thus, experimentation is encouraged to improve or maintain performance while reducing the risk of causing congestion and, therefore potentially reducing the need to signal so much credit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、（スロースタートのために使用され、別のアプローチを）知らせるためにどのくらいのクレジットを決定するための具体的なアルゴリズムを提案します。しかし、クレジット設定アルゴリズムにおける実験が期待して奨励されます。コーネックスの広い目標はそれに最も貢献しているもので渋滞を引き起こすリスクの「コスト」を反映しています。このように、実験が渋滞を引き起こし、したがって潜在的にそんなに信用を通知する必要性を低下させるリスクを削減しながらパフォーマンスを向上させるか、維持することが奨励されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Loss of ConEx Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
コーネックス情報の喪失5.
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Packets carrying ConEx Signals could be discarded themselves. This will be a second order problem (e.g., if the loss probability is 0.1%, the probability of losing a ConEx L signal will be 0.1% of 0.1% = 0.01%). Further, the penalty an audit induces should be proportional to the mismatch of expected ConEx marks and observed congestion, therefore the audit might only slightly increase the loss level of this flow. Therefore, an implementer MAY choose to ignore this problem, accepting instead the risk that an audit function might wrongly penalize a flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コーネックス信号を運ぶパケット自体を破棄することができます。これは、二次問題となる（例えば、損失確率が0.1％、0.1％= 0.01％、0.1％となるコーネックスのL信号を失う確率である場合）。さらに、ペナルティ監査誘導は、したがって、監査はわずかしかこのフローの損失レベルを増加させる可能性があり、予想されるコーネックスマーク観察輻輳のミスマッチに比例するはずです。そのため、実装ではなく、監査機能が誤って流れを罰するかもしれないというリスクを受け入れて、この問題を無視することを選ぶかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nonetheless, a ConEx sender is responsible for always signaling sufficient congestion feedback, and therefore SHOULD remember which packet was marked with either the L, the E, or the C flag. If one of these packets is detected as lost, the sender SHOULD increase the respective gauge(s), LEG or CEG, by the number of lost payload bytes in addition to increasing LEG for the loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それにもかかわらず、コーネックスの送信者は、常に十分な輻輳フィードバックをシグナリングのための責任があり、そのためL、E、またはCフラグのいずれかでマークされたパケットを覚えておいてください。失われたように、これらのパケットの1つが検出された場合、送信者は損失LEGを増加させることに加えて、失われたペイロードバイトの数によって、それぞれのゲージ（複数可）、LEGまたはCEGを増やす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Timeliness of the ConEx Signals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
コネックス信号の6適時
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ConEx Signals will only be useful to a network node within a time delay of about one RTT after the congestion occurred. To avoid further delays, a ConEx sender SHOULD send the ConEx signaling on the next available packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳が発生した後にコーネックスのシグナルは約1 RTTの時間遅延内のネットワーク・ノードに有用であろう。さらに遅延を回避するには、コーネックスの送信者は、次の利用可能なパケットのコネックスシグナリングを送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any or all of the ConEx flags can be used in the same packet, which allows delays to be minimized when multiple signals are pending. The need to set multiple ConEx flags at the same time can occur if, e.g, an ACK is received by the sender that simultaneously indicates that at least one ECN mark was received, and that one or more segments were lost. This may happen during excessive congestion, if the queues overflow even though ECN was used and currently all forwarded packets are marked, while others have to be dropped. Another case when this might happen is when ACKs are lost, so that a subsequent ACK carries summary information not previously available to the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれかまたはコーネックスフラグの全ては、複数の信号が保留されているときに遅延を最小限に抑えることを可能にする同一のパケットで使用することができます。例えば、ACKが同時に少なくとも一つのECNマークが受信されたことを示し、および1つまたは複数のセグメントが失われたことを送信者によって受信される場合、同時に複数のコーネックスフラグを設定する必要が生じる可能性があります。他の人が落下する必要がある一方で、キューは、ECNが使用されていてもオーバーフローし、現在は全て転送されたパケットがマークされている場合、これは、過度の輻輳時に発生する可能性があります。その後のACKが送信者に事前に入手できない要約情報を運ぶようにACKが、失われたときにこれが起こるかもしれないもう一つのケースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a flow becomes application-limited, there could be insufficient bytes to send to reduce the gauges to zero or below. In such cases, the sender cannot help but delay ConEx Signals. Nonetheless, as long as the sender is marking all outgoing packets, an audit function is unlikely to penalize ConEx-Marked packets. Therefore, no matter how long a gauge has been positive, a sender MUST NOT reduce the gauge by more than the ConEx-Marked bytes it has sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フローは、アプリケーション制限になった場合、ゼロ以下にゲージを減少させるために送信するために不十分バイトがあってもよいです。このような場合には、送信者は助けるが、コーネックス信号を遅延することはできません。それにもかかわらず、限り、送信者は、すべての発信パケットをマーキングされるよう、監査機能は、CONEX-マークパケットを罰することはほとんどありません。したがって、関係なくゲージがプラスされているどのくらいの時間、送信者は、送信したCONEX-マークバイト以上でゲージを減らすないてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the CEG or LEG counter is negative, the respective counter MAY be reset to zero within one RTT after it was decreased the last time, or one RTT after recovery if no further congestion occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CEGまたはLEGカウンタが負の場合はそれ以上の渋滞が発生していない場合には、回復した後、最後の時間を減少させ、または1 RTTた後、それぞれのカウンタは1 RTT内にゼロにリセットされることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Open Areas for Experimentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.オープンエリア実験のために
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All proposed mechanisms in this document are experimental, and therefore further large-scale experimentation on the Internet is required to evaluate if the signaling provided by these mechanisms is accurate and timely enough to produce value for ConEx-based (traffic management or other) mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書に記載されているすべての提案されたメカニズムは実験的であり、したがってさらに、インターネット上の大規模な実験は、これらのメカニズムによって提供されるシグナリングはCONEXベース（トラフィック管理または他の）メカニズムのための値を生成するために正確かつ十分にタイムリーであるかどうかを評価する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current ConEx specifications assume that congestion is counted in the number of bytes (including the IP header that directly encapsulates the CDO and everything that the IP header encapsulates) [RFC7837]. This decision was taken because most network devices today experience byte-congestion where the memory is filled exactly with the number of bytes a packet carries [RFC7141]. However, there are also devices that may allocate a certain amount of memory per packet, no matter how large a packet is. These devices get congested based on the number of packets in their memory and therefore, in this case, congestion is determined by the number of packets that have been lost or marked. Furthermore, a transport-layer endpoint such as a TCP sender or receiver, might not know the exact number of bytes that a lower layer was carrying. Therefore, a TCP endpoint may only be able to estimate the exact number of congested bytes (assuming that all lower-layer headers have the same length). If this estimation is sufficient to work with, the ConEx Signal needs to be further evaluated in tests on the Internet together with different auditor implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のコーネックス仕様は、輻輳が（直接CDOおよびIPヘッダをカプセル化するすべてをカプセル化IPヘッダを含む）バイトの数[RFC7837]にカウントされると仮定する。メモリはバイト数で正確に満たされているほとんどのネットワークデバイスは、今日の経験バイト-輻輳がパケットは[RFC7141]を運ぶので、この決定が取られました。しかし、パケットごとに一定量のメモリを割り当てることができるデバイスに関係なく、パケットがどのように大規模な、もありません。これらのデバイスは、そのメモリ内のパケットの数に基づいて、混雑しますので、この場合には、輻輳が失われたり、マークされたパケットの数によって決定されます。また、トランスポート層エンドポイントは、TCPの送信者または受信者として、下層を運んでいたバイト数を正確に知らないかもしれません。したがって、TCPエンドポイントは、輻輳バイト（すべての下層ヘッダーが同じ長さを有すると仮定して）の正確な数を推定することができるかもしれません。この推定はで動作するのに十分である場合には、コーネックス信号は、さらに別の監査の実装とともに、インターネット上の試験で評価する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Further, the proposed marking schemes in this document are designed under the assumption that all TCP packets of a ConEx-capable flow are of equal size or that flows have a constant mean packet size over a rather small time frame, like one RTT or less. In most implementations, this assumption might be taken as well and is probably true for most of the traffic flows. If this proposed scheme is used, it is necessary to evaluate how much accuracy degrades if this precondition is not met. Evaluating with real traffic from different applications is especially important in making the decision regarding whether the proposed schemes are sufficient or whether a more complex scheme is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、本文書で提案マーキング方式はCONEX対応フローのすべてのTCPパケットが同じサイズであること、またはフローが1 RTT以下のように、かなり小さい時間フレームにわたって一定の平均パケットサイズを持っているという仮定の下に設計されています。ほとんどの実装では、この仮定は、同様に取られる可能性があり、トラフィックフローのほとんどのため、おそらく本当です。この提案された方式を使用する場合は、この前提条件が満たされない場合は劣化するどのくらいの精度評価する必要があります。異なるアプリケーションからの実際のトラフィックを評価することは、提案手法が十分以上の複雑なスキームが必要とされているかどうかであるかどうかについての決定を行う際に特に重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this context, the proposed scheme to set credit markings in Slow Start runs the risk of providing an insufficient number of markings, which can cause an audit function to penalize this flow. Both the proposed credit scheme for Slow Start as well as the scheme in Congestion Avoidance must be evaluated together with one or more specific implementations of a ConEx auditor to ensure that both algorithms, in the sender and in the auditor, work properly together with a low risk of false positives (which would lead to penalization of an honest sender). However, if a sender is wrongly assumed to cheat, the penalization of the audit should be adequate and should allow an honest sender using a congestion control scheme that is commonly used today to recover quickly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文脈において、スロースタートで信用マーキングを設定するために提案されたスキームは、この流れを不利に監査機能を引き起こすことができるマーキングの不十分な数を提供する危険を冒します。提案されたクレジットスキームのスロースタート並びに輻輳回避におけるスキームは、送信者及び監査人の両方のアルゴリズムは、低いと適切に一緒に動作することを保証するために、コーネックスの監査役の一つ以上の特定の実装と一緒に評価されなければならないの両方（正直な送信者の処罰につながる）偽陽性のリスク。送信者が誤ってカンニングすると想定される場合には、監査の処罰が十分でなければならないと一般的に迅速に回復するために、今日使用されている輻輳制御方式を使用して、正直、送信者を許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another open issue is the accuracy of the ECN feedback signal. At the time of this document&#39;s publication, there is no AccECN mechanism specified yet, and further AccECN will also take some time to be widely deployed. This document proposes an advanced compatibility mode for classic ECN. The proposed mechanism can provide more accurate feedback by utilizing the way classic ECN is specified but has a higher risk of losing information. To figure out how high this risk is in a real deployment scenario, further experimental evaluation is needed. The following argument is intended to prove that suppressing repetitions of ECE, however, is still safe against possible congestion collapse due to lost congestion feedback and should be further proven in experimentation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もう一つの未解決の問題は、ECNフィードバック信号の精度です。このドキュメントの公開時点で、そこにまだ指定されていませんAccECNメカニズムはなく、さらにAccECNも広く展開するためにいくつかの時間がかかります。この文書では、古典的なECNのための高度な互換モードを提案しています。提案されたメカニズムは、古典的なECNは、指定されたが、情報を失うリスクが高いされている方法を利用することにより、より正確なフィードバックを提供することができます。このリスクが現実の展開シナリオでどのように高い把握するために、さらに実験的評価が必要とされています。次の引数ECEの繰り返しを抑制することを証明するために意図されたが、しかし、まだ失われた混雑フィードバックに起因する可能性輻輳崩壊に対して安全であり、さらなる実験で証明する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Repetition of ECE in classic ECN is intended to ensure reliable delivery of congestion feedback. However, with advanced compatibility mode, it is possible to miss congestion notifications. This can happen in some implementations if delayed acknowledgements are used. Further, an ACK containing ECE can simply get lost. If only a few CE marks are received within one congestion event (e.g., only one), the loss of one acknowledgement due to (heavy) congestion on the reverse path can prevent that any congestion notification is received by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
古典的なECNにおけるECEの繰り返しが混雑フィードバックの信頼性の高い配信を確実にするためのものです。しかし、高度な互換モードでは、輻輳通知を欠場することが可能です。遅れて確認応答が使用されている場合、これはいくつかの実装で発生する可能性があります。さらに、ECEを含むACKは、単に迷子になることができます。ほんの数CEマーク一つの輻輳イベント内で受信された場合（例えば、一方のみ）による逆経路上の（重）輻輳への1つの肯定応答の損失は、任意の輻輳通知が送信者によって受信されることを防止することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, if loss of feedback exacerbates congestion on the forward path, more forward packets will be CE-marked, increasing the likelihood that feedback from at least one CE will get through per RTT. As long as one ECE reaches the sender per RTT, the sender&#39;s congestion response will be the same as if CWR were not continuous. The only way that heavy congestion on the forward path could be completely hidden would be if all ACKs on the reverse path were lost. If total ACK loss persisted, the sender would time out and do a congestion response anyway. Therefore, the problem seems confined to potential suppression of a congestion response during light congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィードバックの損失は順方向経路上の混雑を悪化させる場合は、より多くのパケットを転送し、少なくとも1つのCEからのフィードバックは、RTTごとに介して取得する可能性を高め、CEマーク付きになります。 CWRが連続していないかのように限り1つのECEはRTTごとに、送信者に到達したとして、送信者の混雑応答は同じになります。逆の経路上の全てのACKが失われた場合、往路の混雑を完全に隠すことができることを唯一の方法は次のようになります。総ACK損失が持続した場合、送信者がタイムアウトして、とにかく混雑応答を行うだろう。したがって、問題は、軽輻輳時の輻輳応答の潜在的抑制に限定思われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Furthermore, even if loss of all ECN feedback leads to no congestion response, the worst that could happen would be loss instead of ECN-signaled congestion on the forward path. Given that compatibility mode does not affect loss feedback, there would be no risk of congestion collapse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、すべてのECNフィードバックの損失が無い渋滞応答につながる場合でも、起こり得る最悪の事態ではなく、フォワードパス上ECN-合図混雑の損失になります。互換モードが損失フィードバックには影響しないことを考えると、輻輳崩壊の危険性はないだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
General ConEx security considerations are covered extensively in the ConEx abstract mechanism [RFC7713]. This section covers TCP-specific concerns that may occur with the addition of ConEx to TCP (while not discussing generally well-known attacks against TCP). It is assumed that any altering of ConEx information can be detected by protection mechanisms in the IP layer and is, therefore, not discussed here but in [RFC7837]. Further, [RFC7837] describes how to use ConEx to mitigate flooding attacks by using preferential drop where the use of ConEx can even increase security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的なコーネックスのセキュリティの考慮事項は、コーネックス抽象メカニズム[RFC7713]で広く覆われています。このセクションでは、TCPのコーネックスの添加で発生する可能性がTCP固有の問題（TCPに対して一般的によく知られている攻撃を議論していない間）をカバーしています。コーネックス情報の任意の変更は、IP層に保護メカニズムによって検出することができ、したがって、ここではなく、[RFC7837]で議論されていないことが想定されます。さらに、[RFC7837]はコーネックスの使用でも、セキュリティを高めることができ、優先ドロップを使用してフラッド攻撃を軽減するためにコーネックスを使用する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ConEx modifications to TCP provide no mechanism for a receiver to force a sender not to use ConEx. A receiver can degrade the accuracy of ConEx by claiming that it does not support SACK, AccECN, or ECN, but the sender will never have to turn ConEx off. Further, the receiver cannot force the sender to have to mark ConEx more conservatively, in order to cover the risk of any inaccuracy. Instead, it is always the sender&#39;s choice to either mark very conservatively, which ensures that the audit always sees enough markings to not penalize the flow, or estimate the needed number of markings more tightly. This second case can lead to inaccurate marking, and therefore increases the likelihood of loss at an audit function that will only harm the receiver itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPにコーネックス修飾は、コーネックスを使用しない送信者を強制的に受信するためのメカニズムを提供しません。受信機は、それがSACK、AccECN、またはECNをサポートしていないと主張することによってコーネックスの精度を低下させることができますが、送信者はコーネックスをオフにする必要はありません。さらに、受信機は、任意の不正確さのリスクをカバーするために、より保守的にコーネックスをマークする必要が送信者を強制することはできません。その代わりに、監査が常に流れを処罰しないように十分なマーキングを見て、またはより緊密にマーキングの必要数を推定することが保証され、非常に保守的に常にどちらかのマークに、送信者の選択です。この第二の場合は、マーキング不正確につながり、したがってのみ受信自体を害するであろう監査機能での損失の可能性を増大させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Assuming the sender is limited in some way by a congestion allowance or quota, a receiver could spoof more loss or ECN congestion feedback than it actually experiences, in an attempt to make the sender draw down its allowance faster than necessary. However, over-declaring congestion simply makes the sender slow down. If the receiver is interested in the content, it will not want to harm its own performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者が混雑手当またはクォータによって何らかの方法で限定されていると仮定すると、受信側は送信側が速く必要以上の手当を描き下ろし作るための試みで、その実際の経験よりも損失やECNの輻輳フィードバックをだますことができます。輻輳を宣言する上で、しかし、単に送信者が遅くなります。受信機は、コンテンツに興味があるならば、それは自身のパフォーマンスに悪影響を与えるとは思わないだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, if the receiver is solely interested in making the sender draw down its allowance, the net effect will depend on the sender&#39;s congestion control algorithm as permanently adding more and more additional congestion would cause the sender to more and more reduce its sending rate. Therefore, a receiver can only maintain a certain congestion level that is corresponding to a certain sending rate. With NewReno [RFC6582], doubling congestion feedback causes the sender to reduce its sending rate such that it would only consume sqrt(2) = 1.4 times more congestion allowance. However, to improve scaling, congestion control algorithms are tending towards less responsive algorithms like Cubic or Compound TCP, and ultimately to linear algorithms like Data Center TCP (DCTCP) [DCTCP] that aim to maintain the same congestion level independent of the current sending rate and always reduce its sending window if the signaled congestion feedback is higher. In each case, if the receiver doubles congestion feedback, it causes the sender to respectively consume more allowance by a factor of 1.2, 1.15, or 1, where 1 implies the attack has become completely ineffective as no further congestion allowance is consumed but the flow will decrease its sending rate to a minimum instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機は、送信者がその手当をドローダウンすることで、単に興味がある場合は、正味の効果は、より多くの追加の輻輳を追加すると、送信者が、より多くのその送信速度を低下させる原因となるよう永久に送信者の輻輳制御アルゴリズムに依存します。したがって、受信機は、特定の送信レートに相当する一定の輻輳レベルを維持することができます。 NewRenoの[RFC6582]と、輻輳フィードバックを倍増することは、唯一のSQRT（2）= 1.4倍以上輻輳余裕を消費するように、その送信レートを低減するために、送信者を引き起こします。しかし、スケーリングを改善するために、輻輳制御アルゴリズムは、現在の送信レートとは無関係に同じ輻輳レベルを維持することを目指すデータセンターTCP（DCTCP）[DCTCP]のような直線的なアルゴリズムに最終的にはキュービックまたは化合TCPのようにそれほど応答アルゴリズム向かう傾向、とされています合図混雑フィードバックが高い場合は、常にその送信ウィンドウを減らします。受信機が輻輳フィードバックを兼ねている場合、それぞれの場合において、それはそれぞれ1は更なる輻輳余裕が消費されないように攻撃が完全に無効となっている意味1.2、1.15、又は1の因子が、流れによって、より余裕を消費する送信者を引き起こします代わりに、最小限にその送信レートを減少します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &#34;TCP Selective Acknowledgment Options&#34;, RFC 2018, DOI 10.17487/RFC2018, October 1996, &lt;http://www.rfc-editor.org/info/rfc2018&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 &#34;TCPの選択確認応答オプション&#34;、RFC 2018、DOI 10.17487 / RFC2018、1996年10月、&lt;HTTP：//www.rfc- editor.org/info/rfc2018&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, DOI 10.17487/RFC3168, September 2001, &lt;http://www.rfc-editor.org/info/rfc3168&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;IPへの明示的輻輳通知の追加（ECN）&#34; [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、&lt;のhttp：// WWW。 rfc-editor.org/info/rfc3168&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, DOI 10.17487/RFC5681, September 2009, &lt;http://www.rfc-editor.org/info/rfc5681&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 &#34;TCP輻輳制御&#34;、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、&lt;http://www.rfc-editor.org/info/ rfc5681&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7713] Mathis, M. and B. Briscoe, &#34;Congestion Exposure (ConEx) Concepts, Abstract Mechanism, and Requirements&#34;, RFC 7713, DOI 10.17487/RFC7713, December 2015, &lt;http://www.rfc-editor.org/info/rfc7713&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7713]マティス、M.及びB.ブリスコウ、 &#34;輻輳露光（CONEX）概念、抽象メカニズム、および要件&#34;、RFC 7713、DOI 10.17487 / RFC7713、2015年12月、&lt;http://www.rfc-editor.org /情報/ rfc7713&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7837] Krishnan, S., Kuehlewind, M., Briscoe, B., and C. Ralli, &#34;IPv6 Destination Option for Congestion Exposure (ConEx)&#34;, RFC 7837, DOI 10.17487/RFC7837, May 2016, &lt;http://www.rfc-editor.org/info/rfc7837&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7837]クリシュナン、S.、Kuehlewind、M.、ブリスコー、B.、およびC. Ralli、 &#34;IPv6宛先輻輳曝露のためのオプション（コーネックス）&#34;、RFC 7837、DOI 10.17487 / RFC7837、2016年5月、&lt;HTTP：/ /www.rfc-editor.org/info/rfc7837&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ACCURATE] Briscoe, B., Kuehlewind, M., and R. Scheffenegger, &#34;More Accurate ECN Feedback in TCP&#34;, Work in Progress, draft-ietf-tcpm-accurate-ecn-00, December 2015.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ACCURATE]ブリスコー、B.、Kuehlewind、M.、およびR. Scheffenegger、 &#34;TCPで、より正確なECNフィードバック&#34; が進行中で働いて、ドラフト-IETF-tcpm精度-ECN-00、2015年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DCTCP] Alizadeh, M., Greenberg, A., Maltz, D., Padhye, J., Patel, P., Prabhakar, B., Sengupta, S., and M. Sridharan, &#34;Data Center TCP (DCTCP)&#34;, ACM SIGCOMM Computer Communication Review, Volume 40, Issue 4, pages 63-74, DOI 10.1145/1851182.1851192, October 2010, &lt;http://portal.acm.org/citation.cfm?id=1851192&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【DCTCP] Alizadeh、M.、グリーンバーグ、A.、モルツ、D.、Padhye、J.、パテル、P.、Prabhakar、B.、Sengupta、S.、およびM. Sridharan、「データセンターTCP（DCTCP） 」、ACM SIGCOMMコンピュータコミュニケーションレビュー、40巻、4号、頁63-74、DOI 10.1145 / 1851182.1851192、2010年10月、&lt;http://portal.acm.org/citation.cfm?id=1851192&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ECNTCP] Briscoe, B., Jacquet, A., Moncaster, T., and A. Smith, &#34;Re-ECN: Adding Accountability for Causing Congestion to TCP/IP&#34;, Work in Progress, draft-briscoe-conex-re-ecn-tcp-04, July 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【ECNTCP】ブリスコー、B.、ジャケ、A.、Moncaster、T.、およびA.スミス、 &#34;再ECN：TCP / IPに輻輳を発生させるための責任の追加&#34;、進行中で働いて、ドラフトブリスコー-CONEX-RE -ecn-TCP-04、2014年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3522] Ludwig, R. and M. Meyer, &#34;The Eifel Detection Algorithm for TCP&#34;, RFC 3522, DOI 10.17487/RFC3522, April 2003, &lt;http://www.rfc-editor.org/info/rfc3522&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3522]ルートヴィヒ、R.及びM.マイヤー、 &#34;TCPのためのアイフェル検出アルゴリズム&#34;、RFC 3522、DOI 10.17487 / RFC3522、2003年4月、&lt;http://www.rfc-editor.org/info/rfc3522&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3708] Blanton, E. and M. Allman, &#34;Using TCP Duplicate Selective Acknowledgement (DSACKs) and Stream Control Transmission Protocol (SCTP) Duplicate Transmission Sequence Numbers (TSNs) to Detect Spurious Retransmissions&#34;, RFC 3708, DOI 10.17487/RFC3708, February 2004, &lt;http://www.rfc-editor.org/info/rfc3708&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3708] &#34;スプリアス再送を検出するためにTCP複製選択的確認応答（DSACKs）およびストリーム制御伝送プロトコル（SCTP）重複送信シーケンス番号（TSNを）を使用して&#34; ブラントン、E.およびM.オールマン、RFC 3708、DOI 10.17487 / RFC3708、 2004年2月、&lt;http://www.rfc-editor.org/info/rfc3708&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4015] Ludwig, R. and A. Gurtov, &#34;The Eifel Response Algorithm for TCP&#34;, RFC 4015, DOI 10.17487/RFC4015, February 2005, &lt;http://www.rfc-editor.org/info/rfc4015&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4015]ルートヴィヒ、R.とA. Gurtov、 &#34;TCPのためのアイフェルレスポンスアルゴリズム&#34;、RFC 4015、DOI 10.17487 / RFC4015、2005年2月、&lt;http://www.rfc-editor.org/info/rfc4015&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5682] Sarolahti, P., Kojo, M., Yamamoto, K., and M. Hata, &#34;Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP&#34;, RFC 5682, DOI 10.17487/RFC5682, September 2009, &lt;http://www.rfc-editor.org/info/rfc5682&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5682] Sarolahti、P.、古城、M.、山本、K.、およびM.秦、 &#34;フォワードRTOリカバリ（F-RTO）：TCPとスプリアス再送タイムアウトを検出するためのアルゴリズム&#34;、RFC 5682、DOI 10.17487 / RFC5682、2009年9月、&lt;http://www.rfc-editor.org/info/rfc5682&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6582] Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, &#34;The NewReno Modification to TCP&#39;s Fast Recovery Algorithm&#34;, RFC 6582, DOI 10.17487/RFC6582, April 2012, &lt;http://www.rfc-editor.org/info/rfc6582&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6582]ヘンダーソン、T.、フロイド、S.、Gurtov、A.、およびY.西田、 &#34;TCPの速い回復アルゴリズムへのNewRenoの変更&#34;、RFC 6582、DOI 10.17487 / RFC6582、2012年4月、&lt;のhttp：// www.rfc-editor.org/info/rfc6582&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6789] Briscoe, B., Ed., Woundy, R., Ed., and A. Cooper, Ed., &#34;Congestion Exposure (ConEx) Concepts and Use Cases&#34;, RFC 6789, DOI 10.17487/RFC6789, December 2012, &lt;http://www.rfc-editor.org/info/rfc6789&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6789]ブリスコー、B.、エド。、Woundy、R.、エド。、およびA.クーパー、エド。、 &#34;輻輳露出（コーネックス）の概念とユースケース&#34;、RFC 6789、DOI 10.17487 / RFC6789、2012年12月、 &lt;http://www.rfc-editor.org/info/rfc6789&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7141] Briscoe, B. and J. Manner, &#34;Byte and Packet Congestion Notification&#34;, BCP 41, RFC 7141, DOI 10.17487/RFC7141, February 2014, &lt;http://www.rfc-editor.org/info/rfc7141&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7141]ブリスコー、B.及びJ.マナー、 &#34;バイトおよびパケット輻輳通知&#34;、BCP 41、RFC 7141、DOI 10.17487 / RFC7141、2014年2月、&lt;http://www.rfc-editor.org/info/rfc7141 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The authors would like to thank Bob Briscoe who contributed with these initial ideas [ECNTCP] and valuable feedback. Moreover, thanks to Jana Iyengar who also provided valuable feedback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者らは、これらの初期のアイデア[ECNTCP]と貴重なフィードバックに貢献したボブ・ブリスコーに感謝したいと思います。また、貴重なフィードバックを提供しヤナアイアンガーのおかげ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mirja Kuehlewind (editor) ETH Zurich Switzerland
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mirja Kuehlewind（エディタ）ETHチューリッヒスイス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Email: mirja.kuehlewind@tik.ee.ethz.ch
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メール：mirja.kuehlewind@tik.ee.ethz.ch
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Richard Scheffenegger NetApp, Inc. Am Euro Platz 2 Vienna 1120 Austria
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リチャードScheffeneggerのNetApp、Inc.のアムプラッツユーロ2 1120ウィーンオーストリア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Email: rs.ietf@gmx.at
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メール：rs.ietf@gmx.at
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
