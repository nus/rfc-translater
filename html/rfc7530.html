<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7530 - Network File System (NFS) Version 4 Protocol 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
    <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7530 - Network File System (NFS) Version 4 Protocol 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7530">
              https://tools.ietf.org/html/rfc7530
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7530 - ネットワークファイルシステム（NFS）バージョン4プロトコル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                    T. Haynes, Ed.
Request for Comments: 7530                                  Primary Data
Obsoletes: 3530                                           D. Noveck, Ed.
Category: Standards Track                                           Dell
ISSN: 2070-1721                                               March 2015
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Network File System (NFS) Version 4 Protocol
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Network File System (NFS) version 4 protocol is a distributed file system protocol that builds on the heritage of NFS protocol version 2 (RFC 1094) and version 3 (RFC 1813). Unlike earlier versions, the NFS version 4 protocol supports traditional file access while integrating support for file locking and the MOUNT protocol. In addition, support for strong security (and its negotiation), COMPOUND operations, client caching, and internationalization has been added. Of course, attention has been applied to making NFS version 4 operate well in an Internet environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークファイルシステム（NFS）バージョン4プロトコルは、NFSプロトコルバージョン2（RFC 1094）とバージョン3（RFC 1813）の遺産の上に構築分散ファイルシステムプロトコルです。ファイルのロックとMOUNTプロトコルのサポートを統合しながら、以前のバージョンとは異なり、NFSバージョン4プロトコルは、従来のファイル・アクセスをサポートします。また、強力なセキュリティ（およびその交渉）、化合物の操作、クライアントのキャッシュ、および国際化のためのサポートが追加されました。もちろん、注意はNFSバージョン4は、インターネット環境でも動作させるに適用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document, together with the companion External Data Representation (XDR) description document, RFC 7531, obsoletes RFC 3530 as the definition of the NFS version 4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、一緒にコンパニオン外部データ表現（XDR）記述文書、RFC 7531で、NFSバージョン4プロトコルの定義としてRFC 3530を廃止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7530.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7530で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................8
      1.1. Requirements Language ......................................8
      1.2. NFS Version 4 Goals ........................................8
      1.3. Definitions in the Companion Document RFC 7531 Are
           Authoritative ..............................................9
      1.4. Overview of NFSv4 Features .................................9
           1.4.1. RPC and Security ....................................9
           1.4.2. Procedure and Operation Structure ..................10
           1.4.3. File System Model ..................................10
           1.4.4. OPEN and CLOSE .....................................12
           1.4.5. File Locking .......................................12
           1.4.6. Client Caching and Delegation ......................13
      1.5. General Definitions .......................................14
      1.6. Changes since RFC 3530 ....................................16
      1.7. Changes between RFC 3010 and RFC 3530 .....................16
   2. Protocol Data Types ............................................18
      2.1. Basic Data Types ..........................................18
      2.2. Structured Data Types .....................................21
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   3. RPC and Security Flavor ........................................25
      3.1. Ports and Transports ......................................25
           3.1.1. Client Retransmission Behavior .....................26
      3.2. Security Flavors ..........................................27
           3.2.1. Security Mechanisms for NFSv4 ......................27
      3.3. Security Negotiation ......................................28
           3.3.1. SECINFO ............................................29
           3.3.2. Security Error .....................................29
           3.3.3. Callback RPC Authentication ........................29
   4. Filehandles ....................................................30
      4.1. Obtaining the First Filehandle ............................30
           4.1.1. Root Filehandle ....................................31
           4.1.2. Public Filehandle ..................................31
      4.2. Filehandle Types ..........................................31
           4.2.1. General Properties of a Filehandle .................32
           4.2.2. Persistent Filehandle ..............................32
           4.2.3. Volatile Filehandle ................................33
           4.2.4. One Method of Constructing a Volatile Filehandle ...34
      4.3. Client Recovery from Filehandle Expiration ................35
   5. Attributes .....................................................35
      5.1. REQUIRED Attributes .......................................37
      5.2. RECOMMENDED Attributes ....................................37
      5.3. Named Attributes ..........................................37
      5.4. Classification of Attributes ..............................39
      5.5. Set-Only and Get-Only Attributes ..........................40
      5.6. REQUIRED Attributes - List and Definition References ......40
      5.7. RECOMMENDED Attributes - List and Definition References ...41
      5.8. Attribute Definitions .....................................42
           5.8.1. Definitions of REQUIRED Attributes .................42
           5.8.2. Definitions of Uncategorized RECOMMENDED
                  Attributes .........................................45
      5.9. Interpreting owner and owner_group ........................51
      5.10. Character Case Attributes ................................53
   6. Access Control Attributes ......................................54
      6.1. Goals .....................................................54
      6.2. File Attributes Discussion ................................55
           6.2.1. Attribute 12: acl ..................................55
           6.2.2. Attribute 33: mode .................................70
      6.3. Common Methods ............................................71
           6.3.1. Interpreting an ACL ................................71
           6.3.2. Computing a mode Attribute from an ACL .............72
      6.4. Requirements ..............................................73
           6.4.1. Setting the mode and/or ACL Attributes .............74
           6.4.2. Retrieving the mode and/or ACL Attributes ..........75
           6.4.3. Creating New Objects ...............................75
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   7. NFS Server Namespace ...........................................77
      7.1. Server Exports ............................................77
      7.2. Browsing Exports ..........................................77
      7.3. Server Pseudo-File System .................................78
      7.4. Multiple Roots ............................................79
      7.5. Filehandle Volatility .....................................79
      7.6. Exported Root .............................................79
      7.7. Mount Point Crossing ......................................79
      7.8. Security Policy and Namespace Presentation ................80
   8. Multi-Server Namespace .........................................81
      8.1. Location Attributes .......................................81
      8.2. File System Presence or Absence ...........................81
      8.3. Getting Attributes for an Absent File System ..............83
           8.3.1. GETATTR within an Absent File System ...............83
           8.3.2. READDIR and Absent File Systems ....................84
      8.4. Uses of Location Information ..............................84
           8.4.1. File System Replication ............................85
           8.4.2. File System Migration ..............................86
           8.4.3. Referrals ..........................................86
      8.5. Location Entries and Server Identity ......................87
      8.6. Additional Client-Side Considerations .....................88
      8.7. Effecting File System Referrals ...........................89
           8.7.1. Referral Example (LOOKUP) ..........................89
           8.7.2. Referral Example (READDIR) .........................93
      8.8. The Attribute fs_locations ................................96
   9. File Locking and Share Reservations ............................98
      9.1. Opens and Byte-Range Locks ................................99
           9.1.1. Client ID ..........................................99
           9.1.2. Server Release of Client ID .......................102
           9.1.3. Use of Seqids .....................................103
           9.1.4. Stateid Definition ................................104
           9.1.5. Lock-Owner ........................................110
           9.1.6. Use of the Stateid and Locking ....................110
           9.1.7. Sequencing of Lock Requests .......................113
           9.1.8. Recovery from Replayed Requests ...................114
           9.1.9. Interactions of Multiple Sequence Values ..........114
           9.1.10. Releasing State-Owner State ......................115
           9.1.11. Use of Open Confirmation .........................116
      9.2. Lock Ranges ..............................................117
      9.3. Upgrading and Downgrading Locks ..........................117
      9.4. Blocking Locks ...........................................118
      9.5. Lease Renewal ............................................119
      9.6. Crash Recovery ...........................................120
           9.6.1. Client Failure and Recovery .......................120
           9.6.2. Server Failure and Recovery .......................120
           9.6.3. Network Partitions and Recovery ...................122
      9.7. Recovery from a Lock Request Timeout or Abort ............130
      9.8. Server Revocation of Locks ...............................130
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      9.9. Share Reservations .......................................132
      9.10. OPEN/CLOSE Operations ...................................132
           9.10.1. Close and Retention of State Information .........133
      9.11. Open Upgrade and Downgrade ..............................134
      9.12. Short and Long Leases ...................................135
      9.13. Clocks, Propagation Delay, and Calculating Lease
            Expiration ..............................................135
      9.14. Migration, Replication, and State .......................136
           9.14.1. Migration and State ..............................136
           9.14.2. Replication and State ............................137
           9.14.3. Notification of Migrated Lease ...................137
           9.14.4. Migration and the lease_time Attribute ...........138
   10. Client-Side Caching ..........................................139
      10.1. Performance Challenges for Client-Side Caching ..........139
      10.2. Delegation and Callbacks ................................140
           10.2.1. Delegation Recovery ..............................142
      10.3. Data Caching ............................................147
           10.3.1. Data Caching and OPENs ...........................147
           10.3.2. Data Caching and File Locking ....................148
           10.3.3. Data Caching and Mandatory File Locking ..........150
           10.3.4. Data Caching and File Identity ...................150
      10.4. Open Delegation .........................................151
           10.4.1. Open Delegation and Data Caching .................154
           10.4.2. Open Delegation and File Locks ...................155
           10.4.3. Handling of CB_GETATTR ...........................155
           10.4.4. Recall of Open Delegation ........................158
           10.4.5. OPEN Delegation Race with CB_RECALL ..............160
           10.4.6. Clients That Fail to Honor Delegation Recalls ....161
           10.4.7. Delegation Revocation ............................162
      10.5. Data Caching and Revocation .............................162
           10.5.1. Revocation Recovery for Write Open Delegation ....163
      10.6. Attribute Caching .......................................164
      10.7. Data and Metadata Caching and Memory-Mapped Files .......166
      10.8. Name Caching ............................................168
      10.9. Directory Caching .......................................169
   11. Minor Versioning .............................................170
   12. Internationalization .........................................170
      12.1. Introduction ............................................170
      12.2. Limitations on Internationalization-Related
            Processing in the NFSv4 Context .........................172
      12.3. Summary of Server Behavior Types ........................173
      12.4. String Encoding .........................................173
      12.5. Normalization ...........................................174
      12.6. Types with Processing Defined by Other Internet Areas ...175
      12.7. Errors Related to UTF-8 .................................177
      12.8. Servers That Accept File Component Names That
            Are Not Valid UTF-8 Strings .............................177
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   13. Error Values .................................................178
      13.1. Error Definitions .......................................179
           13.1.1. General Errors ...................................180
           13.1.2. Filehandle Errors ................................181
           13.1.3. Compound Structure Errors ........................183
           13.1.4. File System Errors ...............................184
           13.1.5. State Management Errors ..........................186
           13.1.6. Security Errors ..................................187
           13.1.7. Name Errors ......................................187
           13.1.8. Locking Errors ...................................188
           13.1.9. Reclaim Errors ...................................190
           13.1.10. Client Management Errors ........................191
           13.1.11. Attribute Handling Errors .......................191
           13.1.12. Miscellaneous Errors ............................191
      13.2. Operations and Their Valid Errors .......................192
      13.3. Callback Operations and Their Valid Errors ..............200
      13.4. Errors and the Operations That Use Them .................201
   14. NFSv4 Requests ...............................................206
      14.1. COMPOUND Procedure ......................................207
      14.2. Evaluation of a COMPOUND Request ........................207
      14.3. Synchronous Modifying Operations ........................208
      14.4. Operation Values ........................................208
   15. NFSv4 Procedures .............................................209
      15.1. Procedure 0: NULL - No Operation ........................209
      15.2. Procedure 1: COMPOUND - COMPOUND Operations .............210
   16. NFSv4 Operations .............................................214
      16.1. Operation 3: ACCESS - Check Access Rights ...............214
      16.2. Operation 4: CLOSE - Close File .........................217
      16.3. Operation 5: COMMIT - Commit Cached Data ................218
      16.4. Operation 6: CREATE - Create a Non-regular File Object ..221
      16.5. Operation 7: DELEGPURGE - Purge Delegations
            Awaiting Recovery .......................................224
      16.6. Operation 8: DELEGRETURN - Return Delegation ............226
      16.7. Operation 9: GETATTR - Get Attributes ...................227
      16.8. Operation 10: GETFH - Get Current Filehandle ............229
      16.9. Operation 11: LINK - Create Link to a File ..............230
      16.10. Operation 12: LOCK - Create Lock .......................232
      16.11. Operation 13: LOCKT - Test for Lock ....................236
      16.12. Operation 14: LOCKU - Unlock File ......................238
      16.13. Operation 15: LOOKUP - Look Up Filename ................240
      16.14. Operation 16: LOOKUPP - Look Up Parent Directory .......242
      16.15. Operation 17: NVERIFY - Verify Difference in
             Attributes .............................................243
      16.16. Operation 18: OPEN - Open a Regular File ...............245
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      16.17. Operation 19: OPENATTR - Open Named Attribute
             Directory ..............................................256
      16.18. Operation 20: OPEN_CONFIRM - Confirm Open ..............257
      16.19. Operation 21: OPEN_DOWNGRADE - Reduce Open File
             Access .................................................260
      16.20. Operation 22: PUTFH - Set Current Filehandle ...........262
      16.21. Operation 23: PUTPUBFH - Set Public Filehandle .........263
      16.22. Operation 24: PUTROOTFH - Set Root Filehandle ..........265
      16.23. Operation 25: READ - Read from File ....................266
      16.24. Operation 26: READDIR - Read Directory .................269
      16.25. Operation 27: READLINK - Read Symbolic Link ............273
      16.26. Operation 28: REMOVE - Remove File System Object .......274
      16.27. Operation 29: RENAME - Rename Directory Entry ..........276
      16.28. Operation 30: RENEW - Renew a Lease ....................278
      16.29. Operation 31: RESTOREFH - Restore Saved Filehandle .....280
      16.30. Operation 32: SAVEFH - Save Current Filehandle .........281
      16.31. Operation 33: SECINFO - Obtain Available Security ......282
      16.32. Operation 34: SETATTR - Set Attributes .................286
      16.33. Operation 35: SETCLIENTID - Negotiate Client ID ........289
      16.34. Operation 36: SETCLIENTID_CONFIRM - Confirm Client ID ..293
      16.35. Operation 37: VERIFY - Verify Same Attributes ..........297
      16.36. Operation 38: WRITE - Write to File ....................299
      16.37. Operation 39: RELEASE_LOCKOWNER - Release
             Lock-Owner State .......................................304
      16.38. Operation 10044: ILLEGAL - Illegal Operation ...........305
   17. NFSv4 Callback Procedures ....................................306
      17.1. Procedure 0: CB_NULL - No Operation .....................306
      17.2. Procedure 1: CB_COMPOUND - COMPOUND Operations ..........307
   18. NFSv4 Callback Operations ....................................309
      18.1. Operation 3: CB_GETATTR - Get Attributes ................309
      18.2. Operation 4: CB_RECALL - Recall an Open Delegation ......310
      18.3. Operation 10044: CB_ILLEGAL - Illegal Callback
            Operation ...............................................311
   19. Security Considerations ......................................312
   20. IANA Considerations ..........................................314
      20.1. Named Attribute Definitions .............................314
           20.1.1. Initial Registry .................................315
           20.1.2. Updating Registrations ...........................315
      20.2. Updates to Existing IANA Registries .....................315
   21. References ...................................................316
      21.1. Normative References ....................................316
      21.2. Informative References ..................................318
   Acknowledgments ..................................................322
   Authors&#39; Addresses ...............................................323
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119], except where &#34;REQUIRED&#34; and &#34;RECOMMENDED&#34; are used as qualifiers to distinguish classes of attributes as described in Sections 1.4.3.2 and 5 of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますRFC 2119 [RFC2119]に記載されている場合を除き、解釈される場合、「REQUIRED」と「推奨」セクション1.4.3.2この文書の5に記載されているように属性のクラスを区別するための修飾子として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. NFS Version 4 Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。 NFSバージョン4つの目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Network File System version 4 (NFSv4) protocol is a further revision of the NFS protocol defined already by versions 2 [RFC1094] and 3 [RFC1813]. It retains the essential characteristics of previous versions: design for easy recovery; independent of transport protocols, operating systems, and file systems; simplicity; and good performance. The NFSv4 revision has the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークファイルシステムバージョン4（NFSv4の）プロトコルのバージョン2 [RFC1094]及び3 [RFC1813]で既に定義されたNFSプロトコルのさらなるリビジョンです。これは、以前のバージョンの本質的な特徴を保持：簡単に回復のためのデザインを、トランスポートプロトコル、オペレーティング・システム、およびファイル・システムとは独立して、シンプルさ。そして、優れたパフォーマンス。 NFSv4のリビジョンは次の目標を持っています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Improved access and good performance on the Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O、インターネット上のアクセスと優れたパフォーマンスを改善しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The protocol is designed to transit firewalls easily, perform well where latency is high and bandwidth is low, and scale to very large numbers of clients per server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルは、レイテンシが高く、帯域幅が低い場合も実行し、簡単にトランジットのファイアウォールに設計されており、サーバーあたりのクライアントの規模に非常に大きな数字です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Strong security with negotiation built into the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O交渉を持つ強力なセキュリティプロトコルに組み込まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The protocol builds on the work of the Open Network Computing (ONC) Remote Procedure Call (RPC) working group in supporting the RPCSEC_GSS protocol (see both [RFC2203] and [RFC5403]). Additionally, the NFSv4 protocol provides a mechanism to allow clients and servers the ability to negotiate security and require clients and servers to support a minimal set of security schemes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルは、オープンネットワークコンピューティング（ONC）リモートプロシージャコール（RPC）RPCSEC_GSSプロトコルをサポートするワーキンググループ（[RFC2203]と[RFC5403]の両方を参照）の仕事に基づいています。また、NFSv4のプロトコルは、クライアントとサーバにセキュリティをネゴシエートし、セキュリティ方式の最小セットをサポートするために、クライアントとサーバーを必要とする機能を許可するためのメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Good cross-platform interoperability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oグッドクロスプラットフォームの相互運用性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The protocol features a file system model that provides a useful, common set of features that does not unduly favor one file system or operating system over another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルは不当に別の上に1つのファイル・システムまたはオペレーティング・システムを支持していない機能の便利な、共通セットを提供し、ファイルシステムのモデルを提供しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Designed for protocol extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oプロトコルの拡張のために設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The protocol is designed to accept standard extensions that do not compromise backward compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルは、下位互換性を損なわない標準の拡張を受け入れるように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document, together with the companion External Data Representation (XDR) description document [RFC7531], obsoletes [RFC3530] as the authoritative document describing NFSv4. It does not introduce any over-the-wire protocol changes, in the sense that previously valid requests remain valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、一緒にコンパニオン外部データ表現（XDR）記述文書[RFC7531]と、NFSv4のを記述する権威文書として[RFC3530]を時代遅れ。これは、以前に有効な要求が有効なまま意味では、任意のオーバーザワイヤプロトコルの変更を導入しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Definitions in the Companion Document Are Authoritative
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3。コンパニオン文書で定義は、権限のあります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;Network File System (NFS) Version 4 External Data Representation Standard (XDR) Description&#34; [RFC7531] contains the definitions in XDR description language of the constructs used by the protocol. Inside this document, several of the constructs are reproduced for purposes of explanation. The reader is warned of the possibility of errors in the reproduced constructs outside of [RFC7531]. For any part of the document that is inconsistent with [RFC7531], [RFC7531] is to be considered authoritative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ネットワークファイルシステム（NFS）バージョン4外部データ表現標準（XDR）の説明」[RFC7531]プロトコルで使用される構文のXDR記述言語で定義が含まれています。このドキュメント内では、構造体のいくつかは、説明の目的のために再現されています。読者は、[RFC7531]の外に再生構築物におけるエラーの可能性を警告されます。 [RFC7531]と一致しない文書の任意の部分のために、[RFC7531]は権威と見なされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Overview of NFSv4 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4。 NFSv4の機能の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To provide a reasonable context for the reader, the major features of the NFSv4 protocol will be reviewed in brief. This is done to provide an appropriate context for both the reader who is familiar with the previous versions of the NFS protocol and the reader who is new to the NFS protocols. For the reader new to the NFS protocols, some fundamental knowledge is still expected. The reader should be familiar with the XDR and RPC protocols as described in [RFC4506] and [RFC5531]. A basic knowledge of file systems and distributed file systems is expected as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読者のための合理的なコンテキストを提供するために、NFSv4のプロトコルの主な機能は、簡単に審査されます。これは、NFSプロトコルとNFSプロトコルに新しく追加され、リーダの以前のバージョンに精通している読者の両方のために適切なコンテキストを提供するために行われます。 NFSプロトコルへの新しい読者のために、いくつかの基本的な知識がまだ期待されています。 [RFC4506]及び[RFC5531]に記載されているように、リーダはXDRとRPCプロトコルに精通しなければなりません。ファイルシステムと分散ファイルシステムの基本的な知識も同様に期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1. RPC and Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1。 RPCとセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As with previous versions of NFS, the XDR and RPC mechanisms used for the NFSv4 protocol are those defined in [RFC4506] and [RFC5531]. To meet end-to-end security requirements, the RPCSEC_GSS framework (both version 1 in [RFC2203] and version 2 in [RFC5403]) will be used to extend the basic RPC security. With the use of RPCSEC_GSS, various mechanisms can be provided to offer authentication, integrity, and privacy to the NFSv4 protocol. Kerberos V5 will be used as described in [RFC4121] to provide one security framework. With the use of RPCSEC_GSS, other mechanisms may also be specified and used for NFSv4 security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSの以前のバージョンと同様に、NFSv4のプロトコルのために使用XDRとRPCメカニズムは、[RFC4506]及び[RFC5531]で定義されたものです。エンドツーエンドのセキュリティ要件を満たすために、RPCSEC_GSSフレームワーク（[RFC2203]にバージョン1とバージョン2 [RFC5403]での両方）は基本的なRPCセキュリティを拡張するために使用されるであろう。 RPCSEC_GSSを使用すると、様々なメカニズムがNFSv4のプロトコルに認証、整合性、およびプライバシーを提供するために提供することができます。 [RFC4121]に記載されているようにケルベロスV5は、一つのセキュリティフレームワークを提供するために使用されます。 RPCSEC_GSSを使用して、他の機構も指定されてもよく、NFSv4のセキュリティのために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To enable in-band security negotiation, the NFSv4 protocol has added a new operation that provides the client with a method of querying the server about its policies regarding which security mechanisms must be used for access to the server&#39;s file system resources. With this, the client can securely match the security mechanism that meets the policies specified at both the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インバンドセキュリティネゴシエーションを有効にするには、NFSv4のプロトコルは、セキュリティ・メカニズムは、サーバーのファイル・システム・リソースへのアクセスに使用する必要がありますについての方針についてのサーバーを照会する方法をクライアントに提供する新しい操作を追加しました。これにより、クライアントが安全に、クライアントとサーバの両方で指定したポリシーを満たしているセキュリティ・メカニズムを一致させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2. Procedure and Operation Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2。手順や運用体制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A significant departure from the previous versions of the NFS protocol is the introduction of the COMPOUND procedure. For the NFSv4 protocol, there are two RPC procedures: NULL and COMPOUND. The COMPOUND procedure is defined in terms of operations, and these operations correspond more closely to the traditional NFS procedures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSプロトコルの旧バージョンからの有意な逸脱は、化合物処置の導入です。 NULLとCOMPOUND：NFSv4のプロトコルでは、2つのRPCの手順があります。 COMPOUND手順は動作の観点から定義され、これらの動作は、従来のNFS手順に、より密接に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the use of the COMPOUND procedure, the client is able to build simple or complex requests. These COMPOUND requests allow for a reduction in the number of RPCs needed for logical file system operations. For example, without previous contact with a server a client will be able to read data from a file in one request by combining LOOKUP, OPEN, and READ operations in a single COMPOUND RPC. With previous versions of the NFS protocol, this type of single request was not possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順を使用すると、クライアントは、単純または複雑な要求を構築することができます。これらの化合物の要求は、論理ファイルシステム操作のために必要なRPCの数の減少を可能とします。たとえば、サーバーとの以前の接触せずに、クライアントは、単一の化合物のRPCでLOOKUP、OPEN、およびREAD操作を組み合わせることにより、一つのリクエストでファイルからデータを読み取ることができるようになります。 NFSプロトコルの以前のバージョンでは、単一の要求のこのタイプは不可能でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The model used for COMPOUND is very simple. There is no logical OR or ANDing of operations. The operations combined within a COMPOUND request are evaluated in order by the server. Once an operation returns a failing result, the evaluation ends and the results of all evaluated operations are returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
化合物に対して使用されるモデルは非常に単純です。操作の論理的ORまたはAND演算はありません。複合要求内で組み合わせる操作はサーバ順に評価されます。操作が失敗し、結果を返した後、評価が終了し、全ての評価の操作の結果がクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol continues to have the client refer to a file or directory at the server by a &#34;filehandle&#34;. The COMPOUND procedure has a method of passing a filehandle from one operation to another within the sequence of operations. There is a concept of a current filehandle and a saved filehandle. Most operations use the current filehandle as the file system object to operate upon. The saved filehandle is used as temporary filehandle storage within a COMPOUND procedure as well as an additional operand for certain operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のプロトコルは、クライアントが「ファイルハンドル」により、サーバーにあるファイルまたはディレクトリを参照する必要があり続けています。 COMPOUND手順は動作のシーケンス内の別の操作からファイルハンドルを渡す方法を有します。現在のファイルハンドルと保存されたファイルハンドルの概念があります。ほとんどの操作は、時に動作するファイル・システム・オブジェクトとして現在のファイルハンドルを使用します。保存されたファイルハンドルは、化合物プロシージャ内の一時ファイルハンドル記憶ならびに特定の操作のための追加のオペランドとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3. File System Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3。ファイルシステムモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The general file system model used for the NFSv4 protocol is the same as previous versions. The server file system is hierarchical, with the regular files contained within being treated as opaque byte streams. In a slight departure, file and directory names are encoded with UTF-8 to deal with the basics of internationalization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4プロトコルに使用される一般的なファイルシステム・モデルは、以前のバージョンと同じです。サーバーのファイルシステムは、不透明なバイトストリームとして処理されている内に含まれる通常のファイルと、階層的です。若干の出発では、ファイル名やディレクトリ名は、国際化の基礎に対処するためにUTF-8でエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol does not require a separate protocol to provide for the initial mapping between pathname and filehandle. Instead of using the older MOUNT protocol for this mapping, the server provides a root filehandle that represents the logical root or top of the file system tree provided by the server. The server provides multiple file systems by gluing them together with pseudo-file systems. These pseudo-file systems provide for potential gaps in the pathnames between real file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4プロトコルは、パス名とファイルハンドルとの間の最初のマッピングを提供するために、別のプロトコルを必要としません。このマッピングの古いMOUNTプロトコルを使用する代わりに、サーバは、サーバが提供するファイル・システム・ツリーの論理ルート又はトップを表すルートファイルハンドルを提供します。サーバーは、擬似ファイルシステムでそれらを一緒に接着することにより、複数のファイルシステムを提供します。これらの疑似ファイルシステムは、実際のファイルシステム間のパス名の潜在的なギャップを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.1. Filehandle Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.1。ファイルハンドルタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In previous versions of the NFS protocol, the filehandle provided by the server was guaranteed to be valid or persistent for the lifetime of the file system object to which it referred. For some server implementations, this persistence requirement has been difficult to meet. For the NFSv4 protocol, this requirement has been relaxed by introducing another type of filehandle -- volatile. With persistent and volatile filehandle types, the server implementation can match the abilities of the file system at the server along with the operating environment. The client will have knowledge of the type of filehandle being provided by the server and can be prepared to deal with the semantics of each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSプロトコルの旧バージョンでは、サーバによって提供されるファイルハンドルは、それが呼ばれるファイル・システム・オブジェクトの寿命のために有効または永続的であることが保証されました。いくつかのサーバ実装では、この永続性要件は満たすことが困難でした。揮発性 - のNFSv4プロトコルの場合、この要件は、ファイルハンドルの別のタイプを導入することによって緩和されています。持続的かつ揮発性ファイルハンドルタイプでは、サーバの実装は、動作環境と一緒にサーバーでのファイルシステムの能力を一致させることができます。クライアントは、サーバによって提供されているファイルハンドルのタイプについての知識を持つことになりますし、それぞれのセマンティクスを扱うように調製することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.2. Attribute Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.2。属性タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol has a rich and extensible file object attribute structure, which is divided into REQUIRED, RECOMMENDED, and named attributes (see Section 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のプロトコルは、必須推奨、と命名された属性（セクション5を参照）に分割して、リッチで拡張可能なファイルオブジェクトの属性構造を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Several (but not all) of the REQUIRED attributes are derived from the attributes of NFSv3 (see the definition of the fattr3 data type in [RFC1813]). An example of a REQUIRED attribute is the file object&#39;s type (Section 5.8.1.2) so that regular files can be distinguished from directories (also known as folders in some operating environments) and other types of objects. REQUIRED attributes are discussed in Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの（すべてではない）必須属性のは（[RFC1813]でfattr3データ型の定義を参照）のNFSv3の属性から導出されます。通常のファイルは、ディレクトリ（また、一部のオペレーティング環境でのフォルダとして知られる）および他のタイプのオブジェクトと区別できるように、必要な属性の例は、ファイルオブジェクトのタイプ（セクション5.8.1.2）です。必要な属性は、セクション5.1で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example of the RECOMMENDED attributes is an acl (Section 6.2.1). This attribute defines an Access Control List (ACL) on a file object. An ACL provides file access control beyond the model used in NFSv3. The ACL definition allows for specification of specific sets of permissions for individual users and groups. In addition, ACL inheritance allows propagation of access permissions and restriction down a directory tree as file system objects are created. RECOMMENDED attributes are discussed in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
推奨属性の例は、ACL（6.2.1項）です。この属性は、ファイルオブジェクトのアクセス制御リスト（ACL）を定義します。 ACLはNFSv3のに使用されるモデルを超えてファイルアクセス制御を提供します。 ACL定義は、個々のユーザーおよびグループの権限の特定のセットの仕様を可能にします。ファイル・システム・オブジェクトが作成されるほか、ACLの継承は、ディレクトリツリーダウンアクセス許可および制限の伝搬を可能にします。推奨属性は、5.2節で議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A named attribute is an opaque byte stream that is associated with a directory or file and referred to by a string name. Named attributes are meant to be used by client applications as a method to associate application-specific data with a regular file or directory. NFSv4.1 modifies named attributes relative to NFSv4.0 by tightening the allowed operations in order to prevent the development of non-interoperable implementations. Named attributes are discussed in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前の属性は、ディレクトリやファイルに関連付けられており、文字列名で呼ばれる不透明なバイトストリームです。名前付き属性は、通常のファイルまたはディレクトリとアプリケーション固有のデータを関連付けるための方法として、クライアントアプリケーションによって使用されることを意味しています。 NFSv4.1は、非相互運用可能な実装の開発を防ぐために許可される操作を締めて、NFSv4.0に対するという名前の属性を変更します。名前付き属性は、5.3節で議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.3. Multi-Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.3。マルチサーバーの名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A single-server namespace is the file system hierarchy that the server presents for remote access. It is a proper subset of all the file systems available locally. NFSv4 contains a number of features to allow implementation of namespaces that cross server boundaries and that allow and facilitate a non-disruptive transfer of support for individual file systems between servers. They are all based upon attributes that allow one file system to specify alternative or new locations for that file system. That is, just as a client might traverse across local file systems on a single server, it can now traverse to a remote file system on a different server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一サーバーの名前空間は、サーバーがリモートアクセス用に提供するファイルシステムの階層です。これは、ローカルで利用可能なすべてのファイルシステムの適切なサブセットです。 NFSv4では、サーバーの境界を越え、それが可能になり、サーバ間の個々のファイルシステムのサポートの無停止移行を促進する名前空間の実装を可能にするために、多数の機能が含まれています。これらはすべて一つのファイルシステムは、そのファイルシステムの代替または新しい場所を指定することができ、属性に基づいています。つまり、クライアントは、単一のサーバー上のローカルファイルシステム間で通過する可能性があると同じように、それは今別のサーバーにリモートファイルシステムに行き来することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These attributes may be used together with the concept of absent file systems, which provide specifications for additional locations but no actual file system content. This allows a number of important facilities:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの属性は、追加の場所のための仕様が、実際のファイル・システム・コンテンツを提供不在でのファイルシステムの概念と一緒に使用することもできます。これは重要な施設の数を可能にします：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Location attributes may be used with absent file systems to implement referrals whereby one server may direct the client to a file system provided by another server. This allows extensive multi-server namespaces to be constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O場所属性は、一つのサーバが別のサーバによって提供されるファイルシステムにクライアントに指示することができることにより、照会を実装するために存在しないファイルシステムで使用されてもよいです。これは、大規模なマルチサーバーの名前空間を構築することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Location attributes may be provided for present file systems to provide the locations of alternative file system instances or replicas to be used in the event that the current file system instance becomes unavailable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oロケーション属性は、現在のファイル・システム・インスタンスが使用できなくなった場合に使用される代替のファイル・システム・インスタンスまたはレプリカの場所を提供することが、本ファイルシステムのために提供されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Location attributes may be provided when a previously present file system becomes absent. This allows non-disruptive migration of file systems to alternative servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以前に、本ファイルシステムが不在になったときにO場所属性が提供されてもよいです。これは、代替サーバーへのファイルシステムの無停止移行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4. OPEN and CLOSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4。開閉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol introduces OPEN and CLOSE operations. The OPEN operation provides a single point where file lookup, creation, and share semantics (see Section 9.9) can be combined. The CLOSE operation also provides for the release of state accumulated by OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のプロトコルは、OPENとCLOSEの操作を紹介します。 OPEN操作は、ファイルの検索、作成、共有セマンティクスが（セクション9.9を参照）を組み合わせることができ、単一のポイントを提供します。 CLOSE動作もOPENによって蓄積された状態の放出を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5. File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5。ファイルロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the NFSv4 protocol, the support for byte-range file locking is part of the NFS protocol. The file locking support is structured so that an RPC callback mechanism is not required. This is a departure from the previous versions of the NFS file locking protocol, Network Lock Manager (NLM) [RFC1813]. The state associated with file locks is maintained at the server under a lease-based model. The server defines a single lease period for all state held by an NFS client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4プロトコルで、バイト範囲ファイルのロックのためのサポートは、NFSプロトコルの一部です。 RPCコールバック機構が必要とされないようにファイルロックのサポートが構成されています。これは、NFSファイルロックプロトコル、ネットワークロックマネージャ（NLM）[RFC1813]の以前のバージョンからの脱却です。ファイルロックに関連付けられた状態は、リースベースのモデルの下でサーバに維持されます。サーバーは、NFSクライアントによって保持されているすべての状態のための単一のリース期間を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client does not renew its lease within the defined period, all state associated with the client&#39;s lease may be released by the server. The client may renew its lease by use of the RENEW operation or implicitly by use of other operations (primarily READ).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが定義された期間内にそのリースを更新しない場合は、クライアントのリースに関連するすべての状態がサーバーによって解放されてもよいです。クライアントがRENEW操作を使用することによって、そのリースを更新または暗黙的に他の操作を使用することにより（主にREAD）があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6. Client Caching and Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6。クライアントキャッシングと委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The file, attribute, and directory caching for the NFSv4 protocol is similar to previous versions. Attributes and directory information are cached for a duration determined by the client. At the end of a predefined timeout, the client will query the server to see if the related file system object has been updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のプロトコル用のファイル、属性、およびディレクトリのキャッシングは、以前のバージョンと同様です。属性と、ディレクトリ情報は、クライアントによって決定期間中にキャッシュされます。事前に定義されたタイムアウトの終わりには、クライアントは、関連するファイル・システム・オブジェクトが更新されているかどうかを確認するためにサーバーを照会します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For file data, the client checks its cache validity when the file is opened. A query is sent to the server to determine if the file has been changed. Based on this information, the client determines if the data cache for the file should be kept or released. Also, when the file is closed, any modified data is written to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルを開いたときに、ファイルデータの場合、クライアントは、そのキャッシュの有効性をチェックします。クエリは、ファイルが変更されているかどうかを判断するためにサーバーに送信されます。ファイルのためのデータ・キャッシュを保持または解放する必要がある場合は、この情報に基づいて、クライアントが決定します。ファイルを閉じたときにも、任意の変更されたデータがサーバーに書き込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an application wants to serialize access to file data, file locking of the file data ranges in question should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションがファイルデータへのアクセスをシリアル化したい場合は、問題のファイルのデータ範囲のファイルのロックを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The major addition to NFSv4 in the area of caching is the ability of the server to delegate certain responsibilities to the client. When the server grants a delegation for a file to a client, the client is guaranteed certain semantics with respect to the sharing of that file with other clients. At OPEN, the server may provide the client either a read (OPEN_DELEGATE_READ) or a write (OPEN_DELEGATE_WRITE) delegation for the file (see Section 10.4). If the client is granted an OPEN_DELEGATE_READ delegation, it is assured that no other client has the ability to write to the file for the duration of the delegation. If the client is granted an OPEN_DELEGATE_WRITE delegation, the client is assured that no other client has read or write access to the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシングのエリア内のNFSv4への主要な追加は、クライアントに一定の責任を委譲するには、サーバーの能力です。サーバーがクライアントへのファイルの委任を許可した場合、クライアントは他のクライアントとそのファイルの共有に対して一定のセマンティクスを保証されています。 OPENでは、サーバはクライアントのいずれかのファイルの読み込み（OPEN_DELEGATE_READ）または書き込み（OPEN_DELEGATE_WRITE）委任を提供することができる（項10.4を参照してください）。クライアントがOPEN_DELEGATE_READ委任を許可された場合は、他のクライアントが委任期間中のファイルへの書き込み機能を持っていないことが保証されます。クライアントがOPEN_DELEGATE_WRITE委任を許可された場合、クライアントは、他のクライアントは読まないか、ファイルへの書き込みアクセスをしていることが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Delegations can be recalled by the server. If another client requests access to the file in such a way that the access conflicts with the granted delegation, the server is able to notify the initial client and recall the delegation. This requires that a callback path exist between the server and client. If this callback path does not exist, then delegations cannot be granted. The essence of a delegation is that it allows the client to locally service operations such as OPEN, CLOSE, LOCK, LOCKU, READ, or WRITE without immediate interaction with the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代表団は、サーバによって呼び出すことができます。別のクライアント要求が許可された代表団とのアクセスが競合するような方法でファイルにアクセスした場合、サーバーは最初のクライアントに通知し、委任をリコールすることができます。これは、コールバックパスは、サーバとクライアントの間に存在することが必要です。このコールバックパスが存在しない場合は、代表団は付与されません。代表団の本質は、それが、サーバーとの直接の対話なしに、このようなOPEN、CLOSE、LOCK、LOCKU、READ、またはWRITEなどのローカルサービス操作へのクライアントを可能にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. General Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5。一般的な定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following definitions are provided for the purpose of providing an appropriate context for the reader.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の定義は、読者のために適切なコンテキストを提供する目的のために提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Absent File System: A file system is &#34;absent&#34; when a namespace component does not have a backing file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不在ファイルシステム：ファイルシステム名前空間のコンポーネントは、バッキングファイルシステムを持っていない場合、「不在」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Anonymous Stateid: The Anonymous Stateid is a special locking object and is defined in Section 9.1.4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
匿名のstateid：匿名のstateidは、特別なロックオブジェクトであり、セクション9.1.4.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Byte: In this document, a byte is an octet, i.e., a datum exactly 8 bits in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト：この文書では、バイトはオクテット、即ち、基準長さが正確に8ビットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client: The client is the entity that accesses the NFS server&#39;s resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント：クライアントがNFSサーバーのリソースにアクセスするエンティティです。クライアントは直接NFSサーバーにアクセスするためのロジックが含まれているアプリケーションであってもよいです。また、クライアントはアプリケーションのセットのためにリモートファイルシステムのサービスを提供し、伝統的なオペレーティングシステムのクライアントであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With reference to byte-range locking, the client is also the entity that maintains a set of locks on behalf of one or more applications. This client is responsible for crash or failure recovery for those locks it manages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト範囲ロックを参照すると、クライアントは、1つ以上のアプリケーションのためにロックのセットを保持するエンティティです。このクライアントは、それが管理し、それらのロックのクラッシュや障害復旧のために責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that multiple clients may share the same transport and connection, and multiple clients may exist on the same network node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数のクライアントが同じトランスポートおよび接続を共有してもよいことに留意されたい、及び複数のクライアントが同一のネットワーク・ノードに存在してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client ID: The client ID is a 64-bit quantity used as a unique, shorthand reference to a client-supplied verifier and ID. The server is responsible for supplying the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントIDは、クライアントIDは、クライアントが提供する検証およびIDに固有の、速記参照として使用64ビット量です。サーバーは、クライアントのIDを供給するための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
File System: The file system is the collection of objects on a server that share the same fsid attribute (see Section 5.8.1.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステム：ファイルシステム（項5.8.1.9を参照）と同じFSID属性を共有し、サーバ上のオブジェクトのコレクションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Lease: A lease is an interval of time defined by the server for which the client is irrevocably granted a lock. At the end of a lease period the lock may be revoked if the lease has not been extended. The lock must be revoked if a conflicting lock has been granted after the lease interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リース：リースは、クライアントが取り返しのつかないロックを付与されているサーバーで定義された時間間隔です。リースが拡張されていない場合は、リース期間の終了時にロックが取り消すことができます。競合ロックがリース期間の後に付与されている場合はロックが取り消されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All leases granted by a server have the same fixed duration. Note that the fixed interval duration was chosen to alleviate the expense a server would have in maintaining state about variable-length leases across server failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバによって付与されたすべてのリースは同じ固定期間を有します。固定された間隔の持続時間は、サーバは、サーバの障害を横切る可変長リースについての状態を維持するであろう費用を軽減するために選択されたことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Lock: The term &#34;lock&#34; is used to refer to record (byte-range) locks as well as share reservations unless specifically stated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロック：特に断りのない限り、用語「ロック」は、レコード（バイト範囲）ロックだけでなく、共有の予約を参照するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Lock-Owner: Each byte-range lock is associated with a specific lock-owner and an open-owner. The lock-owner consists of a client ID and an opaque owner string. The client presents this to the server to establish the ownership of the byte-range lock as needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロック所有者：各バイト範囲ロックは、特定のロック所有者とのオープン所有者に関連付けられています。ロック所有者は、クライアントIDと不透明な所有者文字列で構成されています。クライアントは、必要に応じてバイト範囲ロックの所有権を確立するために、サーバーにこれを提示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Open-Owner: Each open file is associated with a specific open-owner, which consists of a client ID and an opaque owner string. The client presents this to the server to establish the ownership of the open as needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オープン所有者：それぞれの開いているファイルは、クライアントIDと不透明な所有者文字列で構成され、特定のオープン所有者、関連付けられています。クライアントは、必要に応じて、オープンの所有権を確立するために、サーバーにこれを提示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ Bypass Stateid: The READ Bypass Stateid is a special locking object and is defined in Section 9.1.4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイパスのstateidを読むREADバイパスのstateidは、特別なロックオブジェクトであり、セクション9.1.4.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Server: The &#34;server&#34; is the entity responsible for coordinating client access to a set of file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー：「サーバーは、」ファイル・システムのセットにクライアントアクセスの調整を担当するエンティティです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stable Storage: NFSv4 servers must be able to recover without data loss from multiple power failures (including cascading power failures, that is, several power failures in quick succession), operating system failures, and hardware failure of components other than the storage medium itself (for example, disk, non-volatile RAM).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
安定記憶：NFSv4のサーバが複数の電源障害からデータを損失することなく回復することができなければなりません（カスケード停電を含む、つまり、いくつか立て続けに停電）、オペレーティングシステム障害、および記憶媒体自体以外の成分のハードウェア障害（例えば、ディスク、不揮発性RAM）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some examples of stable storage that are allowable for an NFS server include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSサーバ用に許容される安定したストレージのいくつかの例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) Media commit of data. That is, the modified data has been successfully written to the disk media -- for example, the disk platter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）メディアは、データのコミット。例えば、ディスクプラッタ - それは、変更されたデータが正常にディスクメディアに書き込まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) An immediate reply disk drive with battery-backed on-drive intermediate storage or uninterruptible power system (UPS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）バッテリバックアップオン駆動中間貯蔵または無停電電源装置（UPS）との即時応答ディスクドライブ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) Server commit of data with battery-backed intermediate storage and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）サーバは、バッテリバックアップ中間貯蔵及び回復ソフトウェアとデータのコミット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) Cache commit with UPS and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）キャッシュは、UPSとリカバリソフトウェアでコミットします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stateid: A stateid is a 128-bit quantity returned by a server that uniquely identifies the open and locking states provided by the server for a specific open-owner or lock-owner/open-owner pair for a specific file and type of lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidは：のstateid一意特定のファイルとロックの種類に特異的なオープン所有者またはロック所有者/オープン所有者ペアのサーバーによって提供されるオープンとロック状態を識別し、サーバによって返された128ビットの量です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Verifier: A verifier is a 64-bit quantity generated by the client that the server can use to determine if the client has restarted and lost all previous lock state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
検証：検証者は、サーバは、クライアントが再起動し、すべての以前のロック状態を喪失したかどうかを判定するために使用できるクライアントによって生成された64ビット量です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.6. Changes since
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.6。以下からの変更点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The main changes from RFC 3530 [RFC3530] are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 3530 [RFC3530]からの主な変更点は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The XDR definition has been moved to a companion document [RFC7531].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O XDR定義は仲間ドキュメント[RFC7531]に移動しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The IETF intellectual property statements were updated to the latest version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETF知的財産文oを最新版に更新されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o There is a restructured and more complete explanation of multi-server namespace features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oマルチサーバーの名前空間機能の再構築と、より完全な説明があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The handling of domain names was updated to reflect Internationalized Domain Names in Applications (IDNA) [RFC5891].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oドメイン名の取り扱いは、アプリケーションにおける国際化ドメイン名（IDNA）[RFC5891]を反映するように更新されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The previously required LIPKEY and SPKM-3 security mechanisms have been removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O以前に必要なLIPKEYおよびSPKM-3のセキュリティメカニズムは削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Some clarification was provided regarding a client re-establishing callback information to the new server if state has been migrated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oいくつかの明確化は、状態が移行された場合は、新しいサーバーへのクライアントの再確立するコールバック情報に関する提供されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A third edge case was added for courtesy locks and network partitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O第三のエッジケースは礼儀ロックとネットワーク・パーティションのために添加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The definition of stateid was strengthened.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oのstateidの定義が強化されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7. Changes between and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.7。間での変更点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The definition of the NFSv4 protocol in [RFC3530] replaced and obsoleted the definition present in [RFC3010]. While portions of the two documents remained the same, there were substantive changes in others. The changes made between [RFC3010] and [RFC3530] reflect implementation experience and further review of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3530]でのNFSv4プロトコルの定義は、[RFC3010]に存在する定義を置換し、廃止しました。二つの文書の部分は同じままで、他では実質的な変更がありました。 [RFC3010]と[RFC3530]の間で行われた変更は、実装経験とプロトコルの更なる見直しを反映しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following list is not inclusive of all changes but presents some of the most notable changes or additions made:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のリストは、すべての変更を包括的ではなく、作られた最も顕著な変更または追加のいくつかを提示します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The state model has added an open_owner4 identifier. This was done to accommodate POSIX-based clients and the model they use for file locking. For POSIX clients, an open_owner4 would correspond to a file descriptor potentially shared amongst a set of processes and the lock_owner4 identifier would correspond to a process that is locking a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O状態モデルはopen_owner4識別子を追加しました。これは、POSIXベースのクライアントと、彼らはファイルのロックに使用するモデルに対応するために行われました。 POSIXクライアントの場合、open_owner4は、潜在的に一連のプロセス間で共有ファイル記述子に対応するであろうとlock_owner4識別子は、ファイルをロックしているプロセスに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Added clarifications and error conditions for the handling of the owner and group attributes. Since these attributes are string based (as opposed to the numeric uid/gid of previous versions of NFS), translations may not be available and hence the changes made.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O所有者およびグループ属性の取り扱いを明確化し、エラー条件を追加しました。これらの属性は、文字列ベース（NFSの以前のバージョンの数値のUID / GIDとは対照的に）であるので、翻訳が利用できない場合があり、したがって、変更が行わ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Added clarifications for the ACL and mode attributes to address evaluation and partial support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACLとモードが評価し、部分的にサポートして対処する属性のO明確化を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For identifiers that are defined as XDR opaque, set limits on their size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O不透明XDRとして定義された識別子は、そのサイズに制限を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Added the mounted_on_fileid attribute to allow POSIX clients to correctly construct local mounts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O POSIXクライアントが正しくローカルマウントを構築できるようにするためにmounted_on_fileid属性が追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Modified the SETCLIENTID/SETCLIENTID_CONFIRM operations to deal correctly with confirmation details along with adding the ability to specify new client callback information. Also added clarification of the callback information itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O新しいクライアントコールバックの情報を指定する機能を追加するとともに、確認の詳細を正しく対処するSETCLIENTID / SETCLIENTID_CONFIRM操作を修正。また、コールバック情報自体の明確化を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Added a new operation RELEASE_LOCKOWNER to enable notifying the server that a lock_owner4 will no longer be used by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O lock_owner4は、もはやクライアントによって使用されることはありませんサーバーに通知有効にするために、新たな操作RELEASE_LOCKOWNERを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Added RENEW operation changes to identify the client correctly and allow for additional error returns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oを追加しましたが、正しくクライアントを識別し、追加のエラーリターンを可能にするための動作の変更を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Verified error return possibilities for all operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oすべての操作のエラーリターンの可能性を検証しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Removed use of the pathname4 data type from LOOKUP and OPEN in favor of having the client construct a sequence of LOOKUP operations to achieve the same effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントが同じ効果を達成するためにLOOKUP動作のシーケンスを構築したの賛成でLOOKUPとOPENからpathname4データ型の使用を削除しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Protocol Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.プロトコル・データ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The syntax and semantics to describe the data types of the NFSv4 protocol are defined in the XDR [RFC4506] and RPC [RFC5531] documents. The next sections build upon the XDR data types to define types and structures specific to this protocol. As a reminder, the size constants and authoritative definitions can be found in [RFC7531].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のプロトコルのデータ型を記述するための構文と意味はXDR [RFC4506]とRPC [RFC5531]ドキュメントで定義されています。次のセクションでは、このプロトコルに特定の種類や構造を定義するにはXDRのデータ型に基づいて構築します。リマインダとして、サイズ定数と権限の定義は、[RFC7531]に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Basic Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。基本データ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 1 lists the base NFSv4 data types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表1は、ベースNFSv4のデータ型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------+-------------------------------------------------+
   | Data Type       | Definition                                      |
   +-----------------+-------------------------------------------------+
   | int32_t         | typedef int int32_t;                            |
   |                 |                                                 |
   | uint32_t        | typedef unsigned int uint32_t;                  |
   |                 |                                                 |
   | int64_t         | typedef hyper int64_t;                          |
   |                 |                                                 |
   | uint64_t        | typedef unsigned hyper uint64_t;                |
   |                 |                                                 |
   | attrlist4       | typedef opaque attrlist4&lt;&gt;;                     |
   |                 |                                                 |
   |                 | Used for file/directory attributes.             |
   |                 |                                                 |
   | bitmap4         | typedef uint32_t bitmap4&lt;&gt;;                     |
   |                 |                                                 |
   |                 | Used in attribute array encoding.               |
   |                 |                                                 |
   | changeid4       | typedef uint64_t changeid4;                     |
   |                 |                                                 |
   |                 | Used in the definition of change_info4.         |
   |                 |                                                 |
   | clientid4       | typedef uint64_t clientid4;                     |
   |                 |                                                 |
   |                 | Shorthand reference to client identification.   |
   |                 |                                                 |
   | count4          | typedef uint32_t count4;                        |
   |                 |                                                 |
   |                 | Various count parameters (READ, WRITE, COMMIT). |
   |                 |                                                 |
   | length4         | typedef uint64_t length4;                       |
   |                 |                                                 |
   |                 | Describes LOCK lengths.                         |
   |                 |                                                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| mode4 | typedef uint32_t mode4; | | | | | | Mode attribute data type. | | | | | nfs_cookie4 | typedef uint64_t nfs_cookie4; | | | | | | Opaque cookie value for READDIR. | | | | | nfs_fh4 | typedef opaque nfs_fh4&lt;NFS4_FHSIZE&gt;; | | | | | | Filehandle definition. | | | | | nfs_ftype4 | enum nfs_ftype4; | | | | | | Various defined file types. | | | | | nfsstat4 | enum nfsstat4; | | | | | | Return value for operations. | | | | | nfs_lease4 | typedef uint32_t nfs_lease4; | | | | | | Duration of a lease in seconds. | | | | | offset4 | typedef uint64_t offset4; | | | | | | Various offset designations (READ, WRITE, LOCK, | | | COMMIT). | | | | | qop4 | typedef uint32_t qop4; | | | | | | Quality of protection designation in SECINFO. | | | | | sec_oid4 | typedef opaque sec_oid4&lt;&gt;; | | | | | | Security Object Identifier. The sec_oid4 data | | | type is not really opaque. Instead, it | | | contains an ASN.1 OBJECT IDENTIFIER as used by | | | GSS-API in the mech_type argument to | | | GSS_Init_sec_context. See [RFC2743] for | | | details. | | | | | seqid4 | typedef uint32_t seqid4; | | | | | | Sequence identifier used for file locking. | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| MODE4 | typedefでのuint32_t MODE4。 | | | | | |モードは、データ型を属性。 | | | | | nfs_cookie4 | typedef uint64_tをnfs_cookie4。 | | | | | | READDIRのための不透明なクッキーの値。 | | | | | nfs_fh4 |不透明nfs_fh4のtypedef &lt;NFS4_FHSIZE&gt;。 | | | | | |ファイルハンドルの定義。 | | | | | nfs_ftype4 |列挙型nfs_ftype4; | | | | | |様々な定義されたファイルの種類。 | | | | | nfsstat4 |列挙型nfsstat4; | | | | | |操作の戻り値。 | | | | | nfs_lease4 | typedefでのuint32_t nfs_lease4。 | | | | | |秒単位のリース期間。 | | | | | OFFSET4 | typedef uint64_tをOFFSET4。 | | | | | |各種の名称を（| | | COMMIT READ、、、書き込みロック）のオフセット。 | | | | | qop4 | typedefでのuint32_t qop4。 | | | | | | SECINFOで保護指定の品質。 | | | | | sec_oid4 |不透明sec_oid4のtypedef &lt;&gt;。 | | | | | |セキュリティオブジェクト識別子。 sec_oid4データ| | |タイプは本当に不透明ではありません。代わりに、それは| | | |によって使用されるASN.1オブジェクト識別子が含まれています| |たmech_type引数でGSS-APIへ| | |もしGSS_Init_sec_context。 [RFC2743]のために参照してください| | |詳細。 | | | | | seqid4 | typedefでのuint32_t seqid4。 | | | | | |ファイルのロックに使用するシーケンス識別子。 | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | utf8string      | typedef opaque utf8string&lt;&gt;;                    |
   |                 |                                                 |
   |                 | UTF-8 encoding for strings.                     |
   |                 |                                                 |
   | utf8str_cis     | typedef utf8string utf8str_cis;                 |
   |                 |                                                 |
   |                 | Case-insensitive UTF-8 string.                  |
   |                 |                                                 |
   | utf8str_cs      | typedef utf8string utf8str_cs;                  |
   |                 |                                                 |
   |                 | Case-sensitive UTF-8 string.                    |
   |                 |                                                 |
   | utf8str_mixed   | typedef utf8string utf8str_mixed;               |
   |                 |                                                 |
   |                 | UTF-8 strings with a case-sensitive prefix and  |
   |                 | a case-insensitive suffix.                      |
   |                 |                                                 |
   | component4      | typedef utf8str_cs component4;                  |
   |                 |                                                 |
   |                 | Represents pathname components.                 |
   |                 |                                                 |
   | linktext4       | typedef opaque linktext4&lt;&gt;;                     |
   |                 |                                                 |
   |                 | Symbolic link contents (&#34;symbolic link&#34; is      |
   |                 | defined in an Open Group [Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 7&#34;&#34;&gt;openg_symlink]        |
   |                 | standard).                                      |
   |                 |                                                 |
   | ascii_REQUIRED4 | typedef utf8string ascii_REQUIRED4;             |
   |                 |                                                 |
   |                 | String is sent as ASCII and thus is             |
   |                 | automatically UTF-8.                            |
   |                 |                                                 |
   | pathname4       | typedef component4 pathname4&lt;&gt;;                 |
   |                 |                                                 |
   |                 | Represents pathname for fs_locations.           |
   |                 |                                                 |
   | nfs_lockid4     | typedef uint64_t nfs_lockid4;                   |
   |                 |                                                 |
   | verifier4       | typedef opaque verifier4[NFS4_VERIFIER_SIZE];   |
   |                 |                                                 |
   |                 | Verifier used for various operations (COMMIT,   |
   |                 | CREATE, OPEN, READDIR, WRITE)                   |
   |                 | NFS4_VERIFIER_SIZE is defined as 8.             |
   +-----------------+-------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 1: Base NFSv4 Data Types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表1：基本NFSv4のデータ型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Structured Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2。構造化データ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. nfstime4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1。 nfstime4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfstime4 {
           int64_t         seconds;
           uint32_t        nseconds;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The nfstime4 structure gives the number of seconds and nanoseconds since midnight or 0 hour January 1, 1970 Coordinated Universal Time (UTC). Values greater than zero for the seconds field denote dates after the 0 hour January 1, 1970. Values less than zero for the seconds field denote dates before the 0 hour January 1, 1970. In both cases, the nseconds field is to be added to the seconds field for the final time representation. For example, if the time to be represented is one-half second before 0 hour January 1, 1970, the seconds field would have a value of negative one (-1) and the nseconds fields would have a value of one-half second (500000000). Values greater than 999,999,999 for nseconds are considered invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfstime4構造は深夜または0時間1970年1月1日協定世界時（UTC）からの秒とナノ秒数を示します。秒フィールドにゼロ以上の値が0時間の1月1日以降の日付を表し、秒フィールドのためのゼロ未満1970の値は両方のケースで0時間1970年1月1日より前の日付を表し、nsecondsフィールドが追加されます最終時間表現のための秒フィールド。例えば、表現される時間は、半分が第二0時間1970年1月1日前に、秒フィールドが負の1（-1）の値を有するであろうとnsecondsフィールドが（第2の半分の値を有するであろうあれば5億）。 nseconds用999999999より大きい値は無効とみなされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This data type is used to pass time and date information. A server converts to and from its local representation of time when processing time values, preserving as much accuracy as possible. If the precision of timestamps stored for a file system object is less than defined, loss of precision can occur. An adjunct time maintenance protocol is recommended to reduce client and server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このデータ型は、日付と時刻の情報を渡すために使用されます。時間値を処理するとき、サーバはできるだけ正確さを維持し、時間のローカル表現へと変換します。ファイル・システム・オブジェクトのための記憶されたタイムスタンプの精度が規定未満であれば、精度の損失が発生する可能性があります。補助時間のメンテナンスプロトコルは、クライアントとサーバーの時間のずれを低減することを推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. time_how4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2。 time_how4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum time_how4 { SET_TO_SERVER_TIME4 = 0, SET_TO_CLIENT_TIME4 = 1 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙time_how4 {SET_TO_SERVER_TIME4 = 0、SET_TO_CLIENT_TIME4 = 1}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3. settime4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3。 settime4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union settime4 switch (time_how4 set_it) {
    case SET_TO_CLIENT_TIME4:
            nfstime4       time;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The above definitions are used as the attribute definitions to set time values. If set_it is SET_TO_SERVER_TIME4, then the server uses its local representation of time for the time value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の定義は、時間の値を設定する属性の定義として使用されています。 set_itがSET_TO_SERVER_TIME4ある場合、サーバーは、時間値のための時間のローカルな表現を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.4. specdata4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.4。 specdata4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct specdata4 {
           uint32_t specdata1; /* major device number */
           uint32_t specdata2; /* minor device number */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This data type represents additional information for the device file types NF4CHR and NF4BLK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このデータ型は、デバイスファイルの種類NF4CHRとNF4BLKの追加情報を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.5. fsid4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.5。 fsid4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fsid4 {
           uint64_t        major;
           uint64_t        minor;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This type is the file system identifier that is used as a REQUIRED attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このタイプは、必要な属性として使用されているファイルシステム識別子です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.6. fs_location4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.6。 fs_location4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_location4 {
           utf8str_cis             server&lt;&gt;;
           pathname4               rootpath;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.7. fs_locations4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.7。 fs_locations4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_locations4 {
           pathname4       fs_root;
           fs_location4    locations&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fs_location4 and fs_locations4 data types are used for the fs_locations RECOMMENDED attribute, which is used for migration and replication support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fs_location4とfs_locations4データ型は、移行およびレプリケーション・サポートのために使用される属性推奨fs_位置のために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.8. fattr4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.8。 fattr4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fattr4 {
           bitmap4         attrmask;
           attrlist4       attr_vals;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fattr4 structure is used to represent file and directory attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fattr4構造は、ファイルやディレクトリの属性を表すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The bitmap is a counted array of 32-bit integers used to contain bit values. The position of the integer in the array that contains bit n can be computed from the expression (n / 32), and its bit within that integer is (n mod 32).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビットマップは、ビット値を含むように使用される32ビット整数のカウント配列です。ビットnを含む配列の整数の位置は、式（N / 32）から計算することができ、その整数内のそのビットは（N MOD 32）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       0            1
     +-----------+-----------+-----------+--
     |  count    | 31  ..  0 | 63  .. 32 |
     +-----------+-----------+-----------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.9. change_info4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.9。変化_info4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct change_info4 {
           bool            atomic;
           changeid4       before;
           changeid4       after;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This structure is used with the CREATE, LINK, REMOVE, and RENAME operations to let the client know the value of the change attribute for the directory in which the target file system object resides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構造は、クライアントがターゲット・ファイル・システム・オブジェクトが存在するディレクトリの変更属性の値を知っているように、LINKを作成、削除、名前の変更操作で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.10. clientaddr4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.10。 clientaddr4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct clientaddr4 {
           /* see struct rpcb in RFC 1833 */
           string r_netid&lt;&gt;;    /* network id */
           string r_addr&lt;&gt;;     /* universal address */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The clientaddr4 structure is used as part of the SETCLIENTID operation, either (1) to specify the address of the client that is using a client ID or (2) as part of the callback registration. The r_netid and r_addr fields respectively contain a network id and universal address. The network id and universal address concepts, together with formats for TCP over IPv4 and TCP over IPv6, are defined in [RFC5665], specifically Tables 2 and 3 and Sections 5.2.3.3 and 5.2.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
clientaddr4構造はSETCLIENTID操作の一部として使用され、いずれかの（1）コールバック登録の一部として、クライアントID又は（2）を使用しているクライアントのアドレスを指定します。 r_netidとR_ADDRフィールドは、それぞれのネットワークIDと汎用アドレスが含まれています。一緒にIPv6を介しIPv4およびTCP上のTCP用フォーマットと、[RFC5665]で定義されているネットワークIDと汎用アドレスの概念、具体的に表2および表3及びセクション5.2.3.3および5.2.3.4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.11. cb_client4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.11。 cb_client4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct cb_client4 {
           unsigned int    cb_program;
           clientaddr4     cb_location;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This structure is used by the client to inform the server of its callback address; it includes the program number and client address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構造は、そのコールバックアドレスのサーバーに通知するためにクライアントによって使用されます。それは、プログラム番号とクライアントのアドレスが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.12. nfs_client_id4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.12。 nfs_client_id4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This structure is part of the arguments to the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構造はSETCLIENTID操作の引数の一部です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.13. open_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.13。 open_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_owner4 {
           clientid4       clientid;
           opaque          owner&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This structure is used to identify the owner of open state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構造は、開いた状態の所有者を識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.14. lock_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.14。 lock_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct lock_owner4 {
           clientid4       clientid;
           opaque          owner&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This structure is used to identify the owner of file locking state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構造は、ファイルのロック状態の所有者を識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.15. open_to_lock_owner4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.15。 open_to_lock_owner4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This structure is used for the first LOCK operation done for an open_owner4. It provides both the open_stateid and lock_owner such that the transition is made from a valid open_stateid sequence to that of the new lock_stateid sequence. Using this mechanism avoids the confirmation of the lock_owner/lock_seqid pair since it is tied to established state in the form of the open_stateid/open_seqid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構造はopen_owner4に対して行う第1のロック操作のために使用されます。それはopen_stateidと遷移が新しいlock_stateid系列のそれに有効なopen_stateid配列から作られるようにlock_ownerの両方を提供します。それはopen_stateid / open_seqidの形で確立された状態に関連付けられているので、この機構を使用することlock_owner / lock_seqidペアの確認を回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.16. stateid4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.16。 stateid4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct stateid4 {
           uint32_t        seqid;
           opaque          other[NFS4_OTHER_SIZE];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This structure is used for the various state-sharing mechanisms between the client and server. For the client, this data structure is read-only. The server is required to increment the seqid field monotonically at each transition of the stateid. This is important since the client will inspect the seqid in OPEN stateids to determine the order of OPEN processing done by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構造は、クライアントとサーバの間の種々の状態共有メカニズムのために使用されます。クライアントの場合、このデータ構造は読み取り専用です。サーバはのstateidの各遷移において単調SEQIDフィールドをインクリメントする必要があります。クライアントがサーバによって行わOPEN処理の順序を決定するためにOPENのstateidsにSEQIDを検査しますので、これは重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RPC and Security Flavor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RPCとセキュリティフレーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol is an RPC application that uses RPC version 2 and the XDR as defined in [RFC5531] and [RFC4506]. The RPCSEC_GSS security flavors as defined in version 1 ([RFC2203]) and version 2 ([RFC5403]) MUST be implemented as the mechanism to deliver stronger security for the NFSv4 protocol. However, deployment of RPCSEC_GSS is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4プロトコルは、[RFC5531]及び[RFC4506]で定義されるようにRPCバージョン2とXDRを使用してRPCアプリケーションです。バージョン1（[RFC2203]）とバージョン2（[RFC5403]）で定義されるようにRPCSEC_GSSセキュリティフレーバーはNFSv4のプロトコルのための強力なセキュリティを提供するための機構として実装されなければなりません。しかし、RPCSEC_GSSの導入は任意です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Ports and Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。ポートおよびトランスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Historically, NFSv2 and NFSv3 servers have resided on port 2049. The registered port 2049 [RFC3232] for the NFS protocol SHOULD be the default configuration. Using the registered port for NFS services means the NFS client will not need to use the RPC binding protocols as described in [RFC1833]; this will allow NFS to transit firewalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
歴史的に、のNFSv2とNFSv3のサーバは、NFSプロトコルの登録ポート2049 [RFC3232]はデフォルトの設定であるべきで、ポート2049上に置かれています。 NFSサービスのために登録されているポートを使用すると、NFSクライアントは[RFC1833]で説明したようにプロトコルをバインドRPCを使用する必要がないことを意味します。これはトランジットファイアウォールにNFSをできるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where an NFSv4 implementation supports operation over the IP network protocol, the supported transport layer between NFS and IP MUST be an IETF standardized transport protocol that is specified to avoid network congestion; such transports include TCP and the Stream Control Transmission Protocol (SCTP). To enhance the possibilities for interoperability, an NFSv4 implementation MUST support operation over the TCP transport protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4の実装では、IPネットワークプロトコルでの動作をサポートしている場合、NFSとIPとの間に支持され、トランスポート層、ネットワークの輻輳を回避するために指定されているIETF標準化されたトランスポート・プロトコルでなければなりません。そのようなトランスポートはTCPとストリーム制御伝送プロトコル（SCTP）が含まれます。相互運用性のための可能性を高めるため、NFSv4の実装は、TCPトランスポートプロトコル上での動作をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If TCP is used as the transport, the client and server SHOULD use persistent connections. This will prevent the weakening of TCP&#39;s congestion control via short-lived connections and will improve performance for the Wide Area Network (WAN) environment by eliminating the need for SYN handshakes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPはトランスポートとして使用されている場合は、クライアントとサーバは、持続的な接続を使用すべきです。これは短命接続を介してTCPの輻輳制御の弱体化を防ぐことができますし、SYNハンドシェイクの必要性を排除することによって、ワイドエリアネットワーク（WAN）環境のパフォーマンスが向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As noted in Section 19, the authentication model for NFSv4 has moved from machine-based to principal-based. However, this modification of the authentication model does not imply a technical requirement to move the TCP connection management model from whole machine-based to one based on a per-user model. In particular, NFS over TCP client implementations have traditionally multiplexed traffic for multiple users over a common TCP connection between an NFS client and server. This has been true, regardless of whether the NFS client is using AUTH_SYS, AUTH_DH, RPCSEC_GSS, or any other flavor. Similarly, NFS over TCP server implementations have assumed such a model and thus scale the implementation of TCP connection management in proportion to the number of expected client machines. It is intended that NFSv4 will not modify this connection management model. NFSv4 clients that violate this assumption can expect scaling issues on the server and hence reduced service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション19で述べたように、NFSv4のための認証モデルは、主ベースに機械ベースから移動しました。しかし、認証モデルのこの変更は、ユーザーごとのモデルに基づいたものに全マシンベースからTCP接続管理モデルを移動するための技術的要件を意味するものではありません。具体的には、NFS over TCPをクライアントの実装は、伝統的にNFSクライアントとサーバの間の共通のTCP接続を介して複数のユーザーのトラフィックを多重化しています。これは関係なく、NFSクライアントはAUTH_SYS、AUTH_DH、RPCSEC_GSS、または任意の他のフレーバーを使用しているかどうかの、真となっています。同様に、NFS TCPを介してサーバの実装は、そのようなモデルを想定しているので、予想されるクライアントマシンの数に比例してTCP接続管理の実装を拡張します。 NFSv4のは、この接続管理モデルを変更しないであろうことが意図されています。この仮定に違反するのNFSv4クライアントは、サーバー上のスケーリングの問題を期待し、したがって、サービスを削減することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Client Retransmission Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1。クライアントの再送信の動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When processing an NFSv4 request received over a reliable transport such as TCP, the NFSv4 server MUST NOT silently drop the request, except if the established transport connection has been broken. Given such a contract between NFSv4 clients and servers, clients MUST NOT retry a request unless one or both of the following are true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4の要求は、TCPなどの信頼性の高いトランスポートを介して受信処理する場合、NFSv4サーバは静かに確立されたトランスポート接続が切断された場合を除き、要求をドロップしてはなりません。次のいずれかまたは両方に該当する場合を除きNFSv4クライアントとサーバーの間で、このような契約を考えると、クライアントが要求を再試行してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The transport connection has been broken
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oトランスポート接続が切断されました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The procedure being retried is the NULL procedure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O再試行される手順は、NULL手順であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since reliable transports, such as TCP, do not always synchronously inform a peer when the other peer has broken the connection (for example, when an NFS server reboots), the NFSv4 client may want to actively &#34;probe&#34; the connection to see if has been broken. Use of the NULL procedure is one recommended way to do so. So, when a client experiences a remote procedure call timeout (of some arbitrary implementation-specific amount), rather than retrying the remote procedure call, it could instead issue a NULL procedure call to the server. If the server has died, the transport connection break will eventually be indicated to the NFSv4 client. The client can then reconnect, and then retry the original request. If the NULL procedure call gets a response, the connection has not broken. The client can decide to wait longer for the original request&#39;s response, or it can break the transport connection and reconnect before re-sending the original request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPのような信頼性の高いトランスポート、以来、常に同期他のピアが（例えば、時にNFSサーバのリブート）は、NFSv4クライアントが持っているかどうかを確認するために接続積極的に「プローブ」したいことがあり、接続が壊れたときのピアに通知しません。壊れて。 NULL手続きの使用がそうする1つの推奨される方法です。だから、ときに、クライアントは、（いくつかの任意の実装に固有の量の）リモート・プロシージャ・コールのタイムアウトを経験し、むしろ、リモート・プロシージャ・コールを再試行するよりも、それは代わりに、サーバーへのNULLプロシージャ・コールを発行することができます。サーバーが死亡した場合は、トランスポート接続の中断は、最終的にはNFSv4クライアントに表示されます。クライアントが再接続した後、元の要求を再試行することができます。 NULLプロシージャ・コールは、応答を取得した場合、接続が切断されていません。クライアントは、元の要求の応答のために長く待つことを決定することができ、またはそれは、トランスポート接続を解除し、元の要求を再送信する前に再接続することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For callbacks from the server to the client, the same rules apply, but the server doing the callback becomes the client, and the client receiving the callback becomes the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーからクライアントへのコールバックの場合、同じ規則が適用されますが、コールバックを行うサーバがクライアントになり、コールバックを受信するクライアントがサーバーになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Security Flavors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。セキュリティフレーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Traditional RPC implementations have included AUTH_NONE, AUTH_SYS, AUTH_DH, and AUTH_KRB4 as security flavors. With [RFC2203], an additional security flavor of RPCSEC_GSS has been introduced, which uses the functionality of GSS-API [RFC2743]. This allows for the use of various security mechanisms by the RPC layer without the additional implementation overhead of adding RPC security flavors. For NFSv4, the RPCSEC_GSS security flavor MUST be used to enable the mandatory-to-implement security mechanism. Other flavors, such as AUTH_NONE, AUTH_SYS, and AUTH_DH, MAY be implemented as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従来のRPCの実装は、セキュリティのフレーバーとしてAUTH_NONE、AUTH_SYS、AUTH_DH、およびAUTH_KRB4が含まれています。 [RFC2203]で、RPCSEC_GSSの追加のセキュリティ風味はGSS-API [RFC2743]の機能を使用する、導入されています。これは、RPCセキュリティ風味を加える追加の実施オーバーヘッドなしRPC層によって様々なセキュリティメカニズムの使用を可能にします。 NFSv4のために、RPCSEC_GSSセキュリティ風味は、実装に必須のセキュリティ・メカニズムを有効にするために使用しなければなりません。このようAUTH_NONE、AUTH_SYS、およびAUTH_DHのような他のフレーバーは、同様に実施することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. Security Mechanisms for NFSv4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1。 NFSv4のためのセキュリティメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RPCSEC_GSS, via GSS-API, supports multiple mechanisms that provide security services. For interoperability, NFSv4 clients and servers MUST support the Kerberos V5 security mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RPCSEC_GSSは、GSS-APIを経由して、セキュリティサービスを提供する複数のメカニズムをサポートしています。相互運用性のため、NFSv4のクライアントとサーバは、Kerberos V5セキュリティメカニズムをサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The use of RPCSEC_GSS requires selection of mechanism, quality of protection (QOP), and service (authentication, integrity, privacy). For the mandated security mechanisms, NFSv4 specifies that a QOP of zero is used, leaving it up to the mechanism or the mechanism&#39;s configuration to map QOP zero to an appropriate level of protection. Each mandated mechanism specifies a minimum set of cryptographic algorithms for implementing integrity and privacy. NFSv4 clients and servers MUST be implemented on operating environments that comply with the required cryptographic algorithms of each required mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RPCSEC_GSSの使用は、メカニズムの選択、保護の品質（QOP）、およびサービス（認証、完全性、プライバシー）が必要です。義務付けられたセキュリティメカニズムについては、NFSv4のは、機構や保護の適切なレベルにQOPゼロをマッピングするためのメカニズムの設定にそれを残して、ゼロのQOPが使用されていることを指定します。各義務付けメカニズムは、整合性とプライバシーを実装するための暗号化アルゴリズムの最小セットを指定します。 NFSv4クライアントとサーバは、それぞれ必要なメカニズムの必要な暗号化アルゴリズムに準拠動作環境に実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.1. Kerberos V5 as a Security Triple
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.1。セキュリティトリプルとしてKerberos V5
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Kerberos V5 GSS-API mechanism as described in [RFC4121] MUST be implemented with the RPCSEC_GSS services as specified in Table 2. Both client and server MUST support each of the pseudo-flavors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケルベロスV5 GSS-APIメカニズム[RFC4121]に記載されているように擬似フレーバーのそれぞれをサポートしなければならない表2に指定されたクライアントとサーバの両方としてRPCSEC_GSSサービスを実装しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +--------+-------+----------------------+-----------------------+
     | Number | Name  | Mechanism&#39;s OID      | RPCSEC_GSS service    |
     +--------+-------+----------------------+-----------------------+
     | 390003 | krb5  | 1.2.840.113554.1.2.2 | rpc_gss_svc_none      |
     | 390004 | krb5i | 1.2.840.113554.1.2.2 | rpc_gss_svc_integrity |
     | 390005 | krb5p | 1.2.840.113554.1.2.2 | rpc_gss_svc_privacy   |
     +--------+-------+----------------------+-----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 2: Mapping Pseudo-Flavor to Service
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表2：サービスへの擬似フレーバーのマッピング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the pseudo-flavor is presented here as a mapping aid to the implementer. Because this NFS protocol includes a method to negotiate security and it understands the GSS-API mechanism, the pseudo-flavor is not needed. The pseudo-flavor is needed for NFSv3 since the security negotiation is done via the MOUNT protocol as described in [RFC2623].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
擬似味が実装へのマッピングの補助として、ここで提示されることに注意してください。このNFSプロトコルはセキュリティを交渉する方法を含み、それはGSS-APIメカニズムを理解しているので、疑似風味が必要とされていません。 [RFC2623]に記載されているように、セキュリティネゴシエーションがMOUNTプロトコルを介して行われるため、疑似風味がNFSv3のために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At the time this document was specified, the Advanced Encryption Standard (AES) with HMAC-SHA1 was a required algorithm set for Kerberos V5. In contrast, when NFSv4.0 was first specified in [RFC3530], weaker algorithm sets were REQUIRED for Kerberos V5, and were REQUIRED in the NFSv4.0 specification, because the Kerberos V5 specification at the time did not specify stronger algorithms. The NFSv4 specification does not specify required algorithms for Kerberos V5, and instead, the implementer is expected to track the evolution of the Kerberos V5 standard if and when stronger algorithms are specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、指定された時点では、HMAC-SHA1でのAdvanced Encryption Standard（AES）はケルベロスV5に必要なアルゴリズムのセットでした。時ケルベロスV5仕様は強力なアルゴリズムを指定しなかったので、対照的に、NFSv4.0は、最初の[RFC3530]で指定された場合、より弱いアルゴリズムセットはケルベロスV5のために必要であった、そしてNFSv4.0仕様で必要でした。 NFSv4の仕様では、Kerberos V5のために必要なアルゴリズムを指定していない、その代わり、実装者は、強力なアルゴリズムが指定されている場合場合とKerberos V5の標準の進化を追跡することが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.2.1.1.1. Security Considerations for Cryptographic Algorithms in Kerberos V5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.2.1.1.1。ケルベロスV5での暗号化アルゴリズムのためのセキュリティの考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When deploying NFSv4, the strength of the security achieved depends on the existing Kerberos V5 infrastructure. The algorithms of Kerberos V5 are not directly exposed to or selectable by the client or server, so there is some due diligence required by the user of NFSv4 to ensure that security is acceptable where needed. Guidance is provided in [RFC6649] as to why weak algorithms should be disabled by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のを展開する場合、達成セキュリティの強さは、既存のKerberos V5インフラストラクチャに依存します。ケルベロスV5のアルゴリズムは、直接にさらされたり、クライアントまたはサーバによって選択されないので、必要な場合、セキュリティが受け入れ可能であることを確認するためにNFSv4のユーザが必要とするいくつかのデューデリジェンスがあります。ガイダンスは弱いアルゴリズムはデフォルトで無効にされなければならない理由として、[RFC6649]で提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Security Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。セキュリティネゴシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the NFSv4 server potentially offering multiple security mechanisms, the client needs a method to determine or negotiate which mechanism is to be used for its communication with the server. The NFS server can have multiple points within its file system namespace that are available for use by NFS clients. In turn, the NFS server can be configured such that each of these entry points can have different or multiple security mechanisms in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4サーバは、潜在的に複数のセキュリティメカニズムを提供して、クライアントは、サーバとの通信に使用すべきメカニズム決定または交渉する方法を必要とします。 NFSサーバは、NFSクライアントで使用するために用意されていて、ファイルシステムの名前空間内の複数のポイントを持つことができます。次に、NFSサーバは、これらのエントリ・ポイントの各々が使用中で異なる又は複数のセキュリティ・メカニズムを持つことができるように構成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The security negotiation between client and server SHOULD be done with a secure channel to eliminate the possibility of a third party intercepting the negotiation sequence and forcing the client and server to choose a lower level of security than required or desired. See Section 19 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバ間のセキュリティネゴシエーションは、交渉のシーケンスを傍受し、必要または所望されるよりもセキュリティの低いレベルを選択し、クライアントとサーバーを強制的に第三者の可能性を排除するために安全なチャネルで行われるべきです。さらなる議論については、セクション19を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. SECINFO
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1。 SECINFO
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SECINFO operation will allow the client to determine, on a per-filehandle basis, what security triple (see [RFC2743] and Section 16.31.4) is to be used for server access. In general, the client will not have to use the SECINFO operation, except during initial communication with the server or when the client encounters a new security policy as the client navigates the namespace. Either condition will force the client to negotiate a new security triple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SECINFO操作は、クライアントが決定できるようになり、あたりのファイルハンドルに基づき、どのようなセキュリティがトリプル（[RFC2743]とセクション16.31.4を参照）、サーバーへのアクセスに使用されます。一般的には、クライアントは、サーバー場合、またはクライアントが名前空間をナビゲートするクライアントは、新しいセキュリティポリシーを検出したとの初期通信中を除いて、SECINFO操作を使用する必要はありません。いずれかの条件は、三重の新しいセキュリティを交渉するクライアントを強制します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. Security Error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2。セキュリティエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Based on the assumption that each NFSv4 client and server MUST support a minimum set of security (i.e., Kerberos V5 under RPCSEC_GSS), the NFS client will start its communication with the server with one of the minimal security triples. During communication with the server, the client can receive an NFS error of NFS4ERR_WRONGSEC. This error allows the server to notify the client that the security triple currently being used is not appropriate for access to the server&#39;s file system resources. The client is then responsible for determining what security triples are available at the server and choosing one that is appropriate for the client. See Section 16.31 for further discussion of how the client will respond to the NFS4ERR_WRONGSEC error and use SECINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各NFSv4クライアントとサーバは、セキュリティの最小セットをサポートしなければならないという仮定に基づいて（すなわち、RPCSEC_GSS下ケルベロスV5）は、NFSクライアントは、最小限のセキュリティトリプルのいずれかを使用してサーバとの通信を開始します。サーバーとの通信中に、クライアントはNFS4ERR_WRONGSECのNFSエラーを受け取ることができます。このエラーは、サーバーがトリプル現在使用しているセキュリティが、サーバーのファイル・システム・リソースへのアクセスのために適切ではないことをクライアントに通知することができます。クライアントは、セキュリティトリプルはサーバーで利用可能であるかを決定し、クライアントに適切なものを選択する責任があります。クライアントがNFS4ERR_WRONGSECエラーに対応し、SECINFOを使用する方法のさらなる議論については、セクション16.31を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.3. Callback RPC Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.3。コールバックRPC認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Except as noted elsewhere in this section, the callback RPC (described later) MUST mutually authenticate the NFS server to the principal that acquired the client ID (also described later), using the security flavor of the original SETCLIENTID operation used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションの他の場所で述べたように除き、（後述する）コールバックRPCは、互いに使用した元のSETCLIENTID操作のセキュリティ風味を使用して、（これも後述する）クライアントIDを取得した主にNFSサーバを認証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For AUTH_NONE, there are no principals, so this is a non-issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AUTH_NONEのために、そこにはプリンシパルではないので、これは非問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AUTH_SYS has no notions of mutual authentication or a server principal, so the callback from the server simply uses the AUTH_SYS credential that the user used when he set up the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AUTH_SYSは、相互認証やサーバープリンシパルのない概念を持っていないので、サーバからのコールバックは、単に彼が委任を設定するとき、ユーザーが使用AUTH_SYS資格情報を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For AUTH_DH, one commonly used convention is that the server uses the credential corresponding to this AUTH_DH principal:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AUTH_DHについて、1つの一般的に使用される規則は、サーバがこのAUTH_DHプリンシパルに対応する資格情報を使用していることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unix.host@domain
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
うにｘ。ほｓｔ＠どまいん
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where host and domain are variables corresponding to the name of the server host and directory services domain in which it lives, such as a Network Information System domain or a DNS domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どこのホストとドメインには、それは、そのようなネットワーク情報システムのドメインまたはDNSドメインとして、住んでいるサーバーのホストとディレクトリサービスドメイン名に対応する変数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Regardless of what security mechanism under RPCSEC_GSS is being used, the NFS server MUST identify itself in GSS-API via a GSS_C_NT_HOSTBASED_SERVICE name type. GSS_C_NT_HOSTBASED_SERVICE names are of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
かかわらずRPCSEC_GSSの下のセキュリティメカニズムが使用されているものの、NFSサーバはGSS_C_NT_HOSTBASED_SERVICE名のタイプを経由してGSS-API自体を特定しなければなりません。 GSS_C_NT_HOSTBASED_SERVICE名の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
service@hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス@ホスト名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For NFS, the &#34;service&#34; element is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSの場合は、「サービス」の要素は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations of security mechanisms will convert nfs@hostname to various different forms. For Kerberos V5, the following form is RECOMMENDED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティ・メカニズムの実装は、種々の異なる形態にホスト名@ NFSを変換します。ケルベロスV5の場合は、以下のフォームをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfs/hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS /ホスト名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For Kerberos V5, nfs/hostname would be a server principal in the Kerberos Key Distribution Center database. This is the same principal the client acquired a GSS-API context for when it issued the SETCLIENTID operation; therefore, the realm name for the server principal must be the same for the callback as it was for the SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケルベロスV5の場合は、NFS /ホスト名は、Kerberosキー配布センター・データベースのサーバープリンシパルになります。これにより、クライアントはそれがSETCLIENTID操作を発行したときのためのGSS-APIコンテキストを取得し、同じ校長です。それがSETCLIENTIDのためにあったように、したがって、サーバー・プリンシパルのレルム名は、コールバックで同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Filehandles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The filehandle in the NFS protocol is a per-server unique identifier for a file system object. The contents of the filehandle are opaque to the client. Therefore, the server is responsible for translating the filehandle to an internal representation of the file system object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSプロトコルにおけるファイルハンドルは、ファイル・システム・オブジェクトごとのサーバの一意の識別子です。ファイルハンドルの内容は、クライアントに不透明です。したがって、サーバは、ファイル・システム・オブジェクトの内部表現にファイルハンドルを変換する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Obtaining the First Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。まず、ファイルハンドルの取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The operations of the NFS protocol are defined in terms of one or more filehandles. Therefore, the client needs a filehandle to initiate communication with the server. With the NFSv2 protocol [RFC1094] and the NFSv3 protocol [RFC1813], there exists an ancillary protocol to obtain this first filehandle. The MOUNT protocol, RPC program number 100005, provides the mechanism of translating a string-based file system pathname to a filehandle that can then be used by the NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSプロトコルの動作は、一つ以上のファイルハンドルで定義されています。そのため、クライアントは、サーバとの通信を開始するためにファイルハンドルを必要とします。 NFSv2プロトコル[RFC1094]とNFSv3のプロトコル[RFC1813]と、この第一のファイルハンドルを取得するために補助的なプロトコルが存在します。 MOUNTプロトコル、RPCプログラム番号100005は、次いで、NFSプロトコルによって使用することができるファイルハンドルに文字列ベースのファイルシステムのパス名を変換する機構を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The MOUNT protocol has deficiencies in the area of security and use via firewalls. This is one reason that the use of the public filehandle was introduced in [RFC2054] and [RFC2055]. With the use of the public filehandle in combination with the LOOKUP operation in the NFSv2 and NFSv3 protocols, it has been demonstrated that the MOUNT protocol is unnecessary for viable interaction between the NFS client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MOUNTプロトコルがファイアウォールを経由して、セキュリティと使用領域の欠陥を持っています。これは、1つの公共ファイルハンドルの使用は[RFC2054]で導入されたことを理由と[RFC2055]です。 NFSv2とNFSv3のプロトコルにおけるLOOKUP操作との組み合わせで、公共ファイルハンドルを使用すると、MOUNTプロトコルはNFSクライアントとサーバの間で実行可能な相互作用のために不必要であることが証明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Therefore, the NFSv4 protocol will not use an ancillary protocol for translation from string-based pathnames to a filehandle. Two special filehandles will be used as starting points for the NFS client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのため、NFSv4のプロトコルは、ファイルハンドルに文字列ベースのパス名からの翻訳のための補助的なプロトコルを使用しません。二つの特別なファイルハンドルはNFSクライアントのための出発点として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1。ルートファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first of the special filehandles is the root filehandle. The root filehandle is the &#34;conceptual&#34; root of the file system namespace at the NFS server. The client uses or starts with the root filehandle by employing the PUTROOTFH operation. The PUTROOTFH operation instructs the server to set the current filehandle to the root of the server&#39;s file tree. Once this PUTROOTFH operation is used, the client can then traverse the entirety of the server&#39;s file tree with the LOOKUP operation. A complete discussion of the server namespace is in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別なファイルハンドルの最初は、ルートファイルハンドルです。ルートファイルハンドルは、NFSサーバーでのファイルシステムの名前空間の「概念」ルートです。クライアントが使用していますかPUTROOTFH操作を採用することにより、ルートファイルハンドルから始まります。 PUTROOTFH操作は、サーバーのファイルツリーのルートに現在のファイルハンドルを設定するために、サーバーに指示します。このPUTROOTFH操作が使用されると、次にクライアントはLOOKUP操作でサーバーのファイルツリーの全体を横切ることができます。サーバーの名前空間の完全な議論はセクション7です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2。公開ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The second special filehandle is the public filehandle. Unlike the root filehandle, the public filehandle may be bound or represent an arbitrary file system object at the server. The server is responsible for this binding. It may be that the public filehandle and the root filehandle refer to the same file system object. However, it is up to the administrative software at the server and the policies of the server administrator to define the binding of the public filehandle and server file system object. The client may not make any assumptions about this binding. The client uses the public filehandle via the PUTPUBFH operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第2の特殊ファイルハンドルは、公開ファイルハンドルです。ルートファイルハンドルとは異なり、公共ファイルハンドルが結合してもよいし、サーバに任意のファイル・システム・オブジェクトを表します。サーバーは、この結合の原因です。これは、公共ファイルハンドルとルートファイルハンドルは同じファイル・システム・オブジェクトを参照している可能性があります。しかし、それが公共ファイルハンドルとサーバーのファイルシステムオブジェクトの結合を定義するために、サーバーの管理ソフトウェア、およびサーバ管理者の方針次第です。クライアントは、このバインディングについての仮定をしない場合があります。クライアントはPUTPUBFH操作を介して公衆ファイルハンドルを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Filehandle Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。ファイルハンドルタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the NFSv2 and NFSv3 protocols, there was one type of filehandle with a single set of semantics, of which the primary one was that it was persistent across a server reboot. As such, this type of filehandle is termed &#34;persistent&#34; in NFSv4. The semantics of a persistent filehandle remain the same as before. A new type of filehandle introduced in NFSv4 is the volatile filehandle, which attempts to accommodate certain server environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv2とNFSv3のプロトコルでは、ファイルハンドルの一つのタイプは、プライマリ1は、サーバの再起動全体で持続的だったことだったのセマンティクス、単一のセットでした。そのため、ファイルハンドルのこのタイプは、NFSv4の中で「持続的」と呼ばれています。永続的なファイルハンドルの意味は前と同じまま。 NFSv4のに導入されたファイルハンドルの新しいタイプは、特定のサーバ環境に適応しようとする揮発性ファイルハンドルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The volatile filehandle type was introduced to address server functionality or implementation issues that make correct implementation of a persistent filehandle infeasible. Some server environments do not provide a file system level invariant that can be used to construct a persistent filehandle. The underlying server file system may not provide the invariant, or the server&#39;s file system programming interfaces may not provide access to the needed invariant. Volatile filehandles may ease the implementation of server functionality, such as hierarchical storage management or file system reorganization or migration. However, the volatile filehandle increases the implementation burden for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
揮発性ファイルハンドルタイプは、実行不可能な永続的なファイルハンドルの正しい実装を行うサーバー機能や実装の問題に対処するために導入されました。一部のサーバー環境では、永続的なファイルハンドルを構築するために使用することができ、ファイル・システム・レベルの不変を提供していません。基盤となるサーバーのファイルシステムは、不変を提供することはできません、または、サーバーのファイル・システム・プログラミング・インターフェースは必要な不変へのアクセスを提供することはできません。揮発性ファイルハンドルは、階層ストレージ管理やファイルシステムの再編成または移行として、サーバの機能の実装を容易にすることができます。ただし、揮発性ファイルハンドルは、クライアントの実装の負担が増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the client will need to handle persistent and volatile filehandles differently, a file attribute is defined that may be used by the client to determine the filehandle types being returned by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは異なり、永続的かつ揮発性ファイルハンドルを処理する必要がありますので、ファイルの属性は、サーバーによって返されるファイルハンドルのタイプを決定するために、クライアントによって使用されることが規定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. General Properties of a Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1。ファイルハンドルの一般プロパティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The filehandle contains all the information the server needs to distinguish an individual file. To the client, the filehandle is opaque. The client stores filehandles for use in a later request and can compare two filehandles from the same server for equality by doing a byte-by-byte comparison. However, the client MUST NOT otherwise interpret the contents of filehandles. If two filehandles from the same server are equal, they MUST refer to the same file. However, it is not required that two different filehandles refer to different file system objects. Servers SHOULD try to maintain a one-to-one correspondence between filehandles and file system objects but there may be situations in which the mapping is not one-to-one. Clients MUST use filehandle comparisons only to improve performance, not for correct behavior. All clients need to be prepared for situations in which it cannot be determined whether two different filehandles denote the same object and in such cases need to avoid assuming that objects denoted are different, as this might cause incorrect behavior. Further discussion of filehandle and attribute comparison in the context of data caching is presented in Section 10.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルハンドルは、サーバーは、個々のファイルを区別するために必要なすべての情報が含まれています。クライアントに、ファイルハンドルは不透明です。クライアント店後の要求で使用するためにファイルハンドルとバイト単位の比較を行うことによって平等に同じサーバーから二つのファイルハンドルを比較することができます。ただし、クライアントは、そうでない場合はファイルハンドルの内容を解釈してはいけません。同じサーバからの2つのファイルハンドルが等しい場合、それらは同じファイルを参照する必要があります。しかし、二つの異なるファイルハンドルは異なるファイル・システム・オブジェクトを参照することを必要とされていません。サーバーは、ファイルハンドルとファイル・システム・オブジェクト間の1対1の対応関係を維持しようとする必要がありますが、マッピングは1対1でない状況があるかもしれません。クライアントは、だけでなく、正しい動作のために、パフォーマンスを向上させるためにファイルハンドルの比較を使用しなければなりません。すべてのクライアントは、2つの異なるファイルハンドルが同じオブジェクトを表すとこのような場合には、これは不正な動作を引き起こす可能性があるとして示されたオブジェクトが、異なっていると仮定して避ける必要があるかどうかを判断することができない状況のために準備する必要があります。データキャッシュのコンテキストでファイルハンドルと属性比較のさらなる議論は10.3.4項に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As an example, in the case that two different pathnames when traversed at the server terminate at the same file system object, the server SHOULD return the same filehandle for each path. This can occur if a hard link is used to create two filenames that refer to the same underlying file object and associated data. For example, if paths /a/b/c and /a/d/c refer to the same file, the server SHOULD return the same filehandle for both pathname traversals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一例として、サーバで横断つの異なるパス名が同じファイル・システム・オブジェクトで終端している場合に、サーバは、パス毎に同じファイルハンドルを返すべきです。ハードリンクは、同じ基本的なファイルオブジェクトと関連付けられたデータを参照する2つのファイル名を作成するために使用されている場合に発生する可能性があります。 /同じファイルを参照cはパス/ A / B / Cの場合、および/ A / D例えば、サーバは、両方のパス名のトラバーサルのために同じファイルハンドルを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Persistent Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2。永続的なファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A persistent filehandle is defined as having a fixed value for the lifetime of the file system object to which it refers. Once the server creates the filehandle for a file system object, the server MUST accept the same filehandle for the object for the lifetime of the object. If the server restarts or reboots, the NFS server must honor the same filehandle value as it did in the server&#39;s previous instantiation. Similarly, if the file system is migrated, the new NFS server must honor the same filehandle as the old NFS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
永続ファイルハンドルは、それが参照するファイル・システム・オブジェクトの寿命のために固定値を有するものとして定義されます。サーバーは、ファイル・システム・オブジェクトのファイルハンドルを作成すると、サーバーは、オブジェクトの寿命のためのオブジェクトの同じファイルハンドルを受け入れなければなりません。それは、サーバーの以前のインスタンスで行ったように、サーバの再起動またはリブートした場合は、NFSサーバは、同じファイルハンドル値を尊重しなければなりません。ファイルシステムが移行された場合も同様に、新しいNFSサーバは、古いNFSサーバと同じファイルハンドルを尊重しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The persistent filehandle will become stale or invalid when the file system object is removed. When the server is presented with a persistent filehandle that refers to a deleted object, it MUST return an error of NFS4ERR_STALE. A filehandle may become stale when the file system containing the object is no longer available. The file system may become unavailable if it exists on removable media and the media is no longer available at the server, or if the file system in whole has been destroyed, or if the file system has simply been removed from the server&#39;s namespace (i.e., unmounted in a UNIX environment).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイル・システム・オブジェクトが削除されたときに、永続ファイルハンドルは、古い、または無効になります。サーバーが削除されたオブジェクトを参照する永続的なファイルハンドルが提示されている場合、それはNFS4ERR_STALEのエラーを返さなければなりません。オブジェクトを含むファイルシステムが使用できなくなったとき、ファイルハンドルが古くなっていないことがあります。それは、リムーバブルメディア上に存在しないとメディアはサーバーで使用できなくなった、または全体のファイルシステムが破壊された場合、またはファイルシステムは、単にサーバの名前空間（すなわち、から削除されている場合場合は、ファイルシステムが使用できなくなることがあり）UNIX環境でのアンマウント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3。揮発性ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A volatile filehandle does not share the same longevity characteristics of a persistent filehandle. The server may determine that a volatile filehandle is no longer valid at many different points in time. If the server can definitively determine that a volatile filehandle refers to an object that has been removed, the server should return NFS4ERR_STALE to the client (as is the case for persistent filehandles). In all other cases where the server determines that a volatile filehandle can no longer be used, it should return an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
揮発性ファイルハンドルは、持続的なファイルハンドルの同じ寿命特性を共有しません。サーバーは、揮発性ファイルハンドルが時間内に多くの異なる時点でもはや有効であることを決定しないことがあります。サーバは決定的揮発性ファイルハンドルが削除されたオブジェクトを参照することを決定することができる場合（永続ファイルハンドルの場合のように）、サーバは、クライアントにNFS4ERR_STALEを返すべきです。サーバーが揮発性ファイルハンドルが使用できなくなると判断した他のすべてのケースでは、それはNFS4ERR_FHEXPIREDのエラーを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The REQUIRED attribute &#34;fh_expire_type&#34; is used by the client to determine what type of filehandle the server is providing for a particular file system. This attribute is a bitmask with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必要な属性「fh_expire_typeは、」特定のファイルシステムのために提供しているファイルハンドルのサーバーの種類を決定するために、クライアントによって使用されます。この属性は、次の値を持つビットマスクです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_PERSISTENT: The value of FH4_PERSISTENT is used to indicate a persistent filehandle, which is valid until the object is removed from the file system. The server will not return NFS4ERR_FHEXPIRED for this filehandle. FH4_PERSISTENT is defined as a value in which none of the bits specified below are set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_PERSISTENT：FH4_PERSISTENTの値は、オブジェクトがファイルシステムから削除されるまで有効です。永続的なファイルハンドルを示すために使用されます。サーバーは、このファイルハンドルのためNFS4ERR_FHEXPIREDを返しません。 FH4_PERSISTENTは、以下の指定されたビットのどれも設定されていないれた値として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_VOLATILE_ANY: The filehandle may expire at any time, except as specifically excluded (i.e., FH4_NOEXPIRE_WITH_OPEN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_VOLATILE_ANY：ファイルハンドルは、具体的に（即ち、FH4_NOEXPIRE_WITH_OPEN）除外を除き、任意の時点で有効期限が切れることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_NOEXPIRE_WITH_OPEN: May only be set when FH4_VOLATILE_ANY is set. If this bit is set, then the meaning of FH4_VOLATILE_ANY is qualified to exclude any expiration of the filehandle when it is open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_NOEXPIRE_WITH_OPENは：FH4_VOLATILE_ANYが設定されている場合にのみ設定することができます。このビットがセットされている場合は、FH4_VOLATILE_ANYの意味は、それが開いているときにファイルハンドルのいずれかの有効期限を除外する資格があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_VOL_MIGRATION: The filehandle will expire as a result of migration. If FH4_VOLATILE_ANY is set, FH4_VOL_MIGRATION is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_VOL_MIGRATION：ファイルハンドルは、移行の結果として、期限切れになります。 FH4_VOLATILE_ANYが設定されている場合、FH4_VOL_MIGRATIONは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_VOL_RENAME: The filehandle will expire during rename. This includes a rename by the requesting client or a rename by any other client. If FH4_VOLATILE_ANY is set, FH4_VOL_RENAME is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH4_VOL_RENAME：ファイルハンドルは、名前の変更時に期限切れになります。これは、要求元のクライアントによる名前変更またはその他のクライアントによる名前の変更が含まれています。 FH4_VOLATILE_ANYが設定されている場合、FH4_VOL_RENAMEは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers that provide volatile filehandles that may expire while open (i.e., if FH4_VOL_MIGRATION or FH4_VOL_RENAME is set or if FH4_VOLATILE_ANY is set and FH4_NOEXPIRE_WITH_OPEN is not set) should deny a RENAME or REMOVE that would affect an OPEN file of any of the components leading to the OPEN file. In addition, the server SHOULD deny all RENAME or REMOVE requests during the grace period upon server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方、有効期限が切れて揮発性ファイルハンドルを提供するサーバのオープン（すなわち、FH4_VOL_MIGRATIONまたはFH4_VOL_RENAMEが設定されている場合、またはFH4_VOLATILE_ANYが設定されている場合とFH4_NOEXPIRE_WITH_OPENが設定されていない）RENAMEを否定するかにつながるのコンポーネントのいずれかのOPENのファイルに影響を与えることを削除する必要がありますOPENファイル。また、サーバはすべてのRENAMEを否定すべきであるか、サーバーの再起動時に猶予期間中の要求を削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the bits FH4_VOL_MIGRATION and FH4_VOL_RENAME allow the client to determine that expiration has occurred whenever a specific event occurs, without an explicit filehandle expiration error from the server. FH4_VOLATILE_ANY does not provide this form of information. In situations where the server will expire many, but not all, filehandles upon migration (e.g., all but those that are open), FH4_VOLATILE_ANY (in this case, with FH4_NOEXPIRE_WITH_OPEN) is a better choice since the client may not assume that all filehandles will expire when migration occurs, and it is likely that additional expirations will occur (as a result of file CLOSE) that are separated in time from the migration event itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビットFH4_VOL_MIGRATIONとFH4_VOL_RENAMEは、特定のイベントが発生するたびにその有効期限を決定するために、クライアントがサーバからの明示的なファイルハンドル満了エラーなしで、発生している可能にすることに注意してください。 FH4_VOLATILE_ANYはこの情報の形式を提供していません。サーバは、多くの有効期限が切れますが、全てではなく、移行時のファイルハンドル（例えば、すべてが、オープンされているもの）、（FH4_NOEXPIRE_WITH_OPENこの場合、）FH4_VOLATILE_ANYは、クライアントはすべてのファイルハンドルがすることを前提としない場合がありますので、より良い選択である状況ではマイグレーションが発生したときに期限切れとなり、移行イベント自体から時間的に分離されている（ファイルCLOSEの結果として）追加の有効期限が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4. One Method of Constructing a Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4。揮発性ファイルハンドルを構築する一つの方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A volatile filehandle, while opaque to the client, could contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
揮発性ファイルハンドルは、クライアントには不透明ながら、含めることができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[volatile bit = 1 | server boot time | slot | generation number]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[揮発性ビット= 1 |サーバーの起動時間|スロット|世代番号]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o slot is an index in the server volatile filehandle table
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oスロットは、サーバ揮発性ファイルハンドルテーブルのインデックスであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o generation number is the generation number for the table entry/slot
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O世代番号は、テーブルエントリ/スロットの世代番号であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client presents a volatile filehandle, the server makes the following checks, which assume that the check for the volatile bit has passed. If the server boot time is less than the current server boot time, return NFS4ERR_FHEXPIRED. If slot is out of range, return NFS4ERR_BADHANDLE. If the generation number does not match, return NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、揮発性ファイルハンドルを提示すると、サーバーは、揮発性ビットのチェックが合格したことを前提とし、以下のチェックを、作ります。サーバーの起動時間は、現在のサーバーの起動時間よりも小さい場合、NFS4ERR_FHEXPIREDを返します。スロットが範囲外の場合は、NFS4ERR_BADHANDLEを返します。世代番号が一致しない場合は、NFS4ERR_FHEXPIREDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server reboots, the table is gone (it is volatile).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーを再起動すると、テーブルには消えている（それは揮発性です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the volatile bit is 0, then it is a persistent filehandle with a different structure following it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
揮発性のビットが0であれば、それはそれ以下の異なる構造を持つ永続的なファイルハンドルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Client Recovery from Filehandle Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。ファイルハンドルの有効期限からクライアント回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If possible, the client should recover from the receipt of an NFS4ERR_FHEXPIRED error. The client must take on additional responsibility so that it may prepare itself to recover from the expiration of a volatile filehandle. If the server returns persistent filehandles, the client does not need these additional steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
可能な場合、クライアントはNFS4ERR_FHEXPIREDエラーの受領から回復する必要があります。それは揮発性ファイルハンドルの満了から回復するために自分自身を準備することができるように、クライアントは、追加の責任を取る必要があります。サーバーは、永続的なファイルハンドルを返した場合、クライアントは、これらの追加の手順は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For volatile filehandles, most commonly the client will need to store the component names leading up to and including the file system object in question. With these names, the client should be able to recover by finding a filehandle in the namespace that is still available or by starting at the root of the server&#39;s file system namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
揮発性ファイルハンドルのために、最も一般的なクライアントは、コンポーネント名に至るまで、問題のファイル・システム・オブジェクトを含むを保存する必要があります。これらの名前を使用すると、クライアントはまだ利用できたり、サーバーのファイルシステムの名前空間のルートに開始することである名前空間にファイルハンドルを見つけることによって回復することができるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the expired filehandle refers to an object that has been removed from the file system, obviously the client will not be able to recover from the expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
期限切れのファイルハンドルは、ファイルシステムから削除されたオブジェクトを参照する場合は、明らかにクライアントが期限切れのファイルハンドルから回復することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is also possible that the expired filehandle refers to a file that has been renamed. If the file was renamed by another client, again it is possible that the original client will not be able to recover. However, in the case that the client itself is renaming the file and the file is open, it is possible that the client may be able to recover. The client can determine the new pathname based on the processing of the rename request. The client can then regenerate the new filehandle based on the new pathname. The client could also use the COMPOUND operation mechanism to construct a set of operations like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
期限切れのファイルハンドルの名前が変更されたファイルを参照することも可能です。ファイルが別のクライアントによって名前が変更された場合は、再度、元のクライアントが回復することができない可能性があります。しかし、クライアント自身がファイルの名前を変更され、ファイルが開いている場合には、クライアントが回復することができる可能性があります。クライアントは、名前変更要求の処理に基づいて、新しいパス名を決定することができます。クライアントは、新しいパス名に基づいて新しいファイルハンドルを再生成することができます。また、クライアントは、のような一連の操作を構築するためにCOMPOUND操作機構を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RENAME A B LOOKUP B GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B LOOKUP B GETFHの名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the COMPOUND procedure does not provide atomicity. This example only reduces the overhead of recovering from an expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順は原子性を提供していないことに注意してください。この例では、唯一の有効期限が切れたファイルハンドルからの回復のオーバーヘッドを軽減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To meet the requirements of extensibility and increased interoperability with non-UNIX platforms, attributes need to be handled in a flexible manner. The NFSv3 fattr3 structure contains a fixed list of attributes that not all clients and servers are able to support or care about. The fattr3 structure cannot be extended as new needs arise, and it provides no way to indicate non-support. With the NFSv4.0 protocol, the client is able to query what attributes the server supports and construct requests with only those supported attributes (or a subset thereof).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非UNIXプラットフォームと拡張性と相互運用性が向上の要件を満たすために、属性は、柔軟な方法で処理する必要があります。 NFSv3のfattr3構造は、すべてのクライアントとサーバーではないが、サポートしたり、気にすることができます属性の固定されたリストが含まれています。新たなニーズが発生するようfattr3構造を拡張することはできません、それは非サポートを示す方法を提供していません。 NFSv4.0プロトコルを使用すると、クライアントは、サーバーがサポートするどの属性照会とのみサポートされる属性（またはそのサブセット）とのリクエストを構築することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To this end, attributes are divided into three groups: REQUIRED, RECOMMENDED, and named. Both REQUIRED and RECOMMENDED attributes are supported in the NFSv4.0 protocol by a specific and well-defined encoding and are identified by number. They are requested by setting a bit in the bit vector sent in the GETATTR request; the server response includes a bit vector to list what attributes were returned in the response. New REQUIRED or RECOMMENDED attributes may be added to the NFSv4 protocol as part of a new minor version by publishing a Standards Track RFC that allocates a new attribute number value and defines the encoding for the attribute. See Section 11 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このため、属性は3つのグループに分けています必須、推奨、および命名します。必須および推奨属性の両方が特異的かつ明確に定義されたエンコーディングによってNFSv4.0プロトコルでサポートされており、番号で識別されます。それらはGETATTR要求で送信されたビット・ベクトル内のビットを設定することによって要求されています。サーバーの応答は、属性が応答で返されたものをリストするビットベクトルを含んでいます。新しい必須または推奨の属性は新しい属性数値を割り当て、属性のエンコーディングを定義する標準化過程のRFCを公開することによって、新たなマイナーバージョンの一部としてのNFSv4プロトコルに加えてもよいです。さらなる議論については、セクション11を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Named attributes are accessed by the OPENATTR operation, which accesses a hidden directory of attributes associated with a file system object. OPENATTR takes a filehandle for the object and returns the filehandle for the attribute hierarchy. The filehandle for the named attributes is a directory object accessible by LOOKUP or READDIR and contains files whose names represent the named attributes and whose data bytes are the value of the attribute. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前の属性は、ファイル・システム・オブジェクトに関連付けられた属性の隠しディレクトリにアクセスOPENATTR操作によってアクセスされます。 OPENATTRは、オブジェクトのファイルハンドルを取り、属性階層のためのファイルハンドルを返します。名前の属性のファイルハンドルは、LOOKUPまたはREADDIRからアクセス可能なディレクトリオブジェクトで、名前が命名された属性とデータバイト属性の値ですが表すファイルが含まれています。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +----------+-----------+---------------------------------+
        | LOOKUP   | &#34;foo&#34;     | ; look up file                  |
        | GETATTR  | attrbits  |                                 |
        | OPENATTR |           | ; access foo&#39;s named attributes |
        | LOOKUP   | &#34;x11icon&#34; | ; look up specific attribute    |
        | READ     | 0,4096    | ; read stream of bytes          |
        +----------+-----------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Named attributes are intended for data needed by applications rather than by an NFS client implementation. NFS implementers are strongly encouraged to define their new attributes as RECOMMENDED attributes by bringing them to the IETF Standards Track process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前付き属性は、アプリケーションではなく、NFSクライアントの実装が必要とするデータのために意図されています。 NFSの実装が強くIETF標準化過程のプロセスにそれらをもたらすことが推奨する属性として彼らの新しい属性を定義することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The set of attributes that are classified as REQUIRED is deliberately small since servers need to do whatever it takes to support them. A server should support as many of the RECOMMENDED attributes as possible; however, by their definition, the server is not required to support all of them. Attributes are deemed REQUIRED if the data is both needed by a large number of clients and is not otherwise reasonably computable by the client when support is not provided on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはそれがそれらをサポートするために取るものは何でもする必要がありますので、必要に応じて分類されている属性のセットは、意図的に小さいです。サーバーは、可能な限り推奨属性の多くをサポートする必要があります。しかし、その定義により、サーバはそれらのすべてをサポートする必要はありません。属性は、データが両方のクライアントの数が多いことにより、必要とサポートがサーバー上で提供されていない場合、クライアントでそれ以外の場合は、合理的に計算可能ではありませんされている場合は必須と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the hidden directory returned by OPENATTR is a convenience for protocol processing. The client should not make any assumptions about the server&#39;s implementation of named attributes and whether or not the underlying file system at the server has a named attribute directory. Therefore, operations such as SETATTR and GETATTR on the named attribute directory are undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENATTRによって返された隠しディレクトリは、プロトコル処理のための便利であることに注意してください。クライアントは、指定された属性のサーバの実装について、サーバーの基本的なファイルシステムは、名前付き属性のディレクトリを持っているかどうか任意の仮定を行うべきではありません。したがって、このような名前の属性ディレクトリにSETATTRやGETATTRなどの操作が定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. REQUIRED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。必要な属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These attributes MUST be supported by every NFSv4.0 client and server in order to ensure a minimum level of interoperability. The server MUST store and return these attributes, and the client MUST be able to function with an attribute set limited to these attributes. With just the REQUIRED attributes, some client functionality can be impaired or limited in some ways. A client can ask for any of these attributes to be returned by setting a bit in the GETATTR request. For each such bit set, the server MUST return the corresponding attribute value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの属性は、相互運用性の最小レベルを確保するために、すべてのNFSv4.0のクライアントとサーバでサポートしなければなりません。サーバに格納され、これらの属性を返し、クライアントがこれらの属性に制限された属性セットで機能できなければならないしなければなりません。ただ、必要な属性を使用すると、いくつかのクライアント機能は、いくつかの方法で障害または制限することができます。クライアントは、GETATTR要求にビットをセットすることによって返されるこれらの属性のいずれかを求めることができます。このような各ビットのセットのために、サーバは、対応する属性値を返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. RECOMMENDED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。推奨属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These attributes are understood well enough to warrant support in the NFSv4.0 protocol. However, they may not be supported on all clients and servers. A client MAY ask for any of these attributes to be returned by setting a bit in the GETATTR request but MUST handle the case where the server does not return them. A client MAY ask for the set of attributes the server supports and SHOULD NOT request attributes the server does not support. A server should be tolerant of requests for unsupported attributes and simply not return them, rather than considering the request an error. It is expected that servers will support all attributes they comfortably can and only fail to support attributes that are difficult to support in their operating environments. A server should provide attributes whenever they don&#39;t have to &#34;tell lies&#34; to the client. For example, a file modification time either should be an accurate time or should not be supported by the server. At times this will be difficult for clients, but a client is better positioned to decide whether and how to fabricate or construct an attribute or whether to do without the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの属性は、NFSv4.0プロトコルでサポートを保証するために十分に理解されています。しかし、彼らはすべてのクライアントとサーバーではサポートされない場合があります。クライアントは、GETATTR要求にビットをセットすることによって返されるこれらの属性のいずれかを求めることができるが、サーバーがそれらを返さない場合を処理する必要があります。クライアントは、サーバーがサポートする属性のセットを求めることができるとSHOULD NOT要求がサポートされていないサーバーを属性。サーバがサポートされていない属性に対する要求の耐性があると単純にかなり要求のエラーを考慮するよりも、それらを返すべきではありません。サーバは、彼らが快適にできるすべての属性をサポートするだけで自分の操作環境でサポートすることが困難な属性をサポートするために失敗することが期待されます。彼らは、クライアントに「嘘をつく」する必要はありませんいつでもサーバーは、属性を提供する必要があります。例えば、ファイルの修正時刻が正確な時間でなければなりませんいずれか、またはサーバによってサポートされてはなりません。時にはこれは、クライアントのために困難になりますが、クライアントは良く製造または属性を構築または属性なしで行うかどうかをするかどうか、およびその方法を決定するように配置されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Named Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。指定された属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These attributes are not supported by direct encoding in the NFSv4 protocol but are accessed by string names rather than numbers and correspond to an uninterpreted stream of bytes that are stored with the file system object. The namespace for these attributes may be accessed by using the OPENATTR operation. The OPENATTR operation returns a filehandle for a virtual &#34;named attribute directory&#34;, and further perusal and modification of the namespace may be done using operations that work on more typical directories. In particular, READDIR may be used to get a list of such named attributes, and LOOKUP and OPEN may select a particular attribute. Creation of a new named attribute may be the result of an OPEN specifying file creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの属性はNFSv4のプロトコルで直接符号化することによってサポートされていないが、文字列の名前ではなく番号でアクセスされ、ファイル・システム・オブジェクトに格納されたバイトの未解釈のストリームに対応します。これらの属性の名前空間はOPENATTR操作を使用してアクセスすることができます。 OPENATTR操作がより一般的なディレクトリに取り組む操作を用いて行うことができる名前空間の仮想「という名前の属性ディレクトリ」、さらに閲覧や変更のためのファイルハンドルを返します。特に、READDIRは、そのような名前の属性のリストを取得するために使用することができる、とLOOKUPとOPENは、特定の属性を選択することができます。新しい名前付き属性の作成は、OPEN指定ファイル作成の結果であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once an OPEN is done, named attributes may be examined and changed by normal READ and WRITE operations using the filehandles and stateids returned by OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENが完了すると、名前の属性が検査され、ファイルハンドルを使用して、通常の読み取りおよび書き込み操作によって変更し、OPENによって返さのstateidsすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Named attributes and the named attribute directory may have their own (non-named) attributes. Each of these objects must have all of the REQUIRED attributes and may have additional RECOMMENDED attributes. However, the set of attributes for named attributes and the named attribute directory need not be, and typically will not be, as large as that for other objects in that file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前付き属性と名前の属性ディレクトリは、独自の（非命名）の属性を有することができます。これらの各オブジェクトは、必要なすべての属性を持っている必要がありますし、追加の推奨属性を有することができます。しかし、指定された属性と名前の属性ディレクトリの属性のセットがある必要はない、と一般的に、そのファイルシステム内の他のオブジェクトの場合と同じ大きさではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Named attributes might be the target of delegations. However, since granting of delegations is at the server&#39;s discretion, a server need not support delegations on named attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前付き属性は、代表団のターゲットであるかもしれません。代表団の付与は、サーバーの裁量であるので、サーバーは指定された属性に代表団をサポートしている必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is RECOMMENDED that servers support arbitrary named attributes. A client should not depend on the ability to store any named attributes in the server&#39;s file system. If a server does support named attributes, a client that is also able to handle them should be able to copy a file&#39;s data and metadata with complete transparency from one location to another; this would imply that names allowed for regular directory entries are valid for named attribute names as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、任意の名前の属性をサポートすることが推奨されます。クライアントは、サーバのファイルシステム内の任意の名前の属性を格納する能力に依存すべきではありません。サーバがサポートという名前の属性がない場合、またそれらを扱うことができるクライアントは、ある場所から別の場所への完全な透明性を持つファイルのデータおよびメタデータをコピーすることができるはずです。これは、通常のディレクトリエントリには使用でき名称は、同様の名前の属性名のために有効であることを含意するでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In NFSv4.0, the structure of named attribute directories is restricted in a number of ways, in order to prevent the development of non-interoperable implementations in which some servers support a fully general hierarchical directory structure for named attributes while others support a limited but adequate structure for named attributes. In such an environment, clients or applications might come to depend on non-portable extensions. The restrictions are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.0では、という名前の属性ディレクトリの構造は、他の人が制限されますがをサポートしながら、一部のサーバが指定された属性の完全一般的な階層ディレクトリ構造をサポートする非相互運用可能な実装の開発を防ぐために、いくつかの方法で制限されています指定された属性のための適切な構造。このような環境では、クライアントまたはアプリケーションは、非ポータブル拡張に依存するようになるかもしれません。制限事項は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o CREATE is not allowed in a named attribute directory. Thus, such objects as symbolic links and special files are not allowed to be named attributes. Further, directories may not be created in a named attribute directory, so no hierarchical structure of named attributes for a single object is allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oという名前の属性ディレクトリに許可されていませんCREATE。したがって、シンボリックリンクや特殊なファイルのようなオブジェクトは、指定された属性であることを許可されていません。さらに、ディレクトリはという名前の属性ディレクトリに作成されない場合があり、その単一のオブジェクトの名前付き属性のない階層構造が許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If OPENATTR is done on a named attribute directory or on a named attribute, the server MUST return an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENATTRという名前の属性ディレクトリ上または名前付き属性に行われている場合は、O、サーバがエラーを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Doing a RENAME of a named attribute to a different named attribute directory or to an ordinary (i.e., non-named-attribute) directory is not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
異なる名前の属性ディレクトリにまたは通常の（すなわち、非命名属性）ディレクトリが許可されていないに指定された属性のRENAMEを行うO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Creating hard links between named attribute directories or between named attribute directories and ordinary directories is not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前付き属性のディレクトリ間または名前付き属性ディレクトリと通常のディレクトリ間のハードリンクを作成するoを許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Names of attributes will not be controlled by this document or other IETF Standards Track documents. See Section 20 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性の名前は、この文書または他のIETF標準化過程文書によって制御されることはありません。さらなる議論については、セクション20を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Classification of Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。属性の分類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each of the attributes accessed using SETATTR and GETATTR (i.e., REQUIRED and RECOMMENDED attributes) can be classified in one of three categories:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各属性は、次の3つのカテゴリのいずれかに分類することができるSETATTRとGETATTR（即ち、必須および推奨属性）を使用してアクセス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. per-server attributes for which the value of the attribute will be the same for all file objects that share the same server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性の値が同じサーバーを共有するすべてのファイルオブジェクトに対して同じになりますれる1サーバごとの属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. per-file system attributes for which the value of the attribute will be the same for some or all file objects that share the same server and fsid attribute (Section 5.8.1.9). See below for details regarding when such sharing is in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.ファイルシステムごとに属性の値が同じサーバとFSID属性（セクション5.8.1.9）を共有一部またはすべてのファイルオブジェクトに対して同じになりますどの属性。そのような共有が有効になっているときに関する詳細については、以下を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. per-file system object attributes.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.ファイルシステムごとのオブジェクト属性。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The handling of per-file system attributes depends on the particular attribute and the setting of the homogeneous (Section 5.8.2.12) attribute. The following rules apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性ごとのファイルシステムの取り扱いは、特定の属性と均質（セクション5.8.2.12）属性の設定に依存します。次の規則が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. The values of the attributes supported_attrs, fsid, homogeneous, link_support, and symlink_support are always common to all objects within the given file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.属性supported_attrs、FSID、均質、link_support、およびsymlink_supportの値は、常に与えられたファイルシステム内のすべてのオブジェクトに共通しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. For other attributes, different values may be returned for different file system objects if the attribute homogeneous is supported within the file system in question and has the value false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他の属性について2.は、異なる値が均質な属性は、問題のファイルシステム内でサポートされている場合、別のファイルシステムオブジェクトに対して返されると、偽の値を持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The classification of attributes is as follows. Note that the attributes time_access_set and time_modify_set are not listed in this section, because they are write-only attributes corresponding to time_access and time_modify and are used in a special instance of SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のような属性の分類があります。それらは書き込み専用のtime_accessとtime_modifyに対応する属性とSETATTRの特殊なインスタンスで使用されているため、属性time_access_setとtime_modify_setこのセクションに記載されていないことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The per-server attribute is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバごとの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
lease_time
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リース時間
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The per-file system attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムごとoを属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         supported_attrs, fh_expire_type, link_support, symlink_support,
         unique_handles, aclsupport, cansettime, case_insensitive,
         case_preserving, chown_restricted, files_avail, files_free,
         files_total, fs_locations, homogeneous, maxfilesize, maxname,
         maxread, maxwrite, no_trunc, space_avail, space_free,
         space_total, and time_delta
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The per-file system object attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムごとにオブジェクトoの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         type, change, size, named_attr, fsid, rdattr_error, filehandle,
         acl, archive, fileid, hidden, maxlink, mimetype, mode,
         numlinks, owner, owner_group, rawdev, space_used, system,
         time_access, time_backup, time_create, time_metadata,
         time_modify, and mounted_on_fileid
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For quota_avail_hard, quota_avail_soft, and quota_used, see their definitions below for the appropriate classification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
quota_avail_hard、quota_avail_soft、およびQUOTA_USEDために、適切な分類については、以下のそれらの定義を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Set-Only and Get-Only Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。のみの設定とは、Get-属性のみ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some REQUIRED and RECOMMENDED attributes are set-only; i.e., they can be set via SETATTR but not retrieved via GETATTR. Similarly, some REQUIRED and RECOMMENDED attributes are get-only; i.e., they can be retrieved via GETATTR but not set via SETATTR. If a client attempts to set a get-only attribute or get a set-only attribute, the server MUST return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの必須および推奨属性は設定専用です。すなわち、それらはSETATTRを介して設定されたが、GETATTRを介して取得しないことができます。同様に、いくつかの必須および推奨の属性が取得専用です。すなわち、それらはGETATTRを介して取り出さなくSETATTRを介して設定されていないことができます。クライアントは、get-のみ設定属性またはセットのみの属性を取得しようとすると、サーバーはNFS4ERR_INVALを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. REQUIRED Attributes - List and Definition References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6。必要な属性 - リストと定義参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The list of REQUIRED attributes appears in Table 3. The meanings of the columns of the table are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必要な属性のリストを表3に表示されるテーブルの列の意味は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Name: The name of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O名：属性の名前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o ID: The number assigned to the attribute. In the event of conflicts between the assigned number and [RFC7531], the latter is authoritative, but in such an event, it should be resolved with errata to this document and/or [RFC7531]. See [IESG_ERRATA] for the errata process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OのID：属性に割り当てられた番号。割り当てられた番号と[RFC7531]の間で競合が発生した場合、後者は信頼できますが、そのような場合には、この文書および/または[RFC7531]にエラッタで解決すべきです。正誤表・プロセスのために[IESG_ERRATA]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Data Type: The XDR data type of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oデータタイプ：属性のXDRデータ型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Acc: Access allowed to the attribute. R means read-only (GETATTR may retrieve, SETATTR may not set). W means write-only (SETATTR may set, GETATTR may not retrieve). R W means read/write (GETATTR may retrieve, SETATTR may set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acc○：アクセス属性に許可されます。 Rは読み取り専用（GETATTRが検索してもよい、SETATTRが設定されていない場合があります）を意味します。 Wは、書き込み専用（SETATTRは、設定することがGETATTRが取得できない場合があります）を意味します。 R Wは、読み取り/書き込みを意味（GETATTRが検索してもよい、SETATTRは設定可能）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Defined in: The section of this specification that describes the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性を記述し、この仕様のセクション：Oで定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-----------------+----+------------+-----+-------------------+
      | Name            | ID | Data Type  | Acc | Defined in        |
      +-----------------+----+------------+-----+-------------------+
      | supported_attrs | 0  | bitmap4    | R   | Section 5.8.1.1   |
      | type            | 1  | nfs_ftype4 | R   | Section 5.8.1.2   |
      | fh_expire_type  | 2  | uint32_t   | R   | Section 5.8.1.3   |
      | change          | 3  | changeid4  | R   | Section 5.8.1.4   |
      | size            | 4  | uint64_t   | R W | Section 5.8.1.5   |
      | link_support    | 5  | bool       | R   | Section 5.8.1.6   |
      | symlink_support | 6  | bool       | R   | Section 5.8.1.7   |
      | named_attr      | 7  | bool       | R   | Section 5.8.1.8   |
      | fsid            | 8  | fsid4      | R   | Section 5.8.1.9   |
      | unique_handles  | 9  | bool       | R   | Section 5.8.1.10  |
      | lease_time      | 10 | nfs_lease4 | R   | Section 5.8.1.11  |
      | rdattr_error    | 11 | nfsstat4   | R   | Section 5.8.1.12  |
      | filehandle      | 19 | nfs_fh4    | R   | Section 5.8.1.13  |
      +-----------------+----+------------+-----+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 3: REQUIRED Attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表3：必要な属性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. RECOMMENDED Attributes - List and Definition References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7。推奨属性 - リストと定義参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The RECOMMENDED attributes are defined in Table 4. The meanings of the column headers are the same as Table 3; see Section 5.6 for the meanings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
推奨属性は、列ヘッダーの意味は、表3と同様である。表4に定義されています。意味については、セクション5.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------+----+-----------------+-----+------------------+
   | Name              | ID | Data Type       | Acc | Defined in       |
   +-------------------+----+-----------------+-----+------------------+
   | acl               | 12 | nfsace4&lt;&gt;       | R W | Section 6.2.1    |
   | aclsupport        | 13 | uint32_t        | R   | Section 6.2.1.2  |
   | archive           | 14 | bool            | R W | Section 5.8.2.1  |
   | cansettime        | 15 | bool            | R   | Section 5.8.2.2  |
   | case_insensitive  | 16 | bool            | R   | Section 5.8.2.3  |
   | case_preserving   | 17 | bool            | R   | Section 5.8.2.4  |
   | chown_restricted  | 18 | bool            | R   | Section 5.8.2.5  |
   | fileid            | 20 | uint64_t        | R   | Section 5.8.2.6  |
   | files_avail       | 21 | uint64_t        | R   | Section 5.8.2.7  |
   | files_free        | 22 | uint64_t        | R   | Section 5.8.2.8  |
   | files_total       | 23 | uint64_t        | R   | Section 5.8.2.9  |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | fs_locations      | 24 | fs_locations4   | R   | Section 5.8.2.10 |
   | hidden            | 25 | bool            | R W | Section 5.8.2.11 |
   | homogeneous       | 26 | bool            | R   | Section 5.8.2.12 |
   | maxfilesize       | 27 | uint64_t        | R   | Section 5.8.2.13 |
   | maxlink           | 28 | uint32_t        | R   | Section 5.8.2.14 |
   | maxname           | 29 | uint32_t        | R   | Section 5.8.2.15 |
   | maxread           | 30 | uint64_t        | R   | Section 5.8.2.16 |
   | maxwrite          | 31 | uint64_t        | R   | Section 5.8.2.17 |
   | mimetype          | 32 | ascii_          | R W | Section 5.8.2.18 |
   |                   |    |   REQUIRED4&lt;&gt;   |     |                  |
   | mode              | 33 | mode4           | R W | Section 6.2.2    |
   | mounted_on_fileid | 55 | uint64_t        | R   | Section 5.8.2.19 |
   | no_trunc          | 34 | bool            | R   | Section 5.8.2.20 |
   | numlinks          | 35 | uint32_t        | R   | Section 5.8.2.21 |
   | owner             | 36 | utf8str_mixed   | R W | Section 5.8.2.22 |
   | owner_group       | 37 | utf8str_mixed   | R W | Section 5.8.2.23 |
   | quota_avail_hard  | 38 | uint64_t        | R   | Section 5.8.2.24 |
   | quota_avail_soft  | 39 | uint64_t        | R   | Section 5.8.2.25 |
   | quota_used        | 40 | uint64_t        | R   | Section 5.8.2.26 |
   | rawdev            | 41 | specdata4       | R   | Section 5.8.2.27 |
   | space_avail       | 42 | uint64_t        | R   | Section 5.8.2.28 |
   | space_free        | 43 | uint64_t        | R   | Section 5.8.2.29 |
   | space_total       | 44 | uint64_t        | R   | Section 5.8.2.30 |
   | space_used        | 45 | uint64_t        | R   | Section 5.8.2.31 |
   | system            | 46 | bool            | R W | Section 5.8.2.32 |
   | time_access       | 47 | nfstime4        | R   | Section 5.8.2.33 |
   | time_access_set   | 48 | settime4        | W   | Section 5.8.2.34 |
   | time_backup       | 49 | nfstime4        | R W | Section 5.8.2.35 |
   | time_create       | 50 | nfstime4        | R W | Section 5.8.2.36 |
   | time_delta        | 51 | nfstime4        | R   | Section 5.8.2.37 |
   | time_metadata     | 52 | nfstime4        | R   | Section 5.8.2.38 |
   | time_modify       | 53 | nfstime4        | R   | Section 5.8.2.39 |
   | time_modify_set   | 54 | settime4        | W   | Section 5.8.2.40 |
   +-------------------+----+-----------------+-----+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 4: RECOMMENDED Attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表4：推奨属性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. Attribute Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8。属性定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1. Definitions of REQUIRED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1。必要な属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.1. Attribute 0: supported_attrs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.1。属性0：supported_attrs
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The bit vector that would retrieve all REQUIRED and RECOMMENDED attributes that are supported for this object. The scope of this attribute applies to all objects with a matching fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトでサポートされているすべての必須および推奨の属性を取得しますビットベクトル。この属性の範囲は、一致するFSIDを持つすべてのオブジェクトに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.2. Attribute 1: type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.2。項目1：タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Designates the type of an object in terms of one of a number of special constants:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別な定数のうちの1つの点でオブジェクトの種類を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NF4REG designates a regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NF4REGは、通常のファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NF4DIR designates a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NF4DIRは、ディレクトリを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NF4BLK designates a block device special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NF4BLKはブロックデバイス特殊ファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NF4CHR designates a character device special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NF4CHRはキャラクタデバイス特殊ファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NF4LNK designates a symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NF4LNKは、シンボリックリンクを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NF4SOCK designates a named socket special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NF4SOCKは、名前付きソケット特殊ファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NF4FIFO designates a fifo special file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NF4FIFOは、FIFO特殊ファイルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NF4ATTRDIR designates a named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NF4ATTRDIRは、名前の属性ディレクトリを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NF4NAMEDATTR designates a named attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NF4NAMEDATTRは、名前の属性を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Within the explanatory text and operation descriptions, the following phrases will be used with the meanings given below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
説明文と動作説明の中に、以下の語句を以下に示す意味で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The phrase &#34;is a directory&#34; means that the object&#39;s type attribute is NF4DIR or NF4ATTRDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O句は、オブジェクトのtype属性がNF4DIRまたはNF4ATTRDIRであることを意味し、「ディレクトリです」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The phrase &#34;is a special file&#34; means that the object&#39;s type attribute is NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フレーズは「特別なファイルである」Oオブジェクトのtype属性がNF4BLK、NF4CHR、NF4SOCK、またはNF4FIFOであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The phrase &#34;is a regular file&#34; means that the object&#39;s type attribute is NF4REG or NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フレーズは、「通常のファイルである」Oオブジェクトのtype属性がNF4REGまたはNF4NAMEDATTRであることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The phrase &#34;is a symbolic link&#34; means that the object&#39;s type attribute is NF4LNK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O句は、オブジェクトのtype属性がNF4LNKであることを意味し、「シンボリックリンクです」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.3. Attribute 2: fh_expire_type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.3。項目2：fh_expire_type
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server uses this to specify filehandle expiration behavior to the client. See Section 4 for additional description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、クライアントにファイルハンドルの有効期限の動作を指定するために、これを使用しています。追加の説明については、セクション4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.4. Attribute 3: change
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.4。属性3：変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A value created by the server that the client can use to determine if file data, directory contents, or attributes of the object have been modified. The server MAY return the object&#39;s time_metadata attribute for this attribute&#39;s value but only if the file system object cannot be updated more frequently than the resolution of time_metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、ファイルデータ、ディレクトリの内容、またはオブジェクトの属性が変更されているかどうかを判断するために使用することができ、サーバによって作成された値。サーバーは、この属性の値のオブジェクトのtime_metadata属性を返すかもしれないが、唯一のファイル・システム・オブジェクトがtime_metadataの解像度よりも頻繁に更新することができない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.5. Attribute 4: size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.5。属性4：サイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The size of the object in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト内のオブジェクトのサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.6. Attribute 5: link_support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.6。属性5：link_support
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if the object&#39;s file system supports hard links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE、オブジェクトのファイルシステムはハードリンクをサポートしている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.7. Attribute 6: symlink_support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.7。属性6：symlink_support
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if the object&#39;s file system supports symbolic links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE、オブジェクトのファイルシステムがシンボリックリンクをサポートしている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.8. Attribute 7: named_attr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.8。 7属性：named_attr
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if this object has named attributes. In other words, this object has a non-empty named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE、このオブジェクトが属性を指名した場合。言い換えれば、このオブジェクトは空でない名前の属性ディレクトリを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.9. Attribute 8: fsid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.9。属性8：ブローチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unique file system identifier for the file system holding this object. The fsid attribute has major and minor components, each of which are of data type uint64_t.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトを保持しているファイルシステムのためのユニークなファイルシステム識別子。 FSID属性は、データ・タイプuint64_tをのあるそれぞれの、メジャーとマイナーのコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.10. Attribute 9: unique_handles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.10。属性9：unique_handles
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if two distinct filehandles are guaranteed to refer to two different file system objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE、二つの異なるファイルハンドルが2つの異なるファイル・システム・オブジェクトを参照することが保証されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.11. Attribute 10: lease_time
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.11。属性10：lease_time
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Duration of the lease at the server in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
秒で、サーバーのリース期間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.12. Attribute 11: rdattr_error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.12。属性11：rdattr_error
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Error returned from an attempt to retrieve attributes during a READDIR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エラーがREADDIR操作中に属性を取得しようとする試みから返されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.13. Attribute 19: filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1.13。属性19：ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The filehandle of this object (primarily for READDIR requests).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（主にREADDIR要求のための）このオブジェクトのファイルハンドル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2. Definitions of Uncategorized RECOMMENDED Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2。未分類の定義は属性を推奨しました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The definitions of most of the RECOMMENDED attributes follow. Collections that share a common category are defined in other sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
推奨属性のほとんどの定義は以下の通り。一般的なカテゴリを共有するコレクションは、他のセクションで定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.1. Attribute 14: archive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.1。属性14：アーカイブ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if this file has been archived since the time of the last modification (deprecated in favor of time_backup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このファイルは最終更新時刻以降にアーカイブされている場合はTRUE、（time_backupの非推奨）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.2. Attribute 15: cansettime
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.2。属性15：cansettime
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if the server is able to change the times for a file system object as specified in a SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE、SETATTR操作に指定されているサーバーは、ファイル・システム・オブジェクトのための時間を変更することができる場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.3. Attribute 16: case_insensitive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.3。属性16：CASE_INSENSITIVE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if filename comparisons on this file system are case insensitive. This refers only to comparisons, and not to the case in which filenames are stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE、このファイルシステム上のファイル名の比較は大文字と小文字が区別されます。これは比較にはなく、ファイル名が格納されている場合を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.4. Attribute 17: case_preserving
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.4。属性17：case_preserving
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if the filename case on this file system is preserved. This refers only to how filenames are stored, and not to how they are compared. Filenames stored in mixed case might be compared using either case-insensitive or case-sensitive comparisons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このファイルシステム上のファイル名のケースが保存されている場合、TRUE。これは、ファイル名のみが格納されているどのようにではなく、それらを比較する方法を指します。混合した場合に格納されたファイル名は、大文字と小文字を区別しないか、大文字と小文字を区別比較のいずれかを使用して比較されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.5. Attribute 18: chown_restricted
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.5。属性18：chown_restricted
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If TRUE, the server will reject any request to change either the owner or the group associated with a file if the caller is not a privileged user (for example, &#34;root&#34; in UNIX operating environments or the &#34;Take Ownership&#34; privilege in Windows 2000).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUEの場合、サーバーは、呼び出し側は、UNIXオペレーティング環境では、特権ユーザー（例えば、「ルート」またはWindows 2000での「所有権の取得」の特権ではない場合、所有者やファイルに関連付けられているグループのいずれかを変更するには、すべての要求を拒否します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.6. Attribute 20: fileid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.6。属性20：FILEID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A number uniquely identifying the file within the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一意のファイルシステム内のファイルを識別するための番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.7. Attribute 21: files_avail
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.7。属性21：files_avail
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
File slots available to this user on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトを含むファイルシステム上でこのユーザが利用可能なファイル・スロット - これは最も小さい関連限界であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.8. Attribute 22: files_free
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.8。属性22：files_free
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Free file slots on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトを含むファイルシステム上の無料のファイルスロットは - これは、最小の関連する制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.9. Attribute 23: files_total
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.9。属性23：files_total
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Total file slots on the file system containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトを含むファイルシステム上のファイルの総スロット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.10. Attribute 24: fs_locations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.10。属性24：fs_位置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Locations where this file system may be found. If the server returns NFS4ERR_MOVED as an error, this attribute MUST be supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このファイルシステムが見つけることができる場所。サーバがエラーとしてNFS4ERR_MOVEDを返す場合、この属性をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server specifies the rootpath for a given server by returning a path consisting of zero path components.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、ゼロパス成分からなるパスを返すことによって、特定のサーバのためのROOTPATHを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.11. Attribute 25: hidden
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.11。属性25：隠されました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if the file is considered hidden with respect to the Windows API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE、ファイルがWindows APIに関して隠されたとみなされた場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.12. Attribute 26: homogeneous
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.12。属性26：均質
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if this object&#39;s file system is homogeneous, i.e., all objects in the file system (all objects on the server with the same fsid) have common values for all per-file system attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトのファイルシステムが均一である場合にTRUE、ファイルシステム内、すなわち、すべてのオブジェクト（同じFSIDを持つサーバー上のすべてのオブジェクト）は、すべてのファイルシステムごとの属性のための共通の価値観を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.13. Attribute 27: maxfilesize
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.13。属性27：MAXFILESIZE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Maximum supported file size for the file system of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトのファイルシステムのサポートされる最大ファイルサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.14. Attribute 28: maxlink
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.14。属性28：maxlink
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Maximum number of hard links for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトのためのハードリンクの最大数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.15. Attribute 29: maxname
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.15。属性29：MAXNAME
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Maximum filename size supported for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトに対してサポートされる最大ファイル名のサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.16. Attribute 30: maxread
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.16。属性30：maxread
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Maximum amount of data the READ operation will return for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データの最大量は、READ操作は、このオブジェクトのために返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.17. Attribute 31: maxwrite
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.17。属性31：maxwrite
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Maximum amount of data the WRITE operation will accept for this object. This attribute SHOULD be supported if the file is writable. Lack of this attribute can lead to the client either wasting bandwidth or not receiving the best performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データの最大量は、WRITE操作は、このオブジェクトのために受け入れます。ファイルが書き込み可能である場合、この属性はサポートされる必要があります。この属性の欠如は、いずれかの帯域幅を浪費や最高のパフォーマンスを受けていないクライアントにつながることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.18. Attribute 32: mimetype
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.18。属性32：MIMEタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MIME media type/subtype of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトのMIMEメディアタイプ/サブタイプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.19. Attribute 55: mounted_on_fileid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.19。属性55：mounted_on_fileid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Like fileid, but if the target filehandle is the root of a file system, this attribute represents the fileid of the underlying directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
対象のファイルハンドルは、ファイルシステムのルートである場合FILEID似ていますが、この属性は、基礎となるディレクトリのFILEIDを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNIX-based operating environments connect a file system into the namespace by connecting (mounting) the file system onto the existing file object (the mount point, usually a directory) of an existing file system. When the mount point&#39;s parent directory is read via an API such as readdir() [readdir_api], the return results are directory entries, each with a component name and a fileid. The fileid of the mount point&#39;s directory entry will be different from the fileid that the stat() [stat] system call returns. The stat() system call is returning the fileid of the root of the mounted file system, whereas readdir() is returning the fileid that stat() would have returned before any file systems were mounted on the mount point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNIXベースのオペレーティング環境は、既存のファイルシステムの既存のファイル・オブジェクト（マウントポイント、通常はディレクトリ）に（実装に）ファイル・システムを接続することによって、名前空間内のファイル・システムを接続します。マウントポイントの親ディレクトリは、READDIR（AS APIを介して読み出される場合）readdir_api]、戻り結果は、ディレクトリエントリ、コンポーネント名とFILEID各あります。マウントポイントのディレクトリエントリのFILEIDはFILEID STAT（）[STAT]システムコールの戻りは異なるであろう。 STAT（readdirのに対し、（）システムコール）が、マウントされたファイルシステムのルートのFILEIDを返すには、すべてのファイルシステムをマウントポイントにマウントされた前のstat（）が戻ってきたでしょうFILEIDを返しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unlike NFSv3, NFSv4.0 allows a client&#39;s LOOKUP request to cross other file systems. The client detects the file system crossing whenever the filehandle argument of LOOKUP has an fsid attribute different from that of the filehandle returned by LOOKUP. A UNIX-based client will consider this a &#34;mount point crossing&#34;. UNIX has a legacy scheme for allowing a process to determine its current working directory. This relies on readdir() of a mount point&#39;s parent and stat() of the mount point returning fileids as previously described. The mounted_on_fileid attribute corresponds to the fileid that readdir() would have returned, as described previously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv3のとは異なり、NFSv4.0は、クライアントのLOOKUP要求は他のファイルシステムを横断することができます。 LOOKUPのファイルハンドル引数はFSIDを持っている時はいつでも、クライアントは、ファイル・システムの交差を検出しLOOKUPで返されるファイルハンドルとは異なる属性。 UNIXベースのクライアントは、この「マウントポイントの交差点」を検討します。 UNIXは、現在の作業ディレクトリを決定するためのプロセスを可能にするための従来の方式を採用しています。先に述べたように、これはfileidsを返すマウントポイントのマウントポイントの親とのstat（）ののreaddir（）に依存しています。 mounted_on_fileid属性は、前述のように（）、返されるはずREADDIR FILEIDに相当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the NFSv4.0 client could simply fabricate a fileid corresponding to what mounted_on_fileid provides (and if the server does not support mounted_on_fileid, the client has no choice), there is a risk that the client will generate a fileid that conflicts with one that is already assigned to another object in the file system. Instead, if the server can provide the mounted_on_fileid, the potential for client operational problems in this area is eliminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.0のクライアントは、単に提供（およびサーバがmounted_on_fileidをサポートしていない場合、クライアントは選択の余地がありません）何mounted_on_fileidに対応FILEIDを作ることもできますが、クライアントである1と競合FILEIDを発生するおそれがありますすでにファイルシステム内の別のオブジェクトに割り当てられています。サーバがmounted_on_fileidを提供できるかどう代わりに、この分野でのクライアントの動作上の問題の可能性が排除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server detects that there is nothing mounted on top of the target file object, then the value for mounted_on_fileid that it returns is the same as that of the fileid attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、対象ファイルのオブジェクトの上に取り付けられたものがないことを検出した場合、それが返すことmounted_on_fileidの値がFILEID属性と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The mounted_on_fileid attribute is RECOMMENDED, so the server SHOULD provide it if possible, and for a UNIX-based server, this is straightforward. Usually, mounted_on_fileid will be requested during a READDIR operation, in which case it is trivial (at least for UNIX-based servers) to return mounted_on_fileid since it is equal to the fileid of a directory entry returned by readdir(). If mounted_on_fileid is requested in a GETATTR operation, the server should obey an invariant that has it returning a value that is equal to the file object&#39;s entry in the object&#39;s parent directory, i.e., what readdir() would have returned. Some operating environments allow a series of two or more file systems to be mounted onto a single mount point. In this case, for the server to obey the aforementioned invariant, it will need to find the base mount point, and not the intermediate mount points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
mounted_on_fileid属性が推奨されているので、可能な場合、サーバはそれを提供すべきである、とUNIXベースのサーバーのために、これは簡単です。それがREADDIR（で返されるディレクトリエントリのFILEIDに等しいので、通常、mounted_on_fileid）がmounted_on_fileidを返すために（少なくともUNIXベースのサーバーのために）それは簡単です、その場合には、READDIR操作中に要求されます。 mounted_on_fileidがGETATTR操作で要求された場合、サーバはそれがすなわち、何のreaddir（）戻っているだろう、オブジェクトの親ディレクトリ内のファイルオブジェクトのエントリに等しい値を返す持つ不変に従わなければなりません。いくつかの動作環境は、二つ以上のファイル・システムのシリーズは、単一のマウントポイントにマウントすることができます。この場合は、サーバーのための前述の不変に従うように、それがベースマウントポイントを見つける必要があるでしょうし、中間ではないマウントポイントを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.20. Attribute 34: no_trunc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.20。属性34：no_trunc
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If this attribute is TRUE, then if the client uses a filename longer than name_max, an error will be returned instead of the name being truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この属性がTRUEの場合、クライアントがNAME_MAXよりも長いファイル名を使用している場合、その後、エラーが切り捨てられ名の代わりに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.21. Attribute 35: numlinks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.21。属性35：numlinks
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Number of hard links to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトへのハードリンクの数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.22. Attribute 36: owner
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.22。属性36：オーナー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The string name of the owner of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトの所有者の文字列名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.23. Attribute 37: owner_group
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.23。 37属性：owner_group
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The string name of the group ownership of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトのグループ所有権の文字列名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.24. Attribute 38: quota_avail_hard
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.24。属性38：quota_avail_hard
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The value in bytes that represents the amount of additional disk space beyond the current allocation that can be allocated to this file or directory before further allocations will be refused. It is understood that this space may be consumed by allocations to other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに配分する前に、このファイルまたはディレクトリに割り当てることができ、現在の割り当てを超える追加のディスク・スペースの量を表し、バイト単位の値が拒否されます。このスペースは、他のファイルまたはディレクトリへの割り当てによって消費されてもよいことが理解されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.25. Attribute 39: quota_avail_soft
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.25。属性39：quota_avail_soft
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The value in bytes that represents the amount of additional disk space that can be allocated to this file or directory before the user may reasonably be warned. It is understood that this space may be consumed by allocations to other files or directories, though there may exist server-side rules as to which other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザー前にこのファイルまたはディレクトリに割り当てることができ、追加のディスク・スペースの量を表しバイト単位の値が合理的に警告されることがあります。他のどのファイルまたはディレクトリに、サーバ側のルールが存在するかもしれないが、この空間は、他のファイルまたはディレクトリへの割り当てによって消費されてもよいことが理解されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.26. Attribute 40: quota_used
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.26。属性40：QUOTA_USED
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The value in bytes that represents the amount of disk space used by this file or directory and possibly a number of other similar files or directories, where the set of &#34;similar&#34; meets at least the criterion that allocating space to any file or directory in the set will reduce the &#34;quota_avail_hard&#34; of every other file or directory in the set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「類似」のセットは、少なくとも基準を満たす可能性がこのファイルまたはディレクトリおよび他の類似のファイルまたはディレクトリの数によって使用されるディスク・スペースの量を表すバイトの値その中の任意のファイルやディレクトリにスペースを割り当てますセットは、セット内の他のすべてのファイルやディレクトリの「quota_avail_hard」を削減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that there may be a number of distinct but overlapping sets of files or directories for which a quota_used value is maintained, e.g., &#34;all files with a given owner&#34;, &#34;all files with a given group owner&#34;, etc. The server is at liberty to choose any of those sets when providing the content of the quota_used attribute but should do so in a repeatable way. The rule may be configured per file system or may be &#34;choose the set with the smallest quota&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは例えば、「特定の所有者を持つすべてのファイル」、「与えられたグループの所有者であるすべてのファイル」など、QUOTA_USED値が維持されているファイルやディレクトリの異なるが重なり合うセットの数があるかもしれないことに注意してくださいQUOTA_USED属性のコンテンツを提供するが、繰り返し可能な方法で行う必要があるときに自由にそれらのセットのいずれかを選択します。ルールは、ファイルシステムごとに設定してもよいし、「最小のクォータでセットを選択」であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.27. Attribute 41: rawdev
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.27。 41属性：rawdev
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Raw device number of file of type NF4BLK or NF4CHR. The device number is split into major and minor numbers. If the file&#39;s type attribute is not NF4BLK or NF4CHR, this attribute SHOULD NOT be returned, and any value returned SHOULD NOT be considered useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイプNF4BLKまたはNF4CHRのファイルの生のデバイス番号。デバイス番号は、メジャーとマイナー番号に分割されます。ファイルのtype属性がNF4BLKかNF4CHRされていない場合は、この属性が返されるべきではない、と返された値が有用であるとみなされるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.28. Attribute 42: space_avail
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.28。属性42：space_avail
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Disk space in bytes available to this user on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、最小の関連限界であるべき - このオブジェクトを含むファイルシステム上でこのユーザーに利用可能なバイト単位のディスク容量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.29. Attribute 43: space_free
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.29。属性43：space_free
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Free disk space in bytes on the file system containing this object -- this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、最小の関連限界であるべき - このオブジェクトを含むファイルシステム上のバイト単位でのディスク空き容量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.30. Attribute 44: space_total
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.30。属性44：space_total
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Total disk space in bytes on the file system containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトを含むファイルシステム上のバイト単位での総ディスク容量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.31. Attribute 45: space_used
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.31。 45属性：space_used
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Number of file system bytes allocated to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオブジェクトに割り当てられたファイルシステムのバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.32. Attribute 46: system
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.32。属性46：システム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE, if this file is a &#34;system&#34; file with respect to the Windows operating environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUE、このファイルは、Windowsオペレーティング環境に関して「システム」ファイルである場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.33. Attribute 47: time_access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.33。属性47：time_access
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Represents the time of last access to the object by a READ operation sent to the server. The notion of what is an &#34;access&#34; depends on the server&#39;s operating environment and/or the server&#39;s file system semantics. For example, for servers obeying Portable Operating System Interface (POSIX) semantics, time_access would be updated only by the READ and READDIR operations and not any of the operations that modify the content of the object [read_api], [readdir_api], [write_api]. Of course, setting the corresponding time_access_set attribute is another way to modify the time_access attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーに送信されたREAD操作によってオブジェクトへの最後のアクセスの時間を表します。 「アクセス」であるものの概念は、サーバの動作環境および/またはサーバのファイルシステムのセマンティクスに依存します。例えば、ポータブルオペレーティングシステムインタフェース（POSIX）のセマンティクスに従うサーバに対して、time_accessは、オブジェクトの内容を変更する操作のいずれかのみREADとREADDIR操作によって更新されないであろう[read_api]、[readdir_api]、[write_api] 。もちろん、対応するtime_access_set属性を設定することtime_access属性を変更する別の方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever the file object resides on a writable file system, the server should make its best efforts to record time_access into stable storage. However, to mitigate the performance effects of doing so, and most especially whenever the server is satisfying the read of the object&#39;s content from its cache, the server MAY cache access time updates and lazily write them to stable storage. It is also acceptable to give administrators of the server the option to disable time_access updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルオブジェクトが、書き込み可能なファイルシステム上に存在するたびに、サーバーは安定したストレージにtime_accessを記録するために最善の努力をする必要があります。しかし、そうすることのパフォーマンスへの影響を軽減するために、最も特に、サーバーがそのキャッシュからオブジェクトの内容の読み取りを満足されるたびに、サーバーは、アクセス時間の更新をキャッシュして、怠惰安定したストレージにそれらを書き込むことができます。サーバーの管理者はtime_access更新を無効にするオプションを与えることも可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.34. Attribute 48: time_access_set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.34。属性48：time_access_set
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sets the time of last access to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクトへの最後のアクセスの時間を設定します。 SETATTRにのみ使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.35. Attribute 49: time_backup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.35。属性49：time_backup
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The time of last backup of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクトの最後のバックアップの時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.36. Attribute 50: time_create
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.36。属性50：time_create
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The time of creation of the object. This attribute does not have any relation to the traditional UNIX file attribute &#34;ctime&#34; (&#34;change time&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクトの作成の時間。この属性は、従来のUNIXファイル属性「CTIME」（「変更時間」）に何らかの関係を持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.37. Attribute 51: time_delta
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.37。属性51：TIME_DELTA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Smallest useful server time granularity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最小の便利なサーバーの時間精度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.38. Attribute 52: time_metadata
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.38。属性52：time_metadata
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The time of last metadata modification of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクトの最後のメタデータの変更の時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.39. Attribute 53: time_modify
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.39。属性53：time_modify
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The time of last modification to the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクトへの最終更新時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.40. Attribute 54: time_modify_set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2.40。属性54：time_modify_set
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sets the time of last modification to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクトの最終更新時刻を設定します。 SETATTRにのみ使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9. Interpreting owner and owner_group
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9。解釈の所有者とowner_group
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The RECOMMENDED attributes &#34;owner&#34; and &#34;owner_group&#34; (and also users and groups used as values of the who field within nfs4ace structures used in the acl attribute) are represented in the form of UTF-8 strings. This format avoids the use of a representation that is tied to a particular underlying implementation at the client or server. Note that Section 6.1 of [RFC2624] provides additional rationale. It is expected that the client and server will have their own local representation of owners and groups that is used for local storage or presentation to the application via APIs that expect such a representation. Therefore, the protocol requires that when these attributes are transferred between the client and server, the local representation is translated to a string of the form &#34;identifier@dns_domain&#34;. This allows clients and servers that do not use the same local representation to effectively interoperate since they both use a common syntax that can be interpreted by both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
推奨属性の「所有者」と「owner_group」（ACL属性で使用nfs4ace構造内誰のフィールドの値として使用しても、ユーザーとグループ）は、UTF-8文字列の形式で表現されています。このフォーマットは、クライアントまたはサーバで特定の基本的な実装に結び付けられている表現の使用を回避します。 [RFC2624]の6.1節に注意してください追加の理論的根拠を提供します。クライアントとサーバは、このような表現を期待するAPIを介してアプリケーションをローカルストレージやプレゼンテーションのために使用されている所有者およびグループの独自のローカルな表現を持っていることが期待されます。したがって、プロトコルは、これらの属性は、クライアントとサーバーの間で転送されたときに、地元の表現はフォーム「識別子の@ dns_domain」の文字列に変換されている必要があります。これは、彼らの両方が解釈できる共通の構文を使用しますので、効果的に相互運用するために、同じローカルな表現を使用していないクライアントとサーバーを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Similarly, security principals may be represented in different ways by different security mechanisms. Servers normally translate these representations into a common format, generally that used by local storage, to serve as a means of identifying the users corresponding to these security principals. When these local identifiers are translated to the form of the owner attribute, associated with files created by such principals, they identify, in a common format, the users associated with each corresponding set of security principals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、セキュリティプリンシパルは、異なるセキュリティメカニズムにより異なる方法で表すことができます。サーバは、通常、これらのセキュリティプリンシパルに対応するユーザを識別する手段として機能するように、ローカル記憶装置によって使用される一般的こと、共通の形式にこれらの表現を翻訳します。これらのローカル識別子は、所有者属性の形式に変換されている場合は、そのようなプリンシパルで作成されたファイルに関連付けられている、彼らは、共通のフォーマットで、セキュリティプリンシパルの各対応するセットに関連付けられているユーザを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The translation used to interpret owner and group strings is not specified as part of the protocol. This allows various solutions to be employed. For example, a local translation table may be consulted that maps a numeric identifier to the user@dns_domain syntax. A name service may also be used to accomplish the translation. A server may provide a more general service, not limited by any particular translation (which would only translate a limited set of possible strings) by storing the owner and owner_group attributes in local storage without any translation, or it may augment a translation method by storing the entire string for attributes for which no translation is available while using the local representation for those cases in which a translation is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
所有者とグループの文字列を解釈するために使用される変換は、プロトコルの一部として指定されていません。これは、様々なソリューションを採用することができるようになります。たとえば、ローカルの変換テーブルはdns_domain構文@ユーザーに数値識別子をマップする参考にすることができます。ネームサービスは、翻訳を達成するために使用することができます。サーバは、所有者とowner_group、変換されずに、ローカルストレージの属性を格納することによって（唯一の可能な文字列の限られたセットを翻訳するであろう）は、任意の特定の翻訳によって限定されるものではなく、より一般的なサービスを提供することができる、又はそれは格納することにより、翻訳方法を増強することができます翻訳が利用可能であるこれらの例のためのローカルな表現を使用しながら、何の翻訳が利用できないために属性の文字列全体。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers that do not provide support for all possible values of user and group strings SHOULD return an error (NFS4ERR_BADOWNER) when a string is presented that has no translation, as the value to be set for a SETATTR of the owner or owner_group attributes or as part of the value of the acl attribute. When a server does accept a user or group string as valid on a SETATTR, it is promising to return that same string (see below) when a corresponding GETATTR is done, as long as there has been no further change in the corresponding attribute before the GETATTR. For some internationalization-related exceptions where this is not possible, see below. Configuration changes (including changes from the mapping of the string to the local representation) and ill-constructed name translations (those that contain aliasing) may make that promise impossible to honor. Servers should make appropriate efforts to avoid a situation in which these attributes have their values changed when no real change to either ownership or acls has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文字列が提示されたときに、ユーザーやグループの文字列のすべての可能な値のためのサポートを提供していないサーバは、値は所有者またはowner_group属性のSETATTRまたは一部として設定されるように、何の翻訳を持っていないというエラー（NFS4ERR_BADOWNER）を返すべきですACL属性の値の。サーバはSETATTR上の有効なユーザーまたはグループの文字列を受け入れない場合には前に、対応する属性にはさらなる変化がなかったとして、対応するGETATTRが行われたときに限り、（下記参照）は、同じ文字列を返すように約束していますGETATTR。これが不可能ないくつかの国際化関連の例外については、以下を参照してください。悪い構築名翻訳（エイリアシングを含むもの）（ローカル表現への文字列のマッピングからの変更を含む）設定の変更は尊重するという約束を不可能にすることがあります。サーバは、これらの属性は、所有権またはACLのいずれかに本当の変化が発生していないとき、その値が変更されていた状況を回避するための適切な努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;dns_domain&#34; portion of the owner string is meant to be a DNS domain name -- for example, &#34;user@example.org&#34;. Servers should accept as valid a set of users for at least one domain. A server may treat other domains as having no valid translations. A more general service is provided when a server is capable of accepting users for multiple domains, or for all domains, subject to security constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、「user@example.org」 - 所有者文字列の「dns_domain」の部分は、DNSドメイン名であることを意味しています。サーバーは、少なくとも1つのドメインに対するユーザーの有効なセットを受け入れる必要があります。サーバーは、有効な翻訳を持っていないとして、他のドメインを扱うことがあります。サーバが複数のドメインのために、またはセキュリティ制約の対象となるすべてのドメインのユーザを受け入れることができる場合に、より一般的なサービスが提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As an implementation guide, both clients and servers may provide a means to configure the &#34;dns_domain&#34; portion of the owner string. For example, the DNS domain name of the host running the NFS server might be &#34;lab.example.org&#34;, but the user names are defined in &#34;example.org&#34;. In the absence of such a configuration, or as a default, the current DNS domain name of the server should be the value used for the &#34;dns_domain&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装ガイドとして、クライアントとサーバの両方が、所有者列の「dns_domain」部分を構成するための手段を提供することができます。たとえば、NFSサーバを実行しているホストのDNSドメイン名は「lab.example.org」かもしれませんが、ユーザー名が「example.org」で定義されています。このような構成がない場合、またはデフォルトとして、サーバーの現在のDNSドメイン名は「dns_domain」のために使用される値でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As mentioned above, it is desirable that a server, when accepting a string of the form &#34;user@domain&#34; or &#34;group@domain&#34; in an attribute, return this same string when that corresponding attribute is fetched. Internationalization issues make this impossible under certain circumstances, and the client needs to take note of these. See Section 12 for a detailed discussion of these issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上述したように、その対応する属性を取得するときに、この同じ文字列を返し、属性内のサーバ、フォームの文字列を受け付ける「ユーザ@ドメイン」又は「グループ@ドメイン」ことが望ましいです。国際化の問題は、特定の状況下で、この不可能を行い、クライアントはこれらのノートを取る必要があります。これらの問題の詳細な議論については、セクション12を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case where there is no translation available to the client or server, the attribute value will be constructed without the &#34;@&#34;. Therefore, the absence of the &#34;@&#34; from the owner or owner_group attribute signifies that no translation was available at the sender and that the receiver of the attribute should not use that string as a basis for translation into its own internal format. Even though the attribute value cannot be translated, it may still be useful. In the case of a client, the attribute string may be used for local display of ownership.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントまたはサーバに利用可能な翻訳が存在しない場合には、属性値は「@」なしで構成されます。したがって、所有者またはowner_group属性から「@」の不在は何の翻訳は、送信側で属性の受信機は、独自の内部形式に変換するための基礎として、その文字列を使用してはならないことを利用できなかったことを意味します。属性値が変換できないにもかかわらず、それはまだ有用である可能性があります。クライアントの場合、属性文字列は、所有権のローカル・ディスプレイのために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To provide a greater degree of compatibility with NFSv3, which identified users and groups by 32-bit unsigned user identifiers and group identifiers, owner and group strings that consist of ASCII-encoded decimal numeric values with no leading zeros can be given a special interpretation by clients and servers that choose to provide such support. The receiver may treat such a user or group string as representing the same user as would be represented by an NFSv3 uid or gid having the corresponding numeric value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別な解釈によって与えられるない先行ゼロでASCIIエンコード進数値から成る32ビットの符号なしのユーザ識別子とグループ識別子、所有者およびグループ列によってユーザおよびグループを同定NFSv3の、との互換性のより大きな程度を提供しますそのようなサポートを提供することを選択したクライアントとサーバ。受信機は、NFSv3のUIDのまたは対応する数値を有するGIDによって表されるであろうと同じユーザを表すようなユーザまたはグループ列を扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server SHOULD reject such a numeric value if the security mechanism is using Kerberos. That is, in such a scenario, the client will already need to form &#34;user@domain&#34; strings. For any other security mechanism, the server SHOULD accept such numeric values. As an implementation note, the server could make such an acceptance be configurable. If the server does not support numeric values or if it is configured off, then it MUST return an NFS4ERR_BADOWNER error. If the security mechanism is using Kerberos and the client attempts to use the special form, then the server SHOULD return an NFS4ERR_BADOWNER error when there is a valid translation for the user or owner designated in this way. In that case, the client must use the appropriate user@domain string and not the special form for compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティメカニズムがKerberosを使用している場合、サーバーは、このような数値を拒否すべきです。すなわち、このようなシナリオでは、クライアントがすでに「ユーザー@ドメイン」の文字列を形成する必要がありますされています。他のセキュリティ・メカニズムでは、サーバーは、このような数値を受け入れる必要があります。実装の注意点として、サーバは、そのような受け入れが設定可能で作ることができます。サーバは、数値をサポートしていない場合、またはそれがオフに設定されている場合、それはNFS4ERR_BADOWNERエラーを返さなければなりません。セキュリティメカニズムがKerberosを使用していると、クライアントは特別なフォームを使用しようとすると、このように指定されたユーザまたは所有者の有効な翻訳がある場合に、サーバはNFS4ERR_BADOWNERエラーを返すべきです。その場合、クライアントは適切なユーザ@ドメイン文字列ではなく、互換性のための特別なフォームを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client MUST always accept numeric values if the security mechanism is not RPCSEC_GSS. A client can determine if a server supports numeric identifiers by first attempting to provide a numeric identifier. If this attempt is rejected with an NFS4ERR_BADOWNER error, then the client should only use named identifiers of the form &#34;user@dns_domain&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティメカニズムがRPCSEC_GSSでない場合、クライアントは常に数値を受け入れなければなりません。サーバーは、最初の数値識別子を提供しようとすることにより、数値識別子をサポートする場合、クライアントが決定することができます。この試みは、NFS4ERR_BADOWNERエラーで拒否された場合、クライアントは専用フォーム「のuser @ dns_domain」の名前の識別子を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The owner string &#34;nobody&#34; may be used to designate an anonymous user, which will be associated with a file created by a security principal that cannot be mapped through normal means to the owner attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
所有者列「誰が」所有者属性に通常の手段を介してマッピングすることができないセキュリティプリンシパルによって作成されたファイルに関連付けられる匿名ユーザを指定するために使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.10. Character Case Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.10。キャラクターケースの属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With respect to the case_insensitive and case_preserving attributes, case-insensitive comparisons of Unicode characters SHOULD use Unicode Default Case Folding as defined in Chapter 3 of the Unicode Standard [UNICODE] and MAY override that behavior for specific selected characters with the case folding defined in the SpecialCasing.txt [SPECIALCASING] file; see Section 3.13 of the Unicode Standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CASE_INSENSITIVEとcase_preserving属性に関しては、Unicode文字の大文字と小文字を区別しない比較はで定義された折りたたみUnicode標準[UNICODE]の第3章で定義された折りたたみUnicodeのデフォルトのケースを使用する必要があり、場合と、特定の選択された文字のためにその動作を無効にすることができますSpecialCasing.txt [SPECIALCASING]ファイル。 Unicode標準のセクション3.13を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SpecialCasing.txt file replaces the Default Case Folding with locale- and context-dependent case folding for specific situations. An example of locale- and context-dependent case folding is that LATIN CAPITAL LETTER I (&#34;I&#34;, U+0049) is default case folded to LATIN SMALL LETTER I (&#34;i&#34;, U+0069). However, several languages (e.g., Turkish) treat an &#34;I&#34; character with a dot as a different letter than an &#34;I&#34; character without a dot; therefore, in such languages, unless an I is before a dot_above, the &#34;I&#34; (U+0049) character should be case folded to a different character, LATIN SMALL LETTER DOTLESS I (U+0131).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SpecialCasing.txtファイルには、特定の状況のた​​めに折りたたみロケールとコンテキスト依存の場合と折りたたみデフォルトのケースを置き換えます。ロケールと文脈依存ケース折りたたみの例は、ラテン大文字I（ &#34;I&#34;、0049 U +）はLATIN SMALL LETTERに折り畳まれ、デフォルトケースがあるということであるI（ &#34;I&#34;、U + 0069）。しかし、いくつかの言語（例えば、トルコ語）ドットのない「I」の文字とは異なる文字としてドットと「I」の文字を扱います。私はdot_above前でなければ従って、そのような言語では、「I」（U + 0049）文字は、異なる文字、ラテン小文字DOTLESS I（U + 0131）に折り畳まれた場合であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The [UNICODE] and [SPECIALCASING] references in this RFC are for version 7.0.0 of the Unicode standard, as that was the latest version of Unicode when this RFC was published. Implementations SHOULD always use the latest version of Unicode (&lt;http://www.unicode.org/versions/latest/&gt;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、このRFCが発行された最新バージョンのUnicodeだったとして、このRFCで[UNICODE]および[SPECIALCASING]参照は、Unicode標準のバージョン7.0.0のためのものです。実装は常にUnicode（&lt;http://www.unicode.org/versions/latest/&gt;）の最新バージョンを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Access Control Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.アクセス制御属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Access Control Lists (ACLs) are file attributes that specify fine-grained access control. This section covers the &#34;acl&#34;, &#34;aclsupport&#34;, and &#34;mode&#34; file attributes, and their interactions. Note that file attributes may apply to any file system object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アクセス制御リスト（ACL）ファイルは、それがファイングレイン・アクセス・コントロールを指定する属性です。このセクションでは、「のacl」、「aclsupport」、および「モード」のファイル属性、およびそれらの相互作用をカバーしています。ファイル属性は、任意のファイル・システム・オブジェクトに適用することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACLs and modes represent two well-established models for specifying permissions. This section specifies requirements that attempt to meet the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACLとモードは、パーミッションを指定するための2つのよく確立したモデルを表しています。このセクションでは、次の目標を達成しようとする要件を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If a server supports the mode attribute, it should provide reasonable semantics to clients that only set and retrieve the mode attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、mode属性をサポートしている場合は、O、それだけでモード属性を設定して検索するクライアントに合理的なセマンティクスを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If a server supports ACL attributes, it should provide reasonable semantics to clients that only set and retrieve those attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはACL属性をサポートしている場合は、O、それだけで設定し、それらの属性を取得し、クライアントへの合理的なセマンティクスを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o On servers that support the mode attribute, if ACL attributes have never been set on an object, via inheritance or explicitly, the behavior should be traditional UNIX-like behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACL属性は継承を介して、または明示的に、オブジェクトに設定されていなかった場合は、Oモード属性をサポートするサーバーでは、挙動は、従来のUNIXのような振る舞いである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o On servers that support the mode attribute, if the ACL attributes have been previously set on an object, either explicitly or via inheritance:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O ACL属性は以前に明示的または継承を経由して、オブジェクトに設定されている場合は、mode属性をサポートしているサーバーの場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Setting only the mode attribute should effectively control the traditional UNIX-like permissions of read, write, and execute on owner, owner_group, and other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*専用モード属性は効果的に、読み取りの伝統的なUNIXライクなアクセス許可を制御し、書き込み、および所有者、owner_group、および他の上で実行する必要があり設定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Setting only the mode attribute should provide reasonable security. For example, setting a mode of 000 should be enough to ensure that future opens for read or write by any principal fail, regardless of a previously existing or inherited ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*専用モード属性を設定すると、合理的なセキュリティを提供する必要があります。例えば、000のモードを設定することにかかわらず、既存の、または継承されたACLの、失敗その将来が読み取りのために開く保証または任意のプリンシパルによって書き込みするのに十分であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When a mode attribute is set on an object, the ACL attributes may need to be modified so as to not conflict with the new mode. In such cases, it is desirable that the ACL keep as much information as possible. This includes information about inheritance, AUDIT and ALARM access control entries (ACEs), and permissions granted and denied that do not conflict with the new mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モード属性がオブジェクトに設定されている場合、新しいモードと競合しないようにO、ACL属性を変更する必要があります。このような場合には、ACLは、できるだけ多くの情報を保持することが望ましいです。これは、継承、AUDITとALARMアクセス制御エントリ（ACE）に関する情報が含まれており、アクセス権が付与され、新しいモードと競合しないことを否定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. File Attributes Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。ファイルには、ディスカッションを属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Support for each of the ACL attributes is RECOMMENDED and not required, since file systems accessed using NFSv4 might not support ACLs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムは、NFSv4のACLをサポートしていない可能性がありますので、使用してアクセスACL属性ごとのサポートは、推奨されていないが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. Attribute 12: acl
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1。属性12：ACL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4.0 ACL attribute contains an array of ACEs that are associated with the file system object. Although the client can read and write the acl attribute, the server is responsible for using the ACL to perform access control. The client can use the OPEN or ACCESS operations to check access without modifying or reading data or metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.0 ACL属性は、ファイル・システム・オブジェクトに関連付けられているACEのアレイを含みます。クライアントがACL属性を読み書きすることができますが、サーバーは、アクセス制御を実行するためにACLを使用する責任があります。クライアントは、データまたはメタデータを変更するか、読まずにアクセスをチェックするためにOPENまたはアクセス操作を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFS ACE structure is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにNFS ACE構造が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef uint32_t acetype4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefでのuint32_t acetype4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef uint32_t aceflag4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefでのuint32_t aceflag4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef uint32_t acemask4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefでのuint32_t acemask4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfsace4 {
           acetype4                type;
           aceflag4                flag;
           acemask4                access_mask;
           utf8str_mixed           who;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To determine if a request succeeds, the server processes each nfsace4 entry in order. Only ACEs that have a &#34;who&#34; that matches the requester are considered. Each ACE is processed until all of the bits of the requester&#39;s access have been ALLOWED. Once a bit (see below) has been ALLOWED by an ACCESS_ALLOWED_ACE, it is no longer considered in the processing of later ACEs. If an ACCESS_DENIED_ACE is encountered where the requester&#39;s access still has unALLOWED bits in common with the &#34;access_mask&#34; of the ACE, the request is denied. When the ACL is fully processed, if there are bits in the requester&#39;s mask that have not been ALLOWED or DENIED, access is denied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストが成功したかどうかを判断するには、サーバは順序で各nfsace4エントリを処理します。依頼者と一致した「」持っている唯一のACEが考慮されます。依頼者のアクセスのビットのすべてが許可されるまで、各ACEが処理されます。ビットが（下記参照）ACCESS_ALLOWED_ACEによって許可された後、それはもはや後のACEの処理において考慮されません。 ACCESS_DENIED_ACEが発生した場合は、要求者のアクセスはまだACEの「access_mask」と共通の許可されていないビットを有する場合、要求は拒否されます。 ACLが完全に処理されると許可または拒否されていない依頼者のマスクのビットがある場合は、アクセスが拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unlike the ALLOW and DENY ACE types, the ALARM and AUDIT ACE types do not affect a requester&#39;s access and instead are for triggering events as a result of a requester&#39;s access attempt. Therefore, AUDIT and ALARM ACEs are processed only after processing ALLOW and DENY ACEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
許可し、DENY ACEタイプとは異なり、ALARMおよびAUDIT ACEタイプは、要求者のアクセスには影響しません、代わりに要求者のアクセス試行の結果としてイベントをトリガするためのものです。したがって、AUDITとALARMのACEのみACEを可能にし、DENY処理した後に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4.0 ACL model is quite rich. Some server platforms may provide access control functionality that goes beyond the UNIX-style mode attribute but that is not as rich as the NFS ACL model. So that users can take advantage of this more limited functionality, the server may support the acl attributes by mapping between its ACL model and the NFSv4.0 ACL model. Servers must ensure that the ACL they actually store or enforce is at least as strict as the NFSv4 ACL that was set. It is tempting to accomplish this by rejecting any ACL that falls outside the small set that can be represented accurately. However, such an approach can render ACLs unusable without special client-side knowledge of the server&#39;s mapping, which defeats the purpose of having a common NFSv4 ACL protocol. Therefore, servers should accept every ACL that they can without compromising security. To help accomplish this, servers may make a special exception, in the case of unsupported permission bits, to the rule that bits not ALLOWED or DENIED by an ACL must be denied. For example, a UNIX-style server might choose to silently allow read attribute permissions even though an ACL does not explicitly allow those permissions. (An ACL that explicitly denies permission to read attributes should still result in a denial.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.0 ACLモデルは非常に豊富です。一部のサーバー・プラットフォームは、UNIXスタイルのmode属性を超えたが、それは、NFS ACLモデルほど豊富ではない、アクセス制御機能を提供することができます。ユーザーはこのより限定された機能を利用することができるように、サーバーは、そのACLモデルとNFSv4.0 ACLモデルとの間のマッピングにより、ACL属性をサポートすることができます。サーバーは、彼らが実際に格納したり、強制ACLが設定されたのNFSv4 ACLと少なくとも同程度に厳格であることを確認する必要があります。正確に表現することができる小さなセットから外れる任意のACLを拒否することによって、これを達成するために魅力的です。しかし、このようなアプローチは、共通のNFSv4 ACLプロトコルを持つことの目的に反し、サーバーのマッピング、の特別なクライアント側の知識がなくてもACLが使用不能になることができます。そのため、サーバは、セキュリティを損なうことなく、その彼らができるすべてのACLを受け入れる必要があります。これを実現しやすくするために、サーバが拒否しなければならないACLによって許可または拒否されていないビットルールに、サポートされていない許可ビットの場合には、特別な例外を行うことができます。たとえば、UNIX形式のサーバーは、ACLが明示的にこれらの権限を許可していないにもかかわらず、読み属性の権限を静かに許可することを選択するかもしれません。 （明示的に属性を読み取るためのアクセス許可を拒否するACLはまだ拒否が発生する必要があります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The situation is complicated by the fact that a server may have multiple modules that enforce ACLs. For example, the enforcement for NFSv4.0 access may be different from, but not weaker than, the enforcement for local access, and both may be different from the enforcement for access through other protocols such as Server Message Block (SMB) [MS-SMB]. So it may be useful for a server to accept an ACL even if not all of its modules are able to support it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
状況は、サーバーがACLを強制する複数のモジュールを持っているかもしれないという事実によって複雑になります。例えば、NFSv4.0アクセスのための施行は、ローカルアクセスのための施行、より弱いとは異なるが、なくてもよい、との両方が、サーバメッセージブロック（SMB）のような他のプロトコルを介してアクセスするために施行異なっていてもよいです[MS- SMB]。そのモジュールのすべてではないが、それをサポートすることができている場合でも、サーバーがACLを受け入れるするので、有用である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The guiding principle with regard to NFSv4 access is that the server must not accept ACLs that give an appearance of more restricted access to a file than what is actually enforced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のアクセスに関する指導原則は、サーバが実際に施行されたものよりも、ファイルへのアクセス制限の外観を与えるACLを受け入れてはならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.1. ACE Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.1。 ACEの種類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The constants used for the type field (acetype4) are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにタイプフィールド（acetype4）に使用される定数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All four bit types are permitted in the acl attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての4つのビットタイプはACL属性で許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------------+--------------+---------------------+
   | Value                        | Abbreviation | Description         |
   +------------------------------+--------------+---------------------+
   | ACE4_ACCESS_ALLOWED_ACE_TYPE | ALLOW        | Explicitly grants   |
   |                              |              | the access defined  |
   |                              |              | in acemask4 to the  |
   |                              |              | file or directory.  |
   |                              |              |                     |
   | ACE4_ACCESS_DENIED_ACE_TYPE  | DENY         | Explicitly denies   |
   |                              |              | the access defined  |
   |                              |              | in acemask4 to the  |
   |                              |              | file or directory.  |
   |                              |              |                     |
   | ACE4_SYSTEM_AUDIT_ACE_TYPE   | AUDIT        | LOG (in a system-   |
   |                              |              | dependent way) any  |
   |                              |              | access attempt to a |
   |                              |              | file or directory   |
   |                              |              | that uses any of    |
   |                              |              | the access methods  |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   |                              |              |                     |
   | ACE4_SYSTEM_ALARM_ACE_TYPE   | ALARM        | Generate a system   |
   |                              |              | ALARM (system       |
   |                              |              | dependent) when any |
   |                              |              | access attempt is   |
   |                              |              | made to a file or   |
   |                              |              | directory for the   |
   |                              |              | access methods      |
   |                              |              | specified in        |
   |                              |              | acemask4.           |
   +------------------------------+--------------+---------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;Abbreviation&#34; column denotes how the types will be referred to throughout the rest of this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「省略形」列には、型が、このセクションの残りの部分と呼ぶことにする方法を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.2. Attribute 13: aclsupport
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.2。属性13：aclsupport
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server need not support all of the above ACE types. This attribute indicates which ACE types are supported for the current file system. The bitmask constants used to represent the above definitions within the aclsupport attribute are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、上記のACEタイプのすべてをサポートしている必要はありません。この属性は、ACEタイプは、現在のファイルシステムでサポートされているかを示します。次のようにaclsupport属性内の上記の定義を表すために使用されるビットマスク定数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
   const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers that support either the ALLOW or DENY ACE type SHOULD support both ALLOW and DENY ACE types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACEの種類が許可し、ACEの種類をDENYの両方をサポートすべき許可または拒否のいずれかサポートするサーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients should not attempt to set an ACE unless the server claims support for that ACE type. If the server receives a request to set an ACE that it cannot store, it MUST reject the request with NFS4ERR_ATTRNOTSUPP. If the server receives a request to set an ACE that it can store but cannot enforce, the server SHOULD reject the request with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバーのクレームがそのACEの種類をサポートしない限り、ACEを設定しようとするべきではありません。サーバが格納できないというACEを設定するための要求を受信した場合、それはNFS4ERR_ATTRNOTSUPPで要求を拒絶しなければなりません。サーバーが保存することができますが、強制することはできませんACEを設定するための要求を受信した場合、サーバはNFS4ERR_ATTRNOTSUPPとのリクエストを拒否すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3. ACE Access Mask
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3。 ACEアクセスマスク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The bitmask constants used for the access mask field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにアクセスマスクフィールドに使用されるビットマスク定数は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that some masks have coincident values -- for example, ACE4_READ_DATA and ACE4_LIST_DIRECTORY. The mask entries ACE4_LIST_DIRECTORY, ACE4_ADD_FILE, and ACE4_ADD_SUBDIRECTORY are intended to be used with directory objects, while ACE4_READ_DATA, ACE4_WRITE_DATA, and ACE4_APPEND_DATA are intended to be used with non-directory objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのマスクが一致する値を持っていることに注意してください - 例えば、ACE4_READ_DATAとACE4_LIST_DIRECTORY。 ACE4_READ_DATA、ACE4_WRITE_DATA、及びACE4_APPEND_DATA非ディレクトリオブジェクトで使用することが意図されている間、マスク・エントリACE4_LIST_DIRECTORY、ACE4_ADD_FILE、及びACE4_ADD_SUBDIRECTORYは、ディレクトリオブジェクトと一緒に使用されることが意図されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.1. Discussion of Mask Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.1。マスク属性のディスカッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_READ_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_READ_DATA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読む
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to read the data of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルのデータを読み取るためのアクセス許可。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、ユーザーにのみACE4_EXECUTEアクセスマスクビットがセットされている場合、ファイルのデータを読み取る能力を可能にしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_LIST_DIRECTORY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_LIST_DIRECTORY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READDIR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READDIR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to list the contents of a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディレクトリの内容を一覧表示するためのアクセス許可。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_DATA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
書く
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTR of size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サイズのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to modify a file&#39;s data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルのデータを変更する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_ADD_FILE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_ADD_FILE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LINK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リンク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リネーム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to add a new file in a directory. The CREATE operation is affected when nfs_ftype4 is NF4LNK, NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO. (NF4DIR is not listed because it is covered by ACE4_ADD_SUBDIRECTORY.) OPEN is affected when used to create a regular file. LINK and RENAME are always affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディレクトリに新しいファイルを追加する権限。 nfs_ftype4はNF4LNK、NF4BLK、NF4CHR、NF4SOCK、又はNF4FIFOある場合、CREATE操作が影響を受けます。 （それはACE4_ADD_SUBDIRECTORYによって覆われているためNF4DIRが記載されていません。）通常のファイルを作成するために使用されるときOPENが影響を受けています。 LINKとRENAMEは常に影響を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_APPEND_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_APPEND_DATA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
書く
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTR of size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サイズのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ability to modify a file&#39;s data, but only starting at EOF. This allows for the notion of append-only files, by allowing ACE4_APPEND_DATA and denying ACE4_WRITE_DATA to the same user or group. If a file has an ACL such as the one described above and a WRITE request is made for somewhere other than EOF, the server SHOULD return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルのデータを変更する機能は、だけEOFから始まります。これはACE4_APPEND_DATAを許可し、同じユーザーまたはグループにACE4_WRITE_DATAを拒否することによって、追加専用ファイルの概念が可能になります。ファイルは、上述したようなACLを持っており、書き込み要求がEOF以外のどこかのために作られた場合、サーバはNFS4ERR_ACCESSを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_ADD_SUBDIRECTORY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_ADD_SUBDIRECTORY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リネーム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to create a subdirectory in a directory. The CREATE operation is affected when nfs_ftype4 is NF4DIR. The RENAME operation is always affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディレクトリ内にサブディレクトリを作成する権限。 NF4DIRがnfs_ftype4あるとき、CREATE操作が影響を受けています。 RENAME操作は常に影響を受けています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_READ_NAMED_ATTRS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_READ_NAMED_ATTRS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENATTR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to read the named attributes of a file or to look up the named attributes directory. OPENATTR is affected when it is not used to create a named attribute directory. This is when 1) createdir is TRUE but a named attribute directory already exists or 2) createdir is FALSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルの名前の属性を読み取るため、または指定された属性のディレクトリを検索する許可。名前の属性ディレクトリを作成するために使用されていない場合OPENATTRが影響を受けています。 1）createdirはTRUEですが、名前の属性ディレクトリが既に存在しているか、2）createdirがFALSEであるとき、これがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_NAMED_ATTRS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_NAMED_ATTRS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENATTR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to write the named attributes of a file or to create a named attribute directory. OPENATTR is affected when it is used to create a named attribute directory. This is when createdir is TRUE and no named attribute directory exists. The ability to check whether or not a named attribute directory exists depends on the ability to look it up; therefore, users also need the ACE4_READ_NAMED_ATTRS permission in order to create a named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルの名前の属性を記述するか、名前付き属性のディレクトリを作成する権限。名前の属性ディレクトリを作成するために使用されている場合OPENATTRが影響を受けています。 createdirがTRUEで、何という名前の属性ディレクトリが存在しない場合です。名前の属性ディレクトリが存在するかどうかをチェックする機能は、それを検索する能力に依存します。そのため、ユーザーはまた、名前の属性ディレクトリを作成するためにACE4_READ_NAMED_ATTRS権限が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_EXECUTE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_EXECUTE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読む
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to execute a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルを実行する権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is set. This is because there is no way to execute a file without reading the contents. Though a server may treat ACE4_EXECUTE and ACE4_READ_DATA bits identically when deciding to permit a READ operation, it SHOULD still allow the two bits to be set independently in ACLs and MUST distinguish between them when replying to ACCESS operations. In particular, servers SHOULD NOT silently turn on one of the two bits when the other is set, as that would make it impossible for the client to correctly enforce the distinction between read and execute permissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、ユーザーにのみACE4_EXECUTEアクセスマスクビットがセットされている場合、ファイルのデータを読み取る能力を可能にしなければなりません。内容を読まずにファイルを実行する方法がないためです。 READ操作を可能とすることを決定する際に、サーバーが同一のACE4_EXECUTEとACE4_READ_DATAビットを扱うかもしれないが、それはまだ2つのビットは、ACLの中で独立して設定できるようにする必要があり、アクセス操作に返信するときにそれらを区別しなければなりません。具体的には、サーバは黙ってそれはそれは不可能クライアントを正しく読み取りおよび実行権限の区別を強制するために作ると同じように、他が設定されている2つのビットの1をオンにすべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As an example, following a SETATTR of the following ACL:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一例として、次のACLのSETATTR次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfsuser:ACE4_EXECUTE:ALLOW
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfsuser：ACE4_EXECUTE：ALLOW
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A subsequent GETATTR of ACL for that file SHOULD return:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのファイルのACLのその後のGETATTRは返すべきです：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfsuser:ACE4_EXECUTE:ALLOW
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfsuser：ACE4_EXECUTE：ALLOW
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rather than:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
のではなく：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfsuser:ACE4_EXECUTE/ACE4_READ_DATA:ALLOW
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfsuser：ACE4_EXECUTE / ACE4_READ_DATA：ALLOW
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_EXECUTE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_EXECUTE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOOKUP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
調べる
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
開いた
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
REMOVE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
削除する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リネーム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LINK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リンク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to traverse/search a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディレクトリを検索/トラバースする許可。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_DELETE_CHILD
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_DELETE_CHILD
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
REMOVE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
削除する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リネーム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to delete a file or directory within a directory. See Section 6.2.1.3.2 for information on how ACE4_DELETE and ACE4_DELETE_CHILD interact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディレクトリ内のファイルやディレクトリを削除する権限。 ACE4_DELETEとACE4_DELETE_CHILDがどのように相互作用するかについては、セクション6.2.1.3.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_READ_ATTRIBUTES
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_READ_ATTRIBUTES
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETATTR of file system object attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイル・システム・オブジェクト属性のGETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
VERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VERIFY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NVERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NVERIFY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READDIR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READDIR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ability to read basic attributes (non-ACLs) of a file. On a UNIX system, basic attributes can be thought of as the stat-level attributes. Allowing this access mask bit would mean the entity can execute &#34;ls -l&#34; and stat. If a READDIR operation requests attributes, this mask must be allowed for the READDIR to succeed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルの基本属性（ACL以外）を読み取る能力。 UNIXシステムでは、基本的な属性は、STAT-レベル属性と考えることができます。このアクセスマスクビットを許可すると、エンティティは「ls -lで」とのstatを実行することができますを意味します。 READDIR操作が属性を要求する場合READDIRを成功させるために、このマスクは、許可する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_ATTRIBUTES
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_ATTRIBUTES
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTR of time_access_set, time_backup, time_create, time_modify_set, mimetype, hidden, and system
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
time_access_set、time_backup、time_create、time_modify_set、MIMEタイプ、隠し、およびシステムのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to change the times associated with a file or directory to an arbitrary value. Also, permission to change the mimetype, hidden and system attributes. A user having ACE4_WRITE_DATA or ACE4_WRITE_ATTRIBUTES will be allowed to set the times associated with a file to the current server time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意の値にファイルまたはディレクトリに関連付けられた時刻を変更する権限。また、MIMEタイプ、隠しおよびシステムの属性を変更する権限。 ACE4_WRITE_DATAまたはACE4_WRITE_ATTRIBUTESを持つユーザーは、現在のサーバー時刻にファイルに関連付けられている時間を設定することが許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_DELETE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_DELETE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
REMOVE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
削除する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to delete the file or directory. See Section 6.2.1.3.2 for information on ACE4_DELETE and ACE4_DELETE_CHILD interact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルまたはディレクトリを削除する権限。 ACE4_DELETEとACE4_DELETE_CHILDの相互作用の詳細については、セクション6.2.1.3.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_READ_ACL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_READ_ACL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETATTR of acl
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACLのGETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NVERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NVERIFY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
VERIFY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VERIFY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to read the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACLの読み取り権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_ACL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_ACL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTR of acl and mode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACLとモードのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to write the acl and mode attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACLとモード属性を書き込む権限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_OWNER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_WRITE_OWNER
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTR of owner and owner_group
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
所有者とowner_groupのSETATTR
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to write the owner and owner_group attributes. On UNIX systems, this is the ability to execute chown() and chgrp().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
所有者の書き込みと属性をowner_groupする許可。 UNIXシステムでは、これは（）はchown（）とchgrpコマンドを実行する能力です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_SYNCHRONIZE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_SYNCHRONIZE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operation(s) affected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション（s）は影響を受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NONE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無し
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Discussion:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
討論：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Permission to use the file object as a synchronization primitive for interprocess communication. This permission is not enforced or interpreted by the NFSv4.0 server on behalf of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロセス間通信のための同期プリミティブとしてファイルオブジェクトを使用する許可。この権限は、クライアントに代わって強制またはNFSv4.0サーバーによって解釈されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Typically, the ACE4_SYNCHRONIZE permission is only meaningful on local file systems, i.e., file systems not accessed via NFSv4.0. The reason that the permission bit exists is that some operating environments, such as Windows, use ACE4_SYNCHRONIZE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
典型的には、ACE4_SYNCHRONIZE許可は、NFSv4.0を介してアクセスされない、すなわち、ファイル・システムのローカルファイルシステム上でのみ有効です。許可ビットが存在する理由は、Windowsのようないくつかの動作環境は、ACE4_SYNCHRONIZEを使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if a client copies a file that has ACE4_SYNCHRONIZE set from a local file system to an NFSv4.0 server, and then later copies the file from the NFSv4.0 server to a local file system, it is likely that if ACE4_SYNCHRONIZE was set in the original file, the client will want it set in the second copy. The first copy will not have the permission set unless the NFSv4.0 server has the means to set the ACE4_SYNCHRONIZE bit. The second copy will not have the permission set unless the NFSv4.0 server has the means to retrieve the ACE4_SYNCHRONIZE bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、クライアントコピーACE4_SYNCHRONIZE後でコピーしたファイルをローカルファイルシステムへのNFSv4.0サーバーから、その後NFSv4.0サーバーへのローカルファイルシステムから設定して、しているファイルならば、ACE4_SYNCHRONIZEだったら可能性が高いです元のファイルに設定され、クライアントは、それが第二のコピーに設定したいと思うでしょう。 NFSv4.0サーバーがACE4_SYNCHRONIZEビットを設定するための手段を持っていない限り、最初のコピーは、アクセス許可セットを持っていません。 NFSv4.0サーバーがACE4_SYNCHRONIZEビットを取得するための手段を持っていない限り、第二のコピーは、アクセス許可セットを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Server implementations need not provide the granularity of control that is implied by this list of masks. For example, POSIX-based systems might not distinguish ACE4_APPEND_DATA (the ability to append to a file) from ACE4_WRITE_DATA (the ability to modify existing contents); both masks would be tied to a single &#34;write&#34; permission. When such a server returns attributes to the client, it would show both ACE4_APPEND_DATA and ACE4_WRITE_DATA if and only if the write permission is enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ実装は、マスクのこのリストによって暗示される制御の粒度を提供する必要はありません。例えば、POSIXベースのシステムは、ACE4_WRITE_DATA（既存の内容を変更する能力）からACE4_APPEND_DATA（ファイルに追加する能力）を区別しないかもしれません。両方のマスクは、単一の「書き込み」権限に縛られることになります。そのようなサーバがクライアントに属性を返すとき、それがあればACE4_APPEND_DATAとACE4_WRITE_DATAの両方を示すであろうし、書き込み許可が有効な場合のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a server receives a SETATTR request that it cannot accurately implement, it should err in the direction of more restricted access, except in the previously discussed cases of execute and read. For example, suppose a server cannot distinguish overwriting data from appending new data, as described in the previous paragraph. If a client submits an ALLOW ACE where ACE4_APPEND_DATA is set but ACE4_WRITE_DATA is not (or vice versa), the server should either turn off ACE4_APPEND_DATA or reject the request with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはそれが正確に実装することはできませんSETATTR要求を受信した場合、それが実行し、読みの先に述べた場合を除いて、より多くのアクセス制限の方向に誤るべきです。例えば、前の段落で説明したように、サーバは、新しいデータを追加するからデータを上書き区別できないと仮定します。クライアントはACE4_APPEND_DATAが設定されているALLOW ACEを提出するが、ACE4_WRITE_DATAは（またはその逆）でない場合、サーバはどちらかACE4_APPEND_DATAをオフにしたり、NFS4ERR_ATTRNOTSUPPで要求を拒否しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.2. ACE4_DELETE versus ACE4_DELETE_CHILD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.3.2。 ACE4_DELETE_CHILD対ACE4_DELETE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Two access mask bits govern the ability to delete a directory entry: ACE4_DELETE on the object itself (the &#34;target&#34;) and ACE4_DELETE_CHILD on the containing directory (the &#34;parent&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
含むディレクトリ（「親」）上でオブジェクト自体（「標的」）にACE4_DELETEとACE4_DELETE_CHILD：2つのアクセス・マスク・ビットは、ディレクトリエントリを削除する能力を支配します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many systems also take the &#34;sticky bit&#34; (MODE4_SVTX) on a directory to allow unlink only to a user that owns either the target or the parent; on some such systems, the decision also depends on whether the target is writable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くのシステムはまた、唯一のターゲットまたは親のいずれかを所有しているユーザーにリンク解除を許可するディレクトリに「スティッキービット」（MODE4_SVTX）を取ります。このようないくつかのシステムでは、意思決定は、ターゲットが書き込み可能であるかどうかに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers SHOULD allow unlink if either ACE4_DELETE is permitted on the target or ACE4_DELETE_CHILD is permitted on the parent. (Note that this is true even if the parent or target explicitly denies the other of these permissions.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーはACE4_DELETEどちらかがターゲットに許可されているかACE4_DELETE_CHILDが親に許可されている場合は解除許可する必要があります。 （これは親またはターゲットが明示的にこれらの権限の他のを拒否した場合も同様であることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the ACLs in question neither explicitly ALLOW nor DENY either of the above, and if MODE4_SVTX is not set on the parent, then the server SHOULD allow the removal if and only if ACE4_ADD_FILE is permitted. In the case where MODE4_SVTX is set, the server may also require the remover to own either the parent or the target, or may require the target to be writable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場合は、問題のACLは、どちらも明示的に許可もDENY上記のいずれかを、そしてMODE4_SVTXが親に設定されていない場合やACE4_ADD_FILEが許可されている場合にだけ、サーバは除去を可能にしなければなりません。 MODE4_SVTXが設定されている場合、サーバは、親またはターゲットを所有する除去を必要とするかもしれない、または書き込み可能にターゲットを必要とし得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This allows servers to support something close to traditional UNIX-like semantics, with ACE4_ADD_FILE taking the place of the write bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、サーバがACE4_ADD_FILEは、書き込みビットの場所を取って、伝統的なUNIXに似た意味論に近いものをサポートすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4. ACE flag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4。 ACEフラグ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The bitmask constants used for the flag field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにフラグフィールドに使用されるビットマスク定数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server need not support any of these flags. If the server supports flags that are similar to, but not exactly the same as, these flags, the implementation may define a mapping between the protocol-defined flags and the implementation-defined flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、これらのフラグのいずれかをサポートする必要はありません。サーバは同様に、これらのフラグは、全く同じではないフラグをサポートしている場合、実装は、プロトコル定義のフラグおよび実装定義フラグとの間のマッピングを定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, suppose a client tries to set an ACE with ACE4_FILE_INHERIT_ACE set but not ACE4_DIRECTORY_INHERIT_ACE. If the server does not support any form of ACL inheritance, the server should reject the request with NFS4ERR_ATTRNOTSUPP. If the server supports a single &#34;inherit ACE&#34; flag that applies to both files and directories, the server may reject the request (i.e., requiring the client to set both the file and directory inheritance flags). The server may also accept the request and silently turn on the ACE4_DIRECTORY_INHERIT_ACE flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、クライアントはACE4_FILE_INHERIT_ACEセットではなくACE4_DIRECTORY_INHERIT_ACEでACEを設定しようとします。サーバーは、ACLの継承のいずれかの形式をサポートしていない場合、サーバはNFS4ERR_ATTRNOTSUPPで要求を拒否しなければなりません。サーバがファイルとディレクトリの両方に適用されるシングル「継承ACE」フラグをサポートしている場合、サーバーが要求を拒否することができる（すなわち、ファイルやディレクトリの継承の両方のフラグを設定するためのクライアントを必要とします）。また、サーバは要求を受け入れ、静かACE4_DIRECTORY_INHERIT_ACEフラグをオンにすることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4.1. Discussion of Flag Bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.4.1。フラグビットのディスカッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_FILE_INHERIT_ACE Any non-directory file in any subdirectory will get this ACE inherited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_FILE_INHERIT_ACE任意のサブディレクトリ内の任意の非ディレクトリファイルは、このACEは継承されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_DIRECTORY_INHERIT_ACE Can be placed on a directory and indicates that this ACE should be added to each new directory created. If this flag is set in an ACE in an ACL attribute to be set on a non-directory file system object, the operation attempting to set the ACL SHOULD fail with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_DIRECTORY_INHERIT_ACEは、ディレクトリ上に配置され、このACEが作成したそれぞれの新しいディレクトリに追加されなければならないことを示していることができます。このフラグがディレクトリ以外のファイルシステムオブジェクトに設定されるACL属性でACEに設定されている場合は、ACLを設定しようとする操作がNFS4ERR_ATTRNOTSUPPで失敗すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_INHERIT_ONLY_ACE Can be placed on a directory but does not apply to the directory; ALLOW and DENY ACEs with this bit set do not affect access to the directory, and AUDIT and ALARM ACEs with this bit set do not trigger log or alarm events. Such ACEs only take effect once they are applied (with this bit cleared) to newly created files and directories as specified by the above two flags. If this flag is present on an ACE, but neither ACE4_DIRECTORY_INHERIT_ACE nor ACE4_FILE_INHERIT_ACE is present, then an operation attempting to set such an attribute SHOULD fail with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_INHERIT_ONLY_ACEはディレクトリに配置することができますが、ディレクトリには適用されません。このビットが設定された許可し、DENY ACEは、ディレクトリへのアクセスには影響しませんし、このビットがセットされたAUDITとALARM ACEは、ログやアラームイベントをトリガしません。それらが適用されると（このビットをクリアして）上記二つのフラグで指定されているようなACEは、新しく作成されたファイルやディレクトリへの効果のみを取ります。このフラグは、ACE上に存在するが、どちらもACE4_DIRECTORY_INHERIT_ACEもACE4_FILE_INHERIT_ACEが存在する場合、そのような属性を設定しようとする操作がNFS4ERR_ATTRNOTSUPPで失敗すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_NO_PROPAGATE_INHERIT_ACE Can be placed on a directory. This flag tells the server that inheritance of this ACE should stop at newly created child directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_NO_PROPAGATE_INHERIT_ACEはディレクトリに配置することができます。このフラグは、このACEの継承が新たに作成された子ディレクトリで停止する必要があり、サーバーに指示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_FAILED_ACCESS_ACE_FLAG The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS) and ACE4_FAILED_ACCESS_ACE_FLAG (FAILED) flag bits may be set only on ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and ACE4_SYSTEM_ALARM_ACE_TYPE (ALARM) ACE types. If, during the processing of the file&#39;s ACL, the server encounters an AUDIT or ALARM ACE that matches the principal attempting the OPEN, the server notes that fact and notes the presence, if any, of the SUCCESS and FAILED flags encountered in the AUDIT or ALARM ACE. Once the server completes the ACL processing, it then notes if the operation succeeded or failed. If the operation succeeded, and if the SUCCESS flag was set for a matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. If the operation failed, and if the FAILED flag was set for the matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. Either or both of the SUCCESS or FAILED can be set, but if neither is set, the AUDIT or ALARM ACE is not useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_FAILED_ACCESS_ACE_FLAGザACE4_SUCCESSFUL_ACCESS_ACE_FLAG（成功）とACE4_FAILED_ACCESS_ACE_FLAG（FAILED）のフラグビットのみACE4_SYSTEM_AUDIT_ACE_TYPE（AUDIT）とACE4_SYSTEM_ALARM_ACE_TYPE（ALARM）ACEタイプに基づいて設定してもよいです。 、ファイルのACLの処理中に、サーバーがOPENをしようと元本と一致したAUDITかALARM ACEに遭遇した場合、サーバーがあれば、実際とはSUCCESSの、存在を指摘し、FAILEDフラグがAUDITに遭遇したかと指摘しますアラームACE。サーバーは、ACLの処理を完了すると、それは、操作が成功したか失敗した場合は指摘しています。操作が成功し、成功フラグをマッチングAUDITまたはアラームACEに設定された場合には、適切な監査またはアラームイベントが発生した場合。操作が失敗した場合、失敗したフラグが一致するAUDITまたはアラームACEに設定された場合には、適切な監査またはアラームイベントが発生します。いずれかまたはSUCCESSの両方またはFAILEDを設定することができますが、どちらも設定されていない場合、AUDITまたはALARM ACEは有用ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The previously described processing applies to ACCESS operations even when they return NFS4_OK. For the purposes of AUDIT and ALARM, we consider an ACCESS operation to be a &#34;failure&#34; if it fails to return a bit that was requested and supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らはNFS4_OKを返す場合でも、前述の処理は、アクセス操作に適用されます。 AUDITとALARMの目的のために、我々はそれが要求され、サポートされたビットを返すことに失敗した場合、アクセス操作は「失敗」であると考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_IDENTIFIER_GROUP Indicates that the &#34;who&#34; refers to a GROUP as defined under UNIX or a GROUP ACCOUNT as defined under Windows. Clients and servers MUST ignore the ACE4_IDENTIFIER_GROUP flag on ACEs with a who value equal to one of the special identifiers outlined in Section 6.2.1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_IDENTIFIER_GROUPは、Windowsの下で定義されているUNIXまたはグループアカウントの下で定義される「誰が」基を意味することを示します。クライアントとサーバーは、セクション6.2.1.5に概説特別な識別子の1に等しい値、誰とACEでACE4_IDENTIFIER_GROUPフラグを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5. ACE Who
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5。 ACEは誰
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The who field of an ACE is an identifier that specifies the principal or principals to whom the ACE applies. It may refer to a user or a group, with the flag bit ACE4_IDENTIFIER_GROUP specifying which.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACEの人フィールドは、元本またはACEの適用対象にプリンシパルを特定する識別子です。それは、フラグビットACE4_IDENTIFIER_GROUPを指定して、ユーザまたはグループを指すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are several special identifiers that need to be understood universally, rather than in the context of a particular DNS domain. Some of these identifiers cannot be understood when an NFS client accesses the server but have meaning when a local process accesses the file. The ability to display and modify these permissions is permitted over NFS, even if none of the access methods on the server understand the identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
むしろ、特定のDNSドメインの文脈におけるよりも、普遍的に理解する必要があるいくつかの特別な識別子があります。これらの識別子の一部は、NFSクライアントがサーバにアクセスするときに理解することはできませんが、ローカルのプロセスがファイルにアクセスしたときに意味しています。表示し、これらの権限を変更する機能は、サーバ上のアクセス方法のどれもが識別子を理解していない場合でも、NFS上で許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------+---------------------------------------------------+
   | Who           | Description                                       |
   +---------------+---------------------------------------------------+
   | OWNER         | The owner of the file.                            |
   | GROUP         | The group associated with the file.               |
   | EVERYONE      | The world, including the owner and owning group.  |
   | INTERACTIVE   | Accessed from an interactive terminal.            |
   | NETWORK       | Accessed via the network.                         |
   | DIALUP        | Accessed as a dialup user to the server.          |
   | BATCH         | Accessed from a batch job.                        |
   | ANONYMOUS     | Accessed without any authentication.              |
   | AUTHENTICATED | Any authenticated user (opposite of ANONYMOUS).   |
   | SERVICE       | Access from a system service.                     |
   +---------------+---------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 5: Special Identifiers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表5：特別な識別子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To avoid conflict, these special identifiers are distinguished by an appended &#34;@&#34; and should appear in the form &#34;xxxx@&#34; (with no domain name after the &#34;@&#34;) -- for example, ANONYMOUS@.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
競合を避けるために、これらの特別な識別子は、「@」追加によって区別され、フォーム（「@」の後には、ドメイン名を持つ）「XXXXの@」に表示されます - 例えば、ANONYMOUS @。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ACE4_IDENTIFIER_GROUP flag MUST be ignored on entries with these special identifiers. When encoding entries with these special identifiers, the ACE4_IDENTIFIER_GROUP flag SHOULD be set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACE4_IDENTIFIER_GROUPフラグは、これらの特別な識別子を持つエントリで無視しなければなりません。これらの特別な識別子を持つエントリを符号化するとき、ACE4_IDENTIFIER_GROUPフラグがゼロに設定されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5.1. Discussion of EVERYONE@
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1.5.1。 EVERYONEの議論@
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is important to note that &#34;EVERYONE@&#34; is not equivalent to the UNIX &#34;other&#34; entity. This is because, by definition, UNIX &#34;other&#34; does not include the owner or owning group of a file. &#34;EVERYONE@&#34; means literally everyone, including the owner or owning group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「誰もが@」UNIX「その他」の実体と等価ではないことに注意することが重要です。定義により、UNIXは、ファイルの所有者または所有グループを「その他」は含まれないためです。 「EVERYONEは、@」所有者または所有グループを含む文字通り皆を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. Attribute 33: mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2。属性33：モード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4.0 mode attribute is based on the UNIX mode bits. The following bits are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.0モード属性は、UNIXモード・ビットに基づいています。次のビットが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const MODE4_SUID = 0x800;  /* set user id on execution */
   const MODE4_SGID = 0x400;  /* set group id on execution */
   const MODE4_SVTX = 0x200;  /* save text even after use */
   const MODE4_RUSR = 0x100;  /* read permission: owner */
   const MODE4_WUSR = 0x080;  /* write permission: owner */
   const MODE4_XUSR = 0x040;  /* execute permission: owner */
   const MODE4_RGRP = 0x020;  /* read permission: group */
   const MODE4_WGRP = 0x010;  /* write permission: group */
   const MODE4_XGRP = 0x008;  /* execute permission: group */ const MODE4_ROTH = 0x004;  /* read permission: other */
   const MODE4_WOTH = 0x002;  /* write permission: other */
   const MODE4_XOTH = 0x001;  /* execute permission: other */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the principal identified in the owner attribute. Bits MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP apply to principals identified in the owner_group attribute but who are not identified in the owner attribute. Bits MODE4_ROTH, MODE4_WOTH, and MODE4_XOTH apply to any principal that does not match that in the owner attribute and does not have a group matching that of the owner_group attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビットMODE4_RUSR、MODE4_WUSR、及びMODE4_XUSRは、所有者の属性で識別されたプリンシパルに適用されます。ビットMODE4_RGRP、MODE4_WGRP、およびMODE4_XGRPは、所有者の属性で識別されていないowner_group属性で識別プリンシパルだけに適用されます。ビットMODE4_ROTH、MODE4_WOTH、及びMODE4_XOTHは、所有者属性に一致しないとowner_group属性と一致する基を有さない任意のプリンシパルに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bits within the mode other than those specified above are not defined by this protocol. A server MUST NOT return bits other than those defined above in a GETATTR or READDIR operation, and it MUST return NFS4ERR_INVAL if bits other than those defined above are set in a SETATTR, CREATE, OPEN, VERIFY, or NVERIFY operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記以外のモード内のビットは、このプロトコルで定義されていません。サーバはGETATTR又はREADDIR操作で上記に定義されるもの以外のビットを返してはいけません、そして、それは上記で定義されたもの以外のビットはSETATTRに設定されている場合、NFS4ERR_INVALを返すCREATE、OPEN、VERIFY、又はNVERIFY動作しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Common Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3。共通メソッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requirements in this section will be referred to in future sections, especially Section 6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションの要件は、特に6.4節、将来のセクションで呼ぶことにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. Interpreting an ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1。 ACLの解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.1. Server Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.1。サーバーの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server uses the algorithm described in Section 6.2.1 to determine whether an ACL allows access to an object. However, the ACL may not be the sole determiner of access. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、ACLがオブジェクトへのアクセスを許可するかどうかを決定するために、セクション6.2.1に記載したアルゴリズムを使用します。しかし、ACLは、アクセスの唯一の決定ではないかもしれません。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In the case of a file system exported as read-only, the server may deny write permissions even though an object&#39;s ACL grants it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O読み取り専用としてエクスポートされたファイルシステムの場合、サーバーは、オブジェクトのACLはそれを許可していても書き込み権限を拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Server implementations MAY grant ACE4_WRITE_ACL and ACE4_READ_ACL permissions to prevent a situation from arising in which there is no valid way to ever modify the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバーの実装は、これまでACLを変更するための有効な方法はありませんここで生じるの事態を防ぐためにACE4_WRITE_ACLとACE4_READ_ACL権限を付与することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o All servers will allow a user the ability to read the data of the file when only the execute permission is granted (i.e., if the ACL denies the user ACE4_READ_DATA access and allows the user ACE4_EXECUTE, the server will allow the user to read the data of the file).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
唯一の実行許可がACLは、ユーザーACE4_READ_DATAへのアクセスを拒否し、ユーザーACE4_EXECUTEを許可する場合、サーバは、ユーザがデータを読み取ることができるようになります、すなわち（付与されたときに、Oすべてのサーバーは、ユーザーのファイルのデータを読み取る機能できるようになりますファイルの）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Many servers have the notion of owner-override, in which the owner of the object is allowed to override accesses that are denied by the ACL. This may be helpful, for example, to allow users continued access to open files on which the permissions have changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバの多くは、オブジェクトの所有者は、ACLによって拒否されたアクセスを無効にすることが許されている所有者、オーバーライド、という概念を持っています。これにより、ユーザーは権限が変更された上でファイルを開くためのアクセスを引き続き許可するように、例えば、役立つかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Many servers have the notion of a &#34;superuser&#34; that has privileges beyond an ordinary user. The superuser may be able to read or write data or metadata in ways that would not be permitted by the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバの多くは、通常のユーザーを超えた権限を持つ「スーパーユーザ」の概念を持っています。スーパーユーザは、ACLによって許可されない方法でデータやメタデータを読み書きすることができるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.2. Client Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.2。クライアントの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients SHOULD NOT do their own access checks based on their interpretation of the ACL but rather use the OPEN and ACCESS operations to do access checks. This allows the client to act on the results of having the server determine whether or not access should be granted based on its interpretation of the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、ACLの彼らの解釈に基づいて、独自のアクセスチェックを行うのではなく、アクセスチェックを行うためにOPENし、アクセスする操作を使用しないでください。これにより、クライアントは、サーバがアクセスがACLの解釈に基づいて許可されるべきかどうかを判断した結果に基づいて行動することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients must be aware of situations in which an object&#39;s ACL will define a certain access even though the server will not have adequate information to enforce it. For example, the server has no way of determining whether a particular OPEN reflects a user&#39;s open for read access or is done as part of executing the file in question. In such situations, the client needs to do its part in the enforcement of access as defined by the ACL. To do this, the client will send the appropriate ACCESS operation (or use a cached previous determination) prior to servicing the request of the user or application in order to determine whether the user or application should be granted the access requested. For examples in which the ACL may define accesses that the server does not enforce, see Section 6.3.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、オブジェクトのACLは、サーバがそれを強制するために十分な情報を持っていないだろうにもかかわらず、特定のアクセスを定義しますする状況を認識する必要があります。例えば、サーバは特定のOPENが読み取りアクセス用のユーザのオープンを反映しているか、問題のファイルを実行するの一環として行われているかどうかを判断する方法はありません。このような状況では、クライアントは、ACLで定義されたアクセスの施行にその一部を行う必要があります。これを行うには、クライアントが適切なアクセス動作をお送りします（またはキャッシュされた前回の判定を使用する）前に、ユーザーまたはアプリケーションが要求されたアクセス権を付与する必要があるかどうかを判断するために、ユーザーまたはアプリケーションの要求にサービスを提供します。 ACLを定義することができた例についてサーバは、セクション6.3.1.1を参照し、強制しないことにアクセスします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. Computing a mode Attribute from an ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2。 ACLからのモード属性を計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following method can be used to calculate the MODE4_R*, MODE4_W*, and MODE4_X* bits of a mode attribute, based upon an ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の方法は、ACLに基づいて、モード属性のMODE4_R *、MODE4_W *、及びMODE4_X *ビットを計算するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First, for each of the special identifiers OWNER@, GROUP@, and EVERYONE@, evaluate the ACL in order, considering only ALLOW and DENY ACEs for the identifier EVERYONE@ and for the identifier under consideration. The result of the evaluation will be an NFSv4 ACL mask showing exactly which bits are permitted to that identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、特別な識別子の所有者@、group @、およびeveryoneする@ごとに、識別子EVERYONEの@のためにと検討中の識別子のためにのみ許可し、DENY ACEを考慮すると、順番にACLを評価します。評価の結果は、ビットがその識別子に許可されている正確に示すのNFSv4 ACLマスクであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Then translate the calculated mask for OWNER@, GROUP@, and EVERYONE@ into mode bits for the user, group, and other, respectively, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように、それぞれの所有者@、グループ@、およびユーザ、グループ、および他のためのモードのビットに@誰もが、について計算マスクを翻訳：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Set the read bit (MODE4_RUSR, MODE4_RGRP, or MODE4_ROTH) if and only if ACE4_READ_DATA is set in the corresponding mask.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.設定ACE4_READ_DATAは、対応するマスクに設定されている場合に限り、読み取りビット（MODE4_RUSR、MODE4_RGRP、又はMODE4_ROTH）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Set the write bit (MODE4_WUSR, MODE4_WGRP, or MODE4_WOTH) if and only if ACE4_WRITE_DATA and ACE4_APPEND_DATA are both set in the corresponding mask.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.書き込みビット（MODE4_WUSR、MODE4_WGRP、又はMODE4_WOTH）IFおよびACE4_WRITE_DATAとACE4_APPEND_DATAの両方対応するマスクに設定されている場合のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Set the execute bit (MODE4_XUSR, MODE4_XGRP, or MODE4_XOTH), if and only if ACE4_EXECUTE is set in the corresponding mask.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. ACE4_EXECUTEが対応するマスクに設定されている場合に限り、（MODE4_XUSR、MODE4_XGRP、又はMODE4_XOTH）実行ビットを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1。討論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some server implementations also add bits permitted to named users and groups to the group bits (MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のサーバーの実装は、グループ・ビット（MODE4_RGRP、MODE4_WGRP、およびMODE4_XGRP）への指定ユーザーおよびグループに許可ビットを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations are discouraged from doing this, because it has been found to cause confusion for users who see members of a file&#39;s group denied access that the mode bits appear to allow. (The presence of DENY ACEs may also lead to such behavior, but DENY ACEs are expected to be more rarely used.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルのグループのメンバーは、モードビットが許可するように見えるのアクセスを拒否された参照のユーザーのための混乱を引き起こすことが分かっているので、実装は、これをやってから、落胆しています。 （DENY ACEの存在はまた、そのような挙動につながるが、ACEのがよりめったに使用されないことが期待されて拒否することができます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The same user confusion seen when fetching the mode also results if setting the mode does not effectively control permissions for the owner, group, and other users; this motivates some of the requirements that follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モードを設定すると効果的に所有者、グループ、および他のユーザーの権限を制御しない場合のモードをフェッチするときに見られる同一のユーザの混乱も生じます。これは続く要件の一部を動機付けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4。必要条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server that supports both mode and ACL must take care to synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH bits with the ACEs that have respective who fields of &#34;OWNER@&#34;, &#34;GROUP@&#34;, and &#34;EVERYONE@&#34; so that the client can see that semantically equivalent access permissions exist whether the client asks for just the ACL or any of the owner, owner_group, and mode attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モードとACLの両方をサポートするサーバーは、それぞれの人「OWNER @」、「グループ@」のフィールド、および「EVERYONEを持っているのACEとMODE4_ * USR、MODE4_ * GRP、およびMODE4_ * OTHビットを同期するために注意しなければなりません@ &#34;ように、クライアントは、意味的に同等のアクセス権限は、クライアントがちょうどACLまたは所有者、owner_group、およびモード属性のいずれかを要求するかどうかに存在していることがわかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many requirements refer to Section 6.3.2, but note that the methods have behaviors specified with &#34;SHOULD&#34;. This is intentional, to avoid invalidating existing implementations that compute the mode according to the withdrawn POSIX ACL draft ([P1003.1e]), rather than by actual permissions on owner, group, and other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くの要件は、6.3.2項を参照してください、しかし、方法は「SHOULD」で指定された振る舞いを持っていることに注意してください。これは、引き出さPOSIX ACLドラフト（[P1003.1e]）に応じてではなく、所有者、グループ、および他の実際の許可によってモードを計算する既存の実装を無効に回避するために、意図的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. Setting the mode and/or ACL Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1。モードおよび/またはACL属性の設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.1. Setting mode and Not ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.1。設定モードとNot ACL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When any of the nine low-order mode bits are changed because the mode attribute was set, and no ACL attribute is explicitly set, the acl attribute must be modified in accordance with the updated value of those bits. This must happen even if the value of the low-order bits is the same after the mode is set as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
mode属性が設定されたため、9低次モードのビットのいずれかが変更され、何のACL属性が明示的に設定されていない場合、ACL属性は、これらのビットの更新値に応じて変更する必要があります。これは、モードは以前のように設定された後、下位ビットの値が同じであっても起こらなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that any AUDIT or ALARM ACEs are unaffected by changes to the mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意のAUDITまたはALARM ACEがモードへの変更の影響を受けないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In cases in which the permissions bits are subject to change, the acl attribute MUST be modified such that the mode computed via the method described in Section 6.3.2 yields the low-order nine bits (MODE4_R*, MODE4_W*, MODE4_X*) of the mode attribute as modified by the change attribute. The ACL attributes SHOULD also be modified such that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パーミッションビットが変更される場合がありする場合には、ACL属性は、セクション6.3.2に記載した方法を介して計算されたモードは、下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）が得られるように修正されなければなりません変化属性によって修正されたモードが属性。 ACL属性はまた、そのようなことを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. If MODE4_RGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_READ_DATA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MODE4_RGRPが設定されていない場合1.、明示的に所有者@とEVERYONEの@以外のACLに記載されているエンティティはACE4_READ_DATAを付与されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. If MODE4_WGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_WRITE_DATA or ACE4_APPEND_DATA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MODE4_WGRPが設定されていない場合は2、明示的に所有者@とEVERYONEの@以外のACLに記載されているエンティティはACE4_WRITE_DATAまたはACE4_APPEND_DATAを付与されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. If MODE4_XGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_EXECUTE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MODE4_XGRPが設定されていない場合3.、明示的に所有者@とEVERYONEの@以外のACLに記載されているエンティティはACE4_EXECUTEを付与されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Access mask bits other than those listed above, appearing in ALLOW ACEs, MAY also be disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACEをALLOWに現れる上記以外のアクセス・マスク・ビットは、また、ディセーブルされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that ACEs with the flag ACE4_INHERIT_ONLY_ACE set do not affect the permissions of the ACL itself, nor do ACEs of the types AUDIT and ALARM. As such, it is desirable to leave these ACEs unmodified when modifying the ACL attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フラグACE4_INHERIT_ONLY_ACEセットでACEは注意がACL自体の権限に影響を与え、また種類のAUDITとALARMのACEを行いません。このように、ACL属性を変更する際、未修飾これらのACEを残すことが望ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Also note that the requirement may be met by discarding the acl in favor of an ACL that represents the mode and only the mode. This is permitted, but it is preferable for a server to preserve as much of the ACL as possible without violating the above requirements. Discarding the ACL makes it effectively impossible for a file created with a mode attribute to inherit an ACL (see Section 6.4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、要件はモードと専用モードを表しACLの賛成でACLを破棄することによって満たすことができることに注意してください。これは許可するが、サーバが上記の要件に違反することなく、可能なACLの多くを保持することが好適です。 ACLを破棄すること（6.4.3項を参照）ACLを継承するモード属性で作成されたファイルのためにそれが効果的にできなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.2. Setting ACL and Not mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.2。設定ACLとNotモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When setting the acl and not setting the mode attribute, the permission bits of the mode need to be derived from the ACL. In this case, the ACL attribute SHOULD be set as given. The nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) MUST be modified to match the result of the method described in Section 6.3.2. The three high-order bits of the mode (MODE4_SUID, MODE4_SGID, MODE4_SVTX) SHOULD remain unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACLを設定し、モード属性を設定しない場合は、モードの許可ビットがACLから派生する必要があります。与えられたとして、この場合、ACL属性を設定する必要があります。モード属性（MODE4_R *、MODE4_W *、MODE4_X *）の9下位ビットは、セクション6.3.2に記載した方法の結果と一致するように修正されなければなりません。モード（MODE4_SUID、MODE4_SGID、MODE4_SVTX）の上位3ビットは不変べきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.3. Setting Both ACL and mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1.3。 ACLとモードの両方を設定します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When setting both the mode and the acl attribute in the same operation, the attributes MUST be applied in this order: mode, then ACL. The mode-related attribute is set as given, then the ACL attribute is set as given, possibly changing the final mode, as described above in Section 6.4.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その後、モード、ACL：モードと同じ操作でACL属性の両方を設定すると、属性がこの順に適用されなければなりません。与えられたモードに関連する属性が設定されて与えられるように、セクション6.4.1.2に上述したように、その後、ACL属性は、おそらく最終的なモードを変更、設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. Retrieving the mode and/or ACL Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2。モードおよび/またはACL属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section applies only to servers that support both the mode and ACL attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、専用モードとACLの属性の両方をサポートするサーバーに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some server implementations may have a concept of &#34;objects without ACLs&#34;, meaning that all permissions are granted and denied according to the mode attribute, and that no ACL attribute is stored for that object. If an ACL attribute is requested of such a server, the server SHOULD return an ACL that does not conflict with the mode; that is to say, the ACL returned SHOULD represent the nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) as described in Section 6.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のサーバーの実装は、すべての権限が付与されたとモード属性に応じて拒否された、と何のACL属性は、そのオブジェクトのために格納されていないことをされていることを意味し、「ACLのなしのオブジェクト」の概念を持つことができます。 ACL属性は、このようなサーバーに要求されている場合は、サーバーモードと競合しないACLを返すべきです。すなわち、ACLは、セクション6.3.2に記載したようにモード属性（MODE4_R *、MODE4_W *、MODE4_X *）の9下位ビットを表現して下さい返さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For other server implementations, the ACL attribute is always present for every object. Such servers SHOULD store at least the three high-order bits of the mode attribute (MODE4_SUID, MODE4_SGID, MODE4_SVTX). The server SHOULD return a mode attribute if one is requested, and the low-order nine bits of the mode (MODE4_R*, MODE4_W*, MODE4_X*) MUST match the result of applying the method in Section 6.3.2 to the ACL attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他のサーバーの実装では、ACL属性は常に、すべてのオブジェクトのために存在しています。そのようなサーバは、モード属性（MODE4_SUID、MODE4_SGID、MODE4_SVTX）少なくとも3つの上位ビットを格納する必要があります。一つは要求された場合、サーバは、モード属性を返す必要があり、モード（MODE4_R *、MODE4_W *、MODE4_X *）の下位9ビットは、ACL属性にセクション6.3.2方法を適用した結果と一致しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3. Creating New Objects
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3。新しいオブジェクトの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a server supports any ACL attributes, it may use the ACL attributes on the parent directory to compute an initial ACL attribute for a newly created object. This will be referred to as the inherited ACL within this section. The act of adding one or more
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、任意のACL属性をサポートしている場合、それはACLが、新しく作成されたオブジェクトの初期ACL属性を計算するために、親ディレクトリの属性使用することができます。これは、このセクション内で継承されたACLと呼ぶことにします。一つ以上の追加の行為
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACEs to the inherited ACL that are based upon ACEs in the parent directory&#39;s ACL will be referred to as inheriting an ACE within this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
親ディレクトリのACL内のACEに基づいています継承されたACLへのACEは、このセクション内のACEを継承と呼ぶことにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the presence or absence of the mode and ACL attributes, the behavior of CREATE and OPEN SHOULD be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モードの存在下または非存在下ではとACL属性、CREATEやOPENの動作は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. If just the mode is given in the call:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.ちょうどモードは呼び出しで指定されている場合：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       In this case, inheritance SHOULD take place, but the mode MUST be
       applied to the inherited ACL as described in Section 6.4.1.1,
       thereby modifying the ACL.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. If just the ACL is given in the call:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.ちょうどACLは呼び出しで指定されている場合：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       In this case, inheritance SHOULD NOT take place, and the ACL as
       defined in the CREATE or OPEN will be set without modification,
       and the mode modified as in Section 6.4.1.2.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. If both mode and ACL are given in the call:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.モードとACLの両方がコールに与えられている場合：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       In this case, inheritance SHOULD NOT take place, and both
       attributes will be set as described in Section 6.4.1.3.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. If neither mode nor ACL is given in the call:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.どちらのモードでもACLは呼び出しで指定されている場合：
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       In the case where an object is being created without any initial
       attributes at all, e.g., an OPEN operation with an opentype4 of
       OPEN4_CREATE and a createmode4 of EXCLUSIVE4, inheritance SHOULD
       NOT take place.  Instead, the server SHOULD set permissions to
       deny all access to the newly created object.  It is expected that
       the appropriate client will set the desired attributes in a
       subsequent SETATTR operation, and the server SHOULD allow that
       operation to succeed, regardless of what permissions the object
       is created with.  For example, an empty ACL denies all
       permissions, but the server should allow the owner&#39;s SETATTR to
       succeed even though WRITE_ACL is implicitly denied.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In other cases, inheritance SHOULD take place, and no modifications to the ACL will happen. The mode attribute, if supported, MUST be as computed via the method described in Section 6.3.2, with the MODE4_SUID, MODE4_SGID, and MODE4_SVTX bits clear. If no inheritable ACEs exist on the parent directory, the rules for creating acl attributes are implementation defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他の例では、継承は行われるべきである、とACLへの変更は起こりません。 MODE4_SUID、MODE4_SGID、及びMODE4_SVTXビットのセクション6.3.2、明確に記載された方法を介して計算されたモード属性は、サポートされている場合でなければなりません。何の継承可能なACEが親ディレクトリに存在しない場合は、ACL属性を作成するための規則は、実装定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3.1. The Inherited ACL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.3.1。継承ACL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the object being created is not a directory, the inherited ACL SHOULD NOT inherit ACEs from the parent directory ACL unless the ACE4_FILE_INHERIT_FLAG is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
作成中のオブジェクトがディレクトリでない場合ACE4_FILE_INHERIT_FLAGが設定されていない限り、継承されたACLは親ディレクトリのACLからACEを継承すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the object being created is a directory, the inherited ACL should inherit all inheritable ACEs from the parent directory, i.e., those that have the ACE4_FILE_INHERIT_ACE or ACE4_DIRECTORY_INHERIT_ACE flag set. If the inheritable ACE has ACE4_FILE_INHERIT_ACE set, but ACE4_DIRECTORY_INHERIT_ACE is clear, the inherited ACE on the newly created directory MUST have the ACE4_INHERIT_ONLY_ACE flag set to prevent the directory from being affected by ACEs meant for non-directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
作成中のオブジェクトがディレクトリである場合は、継承されたACLは、親ディレクトリからACE4_FILE_INHERIT_ACEまたはACE4_DIRECTORY_INHERIT_ACEフラグが設定されていること、すなわち、それらをすべて継承可能なACEを継承する必要があります。継承ACEはACE4_FILE_INHERIT_ACEセットを持っていますが、ACE4_DIRECTORY_INHERIT_ACEがクリアされている場合は、新しく作成したディレクトリに継承されたACEは、ディレクトリ以外のために意味のACEに影響されることから、ディレクトリを防止するために設定ACE4_INHERIT_ONLY_ACEフラグを持たなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a new directory is created, the server MAY split any inherited ACE that is both inheritable and effective (in other words, that has neither ACE4_INHERIT_ONLY_ACE nor ACE4_NO_PROPAGATE_INHERIT_ACE set) into two ACEs -- one with no inheritance flags, and one with ACE4_INHERIT_ONLY_ACE set. This makes it simpler to modify the effective permissions on the directory without modifying the ACE that is to be inherited to the new directory&#39;s children.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無継承フラグと1、およびACE4_INHERIT_ONLY_ACEが設定された1  - 新しいディレクトリが作成されると、サーバーは、2つのACEに（どちらもACE4_INHERIT_ONLY_ACEもACE4_NO_PROPAGATE_INHERIT_ACEが設定されている他の言葉で、）継承可能かつ効果的である任意の継承されたACEを分割することができます。これは、単純に新しいディレクトリの子に継承されるACEを変更せずに、ディレクトリの有効なアクセス許可を変更することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. NFS Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. NFSサーバーの名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Server Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。サーバーの輸出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On a UNIX server, the namespace describes all the files reachable by pathnames under the root directory or &#34;/&#34;. On a Windows server, the namespace constitutes all the files on disks named by mapped disk letters. NFS server administrators rarely make the entire server&#39;s file system namespace available to NFS clients. More often, portions of the namespace are made available via an &#34;export&#34; feature. In previous versions of the NFS protocol, the root filehandle for each export is obtained through the MOUNT protocol; the client sends a string that identifies an object in the exported namespace, and the server returns the root filehandle for it. The MOUNT protocol supports an EXPORTS procedure that will enumerate the server&#39;s exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNIXサーバーでは、名前空間は、ルートディレクトリの下にパス名で到達可能なすべてのファイルを記述したり、「/」。 Windowsサーバでは、名前空間がマッピングされたディスクの文字で指定されたディスク上のすべてのファイルを構成しています。 NFSサーバーの管理者は、めったにNFSクライアントに、サーバー全体のファイルシステムの名前空間を利用可能にしません。多くの場合、名前空間の部分は、「エクスポート」機能を経由して利用できるようになります。 NFSプロトコルの旧バージョンでは、各エクスポートのルートファイルハンドルは、MOUNTプロトコルを介して得られます。クライアントは、エクスポートされた名前空間内のオブジェクトを識別する文字列を送信し、サーバはそれのために、ルートファイルハンドルを返します。 MOUNTプロトコルは、サーバの輸出を列挙しますEXPORTS手順をサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Browsing Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。ブラウズ輸出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol provides a root filehandle that clients can use to obtain filehandles for these exports via a multi-component LOOKUP. A common user experience is to use a graphical user interface (perhaps a file &#34;Open&#34; dialog window) to find a file via progressive browsing through a directory tree. The client must be able to move from one export to another export via single-component, progressive LOOKUP operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4プロトコルは、クライアントが多成分LOOKUPを介してこれらの輸出のためにファイルハンドルを取得するために使用することができ、ルートファイルハンドルを提供します。一般的なユーザーエクスペリエンスは、ディレクトリツリーをプログレッシブブラウジング経由でファイルを見つけるために、グラフィカル・ユーザー・インターフェース（おそらくファイル「開く」ダイアログ・ウィンドウ）を使用することです。クライアントは、単一成分、プログレッシブLOOKUP操作を介して別の輸出に1つのエクスポートから動くことができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This style of browsing is not well supported by the NFSv2 and NFSv3 protocols. The client expects all LOOKUP operations to remain within a single-server file system. For example, the device attribute will not change. This prevents a client from taking namespace paths that span exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブラウジングのこのスタイルは良くはNFSv2とNFSv3のプロトコルによってサポートされていません。クライアントは、すべてのLOOKUP操作は、単一サーバのファイルシステム内にとどまると予想しています。例えば、デバイスの属性が変更されません。これは、輸出にまたがる名前空間のパスを取ってからクライアントを防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An automounter on the client can obtain a snapshot of the server&#39;s namespace using the EXPORTS procedure of the MOUNT protocol. If it understands the server&#39;s pathname syntax, it can create an image of the server&#39;s namespace on the client. The parts of the namespace that are not exported by the server are filled in with a &#34;pseudo-file system&#34; that allows the user to browse from one mounted file system to another. There is a drawback to this representation of the server&#39;s namespace on the client: it is static. If the server administrator adds a new export, the client will be unaware of it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント上のオートマウンタは、MOUNTプロトコルのEXPORTS手順を使用して、サーバーの名前空間のスナップショットを取得することができます。それは、サーバのパス名の構文を理解している場合、それは、クライアント上のサーバーの名前空間の画像を作成することができます。サーバによってエクスポートされていない名前空間の部分は、ユーザが別のマウントされたファイル・システムから参照することができ、「擬似ファイルシステム」で充填されます。クライアント上のサーバーの名前空間のこの表現への欠点があります：それは静的です。サーバ管理者が新たな輸出を追加した場合、クライアントはそれに気づいていないだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Server Pseudo-File System
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。サーバー擬似ファイルシステム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4 servers avoid this namespace inconsistency by presenting all the exports within the framework of a single-server namespace. An NFSv4 client uses LOOKUP and READDIR operations to browse seamlessly from one export to another. Portions of the server namespace that are not exported are bridged via a &#34;pseudo-file system&#34; that provides a view of exported directories only. A pseudo-file system has a unique fsid and behaves like a normal, read-only file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4サーバーは、単一サーバーの名前空間の枠組みの中で、すべての輸出を提示することによって、この名前空間の矛盾を避けます。 NFSv4クライアントは、別のエクスポートからシームレスに閲覧することLOOKUPとREADDIR操作を使用しています。エクスポートされていないサーバーの名前空間の一部のみがエクスポートされたディレクトリのビューを提供し、「擬似ファイルシステム」を介してブリッジされます。擬似ファイルシステムは、ユニークなFSIDを持っており、通常、読み取り専用ファイルシステムのように動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Based on the construction of the server&#39;s namespace, it is possible that multiple pseudo-file systems may exist. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーの名前空間の建設に基づいて、複数の擬似ファイルシステムが存在する可能性があります。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
/a pseudo-file system /a/b real file system /a/b/c pseudo-file system /a/b/c/d real file system
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
/擬似ファイルシステム/ A / B実ファイルシステム/ A / B / C擬似ファイルシステム/ A / B / C / D実ファイルシステム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each of the pseudo-file systems are considered separate entities and therefore will have a unique fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
擬似ファイルシステムの各々は別個のものと考えられているため、ユニークなFSIDを持つことになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Multiple Roots
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4。複数のルーツ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The DOS and Windows operating environments are sometimes described as having &#34;multiple roots&#34;. File systems are commonly represented as disk letters. MacOS represents file systems as top-level names. NFSv4 servers for these platforms can construct a pseudo-file system above these root names so that disk letters or volume names are simply directory names in the pseudo-root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DOSとWindowsのオペレーティング環境は、時々「重根」を有すると記載されています。ファイルシステムは、一般的にディスクの文字として表されます。 MacOSのは、トップレベル名などのファイルシステムを表します。ディスクの文字またはボリューム名は、単に疑似ルートディレクトリ名になるように、これらのプラットフォーム用のNFSv4サーバは、これらのルート名の上の擬似ファイルシステムを構築することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. Filehandle Volatility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5。ファイルハンドルボラティリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The nature of the server&#39;s pseudo-file system is that it is a logical representation of file system(s) available from the server. Therefore, the pseudo-file system is most likely constructed dynamically when the server is first instantiated. It is expected that the pseudo-file system may not have an on-disk counterpart from which persistent filehandles could be constructed. Even though it is preferable that the server provide persistent filehandles for the pseudo-file system, the NFS client should expect that pseudo-file system filehandles are volatile. This can be confirmed by checking the associated &#34;fh_expire_type&#34; attribute for those filehandles in question. If the filehandles are volatile, the NFS client must be prepared to recover a filehandle value (e.g., with a multi-component LOOKUP) when receiving an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバの擬似ファイルシステムの性質は、それがサーバから利用可能なファイルシステム（複数可）の論理的な表現であるということです。そのため、擬似ファイルシステムは、最も可能性の高いサーバが最初にインスタンス化されるときに動的に構築されています。擬似ファイルシステムは永続的なファイルハンドルを構築することができたから、ディスク上の対応するものがないことが予想されます。それは、サーバが擬似ファイルシステムのための永続的なファイルハンドルを提供することが好ましいですが、NFSクライアントは、擬似ファイルシステムのファイルハンドルが揮発性であることを期待してください。これが問題になっているこれらのファイルハンドルに関連付けられた「fh_expire_type」属性をチェックすることで確認することができます。ファイルハンドルが揮発性である場合NFS4ERR_FHEXPIREDのエラーを受信した場合、NFSクライアントは、（多成分LOOKUPと例えば、）ファイルハンドル値を回復するために用意されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. Exported Root
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6。エクスポートされたルート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server&#39;s root file system is exported, one might conclude that a pseudo-file system is not needed. This would be wrong. Assume the following file systems on a server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーのルートファイルシステムがエクスポートされている場合は、一つは、擬似ファイルシステムが必要とされていないと結論することがあります。これは間違っているだろう。サーバー上の次のファイルシステムを想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
/ disk1 (exported) /a disk2 (not exported) /a/b disk3 (exported)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（エクスポート）/ DISK1（エクスポート）/ DISK2（エクスポートしない）/ A / BのDISK3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because disk2 is not exported, disk3 cannot be reached with simple LOOKUPs. The server must bridge the gap with a pseudo-file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DISK2はエクスポートされていないので、DISK3は簡単な検索で到達することはできません。サーバは、擬似ファイルシステムとのギャップを埋める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7. Mount Point Crossing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7。マウントポイントクロッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server file system environment may be constructed in such a way that one file system contains a directory that is &#39;covered&#39; or mounted upon by a second file system. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーのファイルシステム環境は、一つのファイルシステムが「カバー」や第2のファイルシステムによって上にマウントされたディレクトリを含むように構成してもよいです。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
/a/b (file system 1) /a/b/c/d (file system 2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
/ / B（ファイルシステム1）/ A / B / C / D（ファイルシステム2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The pseudo-file system for this server may be constructed to look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このサーバーの擬似ファイルシステムが見えるように構築することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
/ (placeholder/not exported) /a/b (file system 1) /a/b/c/d (file system 2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
/（プレースホルダ/エクスポートされません）/ A / B（ファイルシステム1）/ A / B / C / D（ファイルシステム2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is the server&#39;s responsibility to present the pseudo-file system that is complete to the client. If the client sends a LOOKUP request for the path &#34;/a/b/c/d&#34;, the server&#39;s response is the filehandle of the file system &#34;/a/b/c/d&#34;. In previous versions of the NFS protocol, the server would respond with the filehandle of directory &#34;/a/b/c/d&#34; within the file system &#34;/a/b&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントに完了している擬似ファイルシステムを提示するサーバーの責任です。クライアントは、パス &#34;/ A / B / C / D&#34; のLOOKUP要求を送信すると、サーバーの応答は、ファイルシステム &#34;/ A / B / C / D&#34; のファイルハンドルです。 NFSプロトコルの以前のバージョンでは、サーバーは、ファイルシステム「/ A / B」内のディレクトリ「/ A / B / C / D」のファイルハンドルで応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFS client will be able to determine if it crosses a server mount point by a change in the value of the &#34;fsid&#34; attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSクライアントは、サーバが「FSID」属性の値の変化により、マウントポイントを横断するかどうかを判断することができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8. Security Policy and Namespace Presentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8。セキュリティポリシーと名前空間プレゼンテーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because NFSv4 clients possess the ability to change the security mechanisms used, after determining what is allowed, by using SECINFO the server SHOULD NOT present a different view of the namespace based on the security mechanism being used by a client. Instead, it should present a consistent view and return NFS4ERR_WRONGSEC if an attempt is made to access data with an inappropriate security mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のクライアントが使用するセキュリティ・メカニズムを変更する機能を有しているため、許可されていることを決定した後、SECINFOを使用することにより、サーバは、クライアントによって使用されているセキュリティ・メカニズムに基づいて、名前空間の異なるビューを提示すべきではありません。代わりに、一貫性のあるビューを提示し、試行が不適切なセキュリティ・メカニズムを使用してデータにアクセスするために行われた場合NFS4ERR_WRONGSECを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If security considerations make it necessary to hide the existence of a particular file system, as opposed to all of the data within it, the server can apply the security policy of a shared resource in the server&#39;s namespace to components of the resource&#39;s ancestors. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティの考慮事項は、その中のすべてのデータとは対照的に、それは必要に応じて、特定のファイルシステムの存在を隠すために作る場合は、サーバーはリソースの祖先のコンポーネントに、サーバーの名前空間内の共有リソースのセキュリティポリシーを適用することができます。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /                       (placeholder/not exported)
       /a/b                    (file system 1)
       /a/b/MySecretProject    (file system 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The /a/b/MySecretProject directory is a real file system and is the shared resource. Suppose the security policy for /a/b/ MySecretProject is Kerberos with integrity and it is desired to limit knowledge of the existence of this file system. In this case, the server should apply the same security policy to /a/b. This allows for knowledge of the existence of a file system to be secured when desirable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
/ A / B / MySecretProjectディレクトリには、実際のファイルシステムであり、共有リソースです。 / A / B / MySecretProjectのセキュリティポリシーは、整合性とKerberosのであり、このファイルシステムの存在の知識を制限することが望まれていると仮定します。この場合、サーバは/ A / Bに同じセキュリティポリシーを適用する必要があります。これは望ましい確保するファイルシステムの存在の知識が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the case of the use of multiple, disjoint security mechanisms in the server&#39;s resources, applying that sort of policy would result in the higher-level file system not being accessible using any security flavor. Therefore, that sort of configuration is not compatible with hiding the existence (as opposed to the contents) from clients using multiple disjoint sets of security flavors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の使用の場合には、ポリシーの並べ替えを適用し、サーバーのリソースでばらばらセキュリティメカニズムは、すべてのセキュリティ風味を使用してアクセスされていない上位レベルのファイルシステムにつながります。したがって、構成のソートは、セキュリティ風味の複数の互いに素な集合を使用して、クライアントから（コンテンツとは対照的に）の存在を隠すと互換性がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In other circumstances, a desirable policy is for the security of a particular object in the server&#39;s namespace to include the union of all security mechanisms of all direct descendants. A common and convenient practice, unless strong security requirements dictate otherwise, is to make the entire pseudo-file system accessible by all of the valid security mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他の状況では、望ましい政策は、すべての直接の子孫のすべてのセキュリティ・メカニズムの組合を含むように、サーバーの名前空間内の特定のオブジェクトのセキュリティのためです。一般的で便利な練習は、強力なセキュリティ要件がそう指示しない限り、有効なセキュリティメカニズムのすべてがアクセスできる全体の擬似ファイルシステムを作成することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where there is concern about the security of data on the network, clients should use strong security mechanisms to access the pseudo-file system in order to prevent man-in-the-middle attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワーク上のデータのセキュリティについて懸念がある場合、クライアントは、man-in-the-middle攻撃を防ぐために、擬似ファイルシステムにアクセスするための強力なセキュリティ・メカニズムを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Multi-Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.マルチサーバーの名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4 supports attributes that allow a namespace to extend beyond the boundaries of a single server. It is RECOMMENDED that clients and servers support construction of such multi-server namespaces. Use of such multi-server namespaces is optional, however, and for many purposes, single-server namespaces are perfectly acceptable. Use of multi-server namespaces can provide many advantages, however, by separating a file system&#39;s logical position in a namespace from the (possibly changing) logistical and administrative considerations that result in particular file systems being located on particular servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4では、名前空間は、単一のサーバーの境界を超えて拡張することを可能にする属性をサポートしています。クライアントとサーバは、このようなマルチサーバの名前空間の構築をサポートすることが推奨されます。こうしたマルチサーバの名前空間の使用はしかし、オプションであり、多くの目的のために、単一サーバーの名前空間は完全に許容されています。マルチサーバの名前空間を使用すると、特定のサーバー上に配置されている特定のファイルシステムになる（おそらく変更）物流や行政の配慮から、名前空間にファイルシステムの論理的な位置を分離することによって、しかし、多くの利点を提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Location Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。場所属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4 contains RECOMMENDED attributes that allow file systems on one server to be associated with one or more instances of that file system on other servers. These attributes specify such file system instances by specifying a server address target (as either a DNS name representing one or more IP addresses, or a literal IP address), together with the path of that file system within the associated single-server namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4では1台のサーバー上のファイル・システムは、他のサーバー上のファイルシステムの1つ以上のインスタンスに関連付けることができるように推奨属性が含まれています。これらの属性は一緒に関連付けられている単一サーバーの名前空間内のそのファイルシステムのパスと、（1つまたは複数のIPアドレスを表すDNS名、またはリテラルIPアドレスのいずれかのような）サーバー・アドレス・ターゲットを指定して、ファイル・システム・インスタンスを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fs_locations RECOMMENDED attribute allows specification of the file system locations where the data corresponding to a given file system may be found.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fs_位置推奨属性は、特定のファイルシステムに対応するデータを見つけることができるファイルシステムの場所の指定を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. File System Presence or Absence
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。システムの有無をファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A given location in an NFSv4 namespace (typically but not necessarily a multi-server namespace) can have a number of file system instance locations associated with it via the fs_locations attribute. There may also be an actual current file system at that location, accessible via normal namespace operations (e.g., LOOKUP). In this case, the file system is said to be &#34;present&#34; at that position in the namespace, and clients will typically use it, reserving use of additional locations specified via the location-related attributes to situations in which the principal location is no longer available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4の名前空間（典型的には必ずしも必要ではないが、マルチサーバの名前空間）内の所定の位置はfs_位置の属性を介して、それに関連するファイル・システム・インスタンスの位置の数を有することができます。また、（例えば、参照）、その位置で通常名前空間操作を介してアクセス可能な実際の現在のファイルシステムが存在してもよいです。この場合、ファイルシステムは、名前空間内のその位置で「存在」であると言われ、そしてクライアントは、典型的には、主位置は、もはやである状況に位置関連の属性を介して指定された追加の場所の使用を予約する、それを使用します利用可能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When there is no actual file system at the namespace location in question, the file system is said to be &#34;absent&#34;. An absent file system contains no files or directories other than the root. Any reference to it, except to access a small set of attributes useful in determining alternative locations, will result in an error, NFS4ERR_MOVED. Note that if the server ever returns the error NFS4ERR_MOVED, it MUST support the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
問題のネームスペースの場所での実際のファイルシステムが存在しない場合、ファイルシステムは、「不在」と言われています。不在のファイルシステムは、ルート以外のファイルやディレクトリが含まれていません。別の場所を決定するのに有用な属性の小さなセットにアクセスすることを除いて、それへの参照は、エラー、NFS4ERR_MOVEDをもたらすであろう。サーバーが今までエラーNFS4ERR_MOVEDを返した場合、それはfs_位置の属性をサポートしなければならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the error name suggests that we have a case of a file system that once was present, and has only become absent later, this is only one possibility. A position in the namespace may be permanently absent with the set of file system(s) designated by the location attributes being the only realization. The name NFS4ERR_MOVED reflects an earlier, more limited conception of its function, but this error will be returned whenever the referenced file system is absent, whether it has moved or simply never existed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エラー名は、我々がかつて存在したファイルシステムのケースを持っていることを示唆している、とだけ後で不在となっているが、これは唯一の可能性です。名前空間内の位置にのみ実現される場所属性で指定されたファイル・システム（単数または複数）のセットと恒久的に存在しなくてもよいです。名前はNFS4ERR_MOVEDは、その機能の以前のバージョンでは、より限定された概念を反映しているが、参照されるファイルシステムは、それが移動したり、単に存在しなかったかどうか、存在しないときには、このエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Except in the case of GETATTR-type operations (to be discussed later), when the current filehandle at the start of an operation is within an absent file system, that operation is not performed and the error NFS4ERR_MOVED is returned, to indicate that the file system is absent on the current server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETATTR型操作の場合を除いて運転開始時の現在のファイルハンドルが存在しないファイル・システム内にある場合、その操作が行われないとNFS4ERR_MOVEDが返されるエラーは、ファイルがあることを示すために、（後述します）システムは、現在のサーバー上に存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because a GETFH cannot succeed if the current filehandle is within an absent file system, filehandles within an absent file system cannot be transferred to the client. When a client does have filehandles within an absent file system, it is the result of obtaining them when the file system was present, and having the file system become absent subsequently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルは、存在しないファイルシステム内にある場合GETFHが成功することはできませんので、不在のファイルシステム内のファイルハンドルをクライアントに転送することはできません。クライアントは、存在しないファイルシステム内のファイルハンドルを持っている場合は、ファイルシステムが存在していたときにそれらを取得し、その後不在となったファイルシステムを持つことの結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It should be noted that because the check for the current filehandle being within an absent file system happens at the start of every operation, operations that change the current filehandle so that it is within an absent file system will not result in an error. This allows such combinations as PUTFH-GETATTR and LOOKUP-GETATTR to be used to get attribute information, particularly location attribute information, as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルは、存在しないファイルシステム内にあることのチェックは、すべての操作の開始時に起こるので、それがないファイルシステム内にあるように、現在のファイルハンドルを変更する操作はエラーになりませんことに留意すべきです。これは、後述するようにPUTFH-GETATTRおよびLOOKUP、GETATTRのような組み合わせが、特に位置属性情報を、属性情報を取得するために使用されることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Getting Attributes for an Absent File System
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3。不在ファイルシステム用の属性の取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a file system is absent, most attributes are not available, but it is necessary to allow the client access to the small set of attributes that are available, and most particularly that which gives information about the correct current locations for this file system, fs_locations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムが存在しない場合、ほとんどの属性は利用できませんが、利用可能な属性の小さなセットへのクライアントアクセスを許可する必要があり、そして最も特に、このファイルシステムの正しい現在の場所、fs_位置に関する情報を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.1. GETATTR within an Absent File System
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.1。不在ファイルシステム内のGETATTR
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As mentioned above, an exception is made for GETATTR in that attributes may be obtained for a filehandle within an absent file system. This exception only applies if the attribute mask contains at least the fs_locations attribute bit, which indicates that the client is interested in a result regarding an absent file system. If it is not requested, GETATTR will result in an NFS4ERR_MOVED error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上述のようにそれが存在しないファイルシステム内のファイルハンドルのために得ることができる属性では、例外がGETATTRのために作られています。属性マスクは、少なくともfs_位置は、ビット属性が含まれている場合、この例外は、クライアントが存在しないファイルシステムについての結果に興味があることを示している、適用されます。それが要求されていない場合は、GETATTRはNFS4ERR_MOVEDエラーになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a GETATTR is done on an absent file system, the set of supported attributes is very limited. Many attributes, including those that are normally REQUIRED, will not be available on an absent file system. In addition to the fs_locations attribute, the following attributes SHOULD be available on absent file systems. In the case of RECOMMENDED attributes, they should be available at least to the same degree that they are available on present file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETATTRが不在のファイルシステム上で実行された場合、サポートされる属性のセットは非常に限られています。通常必要とされるものを含む多くの属性は、存在しないファイルシステム上で使用できなくなります。 fs_位置の属性に加えて、次の属性は存在しないファイルシステム上で利用可能であるべきです。推奨属性の場合、彼らは現在のファイルシステム上で利用可能であること、少なくとも同じ程度に利用可能であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fsid: This attribute should be provided so that the client can determine file system boundaries, including, in particular, the boundary between present and absent file systems. This value must be different from any other fsid on the current server and need have no particular relationship to fsids on any particular destination to which the client might be directed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FSID：クライアントは、ファイルシステムの境界を決定することができるように、この属性は、特に、を含む、現在および不在のファイルシステムとの間の境界を提供する必要があります。この値は、現行のサーバー上の他のFSIDと異なることと、クライアントが向けられる可能性があるに任意の特定の宛先にfsidsには特に関係がない必要なければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
mounted_on_fileid: For objects at the top of an absent file system, this attribute needs to be available. Since the fileid is within the present parent file system, there should be no need to reference the absent file system to provide this information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
mounted_on_fileid：不在のファイルシステムの一番上にあるオブジェクトの場合、この属性は利用できるようにする必要があります。 FILEID本親ファイル・システム内にあるので、この情報を提供するために存在しないファイルシステムを参照する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Other attributes SHOULD NOT be made available for absent file systems, even when it is possible to provide them. The server should not assume that more information is always better and should avoid gratuitously providing additional information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他の属性は、それらを提供することが可能である場合でも、不在のファイルシステムのために利用可能行うべきではありません。サーバは、より多くの情報が常に優れていることを前提とすべきではなく、付加的な情報を提供する無償避けるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a GETATTR operation includes a bitmask for the attribute fs_locations, but where the bitmask includes attributes that are not supported, GETATTR will not return an error but will return the mask of the actual attributes supported with the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETATTR操作はビットマスクがサポートされていない属性が含まれ、属性fs_位置のためのビットマスクが、が含まれている場合、GETATTRはエラーを返しませんが、その結果でサポート実際の属性のマスクを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Handling of VERIFY/NVERIFY is similar to GETATTR in that if the attribute mask does not include fs_locations the error NFS4ERR_MOVED will result. It differs in that any appearance in the attribute mask of an attribute not supported for an absent file system (and note that this will include some normally REQUIRED attributes) will also cause an NFS4ERR_MOVED result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VERIFY / NVERIFYの取り扱いは、属性マスクがエラーNFS4ERR_MOVEDが発生しますfs_位置が含まれていない場合というのでGETATTRに似ています。それは存在しないファイルシステムではサポートされていない属性の属性マスク（これは、いくつかの通常必要な属性が含まれることに注意）のいずれかの外見もNFS4ERR_MOVED結果を引き起こすことで異なっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2. READDIR and Absent File Systems
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.2。 READDIRと不在ファイルシステム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A READDIR performed when the current filehandle is within an absent file system will result in an NFS4ERR_MOVED error, since, unlike the case of GETATTR, no such exception is made for READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルがGETATTRの場合とは異なり、そのような例外がREADDIRのために作られていない、ので、NFS4ERR_MOVEDエラーになります存在しないファイル・システム内にある場合READDIRを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Attributes for an absent file system may be fetched via a READDIR for a directory in a present file system, when that directory contains the root directories of one or more absent file systems. In this case, the handling is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
存在しないファイルシステムの属性は、そのディレクトリが1つの以上存在しないファイルシステムのルートディレクトリを含む場合、本ファイルシステム内のディレクトリのREADDIRを介してフェッチされてもよいです。この場合、以下のように、取り扱いは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the attribute set requested includes fs_locations, then the fetching of attributes proceeds normally, and no NFS4ERR_MOVED indication is returned even when the rdattr_error attribute is requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O要求された属性セットはfs_位置が含まれている場合、属性の取り込みが正常に進行し、rdattr_error属性が要求されたときに何NFS4ERR_MOVED指示があっても返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the attribute set requested does not include fs_locations, then if the rdattr_error attribute is requested, each directory entry for the root of an absent file system will report NFS4ERR_MOVED as the value of the rdattr_error attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求された属性セットがfs_位置が含まれていない場合はrdattr_error属性が要求された場合、O、そして、不在のファイルシステムのルートの各ディレクトリエントリはrdattr_error属性の値としてNFS4ERR_MOVEDを報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the attribute set requested does not include either of the attributes fs_locations or rdattr_error, then the occurrence of the root of an absent file system within the directory will result in the READDIR failing with an NFS4ERR_MOVED error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求された属性セットに属性fs_位置やrdattr_errorのいずれかが含まれていない場合は、O、そのディレクトリ内に存在し、ファイルシステムのルートの発生がNFS4ERR_MOVEDエラーで失敗READDIRになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The unavailability of an attribute because of a file system&#39;s absence, even one that is ordinarily REQUIRED, does not result in any error indication. The set of attributes returned for the root directory of the absent file system in that case is simply restricted to those actually available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
なぜなら、ファイルシステムの不在の属性が利用できない、通常必要な場合でも1 O、任意のエラー表示にはなりません。その場合には存在しないファイルシステムのルートディレクトリのために返される属性のセットは、単に実際に利用可能なものに限定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. Uses of Location Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4。位置情報を使用しています
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The location-bearing attribute of fs_locations provides, together with the possibility of absent file systems, a number of important facilities in providing reliable, manageable, and scalable data access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fs_位置の位置ベアリング属性が一緒に存在しないファイルシステムの可能性、信頼性管理、およびスケーラブルなデータアクセスを提供する上で重要な施設の数で、提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a file system is present, these attributes can provide alternative locations, to be used to access the same data, in the event of server failures, communications problems, or other difficulties that make continued access to the current file system impossible or otherwise impractical. Under some circumstances, multiple alternative locations may be used simultaneously to provide higher-performance access to the file system in question. Provision of such alternative locations is referred to as &#34;replication&#34;, although there are cases in which replicated sets of data are not in fact present and the replicas are instead different paths to the same data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムが存在する場合、これらの属性は、サーバの障害、コミュニケーションの問題、または不可能あるいは実用的でない現在のファイルシステムへの継続的なアクセスを行う他の困難の場合には、同じデータにアクセスするために使用されるように、代わりの場所を提供することができます。いくつかの状況下では、複数の代替の場所は、問題のファイルシステムへの高性能なアクセスを提供するために同時に使用することができます。データのセットは、実際には存在しないとレプリカではなく、同じデータに対して異なる経路で複製される場合があるが、そのような代替ロケーションの提供は、「複製」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a file system is present and subsequently becomes absent, clients can be given the opportunity to have continued access to their data, at an alternative location. Transfer of the file system contents to the new location is referred to as &#34;migration&#34;. See Section 8.4.2 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムが存在し、その後に不在となった場合、クライアントは別の場所で、そのデータへのアクセスを続けているの機会を与えることができます。新しい場所へのファイルシステムの内容の転送は、「移行」と呼ばれています。詳細については、8.4.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alternative locations may be physical replicas of the file system data or alternative communication paths to the same server or, in the case of various forms of server clustering, another server providing access to the same physical file system. The client&#39;s responsibilities in dealing with this transition depend on the specific nature of the new access path as well as how and whether data was in fact migrated. These issues will be discussed in detail below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代替的な場所は、物理的に同じサーバーにファイルシステムデータまたは代替の通信パスのレプリカまたは、サーバクラスタリングの種々の形態の場合には、同一の物理ファイルシステムへのアクセスを提供する別のサーバであってもよいです。この移行に対処するクライアントの責任は、特定の新しいアクセス・パスの性質だけでなく、どのようにして、データが実際に移行されたかどうかに依存します。これらの問題は、以下に詳細に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where a file system was not previously present, specification of file system location provides a means by which file systems located on one server can be associated with a namespace defined by another server, thus allowing a general multi-server namespace facility. A designation of such a location, in place of an absent file system, is called a &#34;referral&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムが以前に存在しなかった場合、ファイルシステムの場所の指定は、1台のサーバー上にあるファイルシステムは、このように一般的なマルチサーバのネームスペースの機能を可能にする、別のサーバによって定義された名前空間に関連付けすることができる手段を提供します。そのような場所の指定は、存在しないファイルシステムの代わりに、「照会」と呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because client support for location-related attributes is OPTIONAL, a server may (but is not required to) take action to hide migration and referral events from such clients, by acting as a proxy, for example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場所関連の属性のためのクライアントのサポートはオプションであるため、サーバーは、例えば、プロキシとして機能することによって、このようなクライアントからの移行と紹介イベントを非表示にする行動を取る（ただし、する必要はありません）があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.1. File System Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.1。システムのレプリケーションファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fs_locations attribute provides alternative locations, to be used to access data in place of, or in addition to, the current file system instance. On first access to a file system, the client should obtain the value of the set of alternative locations by interrogating the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fs_位置の代わりにデータにアクセスするために使用されるように、代替の場所を提供し、または現在のファイル・システム・インスタンスに加えて属性。ファイルシステムへの最初のアクセスでは、クライアントはfs_位置の属性を問い合わせることによって、代替場所のセットの値を取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the event that server failures, communications problems, or other difficulties make continued access to the current file system impossible or otherwise impractical, the client can use the alternative locations as a way to get continued access to its data. Multiple locations may be used simultaneously, to provide higher performance through the exploitation of multiple paths between client and target file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバの障害、コミュニケーションの問題、または他の困難は、現在のファイルシステムへの継続的なアクセスが不可能あるいは実用的でないという場合には、クライアントはそのデータへの継続的なアクセスを取得する方法として、代替場所を使用することができます。複数の場所は、クライアントとターゲット・ファイル・システムとの間の複数のパスの利用を介して、より高い性能を提供するために、同時に使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multiple server addresses, whether they are derived from a single entry with a DNS name representing a set of IP addresses or from multiple entries each with its own server address, may correspond to the same actual server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それらは、それ自身のサーバアドレスと各IPアドレスの組を表すDNS名を持つ単一のエントリまたは複数のエントリから誘導されるかどうか複数のサーバアドレスは、同じ実際のサーバに対応することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2. File System Migration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2。ファイルシステムへの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a file system is present and becomes absent, clients can be given the opportunity to have continued access to their data, at an alternative location, as specified by the fs_locations attribute. Typically, a client will be accessing the file system in question, get an NFS4ERR_MOVED error, and then use the fs_locations attribute to determine the new location of the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムが存在し、不在になるとfs_位置の属性で指定され、クライアントは、別の場所で、そのデータへの継続的なアクセスを持ってする機会を与えることができます。一般的に、クライアントは、問題のファイルシステムにアクセスすることNFS4ERR_MOVEDエラーを取得し、その後、fs_位置は、データの新しい位置を決定するために属性を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Such migration can be helpful in providing load balancing or general resource reallocation. The protocol does not specify how the file system will be moved between servers. It is anticipated that a number of different server-to-server transfer mechanisms might be used, with the choice left to the server implementer. The NFSv4 protocol specifies the method used to communicate the migration event between client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような移行は、負荷分散や、一般的なリソースの再配分を提供するのに役立つことができます。プロトコルは、ファイルシステムがサーバ間で移動する方法を指定しません。異なるサーバー間の転送メカニズムの数は、サーバの実装者に委ね選択肢で、使用されるかもしれないことが予想されます。 NFSv4プロトコルは、クライアントとサーバとの間の移行イベントを通信するために使用される方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an alternative location is designated as the target for migration, it must designate the same data. Where file systems are writable, a change made on the original file system must be visible on all migration targets. Where a file system is not writable but represents a read-only copy (possibly periodically updated) of a writable file system, similar requirements apply to the propagation of updates. Any change visible in the original file system must already be effected on all migration targets, to avoid any possibility that a client, in effecting a transition to the migration target, will see any reversion in file system state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の場所を移動するための対象として指定された場合には、同じデータを指定しなければなりません。ファイルシステムが書き込み可能である場合、元のファイルシステム上で行われた変更は、すべての移行のターゲットに表示されなければなりません。ファイルシステムが書き込み可能ではありませんが、書き込み可能なファイルシステムの読み取り専用コピー（おそらく定期的に更新）を表し、同様の要件は、更新の伝播に適用されます。元のファイルシステムに見える変更はすでにクライアントは、移行先への移行を行うには、ファイルシステムの状態のいずれかの復帰を参照することを任意の可能性を回避するために、すべての移行対象に行なわれなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.3. Referrals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.3。紹介
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Referrals provide a way of placing a file system in a location within the namespace essentially without respect to its physical location on a given server. This allows a single server or a set of servers to present a multi-server namespace that encompasses file systems located on multiple servers. Some likely uses of this include establishment of site-wide or organization-wide namespaces, or even knitting such together into a truly global namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
照会は、指定されたサーバー上の物理的位置に関係なく、本質的に名前空間内の場所にファイルシステムを配置する方法を提供します。これは、単一のサーバまたはサーバのセットは、複数のサーバー上にあるファイル・システムを含むマルチサーバーの名前空間を提示することができます。このいくつかの可能性の高い用途は、サイト全体または組織全体のネームスペース、あるいは真のグローバル名前空間に一緒に、このような編みの確立が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Referrals occur when a client determines, upon first referencing a position in the current namespace, that it is part of a new file system and that the file system is absent. When this occurs, typically by receiving the error NFS4ERR_MOVED, the actual location or locations of the file system can be determined by fetching the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが判断した場合紹介は、新しいファイルシステムの一部であり、ファイルシステムが存在しないことをことを、最初に現在の名前空間での位置を参照すると、発生します。これが発生すると、典型的には、エラーNFS4ERR_MOVEDを受信することによって、ファイルシステムの実際の位置または位置はfs_位置の属性を取り出すことによって決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The location-related attribute may designate a single file system location or multiple file system locations, to be selected based on the needs of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
位置関連属性は、クライアントのニーズに基づいて選択される、単一のファイルシステムの場所または複数のファイルシステムの場所を指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Use of multi-server namespaces is enabled by NFSv4 but is not required. The use of multi-server namespaces and their scope will depend on the applications used and system administration preferences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチサーバーの名前空間の使用が可能なNFSv4で有効になっていますが、必須ではありません。マルチサーバの名前空間とその範囲の使用は、使用するアプリケーションやシステム管理の好みに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multi-server namespaces can be established by a single server providing a large set of referrals to all of the included file systems. Alternatively, a single multi-server namespace may be administratively segmented with separate referral file systems (on separate servers) for each separately administered portion of the namespace. The top-level referral file system or any segment may use replicated referral file systems for higher availability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチサーバの名前空間が含まれるファイルシステムのすべてに紹介の大規模なセットを提供する単一のサーバによって確立することができます。あるいは、単一のマルチサーバの名前空間は、名前空間管理のそれぞれ別々に投与するための部分（別のサーバー上の）別リファーラルファイルシステムに分割することができます。トップレベルのリファーラルファイルシステムまたは任意のセグメントは、より高い可用性のために複製リファーラルファイルシステムを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Generally, multi-server namespaces are for the most part uniform, in that the same data made available to one client at a given location in the namespace is made available to all clients at that location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に、マルチサーバの名前空間は、その名前空間内の指定された場所にあるクライアントが利用できるように同じデータがその場所ですべてのクライアントで使用できるようになり、大部分の均一なためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. Location Entries and Server Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5。場所エントリとサーバのアイデンティティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As mentioned above, a single location entry may have a server address target in the form of a DNS name that may represent multiple IP addresses, while multiple location entries may have their own server address targets that reference the same server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上述したように、複数の位置のエントリが同じサーバを参照する独自のサーバ・アドレス・ターゲットを有することができる、単一の位置エントリは、複数のIPアドレスを表すことができるDNS名の形式でサーバアドレスターゲットを有していてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When multiple addresses for the same server exist, the client may assume that for each file system in the namespace of a given server network address, there exist file systems at corresponding namespace locations for each of the other server network addresses. It may do this even in the absence of explicit listing in fs_locations. Such corresponding file system locations can be used as alternative locations, just as those explicitly specified via the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じサーバに対して複数のアドレスが存在する場合、クライアントが特定のサーバのネットワーク・アドレスの名前空間内の各ファイルシステムのためにそれをとることができる、他のサーバのネットワーク・アドレスのそれぞれについて、名前空間の対応する位置にファイルシステムが存在します。それも、fs_位置での明示的なリストが存在しない場合に、これを行うことがあります。このような対応するファイルシステムの場所は、単に明示的fs_位置の属性で指定されたものとして、代替場所として使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a single location entry designates multiple server IP addresses, the client should choose a single one to use. When two server addresses are designated by a single location entry and they correspond to different servers, this normally indicates some sort of misconfiguration, and so the client should avoid using such location entries when alternatives are available. When they are not, clients should pick one of the IP addresses and use it, without using others that are not directed to the same server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一の場所のエントリは、複数のサーバーのIPアドレスを指定した場合、クライアントが使用する単一のものを選択する必要があります。 2つのサーバーアドレスが単一の場所のエントリで指定された、彼らは別のサーバーに対応している場合、これは通常、設定ミスのいくつかの並べ替えを示し、そのクライアントは、選択肢が用意されていたときに、そのような場所のエントリを使用しないでください。そうでない場合は、クライアントがIPアドレスのいずれかを選ぶ必要がありますし、同じサーバーに送られていない他の人を使用せずに、それを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. Additional Client-Side Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6。追加のクライアント側の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When clients make use of servers that implement referrals, replication, and migration, care should be taken that a user who mounts a given file system that includes a referral or a relocated file system continues to see a coherent picture of that user-side file system despite the fact that it contains a number of server-side file systems that may be on different servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが紹介を実装するサーバの使用、複製、および移行を行う場合は、注意が紹介や再配置、ファイルシステムが含まれ、指定されたファイルシステムをマウントし、ユーザがそのユーザ側のファイルシステムのコヒーレントな絵を見るために続けていることを注意する必要がありますそれは別のサーバー上にあるサーバー側のファイルシステムの数が含まれているという事実にもかかわらず。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One important issue is upward navigation from the root of a server-side file system to its parent (specified as &#34;..&#34; in UNIX), in the case in which it transitions to that file system as a result of referral, migration, or a transition as a result of replication. When the client is at such a point, and it needs to ascend to the parent, it must go back to the parent as seen within the multi-server namespace rather than sending a LOOKUPP operation to the server, which would result in the parent within that server&#39;s single-server namespace. In order to do this, the client needs to remember the filehandles that represent such file system roots and use these instead of issuing a LOOKUPP operation to the current server. This will allow the client to present to applications a consistent namespace, where upward navigation and downward navigation are consistent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一つの重要な問題は、上向きの親にサーバ側のファイルシステムのルートからのナビゲーション（UNIXで「..」として指定された）、それは照会の結果として、そのファイルシステムに移行する場合には、移行、またはあります複製の結果として推移。クライアントは、このような点にある、それは親に上昇する必要がある場合、それは親の中につながるというサーバにLOOKUPP操作を送信するよりも、マルチサーバーの名前空間の中に見られるように、親に戻って行かなければなりませんそのサーバーの単一サーバーの名前空間。これを行うためには、クライアントは、ファイルシステムのルートを表すファイルハンドルを覚えているし、代わりに現在のサーバーにLOOKUPP操作を発行するこれらを使用する必要があります。これは、クライアントがアプリケーションに上向きと下向きのナビゲーションナビゲーションが一貫している一貫性のある名前空間を提示することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another issue concerns refresh of referral locations. When referrals are used extensively, they may change as server configurations change. It is expected that clients will cache information related to traversing referrals so that future client-side requests are resolved locally without server communication. This is usually rooted in client-side name lookup caching. Clients should periodically purge this data for referral points in order to detect changes in location information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もう一つの問題の懸念が紹介場所のリフレッシュ。紹介が広く使用されている場合は、サーバーの構成が変化するように、彼らは変更されることがあります。将来のクライアント側の要求がサーバ通信せずにローカルで解決されるように、クライアントが横断紹介に関連する情報をキャッシュすることが期待されます。これは通常、クライアント側の名前検索のキャッシュに根ざしています。クライアントは、定期的に位置情報の変化を検出するために、紹介ポイントについては、このデータを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A potential problem exists if a client were to allow an open-owner to have state on multiple file systems on a server, in that it is unclear how the sequence numbers associated with open-owners are to be dealt with, in the event of transparent state migration. A client can avoid such a situation if it ensures that any use of an open-owner is confined to a single file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、オープン所有者に関連付けられたシーケンス番号が透明の場合には、扱うことになっているかは不明であるという点でオープン所有者は、サーバー上の複数のファイルシステム上の状態を持つことができるようにした場合の潜在的な問題が存在します状態移行。それはオープン所有者の任意の使用は、単一のファイルシステムに限定されることを保証した場合、クライアントは、このような事態を回避することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server MAY decline to migrate state associated with open-owners that span multiple file systems. In cases in which the server chooses not to migrate such state, the server MUST return NFS4ERR_BAD_STATEID when the client uses those stateids on the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、複数のファイルシステムにまたがるオープン所有者に関連付けられている状態を移行するために低下する可能性があります。クライアントは、新しいサーバー上でそれらのstateidsを使用する場合、サーバーがそのような状態に移行しないことを選択した場合には、サーバがNFS4ERR_BAD_STATEIDを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MUST return NFS4ERR_STALE_STATEID when the client uses those stateids on the old server, regardless of whether migration has occurred or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは関係なく、移行が発生したかどうかのか、古いサーバー上でこれらのstateidsを使用する場合、サーバーはNFS4ERR_STALE_STATEIDを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. Effecting File System Referrals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7。ファイルシステムの紹介を行います
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Referrals are effected when an absent file system is encountered and one or more alternative locations are made available by the fs_locations attribute. The client will typically get an NFS4ERR_MOVED error, fetch the appropriate location information, and proceed to access the file system on a different server, even though it retains its logical position within the original namespace. Referrals differ from migration events in that they happen only when the client has not previously referenced the file system in question (so there is nothing to transition). Referrals can only come into effect when an absent file system is encountered at its root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不在のファイルシステムが遭遇され、1つの以上の代替場所がfs_位置の属性によって提供されるときの紹介が行われています。クライアントは一般的に、それは、元の名前空間内のその論理的位置を保持していても、NFS4ERR_MOVEDエラーを取得し、適切な位置情報を取得し、別のサーバー上のファイルシステムにアクセスすることを進めてまいります。紹介は、彼らは、クライアントが以前に問題のファイルシステムを参照していないときにのみ起こることで、移行イベント異なる（その移行には何もありません）。不在のファイルシステムがそのルートに遭遇したときに、紹介にのみ発効することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The examples given in the sections below are somewhat artificial in that an actual client will not typically do a multi-component lookup but will have cached information regarding the upper levels of the name hierarchy. However, these example are chosen to make the required behavior clear and easy to put within the scope of a small number of requests, without getting unduly into details of how specific clients might choose to cache things.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のセクションで与えられた例は、実際のクライアントは、通常、多成分の検索を行うことはありませんが、名前の階層の上位レベルに関する情報をキャッシュしているということで、やや人工的です。しかし、これらの例は、物事をキャッシュすることを選択するかもしれない方法特定のクライアントの詳細を不当に取得せずに、リクエストの数が少ないの範囲内に置くために必要な行動を明確かつ簡単にするために選択されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7.1. Referral Example (LOOKUP)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7.1。紹介例（LOOKUP）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let us suppose that the following COMPOUND is sent in an environment in which /this/is/the/path is absent from the target server. This may be for a number of reasons. It may be the case that the file system has moved, or it may be the case that the target server is functioning mainly, or solely, to refer clients to the servers on which various file systems are located.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは、以下の化合物は、これは/である/ /パスは、ターゲットサーバーから不在である/環境に送られているとしましょう。これは、いくつかの理由のためのものであってもよいです。これは、ファイルシステムが移動した場合であってもよいし、ターゲット・サーバーは、さまざまなファイル・システムが配置されているサーバにクライアントを参照するために、主に、または単に機能している場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O putarutaphaha
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;この&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUPは &#34;あります&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOOKUP O &#34;&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;path&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OのLOOKUP &#34;パス&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o GETATTR(fsid, fileid, size, time_modify)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O GETATTR（FSID、FILEID、サイズ、time_modify）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Under the given circumstances, the following will be the result:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
与えられた状況下では、以下の結果になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o PUTROOTFH --&gt; NFS_OK. The current fh is now the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O PUTROOTFH  - &gt; NFS_OK。現在のFHは現在、疑似FSのルートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;この&#34;  - &gt; NFS_OK。現在のFH /このためのものであり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&gt; NFS_OK  -  O LOOKUP &#34;です&#34;。現在のFHは、/ /これをであり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;&#34;  - &gt; NFS_OK。現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;path&#34; --&gt; NFS_OK. The current fh is for /this/is/the/path and is within a new, absent file system, but ... the client will never see the value of that fh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;パス&#34;  - &gt; NFS_OK。現在のFHは、この/です/ /パス/のためのものであり、新たに、不在のファイルシステム内にある、しかし...クライアントは、そのFHの値を参照することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o GETFH --&gt; NFS4ERR_MOVED. Fails, because the current fh is in an absent file system at the start of the operation and the specification makes no exception for GETFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O GETFH  - &gt; NFS4ERR_MOVED。現在のFHは、操作の開始時に存在しないファイルシステムであり、仕様はGETFHための例外をしないので、失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o GETATTR(fsid, fileid, size, time_modify). Not executed, because the failure of the GETFH stops the processing of the COMPOUND.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O GETATTR（FSID、FILEID、サイズ、time_modify）。 GETFHの障害が化合物の処理を停止するため、実行されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given the failure of the GETFH, the client has the job of determining the root of the absent file system and where to find that file system, i.e., the server and path relative to that server&#39;s root fh. Note here that in this example, the client did not obtain filehandles and attribute information (e.g., fsid) for the intermediate directories, so that it would not be sure where the absent file system starts. It could be the case, for example, that /this/is/the is the root of the moved file system and that the reason that the lookup of &#34;path&#34; succeeded is that the file system was not absent on that operation but was moved between the last LOOKUP and the GETFH (since COMPOUND is not atomic). Even if we had the fsids for all of the intermediate directories, we could have no way of knowing that /this/is/the/path was the root of a new file system, since we don&#39;t yet have its fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETFHの失敗を考えると、クライアントは存在しないファイルシステムのルートを決定する仕事とどこそのファイルシステム、すなわち、サーバとそのサーバのルートFHへの相対パスを見つけるためにしています。不在のファイルシステムが始まることを確認しないように、この例では、クライアントがファイルハンドルを取得し、中間ディレクトリのための情報（例えば、FSID）を属性なかったことをここで注意してください。これは、移動したファイルシステムのルートであり、「パス」の検索が成功したことを理由は、ファイルシステムがその操作に存在しなかったことであることが、感動しました/ /これは/であること、例えば、ケースかもしれません最後LOOKUPとGETFH（化合物がアトミックではないので）の間です。我々は中間ディレクトリのすべてのためのfsidsを持っていたとしても、我々はまだそのFSIDを持っていないので、この/ / /パスは、新しいファイルシステムのルートは、/していることを知る方法はありませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to get the necessary information, let us re-send the chain of LOOKUPs with GETFHs and GETATTRs to at least get the fsids so we can be sure where the appropriate file system boundaries are. The client could choose to get fs_locations at the same time, but in most cases the client will have a good guess as to where the file system boundaries are (because of where NFS4ERR_MOVED was, and was not, received), making the fetching of fs_locations unnecessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必要な情報を得るために、私たちは適切なファイルシステムの境界がどこにあるかを確認することができますように、少なくともfsidsを取得するGETFHsとGETATTRsと検索の連鎖を再送信してみましょう。 fs_位置のフェッチを作り、クライアントが同時にfs_位置を取得することを選択することができるが、ほとんどの場合、クライアントは、ファイルシステムの境界がどこにとして良い推測を持つことになります（なぜならNFS4ERR_MOVEDがあった場所で、そして、できなかった受信しました）不要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP01: PUTROOTFH --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペアンプ01：putarutaphaha  - &gt; naphsaoka
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 現在のFHは、擬似FSのルートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP02: GETATTR(fsid) --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP02：GETATTR（出血） - &gt; NFS_OK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Just for completeness. Normally, clients will know the fsid of the pseudo-fs as soon as they establish communication with a server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ただ、完全性のために。通常、クライアントは、すぐに彼らは、サーバとの通信を確立するよう疑似-FSのFSIDを知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP03: LOOKUP &#34;this&#34; --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP03：LOOKUP &#34;この&#34;  - &gt; NFS_OK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP04: GETATTR(fsid) --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP04：GETATTR（出血） - &gt; NFS_OK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Get the current fsid to see where the file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ファイルシステムの境界がどこにあるか確認するために、現在のFSIDを取得します。 FSIDは、この例では、擬似FS、それほどない境界のためにそれをあろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP05: GETFH --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウェブ05：Jtvh  - &gt;自分
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 現在のFH /このためのものであり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP06: LOOKUP &#34;is&#34; --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP06：LOOKUPは &#34;ある&#34;  - &gt; NFS_OK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 現在のFH /この/用であり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP07: GETATTR(fsid) --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP07：GETATTR（出血） - &gt; NFS_OK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Get the current fsid to see where the file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ファイルシステムの境界がどこにあるか確認するために、現在のFSIDを取得します。 FSIDは、この例では、擬似FS、それほどない境界のためにそれをあろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP08: GETFH --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウェブ08：Jtvh  - &gt;自分
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 現在のFH /この/用であり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP09: LOOKUP &#34;the&#34; --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP09：LOOKUP &#34;&#34;  - &gt; NFS_OK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP10: GETATTR(fsid) --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP10：GETATTR（出血） - &gt; NFS_OK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Get the current fsid to see where the file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ファイルシステムの境界がどこにあるか確認するために、現在のFSIDを取得します。 FSIDは、この例では、擬似FS、それほどない境界のためにそれをあろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP11: GETFH --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B 11：Jtvh  - &gt;自分
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP12: LOOKUP &#34;path&#34; --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP12：LOOKUP &#34;パス&#34;  - &gt; NFS_OK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The current fh is for /this/is/the/path and is within a new, absent file system, but ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 現在のFHは/このためである/ /パス/で、新しい、不在ファイルシステム内にある、しかし...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The client will never see the value of that fh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - クライアントは、そのFHの値を参照することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP13: GETATTR(fsid, fs_locations) --&gt; NFS_OK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP13：GETATTR（出血、fs_位置） - &gt; NFS_OK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- We are getting the fsid to know where the file system boundaries are. In this operation, the fsid will be different than that of the parent directory (which in turn was retrieved in OP10). Note that the fsid we are given will not necessarily be preserved at the new location. That fsid might be different, and in fact the fsid we have for this file system might be a valid fsid of a different file system on that new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 私たちは、ファイルシステムの境界がどこにあるか知っているFSIDを得ています。この操作では、FSIDは（順番にOP10で取得された）親ディレクトリとは異なるであろう。私たちは与えられたFSIDは必ずしも新しい場所で保存されないことに注意してください。それFSIDは異なる場合があり、実際には、このファイルシステムのための私たちが持っているFSIDはその新しいサーバ上の異なるファイルシステムの有効FSIDかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- In this particular case, we are pretty sure anyway that what has moved is /this/is/the/path rather than /this/is/the since we have the fsid of the latter and it is that of the pseudo-fs, which presumably cannot move. However, in other examples, we might not have this kind of information to rely on (e.g., /this/is/the might be a non-pseudo-file system separate from /this/is/the/path), so we need to have other reliable source information on the boundary of the file system that is moved. If, for example, the file system /this/is had moved, we would have a case of migration rather than referral, and once the boundaries of the migrated file system were clear we could fetch fs_locations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - この特定のケースでは、我々はとにかく何を移動していること/本/である/ /パスではなくであることをかなり確信している/この/である/私たちは後者のFSIDを持っており、それはその疑似Fのであるから、これはおそらく移動することはできません。しかし、他の例では、我々はに頼るこの種の情報を持っていない可能性があります（例えば、/この/ /このは別に非擬似ファイルシステムであるかもしれない/ / /パス/です）ので、我々は必要移動されたファイルシステムの境界上の他の信頼できる情報源の情報を持っています。例えば、ファイルシステムが/これは/移動したならば、我々は、移行ではなく、紹介のケースを持っているでしょうし、移行したファイルシステムの境界が明確であったら、私たちはfs_位置を取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- We are fetching fs_locations because the fact that we got an NFS4ERR_MOVED at this point means that this is most likely a referral and we need the destination. Even if it is the case that /this/is/the is a file system that has migrated, we will still need the location information for that file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 私たちは、この時点でNFS4ERR_MOVEDを得たという事実は、これが最も可能性が高いの紹介であり、我々は先が必要であることを意味するので、私たちはfs_位置を取得しています。それは、これは/移行したファイルシステムである/である/場合であっても、我々はまだそのファイルシステムの位置情報が必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP14: GETFH --&gt; NFS4ERR_MOVED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OP14：GETFH  - &gt; NFS4ERR_MOVED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Fails because current fh is in an absent file system at the start of the operation, and the specification makes no exception for GETFH. Note that this means the server will never send the client a filehandle from within an absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 現在のFHは、操作の開始時に存在しないファイルシステムであり、仕様はGETFHための例外をしないため失敗。これは、サーバーが不在のファイルシステム内からクライアントにファイルハンドルを送信することはありませんを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given the above, the client knows where the root of the absent file system is (/this/is/the/path) by noting where the change of fsid occurred (between &#34;the&#34; and &#34;path&#34;). The fs_locations attribute also gives the client the actual location of the absent file system so that the referral can proceed. The server gives the client the bare minimum of information about the absent file system so that there will be very little scope for problems of conflict between information sent by the referring server and information of the file system&#39;s home. No filehandles and very few attributes are present on the referring server, and the client can treat those it receives as transient information with the function of enabling the referral.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記を考えると、クライアントはFSIDの変更が（「」と「パス」の間で）発生した場所を注意することによって（/本/である/ /パス）不在のファイルシステムのルートがどこにあるか知っています。 fs_位置は、紹介を進めることができるようにもクライアントに欠け、ファイルシステムの実際の場所を与える属性。ファイルシステムのホームの参照サーバとの情報から送信された情報間の紛争の問題のための非常に小さな範囲が存在することになるように、サーバーはクライアントに不在のファイルシステムに関する情報の最低限を提供します。いいえ、ファイルハンドルと非常に少数の属性が参照するサーバー上に存在しない、そしてクライアントが紹介を可能にする機能を備えた過渡的な情報として受け取るものを扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7.2. Referral Example (READDIR)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7.2。紹介例（READDIR）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another context in which a client may encounter referrals is when it does a READDIR on a directory in which some of the subdirectories are the roots of absent file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはサブディレクトリの一部が欠けているファイルシステムの根されているディレクトリにREADDIRをしたときに、クライアントは紹介に遭遇する可能性のある別のコンテキストがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suppose such a directory is read as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようなディレクトリが読まれていると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O putarutaphaha
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;この&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUPは &#34;あります&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOOKUP O &#34;&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o READDIR(fsid, size, time_modify, mounted_on_fileid)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O READDIR（FSID、サイズ、time_modify、mounted_on_fileid）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this case, because rdattr_error is not requested, fs_locations is not requested, and some of the attributes cannot be provided, the result will be an NFS4ERR_MOVED error on the READDIR, with the detailed results as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにrdattr_errorが要求されていないので、この場合には、fs_位置が要求されていない、および属性のいくつかを提供することができず、結果は、詳細な結果を、READDIRにNFS4ERR_MOVEDエラーになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o PUTROOTFH --&gt; NFS_OK. The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O PUTROOTFH  - &gt; NFS_OK。現在のFHは、擬似-FSのルートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;この&#34;  - &gt; NFS_OK。現在のFH /このためのものであり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&gt; NFS_OK  -  O LOOKUP &#34;です&#34;。現在のFHは、/ /これをであり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;&#34;  - &gt; NFS_OK。現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o READDIR(fsid, size, time_modify, mounted_on_fileid) --&gt; NFS4ERR_MOVED. Note that the same error would have been returned if /this/is/the had migrated, but it is returned because the directory contains the root of an absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O READDIR（FSID、サイズ、time_modify、mounted_on_fileid） - &gt; NFS4ERR_MOVED。同じエラーがこの/ / /移動した場合に返されたであろう、しかし、ディレクトリが存在しないファイルシステムのルートが含まれているため、それが返されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
So now suppose that we re-send with rdattr_error:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
だから今、私たちはrdattr_errorで再送信したとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O putarutaphaha
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;この&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUPは &#34;あります&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOOKUP O &#34;&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o READDIR(rdattr_error, fsid, size, time_modify, mounted_on_fileid)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O READDIR（rdattr_error、FSID、サイズ、time_modify、mounted_on_fileid）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The results will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
結果は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o PUTROOTFH --&gt; NFS_OK. The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O PUTROOTFH  - &gt; NFS_OK。現在のFHは、擬似-FSのルートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;この&#34;  - &gt; NFS_OK。現在のFH /このためのものであり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&gt; NFS_OK  -  O LOOKUP &#34;です&#34;。現在のFHは、/ /これをであり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;&#34;  - &gt; NFS_OK。現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o READDIR(rdattr_error, fsid, size, time_modify, mounted_on_fileid) --&gt; NFS_OK. The attributes for the directory entry with the component named &#34;path&#34; will only contain rdattr_error with the value NFS4ERR_MOVED, together with an fsid value and a value for mounted_on_fileid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O READDIR（rdattr_error、FSID、サイズ、time_modify、mounted_on_fileid） - &gt; NFS_OK。 「パス」という名前のコンポーネントを持つディレクトリエントリの属性は、唯一のFSID値とmounted_on_fileidの値と一緒に、値NFS4ERR_MOVEDとrdattr_errorが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
So suppose we do another READDIR to get fs_locations (although we could have used a GETATTR directly, as in Section 8.7.1):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
だから我々は、（8.7.1項のように、私たちは直接GETATTRを使用することもできましたが）fs_位置を取得するために別のREADDIRを行うとします
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o PUTROOTFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O putarutaphaha
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;this&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;この&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;is&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUPは &#34;あります&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;the&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOOKUP O &#34;&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o READDIR(rdattr_error, fs_locations, mounted_on_fileid, fsid, size, time_modify)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O READDIR（rdattr_error、fs_位置、mounted_on_fileid、FSID、サイズ、time_modify）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The results would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
結果は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o PUTROOTFH --&gt; NFS_OK. The current fh is at the root of the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O PUTROOTFH  - &gt; NFS_OK。現在のFHは、擬似-FSのルートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;this&#34; --&gt; NFS_OK. The current fh is for /this and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;この&#34;  - &gt; NFS_OK。現在のFH /このためのものであり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;is&#34; --&gt; NFS_OK. The current fh is for /this/is and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&gt; NFS_OK  -  O LOOKUP &#34;です&#34;。現在のFHは、/ /これをであり、擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o LOOKUP &#34;the&#34; --&gt; NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LOOKUP &#34;&#34;  - &gt; NFS_OK。現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o READDIR(rdattr_error, fs_locations, mounted_on_fileid, fsid, size, time_modify) --&gt; NFS_OK. The attributes will be as shown below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O READDIR（rdattr_error、fs_位置、mounted_on_fileid、FSID、サイズ、time_modify） - &gt; NFS_OK。属性は以下のように表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The attributes for the directory entry with the component named &#34;path&#34; will only contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「パス」という名前のコンポーネントを持つディレクトリエントリの属性にのみ含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o rdattr_error (value: NFS_OK)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入出力rdattr_error（値：NFS_OK）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o fs_locations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fs_位置O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o mounted_on_fileid (value: unique fileid within referring file system)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O mounted_on_fileid（値：参照するファイルシステム内で一意FILEID）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o fsid (value: unique value within referring server)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O FSID（値：参照サーバー内で一意の値）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The attributes for entry &#34;path&#34; will not contain size or time_modify, because these attributes are not available within an absent file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの属性は、存在しないファイルシステム内で利用できないため、エントリの属性は「パス」は、大きさやtime_modifyは含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. The Attribute fs_locations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8。属性fs_位置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fs_locations attribute is defined by both fs_location4 (Section 2.2.6) and fs_locations4 (Section 2.2.7). It is used to represent the location of a file system by providing a server name and the path to the root of the file system within that server&#39;s namespace. When a set of servers have corresponding file systems at the same path within their namespaces, an array of server names may be provided. An entry in the server array is a UTF-8 string and represents one of a traditional DNS host name, IPv4 address, IPv6 address, or a zero-length string. A zero-length string SHOULD be used to indicate the current address being used for the RPC. It is not a requirement that all servers that share the same rootpath be listed in one fs_location4 instance. The array of server names is provided for convenience. Servers that share the same rootpath may also be listed in separate fs_location4 entries in the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fs_位置はfs_location4（セクション2.2.6）とfs_locations4（セクション2.2.7）の両方によって定義される属性。サーバー名と、そのサーバーの名前空間内のファイルシステムのルートへのパスを提供することで、ファイルシステムの場所を表すために使用されます。サーバのセットは、その名前空間内の同じパスに対応するファイルシステムを持っている場合は、サーバー名の配列を提供することができます。サーバーアレイ内のエントリは、UTF-8文字列であり、伝統的なDNSホスト名、IPv4アドレス、IPv6アドレス、または長さゼロの文字列の1つを表します。長さゼロの文字列は、RPCのために使用されている現在のアドレスを示すために使用されるべきです。これは、同じROOTPATHを共有するすべてのサーバーが1つのfs_location4インスタンスに一覧表示され要件ではありません。サーバー名の配列は、便宜のために提供されます。同じROOTPATHを共有するサーバもfs_位置の属性で別のfs_location4エントリに表示されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fs_locations4 data type and fs_locations attribute contain an array of such locations. Since the namespace of each server may be constructed differently, the fs_root field is provided. The path represented by the fs_root represents the location of the file system in the current server&#39;s namespace, i.e., that of the server from which the fs_locations attribute was obtained. The fs_root path is meant to aid the client by clearly referencing the root of the file system whose locations are being reported, no matter what object within the current file system the current filehandle designates. The fs_root is simply the pathname the client used to reach the object on the current server (i.e., the object to which the fs_locations attribute applies).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fs_locations4データタイプとfs_位置は、位置のアレイを含む属性。各サーバの名前空間が異なるように構成することができるので、fs_rootフィールドが設けられています。 fs_rootで表される経路は、すなわち、fs_位置の属性が取得されたサーバの現在のサーバの名前空間内のファイル・システムの位置を表します。 fs_rootパスが明確に場所に関係なく、現在のファイルハンドルを指定し、現在のファイルシステム内のどのオブジェクト、報告されていないされているファイルシステムのルートを参照することで、クライアントを支援するためのものです。 fs_rootは単にパス名現在のサーバー（すなわち、fs_位置がどの属性にオブジェクトが適用される）上のオブジェクトに到達するために使用されるクライアントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the fs_locations attribute is interrogated and there are no alternative file system locations, the server SHOULD return a zero-length array of fs_location4 structures, together with a valid fs_root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fs_位置が調べられる属性と全く別のファイルシステムの場所が存在しない場合は、サーバが一緒に有効なfs_rootで、fs_location4構造の長さゼロの配列を返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As an example, suppose there is a replicated file system located at two servers (servA and servB). At servA, the file system is located at path /a/b/c. At servB, the file system is located at path /x/y/z. If the client were to obtain the fs_locations value for the directory at /a/b/c/d, it might not necessarily know that the file system&#39;s root is located in servA&#39;s namespace at /a/b/c. When the client switches to servB, it will need to determine that the directory it first referenced at servA is now represented by the path /x/y/z/d on servB. To facilitate this, the fs_locations attribute provided by servA would have an fs_root value of /a/b/c and two entries in fs_locations. One entry in fs_locations will be for itself (servA), and the other will be for servB with a path of /x/y/z. With this information, the client is able to substitute /x/y/z for /a/b/c at the beginning of its access path and construct /x/y/z/d to use for the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一例として、2台のサーバ（SERVAとservB）に位置する複製されたファイルシステムがあると仮定する。 SERVAで、ファイルシステムは、パス/ A / B / Cに位置しています。 servBで、ファイルシステムは、パス/ X / Y / Zに位置しています。クライアントは/ A / B / C / Dでのディレクトリのfs_位置の値を取得した場合、それは必ずしも、ファイルシステムのルートが/ A / B / Cでセルバの名前空間に配置されていることを知らないかもしれません。クライアントはservBに切り替わるときに、それは最初SERVAで参照されるディレクトリは現在servBのパス/ X / Y / Z / Dで表されることを決定する必要があります。これを容易にするために、SERVAによって提供される属性fs_位置はfs_rootの/ A / B / Cの値とfs_位置に2つのエントリを有することになります。 fs_位置における1つのエントリが（SERVA）自体になり、他方は/ X / Y / ZのパスとservBためであろう。この情報により、クライアントは、そのアクセスパスの先頭に/ A / B / Cのための/ X / Y / Zを代入して、新しいサーバに使用する/ X / Y / Z / Dを構築することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that there is no requirement that the number of components in each rootpath be the same; there is no relation between the number of components in the rootpath or fs_root, and none of the components in each rootpath and fs_root have to be the same. In the above example, we could have had a third element in the locations array, with server equal to &#34;servC&#34; and rootpath equal to &#34;/I/II&#34;, and a fourth element in the locations array, with server equal to &#34;servD&#34; and rootpath equal to &#34;/aleph/beth/gimel/daleth/he&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ROOTPATH中の成分の数は同じである必要はないことに留意されたいです。 ROOTPATH又はfs_root、各ROOTPATHとfs_root中の成分のいずれの成分数との間には関係が同じである必要はありません。上記の例では、「servDに等しいサーバと、「SERVC」および「/ I / II」に等しいROOTPATH、および場所アレイ内の4番目の要素に等しいサーバと、位置配列の3番目の要素を持っていた可能性が&#34;とROOTPATH等しい &#34;/アレフ/ベス/ギメル/ daleth /彼&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The relationship between an fs_root and a rootpath is that the client replaces the pathname indicated in the fs_root for the current server for the substitute indicated in the rootpath for the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
fs_rootとROOTPATHとの間の関係は、クライアントが新しいサーバーのROOTPATHに示されている代替のための現在のサーバー用fs_rootに示されたパス名を置き換えることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For an example of a referred or migrated file system, suppose there is a file system located at serv1. At serv1, the file system is located at /az/buky/vedi/glagoli. The client finds that the object at glagoli has migrated (or is a referral). The client gets the fs_locations attribute, which contains an fs_root of /az/buky/vedi/ glagoli, and one element in the locations array, with server equal to serv2, and rootpath equal to /izhitsa/fita. The client replaces /az/buky/vedi/glagoli with /izhitsa/fita and uses the latter pathname on serv2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照またはマイグレーションファイルシステムの例については、SERV1に位置するファイルシステムが存在すると仮定する。 SERV1では、ファイルシステムは/ AZ / buky / vedi / glagoliに位置しています。クライアントはglagoliのオブジェクトが移行していることを見つけた（または紹介です）。クライアントは、SERV2に等しいサーバ、および/ izhitsa /フィッタに等しいROOTPATHと/ AZ / buky / vedi / glagoliのfs_root、及び場所アレイ内の1つの要素を含む、fs_位置属性を取得します。クライアントは/ izhitsa /フィッタで/ AZ / buky / vedi / glagoliを置き換え、SERV2に後者のパス名を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thus, the server MUST return an fs_root that is equal to the path the client used to reach the object to which the fs_locations attribute applies. Otherwise, the client cannot determine the new path to use on the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
したがって、サーバーは、クライアントがfs_位置が適用されるどの属性にオブジェクトに到達するために使用されるパスに等しいfs_rootを返さなければなりません。そうでない場合、クライアントは、新しいサーバーで使用する新しいパスを決定することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. File Locking and Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.ファイルロックと共有予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Integrating locking into the NFS protocol necessarily causes it to be stateful. With the inclusion of share reservations, the protocol becomes substantially more dependent on state than the traditional combination of NFS and NLM (Network Lock Manager) [xnfs]. There are three components to making this state manageable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSプロトコルにロック統合必ずしもステートフルさせます。共有の予約を含めて、プロトコルはNFSとNLM（ネットワークロックマネージャ）xnfs】従来の組合せよりも状態に実質的に依存するようになります。この状態は管理しやすい作りには3つのコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o clear division between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバの間のO明確な区分
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o ability to reliably detect inconsistency in state between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O能力は確実にクライアントとサーバの間の状態に矛盾を検出します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o simple and robust recovery mechanisms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oシンプルで堅牢な回復メカニズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this model, the server owns the state information. The client requests changes in locks, and the server responds with the changes made. Non-client-initiated changes in locking state are infrequent. The client receives prompt notification of such changes and can adjust its view of the locking state to reflect the server&#39;s changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このモデルでは、サーバーは、状態情報を所有しています。クライアントは、ロックの変更を要求し、サーバが行った変更で応答します。ロック状態での非クライアント主導の変更はまれです。クライアントは、このような変化の迅速な通知を受信して​​、サーバーの変更を反映するために、ロック状態のその視野を調整することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Individual pieces of state created by the server and passed to the client at its request are represented by 128-bit stateids. These stateids may represent a particular open file, a set of byte-range locks held by a particular owner, or a recallable delegation of privileges to access a file in particular ways or at a particular location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その要求に応じてクライアントにサーバによって作成され、渡された状態の個々の部分は、128ビットのstateidsで表現されています。これらのstateidsは、特定の開いているファイル、特定の所有者によって保持されたバイト範囲ロックのセット、または特定の方法で、または特定の場所にあるファイルへのアクセス権限の委譲リコールを表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In all cases, there is a transition from the most general information that represents a client as a whole to the eventual lightweight stateid used for most client and server locking interactions. The details of this transition will vary with the type of object, but it always starts with a client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
全ての場合において、最もクライアントとサーバのロックの相互作用のために使用される最終的な軽量のstateidに全体としてクライアントを表す最も一般的な情報の遷移があります。この移行の詳細については、オブジェクトの種類によって異なりますが、それは常にクライアントのIDで始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To support Win32 share reservations, it is necessary to atomically OPEN or CREATE files and apply the appropriate locks in the same operation. Having a separate share/unshare operation would not allow correct implementation of the Win32 OpenFile API. In order to correctly implement share semantics, the previous NFS protocol mechanisms used when a file is opened or created (LOOKUP, CREATE, ACCESS) need to be replaced. The NFSv4 protocol has an OPEN operation that subsumes the NFSv3 methodology of LOOKUP, CREATE, and ACCESS. However, because many operations require a filehandle, the traditional LOOKUP is preserved to map a filename to a filehandle without establishing state on the server. The policy of granting access or modifying files is managed by the server based on the client&#39;s state. These mechanisms can implement policy ranging from advisory only locking to full mandatory locking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Win32のシェアの予約をサポートするために、それはアトミックOPENまたはファイルを作成し、同じ操作で適切なロックを適用する必要があります。別のシェア/共有解除操作を持つことのWin32のOpenFileのAPIの正しい実装を許可しないでしょう。正しく共有セマンティクスを実現するために、ファイルを開くまたは作成されたときに使用される従来のNFSプロトコルメカニズム（LOOKUPは、CREATE、ACCESS）に交換する必要があります。 NFSv4プロトコルを作成し、ACCESS、LOOKUPのNFSv3の方法を包含するOPEN操作を有します。多くの操作は、ファイルハンドルを必要とするためしかし、伝統的なLOOKUPは、サーバー上の状態を確立することなくファイルハンドルにファイル名をマップするために保存されています。アクセスを許可またはファイルを変更するポリシーは、クライアントの状態に基づいてサーバによって管理されています。これらのメカニズムは、完全な強制ロックにロックする諮問に至るまでポリシーを実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Opens and Byte-Range Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。オープンして、バイト範囲ロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is assumed that manipulating a byte-range lock is rare when compared to READ and WRITE operations. It is also assumed that server restarts and network partitions are relatively rare. Therefore, it is important that the READ and WRITE operations have a lightweight mechanism to indicate if they possess a held lock. A byte-range lock request contains the heavyweight information required to establish a lock and uniquely define the owner of the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読み出し動作と書き込み動作と比較した場合、バイト範囲ロックを操作することはまれであると仮定されます。また、サーバーが再起動し、ネットワークパーティションは比較的まれであると仮定する。したがって、READとWRITE操作は、彼らが保持されたロックを所有どうかを示すための軽量なメカニズムを持っていることが重要です。バイト範囲ロック要求がロックを確立し、一意のロックの所有者を定義するために必要なヘビーな情報を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following sections describe the transition from the heavyweight information to the eventual stateid used for most client and server locking and lease interactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のセクションでは、ほとんどのクライアントとサーバーのロックとリースの相互作用のために使用される最終的なのstateidのヘビー情報の遷移を記述しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1. Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1。クライアントID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For each LOCK request, the client must identify itself to the server. This is done in such a way as to allow for correct lock identification and crash recovery. A sequence of a SETCLIENTID operation followed by a SETCLIENTID_CONFIRM operation is required to establish the identification onto the server. Establishment of identification by a new incarnation of the client also has the effect of immediately breaking any leased state that a previous incarnation of the client might have had on the server, as opposed to forcing the new client incarnation to wait for the leases to expire. Breaking the lease state amounts to the server removing all lock, share reservation, and, where the server is not supporting the CLAIM_DELEGATE_PREV claim type, all delegation state associated with the same client with the same identity. For a discussion of delegation state recovery, see Section 10.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各LOCK要求の場合、クライアントはサーバーに自分自身を識別しなければなりません。これは、正しいロック識別とクラッシュリカバリを可能にするような方法で行われます。 SETCLIENTID_CONFIRM操作続いSETCLIENTID操作のシーケンスは、サーバに識別を確立するために必要とされます。クライアントの新しいインカネーションによる識別の確立もすぐにリースの期限が切れるのを待つために新しいクライアント化身を強制的に対立するものとして、クライアントの前身は、サーバー上で持っていたかもしれない任意のリースを破らせる効果を有します。サーバがCLAIM_DELEGATE_PREV請求タイプ、同じIDを持つ同じクライアントに関連するすべての委任状態をサポートしていないすべてのロック、共有の予約などを除去サーバにリース状態量を破ります。委任状態の回復の議論については、10.2.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Owners of opens and owners of byte-range locks are separate entities and remain separate even if the same opaque arrays are used to designate owners of each. The protocol distinguishes between open-owners (represented by open_owner4 structures) and lock-owners (represented by lock_owner4 structures).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オープンおよびバイト範囲ロックの所有者の所有者が同じ不透明アレイはそれぞれの所有者を指定するために使用されていても、別個のエンティティであり、別個のままです。プロトコルは、オープン所有者（open_owner4構造によって表される）と（lock_owner4構造によって表される）ロック所有者を区別する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Both sorts of owners consist of a clientid and an opaque owner string. For each client, the set of distinct owner values used with that client constitutes the set of owners of that type, for the given client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
所有者の両方の種類はのclientidと不透明な所有者文字列で構成されています。クライアントごとに、そのクライアントで使用される個別の所有者の値のセットは、特定のクライアントのために、そのタイプの所有者のセットを構成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each open is associated with a specific open-owner, while each byte-range lock is associated with a lock-owner and an open-owner, the latter being the open-owner associated with the open file under which the LOCK operation was done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各バイト範囲ロックがロック所有者とオープン所有者は、ロック操作が行われたときのオープンファイルに関連付けられている後者はオープン所有者に関連付けられている間に各オープンは、特定のオープン所有者に関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client identification is encapsulated in the following structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント識別は、以下の構造の中にカプセル化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first field, verifier, is a client incarnation verifier that is used to detect client reboots. Only if the verifier is different from that which the server has previously recorded for the client (as identified by the second field of the structure, id) does the server start the process of canceling the client&#39;s leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のフィールドは、検証者は、クライアントの再起動を検出するために使用されるクライアント・インカネーションの検証です。検証者は、（構造体の第2のフィールド、IDによって識別されるように）サーバが以前にクライアントのために記録したものと異なる場合にのみ、サーバはクライアントのリース状態を解除するプロセスを開始しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The second field, id, is a variable-length string that uniquely defines the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第2のフィールド、IDは、クライアントを一意に定義する可変長の文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are several considerations for how the client generates the id string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがID文字列を生成する方法にはいくつかの考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The string should be unique so that multiple clients do not present the same string. The consequences of two clients presenting the same string range from one client getting an error to one client having its leased state abruptly and unexpectedly canceled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数のクライアントが同じ文字列を提示しないように、文字列が一意である必要がありますoを。 1つのクライアントにエラーを取得して1つのクライアントから同じ文字列の範囲を提示する2つのクライアントの結果は、そのリース状態が突然と予期せずにキャンセルされました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The string should be selected so the subsequent incarnations (e.g., reboots) of the same client cause the client to present the same string. The implementer is cautioned against an approach that requires the string to be recorded in a local file because this precludes the use of the implementation in an environment where there is no local disk and all file access is from an NFSv4 server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O文字列は、同じ文字列を提示するようにクライアントを引き起こす同じクライアントの後続の化身（例えば、リブート）ように選択されるべきです。実装者は、これはローカルディスクがない環境での実装の使用を排除し、すべてのファイルアクセスは、NFSv4サーバからあるので、ローカルファイルに記録される文字列を必要としたアプローチに警告を発しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The string should be different for each server network address that the client accesses, rather than common to all server network addresses. The reason is that it may not be possible for the client to tell if the same server is listening on multiple network addresses. If the client issues SETCLIENTID with the same id string to each network address of such a server, the server will think it is the same client, and each successive SETCLIENTID will cause the server to begin the process of removing the client&#39;s previous leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oの文字列は、すべてのサーバのネットワークアドレスにクライアントがアクセスする各サーバーネットワークアドレスの異なる、というより一般的でなければなりません。その理由は、クライアントが同じサーバーに複数のネットワーク・アドレスでリッスンされているかどうかをすることは可能ではないかもしれないということです。クライアントの問題は、サーバの各ネットワークアドレスに同じID文字列でSETCLIENTID場合、サーバは同じクライアントだと思いますし、それぞれの連続したSETCLIENTIDは、サーバーがクライアントの以前のリースの状態を除去するプロセスを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The algorithm for generating the string should not assume that the client&#39;s network address won&#39;t change. This includes changes between client incarnations and even changes while the client is still running in its current incarnation. This means that if the client includes just the client&#39;s and server&#39;s network address in the id string, there is a real risk, after the client gives up the network address, that another client, using a similar algorithm for generating the id string, will generate a conflicting id string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oの文字列を生成するためのアルゴリズムは、クライアントのネットワークアドレスが変更されないことを仮定するべきではありません。クライアントが現在の化身で実行されている間、これは、クライアントの化身とでも変化と変更が含まれています。これは、クライアントがネットワークアドレスを放棄した後、クライアントはクライアントだけのとid文字列にサーバのネットワークアドレスが含まれている場合、現実的なリスクがあることを意味し、id文字列を生成するための同様のアルゴリズムを使用して別のクライアントが、生成すること競合id文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given the above considerations, an example of a well-generated id string is one that includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の考察を考慮すると、十分に生成されたID列の例を含むものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server&#39;s network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバのネットワークアドレスO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client&#39;s network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのネットワークアドレスO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For a user-level NFSv4 client, it should contain additional information to distinguish the client from other user-level clients running on the same host, such as a universally unique identifier (UUID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OユーザーレベルNFSv4クライアントの場合、このような汎用一意識別子（UUID）と同じホスト上で動作している他のユーザーレベルのクライアントからクライアントを区別するために付加的な情報を含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Additional information that tends to be unique, such as one or more of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このようの一つ以上のように、ユニークになりがちO追加情報：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* The client machine&#39;s serial number (for privacy reasons, it is best to perform some one-way function on the serial number).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*クライアント・マシンのシリアル番号（プライバシー上の理由から、それはシリアル番号にいくつかの一方向関数を実行するのが最善です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* A MAC address (for privacy reasons, it is best to perform some one-way function on the MAC address).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* AのMACアドレス（プライバシー上の理由から、それはMACアドレスにいくつかの一方向関数を実行するのが最善です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* The timestamp of when the NFSv4 software was first installed on the client (though this is subject to the previously mentioned caution about using information that is stored in a file, because the file might only be accessible over NFSv4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*（ファイルのみのNFSv4経由でアクセス可能であるかもしれないので、これはファイルに格納された情報を、使用について前述の注意の対象となるが）NFSv4のソフトウェアが最初のクライアントにインストールしたときのタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* A true random number. However, since this number ought to be the same between client incarnations, this shares the same problem as that of using the timestamp of the software installation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*真の乱数。しかし、この数は、クライアント・インカネーションの間で同じであるべきことから、これは、ソフトウェアのインストールのタイムスタンプを使用してのものと同じ問題を共有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a security measure, the server MUST NOT cancel a client&#39;s leased state if the principal that established the state for a given id string is not the same as the principal issuing the SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
与えられたid文字列の状態を確立プリンシパルがSETCLIENTIDを発行する元本と同じでない場合、セキュリティ対策として、サーバーはクライアントのリース状態を解除してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that SETCLIENTID (Section 16.33) and SETCLIENTID_CONFIRM (Section 16.34) have a secondary purpose of establishing the information the server needs to make callbacks to the client for the purpose of supporting delegations. It is permitted to change this information via SETCLIENTID and SETCLIENTID_CONFIRM within the same incarnation of the client without removing the client&#39;s leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのSETCLIENTIDに注意してください（セクション16.33）とSETCLIENTID_CONFIRM（セクション16.34）サーバが代表団を支援する目的で、クライアントへのコールバックを行うために必要な情報を確立する二次的な目的を持っています。クライアントのリースの状態を削除せずに、クライアントの同じ化身内SETCLIENTIDとSETCLIENTID_CONFIRMを経由してこの情報を変更することが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once a SETCLIENTID and SETCLIENTID_CONFIRM sequence has successfully completed, the client uses the shorthand client identifier, of type clientid4, instead of the longer and less compact nfs_client_id4 structure. This shorthand client identifier (a client ID) is assigned by the server and should be chosen so that it will not conflict with a client ID previously assigned by the server. This applies across server restarts or reboots. When a client ID is presented to a server and that client ID is not recognized, as would happen after a server reboot, the server will reject the request with the error NFS4ERR_STALE_CLIENTID. When this happens, the client must obtain a new client ID by use of the SETCLIENTID operation and then proceed to any other necessary recovery for the server reboot case (see Section 9.6.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTIDとSETCLIENTID_CONFIRMシーケンスが正常に完了すると、クライアントはタイプclientid4の代わりに、より長く、より少ないコンパクトなnfs_client_id4構造のため、速記クライアント識別子を使用しています。この速記クライアント識別子（クライアントID）がサーバによって割り当てられ、それが以前にサーバによって割り当てられたクライアントIDと競合しないように選択されるべきです。これは、サーバの再起動または再起動しても適用されます。クライアントIDがサーバーに提示され、そのクライアントIDがサーバーの再起動後に起こるように、認識されない場合は、サーバがエラーNFS4ERR_STALE_CLIENTIDで要求を拒否します。このような場合、クライアントはSETCLIENTID操作の使用によって、新しいクライアントIDを取得して、サーバーの再起動の場合のために、他の必要な回復に進ん必要があります（セクション9.6.2を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client must also employ the SETCLIENTID operation when it receives an NFS4ERR_STALE_STATEID error using a stateid derived from its current client ID, since this also indicates a server reboot, which has invalidated the existing client ID (see Section 9.6.2 for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これはまた、既存のクライアントIDを（詳細はセクション9.6.2を参照）を無効にしているサーバーの再起動を示すので、それは、その現在のクライアントIDから派生したstateidを使用してNFS4ERR_STALE_STATEIDエラーを受信したときにクライアントはSETCLIENTID操作を使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See the detailed descriptions of SETCLIENTID (Section 16.33.4) and SETCLIENTID_CONFIRM (Section 16.34.4) for a complete specification of the operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作の完全な仕様についてはSETCLIENTID（セクション16.33.4）とSETCLIENTID_CONFIRM（セクション16.34.4）の詳細な説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.2. Server Release of Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.2。クライアントIDのサーバ・リリース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server determines that the client holds no associated state for its client ID, the server may choose to release the client ID. The server may make this choice for an inactive client so that resources are not consumed by those intermittently active clients. If the client contacts the server after this release, the server must ensure that the client receives the appropriate error so that it will use the SETCLIENTID/SETCLIENTID_CONFIRM sequence to establish a new identity. It should be clear that the server must be very hesitant to release a client ID since the resulting work on the client to recover from such an event will be the same burden as if the server had failed and restarted. Typically, a server would not release a client ID unless there had been no activity from that client for many minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、クライアントがそのクライアントIDのための関連した状態を保持していないと判断した場合、サーバーはクライアントのIDを解放することもできます。リソースは、これらの断続的にアクティブなクライアントによって消費されないように、サーバーは非アクティブクライアントのためにこの選択を行うことができます。クライアントは、このリリースの後にサーバー場合は、サーバーは、それが新しいアイデンティティを確立するためにSETCLIENTID / SETCLIENTID_CONFIRMシーケンスを使用するようにクライアントに適切なエラーを受け取ることを確認する必要があります。サーバーが失敗し、再起動したかのようなイベントから回復するには、クライアント上の結果の作業は同じ負担になりますので、サーバがクライアントのIDを解放するために非常に躊躇しなければならないことは明らかです。多く分間そのクライアントからの活動がなかった場合を除き一般的に、サーバはクライアントのIDを解放しないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that if the id string in a SETCLIENTID request is properly constructed, and if the client takes care to use the same principal for each successive use of SETCLIENTID, then, barring an active denial-of-service attack, NFS4ERR_CLID_INUSE should never be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTID要求のid列が適切に構築されている場合、クライアントはSETCLIENTIDの各連続使用のために同じプリンシパルを使用するように世話をしている場合、および、その後、アクティブなサービス拒否攻撃がなければ、NFS4ERR_CLID_INUSEが返されることはありませんように注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, client bugs, server bugs, or perhaps a deliberate change of the principal owner of the id string (such as the case of a client that changes security flavors, and under the new flavor there is no mapping to the previous owner) will in rare cases result in NFS4ERR_CLID_INUSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、クライアントのバグは、サーバーのバグ、または多分id文字列の主な所有者の意図的な変更がでます（このようなセキュリティ風味を変更し、新しい味の下クライアントの場合のように、前の所有者へのマッピングはありません）まれなケースはNFS4ERR_CLID_INUSEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In that event, when the server gets a SETCLIENTID for a client ID that currently has no state, or it has state but the lease has expired, rather than returning NFS4ERR_CLID_INUSE, the server MUST allow the SETCLIENTID and confirm the new client ID if followed by the appropriate SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その場合、サーバーには現在の状態を持っていないクライアントIDのためのSETCLIENTIDを取得、またはそれは状態を持っていますが、リースが、むしろNFS4ERR_CLID_INUSEを返すよりも、有効期限が切れたとき、サーバはSETCLIENTIDを許容しなければなりませんし、続いている場合、新しいクライアントIDを確認します適切なSETCLIENTID_CONFIRM。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.3. Use of Seqids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.3。 Seqidsの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In several contexts, 32-bit sequence values called &#34;seqids&#34; are used as part of managing locking state. Such values are used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの状況において、「seqids」と呼ばれる32ビットのシーケンス値は、ロック状態管理の一部として使用されます。このような値が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o To provide an ordering of locking-related operations associated with a particular lock-owner or open-owner. See Section 9.1.7 for a detailed explanation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oは、特定のロック所有者またはオープン所有者に関連付けられているロックに関連する操作の順序を提供します。詳細な説明については、セクション9.1.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o To define an ordered set of instances of a set of locks sharing a particular set of ownership characteristics. See Section 9.1.4.2 for a detailed explanation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oは、所有権特性の特定のセットを共有ロックのセットのインスタンスの順序付けられた集合を定義します。詳細な説明については、セクション9.1.4.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Successive seqid values for the same object are normally arrived at by incrementing the current value by one. This pattern continues until the seqid is incremented past NFS4_UINT32_MAX, in which case one (rather than zero) is to be the next seqid value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じ目的のために、連続するSEQID値は、通常1によって電流値をインクリメントすることによって到達されます。 SEQIDが1（よりむしろゼロ）次SEQID値しようとする場合には、NFS4_UINT32_MAX過ぎてインクリメントされるまで、このパターンが継続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When two seqid values are to be compared to determine which of the two is later, the possibility of wraparound needs to be considered. In many cases, the values are such that simple numeric comparisons can be used. For example, if the seqid values to be compared are both less than one million, the higher value can be considered the later. On the other hand, if one of the values is at or near NFS_UINT32_MAX and the other is less than one million, then implementations can reasonably decide that the lower value has had one more wraparound and is thus, while numerically lower, actually later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2つのSEQID値は後2つのかを決定するために比較されるとき、ラップアラウンドの可能性を考慮する必要があります。多くの場合、値は単純な数値比較を使用することができるようなものです。比較するSEQID値が両方百万未満である場合、例えば、より高い値は、後に考えることができます。値のいずれかで、またはNFS_UINT32_MAX近くにあり、一方、他は、数値的により低いながら実装が合理実際後、より低い値が1つのより多くのラップアラウンドを有し、従って、あるていることを決定することができ、百万円未満です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations can compare seqids in the presence of potential wraparound by adopting the reasonable assumption that the chain of increments from one to the other is shorter than 2**31. So, if the difference between the two seqids is less than 2**31, then the lower seqid is to be treated as earlier. If, however, the difference between the two seqids is greater than or equal to 2**31, then it can be assumed that the lower seqid has encountered one more wraparound and can be treated as later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、一方から他方への増分の鎖がより短い2 ** 31であり、合理的な仮定を採用することにより、潜在的なラップアラウンドの存在下でseqidsを比較することができます。 2 seqids差が** 31 2未満であれば、次に低いSEQIDは、以前のように扱われるべきです。 、しかし、2つのseqidsの差が2以上** 31に等しい場合、低いSEQID一つ以上のラップアラウンドが発生したと、後に処理することができると仮定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4. Stateid Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4。 STATEID定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server grants a lock of any type (including opens, byte-range locks, and delegations), it responds with a unique stateid that represents a set of locks (often a single lock) for the same file, of the same type, and sharing the same ownership characteristics. Thus, opens of the same file by different open-owners each have an identifying stateid. Similarly, each set of byte-range locks on a file owned by a specific lock-owner has its own identifying stateid. Delegations also have associated stateids by which they may be referenced. The stateid is used as a shorthand reference to a lock or set of locks, and given a stateid, the server can determine the associated state-owner or state-owners (in the case of an open-owner/lock-owner pair) and the associated filehandle. When stateids are used, the current filehandle must be the one associated with that stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは（、バイト範囲ロックを開き、代表団を含む）あらゆるタイプのロックを許可する場合は、同じ種類で、同じファイルのロックの集合を表す一意のstateid（多くの場合、単一のロック）で応答し、そして、同じ所有権の特性を共有します。このように、各々が特定のstateidを有する異なるオープンオーナーによって同じファイルの開き。同様に、特定のロック所有者が所有するファイル上のバイト範囲ロックの各セットは、それ自身の特定のstateidを有しています。代表団はまた、彼らが参照されるかもしれないのstateidsが関連付けられています。 stateidロックに速記参照として使用されるか、またはロックの設定、およびのstateidが与えられ、サーバは（オープン所有者/ロック所有者ペアの場合）関連状態、所有者または状態の所有者を決定することができると関連するファイルハンドル。 stateidsが使用される場合、現在のファイルハンドルは、そののstateidに関連付けられているものでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All stateids associated with a given client ID are associated with a common lease that represents the claim of those stateids and the objects they represent to be maintained by the server. See Section 9.5 for a discussion of the lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
所与のクライアントIDに関連付けられたすべてのstateidsは、それらのstateids、それらがサーバによって維持される表すオブジェクトの項を表す一般的なリースに関連しています。リースの議論については9.5節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each stateid must be unique to the server. Many operations take a stateid as an argument but not a clientid, so the server must be able to infer the client from the stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各のstateidはサーバに一意である必要があります。多くの操作は、引数ではなく、そのclientidとしてのstateidを取るので、サーバは、クライアントからのstateidを推測することができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.1. Stateid Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.1。 STATEIDタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the exception of special stateids (see Section 9.1.4.3), each stateid represents locking objects of one of a set of types defined by the NFSv4 protocol. Note that in all these cases, where we speak of a guarantee, it is understood there are situations such as a client restart, or lock revocation, that allow the guarantee to be voided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別のstateids（セクション9.1.4.3を参照）を除いて、それぞれのstateidはNFSv4のプロトコルによって定義されたタイプのセットのうちの1つのロックオブジェクトを表しています。我々は保証の話これらすべてのケースで、保証は無効とすることができ、クライアントの再起動、またはロック失効などの状況が、そこにあるものと理解されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Stateids may represent opens of files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oのstateidsはファイルの開きを表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each stateid in this case represents the OPEN state for a given client ID/open-owner/filehandle triple. Such stateids are subject to change (with consequent incrementing of the stateid&#39;s seqid) in response to OPENs that result in upgrade and OPEN_DOWNGRADE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この場合の各のstateidは、所与のクライアントID /オープン所有者/ファイルハンドル三重ためOPEN状態を表しています。そのようなのstateidsアップグレードとOPEN_DOWNGRADE動作をもたらすのOPENsに応答して（のstateidのSEQIDの結果としての増分で）変更される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Stateids may represent sets of byte-range locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oのstateidsは、バイト範囲ロックのセットを表してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All locks held on a particular file by a particular owner and all gotten under the aegis of a particular open file are associated with a single stateid, with the seqid being incremented whenever LOCK and LOCKU operations affect that set of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定の所有者および特定のオープンファイルの庇護の下で得全てによって、特定のファイルに保持されたすべてのロックは、ロックとLOCKU操作がロックのセットに影響を与えるたびSEQIDがインクリメントされると、単一のstateidと関連しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Stateids may represent file delegations, which are recallable guarantees by the server to the client that other clients will not reference, or will not modify, a particular file until the delegation is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oのstateidsは代表団が返されるまで、他のクライアントは、特定のファイルを参照していないか、または変更されることはありませんサーバからクライアントにリコール保証されているファイルの代表団を表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A stateid represents a single delegation held by a client for a particular filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidは、特定のファイルハンドルのためにクライアントによって保持された単一の代表団を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.2. Stateid Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.2。 STATEID構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stateids are divided into two fields: a 96-bit &#34;other&#34; field identifying the specific set of locks and a 32-bit &#34;seqid&#34; sequence value. Except in the case of special stateids (see Section 9.1.4.3), a particular value of the &#34;other&#34; field denotes a set of locks of the same type (for example, byte-range locks, opens, or delegations), for a specific file or directory, and sharing the same ownership characteristics. The seqid designates a specific instance of such a set of locks, and is incremented to indicate changes in such a set of locks, by either the addition or deletion of locks from the set, a change in the byte-range they apply to, or an upgrade or downgrade in the type of one or more locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロックの特定のセットと32ビットの「SEQID」シーケンス値を識別する96ビットの「その他」フィールド：のstateidsは、2つのフィールドに分割されます。特別のstateidsの場合を除き、「その他」フィールドは、（例えば、バイト範囲ロックを開き、又は委任）同じタイプのロックの集合を示す特定の値（セクション9.1.4.3を参照）、Aについて特定のファイルやディレクトリ、および同じ所有者の特性を共有します。 SEQIDはロックのようなセットの特定のインスタンスを指定して、セットからのロックの付加または欠失のいずれかによって、それらを適用バイト範囲の変化をロックのようなセットの変更を示すために増分され、又は一の以上のロックのタイプでアップグレードまたはダウングレード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When such a set of locks is first created, the server returns a stateid with a seqid value of one. On subsequent operations that modify the set of locks, the server is required to advance the seqid field by one whenever it returns a stateid for the same state-owner/file/type combination and the operation is one that might make some change in the set of locks actually designated. In this case, the server will return a stateid with an &#34;other&#34; field the same as previously used for that state-owner/file/type combination, with an incremented seqid field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロックのようなセットが最初に作成されたとき、サーバは、一つのSEQID値とのstateidを返します。ロックのセットを変更後の操作では、サーバは同じ状態-オーナー/ファイル/タイプの組み合わせのためのstateidを返すたび1でSEQIDフィールドを進めるために必要とされ、操作がセットにいくつかの変更を行う可能性があるものですロックの実際の指定。この場合、サーバがインクリメントSEQIDフィールドと、以前にその状態所有者/ファイル/タイプ組合せに用いたものと同じフィールドを「その他」とのstateidを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Seqids will be compared, by both the client and the server. The client uses such comparisons to determine the order of operations, while the server uses them to determine whether the NFS4ERR_OLD_STATEID error is to be returned. In all cases, the possibility of seqid wraparound needs to be taken into account, as discussed in Section 9.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Seqidsは、クライアントとサーバーの両方で、比較されます。サーバがNFS4ERR_OLD_STATEIDエラーが返されるかどうかを判断するためにそれらを使用しながら、クライアントは、操作の順序を決定するために、このような比較を使用しています。すべての場合において、SEQIDラップアラウンドの可能性は、9.1.3項で述べたように、考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.3. Special Stateids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.3。特別のstateids
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stateid values whose &#34;other&#34; field is either all zeros or all ones are reserved. They MUST NOT be assigned by the server but have special meanings defined by the protocol. The particular meaning depends on whether the &#34;other&#34; field is all zeros or all ones and the specific value of the seqid field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その「その他」の欄のstateid値はすべてゼロ、またはすべてのもののいずれかを予約されています。彼らは、サーバーによって割り当てられたが、プロトコルによって定義された特別な意味を持っていてはなりません。特定の意味は、「その他」の欄はすべてゼロ、またはすべてのものとSEQIDフィールドの特定の値であるかどうかに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following combinations of &#34;other&#34; and seqid are defined in NFSv4:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「その他」とSEQIDの次の組み合わせは、NFSv4の中で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Anonymous Stateid: When &#34;other&#34; and seqid are both zero, the stateid is treated as a special anonymous stateid, which can be used in READ, WRITE, and SETATTR requests to indicate the absence of any open state associated with the request. When an anonymous stateid value is used, and an existing open denies the form of access requested, then access will be denied to the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
匿名のstateid：両方ともゼロである場合、「他の」及びSEQID、のstateidは、WRITE、READで使用することができる特別な匿名のstateid、として扱われ、その要求に関連する任意の開状態が存在しないことを示すためにSETATTR要求されます。匿名のstateid値を使用して、既存のオープンが要求されたアクセスのフォームを拒否された場合、アクセスは、要求に拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ Bypass Stateid: When &#34;other&#34; and seqid are both all ones, the stateid is a special READ bypass stateid. When this value is used in WRITE or SETATTR, it is treated like the anonymous value. When used in READ, the server MAY grant access, even if access would normally be denied to READ requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイパスたstateidを読むときは、「その他」とSEQIDは両方とも、すべてのものであり、のstateidは特別READバイパスのstateidです。この値は、WRITEまたはSETATTRに使用されている場合は、匿名の値のように扱われています。 READで使用する場合、サーバはアクセスが通常のリクエストを読むために拒否された場合でも、アクセスを許可することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a stateid value is used that has all zeros or all ones in the &#34;other&#34; field but does not match one of the cases above, the server MUST return the error NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateid値がすべてゼロまたは「その他」の欄にあるすべてのものを持っていますが、上記の例1と一致していませんが使用されている場合は、サーバがエラーNFS4ERR_BAD_STATEIDを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Special stateids, unlike other stateids, are not associated with individual client IDs or filehandles and can be used with all valid client IDs and filehandles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別のstateidsは、他のstateidsとは異なり、個々のクライアントIDまたはファイルハンドルに関連付けられていないと、すべての有効なクライアントIDとファイルハンドルを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.4. Stateid Lifetime and Validation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.4。 STATEID生涯と検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stateids must remain valid until either a client restart or a server restart, or until the client returns all of the locks associated with the stateid by means of an operation such as CLOSE or DELEGRETURN. If the locks are lost due to revocation, as long as the client ID is valid, the stateid remains a valid designation of that revoked state. Stateids associated with byte-range locks are an exception. They remain valid even if a LOCKU frees all remaining locks, so long as the open file with which they are associated remains open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントの再起動またはサーバの再起動、またはクライアントまでのいずれかは、CLOSEまたはDELEGRETURNなどの操作によってのstateidに関連付けられているロックのすべてを返すまでのstateidsは有効でなければなりません。ロックが失効のために失われた場合に限り、クライアントIDが有効であるとして、のstateidは、その取り消された状態の有効な名称のまま。バイト範囲ロックに関連付けられているのstateidsは例外です。彼らはとても長い間、関連付けられている、開いているファイルが開いたままで、LOCKUは、残りのすべてのロックを解放しても有効なまま。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It should be noted that there are situations in which the client&#39;s locks become invalid, without the client requesting they be returned. These include lease expiration and a number of forms of lock revocation within the lease period. It is important to note that in these situations, the stateid remains valid and the client can use it to determine the disposition of the associated lost locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのロックが無効になっている状況では、クライアントは、彼らが返されることを要求せずに、あることに留意すべきです。これらは、リース満了及びリース期間内にロック失効のフォームの数を含みます。このような状況で、のstateidが有効なままで、クライアントが関連付けられている失われたロックの配置を決定するためにそれを使用できることに注意することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An &#34;other&#34; value must never be reused for a different purpose (i.e., different filehandle, owner, or type of locks) within the context of a single client ID. A server may retain the &#34;other&#34; value for the same purpose beyond the point where it may otherwise be freed, but if it does so, it must maintain seqid continuity with previous values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「その他」の値は、単一のクライアントIDのコンテキスト内で（すなわち、異なるファイルハンドル、所有者、またはロックの種類）は、異なる目的のために再利用してはなりません。サーバは、それがそうでなければ解放されてもよいが、そうしなければ、それが以前の値とSEQID連続性を維持しなければならない点を越えて同じ目的のために、「その他」の値を保持することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One mechanism that may be used to satisfy the requirement that the server recognize invalid and out-of-date stateids is for the server to divide the &#34;other&#34; field of the stateid into two fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが無効とアウト日付のstateidsを認識要件を満たすために使用され得る1つの機構は、サーバーに2つのフィールドへのstateidの「その他」フィールドを分割するためのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An index into a table of locking-state structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oロック状態構造のテーブルへのインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A generation number that is incremented on each allocation of a table entry for a particular use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定の使用のためのテーブルエントリの各割当にインクリメントされる世代番号O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
And then store the following in each table entry:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そして、各テーブルエントリに次のように格納します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client ID with which the stateid is associated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たstateidが関連付けられているクライアントID O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The current generation number for the (at most one) valid stateid sharing this index value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このインデックス値を共有する（最大1つ）が有効のstateidのための現在の世代番号O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The filehandle of the file on which the locks are taken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロックが取られているファイルのファイルハンドルO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An indication of the type of stateid (open, byte-range lock, file delegation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oのstateidのタイプの指示（オープン、バイト範囲ロックは、委任ファイル）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The last seqid value returned corresponding to the current &#34;other&#34; value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O最後SEQID値は、現在の「その他」の値に対応する戻りました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An indication of the current status of the locks associated with this stateid -- in particular, whether these have been revoked and, if so, for what reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このたstateidに関連付けられているロックの現在のステータスの表示O  - 特に、これらのかどうかをどのような理由のために、そうであれば、取り消されてきました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With this information, an incoming stateid can be validated and the appropriate error returned when necessary. Special and non-special stateids are handled separately. (See Section 9.1.4.3 for a discussion of special stateids.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この情報を用いて、着信のstateidを検証することができ、必要なときに適切なエラーが返されます。特殊および非特殊なのstateidsは別々に処理されています。 （特別のstateidsの議論については、セクション9.1.4.3を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a stateid is being tested, and the &#34;other&#34; field is all zeros or all ones, a check that the &#34;other&#34; and seqid fields match a defined combination for a special stateid is done and the results determined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidがテストされ、そして「その他」の欄には、すべてのゼロまたはすべてのものを、「その他」とSEQIDフィールドが行われている特別なstateidと、以下のように決定された結果のために定義された組み合わせと一致していることを確認する場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the &#34;other&#34; and seqid fields do not match a defined combination associated with a special stateid, the error NFS4ERR_BAD_STATEID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「その他」とSEQIDフィールドは特別なstateidに関連付けられて定義された組み合わせと一致しない場合は、O、エラーNFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the combination is valid in general but is not appropriate to the context in which the stateid is used (e.g., an all-zero stateid is used when an open stateid is required in a LOCK operation), the error NFS4ERR_BAD_STATEID is also returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
組み合わせは、一般的に有効であるが、（オープンのstateidがロック動作に必要とされる場合、例えば、全てゼロのstateidが使用されている）のstateidが使用される文脈に適切でない場合はO、エラーNFS4ERR_BAD_STATEIDも返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Otherwise, the check is completed and the special stateid is accepted as valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれ以外の場合は、チェックが完了し、特別なstateidが有効なものとして受け入れられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a stateid is being tested, and the &#34;other&#34; field is neither all zeros nor all ones, the following procedure could be used to validate an incoming stateid and return an appropriate error, when necessary, assuming that the &#34;other&#34; field would be divided into a table index and an entry generation. Note that the terms &#34;earlier&#34; and &#34;later&#34; used in connection with seqid comparison are to be understood as explained in Section 9.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidがテストされ、そして「その他」フィールドがすべてゼロでも全てのものでもない場合、次の手順は、着信のstateidを検証し、適切なエラーを返すために使用することができる、と仮定すると、必要な場合、「他の」フィールドは、あろうことテーブルインデックスエントリの世代に分け。 SEQID比較に関連して使用される「以前」という用語及び「後」は、セクション9.1.3で説明したように理解されるべきであることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the table index field is outside the range of the associated table, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
テーブルインデックスフィールドは、関連するテーブルの範囲外である場合、O、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the selected table entry is of a different generation than that specified in the incoming stateid, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択されたテーブル・エントリが入ってくるのstateidで指定されたものとは異なる世代である場合、O、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the selected table entry does not match the current filehandle, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択したテーブルのエントリは、現在のファイルハンドルと一致しない場合は、O、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the stateid represents revoked state or state lost as a result of lease expiration, then return NFS4ERR_EXPIRED, NFS4ERR_BAD_STATEID, or NFS4ERR_ADMIN_REVOKED, as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O場合のstateidは、必要に応じて、NFS4ERR_EXPIRED、NFS4ERR_BAD_STATEID、又はNFS4ERR_ADMIN_REVOKEDを返し、その後、リース期限の結果として失わ失効状態または状態を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the stateid type is not valid for the context in which the stateid appears, return NFS4ERR_BAD_STATEID. Note that a stateid may be valid in general but invalid for a particular operation, as, for example, when a stateid that doesn&#39;t represent byte-range locks is passed to the non-from_open case of LOCK or to LOCKU, or when a stateid that does not represent an open is passed to CLOSE or OPEN_DOWNGRADE. In such cases, the server MUST return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidタイプがのstateidが現れるコンテキストのために有効でない場合は、O、NFS4ERR_BAD_STATEIDを返します。バイト範囲ロックを表していないのstateidはLOCKの非from_openケースまたはLOCKUに渡されたとき、例えば、として、のstateidは、特定の動作のために一般に有効ではなく無効であってもよいことに留意されたい場合、またはオープンを表していないのstateidは近いかOPEN_DOWNGRADEに渡されます。このような場合には、サーバがNFS4ERR_BAD_STATEIDを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the seqid field is not zero and it is later than the current sequence value corresponding to the current &#34;other&#34; field, return NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQIDフィールドがゼロでないと、それは現在の「その他」フィールドに対応する現在のシーケンス値より後であれば、O、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the seqid field is earlier than the current sequence value corresponding to the current &#34;other&#34; field, return NFS4ERR_OLD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQIDフィールドは、現在の「その他」のフィールドに対応する現在のシーケンスの値よ​​りも前である場合には、O、NFS4ERR_OLD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Otherwise, the stateid is valid, and the table entry should contain any additional information about the type of stateid and information associated with that particular type of stateid, such as the associated set of locks (e.g., open-owner and lock-owner information), as well as information on the specific locks themselves, such as open modes and byte ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれ以外の場合は、のstateidが有効であり、テーブルエントリは、このようなロックの関連したセットとしてのstateidとのstateidのその特定のタイプに関連付けられた情報のタイプに関する追加情報を含むべきである（例えば、オープン所有者とロック所有者情報）、ならびにオープンモードとバイト範囲として特定ロック自体の情報として。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.5. Stateid Use for I/O Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.5。 I / O操作のためのstateid使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients performing Input/Output (I/O) operations need to select an appropriate stateid based on the locks (including opens and delegations) held by the client and the various types of state-owners sending the I/O requests. SETATTR operations that change the file size are treated like I/O operations in this regard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力/出力（I / O）操作を実行するクライアントは、クライアントが保持している（開いて代表団を含む）ロックおよびI / O要求を送信状態の所有者の様々なタイプに基づいて適切なstateidを選択する必要があります。ファイルサイズを変更するSETATTR操作は、この点でI / O操作のように扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following rules, applied in order of decreasing priority, govern the selection of the appropriate stateid. In following these rules, the client will only consider locks of which it has actually received notification by an appropriate operation response or callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
優先度の高いものから順に適用される以下の規則は、適切なのstateidの選択を支配します。これらのルールを次のように、クライアントは、それが実際に適切な操作の応答またはコールバックにより通知を受けたのロックを検討します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the client holds a delegation for the file in question, the delegation stateid SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、問題のファイルのための委任を保持している場合は、O、委任のstateidを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Otherwise, if the entity corresponding to the lock-owner (e.g., a process) sending the I/O has a byte-range lock stateid for the associated open file, then the byte-range lock stateid for that lock-owner and open file SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれ以外の場合は、エンティティがロック所有者に対応する場合（例えば、プロセス）I / Oに関連したオープンファイルのバイト範囲ロックのstateid、そのロック所有者とオープン用次いでバイト範囲ロックのstateidを有する送信ファイルを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If there is no byte-range lock stateid, then the OPEN stateid for the current open-owner, i.e., the OPEN stateid for the open file in question, SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何のバイト範囲ロックのstateid、現在オープンの所有者、すなわち、問題の開いているファイルのOPENのstateidのために、その後OPENのstateidが存在しない場合は、O、使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Finally, if none of the above apply, then a special stateid SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記に該当しない場合はO最後に、その後、特別のstateidを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ignoring these rules may result in situations in which the server does not have information necessary to properly process the request. For example, when mandatory byte-range locks are in effect, if the stateid does not indicate the proper lock-owner, via a lock stateid, a request might be avoidably rejected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのルールを無視すると、サーバがリクエストを適切に処理するために必要な情報を持っていないという状況になることがあります。必須バイト範囲ロックが有効になっているときのstateidは、適切なロック所有者を示すものではありません場合たとえば、ロックのstateidを経由して、要求がavoidably拒否されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server, however, should not try to enforce these ordering rules and should use whatever information is available to properly process I/O requests. In particular, when a client has a delegation for a given file, it SHOULD take note of this fact in processing a request, even if it is sent with a special stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、しかし、これらの発注ルールを適用しようとするべきではないと適切にI / O要求を処理するために利用可能であるどんな情報を使用する必要があります。クライアントが指定したファイルのための委任を持っているとき、特に、それが特別なstateidで送信された場合でも、要求を処理するには、この事実に注意を払うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.6. Stateid Use for SETATTR Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.4.6。 SETATTR操作のためのstateid使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of SETATTR operations, a stateid is present. In cases other than those that set the file size, the client may send either a special stateid or, when a delegation is held for the file in question, a delegation stateid. While the server SHOULD validate the stateid and may use the stateid to optimize the determination as to whether a delegation is held, it SHOULD note the presence of a delegation even when a special stateid is sent, and MUST accept a valid delegation stateid when sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTR操作の場合、のstateidが存在します。ファイルサイズを設定しているもの以外のケースでは、クライアントは、代表団が問題のファイル、委任のstateidのために保持されている特別なstateidか、のいずれかを送信することができます。サーバがたstateidを検証する必要がありますし、委任が保持されているかどうかの判定を最適化するためのstateidを使用することができますが、それは特別なstateidが送られても代表団の存在に注意する必要があり、かつ送信されたときに有効な委任のstateidを受け入れなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.5. Lock-Owner
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.5。ロック、所有者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When requesting a lock, the client must present to the server the client ID and an identifier for the owner of the requested lock. These two fields comprise the lock-owner and are defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロックを要求する場合、クライアントがサーバーへのクライアントIDと要求されたロックの所有者のための識別子を提示する必要があります。これらの二つのフィールドは、ロック所有者を含み、次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A client ID returned by the server as part of the client&#39;s use of the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OクライアントIDはSETCLIENTID操作のクライアントの使用の一環として、サーバから返されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A variable-length opaque array used to uniquely define the owner of a lock managed by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一意のクライアントが管理するロックの所有者を定義するために使用される可変長の不透明な配列を、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This may be a thread id, process id, or other unique value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、スレッドID、プロセスID、または他のユニークな値であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server grants the lock, it responds with a unique stateid. The stateid is used as a shorthand reference to the lock-owner, since the server will be maintaining the correspondence between them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがロックを許可した場合、それはユニークなstateidで応答します。サーバはそれらの間の対応を維持するためのstateidは、ロック所有者に速記参照として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.6. Use of the Stateid and Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.6。 STATEIDとロックの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All READ, WRITE, and SETATTR operations contain a stateid. For the purposes of this section, SETATTR operations that change the size attribute of a file are treated as if they are writing the area between the old and new size (i.e., the range truncated or added to the file by means of the SETATTR), even where SETATTR is not explicitly mentioned in the text. The stateid passed to one of these operations must be one that represents an OPEN (e.g., via the open-owner), a set of byte-range locks, or a delegation, or it may be a special stateid representing anonymous access or the READ bypass stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのREAD、WRITE、およびSETATTR操作はのstateidを含んでいます。彼らは（つまり、範囲が切り捨てられるかSETATTRによってファイルに追加）古いものと新しいサイズとの間の領域を書いているかのように、このセクションの目的のために、ファイルのサイズ属性を変更するSETATTR操作は、処理されますSETATTRは、明示的にテキストで言及されていない場合でも。これらの操作のいずれかに渡されたのstateidは（オープン所有者を経由して、例えば）OPENを表し1、バイト範囲ロックのセット、または委任でなければならない、またはそれは、匿名アクセスまたはREADを表す特別なstateidかもしれバイパスのstateid。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the state-owner performs a READ or WRITE in a situation in which it has established a lock or share reservation on the server (any OPEN constitutes a share reservation), the stateid (previously returned by the server) must be used to indicate what locks, including both byte-range locks and share reservations, are held by the state-owner. If no state is established by the client -- either byte-range lock or share reservation -- the anonymous stateid is used. Regardless of whether an anonymous stateid or a stateid returned by the server is used, if there is a conflicting share reservation or mandatory byte-range lock held on the file, the server MUST refuse to service the READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
状態所有者は（任意OPENは、共有の予約を構成する）は、サーバー上のロックまたは共有の予約を確立している状況で読み取りまたは書き込みを行う場合、（以前にサーバによって返された）のstateidは何を示すために使用されなければなりませんバイト範囲ロックと共有の予約の両方を含むロックは、状態所有者によって保持されています。どちらかのバイト範囲ロックまたは共有予約 -   - 何の状態がクライアントによって確立されていない場合は、匿名のstateidが使用されます。ファイルに開催され、競合シェア予約や必須バイト範囲ロックがある場合にかかわらず、匿名のstateidまたはサーバから返されたstateidが使用されているかどうかの、サーバがREADを修理または書き込み操作することを拒否しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Share reservations are established by OPEN operations and by their nature are mandatory in that when the OPEN denies READ or WRITE operations, that denial results in such operations being rejected with error NFS4ERR_LOCKED. Byte-range locks may be implemented by the server as either mandatory or advisory, or the choice of mandatory or advisory behavior may be determined by the server on the basis of the file being accessed (for example, some UNIX-based servers support a &#34;mandatory lock bit&#34; on the mode attribute such that if set, byte-range locks are required on the file before I/O is possible). When byte-range locks are advisory, they only prevent the granting of conflicting lock requests and have no effect on READs or WRITEs. Mandatory byte-range locks, however, prevent conflicting I/O operations. When they are attempted, they are rejected with NFS4ERR_LOCKED. When the client gets NFS4ERR_LOCKED on a file it knows it has the proper share reservation for, it will need to issue a LOCK request on the region of the file that includes the region the I/O was to be performed on, with an appropriate locktype (i.e., READ*_LT for a READ operation, WRITE*_LT for a WRITE operation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENは、READまたはWRITE操作を拒否したとき、共有予約がOPEN操作によって、その性質上、確立されているという点で必須で、このような操作でその否定結果がエラーNFS4ERR_LOCKEDで拒否されています。バイト範囲ロックは必須または諮問のいずれかとしてサーバによって実現することができる、または必須または諮問行動の選択がアクセスされるファイルに基づいてサーバによって決定することができる（例えば、いくつかのUNIXベースのサーバは、「サポートモードで強制ロックビット」）が設定されている場合、I / Oが可能である前に、バイト範囲ロックがファイル上で必要とされるような属性。バイト範囲ロックが助言しているとき、彼らは唯一の競合ロック要求の付与を防止し、読み出しまたは書き込みには影響しません。必須バイト範囲ロックは、しかし、I / O操作の競合防ぎます。それらが試みられている場合、それらはNFS4ERR_LOCKEDで拒否されています。クライアントは、それがために、適切な共有の予約を持って知っているファイルにNFS4ERR_LOCKEDを取得すると、それはI / Oは、適切な種類のLockTypeで、上に実行されることになっていた領域を含むファイル領域上のロック要求を発行する必要があります。 （すなわち、READ操作用のREAD * _LT、WRITE動作のための* _LTをWRITE）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With NFSv3, there was no notion of a stateid, so there was no way to tell if the application process of the client sending the READ or WRITE operation had also acquired the appropriate byte-range lock on the file. Thus, there was no way to implement mandatory locking. With the stateid construct, this barrier has been removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv3のでは、のstateidの概念がなかったので、READまたはWRITE操作を送信するクライアントのアプリケーション・プロセスは、ファイル上の適切なバイト範囲ロックを獲得していた場合に指示する方法はありませんでした。このように、強制ロックを実装する方法はありませんでした。 stateid構築物で、この障壁は削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that for UNIX environments that support mandatory file locking, the distinction between advisory and mandatory locking is subtle. In fact, advisory and mandatory byte-range locks are exactly the same insofar as the APIs and requirements on implementation are concerned. If the mandatory lock attribute is set on the file, the server checks to see if the lock-owner has an appropriate shared (read) or exclusive (write) byte-range lock on the region it wishes to read or write to. If there is no appropriate lock, the server checks if there is a conflicting lock (which can be done by attempting to acquire the conflicting lock on behalf of the lock-owner and, if successful, release the lock after the READ or WRITE is done), and if there is, the server returns NFS4ERR_LOCKED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必須ファイルのロックをサポートするUNIX環境では、顧問と強制ロックの区別は微妙であることに注意してください。実際には、顧問と必須バイト範囲ロックは、実装上のAPIと要件を懸念している限り、まったく同じです。強制ロック属性がファイルに設定されている場合は、ロック所有者は、それが読み取りまたは書き込みをしたい領域上の共有の適切な（読み取り）または排他（書き込み）バイト範囲ロックを持っている場合は、サーバーのかどうかを確認します。何の適切なロックが存在しない場合は、サーバーをチェックし、成功すれば、ロック所有者に代わって競合ロックを取得し、しようとすることによって行うことができ、競合するロックが（存在する場合READまたはWRITEが行われた後、ロックを解除）、および存在する場合、サーバはNFS4ERR_LOCKEDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For Windows environments, there are no advisory byte-range locks, so the server always checks for byte-range locks during I/O requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Windows環境の場合は、何の助言バイト範囲ロックが存在しないので、サーバは常にI / O要求時にバイト範囲ロックをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thus, the NFSv4 LOCK operation does not need to distinguish between advisory and mandatory byte-range locks. It is the NFSv4 server&#39;s processing of the READ and WRITE operations that introduces the distinction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このように、NFSv4のLOCK操作が顧問と必須バイト範囲ロックを区別する必要はありません。それは区別を紹介読み取りおよび書き込み操作のNFSv4サーバの処理です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Every stateid other than the special stateid values noted in this section, whether returned by an OPEN-type operation (i.e., OPEN, OPEN_DOWNGRADE) or by a LOCK-type operation (i.e., LOCK or LOCKU), defines an access mode for the file (i.e., READ, WRITE, or READ-WRITE) as established by the original OPEN that began the stateid sequence, and as modified by subsequent OPENs and OPEN_DOWNGRADEs within that stateid sequence. When a READ, WRITE, or SETATTR that specifies the size attribute is done, the operation is subject to checking against the access mode to verify that the operation is appropriate given the OPEN with which the operation is associated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての（すなわち、OPEN、OPEN_DOWNGRADE）またはLOCK型操作によって（すなわち、LOCKまたはLOCKU）は、ファイルのアクセスモードを定義する開放型操作によって返されるかどうかを、このセクションで述べた特別のstateid値以外のstateid stateidシーケンスを開始した元のOPENによって確立され、そののstateidシーケンス内の後続開き、OPEN_DOWNGRADEsによって修正され（すなわち、読み取り、書き込み、又は読み取り - 書き込み）。 size属性を指定するREAD、WRITE、またはSETATTRが完了すると、操作が操作は、操作が関連付けられているOPEN所与適切であることを確認するために、アクセスモードに対してチェックを受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of WRITE-type operations (i.e., WRITEs and SETATTRs that set size), the server must verify that the access mode allows writing and return an NFS4ERR_OPENMODE error if it does not. In the case of READ, the server may perform the corresponding check on the access mode, or it may choose to allow READ on opens for WRITE only, to accommodate clients whose write implementation may unavoidably do reads (e.g., due to buffer cache constraints). However, even if READs are allowed in these circumstances, the server MUST still check for locks that conflict with the READ (e.g., another open specifying denial of READs). Note that a server that does enforce the access mode check on READs need not explicitly check for conflicting share reservations since the existence of OPEN for read access guarantees that no conflicting share reservation can exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
書き込みタイプの操作（すなわち、書き込みとサイズを設定SETATTRs）の場合には、サーバは、アクセスモードが書き込み可能ことを確認し、そうでない場合NFS4ERR_OPENMODEエラーを返さなければなりません。 READの場合は、サーバがアクセスモードに対応するチェックを行うことができるか、それが唯一のWRITEのために開いた上で、READを許可するように選択することができ、その書き込みの実装を行う避けられないかもしれ読み込み、クライアントに対応するために（例えば、キャッシュ制約をバッファリングによる） 。しかしながら、このような状況で許可されている読んでも、サーバは依然としてそのし（読み出しの例えば、別のオープン特定拒否）READと競合ロックをチェックしなければなりません。上のアクセスモードのチェックを強制しないサーバが競合する共有予約が存在しないことを読み取りアクセス保証のためのOPENの存在するので、競合シェアの予約をチェックし、明示的にする必要はありません読み取るように注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A READ bypass stateid MAY allow READ operations to bypass locking checks at the server. However, WRITE operations with a READ bypass stateid MUST NOT bypass locking checks and are treated exactly the same as if an anonymous stateid were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READバイパスのstateidは、READ操作はサーバにロックチェックをバイパスすることを可能にし得ます。しかし、バイパスチェックロックMUST NOT READバイパスのstateidとの動作を記述し、匿名のstateidが使用された場合と全く同様に扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A lock may not be granted while a READ or WRITE operation using one of the special stateids is being performed and the range of the lock request conflicts with the range of the READ or WRITE operation. For the purposes of this paragraph, a conflict occurs when a shared lock is requested and a WRITE operation is being performed, or an exclusive lock is requested and either a READ or a WRITE operation is being performed. A SETATTR that sets size is treated similarly to a WRITE as discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別のstateidsのいずれかを使用してREADまたはWRITE動作が行われ、READまたはWRITE動作の範囲とロック要求の競合の範囲されている間、ロックが付与されなくてもよいです。共有ロックが要求され、書き込み動作が行われている、または排他ロックが要求され、READまたはWRITE動作のいずれかが行われているとき、この項の目的のために、競合が発生します。上述のように大きさを設定するSETATTRは、書き込みと同様に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.7. Sequencing of Lock Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.7。ロック要求のシーケンシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Locking is different than most NFS operations as it requires &#34;at-most-one&#34; semantics that are not provided by ONC RPC. ONC RPC over a reliable transport is not sufficient because a sequence of locking requests may span multiple TCP connections. In the face of retransmission or reordering, lock or unlock requests must have a well-defined and consistent behavior. To accomplish this, each lock request contains a sequence number that is a consecutively increasing integer. Different state-owners have different sequences. The server maintains the last sequence number (L) received and the response that was returned. The server SHOULD assign a seqid value of one for the first request issued for any given state-owner. Subsequent values are arrived at by incrementing the seqid value, subject to wraparound as described in Section 9.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが「で最も-1」ONC RPCによって提供されていないセマンティクスを必要とするロックは、ほとんどのNFS操作とは異なります。ロック要求のシーケンスは、複数のTCP接続にまたがる可能性があるため、信頼性の高いトランスポート上でONCのRPCは十分ではありません。再送信または並べ替えの顔には、ロックまたはロック解除要求が明確に定義された一貫性のある動作を持っている必要があります。これを達成するために、各ロック要求が連続して増加する整数であり、シーケンス番号を含みます。異なる状態の所有者が異なる配列を有します。サーバーは、最後のシーケンス番号（L）を受信し、返された応答を維持します。サーバは、任意の所与の状態、所有者に対して発行された最初の要求のために一方のSEQID値を割り当てる必要があります。その後の値は、セクション9.1.3に記載したように回り込み対象SEQID値をインクリメントすることによって到達されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that for requests that contain a sequence number, for each state-owner, there should be no more than one outstanding request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各状態の所有者のために、シーケンス番号を含む要求のために、1つ以下の未処理の要求があってはならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a request is received, its sequence number (r) is compared to that of the last one received (L). Only if it has the correct next sequence, normally L + 1, is the request processed beyond the point of seqid checking. Given a properly functioning client, the response to (r) must have been received before the last request (L) was sent. If a duplicate of last request (r == L) is received, the stored response is returned. If the sequence value received is any other value, it is rejected with the return of error NFS4ERR_BAD_SEQID. Sequence history is reinitialized whenever the SETCLIENTID/ SETCLIENTID_CONFIRM sequence changes the client verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求が受信されると、そのシーケンス番号（R）は（L）を受信した最後のものと比較されます。それが正しい次のシーケンス、通常はL + 1を持っている場合のみ、SEQIDチェックのポイントを超えて処理された要求があります。最後の要求（L）が送信される前に適切に機能してクライアントを考えると、（R）への応答が受信されている必要があります。最後の要求（R == L）の複製を受信した場合、保存された応答が返されます。受信したシーケンス値が他の値であれば、それは誤りNFS4ERR_BAD_SEQIDの復帰で拒絶されます。 SETCLIENTID / SETCLIENTID_CONFIRMシーケンスは、クライアント検証を変更するたびに、シーケンス履歴が再初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is critical that the server maintain the last response sent to the client to provide a more reliable cache of duplicate non-idempotent requests than that of the traditional cache described in [Chet]. The traditional duplicate request cache uses a least recently used algorithm for removing unneeded requests. However, the last lock request and response on a given state-owner must be cached as long as the lock state exists on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが[チェット]で説明従来のキャッシュよりも、重複非べき等の要求より信頼性の高いキャッシュを提供するために、クライアントに送信された最後の応答を維持することが重要です。伝統的な重複要求キャッシュは不要な要求を除去するために最も最近使用されたアルゴリズムを使用しています。しかし、与えられた状態、所有者の最後のロック要求と応答がある限り、ロック状態がサーバー上に存在するとしてキャッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client MUST advance the sequence number for the CLOSE, LOCK, LOCKU, OPEN, OPEN_CONFIRM, and OPEN_DOWNGRADE operations. This is true even in the event that the previous operation that used the sequence number received an error. The only exception to this rule is if the previous operation received one of the following errors: NFS4ERR_STALE_CLIENTID, NFS4ERR_STALE_STATEID, NFS4ERR_BAD_STATEID, NFS4ERR_BAD_SEQID, NFS4ERR_BADXDR, NFS4ERR_RESOURCE, NFS4ERR_NOFILEHANDLE, or NFS4ERR_MOVED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはCLOSE、LOCK、LOCKU、OPEN、オープン_CONFIRM、およびOPEN_DOWNGRADE操作のためのシーケンス番号を進めなければなりません。これは、偶数シーケンス番号を使用する前の操作がエラーを受信した場合に真です。 NFS4ERR_STALE_CLIENTID、NFS4ERR_STALE_STATEID、NFS4ERR_BAD_STATEID、NFS4ERR_BAD_SEQID、NFS4ERR_BADXDR、NFS4ERR_RESOURCE、NFS4ERR_NOFILEHANDLE、又はNFS4ERR_MOVED：前の操作は、以下のいずれかのエラーを受信した場合、このルールの唯一の例外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.8. Recovery from Replayed Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.8。リプレイリクエストからの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described above, the sequence number is per state-owner. As long as the server maintains the last sequence number received and follows the methods described above, there are no risks of a Byzantine router re-sending old requests. The server need only maintain the (state-owner, sequence number) state as long as there are open files or closed files with locks outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上述したように、シーケンス番号は状態所有者ごとです。限り、サーバーが受信した最後のシーケンス番号を維持し、上記の方法を以下のように、古い要求を再送信するビザンチンルータの一切のリスクはありません。サーバは限り優れたロックと開いているファイルまたは閉じたファイルがあるので（状態-所有者、シーケンス番号）状態を維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCK, LOCKU, OPEN, OPEN_DOWNGRADE, and CLOSE each contain a sequence number, and therefore the risk of the replay of these operations resulting in undesired effects is non-existent while the server maintains the state-owner state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCK、LOCKU、OPEN、OPEN_DOWNGRADE、各シーケンス番号を含む閉じ、サーバは、状態所有者状態を維持しつつ望ましくない影響をもたらすこれらの操作の再生のリスクが非存在です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.9. Interactions of Multiple Sequence Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.9。複数の配列の値の相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some operations may have multiple sources of data for request sequence checking and retransmission determination. Some operations have multiple sequence values associated with multiple types of state-owners. In addition, such operations may also have a stateid with its own seqid value, that will be checked for validity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部の操作は、要求シーケンスチェックと再送判定のためのデータの複数のソースを持つことができます。一部の操作は、状態所有者の複数の種類に関連付けられた複数のシーケンス値を持っています。また、このような作業にも有効性が確認されます独自のSEQID値、とのstateidを有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As noted above, there may be multiple sequence values to check. The following rules should be followed by the server in processing these multiple sequence values within a single operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上述したように、確認するために、複数のシーケンス値があってもよいです。以下の規則は、単一の操作内でこれらの複数のシーケンス値を処理する際にサーバが続くべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When a sequence value associated with a state-owner is unavailable for checking because the state-owner is unknown to the server, it takes no part in the comparison.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
状態所有者に関連付けられたシーケンス値が状態所有者がサーバに知られていないので、確認のために使用できない場合、O、それは比較に関与しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When any of the state-owner sequence values are invalid, NFS4ERR_BAD_SEQID is returned. When a stateid sequence is checked, NFS4ERR_BAD_STATEID or NFS4ERR_OLD_STATEID is returned as appropriate, but NFS4ERR_BAD_SEQID has priority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
状態所有者シーケンス値のいずれかが無効である場合、O、NFS4ERR_BAD_SEQIDが返されます。 stateidシーケンスをチェックすると、NFS4ERR_BAD_STATEIDまたはNFS4ERR_OLD_STATEIDは、必要に応じて返されますが、NFS4ERR_BAD_SEQIDが優先されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When any one of the sequence values matches a previous request, for a state-owner, it is treated as a retransmission and not re-executed. When the type of the operation does not match that originally used, NFS4ERR_BAD_SEQID is returned. When the server can determine that the request differs from the original, it may return NFS4ERR_BAD_SEQID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
配列のいずれかの値が前の要求と一致する場合、O、状態所有者のために、それが再実行再送信として扱われていません。操作のタイプが元々使用していることと一致しない場合は、NFS4ERR_BAD_SEQIDが返されます。サーバは、要求がオリジナルと異なることを決定することができたとき、それはNFS4ERR_BAD_SEQIDを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When multiple sequence values match previous operations but the operations are not the same, NFS4ERR_BAD_SEQID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の配列の値が前の操作を一致が、操作が同じでない場合には、O、NFS4ERR_BAD_SEQIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When there are no sequence values available for comparison and the operation is an OPEN, the server indicates to the client that an OPEN_CONFIRM is required, unless it can conclusively determine that confirmation is not required (e.g., by knowing that no open-owner state has ever been released for the current clientid).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そこに比較のために利用可能なシーケンス値がされず、操作が開いているとき、それは決定的に決めることの確認は、その一切のオープン所有者の状態を知っていないことで、例えば（必須ではないことができない限り、O、サーバは、オープン_CONFIRMが必要であることをクライアントに指示します今まで）現在のclientidのためにリリースされました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.10. Releasing State-Owner State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.10。国家所有者状態を解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a particular state-owner no longer holds open or file locking state at the server, the server may choose to release the sequence number state associated with the state-owner. The server may make this choice based on lease expiration, the reclamation of server memory, or other implementation-specific details. Note that when this is done, a retransmitted request, normally identified by a matching state-owner sequence, may not be correctly recognized, so that the client will not receive the original response that it would have if the state-owner state was not released.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定の状態、所有者がもはやサーバに開いたりファイルロック状態を保持している場合、サーバは、状態所有者に関連付けられたシーケンス番号状態を解除することを選択しなくてもよいです。サーバは、リース期限、サーバーのメモリの再利用、または他の実装固有の詳細に基づいてこの選択を行うことができます。これが行われたとき、クライアントは国家所有者の状態が解除されなかった場合、それが持っているであろうと、元の応答を受信しないように、通常のマッチング状態所有者配列により特定され、再送要求は、正しく認識されない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server were able to be sure that a given state-owner would never again be used by a client, such an issue could not arise. Even when the state-owner state is released and the client subsequently uses that state-owner, retransmitted requests will be detected as invalid and the request not executed, although the client may have a recovery path that is more complicated than simply getting the original response back transparently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが与えられた状態、所有者が再びクライアントによって使用されることはありませんでしょうことを確認することができたならば、このような問題は発生しませんでした。国家所有者の状態が解除されると、クライアントは、その後、その状態、所有者を使用する場合でも、クライアントは単に元の応答を取得するよりも複雑である回復パスを持っているかもしれないが、再送された要求は、無効な要求を実行しないとして検出されますバック透過的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In any event, the server is able to safely release state-owner state (in the sense that retransmitted requests will not be erroneously acted upon) when the state-owner is not currently being utilized by the client (i.e., there are no open files associated with an open-owner and no lock stateids associated with a lock-owner). The server may choose to hold the state-owner state in order to simplify the recovery path, in the case in which retransmissions of currently active requests are received. However, the period for which it chooses to hold this state is implementation specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれにせよ、サーバーが安全な状態、所有者が現在のクライアントで利用されていない（再転送要求が誤って作用されないという意味で）状態所有者の状態を解除することができます（つまり、開いているファイルはありませんオープン所有者とロック所有者に関連付けられているロックのstateids）に関連付けられています。サーバーは、現在アクティブな要求の再送信が受信される場合には、回復のパスを簡単にするために国家の所有者の状態を保持することもできます。しかし、それはこの状態を保持することを選択する期間は、実装固有のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case that a LOCK, LOCKU, OPEN_DOWNGRADE, or CLOSE is retransmitted after the server has previously released the state-owner state, the server will find that the state-owner has no files open and an error will be returned to the client. If the state-owner does have a file open, the stateid will not match and again an error is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが以前の状態、所有者の状態をリリースした後にLOCK、LOCKU、OPEN_DOWNGRADE、またはCLOSEが再送される場合、サーバは、状態所有者が開いているファイルがありませんし、エラーがクライアントに返されることがわかります。国家所有者は、開いているファイルを持っている場合は、のstateidは一致しませんし、再びエラーがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.11. Use of Open Confirmation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.11。オープン確認の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case that an OPEN is retransmitted and the open-owner is being used for the first time or the open-owner state has been previously released by the server, the use of the OPEN_CONFIRM operation will prevent incorrect behavior. When the server observes the use of the open-owner for the first time, it will direct the client to perform the OPEN_CONFIRM for the corresponding OPEN. This sequence establishes the use of an open-owner and associated sequence number. Since the OPEN_CONFIRM sequence connects a new open-owner on the server with an existing open-owner on a client, the sequence number may have any valid (i.e., non-zero) value. The OPEN_CONFIRM step assures the server that the value received is the correct one. (See Section 16.18 for further details.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENが再送され、オープン所有者がサーバーによって最初に使用されているか、オープン所有者の状態は、以前にリリースされた場合には、オープン_CONFIRM操作を使用すると、不正な動作を防止します。サーバーが初めてのためのオープン所有者の使用を観察すると、対応するOPENのためのオープン_CONFIRMを実行するために、クライアントに指示します。この配列は、オープン所有者と関連したシーケンス番号の使用を確立します。オープン_CONFIRM配列は、クライアント上の既存のオープン所有者とサーバー上で新しいオープン所有者を接続するので、シーケンス番号は、任意の有効な（すなわち、非ゼロ）値を有することができます。オープン_CONFIRMステップは、受信された値が正しいものであるサーバを保証します。 （詳細については、セクション16.18を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are a number of situations in which the requirement to confirm an OPEN would pose difficulties for the client and server, in that they would be prevented from acting in a timely fashion on information received, because that information would be provisional, subject to deletion upon non-confirmation. Fortunately, these are situations in which the server can avoid the need for confirmation when responding to open requests. The two constraints are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時に削除の対象その情報は暫定的になるので、彼らは、受信した情報にタイムリーに行動することを防止することがあろうとしてOPENを確認するための要件は、クライアントとサーバーのために困難をもたらすことになる状況の数がありますが、非確認。幸いなことに、これらの要求を開くに応答するときに、サーバーが確認の必要性を回避することができている状況です。 2つの制約があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server must not bestow a delegation for any open that would require confirmation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバーには確認が必要となる任意のオープンのための委任を授けるてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server MUST NOT require confirmation on a reclaim-type open (i.e., one specifying claim type CLAIM_PREVIOUS or CLAIM_DELEGATE_PREV).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバは再利用型オープン（すなわち、ある特定のクレームの種類CLAIM_PREVIOUSまたはCLAIM_DELEGATE_PREV）に確認を要求してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These constraints are related in that reclaim-type opens are the only ones in which the server may be required to send a delegation. For CLAIM_NULL, sending the delegation is optional, while for CLAIM_DELEGATE_CUR, no delegation is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの制約は、その再利用型で開きます関連しているサーバーが委任を送信するために必要とすることのできる唯一のものです。 CLAIM_DELEGATE_CURのために、何の代表団が送信されない一方でCLAIM_NULLについて、代表団を送ることは、オプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Delegations being sent with an open requiring confirmation are troublesome because recovering from non-confirmation adds undue complexity to the protocol, while requiring confirmation on reclaim-type opens poses difficulties in that the inability to resolve the status of the reclaim until lease expiration may make it difficult to have timely determination of the set of locks being reclaimed (since the grace period may expire).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非確認から回復するプロトコルに過度に複雑になりますので、再利用型に確認を必要とするリース満了するまで、再利用の状況を解決できないことは、それを作ることが困難にで提起開きながら、オープン要求する確認を送られている代表団は、厄介です（猶予期間の期限が切れる可能性があるため）再利用されているロックのセットのタイムリーな決意を持ってすることは困難。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Requiring open confirmation on reclaim-type opens is avoidable because of the nature of the environments in which such opens are done. For CLAIM_PREVIOUS opens, this is immediately after server reboot, so there should be no time for open-owners to be created, found to be unused, and recycled. For CLAIM_DELEGATE_PREV opens, we are dealing with either a client reboot situation or a network partition resulting in deletion of lease state (and returning NFS4ERR_EXPIRED). A server that supports delegations can be sure that no open-owners for that client have been recycled since client initialization or deletion of lease state and thus can be confident that confirmation will not be required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再利用型に開いて確認を開き要求することはあるため、このような開きが行われている環境の性質の回避です。 CLAIM_PREVIOUSが開くために、これはサーバーの再起動直後であるので、オープン所有者は、作成した未使用であることが判明し、再利用するためには時間があってはなりません。 CLAIM_DELEGATE_PREVが開くために、私たちはクライアントの再起動状況やリース状態（とNFS4ERR_EXPIREDを返す）の欠失をもたらすネットワークパーティションのいずれかを扱っています。代表団をサポートするサーバーは、そのクライアントのためのオープン所有者がリース状態のクライアントの初期化や削除以来、リサイクルされていないため、確認が必要とされないことを確信することができることを確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Lock Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。ロック範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The protocol allows a lock-owner to request a lock with a byte range and then either upgrade or unlock a sub-range of the initial lock. It is expected that this will be an uncommon type of request. In any case, servers or server file systems may not be able to support sub-range lock semantics. In the event that a server receives a locking request that represents a sub-range of current locking state for the lock-owner, the server is allowed to return the error NFS4ERR_LOCK_RANGE to signify that it does not support sub-range lock operations. Therefore, the client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルは、ロック所有者は、バイト範囲のロックを要求した後、いずれかのアップグレードまたは初期ロックのサブ範囲のロックを解除することを可能にします。要求の珍しいタイプであることが期待されます。いずれの場合も、サーバーまたはサーバーのファイル・システムは、サブ範囲ロックのセマンティクスをサポートすることができない場合があります。サーバは、ロック所有者の現在のロック状態のサブ範囲を表すロック要求を受信した場合に、サーバは、それがサブ範囲ロック操作をサポートしていないことを示すためにエラーNFS4ERR_LOCK_RANGEを返すことが許可されています。そのため、クライアントは、適切な場合には、要求元のアプリケーションにエラーを報告し、このエラーを受け取るために準備してする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client is discouraged from combining multiple independent locking ranges that happen to be adjacent into a single request, since the server may not support sub-range requests, and for reasons related to the recovery of file locking state in the event of server failure. As discussed in Section 9.6.2 below, the server may employ certain optimizations during recovery that work effectively only when the client&#39;s behavior during lock recovery is similar to the client&#39;s locking behavior prior to server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバは、サブ範囲要求をサポートし、サーバに障害が発生した場合にファイルのロック状態の回復に関連する理由のためではない可能性があるため、単一の要求に隣接するように起こる複数の独立したロック範囲を組み合わせることから推奨されます。以下のセクション9.6.2で説明したように、サーバはロックリカバリ時に、クライアントの動作は、サーバーの障害が発生する前に、クライアントのロック動作に似ている場合にのみ、効果的に機能回復中に特定の最適化を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. Upgrading and Downgrading Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3。ロックのアップグレードとダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a client has a write lock on a record, it can request an atomic downgrade of the lock to a read lock via the LOCK request, by setting the type to READ_LT. If the server supports atomic downgrade, the request will succeed. If not, it will return NFS4ERR_LOCK_NOTSUPP. The client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがレコードの書き込みロックを持っている場合、それはREAD_LTにタイプを設定することにより、LOCK要求によって読み取りロックにロックの原子格下げを要求することができます。サーバは、原子ダウングレードをサポートしている場合、要求は成功します。そうでない場合、それはNFS4ERR_LOCK_NOTSUPPを返します。クライアントは、適切な場合には、要求元のアプリケーションにエラーを報告し、このエラーを受け取るために準備してする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a client has a read lock on a record, it can request an atomic upgrade of the lock to a write lock via the LOCK request by setting the type to WRITE_LT or WRITEW_LT. If the server does not support atomic upgrade, it will return NFS4ERR_LOCK_NOTSUPP. If the upgrade can be achieved without an existing conflict, the request will succeed. Otherwise, the server will return either NFS4ERR_DENIED or NFS4ERR_DEADLOCK. The error NFS4ERR_DEADLOCK is returned if the client issued the LOCK request with the type set to WRITEW_LT and the server has detected a deadlock. The client should be prepared to receive such errors and, if appropriate, report them to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがレコードの読み取りロックを持っている場合、それはWRITE_LTまたはWRITEW_LTするタイプを設定することにより、LOCK要求を経由して書き込みロックへのロックの原子アップグレードを要求することができます。サーバは、原子のアップグレードをサポートしていない場合、それはNFS4ERR_LOCK_NOTSUPPを返します。アップグレードは、既存の競合することなく達成することができた場合、要求は成功します。そうしないと、サーバはNFS4ERR_DENIEDまたはNFS4ERR_DEADLOCKのいずれかを返します。クライアントがWRITEW_LTに設定するタイプでLOCK要求を発行し、サーバーがデッドロックを検出した場合、エラーNFS4ERR_DEADLOCKが返されます。クライアントは、このようなエラーを受信し、適切な場合には、要求元のアプリケーションに報告するために準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. Blocking Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4。ブロッキング・ロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some clients require the support of blocking locks. The NFSv4 protocol must not rely on a callback mechanism and therefore is unable to notify a client when a previously denied lock has been granted. Clients have no choice but to continually poll for the lock. This presents a fairness problem. Two new lock types are added, READW and WRITEW, and are used to indicate to the server that the client is requesting a blocking lock. The server should maintain an ordered list of pending blocking locks. When the conflicting lock is released, the server may wait the lease period for the first waiting client to re-request the lock. After the lease period expires, the next waiting client request is allowed the lock. Clients are required to poll at an interval sufficiently small that it is likely to acquire the lock in a timely manner. The server is not required to maintain a list of pending blocked locks, as it is not used to provide correct operation but only to increase fairness. Because of the unordered nature of crash recovery, storing of lock state to stable storage would be required to guarantee ordered granting of blocking locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のクライアントには、ロックをブロックのサポートを必要とします。 NFSv4のプロトコルは、コールバックメカニズムに依存しているため、以前に拒否されたロックが許可されたときにクライアントに通知することができないではない必要があります。クライアントが継続的にロックをポーリングするしかありません。これは、公平性の問題を提示します。二つの新しいロックタイプは、READWとWRITEWを追加され、クライアントがブロッキングロックを要求しているサーバーに示すために使用されています。サーバーは、保留中のブロッキング・ロックの順序付きリストを維持する必要があります。矛盾するロックが解除されると、サーバーは再要求するロックへの最初の待機しているクライアントのリース期間を待つことがあります。リース期間が満了した後、次の待機クライアントの要求は、ロックを許可されています。クライアントは、タイムリーにロックを取得する可能性があることを十分に小さい間隔でポーリングするように要求されています。正しい動作を提供するために使用されていないだけ公平性を高めるために、サーバは、保留中のブロックされたロックのリストを維持するために必要とされていません。そのためクラッシュ回復の順不同の性質上、安定したストレージにロック状態の記憶がロックをブロックする命じ付与を保証するために必要とされるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers may also note the lock types and delay returning denial of the request to allow extra time for a conflicting lock to be released, allowing a successful return. In this way, clients can avoid the burden of needlessly frequent polling for blocking locks. The server should take care with the length of delay in the event that the client retransmits the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはまた、ロックの種類に注意し、成功したリターンをできるように、リリースされる競合ロックのための余分な時間を与えるために、要求の拒否を返す遅れることがあります。このように、クライアントがロックを阻止するための不頻繁にポーリングの負担を回避することができます。サーバは、クライアントが要求を再送信する場合の遅延の長さで世話をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a server receives a blocking lock request, denies it, and then later receives a non-blocking request for the same lock, which is also denied, then it should remove the lock in question from its list of pending blocking locks. Clients should use such a non-blocking request to indicate to the server that this is the last time they intend to poll for the lock, as may happen when the process requesting the lock is interrupted. This is a courtesy to the server, to prevent it from unnecessarily waiting a lease period before granting other lock requests. However, clients are not required to perform this courtesy, and servers must not depend on them doing so. Also, clients must be prepared for the possibility that this final locking request will be accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、ブロックロック要求を受け取ることを拒否し、その後も拒否されているのと同じロック、非ブロック要求を受信した場合、それは保留中のブロッキング・ロックのリストから、問題のロックを解除する必要があります。クライアントは、これは、彼らがロックを要求しているプロセスが中断されたときに起こり得るような、ロックをポーリングする予定の最後の時間であるサーバーに示すために、このような非ブロック要求を使用する必要があります。これは、不必要に他のロック要求を許可する前に、リース期間を待ってから、それを防ぐために、サーバへの礼儀です。ただし、クライアントはこの礼儀を実行するために必要とされていない、およびサーバはそうそれらに依存してはなりません。また、クライアントはこの最後のロック要求が受け入れられる可能性のために準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. Lease Renewal
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5。リースの更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The purpose of a lease is to allow a server to remove stale locks that are held by a client that has crashed or is otherwise unreachable. It is not a mechanism for cache consistency, and lease renewals may not be denied if the lease interval has not expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リースの目的は、サーバがクラッシュしたか、そうでなければ到達できないいるクライアントによって保持されている古いロックを削除できるようにすることです。これは、キャッシュの一貫性のためのメカニズムではなく、リース期間が満了していない場合は、リースの更新を拒否することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client can implicitly provide a positive indication that it is still active and that the associated state held at the server, for the client, is still valid. Any operation made with a valid clientid (DELEGPURGE, LOCK, LOCKT, OPEN, RELEASE_LOCKOWNER, or RENEW) or a valid stateid (CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, OPEN_CONFIRM, OPEN_DOWNGRADE, READ, SETATTR, or WRITE) informs the server to renew all of the leases for that client (i.e., all those sharing a given client ID). In the latter case, the stateid must not be one of the special stateids (anonymous stateid or READ bypass stateid).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、暗黙的にそれがまだアクティブであることを肯定的指示を提供することができますし、サーバで開催された関連する状態は、クライアントのために、まだ有効であること。任意の操作が有効なのclientid（DELEGPURGE、LOCK、LOCKT、OPEN、RELEASE_LOCKOWNER、またはRENEW）で作られたか、有効なstateid（CLOSE、DELEGRETURN、LOCK、LOCKU、OPEN、オープン_CONFIRM、OPEN_DOWNGRADE、READ、SETATTR、またはWRITE）がサーバーに通知しますそのクライアントのリースのすべてを更新する（すなわち、与えられたクライアントIDを共有するすべてのものを）。後者の場合、のstateidは、特別のstateids（匿名のstateidまたはREADバイパスのstateid）のいずれかであってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that if the client had restarted or rebooted, the client would not be making these requests without issuing the SETCLIENTID/ SETCLIENTID_CONFIRM sequence. The use of the SETCLIENTID/ SETCLIENTID_CONFIRM sequence (one that changes the client verifier) notifies the server to drop the locking state associated with the client. SETCLIENTID/SETCLIENTID_CONFIRM never renews a lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントを再起動または再起動した場合、クライアントはSETCLIENTID / SETCLIENTID_CONFIRMシーケンスを発行することなく、これらの要求を行うことはないことに注意してください。 SETCLIENTID / SETCLIENTID_CONFIRM配列（クライアント検証を変更するもの）の使用は、クライアントに関連付けられたロック状態をドロップするサーバに通知します。 SETCLIENTID / SETCLIENTID_CONFIRMは、リースを更新することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server has rebooted, the stateids (NFS4ERR_STALE_STATEID error) or the client ID (NFS4ERR_STALE_CLIENTID error) will not be valid, hence preventing spurious renewals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが再起動している場合、のstateids（NFS4ERR_STALE_STATEIDエラー）またはクライアントID（NFS4ERR_STALE_CLIENTIDエラー）は、有効であるので、スプリアス更新を防ぐことはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This approach allows for low-overhead lease renewal, which scales well. In the typical case, no extra RPCs are required for lease renewal, and in the worst case, one RPC is required every lease period (i.e., a RENEW operation). The number of locks held by the client is not a factor since all state for the client is involved with the lease renewal action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このアプローチはうまくスケール低オーバーヘッドのリース更新を可能にします。典型的なケースでは、余分のRPCは、リース更新のために必要とされず、最悪の場合には、あるRPC毎リース期間（すなわち、動作をRENEW）が必要です。クライアントの状態はすべてのリース更新アクションに関与しているため、クライアントが保持しているロックの数倍ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since all operations that create a new lease also renew existing leases, the server must maintain a common lease expiration time for all valid leases for a given client. This lease time can then be easily updated upon implicit lease renewal actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、新しいリースを作成するすべての操作は、既存のリースを更新するので、サーバが特定のクライアントのための有効なすべてのリースのための共通のリース満了時間を維持しなければなりません。このリース時間は、簡単に暗黙のリース更新アクション時に更新することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. Crash Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6。クラッシュ回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The important requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts or reboots. All READ and WRITE operations that may have been queued within the client or network buffers must wait until the client has successfully recovered the locks protecting the READ and WRITE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クラッシュリカバリでの重要な要件は、他に障害が発生したときにクライアントとサーバーの両方が知っていることです。さらに、クライアントがサーバの再起動または再起動してもデータの一貫性のあるビューを見ることが必要です。クライアントが正常に読み取りおよび書き込み操作を保護するロックを回復するまで、クライアントまたはネットワークバッファ内キューに登録されている可能性があり、すべての読み取りおよび書き込み操作が待機する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.1. Client Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.1。クライアントの障害と復旧
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the event that a client fails, the server may recover the client&#39;s locks when the associated leases have expired. Conflicting locks from another client may only be granted after this lease expiration. If the client is able to restart or reinitialize within the lease period, the client may be forced to wait the remainder of the lease period before obtaining new locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連するリースが期限切れになったときに、クライアントに障害が発生した場合には、サーバはクライアントのロックを回復することができます。別のクライアントから競合するロックにのみ、このリース満了後に付与することができます。クライアントは、リース期間内に再起動するか、再初期化することが可能である場合、クライアントは新しいロックを取得する前に、リース期間の残りを待つことを余儀なくされることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To minimize client delay upon restart, open and lock requests are associated with an instance of the client by a client-supplied verifier. This verifier is part of the initial SETCLIENTID call made by the client. The server returns a client ID as a result of the SETCLIENTID operation. The client then confirms the use of the client ID with SETCLIENTID_CONFIRM. The client ID in combination with an opaque owner field is then used by the client to identify the open-owner for OPEN. This chain of associations is then used to identify all locks for a particular client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再起動時にクライアントの遅延を最小限に抑えるために、オープンロック要求は、クライアントが提供する検証することで、クライアントのインスタンスに関連付けられています。この検証では、クライアントによって行われた最初のSETCLIENTID呼び出しの一部です。サーバーは、SETCLIENTID操作の結果としてクライアントのIDを返します。次に、クライアントは、SETCLIENTID_CONFIRMを持つクライアントIDの使用を確認します。不透明な所有者フィールドと組み合わせて、クライアントIDは、OPENのためのオープン所有者を識別するために、クライアントによって使用されます。団体のこのチェーンは、特定のクライアントのすべてのロックを識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the verifier will be changed by the client upon each initialization, the server can compare a new verifier to the verifier associated with currently held locks and determine that they do not match. This signifies the client&#39;s new instantiation and subsequent loss of locking state. As a result, the server is free to release all locks held that are associated with the old client ID that was derived from the old verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
検証は、各初期化時にクライアントによって変更されますので、サーバーは現在保持しているロックに関連した検証者に新しい検証を比較し、一致していないと判断することができます。これは、クライアントの新しいインスタンス化し、ロック状態のその後の損失を意味します。その結果、サーバは古い検証から得られた古いクライアントIDに関連付けられて保持されているすべてのロックを解放して自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the verifier must have the same uniqueness properties of the verifier for the COMMIT operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
検証は、COMMIT操作のための検証の同じ一意性の性質を持っている必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.2. Server Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.2。サーバーの障害と復旧
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server loses locking state (usually as a result of a restart or reboot), it must allow clients time to discover this fact and re-establish the lost locking state. The client must be able to re-establish the locking state without having the server deny valid requests because the server has granted conflicting access to another client. Likewise, if there is the possibility that clients have not yet re-established their locking state for a file, the server must disallow READ and WRITE operations for that file. The duration of this recovery period is equal to the duration of the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが（通常は再起動または再起動の結果として）状態をロック失った場合、それはクライアントの時間がこの事実を発見し、失われたロック状態を再確立することを許可する必要があります。クライアントは、サーバーが他のクライアントへのアクセスが競合付与しているため、サーバーは有効な要求を拒否せずにロック状態を再確立することができなければなりません。クライアントがまだファイルのために彼らのロック状態を再確立していない可能性がある場合同様に、サーバはREADを禁止し、そのファイルの操作を記述する必要があります。この回復期間の長さは、リース期間の長さに等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client can determine that server failure (and thus loss of locking state) has occurred, when it receives one of two errors. The NFS4ERR_STALE_STATEID error indicates a stateid invalidated by a reboot or restart. The NFS4ERR_STALE_CLIENTID error indicates a client ID invalidated by reboot or restart. When either of these is received, the client must establish a new client ID (see Section 9.1.1) and re-establish the locking state as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、それが2つのエラーのいずれかを受信した場合、そのサーバの障害（及び状態をロックする、したがって損失）が発生したかを決定することができます。 NFS4ERR_STALE_STATEIDエラーがリブートまたは再起動によって無効たstateidを示しています。 NFS4ERR_STALE_CLIENTIDエラーがリブートまたは再起動によって無効化クライアントIDを示します。これらのいずれかを受信した場合、クライアントは新しいクライアントIDを確立する必要があります（9.1.1項を参照）、以下に説明するように、ロック状態を再確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The period of special handling of locking and READs and WRITEs, equal in duration to the lease period, is referred to as the &#34;grace period&#34;. During the grace period, clients recover locks and the associated state by reclaim-type locking requests (i.e., LOCK requests with reclaim set to TRUE and OPEN operations with a claim type of either CLAIM_PREVIOUS or CLAIM_DELEGATE_PREV). During the grace period, the server must reject READ and WRITE operations and non-reclaim locking requests (i.e., other LOCK and OPEN operations) with an error of NFS4ERR_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リース期間の持続時間が等しいロックおよび読み取りおよび書き込みの特別な処理の期間は、「猶予期間」と呼びます。猶予期間中、クライアントは再利用型のロック要求によってロックと関連した状態を回復（すなわち、CLAIM_PREVIOUS又はCLAIM_DELEGATE_PREVいずれかのクレームの種類とTRUEとOPEN操作に設定され再利用とロック要求）。猶予期間中、サーバはNFS4ERR_GRACEのエラーで読み取りおよび書き込み操作と非再利用ロック要求（すなわち、他のLOCKとOPEN操作）を拒否しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server can reliably determine that granting a non-reclaim request will not conflict with reclamation of locks by other clients, the NFS4ERR_GRACE error does not have to be returned and the non-reclaim client request can be serviced. For the server to be able to service READ and WRITE operations during the grace period, it must again be able to guarantee that no possible conflict could arise between an impending reclaim locking request and the READ or WRITE operation. If the server is unable to offer that guarantee, the NFS4ERR_GRACE error must be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが確実に非再利用要求を許可すると、他のクライアントによるロックの再生と競合しないだろうと判断できる場合は、NFS4ERR_GRACEエラーが返されると、非再利用のクライアント要求をサービスすることができていません。サーバが猶予期間中に読み取りおよび書き込み操作にサービスを提供できるようにするには、再び何の可能性競合が要求およびREADまたはWRITE操作をロックする差し迫った再利用の間で発生することができなかったことを保証することができなければなりません。サーバがその保証を提供することができない場合は、NFS4ERR_GRACEエラーがクライアントに返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a server to provide simple, valid handling during the grace period, the easiest method is to simply reject all non-reclaim locking requests and READ and WRITE operations by returning the NFS4ERR_GRACE error. However, a server may keep information about granted locks in stable storage. With this information, the server could determine if a regular lock or READ or WRITE operation can be safely processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが猶予期間中に、単純な、有効な処理を提供するために、最も簡単な方法は、単純にNFS4ERR_GRACEエラーを返すことによって、要求とREADとWRITE操作をロックするすべての非再利用を拒否することです。ただし、サーバーは安定したストレージに付与されたロックに関する情報を保持することができます。通常のロックまたはREADまたはWRITE操作を安全に処理できる場合は、この情報を使用して、サーバが決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if a count of locks on a given file is available in stable storage, the server can track reclaimed locks for the file, and when all reclaims have been processed, non-reclaim locking requests may be processed. This way, the server can ensure that non-reclaim locking requests will not conflict with potential reclaim requests. With respect to I/O requests, if the server is able to determine that there are no outstanding reclaim requests for a file by information from stable storage or another similar mechanism, the processing of I/O requests could proceed normally for the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、指定したファイルのロックのカウントが安定したストレージに利用可能な場合、サーバーは、ファイルのロックを再利用追跡することができ、すべての再要求が処理されたとき、非再利用ロック要求を処理することができます。この方法では、サーバーは非再利用ロック要求は、潜在的な再利用の要求と競合しないことを確実にすることができます。 I / O要求に対して、サーバが安定したストレージまたは他の同様の機構からの情報により、ファイルに対する未処理の再利用の要求が存在しないことを決定することができるならば、I / O要求の処理は、ファイルを正常に進行できました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To reiterate, for a server that allows non-reclaim lock and I/O requests to be processed during the grace period, it MUST determine that no lock subsequently reclaimed will be rejected and that no lock subsequently reclaimed would have prevented any I/O operation processed during the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
猶予期間中に処理するために、非再利用ロックおよびI / O要求を可能にするサーバに対して、繰り返しに、それはその後埋め立て何のロックが拒否されないことを決定する必要があり、その後、埋め立て何のロックは任意のI / O操作を妨げないだろうということ猶予期間中に処理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients should be prepared for the return of NFS4ERR_GRACE errors for non-reclaim lock and I/O requests. In this case, the client should employ a retry mechanism for the request. A delay (on the order of several seconds) between retries should be used to avoid overwhelming the server. Further discussion of the general issue is included in [Floyd]. The client must account for the server that is able to perform I/O and non-reclaim locking requests within the grace period as well as those that cannot do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、非再利用のためのロックNFS4ERR_GRACEエラーのリターンのために準備し、I ​​/ O要求されなければなりません。この場合、クライアントは要求の再試行メカニズムを採用する必要があります。再試行の間（数秒程度）の遅延は、サーバーを圧倒回避するために使用する必要があります。一般的な問題のさらなる議論は[フロイド]に含まれています。クライアントがそうすることができないものだけでなく、猶予期間内にI / Oと非再利用ロック要求を行うことが可能であるサーバーを考慮に入れなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A reclaim-type locking request outside the server&#39;s grace period can only succeed if the server can guarantee that no conflicting lock or I/O request has been granted since reboot or restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが競合するロックまたはI / O要求を再起動や再起動してから付与されていないことを保証することができた場合、サーバーの猶予期間外の再利用型のロック要求にのみ成功することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server may, upon restart, establish a new value for the lease period. Therefore, clients should, once a new client ID is established, refetch the lease_time attribute and use it as the basis for lease renewal for the lease associated with that server. However, the server must establish, for this restart event, a grace period at least as long as the lease period for the previous server instantiation. This allows the client state obtained during the previous server instance to be reliably re-established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、再起動時に、リース期間のための新しい値を確立することができます。新しいクライアントIDが確​​立されるため、クライアントは、lease_time属性を再フェッチし、そのサーバーに関連付けられているリースのリース更新のための基礎としてそれを使用する必要があります。ただし、サーバはこの再起動イベント、猶予期間、少なくとも限り、以前のサーバインスタンス化のためのリース期間のために、確立する必要があります。これは、以前のサーバインスタンスの間に取得したクライアントの状態が確実に再確立することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3. Network Partitions and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3。ネットワークパーティションと回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the duration of a network partition is greater than the lease period provided by the server, the server will have not received a lease renewal from the client. If this occurs, the server may cancel the lease and free all locks held for the client. As a result, all stateids held by the client will become invalid or stale. Once the client is able to reach the server after such a network partition, all I/O submitted by the client with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once this error is received, the client will suitably notify the application that held the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークパーティションの期間は、サーバーが提供するリース期間よりも大きい場合、サーバはクライアントからのリースの更新を受け取っていないだろう。この問題が発生した場合、サーバはリースをキャンセルして、クライアントのために開催されたすべてのロックを解放することがあります。その結果、クライアントが保持しているすべてのstateidsが無効または古くなります。クライアントは、そのようなネットワークパーティションの後にサーバーにアクセスできるようになると、すべてのIエラーNFS4ERR_EXPIREDを返すサーバーで失敗します今無効のstateidsでクライアントによって提出/ O。このエラーが受信されると、クライアントは、適切にロックを保持するアプリケーションに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.1. Courtesy Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.1。礼儀のロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a courtesy to the client or as an optimization, the server may continue to hold locks, including delegations, on behalf of a client for which recent communication has extended beyond the lease period, delaying the cancellation of the lease. If the server receives a lock or I/O request that conflicts with one of these courtesy locks or if it runs out of resources, the server MAY cause lease cancellation to occur at that time and henceforth return NFS4ERR_EXPIRED when any of the stateids associated with the freed locks is used. If lease cancellation has not occurred and the server receives a lock or I/O request that conflicts with one of the courtesy locks, the requirements are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントへの礼儀として、または最適化として、サーバは、最近の通信は、リースの解約を遅らせる、リース期間を超えて延長していたために、クライアントに代わって、代表団を含め、ロックを保持し続けることができます。サーバーは、ロックまたはこれらの礼儀ロックの一つと競合するか、リソースを使い果たした場合、サーバはその時点でリースのキャンセルが発生する可能性がありと今後のstateidsのいずれかに関連付けられているときNFS4ERR_EXPIREDを返すI / O要求を受信した場合解放されたロックが使用されています。リースのキャンセルが発生していないと、サーバーが礼儀ロックの一つと競合するロックまたはI / O要求を受けた場合は、次のように要件は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In the case of a courtesy lock that is not a delegation, it MUST free the courtesy lock and grant the new request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O委任ではない礼儀ロックの場合は、それが礼儀ロックを解放し、新しい要求を付与する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In the case of a lock or an I/O request that conflicts with a delegation that is being held as a courtesy lock, the server MAY delay resolution of the request but MUST NOT reject the request and MUST free the delegation and grant the new request eventually.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oロックや礼儀ロックとして開催されている代表団と競合するI / O要求の場合、サーバーは、要求の解決を遅らせるかもしれませんが、要求を拒否してはならないと委任を解放し、新しいを付与する必要があります最終的に要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In the case of a request for a delegation that conflicts with a delegation that is being held as a courtesy lock, the server MAY grant the new request or not as it chooses, but if it grants the conflicting request, the delegation held as a courtesy lock MUST be freed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O礼儀ロックとして開催されている代表団と競合する代表団のための要求の場合、サーバーは新しい要求を許可またはない、それが選択したとして、それが矛盾する要求を許可した場合、代表団は、として保持してもよい（MAY）礼儀ロックを解放しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server does not reboot or cancel the lease before the network partition is healed, when the original client tries to access a courtesy lock that was freed, the server SHOULD send back an NFS4ERR_BAD_STATEID to the client. If the client tries to access a courtesy lock that was not freed, then the server SHOULD mark all of the courtesy locks as implicitly being renewed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークパーティションが癒される前に、サーバがリースを再起動するか、キャンセルしていない場合は、元のクライアントは解放された礼儀ロックにアクセスしようとすると、サーバはクライアントにNFS4ERR_BAD_STATEIDを送り返すべきです。クライアントが解放されていなかった礼儀ロックにアクセスしようとすると、暗黙的に更新されるように、サーバは礼儀ロックのすべてをマークすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.2. Lease Cancellation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.2。リースキャンセル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a result of lease expiration, leases may be canceled, either immediately upon expiration or subsequently, depending on the occurrence of a conflicting lock or extension of the period of partition beyond what the server will tolerate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リース満了の結果、リースは競合ロックまたはサーバーが許容する範囲を超えてパーティションの期間の延長の発生に応じて、すぐに満了により、またはその後のいずれか、キャンセルすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a lease is canceled, all locking state associated with it is freed, and the use of any of the associated stateids will result in NFS4ERR_EXPIRED being returned. Similarly, the use of the associated clientid will result in NFS4ERR_EXPIRED being returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リースが解除されると、それに関連付けられたすべてのロック状態が解放され、そして関連のstateidsのいずれかの使用はNFS4ERR_EXPIREDが返されることになります。同様に、関連したクライアントIDの使用はNFS4ERR_EXPIREDが返されることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client should recover from this situation by using SETCLIENTID followed by SETCLIENTID_CONFIRM, in order to establish a new clientid. Once a lock is obtained using this clientid, a lease will be established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが新しいのclientidを確立するために、SETCLIENTID_CONFIRM続いSETCLIENTIDを使用して、このような状況から回復する必要があります。ロックがこれにClientIDを使用して取得されると、リースが確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.3. Client&#39;s Reaction to a Freed Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.3。フリード・ロックへのクライアントの反応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is no way for a client to predetermine how a given server is going to behave during a network partition. When the partition heals, the client still has either all of its locks, some of its locks, or none of them. The client will be able to examine the various error return values to determine its response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが特定のサーバがネットワークパーティション時に動作するように起こっているかを予め決定する方法はありません。パーティションが癒しすると、クライアントはまだどちらかのロックのすべて、そのロックの一部、またはそれらのどれを持っています。クライアントは、その応答を決定するために、さまざまなエラーの戻り値を調べることができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_EXPIRED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_EXPIRED：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All locks have been freed as a result of a lease cancellation that occurred during the partition. The client should use a SETCLIENTID to recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのロックは、パーティション中に発生したリース解約の結果として解放されました。クライアントが回復するSETCLIENTIDを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_ADMIN_REVOKED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_ADMIN_REVOKED：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current lock has been revoked before, during, or after the partition. The client SHOULD handle this error as it normally would.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のロックは中、またはパーティションの後に、以前に取り消されました。クライアントは通常どおり、このエラーを処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_BAD_STATEID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_BAD_STATEID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current lock has been revoked/released during the partition, and the server did not reboot. Other locks MAY still be renewed. The client need not do a SETCLIENTID and instead SHOULD probe via a RENEW call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のロックは、パーティション中にリリース/取り消された、サーバが再起動しませんでした。その他のロックはまだ更新することができます。クライアントはSETCLIENTIDを行うと、代わりにRENEWコールを介してプローブすべきである必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_RECLAIM_BAD:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_RECLAIM_BAD：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current lock has been revoked during the partition, and the server rebooted. The server might have no information on the other locks. They may still be renewable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のロックは、パーティション中に取り消された、サーバを再起動します。サーバーは、他のロックについての情報を持っていないかもしれません。彼らはまだ、再生可能かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_NO_GRACE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_NO_GRACE：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client&#39;s locks have been revoked during the partition, and the server rebooted. None of the client&#39;s locks will be renewable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのロックは、パーティションの間に失効している、そしてサーバーを再起動します。クライアントのロックのいずれも再生可能になることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_OLD_STATEID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_OLD_STATEID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server has not rebooted. The client SHOULD handle this error as it normally would.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが再起動されていません。クライアントは通常どおり、このエラーを処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4. Edge Conditions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4。エッジ条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a network partition is combined with a server reboot, then both the server and client have responsibilities to ensure that the client does not reclaim a lock that it should no longer be able to access. Briefly, those are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークパーティションがサーバの再起動と組み合わされた場合、サーバとクライアントの両方は、クライアントが、もはやアクセスすることがあってはならないというロックを再利用しないことを確実にするために責任を持っています。簡単に言えば、それらは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Client&#39;s responsibility: A client MUST NOT attempt to reclaim any locks that it did not hold at the end of its most recent successfully established client lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントの責任○：クライアントは、その直近の確立に成功したクライアントのリースの終了時に保有していなかったのすべてのロックを再要求してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Server&#39;s responsibility: A server MUST NOT allow a client to reclaim a lock unless it knows that it could not have since granted a conflicting lock. However, in deciding whether a conflicting lock could have been granted, it is permitted to assume that its clients are responsible, as above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバーの責任：サーバは、それがあるため、競合するロックが付与されていることができなかったことを知っている場合を除き、クライアントがロックを取り戻すのを許してはなりません。しかし、競合ロックが付与されていることができるかどうかを決定する際に、そのクライアントは、上記のように、責任があると仮定することが許されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server may consider a client&#39;s lease &#34;successfully established&#34; once it has received an OPEN operation from that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、クライアントからのOPEN操作を受けた後、サーバーは、クライアントのリースが「正常に確立」を検討してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The above are directed to CLAIM_PREVIOUS reclaims and not to CLAIM_DELEGATE_PREV reclaims, which generally do not involve a server reboot. However, when a server persistently stores delegation information to support CLAIM_DELEGATE_PREV across a period in which both client and server are down at the same time, similar strictures apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記はCLAIM_PREVIOUSに向けられている再利用およびCLAIM_DELEGATE_PREVに、一般的にサーバーの再起動を伴わないもの、再利用していません。しかし、サーバが永続的にクライアントとサーバの両方が同時にダウンしていた期間を越えCLAIM_DELEGATE_PREVをサポートするための委任情報を格納する際、同様の狭窄が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The next sections give examples showing what can go wrong if these responsibilities are neglected and also provide examples of server implementation strategies that could meet a server&#39;s responsibilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のセクションでは、これらの責任を無視している場合はうまくいかないと、サーバの責任を果たすことができ、サーバの実装戦略の例を提供することができるものを示す例を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.1. First Server Edge Condition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.1。まずServerエッジの条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first edge condition has the following scenario:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のエッジ条件は、次のシナリオがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Client A acquires a lock.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.クライアントAは、ロックを取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Client A and the server experience mutual network partition, such that client A is unable to renew its lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.クライアントAとサーバの経験の相互ネットワークパーティション、その結果、クライアントAは、そのリースを更新することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Client A&#39;s lease expires, so the server releases the lock.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.クライアントAのリースが期限切れになるので、サーバはロックを解除します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Client B acquires a lock that would have conflicted with that of client A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.クライアントBは、クライアントAのそれと衝突していたロックを取得します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Client B releases the lock.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.クライアントBは、ロックを解除します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. The server reboots.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.サーバーを再起動します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. The network partition between client A and the server heals.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
クライアントAとサーバ間の治癒7.ネットワークパーティション。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
8. Client A issues a RENEW operation and gets back an NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
8.クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Client A reclaims its lock within the server&#39;s grace period.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.クライアントAは、サーバーの猶予期間内にそのロックを再利用します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thus, at the final step, the server has erroneously granted client A&#39;s lock reclaim. If client B modified the object the lock was protecting, client A will experience object corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このように、最後のステップでは、サーバが誤ってクライアントAのロック再利用を許可されています。クライアントBは、ロックが保護されたオブジェクトを変更した場合、クライアントAは、オブジェクトの破損が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.2. Second Server Edge Condition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.2。第二Serverエッジの条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The second known edge condition follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第2の既知のエッジ条件は次のとおり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Client A acquires a lock.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.クライアントAは、ロックを取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. The server reboots.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.サーバーが再起動します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Client A and the server experience mutual network partition, such that client A is unable to reclaim its lock within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.クライアントAとサーバの経験の相互ネットワークパーティション、その結果、クライアントAは、猶予期間内にそのロックを再利用することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. The server&#39;s reclaim grace period ends. Client A has no locks recorded on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.サーバーの再利用の猶予期間が終了します。クライアントAは、サーバに記録されて何のロックを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. Client B acquires a lock that would have conflicted with that of client A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.クライアントBは、クライアントAのそれと衝突していたロックを取得します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Client B releases the lock.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.クライアントBは、ロックを解除します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. The server reboots a second time.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.サーバーを2回再起動します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. The network partition between client A and the server heals.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
クライアントAとサーバ間の治癒8.ネットワークパーティション。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
9. Client A issues a RENEW operation and gets back an NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
9.クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Client A reclaims its lock within the server&#39;s grace period.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.クライアントAは、サーバーの猶予期間内にそのロックを再利用します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As with the first edge condition, the final step of the scenario of the second edge condition has the server erroneously granting client A&#39;s lock reclaim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のエッジ条件と同様に、第2のエッジ条件のシナリオの最終ステップは、誤ってクライアントAのロックの再利用を許可するサーバを有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.3. Handling Server Edge Conditions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.3。サーバエッジ条件の取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In both of the above examples, the client attempts reclaim of a lock that it held at the end of its most recent successfully established lease; thus, it has fulfilled its responsibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の例の両方で、クライアントの試みは、その直近の正常に確立リースの終わりに開催されたロックの再利用します。したがって、それは、その責任を果たしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server, however, has failed, by granting a reclaim, despite having granted a conflicting lock since the reclaimed lock was last held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、しかし、埋立ロックが開催された最後だったので、競合するロックが付与されたにも関わらず、再利用を許可することで、失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Solving these edge conditions requires that the server either (1) assume after it reboots that an edge condition occurs, and thus return NFS4ERR_NO_GRACE for all reclaim attempts, or (2) record some information in stable storage. The amount of information the server records in stable storage is in inverse proportion to how harsh the server wants to be whenever the edge conditions occur. The server that is completely tolerant of all edge conditions will record in stable storage every lock that is acquired, removing the lock record from stable storage only when the lock is unlocked by the client and the lock&#39;s owner advances the sequence number such that the lock release is not the last stateful event for the owner&#39;s sequence. For the two aforementioned edge conditions, the harshest a server can be, and still support a grace period for reclaims, requires that the server record in stable storage some minimal information. For example, a server implementation could, for each client, save in stable storage a record containing:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのエッジ条件を解くと、サーバーは、（1）それは、エッジ状態が発生するリブート後に想定し、したがってすべての試みを再利用するためのNFS4ERR_NO_GRACEを返す、または（2）安定したストレージにいくつかの情報を記録することを必要とします。安定したストレージの情報量サーバーレコードは、サーバーは、エッジ状態が発生するたびになりたいどのように厳しいに反比例します。すべてのエッジ条件の完全耐性のあるサーバーは、ロックがクライアントによってロックが解除され、ロックの所有者は、このようなロック解除そのシーケンス番号を進める場合にのみ、安定したストレージからロック・レコードを削除し、安定したストレージに取得されたすべてのロックを記録します所有者のシーケンスのための最後のステートフルなイベントではありません。前述の2つのエッジ条件について、最も厳しいサーバがあること、そしてまだ再要求のための猶予期間をサポートすることができ、いくつかの最小限の情報安定したストレージで、そのサーバーレコードが必要です。例えば、サーバの実装は、各クライアントのために、安定したストレージに含むレコードを保存できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o the client&#39;s id string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのID文字列O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o a boolean that indicates if the client&#39;s lease expired or if there was administrative intervention (see Section 9.8) to revoke a byte-range lock, share reservation, or delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントのリース期限が切れたり、管理者の介入があった場合（セクション9.8を参照）かどうかを示すブール値はバイト範囲ロック、共有予約、または委任を取り消します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o a timestamp that is updated the first time after a server boot or reboot the client acquires byte-range locking, share reservation, or delegation state on the server. The timestamp need not be updated on subsequent lock requests until the server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバーの起動後、初めての更新またはクライアントを再起動されるタイムスタンプは、サーバー上のバイト範囲ロック、共有予約、または委任状態を取得します。タイムスタンプは、サーバーが再起動するまで、後続のロック要求で更新する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server implementation would also record in stable storage the timestamps from the two most recent server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーの実装も安定したストレージに最新の2回のサーバーが再起動からのタイムスタンプを記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Assuming the above record keeping, for the first edge condition, after the server reboots, the record that client A&#39;s lease expired means that another client could have acquired a conflicting record lock, share reservation, or delegation. Hence, the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE or NFS4ERR_RECLAIM_BAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のエッジ条件のために、上記の記録保持を仮定すると、サーバーの再起動後、クライアントAのリースが期限切れという記録は、別のクライアントが競合レコードロック、共有予約、または委任を取得していることを意味します。したがって、サーバーはエラーNFS4ERR_NO_GRACEまたはNFS4ERR_RECLAIM_BADでクライアントAからの再利用を拒否しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the second edge condition, after the server reboots for a second time, the record that the client had an unexpired record lock, share reservation, or delegation established before the server&#39;s previous incarnation means that the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE or NFS4ERR_RECLAIM_BAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第2のエッジ状態の場合、二回目のためにサーバの再起動後、クライアントは、期限が切れていないレコードロック、共有予約、または委任を持っていたという記録は、サーバーの前の化身はサーバーのクライアントAからの再利用を拒否しなければならないことを意味する前に設立しますエラーNFS4ERR_NO_GRACEまたはNFS4ERR_RECLAIM_BAD。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Regardless of the level and approach to record keeping, the server MUST implement one of the following strategies (which apply to reclaims of share reservations, byte-range locks, and delegations):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
かかわらず、記録保持のレベルやアプローチの、サーバは、（株予約、バイト範囲ロック、および代表団の再利用に適用されます）次のいずれかを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Reject all reclaims with NFS4ERR_NO_GRACE. This is extremely harsh but is necessary if the server does not want to record lock state in stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. NFS4ERR_NO_GRACEですべてを再要求を拒否します。これは非常に厳しいですが、サーバーが安定したストレージにロック状態を記録したくない場合に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Record sufficient state in stable storage to meet its responsibilities. In doubt, the server should err on the side of being harsh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その責任を果たすために安定したストレージ2.録音十分な状態。疑いで、サーバーは厳しいというの側に誤るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       In the event that, after a server reboot, the server determines
       that there is unrecoverable damage or corruption to stable
       storage, then for all clients and/or locks affected, the server
       MUST return NFS4ERR_NO_GRACE.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.4. Client Edge Condition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.4。クライアントの縁の条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A third edge condition affects the client and not the server. If the server reboots in the middle of the client reclaiming some locks and then a network partition is established, the client might be in the situation of having reclaimed some, but not all, locks. In that case, a conservative client would assume that the non-reclaimed locks were revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第三縁の条件は、クライアントとサーバーではなく影響を与えます。サーバーは、いくつかのロックを再利用するクライアントの途中で再起動し、その後、ネットワークパーティションが確立され、クライアントは、いくつかを再利用した状況でも、すべてではないが、ロック可能性があります。場合その場合には、保守的なクライアントは、非埋立ロックが取り消されたことを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The third known edge condition follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第三の既知のエッジ条件は次のとおり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Client A acquires a lock 1.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.クライアントAは、ロック1を獲得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Client A acquires a lock 2.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.クライアントAは、ロック2を獲得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. The server reboots.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.サーバーが再起動します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Client A issues a RENEW operation and gets back an NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Client A reclaims its lock 1 within the server&#39;s grace period.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.クライアントAは、サーバーの猶予期間内にそのロック1を再利用します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. Client A and the server experience mutual network partition, such that client A is unable to reclaim its remaining locks within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6.クライアントAとサーバの経験の相互ネットワークパーティション、その結果、クライアントAは、猶予期間内にその残りのロックを再利用することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. The server&#39;s reclaim grace period ends.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.サーバーの再利用の猶予期間が終了します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
8. Client B acquires a lock that would have conflicted with client A&#39;s lock 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
8.クライアントBは、クライアントAのロック2と競合しているだろうロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Client B releases the lock.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.クライアントBは、ロックを解除します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. The server reboots a second time.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.サーバーを2回再起動します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. The network partition between client A and the server heals.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.クライアントAとサーバ治癒の間にネットワークパーティション。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
12. Client A issues a RENEW operation and gets back an NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
12.クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
13. Client A reclaims both lock 1 and lock 2 within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
13.クライアントAは両方が1をロックして、サーバーの猶予期間内に2ロック再利用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At the last step, the client reclaims lock 2 as if it had held that lock continuously, when in fact a conflicting lock was granted to client B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実際には矛盾するロックがクライアントBに付与されたとき、最後のステップでは、クライアントは、それが継続的にロックし、その保有していたかのように2をロック再利用します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This occurs because the client failed its responsibility, by attempting to reclaim lock 2 even though it had not held that lock at the end of the lease that was established by the SETCLIENTID after the first server reboot. (The client did hold lock 2 on a previous lease, but it is only the most recent lease that matters.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、それが最初のサーバの再起動後にSETCLIENTIDによって設立されたリースの終わりにそのロックを保有していなかったにもかかわらず、ロック2を再利用しようとすることで、その責任を失敗したために発生します。 （クライアントは、以前のリースのロック2を保持していたが、それは重要なだけで、最新のリースです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server could avoid this situation by rejecting the reclaim of lock 2. However, to do so accurately, it would have to ensure that additional information about individual locks held survives a reboot. Server implementations are not required to do that, so the client must not assume that the server will.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは正確に、それが開催された個々のロックに関する追加情報は、再起動を生き残ることを保証しなければならないでしょうそうする、しかしロック2の再生利用を拒否することによって、このような状況を避けることができます。サーバ実装はそれを行うために必要とされていないので、クライアントは、サーバーがすると仮定してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Instead, a client MUST reclaim only those locks that it successfully acquired from the previous server instance, omitting any that it failed to reclaim before a new reboot. Thus, in the last step above, client A should reclaim only lock 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代わりに、クライアントは、それが新しいリブートの前に再利用するために失敗したことを任意のを省略し、それが成功し、以前のサーバインスタンスから取得したもののみロックを再要求しなければなりません。したがって、上記の最後のステップで、クライアントAはロック1を取り戻す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.5. Client&#39;s Handling of Reclaim Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6.3.4.5。取り戻すエラーのクライアントの取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A mandate for the client&#39;s handling of the NFS4ERR_NO_GRACE and NFS4ERR_RECLAIM_BAD errors is outside the scope of this specification, since the strategies for such handling are very dependent on the client&#39;s operating environment. However, one potential approach is described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのような取扱いのための戦略は、クライアントの動作環境に非常に依存しているので、NFS4ERR_NO_GRACEとNFS4ERR_RECLAIM_BADエラーのクライアントの処理のための任務は、この仕様の範囲外です。しかしながら、潜在的なアプローチは、以下に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client&#39;s reclaim fails, it could examine the change attribute of the objects the client is trying to reclaim state for, and use that to determine whether to re-establish the state via normal OPEN or LOCK requests. This is acceptable, provided the client&#39;s operating environment allows it. In other words, the client implementer is advised to document the behavior for his users. The client could also inform the application that its byte-range lock or share reservations (whether they were delegated or not) have been lost, such as via a UNIX signal, a GUI pop-up window, etc. See Section 10.5 for a discussion of what the client should do for dealing with unreclaimed delegations on client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントの再利用に障害が発生した場合、それは、クライアントがために状態を再利用しようとしているオブジェクトの変化属性を調べ、通常のOPENまたはLOCKリクエストを経由して状態を再確立するかどうかを決定するためにそれを使用することができます。これは、クライアントの動作環境がそれを可能に提供し、許容可能です。つまり、クライアントの実装者は、彼のユーザーのための行動を文書化することをお勧めします。また、クライアントは、そのバイト範囲ロックまたは共有の予約が（彼らは委任されたかどうか）などUNIX信号、GUIポップアップウィンドウなどの議論については、セクション10.5を参照してください経由として、失われたアプリケーションを通知することができクライアントは、クライアントの状態にunreclaimed代表団に対処するために何をすべきかの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For further discussion of revocation of locks, see Section 9.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロックの取消しのさらなる議論については、セクション9.8を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. Recovery from a Lock Request Timeout or Abort
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7。ロック要求のタイムアウトや中止からの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the event a lock request times out, a client may decide to not retry the request. The client may also abort the request when the process for which it was issued is terminated (e.g., in UNIX due to a signal). It is possible, though, that the server received the request and acted upon it. This would change the state on the server without the client being aware of the change. It is paramount that the client resynchronize state with the server before it attempts any other operation that takes a seqid and/or a stateid with the same state-owner. This is straightforward to do without a special resynchronize operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロック要求がタイムアウトする場合には、クライアントが要求を再試行しないことを決定することができます。それが発行されたプロセスが終了すると、クライアントは、（原因信号にUNIXで、例えば）要求を中止することができます。これは、サーバーが要求を受信し、それに作用すること、しかし、可能です。これは、クライアントが変更を意識することなく、サーバー上の状態を変更することになります。 SEQIDおよび/または同じ状態所有者とのstateidをとり、他の操作を試みる前に、クライアントがサーバーとの状態を再同期することを最優先事項です。これは、特別な再同期操作なしで行うことは簡単です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the server maintains the last lock request and response received on the state-owner, for each state-owner, the client should cache the last lock request it sent such that the lock request did not receive a response. From this, the next time the client does a lock operation for the state-owner, it can send the cached request, if there is one, and if the request was one that established state (e.g., a LOCK or OPEN operation), the server will return the cached result or, if it never saw the request, perform it. The client can follow up with a request to remove the state (e.g., a LOCKU or CLOSE operation). With this approach, the sequencing and stateid information on the client and server for the given state-owner will resynchronize, and in turn the lock state will resynchronize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、要求と応答が国家所有者で受信した最後のロックを維持するので、各状態の所有者のために、クライアントは、それがロック要求が応答を受信しないように送られた最後のロック要求をキャッシュする必要があります。このことから、1が存在する場合、クライアントは国家所有者のためのロック操作を行い、次回は、それは、キャッシュされたリクエストを送信することができ、かつ要求が状態を確立1（例えば、LOCKまたはOPEN操作）であった場合サーバは、要求を見たことがない場合は、それを実行し、キャッシュされた結果を返したりします。クライアントが状態を削除するための要求（例えば、LOCKUまたはCLOSE操作）をフォローアップすることができます。このアプローチでは、与えられた状態、所有者のために、クライアントとサーバー上のシーケンシングとのstateid情報が再同期され、順番にロック状態を再同期します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. Server Revocation of Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8。ロックのサーバーの失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At any point, the server can revoke locks held by a client and the client must be prepared for this event. When the client detects that its locks have been or may have been revoked, the client is responsible for validating the state information between itself and the server. Validating locking state for the client means that it must verify or reclaim state for each lock currently held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意の時点で、サーバは、クライアントが保持しているロックを取り消すことができますし、クライアントは、このイベントのために準備しなければなりません。クライアントは、そのロックがされているか、取り消されたことを検出すると、クライアントは、それ自体とサーバの間で状態情報を検証する責任があります。クライアントのロック状態を検証することは、現在開催され、各ロックの状態を確認したり、再利用しなければならないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first instance of lock revocation is upon server reboot or re-initialization. In this instance, the client will receive an error (NFS4ERR_STALE_STATEID or NFS4ERR_STALE_CLIENTID) and the client will proceed with normal crash recovery as described in the previous section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロック失効の最初のインスタンスは、サーバの再起動または再初期化時です。この場合、クライアントは、エラー（NFS4ERR_STALE_STATEID又はNFS4ERR_STALE_CLIENTID）を受信すると、前のセクションで説明したように、クライアントは、通常のクラッシュ・リカバリを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The second lock revocation event is the inability to renew the lease before expiration. While this is considered a rare or unusual event, the client must be prepared to recover. Both the server and client will be able to detect the failure to renew the lease and are capable of recovering without data corruption. For the server, it tracks the last renewal event serviced for the client and knows when the lease will expire. Similarly, the client must track operations that will renew the lease period. Using the time that each such request was sent and the time that the corresponding reply was received, the client should bound the time that the corresponding renewal could have occurred on the server and thus determine if it is possible that a lease period expiration could have occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第2ロック失効イベントが満了前にリースを更新することができないことです。これは稀なまたは異常なイベントと見なされますが、クライアントが回復する準備をしなければなりません。サーバとクライアントの両方がリースを更新し、データの破損せずに回復することができるに失敗したことを検出することができます。サーバーの場合は、クライアントのためにサービスを最後に更新イベントを追跡し、リースが期限切れになる知っています。同様に、クライアントは、リース期間を更新されます操作を追跡する必要があります。それぞれのそのようなリクエストが送信された時刻と対応する応答が受信された時刻を使用して、クライアントは、対応する更新がサーバー上で発生したので、リース期間の満了が発生している可能性があるかどうかを判断していることができると時間をバインドする必要があり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The third lock revocation event can occur as a result of administrative intervention within the lease period. While this is considered a rare event, it is possible that the server&#39;s administrator has decided to release or revoke a particular lock held by the client. As a result of revocation, the client will receive an error of NFS4ERR_ADMIN_REVOKED. In this instance, the client may assume that only the state-owner&#39;s locks have been lost. The client notifies the lock holder appropriately. The client cannot assume that the lease period has been renewed as a result of a failed operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第三のロック失効イベントがリース期間内に管理者の介入の結果として起こり得ます。これはまれなイベントと見なされているが、サーバーの管理者がクライアントによって保持された特定のロックを解除するか、取り消すことを決めている可能性があります。取り消しの結果、クライアントはNFS4ERR_ADMIN_REVOKEDのエラーを受け取ることになります。この例では、クライアントは、国家所有者のロックが失われていると仮定してよいです。クライアントは、適切にロックホルダを通知します。クライアントは、リース期間は、失敗した操作の結果として更新されたと仮定することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client determines the lease period may have expired, the client must mark all locks held for the associated lease as &#34;unvalidated&#34;. This means the client has been unable to re-establish or confirm the appropriate lock state with the server. As described in Section 9.6, there are scenarios in which the server may grant conflicting locks after the lease period has expired for a client. When it is possible that the lease period has expired, the client must validate each lock currently held to ensure that a conflicting lock has not been granted. The client may accomplish this task by issuing an I/O request; if there is no relevant I/O pending, a zero-length read specifying the stateid associated with the lock in question can be synthesized to trigger the renewal. If the response to the request is success, the client has validated all of the locks governed by that stateid and re-established the appropriate state between itself and the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、リース期間が満了したかもしれないと判断した場合、クライアントは「未検証」として関連付けられたリースのために開催されたすべてのロックをマークする必要があります。これは、クライアントがサーバーとの適切なロック状態を再確立または確認することができなかったことを意味します。セクション9.6で説明したように、リース期間は、クライアントのために有効期限が切れた後に、サーバーが競合するロックを与える可能性のあるシナリオがあります。それは、リース期間が終了している可能性がある場合は、クライアントは各ロックを検証する必要があり、現在、競合するロックが付与されていないことを確認するために開催されました。クライアントは、I / O要求を発行することによって、このタスクを達成することができます。 I / O保留中の該当がない場合、長さゼロの質問にロックに関連付けられたstateidを指定して読んで、更新をトリガするために合成することができます。要求に対する応答が成功の場合、クライアントはそののstateidに支配し、自分自身とサーバの間の適切な状態を再確立ロックのすべてを検証しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the I/O request is not successful, then one or more of the locks associated with the stateid were revoked by the server, and the client must notify the owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
I / O要求が成功しなかった場合、その後のstateidに関連付けられているロックの一つ以上は、サーバによって取り消された、およびクライアントは、所有者に通知しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9. Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9。シェア予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A share reservation is a mechanism to control access to a file. It is a separate and independent mechanism from byte-range locking. When a client opens a file, it issues an OPEN operation to the server specifying the type of access required (READ, WRITE, or BOTH) and the type of access to deny others (OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH). If the OPEN fails, the client will fail the application&#39;s open request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シェア予約は、ファイルへのアクセスを制御するメカニズムです。これは、バイト範囲ロックは別個の独立した機構です。クライアントがファイルを開くと、それは他の人を否定するために必要なアクセスの種類（読み取り、書き込み、またはその両方）とアクセスの種類を指定してサーバにOPEN操作を発行する（OPEN4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_READ、OPEN4_SHARE_DENY_WRITE、またはOPEN4_SHARE_DENY_BOTH）。 OPENが失敗した場合、クライアントは、アプリケーションのオープン要求を失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Pseudo-code definition of the semantics:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セマンティクスの擬似コードの定義：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (request.access == 0) return (NFS4ERR_INVAL) else if ((request.access &amp; file_state.deny) || (request.deny &amp; file_state.access)) return (NFS4ERR_DENIED)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし（request.access == 0）リターン（NFS4ERR_INVAL）それ以外の場合（（request.access＆file_state.deny）||（request.deny＆file_state.access））リターン（NFS4ERR_DENIED）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This checking of share reservations on OPEN is done with no exception for an existing OPEN for the same open-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN上の共有の予約のこのチェックは、同じオープン所有者のための既存のOPENのために例外なく行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The constants used for the OPEN and OPEN_DOWNGRADE operations for the access and deny fields are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにアクセスするためにOPENとOPEN_DOWNGRADE操作に使用してフィールドを否定する定数は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10. OPEN/CLOSE Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10。 OPEN / CLOSE操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To provide correct share semantics, a client MUST use the OPEN operation to obtain the initial filehandle and indicate the desired access and what access, if any, to deny. Even if the client intends to use one of the special stateids (anonymous stateid or READ bypass stateid), it must still obtain the filehandle for the regular file with the OPEN operation so the appropriate share semantics can be applied. Clients that do not have a deny mode built into their programming interfaces for opening a file should request a deny mode of OPEN4_SHARE_DENY_NONE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
正しい共有セマンティクスを提供するために、クライアントは、最初のファイルハンドルを取得するためにOPEN操作を使用しなければならないと拒否し、もしあれば、所望のアクセスと何のアクセスを示しています。クライアントが特別なのstateids（匿名のstateidまたはREADバイパスのstateid）のいずれかを使用しようとする場合であっても、適切な共有のセマンティクスを適用することができますので、それはまだOPEN操作で通常のファイルのためのファイルハンドルを取得する必要があります。ファイルを開くための彼らのプログラミング・インターフェースに組み込まれて拒否モードを持っていないクライアントは、OPEN4_SHARE_DENY_NONEの拒否モードを要求すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OPEN operation with the CREATE flag also subsumes the CREATE operation for regular files as used in previous versions of the NFS protocol. This allows a create with a share to be done atomically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATEフラグをOPEN動作もNFSプロトコルの以前のバージョンで使用されるような、通常のファイルのCREATE操作を包含し。これはアトミックに行われるシェアで作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CLOSE operation removes all share reservations held by the open-owner on that file. If byte-range locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure, NFS4ERR_LOCKS_HELD, if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLOSE操作は、そのファイルのオープン、所有者が保有する全ての株式の予約を削除します。バイト範囲ロックが保持されている場合、クライアントはCLOSEを発行する前に、すべてのロックを解除しなければなりません。サーバーは、CLOSE上のすべての未解決のロックを解放するかもしれが、一部のサーバーがまだ開催されたバイト範囲ロックを持つファイルのCLOSEをサポートしていないかもしれません。すべてのロックは、CLOSEの後に存在するならば、サーバーは、障害が発生、NFS4ERR_LOCKS_HELDを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The LOOKUP operation will return a filehandle without establishing any lock state on the server. Without a valid stateid, the server will assume that the client has the least access. For example, if one client opened a file with OPEN4_SHARE_DENY_BOTH and another client accesses the file via a filehandle obtained through LOOKUP, the second client could only read the file using the special READ bypass stateid. The second client could not WRITE the file at all because it would not have a valid stateid from OPEN and the special anonymous stateid would not be allowed access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOOKUP操作は、サーバー上の任意のロック状態を確立することなくファイルハンドルを返します。有効なstateidがなければ、サーバーは、クライアントが少なくともアクセス権を持っていることを前提としています。 1つのクライアントがOPEN4_SHARE_DENY_BOTHでファイルを開いて、別のクライアントがLOOKUPを経て得られたファイルハンドル経由でファイルにアクセスする場合、例えば、第2のクライアントが唯一の特別READバイパスのstateidを使用してファイルを読み込むことができます。それがアクセスを許可されませんOPENと特別な匿名なstateidから有効なstateidを持っていないため、2番目のクライアントは、すべてのファイルを書き込むことができませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10.1. Close and Retention of State Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10.1。閉じると状態情報の保持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since a CLOSE operation requests deallocation of a stateid, dealing with retransmission of the CLOSE may pose special difficulties, since the state information, which normally would be used to determine the state of the open file being designated, might be deallocated, resulting in an NFS4ERR_BAD_STATEID error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLOSE動作が正常に開いているファイルの状態を決定するために使用される状態情報は、指定されるので、特別な問題を引き起こすことがCLOSEの再送を扱うのstateidの割当て解除を要求するので、NFS4ERR_BAD_STATEIDその結果、割り当て解除される可能性がありますエラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers may deal with this problem in a number of ways. To provide the greatest degree of assurance that the protocol is being used properly, a server should, rather than deallocate the stateid, mark it as close-pending, and retain the stateid with this status, until later deallocation. In this way, a retransmitted CLOSE can be recognized since the stateid points to state information with this distinctive status, so that it can be handled without error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、いくつかの方法でこの問題に対処することがあります。プロトコルが適切に使用されていることを保証の最大度を提供するために、サーバは、のstateidの割り当てを解除するのではなく、それは近く係属マークする必要があり、その後解放されるまで、この状態でのstateidを保持します。このように、再送CLOSEは、それがエラーなしで取り扱うことができるように、この独特の状態との間で情報を述べるのstateidポイント以降に認識することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When adopting this strategy, a server should retain the state information until the earliest of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この戦略を採用する場合、サーバは最古までの状態情報を保持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Another validly sequenced request for the same open-owner, that is not a retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じオープン所有者のためのもう一つの有効にシーケンスされた要求O、それは再送信ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The time that an open-owner is freed by the server due to period with no activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オープン所有者による無活性の期間にサーバによって解放される時、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o All locks for the client are freed as a result of a SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントのためのすべてのロックは、SETCLIENTIDの結果として解放されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers may avoid this complexity, at the cost of less complete protocol error checking, by simply responding NFS4_OK in the event of a CLOSE for a deallocated stateid, on the assumption that this case must be caused by a retransmitted close. When adopting this approach, it is desirable to at least log an error when returning a no-error indication in this situation. If the server maintains a reply-cache mechanism, it can verify that the CLOSE is indeed a retransmission and avoid error logging in most cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、単にこのような場合は、再送近いによって引き起こされなければならないことを前提に、割り当て解除のstateidのためのCLOSEの際にNFS4_OKを応答することにより、より少ない完全なプロトコルエラーチェックのコストで、この複雑さを回避することができます。このアプローチを採用する場合には、この状況で無エラー表示を返すときに、少なくともエラーを記録することが望ましいです。サーバーが応答キャッシュ・メカニズムを維持した場合、それはCLOSEが実際に再送信であることを確認し、ほとんどの場合、エラーログを避けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.11. Open Upgrade and Downgrade
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.11。オープンアップグレードおよびダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an OPEN is done for a file and the open-owner for which the open is being done already has the file open, the result is to upgrade the open file status maintained on the server to include the access and deny bits specified by the new OPEN as well as those for the existing OPEN. The result is that there is one open file, as far as the protocol is concerned, and it includes the union of the access and deny bits for all of the OPEN requests completed. Only a single CLOSE will be done to reset the effects of both OPENs. Note that the client, when issuing the OPEN, may not know that the same file is in fact being opened. The above only applies if both OPENs result in the OPENed object being designated by the same filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENは、ファイルのオープンはまだ行ってファイルを開いているされているオープン所有者のために行われた場合、結果は新しいで指定されたビットへのアクセスを含めると拒否するようにサーバー上に保持開いているファイルのステータスをアップグレードすることです同様に、既存のOPENのものとしてOPEN。結果は限りプロトコルに関しては、1つの開いているファイルがあることであり、それはアクセスの組合を含んでおり、完成OPENすべての要求のためのビットを否定します。つだけCLOSEが開き、両方の効果をリセットするために行われます。 OPENを発行するとき、クライアントは、同じファイルが実際に開かれていることを知らないかもしれないことに注意してください。両方が同じファイルハンドルによって指定されるオープンされたオブジェクトをもたらす開いた場合、上記にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server chooses to export multiple filehandles corresponding to the same file object and returns different filehandles on two different OPENs of the same file object, the server MUST NOT &#34;OR&#34; together the access and deny bits and coalesce the two open files. Instead, the server must maintain separate OPENs with separate stateids and will require separate CLOSEs to free them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、同じファイルオブジェクトに対応する複数のファイルハンドルをエクスポートすることを選択したと同じファイルオブジェクトの二つの異なるのOPENs上の異なるファイルハンドルを返し、サーバーはMUST NOT「OR」一緒にアクセスをしてビットを否定し、2つの開いているファイルを結合する場合。代わりに、サーバは別ののstateidsで別々のOPENsを維持しなければならないし、それらを解放するために別の閉じが必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When multiple open files on the client are merged into a single open file object on the server, the close of one of the open files (on the client) may necessitate change of the access and deny status of the open file on the server. This is because the union of the access and deny bits for the remaining opens may be smaller (i.e., a proper subset) than previously. The OPEN_DOWNGRADE operation is used to make the necessary change, and the client should use it to update the server so that share reservation requests by other clients are handled properly. The stateid returned has the same &#34;other&#34; field as that passed to the server. The seqid value in the returned stateid MUST be incremented (Section 9.1.4), even in situations in which there has been no change to the access and deny bits for the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント上の複数の開いているファイルを、サーバー上の単一のオープンファイルオブジェクトにマージされている場合、（クライアント上）開いているファイルの一つの近くには、アクセスの変更を必要とし、サーバー上の開いているファイルの状態を拒否することができます。アクセスの和集合と残りのためのビットを否定するが、以前よりも（すなわち、適切なサブセット）も小さくてもよい開くからです。 OPEN_DOWNGRADE操作が必要な変更を行うために使用され、他のクライアントがその共有の予約要求が適切に処理されているように、クライアントはサーバーを更新するためにそれを使用する必要があります。返されたstateidはサーバに渡さと同じ「その他」のフィールドがあります。返さのstateidでSEQID値も存在アクセスに変化されず、ファイルのビットを拒否していた状況では、（セクション9.1.4）に増加しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.12. Short and Long Leases
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.12。ショートとロングリース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When determining the time period for the server lease, the usual lease trade-offs apply. Short leases are good for fast server recovery at a cost of increased RENEW or READ (with zero length) requests. Longer leases are certainly kinder and gentler to servers trying to handle very large numbers of clients. The number of RENEW requests drops in proportion to the lease time. The disadvantages of long leases are slower recovery after server failure (the server must wait for the leases to expire and the grace period to elapse before granting new lock requests) and increased file contention (if the client fails to transmit an unlock request, then the server must wait for lease expiration before granting new locks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーのリース期間を決定する際に、通常の賃貸借トレードオフが適用されます。短いリースは（ゼロ長さ）RENEW増加またはREAD要求のコストで高速なサーバー回復のために良いです。長いリースは、クライアントの非常に大きな数字を扱うしようとしているサーバへの確かに親切と穏やかなです。 RENEW要求の数は、リース時間に比例して低下します。クライアントがアンロック要求を送信するために失敗した場合、長いリースの欠点は、その後、（（期限切れにサーバがリースを待たなければなりませんし、新しいロック要求を許可する前に経過する猶予期間）サーバ障害の後に遅い回復と増加したファイルの競合していますサーバーは）新しいロックを許可する前に、リース満了を待たなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Long leases are usable if the server is able to store lease state in non-volatile memory. Upon recovery, the server can reconstruct the lease state from its non-volatile memory and continue operation with its clients, and therefore long leases would not be an issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、不揮発性メモリにリース状態を記憶することが可能であるならばロングリースが使用可能です。回復時に、サーバーは、その不揮発性メモリからリース状態を再構築することができ、そのクライアントとの動作を継続するため、長期リースは問題にならないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.13. Clocks, Propagation Delay, and Calculating Lease Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.13。時計、伝播遅延、および計算リースの有効期限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To avoid the need for synchronized clocks, lease times are granted by the server as a time delta. However, there is a requirement that the client and server clocks do not drift excessively over the duration of the lock. There is also the issue of propagation delay across the network -- which could easily be several hundred milliseconds -- as well as the possibility that requests will be lost and need to be retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同期クロックの必要性を回避するには、リース時間は時間デルタとしてサーバによって付与されます。ただし、クライアントとサーバーのクロックがロックの期間にわたって過度にドリフトしていない要件があります。簡単に数百ミリ秒かもしれない -   - だけでなく、要求が失われ、再送信する必要があります可能性がネットワークを介して伝播遅延の問題もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To take propagation delay into account, the client should subtract it from lease times (e.g., if the client estimates the one-way propagation delay as 200 msec, then it can assume that the lease is already 200 msec old when it gets it). In addition, it will take another 200 msec to get a response back to the server. So the client must send a lock renewal or write data back to the server 400 msec before the lease would expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アカウントに伝播遅延を取るために、クライアントはリース時間からそれを引く必要があります（それはそれを取得する場合、クライアントは200ミリ秒として一方向の伝搬遅延を推定した場合、例えば、それはリースがすでに200ミリ秒古いであると仮定することができます）。また、それは戻って、サーバへの応答を取得するには、別の200ミリ秒かかります。リースが期限切れになるでしょう前に400ミリ秒だから、クライアントは、ロックの更新を送信しなければならないか、サーバーに戻ってデータを書き込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server&#39;s lease period configuration should take into account the network distance of the clients that will be accessing the server&#39;s resources. It is expected that the lease period will take into account the network propagation delays and other network delay factors for the client population. Since the protocol does not allow for an automatic method to determine an appropriate lease period, the server&#39;s administrator may have to tune the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバのリース期間の設定は、アカウントに、サーバーのリソースにアクセスするクライアントのネットワーク距離を取る必要があります。リース期間は、アカウントにクライアント人口のネットワーク伝播遅延およびその他のネットワーク遅延の要因を取ることが期待されます。プロトコルは、適切なリース期間を決定するための自動方法を許可しないので、サーバーの管理者が同調するように、リース期間を有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14. Migration, Replication, and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14。移行、レプリケーション、および州
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When responsibility for handling a given file system is transferred to a new server (migration) or the client chooses to use an alternative server (e.g., in response to server unresponsiveness) in the context of file system replication, the appropriate handling of state shared between the client and server (i.e., locks, leases, stateids, and client IDs) is as described below. The handling differs between migration and replication. For a related discussion of file server state and recovery of same, see the subsections of Section 9.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定したファイルシステムを処理するための責任が新しいサーバー（移行）に転送されるか、クライアントがファイルシステムのレプリケーションのコンテキストで（サーバ不応答に応じて、例えば）代替サーバーを使用することを選択した場合は、状態の適切な取り扱いを間で共有しました後述のように、クライアントとサーバは（すなわち、ロック、リース、のstateids、およびクライアントID）です。取り扱いは、移行と複製の間で異なっています。ファイルサーバの状態と同じの回復の関連については、セクション9.6のサブセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In cases in which one server is expected to accept opaque values from the client that originated from another server, the servers SHOULD encode the opaque values in big-endian byte order. If this is done, the new server will be able to parse values like stateids, directory cookies, filehandles, etc. even if their native byte order is different from that of other servers cooperating in the replication and migration of the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方のサーバーが別のサーバーから発信クライアントからの不透明な値を受け入れることが予想される場合には、サーバはビッグエンディアンのバイト順の不透明値をエンコードする必要があります。これが行われた場合、新しいサーバは、ネイティブのバイト順序は、ファイルシステムの複製や移行に協力他のサーバーとは異なる場合でもなどのstateids、ディレクトリクッキー、ファイルハンドル、のような値を解析することができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.1. Migration and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.1。移行と国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of migration, the servers involved in the migration of a file system SHOULD transfer all server state from the original server to the new server. This must be done in a way that is transparent to the client. This state transfer will ease the client&#39;s transition when a file system migration occurs. If the servers are successful in transferring all state, the client will continue to use stateids assigned by the original server. Therefore, the new server must recognize these stateids as valid. This holds true for the client ID as well. Since responsibility for an entire file system is transferred with a migration event, there is no possibility that conflicts will arise on the new server as a result of the transfer of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
移行の場合には、ファイルシステムの移行に関係するサーバーは、元のサーバーから新しいサーバーにすべてのサーバーの状態を転送する必要があります。これは、クライアントに透過的な方法で行う必要があります。ファイルシステムの移行が発生したときに、この状態転送は、クライアントの移行を容易にします。サーバはすべての状態を転送することに成功している場合、クライアントは元のサーバーによって割り当てられたのstateidsを使用し続けます。そのため、新しいサーバーは有効なものとしてこれらのstateidsを認識しなければなりません。これは、同様に、クライアントのIDについても同様です。ファイルシステム全体の責任が移行イベントで転送されているので、競合はロックの転送の結果として、新しいサーバ上で生じてしまうおそれはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As part of the transfer of information between servers, leases would be transferred as well. The leases being transferred to the new server will typically have a different expiration time from those for the same client, previously on the old server. To maintain the property that all leases on a given server for a given client expire at the same time, the server should advance the expiration time to the later of the leases being transferred or the leases already present. This allows the client to maintain lease renewal of both classes without special effort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ間の情報の転送の一部として、リースは同様に転送されます。新しいサーバーに転送されているリースは、通常、以前に古いサーバーで、同じクライアントのためのものとは異なる有効期限を持っています。与えられたクライアントのために特定のサーバー上のすべてのリースが同時に期限切れに財産を維持するために、サーバーが転送されているリース、または既に存在リースの後のに有効期限を進める必要があります。これにより、クライアントは、特別な努力なしで両方のクラスのリース更新を維持することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The servers may choose not to transfer the state information upon migration. However, this choice is discouraged. In this case, when the client presents state information from the original server (e.g., in a RENEW operation or a READ operation of zero length), the client must be prepared to receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server. The client should then recover its state information as it normally would in response to a server failure. The new server must take care to allow for the recovery of state information as it would in the event of server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、移行時に状態情報を転送しないこともできます。しかし、この選択はお勧めしません。クライアントは、元のサーバから状態情報を提示すると、この場合には、（例えば、RENEW操作またはゼロ長のREAD動作で）、クライアントは、新しいサーバーからNFS4ERR_STALE_CLIENTID又はNFS4ERR_STALE_STATEIDいずれかを受けるように準備されなければなりません。それは通常、サーバーの障害に応じて同じように、クライアントは、その状態情報を復元する必要があります。新しいサーバーは、サーバーの再起動のイベントと同じように状態情報の復旧を可能にするように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client SHOULD re-establish new callback information with the new server as soon as possible, according to sequences described in Sections 16.33 and 16.34. This ensures that server operations are not blocked by the inability to recall delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、セクション16.33と16.34で説明したシーケンスに従って、できるだけ早く新しいサーバーで新しいコールバック情報を再確立する必要があります。これは、サーバーの操作が代表団を思い出すことができないことによってブロックされていないことを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.2. Replication and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.2。レプリケーションと国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since client switch-over in the case of replication is not under server control, the handling of state is different. In this case, leases, stateids, and client IDs do not have validity across a transition from one server to another. The client must re-establish its locks on the new server. This can be compared to the re-establishment of locks by means of reclaim-type requests after a server reboot. The difference is that the server has no provision to distinguish requests reclaiming locks from those obtaining new locks or to defer the latter. Thus, a client re-establishing a lock on the new server (by means of a LOCK or OPEN request), may have the requests denied due to a conflicting lock. Since replication is intended for read-only use of file systems, such denial of locks should not pose large difficulties in practice. When an attempt to re-establish a lock on a new server is denied, the client should treat the situation as if its original lock had been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複製の場合のクライアントスイッチオーバーは、サーバーの管理下にはないので、状態の取り扱いが異なっています。この場合、リース、のstateids、およびクライアントIDは1サーバーから別のサーバーへの移行全体の妥当性を持っていません。クライアントは、新しいサーバー上のロックを再確立する必要があります。これは、サーバの再起動後に再利用型リクエストによってロックの再確立と比較することができます。違いは、サーバーがそれらの取得新しいロックからロックを再利用要求を区別するか、後者を延期することを想定していませんということです。このように、クライアントの再確立新しいサーバーのロックを（LOCKまたはOPENのリクエストによる）は、競合ロックが原因で拒否されたリクエストを有することができます。複製は、ファイル・システムの読み取り専用の使用を意図しているので、ロックのように否定は実際には大きな困難をもたらすべきではありません。新しいサーバーにロックを再確立しようとする試みが拒否された場合は、元のロックが取り消されたかのように、クライアントは状況を扱うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.3. Notification of Migrated Lease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.3。移行したリースの通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of lease renewal, the client may not be submitting requests for a file system that has been migrated to another server. This can occur because of the implicit lease renewal mechanism. The client renews leases for all file systems when submitting a request to any one file system at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リース更新の場合、クライアントは別のサーバに移行されたファイルシステムに対する要求を提出することはできません。これは、暗黙のリース更新機構から発生する可能性があります。サーバーのいずれかのファイルシステムに要求を提出するとき、クライアントは、すべてのファイルシステムのためのリースを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order for the client to schedule renewal of leases that may have been relocated to the new server, the client must find out about lease relocation before those leases expire. To accomplish this, all operations that implicitly renew leases for a client (such as OPEN, CLOSE, READ, WRITE, RENEW, LOCK, and others) will return the error NFS4ERR_LEASE_MOVED if responsibility for any of the leases to be renewed has been transferred to a new server. This condition will continue until the client receives an NFS4ERR_MOVED error and the server receives the subsequent GETATTR(fs_locations) for an access to each file system for which a lease has been moved to a new server. By convention, the compound including the GETATTR(fs_locations) SHOULD append a RENEW operation to permit the server to identify the client doing the access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのリース期限が切れる前に新しいサーバーに移転されている可能性がリースの更新をスケジュールするクライアントのために、クライアントは、リースの再配置を知る必要があります。更新するリースのいずれかの責任がに転送された場合は、これを達成するために、暗黙的に（例えばOPEN、CLOSE、READ、WRITE、RENEW、LOCK、および他のような）クライアントのリースを更新するすべての操作はエラーNFS4ERR_LEASE_MOVEDを返します。新しいサーバー。クライアントがNFS4ERR_MOVEDエラーを受信して​​、サーバがリースを新しいサーバーに移動された各ファイルシステムにアクセスするために、その後のGETATTR（fs_位置）を受信するまで、この状態が継続されます。慣例により、GETATTR（fs_位置）を含む化合物は、アクセスをしているクライアントを識別するために、サーバーを許可するRENEW操作を追加すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon receiving the NFS4ERR_LEASE_MOVED error, a client that supports file system migration MUST probe all file systems from that server on which it holds open state. Once the client has successfully probed all those file systems that are migrated, the server MUST resume normal handling of stateful requests from that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_LEASE_MOVEDエラーを受信すると、ファイルシステムの移行をサポートするクライアントは、それが開いた状態を保持する上で、そのサーバーからすべてのファイルシステムを調査しなければなりません。クライアントが正常に移行されているすべてのそれらのファイルシステムを探索した後は、サーバーはそのクライアントからステートフル要求の通常の取り扱いを再開しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to support legacy clients that do not handle the NFS4ERR_LEASE_MOVED error correctly, the server SHOULD time out after a wait of at least two lease periods, at which time it will resume normal handling of stateful requests from all clients. If a client attempts to access the migrated files, the server MUST reply with NFS4ERR_MOVED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
正しくNFS4ERR_LEASE_MOVEDのエラーを処理していないレガシークライアントをサポートするために、サーバーは、それがすべてのクライアントからのリクエストのステートフルの通常の取り扱いを再開しますその時点で少なくとも二つのリース期間の待機後にタイムアウトすべきです。クライアントが移行されたファイルにアクセスしようとすると、サーバはNFS4ERR_MOVEDに返答しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client receives an NFS4ERR_MOVED error, the client can follow the normal process to obtain the new server information (through the fs_locations attribute) and perform renewal of those leases on the new server. If the server has not had state transferred to it transparently, the client will receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server, as described above. The client can then recover state information as it does in the event of server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがNFS4ERR_MOVEDエラーを受信した場合、クライアントは、（fs_位置の属性で）新しいサーバーの情報を取得するために、通常のプロセスに従うと、新しいサーバー上のリースの更新を行うことができます。サーバは状態が透過的に転送されなかった場合は、上記のように、クライアントは、新しいサーバーからNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_STALE_STATEIDのいずれかを受け取ることになります。それは、サーバーに障害が発生した場合に行うように、クライアントは、状態情報を復元することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.4. Migration and the lease_time Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.14.4。移行とlease_time属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order that the client may appropriately manage its leases in the case of migration, the destination server must establish proper values for the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが適切に移行した場合にそのリースを管理できるように、送信先サーバーはlease_time属性の適切な値を確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When state is transferred transparently, that state should include the correct value of the lease_time attribute. The lease_time attribute on the destination server must never be less than that on the source since this would result in premature expiration of leases granted by the source server. Upon migration, in which state is transferred transparently, the client is under no obligation to refetch the lease_time attribute and may continue to use the value previously fetched (on the source server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
状態が透過的に転送されると、その状態はlease_time属性の正しい値を含むべきです。これは、ソースサーバによって付与されたリースの早期満了ことになるので、先サーバー上のlease_time属性は、ソース上のそれよりも少ないにすることはできません。透過的に転送される状態に移行すると、クライアントはlease_time属性を再フェッチし、（ソースサーバ上の）以前にフェッチされた値を使用し続けるかもしれない義務です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If state has not been transferred transparently (i.e., the client sees a real or simulated server reboot), the client should fetch the value of lease_time on the new (i.e., destination) server and use it for subsequent locking requests. However, the server must respect a grace period at least as long as the lease_time on the source server, in order to ensure that clients have ample time to reclaim their locks before potentially conflicting non-reclaimed locks are granted. The means by which the new server obtains the value of lease_time on the old server is left to the server implementations. It is not specified by the NFSv4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
状態は（つまり、クライアントが本物か、シミュレートされたサーバーの再起動を見て）透過的に転送されていない場合、クライアントは、新しい（すなわち、宛先）サーバー上lease_timeの値を取得し、後続のロック要求のためにそれを使用する必要があります。ただし、サーバは潜在的に競合非埋立ロックが付与される前に、クライアントがロックを取り戻すために十分な時間を持っていることを確実にするためには、少なくとも限り、ソースサーバー上のlease_timeとして、猶予期間を尊重しなければなりません。新しいサーバーは、古いサーバー上lease_timeの値を取得する手段は、サーバの実装に任されています。これは、NFSv4のプロトコルによって指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.クライアント側のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client-side caching of data, file attributes, and filenames is essential to providing good performance with the NFS protocol. Providing distributed cache coherence is a difficult problem, and previous versions of the NFS protocol have not attempted it. Instead, several NFS client implementation techniques have been used to reduce the problems that a lack of coherence poses for users. These techniques have not been clearly defined by earlier protocol specifications, and it is often unclear what is valid or invalid client behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データ、ファイル属性、およびファイル名のクライアント側のキャッシュは、NFSプロトコルで良好なパフォーマンスを提供するために不可欠です。分散キャッシュの一貫性を提供することは困難な問題であり、およびNFSプロトコルの以前のバージョンではそれをしようとしていません。代わりに、いくつかのNFSクライアントの実装技術は、一貫性の欠如は、ユーザーのためのポーズの問題を軽減するために使用されています。これらの技術は明らかに以前のプロトコル仕様で定義されていない、有効か無効クライアントの動作が何であるかを、多くの場合不明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol uses many techniques similar to those that have been used in previous protocol versions. The NFSv4 protocol does not provide distributed cache coherence. However, it defines a more limited set of caching guarantees to allow locks and share reservations to be used without destructive interference from client-side caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4プロトコルは、以前のプロトコルバージョンで使用されたものと同様の多くの技術を使用します。 NFSv4のプロトコルは、分散キャッシュの一貫性を提供していません。しかし、ロックと共有の予約がクライアント側のキャッシュからの破壊的干渉なしに使用することができるようにキャッシング保証のより限定されたセットを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, the NFSv4 protocol introduces a delegation mechanism that allows many decisions normally made by the server to be made locally by clients. This mechanism provides efficient support of the common cases where sharing is infrequent or where sharing is read-only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、NFSv4のプロトコルは、通常、サーバーによって行われた多くの決定は、クライアントによってローカルで行うことを可能にする委譲メカニズムを導入しています。この機構は、共有がまれであるか、または共有が読み取り専用である場合に一般的なケースの効率的なサポートを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Performance Challenges for Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1。クライアント側のキャッシュのパフォーマンスの課題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Caching techniques used in previous versions of the NFS protocol have been successful in providing good performance. However, several scalability challenges can arise when those techniques are used with very large numbers of clients. This is particularly true when clients are geographically distributed, which classically increases the latency for cache revalidation requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSプロトコルの以前のバージョンで使用されるキャッシュ技術は、優れた性能を提供することに成功しています。これらの技術は、クライアントの非常に大きな数字で使用されている場合しかし、いくつかのスケーラビリティの問題が発生する可能性があります。クライアントが地理的に古典的にキャッシュ再検証要求のための待ち時間が増加する、分散している場合は特にそうです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The previous versions of the NFS protocol repeat their file data cache validation requests at the time the file is opened. This behavior can have serious performance drawbacks. A common case is one in which a file is only accessed by a single client. Therefore, sharing is infrequent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSプロトコルの以前のバージョンでは、ファイルが開かれた時にそのファイルのデータ・キャッシュの検証要求を繰り返します。この動作は、パフォーマンスに重大な欠点を持つことができます。一般的なケースでは、ファイルは、単一のクライアントがアクセスしたものです。そのため、共有はまれです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this case, repeated reference to the server to find that no conflicts exist is expensive. A better option with regards to performance is to allow a client that repeatedly opens a file to do so without reference to the server. This is done until potentially conflicting operations from another client actually occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この場合、競合が存在しないことを見つけるために、サーバへの反復参照は高価です。パフォーマンスに関してとのより良いオプションは、繰り返し、サーバーを参照することなくこれを行うには、ファイルを開くクライアントをできるようにすることです。別のクライアントからの潜在的な競合の操作が実際に発生するまで、これが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A similar situation arises in connection with file locking. Sending file lock and unlock requests to the server as well as the READ and WRITE requests necessary to make data caching consistent with the locking semantics (see Section 10.3.2) can severely limit performance. When locking is used to provide protection against infrequent conflicts, a large penalty is incurred. This penalty may discourage the use of file locking by applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様の状況は、ファイルのロックに関連して発生します。ファイルロックを送信し、サーバだけでなく、ロックセマンティクスを持つデータキャッシュの一貫性にするために必要なREADとWRITE要求にリクエストのロックを解除する（10.3.2項を参照）、パフォーマンスが大幅に制限することができます。ロックがまれ衝突に対する保護を提供するために使用される場合、大きなペナルティが発生しています。このペナルティはアプリケーションによるファイルロックの使用を阻止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol provides more aggressive caching strategies with the following design goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のプロトコルは、次の設計目標をより積極的なキャッシング戦略を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Compatibility with a large range of server semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーのセマンティクスの大規模な範囲でのOの互換性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Providing the same caching benefits as previous versions of the NFS protocol when unable to provide the more aggressive model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
より積極的なモデルを提供することができませんでしNFSプロトコルの以前のバージョンと同じキャッシングの利点を提供し、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Organizing requirements for aggressive caching so that a large portion of the benefit can be obtained even when not all of the requirements can be met.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
利益の大部分は、要件のすべてを満たすことができない場合でも得られるように、積極的なキャッシュのための要件を整理O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The appropriate requirements for the server are discussed in later sections, in which specific forms of caching are covered (see Section 10.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバのための適切な要件は、キャッシュの特定の形態は、被覆された後のセクション（セクション10.4を参照）に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Delegation and Callbacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2。委任とコールバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Recallable delegation of server responsibilities for a file to a client improves performance by avoiding repeated requests to the server in the absence of inter-client conflict. With the use of a &#34;callback&#34; RPC from server to client, a server recalls delegated responsibilities when another client engages in the sharing of a delegated file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントへのファイルのサーバー責任のリコール代表団は、クライアント間の競合が存在しない場合に、サーバーへの再三の要求を回避することによって、パフォーマンスが向上します。別のクライアントが委任ファイルの共有に従事したときに、サーバーからクライアントへの「コールバック」RPCを使用すると、サーバーは、委任の責任を思い出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A delegation is passed from the server to the client, specifying the object of the delegation and the type of delegation. There are different types of delegations, but each type contains a stateid to be used to represent the delegation when performing operations that depend on the delegation. This stateid is similar to those associated with locks and share reservations but differs in that the stateid for a delegation is associated with a client ID and may be used on behalf of all the open-owners for the given client. A delegation is made to the client as a whole and not to any specific process or thread of control within it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
委任は、委任の対象と委任の種類を指定して、サーバからクライアントに渡されます。そこ代表団の異なるタイプがありますが、それぞれのタイプには、代表団に依存する操作を実行する場合、委任を表すために使用されるのstateidが含まれています。これのstateidはロックとシェアの予約に関連したものと同様であるが、代表団のためのstateidは、クライアントIDに関連付けられており、特定のクライアントのために開いているすべての所有者に代わって使用することができるという点で異なります。代表団は、全体としてではなく、特定のプロセスやその内のコントロールのスレッドに、クライアントに行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because callback RPCs may not work in all environments (due to firewalls, for example), correct protocol operation does not depend on them. Preliminary testing of callback functionality by means of a CB_NULL procedure determines whether callbacks can be supported. The CB_NULL procedure checks the continuity of the callback path. A server makes a preliminary assessment of callback availability to a given client and avoids delegating responsibilities until it has determined that callbacks are supported. Because the granting of a delegation is always conditional upon the absence of conflicting access, clients must not assume that a delegation will be granted, and they must always be prepared for OPENs to be processed without any delegations being granted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コールバックRPCが（例えば、原因ファイアウォールに）すべての環境で動作しない場合がありますので、正しいプロトコル動作は、それらに依存しません。 CB_NULL手順によって、コールバック機能の予備試験は、コールバックをサポートできるかどうかを決定します。 CB_NULL手順は、コールバック・パスの連続性をチェックします。サーバーは、特定のクライアントへのコールバックの可用性の予備的な評価を行い、それがコールバックがサポートされていると判断するまで、責任を委譲することを回避します。代表団の付与は、常に競合アクセスの不在時に条件付きであるため、クライアントが委任を許可されることを想定してはならない、と彼らは常に許可されている任意の代表団ずに処理されるために開くために準備しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once granted, a delegation behaves in most ways like a lock. There is an associated lease that is subject to renewal, together with all of the other leases held by that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付与された後は、代表団は、ロックのように、ほとんどの方法で動作します。一緒にそのクライアントが保有する他のリースのすべてで、更新の対象となる関連したリースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unlike locks, an operation by a second client to a delegated file will cause the server to recall a delegation through a callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロックとは異なり、委任ファイルへの2番目のクライアントによる操作は、サーバーがコールバックを通じて委任をリコールするようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On recall, the client holding the delegation must flush modified state (such as modified data) to the server and return the delegation. The conflicting request will not be acted on until the recall is complete. The recall is considered complete when the client returns the delegation or the server times out its wait for the delegation to be returned and revokes the delegation as a result of the timeout. In the interim, the server will either delay responding to conflicting requests or respond to them with NFS4ERR_DELAY. Following the resolution of the recall, the server has the information necessary to grant or deny the second client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リコールでは、委任を保持しているクライアントは、サーバに（例えば修正されたデータなど）変更された状態をフラッシュし、委任を返す必要があります。リコールが完了するまでの相反する要求を実行しません。クライアントは、代表団が返されるため、委任またはその待機サーバーがタイムアウトを返し、タイムアウトの結果として委任を取り消したときにリコールが完了したと見なされます。暫定では、サーバはどちらかの遅延、競合する要求に応答しますかNFS4ERR_DELAYでそれらに対応しています。リコールの解決に続いて、サーバーは、第二のクライアントの要求を許可または拒否するために必要な情報を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At the time the client receives a delegation recall, it may have substantial state that needs to be flushed to the server. Therefore, the server should allow sufficient time for the delegation to be returned since it may involve numerous RPCs to the server. If the server is able to determine that the client is diligently flushing state to the server as a result of the recall, the server MAY extend the usual time allowed for a recall. However, the time allowed for recall completion should not be unbounded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが委譲リコールを受ける時には、それがサーバーにフラッシュする必要がかなりの状態を有することができます。そのため、サーバーは、サーバーに多数のRPCを含むことができるので、返される委譲のための十分な時間を許可する必要があります。サーバは、クライアントが熱心にリコールの結果としてサーバーに状態をフラッシュしていることを決定することができる場合は、サーバーはリコールのために許可される通常の時間を延長することができます。しかし、リコール完了に許される時間は無制限ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example of this is when responsibility to mediate opens on a given file is delegated to a client (see Section 10.4). The server will not know what opens are in effect on the client. Without this knowledge, the server will be unable to determine if the access and deny state for the file allows any particular open until the delegation for the file has been returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
仲介する責任が与えられたファイルに開いたときに、この例では（項10.4を参照）、クライアントに委譲されています。開いたのか分からなくなり、サーバーは、クライアントに適用されています。ファイルの委譲が返されるまでのファイルが特定のオープンができますのためにこの知識がないと、サーバーはアクセスかどうかを判断し、状態を否定することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client failure or a network partition can result in failure to respond to a recall callback. In this case, the server will revoke the delegation; this in turn will render useless any modified state still on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント障害またはネットワークパーティションは、リコールコールバックに応答する障害が発生することができます。この場合、サーバが委任を撤回します。これは、順番に、クライアント上ではまだ役に立たない任意の変更された状態をレンダリングします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients need to be aware that server implementers may enforce practical limitations on the number of delegations issued. Further, as there is no way to determine which delegations to revoke, the server is allowed to revoke any. If the server is implemented to revoke another delegation held by that client, then the client may be able to determine that a limit has been reached because each new delegation request results in a revoke. The client could then determine which delegations it may not need and preemptively release them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバの実装者が発行した代表団の数に実用上の制限を強制する可能性があることに注意する必要があります。取り消すためにどの委譲を決定する方法がないように、さらに、サーバは、任意に取り消すことが可能となります。サーバーはそのクライアントによって保持された別の委任を撤回するために実装されている場合、クライアントはそれぞれの新しい委譲要求はREVOKEにつながるので、上限に達していることを決定することができます。クライアントは、それが必要と先制それらを解放しない可能性がある代表団決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.1. Delegation Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.1。委任回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are three situations that delegation recovery must deal with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代表団の回復が対処しなければならないことの3つの状況があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Client reboot or restart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
oクライアントの再起動または再起動
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Server reboot or restart (see Section 9.6.3.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバの再起動または再起動（セクション9.6.3.1を参照してください）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Network partition (full or callback-only)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oネットワークパーティション（フルまたはコールバックのみ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the event that the client reboots or restarts, the confirmation of a SETCLIENTID done with an nfs_client_id4 with a new verifier4 value will result in the release of byte-range locks and share reservations. Delegations, however, may be treated a bit differently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが再起動または再起動した場合には、新しいverifier4値でnfs_client_id4で行わSETCLIENTIDの確認がバイト範囲ロックと共有の予約のリリースになります。代表団は、しかし、異なるビットを処理することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There will be situations in which delegations will need to be re-established after a client reboots or restarts. The reason for this is the client may have file data stored locally and this data was associated with the previously held delegations. The client will need to re-establish the appropriate file state on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代表団は、クライアントの再起動や再起動後に再確立する必要がある状況があります。この理由は、クライアントがローカルに保存されたファイルデータを持っていることであり、このデータは、以前開催された代表団と関連していました。クライアントは、サーバ上の適切なファイルの状態を再確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To allow for this type of client recovery, the server MAY allow delegations to be retained after other sorts of locks are released. This implies that requests from other clients that conflict with these delegations will need to wait. Because the normal recall process may require significant time for the client to flush changed state to the server, other clients need to be prepared for delays that occur because of a conflicting delegation. In order to give clients a chance to get through the reboot process -- during which leases will not be renewed -- the server MAY extend the period for delegation recovery beyond the typical lease expiration period. For open delegations, such delegations that are not released are reclaimed using OPEN with a claim type of CLAIM_DELEGATE_PREV. (See Sections 10.5 and 16.16 for discussions of open delegation and the details of OPEN, respectively.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントの回復のこのタイプを可能にするため、サーバーはロックの他の種類がリリースされた後、代表団が保持されることを可能にします。これは、他のクライアントからの要求は、これらの代表団と競合を待つ必要があることを意味します。通常のリコール処理がサーバに変更された状態をフラッシュするために、クライアントのためにかなりの時間を必要とする場合がありますので、他のクライアントがあるため、競合する代表団の発生の遅れのために準備する必要があります。クライアントに再起動プロセスを介して取得する機会を与えるために - リースその間に更新されることはありません - サーバーは、一般的なリースの有効期限を越えた委任回復のための期間を延長することができます。オープン委譲のために、解放されないように代表団はCLAIM_DELEGATE_PREVの請求タイプでOPEN使用して再利用されています。 （それぞれ開いている委譲の議論やOPENの詳細については、セクション10.5と16.16を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server MAY support a claim type of CLAIM_DELEGATE_PREV, but if it does, it MUST NOT remove delegations upon SETCLIENTID_CONFIRM and instead MUST make them available for client reclaim using CLAIM_DELEGATE_PREV. The server MUST NOT remove the delegations until either the client does a DELEGPURGE or one lease period has elapsed from the time -- whichever is later -- of the SETCLIENTID_CONFIRM or the last successful CLAIM_DELEGATE_PREV reclaim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーはCLAIM_DELEGATE_PREVの請求タイプをサポートするかもしれないが、それがない場合は、SETCLIENTID_CONFIRM時に代表団を削除してはなりませんし、代わりにCLAIM_DELEGATE_PREVを使用してクライアントの再利用のためにそれらを利用できるようにしなければなりません。いずれか遅い -   -  SETCLIENTID_CONFIRMまたは最後に成功したCLAIM_DELEGATE_PREVの再利用のクライアントがDELEGPURGEを行うか、1つのリース期間は、時間の経過するまで、サーバーは、委任を削除してはなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the requirement stated above is not meant to imply that, when the server is no longer obliged, as required above, to retain delegation information, it should necessarily dispose of it. Some specific cases are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の要件は、上記の必要に応じて、サーバがもはや委任情報を保持するために、義務付けられているとき、それは必ずしもそれを処分するべきではない、ことを意味するものではないことに注意してください。いくつかの具体的な例は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When the period is terminated by the occurrence of DELEGPURGE, deletion of unreclaimed delegations is appropriate and desirable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
期間はDELEGPURGEの発生によって終了した場合、O、unreclaimed委任の削除が適切かつ望ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When the period is terminated by a lease period elapsing without a successful CLAIM_DELEGATE_PREV reclaim, and that situation appears to be the result of a network partition (i.e., lease expiration has occurred), a server&#39;s lease expiration approach, possibly including the use of courtesy locks, would normally provide for the retention of unreclaimed delegations. Even in the event that lease cancellation occurs, such delegation should be reclaimed using CLAIM_DELEGATE_PREV as part of network partition recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O期間は成功CLAIM_DELEGATE_PREVの再利用せずにリース期間の経過により終了し、その状況は、ネットワークパーティション（すなわち、リース満了が発生している）、サーバのリース満了アプローチの結果であると思われ、おそらく礼儀の使用を含めている場合にはロックは、通常unreclaimed代表団の保持を提供するだろう。でも、リースのキャンセルが発生した場合には、そのような委任は、ネットワークパーティションの回復の一環としてCLAIM_DELEGATE_PREVを使用して再利用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When the period of non-communicating is followed by a client reboot, unreclaimed delegations should also be reclaimable by use of CLAIM_DELEGATE_PREV as part of client reboot recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非通信の期間は、クライアントの再起動が続いている場合は、O、unreclaimed代表団はまた、クライアントの再起動回復の一環としてCLAIM_DELEGATE_PREVの使用による再利用可能でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When the period is terminated by a lease period elapsing without a successful CLAIM_DELEGATE_PREV reclaim, and lease renewal is occurring, the server may well conclude that unreclaimed delegations have been abandoned and consider the situation as one in which an implied DELEGPURGE should be assumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
期間は成功CLAIM_DELEGATE_PREVの再利用せずにリース期間の経過により終了し、リース更新が発生している場合は、O、サーバーはよくそのunreclaimed代表団が放棄されていると結論し、暗黙のDELEGPURGEが想定されるべきものとして、状況を考慮することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server that supports a claim type of CLAIM_DELEGATE_PREV MUST support the DELEGPURGE operation, and similarly, a server that supports DELEGPURGE MUST support CLAIM_DELEGATE_PREV. A server that does not support CLAIM_DELEGATE_PREV MUST return NFS4ERR_NOTSUPP if the client attempts to use that feature or performs a DELEGPURGE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_DELEGATE_PREVのクレーム・タイプをサポートするサーバは、DELEGPURGE動作をサポートしなければならない、と同様に、DELEGPURGEをサポートするサーバはCLAIM_DELEGATE_PREVをサポートしなければなりません。クライアントがその機能を使用しようとしたりDELEGPURGE操作を行った場合CLAIM_DELEGATE_PREVをサポートしていないサーバがNFS4ERR_NOTSUPPを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Support for a claim type of CLAIM_DELEGATE_PREV is often referred to as providing for &#34;client-persistent delegations&#34; in that they allow the use of persistent storage on the client to store data written by the client, even across a client restart. It should be noted that, with the optional exception noted below, this feature requires persistent storage to be used on the client and does not add to persistent storage requirements on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_DELEGATE_PREVの請求タイプのサポートは、多くの場合、彼らは、クライアント上の永続ストレージを使用することも、クライアントの再起動を越え、クライアントによって書き込まれたデータを保存できるようにするという点で、「クライアントの永続代表団」を提供すると呼ばれています。以下に記載するオプションの例外を除いて、この機能は、クライアント上で使用される永続的なストレージを必要とし、サーバー上の永続的なストレージ要件に追加されないことに留意すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One good way to think about client-persistent delegations is that for the most part, they function like &#34;courtesy locks&#34;, with special semantic adjustments to allow them to be retained across a client restart, which cause all other sorts of locks to be freed. Such locks are generally not retained across a server restart. The one exception is the case of simultaneous failure of the client and server and is discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント永続代表団を考えるための一つの良い方法は、彼らがロックの他のすべての種類が解放させ、クライアントの再起動、全体で保持することができるように、特別な意味的な調整で、ほとんどの部分は、彼らは「礼儀ロック」のように機能することです。このようなロックは、一般的に、サーバーを再起動しても保持されていません。唯一の例外は、クライアントとサーバーの同時障害が発生した場合であり、以下に説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server indicates support of CLAIM_DELEGATE_PREV (implicitly) by returning NFS_OK to DELEGPURGE, a client with a write delegation can use write-back caching for data to be written to the server, deferring the write-back until such time as the delegation is recalled, possibly after intervening client restarts. Similarly, when the server indicates support of CLAIM_DELEGATE_PREV, a client with a read delegation and an open-for-write subordinate to that delegation may be sure of the integrity of its persistently cached copy of the file after a client restart without specific verification of the change attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがDELEGPURGEにNFS_OKを返すことによってCLAIM_DELEGATE_PREV（暗黙的）のサポートを示している場合、書き込み代表団とのクライアントは、委任がリコールされるような時までライトバックを延期、サーバーに書き込まれるデータのためのライトバックキャッシュを使用することができます、おそらくクライアントの再起動を介在した後。同様に、サーバはCLAIM_DELEGATE_PREV、読み取り委任とオープンのため、書き込みの具体的な検証せずにクライアントを再起動した後、ファイルのその永続的にキャッシュされたコピーの整合性を確認することができることを委任に従属してクライアントのサポートを示している場合変化属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server reboots or restarts, delegations are reclaimed (using the OPEN operation with CLAIM_PREVIOUS) in a similar fashion to byte-range locks and share reservations. However, there is a slight semantic difference. In the normal case, if the server decides that a delegation should not be granted, it performs the requested action (e.g., OPEN) without granting any delegation. For reclaim, the server grants the delegation, but a special designation is applied so that the client treats the delegation as having been granted but recalled by the server. Because of this, the client has the duty to write all modified state to the server and then return the delegation. This process of handling delegation reclaim reconciles three principles of the NFSv4 protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバの再起動または再起動したときに、委任は、バイト範囲ロックと共有の予約と同様に（CLAIM_PREVIOUSで開く操作を使用して）再利用されます。しかし、わずかなセマンティック違いがあります。サーバは委任が許可されるべきではないと判断した場合、通常の場合、それは任意の委任を許可することなく、要求されたアクション（例えば、OPEN）を行います。再利用のために、サーバが委任を許可しますが、クライアントがサーバによって付与されたが、リコールされたものとして委任を扱うように、特別な指定が適用されます。このため、クライアントは、サーバーへのすべての変更された状態を書き込み、委任を返す義務があります。委任再利用を扱うこのプロセスはNFSv4のプロトコルの3つの原則を調和させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Upon reclaim, a client claiming resources assigned to it by an earlier server instance must be granted those resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O再利用時には、以前のサーバインスタンスによってそれに割り当てられたリソースを主張するクライアントは、それらのリソースを付与する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server has unquestionable authority to determine whether delegations are to be granted and, once granted, whether they are to be continued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバは、代表団は、かつて彼らが継続するかどうか、付与された、許可されたとされるようにしているかどうかを判断するために疑う余地のない権限を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The use of callbacks is not to be depended upon until the client has proven its ability to receive them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがそれらを受信する能力を証明しているまで、Oコールバックの使用はないに依存することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client has more than a single open associated with a delegation, state for those additional opens can be established using OPEN operations of type CLAIM_DELEGATE_CUR. When these are used to establish opens associated with reclaimed delegations, the server MUST allow them when made within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、委任に関連した単一のオープンより多くを持っている場合は、追加のそれらのための状態は、型CLAIM_DELEGATE_CURのOPEN操作を使用して確立することができます開きます。これらは再利用の代表団に関連付け開き確立するために使用されている場合は、猶予期間内になされたときに、サーバーがそれらを許容しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Situations in which there is a series of client and server restarts where there is no restart of both at the same time are dealt with via a combination of CLAIM_DELEGATE_PREV and CLAIM_PREVIOUS reclaim cycles. Persistent storage is needed only on the client. For each server failure, a CLAIM_PREVIOUS reclaim cycle is done, while for each client restart, a CLAIM_DELEGATE_PREV reclaim cycle is done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
両方のない再起動が同時に存在していないクライアントとサーバの再起動のシリーズが存在している状況はCLAIM_DELEGATE_PREVとCLAIM_PREVIOUSの組み合わせを経由して扱われるサイクルを取り戻します。永続ストレージは、クライアントのみに必要とされています。各クライアントの再起動のために、CLAIM_DELEGATE_PREVの再利用サイクルが行われている間、各サーバの障害について、CLAIM_PREVIOUS再利用サイクルが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To deal with the possibility of simultaneous failure of client and server (e.g., a data center power outage), the server MAY persistently store delegation information so that it can respond to a CLAIM_DELEGATE_PREV reclaim request that it receives from a restarting client. This is the one case in which persistent delegation state can be retained across a server restart. A server is not required to store this information, but if it does do so, it should do so for write delegations and for read delegations, during the pendency of which (across multiple client and/or server instances), some open-for-write was done as part of delegation. When the space to persistently record such information is limited, the server should recall delegations in this class in preference to keeping them active without persistent storage recording.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバ（例えば、データセンターの停電）の同時故障の可能性に対処するために、サーバが永続的に格納する委任情報、それが再起動し、クライアントから受信したCLAIM_DELEGATE_PREVの再利用要求に対応できることができるように。これは、永続的委任状態はサーバーの再起動しても保持できる1つのケースです。サーバはこの情報を格納するために必要とされていないが、それはそうしなければ、それは（複数のクライアントおよび/またはサーバインスタンス間）の係属中に、書き込み代表団のために、リードの代表団のためにそうする必要があり、いくつかのオープン-FOR-書き込みは代表団の一部として行われました。レコードのような情報を永続的にするスペースが限られている場合は、サーバーは、永続的なストレージ記録せずにアクティブにそれらを保つことに優先してこのクラスの代表団を思い出す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a network partition occurs, delegations are subject to freeing by the server when the lease renewal period expires. This is similar to the behavior for locks and share reservations, and as for locks and share reservations, it may be modified by support for &#34;courtesy locks&#34; in which locks are not freed in the absence of a conflicting lock request. Whereas for locks and share reservations the freeing of locks will occur immediately upon the appearance of a conflicting request, for delegations, the server MAY institute a period during which conflicting requests are held off. Eventually, the occurrence of a conflicting request from another client will cause revocation of the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークパーティションが発生した場合、代表団はリース更新期間が満了したときに、サーバによって解放の対象となっています。これは、ロックと共有の予約のための動作に類似しており、ロックと共有の予約に関しては、それはロックが競合するロック要求が存在しない状態で解放されていない「礼儀ロック」のサポートによって修飾することができます。ロックと共有の予約のためのロックの解放が競合要求の出現直後に発生するのに対し、委譲のために、サーバは、競合する要求がオフに保持される期間を提起するかもしれません。最終的には、別のクライアントから競合の要求の発生は委任の取消しの原因となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A loss of the callback path (e.g., by a later network configuration change) will have a similar effect in that it can also result in revocation of a delegation. A recall request will fail, and revocation of the delegation will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（後にネットワーク構成変更によって、例えば、）コールバックパスの損失は、それはまた、委任の取り消しをもたらすことができることで同様の効果を有するであろう。リコール要求は失敗し、代表団の失効が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client normally finds out about revocation of a delegation when it uses a stateid associated with a delegation and receives one of the errors NFS4ERR_EXPIRED, NFS4ERR_BAD_STATEID, or NFS4ERR_ADMIN_REVOKED (NFS4ERR_EXPIRED indicates that all lock state associated with the client has been lost). It also may find out about delegation revocation after a client reboot when it attempts to reclaim a delegation and receives NFS4ERR_EXPIRED. Note that in the case of a revoked OPEN_DELEGATE_WRITE delegation, there are issues because data may have been modified by the client whose delegation is revoked and, separately, by other clients. See Section 10.5.1 for a discussion of such issues. Note also that when delegations are revoked, information about the revoked delegation will be written by the server to stable storage (as described in Section 9.6). This is done to deal with the case in which a server reboots after revoking a delegation but before the client holding the revoked delegation is notified about the revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは代表団に関連付けられたstateidを使用し、NFS4ERR_EXPIRED、NFS4ERR_BAD_STATEID、またはNFS4ERR_ADMIN_REVOKED（NFS4ERR_EXPIREDは、クライアントに関連付けられているすべてのロック状態が失われていることを示している）のいずれかのエラーを受信したときに、クライアントは通常、委任の取消しについて見つけ出します。それは代表団を再利用しようとするとNFS4ERR_EXPIREDを受けた場合にも、クライアントの再起動後に委任失効について調べることがあります。データは、その委任他のクライアントにより、別途、取り消されたクライアントによって変更された可能性があるため、失効OPEN_DELEGATE_WRITE委任の場合には、問題があることに注意してください。そのような問題の議論については、セクション10.5.1を参照してください。代表団が取り消されたときに（セクション9.6で説明したように）、取り消された代表団についての情報が安定したストレージにサーバーによって書き込まれることにも注意してください。これは、サーバが委任を取り消した後が、取り消された代表団を保持しているクライアントが失効について通知される前に再起動した場合に対処するために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that when there is a loss of a delegation, due to a network partition in which all locks associated with the lease are lost, the client will also receive the error NFS4ERR_EXPIRED. This case can be distinguished from other situations in which delegations are revoked by seeing that the associated clientid becomes invalid so that NFS4ERR_STALE_CLIENTID is returned when it is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リースに関連付けられたすべてのロックが失われているネットワークパーティションに、代表団の損失がある場合、クライアントは、エラーNFS4ERR_EXPIREDを受けることに注意してください。この場合は、代表団は、それが使用されている場合NFS4ERR_STALE_CLIENTIDが返されるように関連するのClientIDが無効になることを見て、取り消されている他の状況を区別することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When NFS4ERR_EXPIRED is returned, the server MAY retain information about the delegations held by the client, deleting those that are invalidated by a conflicting request. Retaining such information will allow the client to recover all non-invalidated delegations using the claim type CLAIM_DELEGATE_PREV, once the SETCLIENTID_CONFIRM is done to recover. Attempted recovery of a delegation that the client has no record of, typically because they were invalidated by conflicting requests, will result in the error NFS4ERR_BAD_RECLAIM. Once a reclaim is attempted for all delegations that the client held, it SHOULD do a DELEGPURGE to allow any remaining server delegation information to be freed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_EXPIREDが返されると、サーバーは、競合要求によって無効にされているものを削除すると、クライアントが保有する代表団についての情報を保持することができます。そのような情報を保持することSETCLIENTID_CONFIRMを回復するために行われた後、クライアントは、請求タイプCLAIM_DELEGATE_PREVを使用して、すべての非無効化された代表団を回復することができます。クライアントは、それらが矛盾する要求によって無効化された、通常ので、記録されていない委任の回復をしようとし、エラーNFS4ERR_BAD_RECLAIMになります。再利用は、クライアントが保有するすべての代表団のために試行されたら、それは残りのサーバーの委任情報が解放されるようにDELEGPURGEを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3。データキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When applications share access to a set of files, they need to be implemented so as to take account of the possibility of conflicting access by another application. This is true whether the applications in question execute on different clients or reside on the same client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルのセットにアプリケーション共有アクセス、彼らは他のアプリケーションによるアクセスの競合の可能性を考慮するように実装する必要があります。これは、問題のアプリケーションは、異なるクライアント上で実行するか、同じクライアント上に存在するかどうか本当です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Share reservations and byte-range locks are the facilities the NFSv4 protocol provides to allow applications to coordinate access by providing mutual exclusion facilities. The NFSv4 protocol&#39;s data caching must be implemented such that it does not invalidate the assumptions that those using these facilities depend upon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
共有の予約およびバイト範囲ロックはNFSv4のプロトコルは、アプリケーションが相互排他設備を提供することによって、アクセスを調整できるようにするために提供する機能です。 NFSv4のプロトコルのデータのキャッシングは、これらの施設を利用したものが依存することを仮定を無効にしないように実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.1. Data Caching and OPENs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.1。データキャッシング、開きました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to avoid invalidating the sharing assumptions that applications rely on, NFSv4 clients should not provide cached data to applications or modify it on behalf of an application when it would not be valid to obtain or modify that same data via a READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションが依存する共有の仮定を無効避けるために、NFSv4のクライアントは、アプリケーションにキャッシュされたデータを提供してはならないか、READまたはWRITE操作を経由して、同じデータを取得または変更するために有効ではないだろうというとき、アプリケーションに代わって、それを修正します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Furthermore, in the absence of open delegation (see Section 10.4), two additional rules apply. Note that these rules are obeyed in practice by many NFSv2 and NFSv3 clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、開いている委譲の不在（項10.4を参照）で、二つの追加の規則が適用されます。これらのルールは、多くのNFSv2とNFSv3のクライアントが実際に守られることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o First, cached data present on a client must be revalidated after doing an OPEN. Revalidating means that the client fetches the change attribute from the server, compares it with the cached change attribute, and, if different, declares the cached data (as well as the cached attributes) as invalid. This is to ensure that the data for the OPENed file is still correctly reflected in the client&#39;s cache. This validation must be done at least when the client&#39;s OPEN operation includes DENY=WRITE or BOTH, thus terminating a period in which other clients may have had the opportunity to open the file with WRITE access. Clients may choose to do the revalidation more often (such as at OPENs specifying DENY=NONE) to parallel the NFSv3 protocol&#39;s practice for the benefit of users assuming this degree of cache revalidation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oまず、クライアント上に存在し、キャッシュされたデータは、OPENをやった後、再検証する必要があります。再検証は、クライアントが、サーバからの変化属性を取得し、キャッシュされた変化属性と比較し、そして、異なる場合は、無効としてキャッシュされたデータ（同様にキャッシュされた属性）を宣言していることを意味します。これは、開いたファイルのデータがまだ正しくクライアントのキャッシュに反映されていることを確認することです。この検証は、クライアントのOPEN操作は、このように他のクライアントが書き込みアクセスでファイルを開くための機会を持っていたかもしれ期間を終了し、= WRITEまたはBOTHをDENY、少なくとも時に行われなければなりません。クライアントは、キャッシュ再検証のこの程度を想定し、ユーザーの利益のためにNFSv3のプロトコルの練習を並行して（例えば= NONEを否定できない指定のOPENsでのように）より頻繁に再検証を行うことを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the change attribute is updated for data and metadata modifications, some client implementers may be tempted to use the time_modify attribute and not the change attribute to validate cached data, so that metadata changes do not spuriously invalidate clean data. The implementer is cautioned against this approach. The change attribute is guaranteed to change for each update to the file, whereas time_modify is guaranteed to change only at the granularity of the time_delta attribute. Use by the client&#39;s data cache validation logic of time_modify and not the change attribute runs the risk of the client incorrectly marking stale data as valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変化属性は、データとメタデータの変更のために更新されているので、いくつかのクライアントの実装者は、そのメタデータの変更が誤ってクリーンなデータが無効になることはありませんので、キャッシュされたデータを検証するためにtime_modify属性ではなく変化属性を使用するように誘惑することができます。実装者は、このアプローチに警告を発しています。 time_modifyがTIME_DELTA属性の粒度でのみ変更することが保証されているのに対し、変化属性は、ファイルへの更新ごとに変更することが保証されています。 time_modifyのクライアントのデータ・キャッシュの検証ロジックで使用していない変化属性は、クライアントが誤って有効な古いデータをマーキングするリスクを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Second, modified data must be flushed to the server before closing a file OPENed for write. This is complementary to the first rule. If the data is not flushed at CLOSE, the revalidation done after the client OPENs a file is unable to achieve its purpose. The other aspect to flushing the data before close is that the data must be committed to stable storage, at the server, before the CLOSE operation is requested by the client. In the case of a server reboot or restart and a CLOSEd file, it may not be possible to retransmit the data to be written to the file -- hence, this requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O第二に、変更されたデータは、書き込みのために開いたファイルを閉じる前に、サーバーにフラッシュする必要があります。これは最初のルールに相補的です。データはCLOSEでフラッシュされていない場合は、クライアントがファイルを開いた後に行う再検証は、その目的を達成することができません。クローズする前にデータをフラッシュする他の側面は、CLOSE操作がクライアントによって要求される前のデータは、サーバーで、安定したストレージにコミットしなければならないということです。サーバの再起動または再起動し、閉じられたファイルの場合、ファイルに書き込まれるデータを再送信することはできないかもしれない - 従って、この要件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.2. Data Caching and File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.2。データ・キャッシングとファイルロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For those applications that choose to use file locking instead of share reservations to exclude inconsistent file access, there is an analogous set of constraints that apply to client-side data caching. These rules are effective only if the file locking is used in a way that matches in an equivalent way the actual READ and WRITE operations executed. This is as opposed to file locking that is based on pure convention. For example, it is possible to manipulate a two-megabyte file by dividing the file into two one-megabyte regions and protecting access to the two regions by file locks on bytes zero and one. A lock for write on byte zero of the file would represent the right to do READ and WRITE operations on the first region. A lock for write on byte one of the file would represent the right to do READ and WRITE operations on the second region. As long as all applications manipulating the file obey this convention, they will work on a local file system. However, they may not work with the NFSv4 protocol unless clients refrain from data caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一貫性のないファイルへのアクセスを除外するために、代わりに株式の予約のファイルロックを使用することを選択し、それらのアプリケーションでは、クライアント側のデータキャッシュに適用される制約の類似したセットがあります。これらのルールは、ファイルのロックが実際の読み出しおよび書き込み動作が実行される同等の方法で一致するように使用されている場合にのみ有効です。純粋な慣例に基づいて、ロックファイルとは対照的にこれがあります。例えば、2つの1メガバイトの領域にファイルを分割し、バイト0と1上のファイルロックによって二つの領域へのアクセスを保護することにより、二メガバイトのファイルを操作することが可能です。ファイルのバイトゼロの書き込みのためのロックは、第1の領域に読み取りおよび書き込み操作を行う権利を表します。ファイルのバイト1の書き込みのためのロックは第二の領域に読み取りおよび書き込み操作を行う権利を表します。限り、ファイルを操作するすべてのアプリケーションがこの規則に従うように、彼らはローカルファイルシステム上で動作します。クライアントがデータ・キャッシングを控える場合を除きしかし、彼らはNFSv4のプロトコルでは動作しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The rules for data caching in the file locking environment are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルロック環境でのデータのキャッシュのためのルールは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o First, when a client obtains a file lock for a particular region, the data cache corresponding to that region (if any cached data exists) must be revalidated. If the change attribute indicates that the file may have been updated since the cached data was obtained, the client must flush or invalidate the cached data for the newly locked region. A client might choose to invalidate all of the non-modified cached data that it has for the file, but the only requirement for correct operation is to invalidate all of the data in the newly locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、特定の地域のためのファイルロックを取得した場合、Oまず、その領域に対応するデータキャッシュは（キャッシュされたデータが存在する場合）、再検証する必要があります。変化属性がキャッシュされたデータが得られたので、ファイルが更新された可能性があることを示している場合、クライアントは、新たにロックされた領域のためにキャッシュされたデータをフラッシュしたり無効化しなければなりません。クライアントは、ファイルのために持っている非改変キャッシュされたデータのすべてを無効にすることを選択するかもしれませんが、正しい操作のための唯一の要件は、新たにロックされた領域内のすべてのデータを無効にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Second, before releasing a write lock for a region, all modified data for that region must be flushed to the server. The modified data must also be written to stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O第二に、地域のために書き込みロックを解除する前に、その地域のすべての変更されたデータをサーバーにフラッシュする必要があります。変更されたデータはまた、安定したストレージに書き込む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that flushing data to the server and the invalidation of cached data must reflect the actual byte ranges locked or unlocked. Rounding these up or down to reflect client cache block boundaries will cause problems if not carefully done. For example, writing a modified block when only half of that block is within an area being unlocked may cause invalid modification to the region outside the unlocked area. This, in turn, may be part of a region locked by another client. Clients can avoid this situation by synchronously performing portions of WRITE operations that overlap that portion (initial or final) that is not a full block. Similarly, invalidating a locked area that is not an integral number of full buffer blocks would require the client to read one or two partial blocks from the server if the revalidation procedure shows that the data that the client possesses may not be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバとキャッシュされたデータの無効化へデータをフラッシュすると、実際のバイト範囲ロックまたはロック解除を反映しなければならないことに注意してください。注意深く行われていない場合は、クライアントのキャッシュ・ブロックの境界を反映するためにダウンこれらを丸めたりすると、問題が発生します。例えば、修飾されたブロックを書き込むと、そのブロックの半分だけがロック解除された領域の外側の領域に、無効な変更を引き起こすことがアンロックされている領域内にある場合。これは、順番に、別のクライアントによってロックされた領域の一部であってもよいです。クライアントは同期満杯ブロックでない部分（初期または最終）を重複WRITE動作の部分を実行することによってこの状況を回避することができます。再検証手順は、クライアントが保有するデータが有効ではないかもしれないことを示す場合同様、フルバッファブロックの整数倍ではないロックされた領域を無効にすると、サーバーから一つまたは二つの部分ブロックを読み取るためにクライアントが必要となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The data that is written to the server as a prerequisite to the unlocking of a region must be written, at the server, to stable storage. The client may accomplish this either with synchronous writes or by following asynchronous writes with a COMMIT operation. This is required because retransmission of the modified data after a server reboot might conflict with a lock held by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
領域のロック解除の前提条件としてサーバに書き込まれたデータは、安定したストレージに、サーバに書き込まれなければなりません。クライアントは同期書き込みまたはCOMMIT操作で非同期書き込みを、次のいずれかによって、これを達成することができます。サーバーの再起動後に変更されたデータの再送信は、別のクライアントによって保持されたロックと競合する可能性がありますので、これが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client implementation may choose to accommodate applications that use byte-range locking in non-standard ways (e.g., using a byte-range lock as a global semaphore) by flushing to the server more data upon a LOCKU than is covered by the locked range. This may include modified data within files other than the one for which the unlocks are being done. In such cases, the client must not interfere with applications whose READs and WRITEs are being done only within the bounds of record locks that the application holds. For example, an application locks a single byte of a file and proceeds to write that single byte. A client that chose to handle a LOCKU by flushing all modified data to the server could validly write that single byte in response to an unrelated unlock. However, it would not be valid to write the entire block in which that single written byte was located since it includes an area that is not locked and might be locked by another client. Client implementations can avoid this problem by dividing files with modified data into those for which all modifications are done to areas covered by an appropriate byte-range lock and those for which there are modifications not covered by a byte-range lock. Any writes done for the former class of files must not include areas not locked and thus not modified on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントの実装では、非標準的な方法でバイト範囲ロックを使用するアプリケーションに対応することもできます（例えば、グローバルセマフォとしてバイト範囲ロックを使用して）ロックされた範囲で覆われているよりも、LOCKU時にサーバーにデータをフラッシュすることにより、 。これは、アンロックが行われているために1以外のファイル内で変更されたデータを含むことができます。このような場合には、クライアントは、その読み込みと書き込みのみアプリケーションが保持しているレコードロックの範囲内で行われているアプリケーションを妨害してはなりません。例えば、アプリケーションは、ファイルの単一のバイトをロックし、その単一バイトの書き込みに進みます。サーバーへのすべての変更されたデータをフラッシュしてLOCKUを処理するために選択したクライアントが有効に無関係なロック解除に応じて、その1バイトを書くことができます。しかし、ロックされていないと別のクライアントによってロックされるかもしれない領域を含むので、その単一書かれたバイトが配置されたブロック全体を書き込むことが有効ではありません。クライアントの実装は、すべての変更が適切なバイト範囲ロックとバイト範囲ロックによって覆われていない変更があるれるものによってカバーされる領域に行われているため、それらに変更されたデータのファイルを分割することによってこの問題を回避することができます。ファイルの元のクラスに行って、任意の書き込みは、領域がロックされていないため、クライアント上で変更されていない含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.3. Data Caching and Mandatory File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.3。データ・キャッシングと強制ファイルロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client-side data caching needs to respect mandatory file locking when it is in effect. The presence of mandatory file locking for a given file is indicated when the client gets back NFS4ERR_LOCKED from a READ or WRITE on a file it has an appropriate share reservation for. When mandatory locking is in effect for a file, the client must check for an appropriate file lock for data being read or written. If a lock exists for the range being read or written, the client may satisfy the request using the client&#39;s validated cache. If an appropriate file lock is not held for the range of the READ or WRITE, the READ or WRITE request must not be satisfied by the client&#39;s cache and the request must be sent to the server for processing. When a READ or WRITE request partially overlaps a locked region, the request should be subdivided into multiple pieces with each region (locked or not) treated appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント側データ・キャッシングは、それが有効であるときに必須のファイルロックを尊重する必要があります。クライアントはREADからNFS4ERR_LOCKEDを取り戻すか、のために適切な共有の予約を持つファイルに書き込むと、所与のファイルのロック必須ファイルの存在が示されています。強制ロックは、ファイルのために有効である場合には、クライアントが読み取りまたは書き込まれるデータのための適切なファイルロックを確認する必要があります。ロックが読み取りまたは書き込まれている範囲に存在する場合、クライアントは、クライアントの検証キャッシュを使用して要求を満たすようにしてもよいです。適切なファイルロックがRE​​ADまたはWRITEの範囲のために保持されていない場合は、READまたはWRITE要求は、クライアントのキャッシュによって満たされなければならないと要求を処理するためにサーバーに送信する必要があります。 READまたはWRITE要求が部分的にロックされた領域と重なる場合、要求が適切に処理（ロックされたかどうか）は、各領域を有する複数の部分に細分されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.4. Data Caching and File Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.4。データキャッシングとファイルアイデンティティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When clients cache data, the file data needs to be organized according to the file system object to which the data belongs. For NFSv3 clients, the typical practice has been to assume for the purpose of caching that distinct filehandles represent distinct file system objects. The client then has the choice to organize and maintain the data cache on this basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがデータをキャッシュすると、ファイルデータは、データが属するファイルシステムオブジェクトに応じて整理する必要があります。 NFSv3のクライアントの場合、典型的な練習は、異なるファイルハンドルが別個のファイル・システム・オブジェクトを表すキャッシングの目的のために仮定することでした。その後、クライアントはこれに基づいてデータキャッシュを整理し、維持するための選択肢を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the NFSv4 protocol, there is now the possibility of having significant deviations from a &#34;one filehandle per object&#34; model, because a filehandle may be constructed on the basis of the object&#39;s pathname. Therefore, clients need a reliable method to determine if two filehandles designate the same file system object. If clients were simply to assume that all distinct filehandles denote distinct objects and proceed to do data caching on this basis, caching inconsistencies would arise between the distinct client-side objects that mapped to the same server-side object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルハンドルは、オブジェクトのパス名に基づいて構築することができるためのNFSv4プロトコルでは、現在「一のファイルハンドルオブジェクトごとに」モデルからの有意な偏差を有する可能性があります。したがって、クライアントは、二つのファイルハンドルが同じファイル・システム・オブジェクトを指定する場合に信頼性の高い方法を決定する必要があります。クライアントは単純にすべての個別のファイルハンドルが別個のオブジェクトを表すことを前提とし、これに基づいてデータのキャッシュを行うに進みした場合、キャッシュの不整合は、同じサーバー側オブジェクトにマッピングされた個別のクライアント側のオブジェクト間で生じるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By providing a method to differentiate filehandles, the NFSv4 protocol alleviates a potential functional regression in comparison with the NFSv3 protocol. Without this method, caching inconsistencies within the same client could occur, and this has not been present in previous versions of the NFS protocol. Note that it is possible to have such inconsistencies with applications executing on multiple clients, but that is not the issue being addressed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルハンドルを区別するための方法を提供することによって、のNFSv4プロトコルはNFSv3のプロトコルと比較して潜在的な機能的回帰を緩和します。この方法がなければ、同じクライアント内のキャッシュの不整合が発生する可能性があり、これは、NFSプロトコルの以前のバージョンに存在していませんでした。複数のクライアント上で実行するアプリケーションで、このような矛盾を持つことが可能であるが、それはここで扱われている問題ではないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the purposes of data caching, the following steps allow an NFSv4 client to determine whether two distinct filehandles denote the same server-side object:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データキャッシュの目的のために、次の手順は、NFSv4クライアントは、2つの別個のファイルハンドルが同じサーバ側のオブジェクトを表すかどうかを決定することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If GETATTR directed to two filehandles returns different values of the fsid attribute, then the filehandles represent distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETATTRは、2つのファイルハンドルに向けFSID属性の異なる値を返す場合、O、次にファイルハンドルは、異なるオブジェクトを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If GETATTR for any file with an fsid that matches the fsid of the two filehandles in question returns a unique_handles attribute with a value of TRUE, then the two objects are distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
問題の2つのファイルハンドルのFSIDと一致するFSIDを持つ任意のファイルのGETATTRがunique_handlesがTRUEの値を持つ属性を返した場合、O、その後、2つのオブジェクトが異なっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If GETATTR directed to the two filehandles does not return the fileid attribute for both of the handles, then it cannot be determined whether the two objects are the same. Therefore, operations that depend on that knowledge (e.g., client-side data caching) cannot be done reliably. Note that if GETATTR does not return the fileid attribute for both filehandles, it will return it for neither of the filehandles, since the fsid for both filehandles is the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETATTRは、2つのファイルハンドルに向けられた場合、Oハンドルの両方のためFILEID属性を返さない、2つのオブジェクトが同一であるか否かを判断することはできません。したがって、その知識に依存する操作（例えば、クライアント側データ・キャッシング）を確実に行うことができません。 GETATTRは、両方のファイルハンドル用FILEID属性を返さない場合は、両方のファイルハンドルのためのfsidが同じであるため、それは、ファイルハンドルのどちらのためにそれを返すことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If GETATTR directed to the two filehandles returns different values for the fileid attribute, then they are distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETATTRは、2つのファイルハンドルに向けFILEID属性の異なる値を返す場合、O、それらは別個のオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Otherwise, they are the same object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれ以外の場合は、同じオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4。オープン委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a file is being OPENed, the server may delegate further handling of opens and closes for that file to the opening client. Any such delegation is recallable, since the circumstances that allowed for the delegation are subject to change. In particular, the server may receive a conflicting OPEN from another client; the server must recall the delegation before deciding whether the OPEN from the other client may be granted. Making a delegation is up to the server, and clients should not assume that any particular OPEN either will or will not result in an open delegation. The following is a typical set of conditions that servers might use in deciding whether OPEN should be delegated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルが開かれている場合は、サーバーがオープンのさらなる取り扱いを委任し、開口部クライアントにそのファイルを閉じて。委任に対して許可状況が変更される場合がありますので、任意のそのような委任は、リコールです。具体的には、サーバは別のクライアントから競合OPENを受けることができます。サーバーは、他のクライアントからのOPENを付与することができるかどうかを決定する前に委任を思い出す必要があります。委任を作ることは、サーバー次第です、とクライアントがどちらかのいずれかの特定のOPENがまたは開いている委譲にはなりませんだろうと想定してはいけません。以下は、サーバーがOPENを委任する必要があるかどうかを決定する際に使用する可能性のある条件の典型的なセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client must be able to respond to the server&#39;s callback requests. The server will use the CB_NULL procedure for a test of callback ability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントは、サーバーのコールバック要求に応答できなければなりません。サーバーは、コールバック機能のテストのためにCB_NULLプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client must have responded properly to previous recalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントは、以前のリコールに適切に対応している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o There must be no current open conflicting with the requested delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O要求された代表団とは、現在開いている矛盾があってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o There should be no current delegation that conflicts with the delegation being requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O委任が要求されていると競合するどんな現在の代表団があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The probability of future conflicting open requests should be low, based on the recent history of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O将来の競合するオープン要求の確率は、ファイルの最近の履歴に基づいて、低くすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The existence of any server-specific semantics of OPEN/CLOSE that would make the required handling incompatible with the prescribed handling that the delegated client would apply (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必要な規定の委任クライアントが適用されることを扱うと互換性の取り扱いになるだろうOPEN / CLOSEの任意のサーバ固有の意味の存在O（下記参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two types of open delegations: OPEN_DELEGATE_READ and OPEN_DELEGATE_WRITE. An OPEN_DELEGATE_READ delegation allows a client to handle, on its own, requests to open a file for reading that do not deny read access to others. It MUST, however, continue to send all requests to open a file for writing to the server. Multiple OPEN_DELEGATE_READ delegations may be outstanding simultaneously and do not conflict. An OPEN_DELEGATE_WRITE delegation allows the client to handle, on its own, all opens. Only one OPEN_DELEGATE_WRITE delegation may exist for a given file at a given time, and it is inconsistent with any OPEN_DELEGATE_READ delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN_DELEGATE_READとOPEN_DELEGATE_WRITE：オープン委譲の2種類があります。 OPEN_DELEGATE_READ代表団は、他の人への読み取りアクセスを拒否していない読書のためのファイルを開くには、独自の、要求に、クライアントが処理することができます。しかし、サーバーに書き込むためのファイルを開くには、すべての要求を送信し続けなければなりません。複数のOPEN_DELEGATE_READの代表団は、同時に優れていてもよく、競合しません。 OPEN_DELEGATE_WRITE代表団が独自に、クライアントが処理することができ、すべてが表示されます。一つだけOPEN_DELEGATE_WRITEの代表団は、与えられた時間に指定したファイルの存在する可能性がある、そしてそれはどのOPEN_DELEGATE_READ代表団と矛盾しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a single client holds an OPEN_DELEGATE_READ delegation, it is assured that no other client may modify the contents or attributes of the file. If more than one client holds an OPEN_DELEGATE_READ delegation, then the contents and attributes of that file are not allowed to change. When a client has an OPEN_DELEGATE_WRITE delegation, it may modify the file data since no other client will be accessing the file&#39;s data. The client holding an OPEN_DELEGATE_WRITE delegation may only affect file attributes that are intimately connected with the file data: size, time_modify, and change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一のクライアントがOPEN_DELEGATE_READ委任を保持している場合は、他のクライアントがファイルの内容や属性を変更しないことが保証されています。複数のクライアントがOPEN_DELEGATE_READ委任を保持している場合、そのファイルの内容と属性を変更することはできません。クライアントがOPEN_DELEGATE_WRITE委任がある場合、他のクライアントがファイルのデータにアクセスできなくなりますので、ファイルのデータを変更することがあります。サイズ、time_modify、および変更：OPEN_DELEGATE_WRITE委任を保持しているクライアントにのみ密接ファイルデータに接続されているファイルの属性に影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client has an open delegation, it does not send OPENs or CLOSEs to the server but updates the appropriate status internally. For an OPEN_DELEGATE_READ delegation, opens that cannot be handled locally (opens for write or that deny read access) must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが開いている委譲を持っているときは、サーバーに開閉するを送ったが、内部で適切なステータスを更新しません。 OPEN_DELEGATE_READ代表団のために、（書き込みのために開くか、それが読み取りアクセスを拒否）サーバーに送信されなければならないことは、ローカルで処理することができません開きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an open delegation is made, the response to the OPEN contains an open delegation structure that specifies the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
開いている委譲が行われると、OPENへの応答は次のように指定するオープン委譲構造が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o the type of delegation (read or write)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代表団のタイプO（読み取りまたは書き込み）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o space limitation information to control flushing of data on close (OPEN_DELEGATE_WRITE delegation only; see Section 10.4.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O近い上のデータのフラッシングを制御する空間制限情報（のみOPEN_DELEGATE_WRITE委任を、第10.4.1項を参照）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o an nfsace4 specifying read and write permissions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読み取りおよび書き込み権限を指定nfsace4 O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o a stateid to represent the delegation for READ and WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OのstateidはREADとWRITEのための委任を表現します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The delegation stateid is separate and distinct from the stateid for the OPEN proper. The standard stateid, unlike the delegation stateid, is associated with a particular open-owner and will continue to be valid after the delegation is recalled and the file remains open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
委任のstateidはOPEN適切ためのstateidから独立した別個です。標準のstateidは、委任のstateidとは異なり、特定のオープン所有者に関連付けられているし、委任がリコールされた後に有効であり続けるであろうと、ファイルは開いたままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a request internal to the client is made to open a file and open delegation is in effect, it will be accepted or rejected solely on the basis of the following conditions. Any requirement for other checks to be made by the delegate should result in open delegation being denied so that the checks can be made by the server itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントへの内部要求がファイルを開くために作られ、開いている委譲が有効になっている場合、それは受け入れられたか、次の条件のみに基づいて拒否されます。チェックはサーバ自体によって行うことができるように、デリゲートによってなされる他のチェックのためにどのような要件が拒否され開いている委譲を生じるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The access and deny bits for the request and the file, as described in Section 9.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アクセスO、セクション9.9で説明したように、要求およびファイルのためのビットを否定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The read and write permissions, as determined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読み取りおよび書き込み権限O、以下のように決定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The nfsace4 passed with delegation can be used to avoid frequent ACCESS calls. The permission check should be as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代表団に渡さnfsace4は、頻繁にアクセス呼び出しを回避するために使用することができます。次のようにパーミッションチェックは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the nfsace4 indicates that the open may be done, then it should be granted without reference to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O nfsace4は、それがサーバーを参照することなく付与されなければならない、オープンを行うことができることを示している場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the nfsace4 indicates that the open may not be done, then an ACCESS request must be sent to the server to obtain the definitive answer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
nfsace4がオープンが行われない可能性があることを示した場合は、O、その後、アクセス要求は、決定的な答えを得るために、サーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server may return an nfsace4 that is more restrictive than the actual ACL of the file. This includes an nfsace4 that specifies denial of all access. Note that some common practices, such as mapping the traditional user &#34;root&#34; to the user &#34;nobody&#34;, may make it incorrect to return the actual ACL of the file in the delegation response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、ファイルの実際のACLよりも制限さnfsace4を返すことがあります。これは、すべてのアクセスの拒否を指定nfsace4が含まれています。こうしたユーザー「誰」に伝統的なユーザー「root」をマッピングするなど、いくつかの一般的な慣行が、それは間違った委任応じて、ファイルの実際のACLを返すように作ることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The use of delegation, together with various other forms of caching, creates the possibility that no server authentication will ever be performed for a given user since all of the user&#39;s requests might be satisfied locally. Where the client is depending on the server for authentication, the client should be sure authentication occurs for each user by use of the ACCESS operation. This should be the case even if an ACCESS operation would not be required otherwise. As mentioned before, the server may enforce frequent authentication by returning an nfsace4 denying all access with every open delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一緒にキャッシングの様々な他の形態、との委任の使用は、ユーザーのすべての要求をローカルに満足されることがありますので、何のサーバ認証が今まで与えられたユーザのために実行されません可能性が作成されます。クライアントが認証のためのサーバに依存している場合は、クライアントは、認証がアクセス動作を使用することによって、ユーザーごとに発生したことを確認する必要があります。これは、アクセス動作がそうでなければ必要とされない場合でも同様である必要があります。前に述べたように、サーバーはすべての開いている委譲を持つすべてのアクセスを拒否nfsace4を返すことによって、頻繁に認証を強制することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.1. Open Delegation and Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.1。オープン委任およびデータキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN delegation allows much of the message overhead associated with the opening and closing files to be eliminated. An open when an open delegation is in effect does not require that a validation message be sent to the server unless there exists a potential for conflict with the requested share mode. The continued endurance of the &#34;OPEN_DELEGATE_READ delegation&#34; provides a guarantee that no OPEN for write and thus no write has occurred that did not originate from this client. Similarly, when closing a file opened for write and if OPEN_DELEGATE_WRITE delegation is in effect, the data written does not have to be flushed to the server until the open delegation is recalled. The continued endurance of the open delegation provides a guarantee that no open and thus no read or write has been done by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN代表団は、ファイルを開いたり閉じ関連付けられているメッセージオーバーヘッドの多くは解消することができます。開いている委譲が有効になっているときに、オープン要求共有モードとの競合の可能性が存在しない限り、検証メッセージをサーバーに送信する必要はありません。 「OPEN_DELEGATE_READ委任」の継続的な耐久性は、このクライアントから発信しませんでしたなしの書き込みのためのOPENので、何の書き込みが発生していない保証を提供します。同様に閉じるときに、ファイルが書き込みのために開かれ、OPEN_DELEGATE_WRITEの委任が有効である場合、書き込まれたデータは、開いている委譲が呼び出されるまで、サーバーにフラッシュする必要はありません。開いている委譲の継続的な耐久性は、このようにオープンし、何の読み取りまたは書き込みまったく別のクライアントによって行われていないという保証を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the purposes of open delegation, READs and WRITEs done without an OPEN (anonymous and READ bypass stateids) are treated as the functional equivalents of a corresponding type of OPEN. READs and WRITEs done with an anonymous stateid done by another client will force the server to recall an OPEN_DELEGATE_WRITE delegation. A WRITE with an anonymous stateid done by another client will force a recall of OPEN_DELEGATE_READ delegations. The handling of a READ bypass stateid is identical, except that a READ done with a READ bypass stateid will not force a recall of an OPEN_DELEGATE_READ delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オープン委譲の目的のために、読み取りと書き込みは、OPENの対応するタイプの機能的等価物として扱われているOPEN（匿名とREADバイパスのstateids）なしで行います。読み取りおよび書き込みはOPEN_DELEGATE_WRITE委任をリコールするためにサーバーを強制的に別のクライアントによって行わ匿名のstateidで行います。別のクライアントによって行わ匿名のstateidとのWRITEはOPEN_DELEGATE_READ代表団のリコールを強制します。 READバイパスのstateidの取り扱いは、READバイパスのstateidで行わ読むOPEN_DELEGATE_READ委任のリコールを強制しないことを除いて、同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With delegations, a client is able to avoid writing data to the server when the CLOSE of a file is serviced. The file close system call is the usual point at which the client is notified of a lack of stable storage for the modified file data generated by the application. At the close, file data is written to the server, and through normal accounting the server is able to determine if the available file system space for the data has been exceeded (i.e., the server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT). This accounting includes quotas. The introduction of delegations requires that an alternative method be in place for the same type of communication to occur between client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代表団では、クライアントは、ファイルのCLOSEがサービスされているサーバへのデータの書き込みを避けることができます。ファイルクローズシステムコールは、クライアントがアプリケーションによって生成された変更されたファイルデータの保存安定性の不足が通知される通常のポイントです。終了時、ファイルデータがサーバーに書き込まれ、そして正常介してサーバアカウンティング、データに利用可能なファイルシステム領域（すなわち、サーバはNFS4ERR_NOSPC又はNFS4ERR_DQUOTを返す）を超えているかどうかを判断することができます。この会計は、クォータが含まれています。代表団の導入は、別の方法は、クライアントとサーバーの間で発生する通信の同じタイプのための場所であることが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the delegation response, the server provides either the limit of the size of the file or the number of modified blocks and associated block size. The server must ensure that the client will be able to flush to the server data of a size equal to that provided in the original delegation. The server must make this assurance for all outstanding delegations. Therefore, the server must be careful in its management of available space for new or modified data, taking into account available file system space and any applicable quotas. The server can recall delegations as a result of managing the available file system space. The client should abide by the server&#39;s state space limits for delegations. If the client exceeds the stated limits for the delegation, the server&#39;s behavior is undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
委任応答して、サーバは、ファイルまたは変更されたブロックの数と関連したブロックサイズの大きさの制限のいずれかを提供します。サーバーは、クライアントが、元代表団に提供されるものに等しいサイズのサーバデータに洗い流すことができるようになりますことを確認する必要があります。サーバーはすべての未処理の代表団のために、この保証をしなければなりません。そのため、サーバは、アカウントに使用可能なファイルシステムスペースおよび適用クォータを取って、新規または変更されたデータのために利用可能なスペースの経営で注意しなければなりません。サーバーは、使用可能なファイルシステム領域の管理の結果として、代表団を思い出すことができます。クライアントは、代表団のために、サーバの状態空間の制限を遵守しなければなりません。クライアントは、委譲のために述べた制限を超えた場合は、サーバーの動作は未定義です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Based on server conditions, quotas, or available file system space, the server may grant OPEN_DELEGATE_WRITE delegations with very restrictive space limitations. The limitations may be defined in a way that will always force modified data to be flushed to the server on close.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーの状況、クォータ、または使用可能なファイル・システム・スペースに基づいて、サーバーは非常に制限的スペースの制約でOPEN_DELEGATE_WRITE代表団を付与することができます。制限は、常に近くにサーバーにフラッシュされるように変更されたデータを強制する方法で定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With respect to authentication, flushing modified data to the server after a CLOSE has occurred may be problematic. For example, the user of the application may have logged off the client, and unexpired authentication credentials may not be present. In this case, the client may need to take special care to ensure that local unexpired credentials will in fact be available. One way that this may be accomplished is by tracking the expiration time of credentials and flushing data well in advance of their expiration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証に関しては、CLOSEが発生した後、サーバーに変更されたデータをフラッシュすることは問題となり得ます。たとえば、アプリケーションのユーザは、クライアントがログオフしていること、および有効期限内の認証資格情報は存在しないかもしれません。この場合、クライアントは、ローカルの期限が切れていない証明書が実際に利用可能になることを保証するために特別な注意を払う必要があるかもしれません。これを達成することができることを一つの方法は、資格証明書の有効期限を追跡し、その有効期限の事前にデータをフラッシュすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.2. Open Delegation and File Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.2。開いている委譲とファイルロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client holds an OPEN_DELEGATE_WRITE delegation, lock operations may be performed locally. This includes those required for mandatory file locking. This can be done since the delegation implies that there can be no conflicting locks. Similarly, all of the revalidations that would normally be associated with obtaining locks and the flushing of data associated with the releasing of locks need not be done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合は、ロック操作はローカルで実行することができます。これは必須ファイルのロックに必要なものも含まれます。代表団は、競合するロックがないことを意味するので、これは行うことができます。同様に、通常は入手ロックとロックの解除に関連したデータのフラッシュに関連付けられる再確認のすべてが行われる必要がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client holds an OPEN_DELEGATE_READ delegation, lock operations are not performed locally. All lock operations, including those requesting non-exclusive locks, are sent to the server for resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがOPEN_DELEGATE_READ委任を保持している場合は、ロックの操作はローカルで実行されていません。非排他的ロックを要求するものも含め、すべてのロック操作は、解決のためにサーバに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.3. Handling of CB_GETATTR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.3。 CB_GETATTRの取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server needs to employ special handling for a GETATTR where the target is a file that has an OPEN_DELEGATE_WRITE delegation in effect. The reason for this is that the client holding the OPEN_DELEGATE_WRITE delegation may have modified the data, and the server needs to reflect this change to the second client that submitted the GETATTR. Therefore, the client holding the OPEN_DELEGATE_WRITE delegation needs to be interrogated. The server will use the CB_GETATTR operation. The only attributes that the server can reliably query via CB_GETATTR are size and change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、ターゲットが有効でOPEN_DELEGATE_WRITE委任を持つファイルであるGETATTRのための特別な処理を採用する必要があります。この理由は、OPEN_DELEGATE_WRITEの委任を保持しているクライアントがデータを変更したこと、およびサーバーがGETATTRを提出した2番目のクライアントにこの変更を反映する必要があるということです。したがって、OPEN_DELEGATE_WRITE委任を保持しているクライアントは、尋問する必要があります。サーバーはCB_GETATTR操作を使用します。唯一のサーバが確実にサイズと変更されているCB_GETATTR経由で照会することができることを属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since CB_GETATTR is being used to satisfy another client&#39;s GETATTR request, the server only needs to know if the client holding the delegation has a modified version of the file. If the client&#39;s copy of the delegated file is not modified (data or size), the server can satisfy the second client&#39;s GETATTR request from the attributes stored locally at the server. If the file is modified, the server only needs to know about this modified state. If the server determines that the file is currently modified, it will respond to the second client&#39;s GETATTR as if the file had been modified locally at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_GETATTRは、別のクライアントのGETATTR要求を満たすために使用されているので、サーバは委任を保持しているクライアントは、ファイルの修正バージョンを持っているかどうかを知る必要があります。委任ファイルのクライアントのコピーが（データまたはサイズ）に変更されていない場合、サーバは、サーバにローカルに保存された属性から2番目のクライアントのGETATTR要求を満たすことができます。ファイルが変更されている場合は、サーバーにのみ、この修正された状態について知る必要があります。サーバーは、ファイルが現在変更されていると判断した場合は、ファイルをサーバーでローカルに変更されたかのように、それは2番目のクライアントのGETATTRに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the form of the change attribute is determined by the server and is opaque to the client, the client and server need to agree on a method of communicating the modified state of the file. For the size attribute, the client will report its current view of the file size. For the change attribute, the handling is more involved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変化属性の形式は、サーバによって決定され、クライアントに不透明であるされているので、クライアントとサーバーは、ファイルの変更された状態を通信する方法に同意する必要があります。サイズ属性の場合、クライアントは、ファイルサイズの現在の見解を報告します。変化属性の場合、取り扱いはより複雑です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the client, the following steps will be taken when receiving an OPEN_DELEGATE_WRITE delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN_DELEGATE_WRITE委任を受けたときに、クライアントの場合は、以下のステップが行われます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The value of the change attribute will be obtained from the server and cached. Let this value be represented by c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O変化属性の値は、サーバーから取得し、キャッシュされます。この値はcで表すことがしてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client will create a value greater than c that will be used for communicating that modified data is held at the client. Let this value be represented by d.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントは、変更されたデータがクライアントで保持されていることを通信するために使用されるCよりも大きい値を作成します。この値をdで表すことがしてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When the client is queried via CB_GETATTR for the change attribute, it checks to see if it holds modified data. If the file is modified, the value d is returned for the change attribute value. If this file is not currently modified, the client returns the value c for the change attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが変更属性のCB_GETATTR経由で照会すると、O、それが変更されたデータを保持しているかどうかを確認します。ファイルが変更されている場合は、値dが変化属性値に返されます。このファイルは、現在変更されていない場合、クライアントは、変更属性の値cを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For simplicity of implementation, the client MAY for each CB_GETATTR return the same value d. This is true even if, between successive CB_GETATTR operations, the client again modifies in the file&#39;s data or metadata in its cache. The client can return the same value because the only requirement is that the client be able to indicate to the server that the client holds modified data. Therefore, the value of d may always be c + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装を簡単にするために、各CB_GETATTRのクライアントMAYは同じ値dを返します。これは場合にも当てはまり、連続CB_GETATTR操作の間、クライアントは再びそのキャッシュ内のファイルのデータやメタデータに変更します。唯一の要件は、クライアントは、クライアントが変更されたデータを保持するサーバに指示することができるということであるため、クライアントが同じ値を返すことができます。したがって、Dの値は常にC + 1であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the change attribute is opaque to the client in the sense that it has no idea what units of time, if any, the server is counting change with, it is not opaque in that the client has to treat it as an unsigned integer, and the server has to be able to see the results of the client&#39;s changes to that integer. Therefore, the server MUST encode the change attribute in network byte order when sending it to the client. The client MUST decode it from network byte order to its native order when receiving it, and the client MUST encode it in network byte order when sending it to the server. For this reason, the change attribute is defined as an unsigned integer rather than an opaque array of bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変化属性は、それはサーバーの変更をカウントしている時間の何単位があれば、何のアイデアを持っていないという意味で、クライアントに不透明であるが、それは、クライアントが符号なし整数として扱う必要があることで不透明ではなく、サーバーは、その整数に対するクライアントの変更の結果を確認することができなければなりません。それをクライアントに送信するときにそのため、サーバーはネットワークバイト順に変化属性を符号化しなければなりません。それを受信したとき、クライアントはその本来の順序にネットワークバイトオーダーからそれをデコードしなければならない、そしてそれをサーバーに送信するときに、クライアントはネットワークバイトオーダーでそれを符号化しなければなりません。この理由のため、変化属性は符号なし整数ではなくバイトの不透明な配列として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the server, the following steps will be taken when providing an OPEN_DELEGATE_WRITE delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN_DELEGATE_WRITE委任を提供する場合、サーバの場合は、以下のステップが行われます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Upon providing an OPEN_DELEGATE_WRITE delegation, the server will cache a copy of the change attribute in the data structure it uses to record the delegation. Let this value be represented by sc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O OPEN_DELEGATE_WRITE委任を提供する際に、サーバーは、それが委任を記録するために使用するデータ構造に変化属性のコピーをキャッシュします。この値は、SCで表すことがしてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When a second client sends a GETATTR operation on the same file to the server, the server obtains the change attribute from the first client. Let this value be cc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2番目のクライアントがサーバに同じファイルにGETATTR操作を送信すると、O、サーバは、最初のクライアントからの変化属性を取得します。この値はccでみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the value cc is equal to sc, the file is not modified and the server returns the current values for change, time_metadata, and time_modify (for example) to the second client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
値CCは皮下に等しい場合、O、ファイルが変更され、サーバは、第2のクライアントへの変化、time_metadata、および（例えば）time_modifyの現在の値が返されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the value cc is NOT equal to sc, the file is currently modified at the first client and most likely will be modified at the server at a future time. The server then uses its current time to construct attribute values for time_metadata and time_modify. A new value of sc, which we will call nsc, is computed by the server, such that nsc &gt;= sc + 1. The server then returns the constructed time_metadata, time_modify, and nsc values to the requester. The server replaces sc in the delegation record with nsc. To prevent the possibility of time_modify, time_metadata, and change from appearing to go backward (which would happen if the client holding the delegation fails to write its modified data to the server before the delegation is revoked or returned), the server SHOULD update the file&#39;s metadata record with the constructed attribute values. For reasons of reasonable performance, committing the constructed attribute values to stable storage is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
値CCがSCに等しいされていない場合は、O、ファイルは現在、最初のクライアントで変更され、最も可能性の高い将来の時点でサーバーに変更されます。次に、サーバーはtime_metadataとtime_modifyの属性値を構築するために、現在の時刻を使用しています。我々は、NSCを呼び出すSCの新しい値は、NSC&gt; = SC + 1サーバは次いで、要求元に構築time_metadata、time_modify、およびNSC値を返すように、サーバによって計算されます。サーバーは、NSCとの委任レコードにSCを置き換えます。 time_modify、time_metadataの可能性を防止し、後方に行くように見えるから変更するには、サーバがファイルのを更新する必要があります（これは、委任を保持しているクライアントは、委任が取り消さまたは返される前に、サーバーにその変更されたデータの書き込みに失敗した場合に発生します）構成された属性値を持つメタデータレコード。妥当な性能の理由から、安定したストレージに構成された属性値をコミットすることは任意です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As discussed earlier in this section, the client MAY return the same cc value on subsequent CB_GETATTR calls, even if the file was modified in the client&#39;s cache yet again between successive CB_GETATTR calls. Therefore, the server must assume that the file has been modified yet again and MUST take care to ensure that the new nsc it constructs and returns is greater than the previous nsc it returned. An example implementation&#39;s delegation record would satisfy this mandate by including a boolean field (let us call it &#34;modified&#34;) that is set to FALSE when the delegation is granted, and an sc value set at the time of grant to the change attribute value. The modified field would be set to TRUE the first time cc != sc and would stay TRUE until the delegation is returned or revoked. The processing for constructing nsc, time_modify, and time_metadata would use this pseudo-code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションですでに述べたように、クライアントは、ファイルが連続したCB_GETATTRの呼び出しの間に再びまだ、クライアントのキャッシュに変更された場合でも、その後のCB_GETATTRの呼び出しで同じCC値を返すことがあります。そのため、サーバーは、ファイルが再び変更されていると、それは構築し、返す新しいNSCはそれが返され、前のNSC以上であることを保証するために注意しなければならないことを前提としなければなりません。実装例の委任レコードは、委任が許可されたときにFALSEに設定されたbooleanフィールド（私たちは、「修正」と呼んでみましょう）、および変更の属性値に付与時に設定SC値を含むことによって、この任務を満たすでしょう。変更されたフィールドがTRUEに初めてCC！= SCに設定されるだろうと委任が返さまたは取り消されるまでTRUEとどまります。 NSCを構築するための処理、time_modify、及びtime_metadataこの擬似コードを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (!modified) {
           do CB_GETATTR for change and size;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           if (cc != sc)
               modified = TRUE;
       } else {
           do CB_GETATTR for size;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       if (modified) {
           sc = sc + 1;
           time_modify = time_metadata = current_time;
           update sc, time_modify, time_metadata into file&#39;s metadata;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This would return to the client (that sent GETATTR) the attributes it requested but would make sure that size comes from what CB_GETATTR returned. The server would not update the file&#39;s metadata with the client&#39;s modified size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、（GETATTRを送った）クライアント、それは要求された属性に戻りますが、サイズがCB_GETATTRが返さ何から来ていることを確認します。サーバーはクライアントの変更サイズのファイルのメタデータを更新しないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case that the file attribute size is different than the server&#39;s current value, the server treats this as a modification regardless of the value of the change attribute retrieved via CB_GETATTR and responds to the second client as in the last step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイル属性のサイズがサーバの現在の値と異なる場合は、関係なく、変化属性CB_GETATTR経由で取得し、最後のステップのように、第2のクライアントに応答の値の変更などのサーバー扱いこれ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This methodology resolves issues of clock differences between client and server and other scenarios where the use of CB_GETATTR breaks down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この方法は、クライアントとサーバとCB_GETATTRの使用が故障し、他のシナリオの間のクロック差の問題を解決します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It should be noted that the server is under no obligation to use CB_GETATTR; therefore, the server MAY simply recall the delegation to avoid its use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがCB_GETATTRを使用する義務はないことに留意すべきです。そのため、サーバーは、単純にその使用を避けるために、委任を思い出すかもしれ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.4. Recall of Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.4。オープン委任のリコール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following events necessitate the recall of an open delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のイベントが開いている委譲のリコールを余儀なく：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Potentially conflicting OPEN request (or READ/WRITE done with &#34;special&#34; stateid)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O潜在的OPEN要求（または &#34;特別&#34; なstateidで行わREAD / WRITE）を矛盾
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o SETATTR issued by another client o REMOVE request for the file
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O SETATTRは、ファイルの別のクライアント0のREMOVE要求によって発行されました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o RENAME request for the file as either source or target of the RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O RENAMEのソースまたはターゲットとしてファイルの要求の名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whether a RENAME of a directory in the path leading to the file results in the recall of an open delegation depends on the semantics of the server file system. If that file system denies such RENAMEs when a file is open, the recall must be performed to determine whether the file in question is, in fact, open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
開いている委譲のリコールで、ファイルの結果につながるパス内のディレクトリのRENAMEかどうかは、サーバーのファイルシステムのセマンティクスに依存します。ファイルが開いているときに、そのファイル・システムは、このような名前に変更を拒否した場合、リコールは、問題のファイルは、実際には、開いているかどうかを決定するために行われなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to the situations above, the server may choose to recall open delegations at any time if resource constraints make it advisable to do so. Clients should always be prepared for the possibility of a recall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の状況に加えて、サーバは、リソースの制約がそうすることをお勧めします場合はいつでも開いている委任をリコールすることもできます。クライアントは常にリコールの可能性のために準備されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client receives a recall for an open delegation, it needs to update state on the server before returning the delegation. These same updates must be done whenever a client chooses to return a delegation voluntarily. The following items of state need to be dealt with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが開いている委譲のためのリコールを受信すると、それは代表団を返す前に、サーバー上での状態を更新する必要があります。これらの同じ更新は、クライアントが自発的に委任を返すことを選択したときに行われなければなりません。状態の以下の項目が扱われる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the file associated with the delegation is no longer open and no previous CLOSE operation has been sent to the server, a CLOSE operation must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代表団に関連付けられたファイルは、もはや開いていて、以前のCLOSE操作がサーバーに送信されていない場合は、O、CLOSE操作がサーバーに送信されませんする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If a file has other open references at the client, then OPEN operations must be sent to the server. The appropriate stateids will be provided by the server for subsequent use by the client since the delegation stateid will not longer be valid. These OPEN requests are done with the claim type of CLAIM_DELEGATE_CUR. This will allow the presentation of the delegation stateid so that the client can establish the appropriate rights to perform the OPEN. (See Section 16.16 for details.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルがクライアントで開いている他の参照を持っている場合は、O、その後、OPEN操作はサーバに送信する必要があります。委任のstateidは、もはや有効ではありませんので、適切なのstateidsは、クライアントによって、その後の使用のために、サーバによって提供されます。これらのOPEN要求はCLAIM_DELEGATE_CURの請求タイプで行われます。クライアントがOPENを実行するための適切な権限を確立できるように、これは、委任のstateidのプレゼンテーションが可能になります。 （詳細はセクション16.16を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If there are granted file locks, the corresponding LOCK operations need to be performed. This applies to the OPEN_DELEGATE_WRITE delegation case only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルロックが付与されている場合は、O、対応するロック操作を実行する必要があります。これはOPEN_DELEGATE_WRITE委任する場合にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For an OPEN_DELEGATE_WRITE delegation, if at the time of the recall the file is not open for write, all modified data for the file must be flushed to the server. If the delegation had not existed, the client would have done this data flush before the CLOSE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルが書き込みのために開かれていないリコール時の場合、O OPEN_DELEGATE_WRITE委任については、ファイルのすべての変更されたデータをサーバーにフラッシュする必要があります。代表団が存在していなかった場合、クライアントはCLOSE操作の前に、このデータフラッシュを行っているでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For an OPEN_DELEGATE_WRITE delegation, when a file is still open at the time of the recall, any modified data for the file needs to be flushed to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルはリコールの時にまだ開いているとき、OPEN_DELEGATE_WRITE委譲のためのO、ファイルの任意の変更されたデータサーバーにフラッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o With the OPEN_DELEGATE_WRITE delegation in place, it is possible that the file was truncated during the duration of the delegation. For example, the truncation could have occurred as a result of an OPEN UNCHECKED4 with a size attribute value of zero. Therefore, if a truncation of the file has occurred and this operation has not been propagated to the server, the truncation must occur before any modified data is written to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代わりにOPEN_DELEGATE_WRITE委任してO、ファイルが委任の期間中に切り捨てられた可能性があります。たとえば、切り捨てがゼロのサイズの属性値を持つOPEN UNCHECKED4の結果として発生した可能性があります。ファイルの切り捨てが発生していると、この操作は、サーバーに伝播されていない場合、任意の変更されたデータがサーバーに書き込まれる前にそのため、切り捨てが行われなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of an OPEN_DELEGATE_WRITE delegation, file locking imposes some additional requirements. To precisely maintain the associated invariant, it is required to flush any modified data in any region for which a write lock was released while the OPEN_DELEGATE_WRITE delegation was in effect. However, because the OPEN_DELEGATE_WRITE delegation implies no other locking by other clients, a simpler implementation is to flush all modified data for the file (as described just above) if any write lock has been released while the OPEN_DELEGATE_WRITE delegation was in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN_DELEGATE_WRITE委任の場合は、ファイルロックは、いくつかの追加の要件を課します。正確関連不変を維持するために、OPEN_DELEGATE_WRITE委任が有効であった書き込みロックが解放されたため、任意の領域内の任意の変更されたデータをフラッシュする必要があります。 OPEN_DELEGATE_WRITE委任が他のクライアントによって他のロックを意味しないためしかし、より簡単な実装は、（ちょうど上記のように）OPEN_DELEGATE_WRITE委任が有効であった任意の書き込みロックが解除された場合、ファイルのすべての変更されたデータをフラッシュすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An implementation need not wait until delegation recall (or deciding to voluntarily return a delegation) to perform any of the above actions, if implementation considerations (e.g., resource availability constraints) make that desirable. Generally, however, the fact that the actual open state of the file may continue to change makes it not worthwhile to send information about opens and closes to the server, except as part of delegation return. Only in the case of closing the open that resulted in obtaining the delegation would clients be likely to do this early, since, in that case, the close once done will not be undone. Regardless of the client&#39;s choices on scheduling these actions, all must be performed before the delegation is returned, including (when applicable) the close that corresponds to the open that resulted in the delegation. These actions can be performed either in previous requests or in previous operations in the same COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、実装上の考慮事項は、（例えば、リソースの可用性の制約）ことが望ましくする場合は、上記のいずれかのアクションを実行するために、委任のリコール（または自主的に委任を返すように決定）まで待つ必要はありません。しかしながら、一般的には、ファイルの実際のオープン状態が変化し続けているという事実が開き、委任リターンの一部として以外に、サーバーに閉じについて、それは価値がない情報を送信することができます。その場合には、一度行わ近いが取り消されることはありません、ので、唯一の代表団を得ることになったのオープンを閉じる場合にクライアントは、早期にこれを実行する可能性が高いだろう。委任が返される前にかかわらず、これらのアクションをスケジュール上のクライアントの選択肢の、すべては（該当する場合）の代表団が生じオープンに対応して近くを含め、実行する必要があります。これらのアクションは、以前の要求または同じCOMPOUND要求で以前の操作のいずれかで行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.5. OPEN Delegation Race with CB_RECALL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.5。 CB_RECALLとOPEN委任人種
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server informs the client of a recall via a CB_RECALL. A race case that may develop is when the delegation is immediately recalled before the COMPOUND that established the delegation is returned to the client. As the CB_RECALL provides both a stateid and a filehandle for which the client has no mapping, it cannot honor the recall attempt. At this point, the client has two choices: either do not respond or respond with NFS4ERR_BADHANDLE. If it does not respond, then it runs the risk of the server deciding to not grant it further delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはCB_RECALL経由でリコールのクライアントに通知します。委任を確立化合物がクライアントに返される前に、代表団がすぐにリコールしたときに発生することがレースのケースがあります。 CB_RECALLはのstateid、クライアントが何のマッピングを持たないためにファイルハンドルの両方を提供したように、リコールの試みを尊重することはできません。この時点で、クライアントは、2つの選択肢があります応答したりNFS4ERR_BADHANDLEに応答しないのいずれか。それが応答しない場合、それはそれをさらに委託を付与しないことを決定するサーバーのリスクを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If instead it does reply with NFS4ERR_BADHANDLE, then both the client and the server might be able to detect that a race condition is occurring. The client can keep a list of pending delegations. When it receives a CB_RECALL for an unknown delegation, it can cache the stateid and filehandle on a list of pending recalls. When it is provided with a delegation, it would only use it if it was not on the pending recall list. Upon the next CB_RECALL, it could immediately return the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代わりに、それはNFS4ERR_BADHANDLEで応答しない場合、クライアントとサーバの両方が競合状態が発生していることを検出することができるかもしれません。クライアントは、保留中の代表団のリストを維持することができます。それは未知の委任に対してCB_RECALLを受信すると、保留リコールのリストに載ってたstateidとファイルハンドルをキャッシュすることができます。それは代表団を備えている場合、それは保留リコールリストになかった場合、それだけで、それを使用します。次CB_RECALLすると、それはすぐに委任を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In turn, the server can keep track of when it issues a delegation and assume that if a client responds to the CB_RECALL with an NFS4ERR_BADHANDLE, then the client has yet to receive the delegation. The server SHOULD give the client a reasonable time both to get this delegation and to return it before revoking the delegation. Unlike a failed callback path, the server should periodically probe the client with CB_RECALL to see if it has received the delegation and is ready to return it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ターンでは、サーバーは、それが委任を発行したときを追跡し、クライアントがNFS4ERR_BADHANDLEでCB_RECALLに応答する場合、クライアントが委任をもらっていないと仮定することができます。サーバーはクライアントに、この委任を取得すると委任を取り消す前にそれを返すために、合理的な時間の両方を与える必要があります。失敗したコールバックパスとは異なり、サーバは定期的にそれが委任を受けて、それを返しする準備ができているかどうかを確認するためにCB_RECALLでクライアントを調べる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server finally determines that enough time has elapsed, it SHOULD revoke the delegation and it SHOULD NOT revoke the lease. During this extended recall process, the server SHOULD be renewing the client lease. The intent here is that the client not pay too onerous a burden for a condition caused by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは最終的に十分な時間が経過したと判断した場合は、それが委任を撤回すべきであり、それがリースを取り消すべきではありません。この拡張リコール処理中に、サーバーは、クライアントのリースを更新するべきです。ここでの意図は、クライアントがサーバーによって引き起こされる状態のためにあまりにも面倒な負担を払っていないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.6. Clients That Fail to Honor Delegation Recalls
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.6。委任リコールを称えるために失敗したクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client may fail to respond to a recall for various reasons, such as a failure of the callback path from the server to the client. The client may be unaware of a failure in the callback path. This lack of awareness could result in the client finding out long after the failure that its delegation has been revoked, and another client has modified the data for which the client had a delegation. This is especially a problem for the client that held an OPEN_DELEGATE_WRITE delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバーからクライアントへのコールバックパスの障害など、さまざまな理由でリコールへの対応に失敗することがあります。クライアントは、コールバックパスの障害に気づかないかもしれません。意識の欠如は、クライアントがその代表団が取り消された障害が発生した後、長い見つけると、別のクライアントは、クライアントが委任を持っていたため、データを変更したにつながる可能性があります。これは特にOPEN_DELEGATE_WRITEの委任を開催クライアントの問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server also has a dilemma in that the client that fails to respond to the recall might also be sending other NFS requests, including those that renew the lease before the lease expires. Without returning an error for those lease-renewing operations, the server leads the client to believe that the delegation it has is in force.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、サーバは、リコールへの応答に失敗したクライアントは、リースの期限が切れる前にリースを更新するものを含め、他のNFS要求を送信されるかもしれないというジレンマがあります。これらのリース更新操作のエラーを返さずに、サーバーは、それが持っている代表団が力であることを信じるようにクライアントをリードしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This difficulty is solved by the following rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この難しさは、次の規則によって解決されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When the callback path is down, the server MUST NOT revoke the delegation if one of the following occurs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コールバックパスがダウンしている場合は、次のいずれかが発生した場合、O、サーバが委任を取り消してはなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* The client has issued a RENEW operation, and the server has returned an NFS4ERR_CB_PATH_DOWN error. The server MUST renew the lease for any byte-range locks and share reservations the client has that the server has known about (as opposed to those locks and share reservations the client has established but not yet sent to the server, due to the delegation). The server SHOULD give the client a reasonable time to return its delegations to the server before revoking the client&#39;s delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*クライアントがRENEW操作を発行しており、サーバはNFS4ERR_CB_PATH_DOWNエラーを返しました。サーバーは、任意のバイト範囲ロックのリースを更新し、クライアントが（クライアントが確立しており、それらのロックと共有の予約ではなく、まだサーバに送信されないように起因代表団に、）サーバーがについて知られていることを持って予約を共有しなければなりません。サーバーはクライアントに、クライアントの代表団を取り消す前に、サーバーへの委任を返すために合理的な時間を与える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* The client has not issued a RENEW operation for some period of time after the server attempted to recall the delegation. This period of time MUST NOT be less than the value of the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが委任をリコールすることを試みた後、*クライアントは、しばらくの間RENEW操作を発行しておりません。この期間はlease_time属性の値以上でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When the client holds a delegation, it cannot rely on operations, except for RENEW, that take a stateid, to renew delegation leases across callback path failures. The client that wants to keep delegations in force across callback path failures must use RENEW to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが委任を保持している場合は、O、それはコールバックパスの障害を越え委任リースを更新するために、のstateidを取るRENEWを除く操作、に頼ることはできません。コールバックパスの障害を越え力に代表団を維持したいクライアントがそうするようにRENEW使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.7. Delegation Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.7。委任失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At the point a delegation is revoked, if there are associated opens on the client, the applications holding these opens need to be notified. This notification usually occurs by returning errors for READ/WRITE operations or when a close is attempted for the open file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そこに関連付けられている場合時点で、委任がクライアントに開き、取り消され、これらを保持しているアプリケーションに通知する必要が開きます。この通知は、通常、READ / WRITE操作にエラーを返すとき、またはクローズが開いたファイルのためにしようとしていることによって起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If no opens exist for the file at the point the delegation is revoked, then notification of the revocation is unnecessary. However, if there is modified data present at the client for the file, the user of the application should be notified. Unfortunately, it may not be possible to notify the user since active applications may not be present at the client. See Section 10.5.1 for additional details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
委任が取り消された時点でファイルの存在開いたいかなる場合は、取り消しの通知は不要ではありません。ファイルのクライアントで変更されたデータが存在した場合ただし、アプリケーションの利用者に通知しなければなりません。残念ながら、アクティブなアプリケーションがクライアントに存在しないかもしれないので、ユーザに通知することはできないかもしれません。詳細については10.5.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. Data Caching and Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5。データキャッシングと失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When locks and delegations are revoked, the assumptions upon which successful caching depend are no longer guaranteed. For any locks or share reservations that have been revoked, the corresponding owner needs to be notified. This notification includes applications with a file open that has a corresponding delegation that has been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロックや代表団が取り消された場合は、成功したキャッシュが依存する仮定はもはや保証されません。取り消されたすべてのロックまたは共有の予約の場合は、対応する所有者に通知する必要があります。この通知は取り消された対応する代表団を持っているファイルのオープンとアプリケーションが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cached data associated with the revocation must be removed from the client. In the case of modified data existing in the client&#39;s cache, that data must be removed from the client without it being written to the server. As mentioned, the assumptions made by the client are no longer valid at the point when a lock or delegation has been revoked. For example, another client may have been granted a conflicting lock after the revocation of the lock at the first client. Therefore, the data within the lock range may have been modified by the other client. Obviously, the first client is unable to guarantee to the application what has occurred to the file in the case of revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
失効に関連付けられたキャッシュされたデータは、クライアントから削除する必要があります。クライアントのキャッシュ内の既存の変更されたデータの場合には、そのデータは、それがサーバーに書き込まれずに、クライアントから削除する必要があります。前述のように、クライアントによって行われた仮定は、ロックまたは委任が取り消された時点で、もはや有効ではありません。例えば、別のクライアントは、最初のクライアントでのロックの失効後に矛盾するロックが付与されている可能性があります。したがって、ロック範囲内のデータは、他のクライアントによって修飾されていてもよいです。もちろん、最初のクライアントが失効した場合のファイルに発生したものをアプリケーションに保証することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Notification to a lock-owner will in many cases consist of simply returning an error on the next and all subsequent READs/WRITEs to the open file or on the close. Where the methods available to a client make such notification impossible because errors for certain operations may not be returned, more drastic action, such as signals or process termination, may be appropriate. The justification for this is that an invariant on which an application depends may be violated. Depending on how errors are typically treated for the client operating environment, further levels of notification, including logging, console messages, and GUI pop-ups, may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロック所有者への通知は、多くの場合、単純に次のエラーを返すから構成され、後続のすべては/がオープンファイルまたは近くに読み書きを行います。クライアントに利用可能な方法は、そのような通知が不可能ここで特定の操作のためにエラーが返されない場合があるので、このような信号またはプロセス終了などのより劇的な作用は、適切であり得ます。これを正当化する理由は、アプリケーションが依存している不変に違反することができるということです。エラーは通常、クライアントの動作環境のために処理されている方法に応じて、ログ、コンソールメッセージ、およびGUIのポップアップを含む通知のさらなるレベルは、適切な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.1. Revocation Recovery for Write Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5.1。書き込みオープン委譲のための失効回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Revocation recovery for an OPEN_DELEGATE_WRITE delegation poses the special issue of modified data in the client cache while the file is not open. In this situation, any client that does not flush modified data to the server on each close must ensure that the user receives appropriate notification of the failure as a result of the revocation. Since such situations may require human action to correct problems, notification schemes in which the appropriate user or administrator is notified may be necessary. Logging and console messages are typical examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルが開いていないながらOPEN_DELEGATE_WRITE委任の失効回復は、クライアントキャッシュに変更されたデータの特別な問題を提起します。このような状況では、各近い上のサーバーに変更されたデータをフラッシュしない任意のクライアントは、ユーザーが失効した結果として故障の適切な通知を受けたことを確認する必要があります。このような状況は、問題を修正するために人間の行動を必要とするかもしれないので、適切なユーザまたは管理者に通知された通知方式が必要であってもよいです。ロギングとコンソールメッセージが典型的な例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If there is modified data on the client, it must not be flushed normally to the server. A client may attempt to provide a copy of the file data as modified during the delegation under a different name in the file system namespace to ease recovery. Note that when the client can determine that the file has not been modified by any other client, or when the client has a complete cached copy of the file in question, such a saved copy of the client&#39;s view of the file may be of particular value for recovery. In other cases, recovery using a copy of the file, based partially on the client&#39;s cached data and partially on the server copy as modified by other clients, will be anything but straightforward, so clients may avoid saving file contents in these situations or mark the results specially to warn users of possible problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント上のデータが変更された場合は、サーバーに正常にフラッシュされてはなりません。クライアントは、リカバリを容易にするために、ファイルシステムの名前空間に別の名前で、委任時に変更されたファイルデータのコピーを提供しようとすることができます。クライアントは、ファイルが他のクライアントによって変更されていないと判断できる場合に、クライアントが問題のファイルの完全なキャッシュされたコピーを持っている場合、または、ファイルのクライアントのビューのように保存されたコピーが特定の値であってもよいことに注意してください回復のため。クライアントはこれらの状況では、ファイルの内容を保存回避またはマークすることができるので、他の例では、クライアントのキャッシュされたデータに部分的に他のクライアントによって変更されたサーバーコピーに部分的に基づいて、ファイルのコピーを使用して、回復は、簡単な何でもなります可能性のある問題のユーザーに警告するために特別になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The saving of such modified data in delegation revocation situations may be limited to files of a certain size or might be used only when sufficient disk space is available within the target file system. Such saving may also be restricted to situations when the client has sufficient buffering resources to keep the cached copy available until it is properly stored to the target file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
委任失効状況で、このような変更されたデータの保存は、特定のサイズのファイルに限定することができるか、十分なディスク領域が、ターゲット・ファイル・システム内で利用可能である場合にのみ使用される可能性があります。このような節約はまた、それが適切にターゲット・ファイル・システムに格納されるまで、クライアントが利用できるキャッシュされたコピーを保持するのに十分なバッファリング資源を持っているときの状況に制限することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. Attribute Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6。属性のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The attributes discussed in this section do not include named attributes. Individual named attributes are analogous to files, and caching of the data for these needs to be handled just as data caching is for regular files. Similarly, LOOKUP results from an OPENATTR directory are to be cached on the same basis as any other pathnames and similarly for directory contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションで説明する属性が指定された属性が含まれていません。個々の名前の属性は、ファイルに類似しており、これらのニーズのためのデータのキャッシュは、データキャッシュが通常のファイルのためであると同じように扱うことが。同様に、OPENATTRディレクトリから参照結果は、ディレクトリの内容のための任意の他のパス名と同様に同じに基づいてキャッシュされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients may cache file attributes obtained from the server and use them to avoid subsequent GETATTR requests. This cache is write through caching in that any modifications to the file attributes are always done by means of requests to the server, which means the modifications should not be done locally and should not be cached. Exceptions to this are modifications to attributes that are intimately connected with data caching. Therefore, extending a file by writing data to the local data cache is reflected immediately in the size as seen on the client without this change being immediately reflected on the server. Normally, such changes are not propagated directly to the server, but when the modified data is flushed to the server, analogous attribute changes are made on the server. When open delegation is in effect, the modified attributes may be returned to the server in the response to a CB_GETATTR call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバから取得したファイル属性をキャッシュし、その後のGETATTR要求を避けるためにそれらを使用することができます。このキャッシュは、ファイルの属性への変更は、常に変更がローカルで行われるべきではありませんし、キャッシュされるべきではないこと、サーバーへのリクエストによって行われている中で、キャッシュライトスルーです。これに対する例外は密接にデータキャッシュに接続されている属性に変更されています。したがって、ローカル・データ・キャッシュにデータを書き込むことで、ファイルを拡張すると、この変更はすぐにサーバーに反映されずに、クライアント上で見られるような大きさにすぐに反映されています。通常、このような変更は、サーバーに直接伝播されるのではなく、変更されたデータをサーバーにフラッシュされたときに、類似した属性の変更は、サーバー上で行われています。開いている委譲が有効になっている場合には、変更された属性はCB_GETATTRの呼び出しに応じてサーバに戻すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The result of local caching of attributes is that the attribute caches maintained on individual clients will not be coherent. Changes made in one order on the server may be seen in a different order on one client and in a third order on a different client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性のローカルキャッシュの結果は、個々のクライアント上で維持さ属性キャッシュがコヒーレントではないということです。サーバー上の1つの順序で行われた変更は1つのクライアントと異なるクライアント上の三ために、異なる順序で見ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The typical file system application programming interfaces do not provide means to atomically modify or interrogate attributes for multiple files at the same time. The following rules provide an environment where the potential incoherency mentioned above can be reasonably managed. These rules are derived from the practice of previous NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的なファイルシステムのアプリケーション・プログラミング・インタフェースは、アトミック、同時に複数のファイルの属性を変更したり、尋問するための手段を提供しません。次のルールは、上記の潜在的なインコヒーレントが合理的に管理することができる環境を提供します。これらの規則は、以前のNFSプロトコルの実施から導出されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o All attributes for a given file (per-fsid attributes excepted) are cached as a unit at the client so that no non-serializability can arise within the context of a single file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何の非直列可能で、単一のファイルのコンテキスト内で発生しないことができるように、O、指定されたファイルのすべての属性は、（あたり-FSID属性は除く）クライアントでの単位としてキャッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An upper time boundary is maintained on how long a client cache entry can be kept without being refreshed from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O上側の時間境界は、クライアントのキャッシュエントリは、サーバから更新されずに保持することができるどのくらいに維持されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When operations are performed that modify attributes at the server, the updated attribute set is requested as part of the containing RPC. This includes directory operations that update attributes indirectly. This is accomplished by following the modifying operation with a GETATTR operation and then using the results of the GETATTR to update the client&#39;s cached attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作は、サーバーの属性を変更することを行っている場合は、O、更新された属性のセットが含まRPCの一部として要求されています。これは、その更新が間接的に属性ディレクトリ操作を含んでいます。これは、GETATTR操作で改質操作を次し、クライアントのキャッシュされた属性を更新するために、GETATTRの結果を使用することによって達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that if the full set of attributes to be cached is requested by READDIR, the results can be cached by the client on the same basis as attributes obtained via GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュされる属性の完全なセットがREADDIRによって要求された場合、結果がGETATTRを介して取得した属性と同じ基準で、クライアントによってキャッシュされることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client may validate its cached version of attributes for a file by only fetching both the change and time_access attributes and assuming that if the change attribute has the same value as it did when the attributes were cached, then no attributes other than time_access have changed. The time_access attribute is also fetched because many servers operate in environments where the operation that updates change does not update time_access. For example, POSIX file semantics do not update access time when a file is modified by the write system call. Therefore, the client that wants a current time_access value should fetch it with change during the attribute cache validation processing and update its cached time_access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、唯一の変化とtime_access属性の両方を取得し、属性がキャッシュされた時にそれがなかったとして変化属性が同じ値を持っている場合は、time_access以外の属性が変更されていないことを仮定することにより、ファイルの属性のそのキャッシュされたバージョンを検証することができます。多くのサーバーが変更を更新操作がtime_accessを更新していない環境でも動作するのでtime_access属性も取得されます。例えば、POSIXファイルのセマンティクスは、ファイルが書き込みシステムコールによって変更されたアクセス時間を更新しません。したがって、現在のtime_access値を望んでいるクライアントは、属性キャッシュの検証処理中に変更して、それをフェッチし、そのキャッシュされたtime_accessを更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client may maintain a cache of modified attributes for those attributes intimately connected with data of modified regular files (size, time_modify, and change). Other than those three attributes, the client MUST NOT maintain a cache of modified attributes. Instead, attribute changes are immediately sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは密接に変更され、通常のファイル（サイズ、time_modify、および変更）のデータに接続し、それらの属性のために変更された属性のキャッシュを維持することができます。これらの3つの属性以外にも、クライアントが変更された属性のキャッシュを維持してはなりません。代わりに、属性の変更は、すぐにサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In some operating environments, the equivalent to time_access is expected to be implicitly updated by each read of the content of the file object. If an NFS client is caching the content of a file object, whether it is a regular file, directory, or symbolic link, the client SHOULD NOT update the time_access attribute (via SETATTR or a small READ or READDIR request) on the server with each read that is satisfied from cache. The reason is that this can defeat the performance benefits of caching content, especially since an explicit SETATTR of time_access may alter the change attribute on the server. If the change attribute changes, clients that are caching the content will think the content has changed and will re-read unmodified data from the server. Nor is the client encouraged to maintain a modified version of time_access in its cache, since this would mean that the client either will eventually have to write the access time to the server with bad performance effects or would never update the server&#39;s time_access, thereby resulting in a situation where an application that caches access time between a close and open of the same file observes the access time oscillating between the past and present. The time_access attribute always means the time of last access to a file by a READ that was satisfied by the server. This way, clients will tend to see only time_access changes that go forward in time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のオペレーティング環境では、time_accessと同等のは暗黙のうちにファイルオブジェクトのコンテンツの各読み取りによって更新されることが期待されます。 NFSクライアントは、それが通常のファイル、ディレクトリ、シンボリックリンクであるかどうか、ファイルオブジェクトのコンテンツをキャッシュしている場合、クライアントはそれぞれに、サーバー上の（SETATTRや小さなREADまたはREADDIR要求を経由して）time_access属性を更新すべきではありませんそれはキャッシュから満足しているお読みください。その理由は、これがtime_accessの明示的なSETATTRは、サーバー上の変化属性を変更することができる、特に以来、キャッシュコンテンツのパフォーマンス上の利点を倒すことができるということです。変更属性の変更をした場合、コンテンツをキャッシュしているクライアントは、コンテンツがサーバーから変更されていないデータを変更したと再読み込みすると思います。これはどちらかのクライアントが、それによって、その結果、最終的に悪いパフォーマンスへの影響を持つサーバへのアクセス時間を記述する必要がありますか、サーバーのtime_accessを更新することはないことを意味するので、NOR、そのキャッシュにtime_accessの修正版を維持することが推奨クライアントであります状況はどこ同一ファイルのクローズとオープンの間のアクセス時間をキャッシュするアプリケーションは、過去と現在との間のアクセス時間の振動を観測します。 time_access属性は常にサーバーによって満たされたREADにより、ファイルへの最後のアクセスの時間を意味します。この方法では、クライアントが時間に前に進むのみtime_accessの変更を確認する傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. Data and Metadata Caching and Memory-Mapped Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7。データおよびメタデータキャッシュとメモリマップファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some operating environments include the capability for an application to map a file&#39;s content into the application&#39;s address space. Each time the application accesses a memory location that corresponds to a block that has not been loaded into the address space, a page fault occurs and the file is read (or if the block does not exist in the file, the block is allocated and then instantiated in the application&#39;s address space).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のオペレーティング環境では、アプリケーションのアドレス空間にファイルの内容をマップするアプリケーションのための機能が含まれています。アドレス空間にロードされていないブロックに対応するメモリ位置にアクセスするアプリケーションごとに、ページフォールトが発生し、ファイルが読み込まれる（またはブロックがファイル内に存在しない場合、ブロックが割り当てられると）アプリケーションのアドレス空間でインスタンス化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As long as each memory-mapped access to the file requires a page fault, the relevant attributes of the file that are used to detect access and modification (time_access, time_metadata, time_modify, and change) will be updated. However, in many operating environments, when page faults are not required, these attributes will not be updated on reads or updates to the file via memory access (regardless of whether the file is a local file or is being accessed remotely). A client or server MAY fail to update attributes of a file that is being accessed via memory-mapped I/O. This has several implications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
限り、ファイルへの各メモリ・マップ・アクセスは、ページフォールトを必要として、アクセスと変更（time_access、time_metadata、time_modify、および変更）を検出するために使用されているファイルの関連属性が更新されます。ただし、ページフォールトが必要とされていないとき、多くのオペレーティング環境では、これらの属性は、上の更新されません（関係なく、ファイルはローカルファイルであるかリモートでアクセスされているかどうかの）メモリアクセスを介したファイルへの読み取りまたは更新されます。クライアントまたはサーバは、メモリマップドI / Oを経由してアクセスされているファイルの属性を更新するために失敗することがあります。これにはいくつかの意味を持っています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If there is an application on the server that has memory mapped a file that a client is also accessing, the client may not be able to get a consistent value of the change attribute to determine whether its cache is stale or not. A server that knows that the file is memory mapped could always pessimistically return updated values for change so as to force the application to always get the most up-to-date data and metadata for the file. However, due to the negative performance implications of this, such behavior is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メモリは、クライアントにもアクセスしているファイルをマッピングしているサーバー上のアプリケーションがある場合は、O、クライアントは、そのキャッシュが古くなっているかいないかどうかを判断するために変化属性の一貫性のある値を取得することができない場合があります。常に最新のデータやファイルのメタデータを取得するためにアプリケーションを強制するように、ファイルがメモリマップされていることを知っているサーバーは、常に悲観的に変更のための更新された値を返すことができます。しかし、この負のパフォーマンスへの影響のために、そのような行動はオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the memory-mapped file is not being modified on the server and instead is just being read by an application via the memory-mapped interface, the client will not see an updated time_access attribute. However, in many operating environments, neither will any process running on the server. Thus, NFS clients are at no disadvantage with respect to local processes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メモリマップドファイルがサーバー上で変更されていないとだけではなく、メモリマップされたインタフェースを介してアプリケーションによって読み取られている場合は、O、クライアントが更新されtime_access属性は表示されません。しかし、多くのオペレーティング環境では、どちらも任意のプロセスは、サーバー上で実行されているんでしょう。したがって、NFSクライアントは、ローカルプロセスに対してない不利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If there is another client that is memory mapping the file and if that client is holding an OPEN_DELEGATE_WRITE delegation, the same set of issues as discussed in the previous two bullet items apply. So, when a server does a CB_GETATTR to a file that the client has modified in its cache, the response from CB_GETATTR will not necessarily be accurate. As discussed earlier, the client&#39;s obligation is to report that the file has been modified since the delegation was granted, not whether it has been modified again between successive CB_GETATTR calls, and the server MUST assume that any file the client has modified in cache has been modified again between successive CB_GETATTR calls. Depending on the nature of the client&#39;s memory management system, this weak obligation may not be possible. A client MAY return stale information in CB_GETATTR whenever the file is memory mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oメモリのファイルをマッピングしている別のクライアントがある場合は、前の2箇条書きの項目で説明したように、そのクライアントは、問題の同じセットをOPEN_DELEGATE_WRITE委任を保持している場合は適用されます。サーバは、クライアントがそのキャッシュ内で変更したファイルにCB_GETATTRをするときに、CB_GETATTRからの応答は必ずしも正確ではありません。先に述べたように、クライアントの義務は、委任が許可されたので、それが連続CB_GETATTR呼び出しの間で再び変更されているかどうか、ファイルが変更されたことを報告することで、サーバは、クライアントがキャッシュ内で変更したすべてのファイルがされていると仮定しなければなりません連続CB_GETATTR呼び出しの間で再び修正。クライアントのメモリ管理システムの性質に応じて、この弱い義務はできないことがあります。ファイルがメモリマップされたときはいつでも、クライアントはCB_GETATTRに古い情報が返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The mixture of memory mapping and file locking on the same file is problematic. Consider the following scenario, where the page size on each client is 8192 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O同じファイルのメモリマッピングおよびファイルのロックの混合物が問題となります。各クライアント上のページサイズが8192バイトである場合、次のシナリオを検討してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Client A memory maps first page (8192 bytes) of file X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*クライアントのメモリは、ファイルXの最初のページ（8192バイト）にマップ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Client B memory maps first page (8192 bytes) of file X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*クライアントBのメモリは、ファイルXの最初のページ（8192バイト）にマップ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Client A write locks first 4096 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*クライアント書き込みロック最初の4096バイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Client B write locks second 4096 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* 4096バイト第2のクライアントBの書き込みロック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Client A, via a STORE instruction, modifies part of its locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*クライアントAは、STORE命令を介して、そのロックされた領域の一部を修正します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Simultaneous to client A, client B issues a STORE on part of its locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*クライアントAへの同時、クライアントBはそのロックされた領域の一部にSTOREを発行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here, the challenge is for each client to resynchronize to get a correct view of the first page. In many operating environments, the virtual memory management systems on each client only know a page is modified, not that a subset of the page corresponding to the respective lock regions has been modified. So it is not possible for each client to do the right thing, which is to only write to the server that portion of the page that is locked. For example, if client A simply writes out the page, and then client B writes out the page, client A&#39;s data is lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各クライアントは、最初のページの正しいビューを取得するために再同期化するためにここでは、課題となっています。多くのオペレーティング環境では、各クライアント上の仮想メモリ管理システムが唯一のページが変更されて知っている、それぞれのロック領域に対応するページのサブセットが変更されていないこと。だから、それぞれのクライアントのみがロックされているページのサーバー部分を書くことである正しいことを、行うことは可能ではありません。例えば、クライアントAは、単にページを書き出した場合、その後、クライアントBがページを書き出し、クライアントAのデータが失われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Moreover, if mandatory locking is enabled on the file, then we have a different problem. When clients A and B issue the STORE instructions, the resulting page faults require a byte-range lock on the entire page. Each client then tries to extend their locked range to the entire page, which results in a deadlock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
強制ロックがファイル上で有効になっている場合はまた、我々は別の問題を抱えています。クライアントのAとBの問題STORE命令は、結果のページフォルトはページ全体のバイト範囲ロックを必要とするとき。各クライアントは、その後、デッドロックになり、ページ全体に彼らのロックされた範囲を拡張しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Communicating the NFS4ERR_DEADLOCK error to a STORE instruction is difficult at best.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
STORE命令にNFS4ERR_DEADLOCKエラーを伝えることは最高に困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a client is locking the entire memory-mapped file, there is no problem with advisory or mandatory byte-range locking, at least until the client unlocks a region in the middle of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、全体のメモリマップファイルをロックしている場合、クライアントはファイルの途中の領域をロック解除少なくともまで、諮問または必須のバイト範囲ロッキング問題がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given the above issues, the following are permitted:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の問題を考えると、次は許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Clients and servers MAY deny memory mapping a file they know there are byte-range locks for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントとサーバーは、バイト範囲ロックがためにそこにいることを知っているファイルをマッピングするメモリを拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Clients and servers MAY deny a byte-range lock on a file they know is memory mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントとサーバーは、メモリがマッピングされている知っているファイルのバイト範囲ロックを拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A client MAY deny memory mapping a file that it knows requires mandatory locking for I/O. If mandatory locking is enabled after the file is opened and mapped, the client MAY deny the application further access to its mapped file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントは、それがI / Oのための強制ロックを必要と知っているファイルをマッピングするメモリを拒否することができます。ファイルが開かれ、マップされた後に強制ロックが有効になっている場合、クライアントはそのマップされたファイルへのアプリケーションのさらなるアクセスを拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. Name Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8。名前キャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The results of LOOKUP and READDIR operations may be cached to avoid the cost of subsequent LOOKUP operations. Just as in the case of attribute caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies and given the context of typical file system APIs, an upper time boundary is maintained on how long a client name cache entry can be kept without verifying that the entry has not been made invalid by a directory change operation performed by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOOKUPとREADDIR操作の結果は、その後のLOOKUP操作のコストを回避するためにキャッシュされる場合があります。ただ、属性のキャッシングの場合のように、矛盾がさまざまなクライアントキャッシュ間生じる可能性があります。これらの不整合の影響を緩和し、一般的なファイルシステムAPIのコンテキストを与えるために、上側の時間境界は、クライアント名のキャッシュエントリが行われたディレクトリ変更操作によってエントリが無効にされていないことを確認せずに維持することができるどのくらいに維持されています別のクライアントによる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client is not making changes to a directory for which there exist name cache entries, the client needs to periodically fetch attributes for that directory to ensure that it is not being modified. After determining that no modification has occurred, the expiration time for the associated name cache entries may be updated to be the current time plus the name cache staleness bound.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが名前のキャッシュエントリが存在するためにディレクトリを変更するされていない場合、クライアントは定期的にそれが修正されていないことを確認するために、そのディレクトリの属性を取得する必要があります。何も変更が発生していないことを決定した後、関連する名前のキャッシュエントリの有効期限は、現在の時刻プラスバインド名キャッシュ古さに更新することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client is making changes to a given directory, it needs to determine whether there have been changes made to the directory by other clients. It does this by using the change attribute as reported before and after the directory operation in the associated change_info4 value returned for the operation. The server is able to communicate to the client whether the change_info4 data is provided atomically with respect to the directory operation. If the change values are provided atomically, the client is then able to compare the pre-operation change value with the change value in the client&#39;s name cache. If the comparison indicates that the directory was updated by another client, the name cache associated with the modified directory is purged from the client. If the comparison indicates no modification, the name cache can be updated on the client to reflect the directory operation and the associated timeout extended. The post-operation change value needs to be saved as the basis for future change_info4 comparisons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが指定したディレクトリに変更を行っているとき、それは他のクライアントがディレクトリへの変更があったかどうかを決定する必要があります。これは、操作のために返される関連する変化_info4値のディレクトリ操作の前と後に報告されたように変化属性を使用してこれを行います。サーバは変化_info4データがディレクトリ動作に関してアトミックに設けられているかどうかをクライアントに通信することができます。変更値をアトミックに提供されている場合、クライアントは、クライアントの名前キャッシュに変更値が事前に動作変更値を比較することです。比較はディレクトリが別のクライアントによって更新されたことを示している場合、修正ディレクトリに関連付けられた名前のキャッシュは、クライアントからパージされます。比較は何も変更がないことを示す場合は、名前のキャッシュは、ディレクトリ操作を反映するために、クライアント上で更新することができ、関連するタイムアウトを延長しました。術後変化値は、将来の変化_info4比較のための基礎として保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As demonstrated by the scenario above, name caching requires that the client revalidate name cache data by inspecting the change attribute of a directory at the point when the name cache item was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory are modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記のシナリオによって示されるように、名前のキャッシュは、クライアントが名前のキャッシュ項目がキャッシュされた時点で、ディレクトリの変更属性を調べることによって、名前のキャッシュデータを再検証する必要があります。これは、対応するディレクトリの内容が変更されると、サーバーがディレクトリの変更属性を更新する必要があります。適切かつ正確に変化_info4情報を使用するクライアントの場合、サーバーは、前後の動作変更がアトミック属性値を報告しなければなりません。サーバーは、ディレクトリ操作に関して原子論前後の値を報告することができない場合は、サーバーは変化_info4の戻り値であることを示す必要があります。情報がアトミックに報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないことを仮定するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9. Directory Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9。ディレクトリのキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The results of READDIR operations may be used to avoid subsequent READDIR operations. Just as in the cases of attribute and name caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies, and given the context of typical file system APIs, the following rules should be followed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READDIR操作の結果は、その後のREADDIR操作を回避するために使用されてもよいです。ただ、属性と名前のキャッシュの例のように、矛盾がさまざまなクライアントキャッシュ間生じる可能性があります。これらの不整合の影響を軽減し、一般的なファイルシステムAPIのコンテキストを与えるために、次の規則に従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Cached READDIR information for a directory that is not obtained in a single READDIR operation must always be a consistent snapshot of directory contents. This is determined by using a GETATTR before the first READDIR and after the last READDIR that contributes to the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OシングルREADDIR操作で得られていないディレクトリのキャッシュREADDIR情報は常に、ディレクトリの内容の一貫性のあるスナップショットでなければなりません。これは最初のREADDIR前に、キャッシュに寄与し、最後のREADDIR後GETATTRを用いて決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An upper time boundary is maintained to indicate the length of time a directory cache entry is considered valid before the client must revalidate the cached information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O上側の時間境界は、クライアントがキャッシュされた情報を再検証する必要があります前に、ディレクトリキャッシュエントリが有効と考えられている時間の長さを示すために維持されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The revalidation technique parallels that discussed in the case of name caching. When the client is not changing the directory in question, checking the change attribute of the directory with GETATTR is adequate. The lifetime of the cache entry can be extended at these checkpoints. When a client is modifying the directory, the client needs to use the change_info4 data to determine whether there are other clients modifying the directory. If it is determined that no other client modifications are occurring, the client may update its directory cache to reflect its own changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前キャッシュの場合で説明した再検証技術の緯線。クライアントがGETATTRとディレクトリの変更属性をチェックし、問題のディレクトリを変更していない場合は十分です。キャッシュエントリの寿命は、これらのチェックポイントに拡張することができます。クライアントがディレクトリを変更している場合は、クライアントがディレクトリを変更する他のクライアントが存在するかどうかを判断するために変化_info4データを使用する必要があります。他のクライアントの変更が発生していないと判断された場合、クライアントは自身の変更を反映するために、そのディレクトリキャッシュを更新することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As demonstrated previously, directory caching requires that the client revalidate directory cache data by inspecting the change attribute of a directory at the point when the directory was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory are modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以前に実証されているように、ディレクトリキャッシュは、クライアントがディレクトリがキャッシュされた時点でのディレクトリの変更属性を調べることによって、ディレクトリキャッシュデータを再検証する必要があります。これは、対応するディレクトリの内容が変更されると、サーバーがディレクトリの変更属性を更新する必要があります。適切かつ正確に変化_info4情報を使用するクライアントの場合、サーバーは、前後の動作変更がアトミック属性値を報告しなければなりません。サーバーは、ディレクトリ操作に関して原子論前後の値を報告することができない場合は、サーバーは変化_info4の戻り値であることを示す必要があります。情報がアトミックに報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないことを仮定するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Minor Versioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.マイナーバージョン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To address the requirement of an NFS protocol that can evolve as the need arises, the NFSv4 protocol contains the rules and framework to allow for future minor changes or versioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必要に応じて進化させることができ、NFSプロトコルの要件に対処するには、NFSv4のプロトコルは、将来のマイナーな変更やバージョン管理を可能にするためのルールやフレームワークが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The base assumption with respect to minor versioning is that any future accepted minor version must follow the IETF process and be documented in a Standards Track RFC. Therefore, each minor version number will correspond to an RFC. Minor version 0 of the NFSv4 protocol is represented by this RFC. The COMPOUND and CB_COMPOUND procedures support the encoding of the minor version being requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マイナーバージョンに関する基本仮定は、将来のマイナーバージョンIETFプロセスに従わなければなりませんし、標準化過程のRFCで文書化することを受け入れたことです。したがって、各マイナーバージョン番号は、RFCに対応することになります。 NFSv4プロトコルのマイナーバージョン0は、このRFCによって表されます。 COMPOUNDとCB_COMPOUND手順は、クライアントによって要求されているマイナーバージョンのエンコーディングをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Future minor versions will extend, rather than replace, the XDR for the preceding minor version, as had been done in moving from NFSv2 to NFSv3 and from NFSv3 to NFSv4.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv2からNFSv3のにとのNFSv3からNFSv4.0への移動で行われていたとして、今後のマイナーバージョンでは、前のマイナーバージョンのため、XDRを拡張するのではなく、置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Specification of detailed rules for the construction of minor versions will be addressed in documents defining early minor versions or, more desirably, in an RFC establishing a versioning framework for NFSv4 as a whole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マイナーバージョンの構築のための詳細な規則の仕様は、全体としてのNFSv4のためのバージョン管理の枠組みを確立するRFCで、より望ましくは、早期のマイナーバージョンを定義する文書で対処されますか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Internationalization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.国際化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1。前書き
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Internationalization is a complex topic with its own set of terminology (see [RFC6365]). The topic is made more complex in NFSv4.0 by the tangled history and state of NFS implementations. This section describes what we might call &#34;NFSv4.0 internationalization&#34; (i.e., internationalization as implemented by existing clients and servers) as the basis upon which NFSv4.0 clients may implement internationalization support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
国際は、用語の独自のセットを有する複雑なトピックである（[RFC6365]を参照）。ここでは、NFSの実装のもつれ歴史や状態によってNFSv4.0で、より複雑になっています。このセクションでは、我々はNFSv4.0のクライアントが国際化サポートを実装することができ、その上に基礎として「NFSv4.0の国際化」（既存のクライアントとサーバによって実装される、すなわち、国際化）と呼ぶかもしれないものを説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section is based on the behavior of existing implementations. Note that the behaviors described are each demonstrated by a combination of an NFSv4 server implementation proper and a server-side physical file system. It is common for servers and physical file systems to be configurable as to the behavior shown. In the discussion below, each configuration that shows different behavior is considered separately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、既存の実装の振る舞いに基づいています。説明行動各NFSv4サーバの実装適切とサーバ側の物理ファイル・システムの組み合わせによって実証されていることに留意されたいです。サーバと物理ファイルシステムが示す行動に関しては、設定可能であることが一般的です。以下の説明では、異なる挙動を示し、各構成が別々に考慮されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that in this section, the key words &#34;MUST&#34;, &#34;SHOULD&#34;, and &#34;MAY&#34; retain their normal meanings. However, in deriving this specification from implementation patterns, we document below how the normative terms used derive from the behavior of existing implementations, in those situations in which existing implementation behavior patterns can be determined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、キーワードは「MUST」、「SHOULD」ことに注意してください、そして、それらの通常の意味を保持して、「MAY」。しかし、実装パターンからこの仕様を導出する際に、我々は、使用規範的な用語は、既存の実装の行動パターンを決定することができるような状況では、既存の実装の行動から派生する方法を下に文書化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Behavior implemented by all existing clients or servers is described using &#34;MUST&#34;, since new implementations need to follow existing ones to be assured of interoperability. While it is possible that different behavior might be workable, we have found no case where this seems reasonable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい実装は、相互運用性を保証するために、既存のものをに従う必要があるため、既存のすべてのクライアントまたはサーバによって実装されるO動作は、「MUST」を使用して記述されています。それは異なった動作が実行可能であるかもしれないことは可能ですが、我々はこれが合理的と思われるいかなる場合は認められません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The converse holds for &#34;MUST NOT&#34;: if a type of behavior poses interoperability problems, it MUST NOT be implemented by any existing clients or servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
逆は「MUST NOT」のために保持している：行動の種類は、相互運用性の問題を提起する場合、それは既存のクライアントまたはサーバによって実装されてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Behavior implemented by most existing clients or servers, where that behavior is more desirable than any alternative, is described using &#34;SHOULD&#34;, since new implementations need to follow that existing practice unless there are strong reasons to do otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい実装がそうでなければ行うための強力な理由がある場合を除き、既存の慣行に従ってくださいする必要があるため、O動作が、その動作は任意の代替よりも望ましいほとんどの既存のクライアントまたはサーバによって実装され、「すべきである」を使用して記述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The converse holds for &#34;SHOULD NOT&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「べきでない」ために逆が成り立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Behavior implemented by some, but not all, existing clients or servers is described using &#34;MAY&#34;, indicating that new implementations have a choice as to whether they will behave in that way. Thus, new implementations will have the same flexibility that existing ones do.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O動作は、いくつかによって実装され、すべてではなく、既存のクライアントまたはサーバは、新しい実装は、彼らがそのように動作しますかどうかについての選択肢を持っていることを示す「MAY」を使用して記述されています。このように、新しい実装では、既存のものが行うのと同じ柔軟性を持つことになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Behavior implemented by all existing clients or servers, so far as is known -- but where there remains some uncertainty as to details -- is described using &#34;should&#34;. Such cases primarily concern details of error returns. New implementations should follow existing practice even though such situations generally do not affect interoperability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「すべきである」用いて説明する -  O動作は、これまでに知られているように、すべての既存のクライアントまたはサーバによって実装される - が、詳細に関しては、いくつかの不確実性が残っています。このようなケースは、主に、エラーを返すの詳細を懸念します。新しい実装では、このような状況は、一般的に、相互運用性に影響を与えることはありませんが、既存の慣行に従うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are also cases in which certain server behaviors, while not known to exist, cannot be reliably determined not to exist. In part, this is a consequence of the long period of time that has elapsed since the publication of [RFC3530], resulting in a situation in which those involved in the implementation may no longer be involved in or aware of working group activities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
存在することが知られていない一方で、特定のサーバービヘイビアは、確実に存在しないと判断できない場合もあります。一部では、これは実装に関与するものはもはやに関与またはグループアクティビティ作業を認識することが可能な状況で得られた、[RFC3530]の出版からの経過時間の長い期間の結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of possible server behavior that is neither known to exist nor known not to exist, we use &#34;SHOULD NOT&#34; and &#34;MUST NOT&#34; as follows, and similarly for &#34;SHOULD&#34; and &#34;MUST&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どちらも存在することが知られていないにも存在しないことが知られている可能性、サーバの動作の場合には、我々は、「SHOULD NOT」と「MUST NOT」次のように、同様に「SHOULD」や「MUST」のために使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In some cases, the potential behavior is not known to exist but is of such a nature that, if it were in fact implemented, interoperability difficulties would be expected and reported, giving us cause to conclude that the potential behavior is not implemented. For such behavior, we use &#34;MUST NOT&#34;. Similarly, we use &#34;MUST&#34; to apply to the contrary behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oいくつかのケースでは、潜在的な行動が存在することが知られていないが、それは実際に実施された場合には、相互運用性の困難が予想されるであろうと、私たちは、潜在的な振る舞いが実装されていないと結論する原因与え、報告された、ような性質のものです。そのような行動のために、私たちは「NOT MUST」を使用します。同様に、我々は反対行動に適用する「MUST」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In other cases, potential behavior is not known to exist but the behavior, while undesirable, is not of such a nature that we are able to draw any conclusions about its potential existence. In such cases, we use &#34;SHOULD NOT&#34;. Similarly, we use &#34;SHOULD&#34; to apply to the contrary behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O他の例では、潜在的な行動が存在することが知られているが、行動されていない、望ましくない一方で、我々はその潜在的な存在についての結論を引き出すことができますこのような性質のものではありません。このような場合には、我々は「べきでない」を使用します。同様に、我々は反対行動に適用する「SHOULD」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of a &#34;MAY&#34;, &#34;SHOULD&#34;, or &#34;SHOULD NOT&#34; that applies to servers, clients need to be aware that there are servers that may or may not take the specified action, and they need to be prepared for either eventuality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の場合、またはサーバに適用される、クライアントは、または指定されたアクションを取らない場合がありますサーバーがあることを認識する必要があり、彼らはどちらかのために準備する必要があり、「すべきではない」「べきである」、「かもしれません」不測の事態。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
12.2. Limitations on Internationalization-Related Processing in the NFSv4 Context
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
12.2。 NFSv4のコンテキストにおける国際関連処理に関する制限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are a number of noteworthy circumstances that limit the degree to which internationalization-related processing can be made universal with regard to NFSv4 clients and servers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
国際関係の処理はNFSv4のクライアントとサーバに関してユニバーサル行うことができる程度を制限する注目すべき事情の数があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The NFSv4 client is part of an extensive set of client-side software components whose design and internal interfaces are not within the IETF&#39;s purview, limiting the degree to which a particular character encoding may be made standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NFSv4クライアントは、特定の文字エンコーディングを標準化することができる程度を制限し、設計及び内部インターフェースIETFの範囲内ではない、クライアント側のソフトウェアコンポーネントの拡張セットの一部です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Server-side handling of file component names is typically implemented within a server-side physical file system, whose handling of character encoding and normalization is not specifiable by the IETF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oファイルコンポーネント名のサーバ側の処理は、典型的には、その文字符号化と正規化の取り扱いIETFによって指定可能ではないで、サーバ側の物理ファイル・システム内で実施されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Typical implementation patterns in UNIX systems result in the NFSv4 client having no knowledge of the character encoding being used, which may even vary between processes on the same client system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O UNIXシステムにおける典型的な実装パターンは同じであっても、クライアント・システム上のプロセス間で変化することができる使用される文字符号化の知識を持たないNFSv4クライアントをもたらします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Users may need access to files stored previously with non-UTF-8 encodings, or with UTF-8 encodings that do not match any particular normalization form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oユーザーが非UTF-8エンコーディングを持つ、または任意の特定の正規のフォームに一致しないUTF-8エンコーディングで以前に格納されたファイルへのアクセスが必要な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. Summary of Server Behavior Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3。サーバービヘイビアタイプの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As mentioned in Section 12.6, servers MAY reject component name strings that are not valid UTF-8. This leads to a number of types of valid server behavior, as outlined below. When these are combined with the valid normalization-related behaviors as described in Section 12.4, this leads to the combined behaviors outlined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
12.6項で述べたように、サーバは、有効なUTF-8でないコンポーネント名の文字列を拒否することがあります。下記のとおり、これは有効なサーバーの動作の種類の数につながります。 12.4項で説明したように、これらは有効な正規化関連行動と組み合わせると、これは以下のとおり組み合わせた行動につながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Servers that limit file component names to UTF-8 strings exist with normalization-related handling as described in Section 12.4. These are best described as &#34;UTF-8-only servers&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
12.4項に記載されているようにUTF-8文字列にファイルコンポーネント名を制限するOサーバは、正規化関連取り扱いに存在します。これらは、最高の「UTF-8専用サーバ」と記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Servers that do not limit file component names to UTF-8 strings are very common and are necessary to deal with clients/ applications not oriented to the use of UTF-8. Such servers ignore normalization-related issues, and there is no way for them to implement either normalization or representation-independent lookups. These are best described as &#34;UTF-8-unaware servers&#34;, since they treat file component names as uninterpreted strings of bytes and have no knowledge of the characters represented. See Section 12.7 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UTF-8文字列にファイルコンポーネント名を限定するものではないOサーバは非常に一般的であり、UTF-8の利用に配向していないクライアント/アプリケーションに対処する必要があります。このようなサーバは、正規化関連の問題を無視し、それらを正規化や表現に依存しないのいずれかの検索を実装するための方法はありません。彼らはバイトの未解釈の文字列としてファイルコンポーネント名を治療し、代表文字の知識がないため、これらは最高の、「UTF-8非対応のサーバー」と記載されています。詳細については、12.7節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o It is possible for a server to allow component names that are not valid UTF-8, while still being aware of the structure of UTF-8 strings. Such servers could implement either normalization or representation-independent lookups but apply those techniques only to valid UTF-8 strings. Such servers are not common, but it is possible to configure at least one known server to have this behavior. This behavior SHOULD NOT be used due to the possibility that a filename using one character set may, by coincidence, have the appearance of a UTF-8 filename; the results of UTF-8 normalization or representation-independent lookups are unlikely to be correct in all cases with respect to the other character set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まだUTF-8文字列の構造を意識したまま、oそれは、有効なUTF-8でないコンポーネント名を許可するサーバ用可能です。このようなサーバは、正規表現または独立のいずれかの検索を実装するだけで、有効なUTF-8文字列にそれらの技術を適用することができます。このようなサーバーでは一般的ではありませんが、この動作を持っている少なくとも1台の既知のサーバーを構成することが可能です。この動作が原因1つの文字セットを使用して、ファイル名は、偶然によって、UTF-8ファイル名の外観を有することができるという可能性には使用しないでください。 UTF-8正規表現または非依存ルックアップの結果は、他の文字セットに対して、すべての場合において正しい可能性は低いです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4. String Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4。文字列エンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Strings that potentially contain characters outside the ASCII range [RFC20] are generally represented in NFSv4 using the UTF-8 encoding [RFC3629] of Unicode [UNICODE]. See [RFC3629] for precise encoding and decoding rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
潜在ASCII範囲[RFC20]以外の文字を含む文字列は、一般的にユニコード[UNICODE]のUTF-8エンコーディング[RFC3629]を使用して、NFSv4のに表されています。正確な符号化および復号化ルールのために[RFC3629]を参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some details of the protocol treatment depend on the type of string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコル処理のいくつかの詳細は、文字列のタイプによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For strings that are component names, the preferred encoding for any non-ASCII characters is the UTF-8 representation of Unicode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oコンポーネント名である文字列は、任意の非ASCII文字のための好ましい符号化は、UnicodeのUTF-8表現です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In many cases, clients have no knowledge of the encoding being used, with the encoding done at the user level under the control of a per-process locale specification. As a result, it may be impossible for the NFSv4 client to enforce the use of UTF-8. The use of non-UTF-8 encodings can be problematic, since it may interfere with access to files stored using other forms of name encoding. Also, normalization-related processing (see Section 12.5) of a string not encoded in UTF-8 could result in inappropriate name modification or aliasing. In cases in which one has a non-UTF-8 encoded name that accidentally conforms to UTF-8 rules, substitution of canonically equivalent strings can change the non-UTF-8 encoded name drastically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くの場合、クライアントは、プロセスごとのロケール仕様の制御下でユーザレベルで行わエンコーディングで、使用される符号化の知識を持っていません。 NFSv4クライアントは、UTF-8の使用を強制するために、結果として、それができない場合があります。それは名前の符号化の他の形式を使用して保存されたファイルへのアクセスを妨害する可能性があるので、非UTF-8エンコーディングを使用することは、問題となり得ます。また、正規化関連処理不適切な名前変更またはエイリアシングが生じる可能性がないUTF-8でエンコードされた文字列の（セクション12.5を参照）。 1が誤ってUTF-8のルールに準拠した非UTF-8でエンコードされた名前を持つする場合には、標準的に等価な文字列の置換が大幅に非UTF-8でエンコードされた名前を変更することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The kinds of modification and aliasing mentioned here can lead to both false negatives and false positives, depending on the strings in question, which can result in security issues such as elevation of privilege and denial of service (see [RFC6943] for further discussion).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
修正とここで言及エイリアシングの種類は、（さらなる議論のための[RFC6943]を参照）、このような特権の昇格およびサービス拒否などのセキュリティ上の問題をもたらすことが問題になっている文字列に応じて、偽陰性および偽陽性の両方につながることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For strings based on domain names, non-ASCII characters MUST be represented using the UTF-8 encoding of Unicode, and additional string format restrictions apply. See Section 12.6 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oドメイン名に基づいて文字列の場合は、非ASCII文字は、UnicodeのUTF-8エンコーディングを使用して表現されなければならない、と追加の文字列形式の制限が適用されます。詳細については、12.6項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The contents of symbolic links (of type linktext4 in the XDR) MUST be treated as opaque data by NFSv4 servers. Although UTF-8 encoding is often used, it need not be. In this respect, the contents of symbolic links are like the contents of regular files in that their encoding is not within the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O（XDRにおける型linktext4の）シンボリックリンクの内容のNFSv4サーバによって不透明なデータとして扱わなければなりません。 UTF-8エンコーディングがしばしば使用されるが、それはする必要はありません。そのエンコーディングはこの仕様の範囲内ではないという点で、この点では、シンボリックリンクの内容は、通常のファイルの内容のようなものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For other sorts of strings, any non-ASCII characters SHOULD be represented using the UTF-8 encoding of Unicode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文字列の他の種類についてはO、非ASCII文字は、UnicodeのUTF-8エンコーディングを使用して表現できるようにして下さい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5. Normalization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.5。正常化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client and server operating environments may differ in their policies and operational methods with respect to character normalization (see [UNICODE] for a discussion of normalization forms). This difference may also exist between applications on the same client. This adds to the difficulty of providing a single normalization policy for the protocol that allows for maximal interoperability. This issue is similar to the issues of character case where the server may or may not support case-insensitive filename matching and may or may not preserve the character case when storing filenames. The protocol does not mandate a particular behavior but allows for a range of useful behaviors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバーの動作環境は、（正規形の議論のための[UNICODE]を参照）文字の正規化に関して、彼らの政策や運用方法が異なることがあります。この違いは、同じクライアント上のアプリケーションの間に存在することができます。これが最大の相互運用性を可能にしたプロトコルのための単一の正規化ポリシーを提供することの難しさに追加されます。サーバーは、または大文字と小文字を区別しないファイル名のマッチングをサポートしていない可能性があり、ファイル名を格納するときや文字ケースを保存しない場合がありますどここの問題は、文字の例の問題に似ています。プロトコルは、特定の行動を義務付けるが、有益な行動の範囲を可能にしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol does not mandate the use of a particular normalization form at this time. A subsequent minor version of the NFSv4 protocol might specify a particular normalization form. Therefore, the server and client can expect that they may receive unnormalized characters within protocol requests and responses. If the operating environment requires normalization, then the implementation will need to normalize the various UTF-8 encoded strings within the protocol before presenting the information to an application (at the client) or local file system (at the server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4プロトコルは、この時点で特定の正規化形式を使用することを強制しません。 NFSv4プロトコルの次のマイナーバージョンは、特定の正規化形式を指定するかもしれません。そのため、サーバとクライアントは、彼らがプロトコルの要求と応答の中に正規化されていない文字を受け取ることができることを期待することができます。動作環境が正常化が必要な場合は、その実装は、（サーバーで）（クライアントで）アプリケーションまたはローカルファイルシステムに情報を提示する前に、プロトコル内の様々なUTF-8エンコードされた文字列を正規化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Server implementations MAY normalize filenames to conform to a particular normalization form before using the resulting string when looking up or creating a file. Servers MAY also perform normalization-insensitive string comparisons without modifying the names to match a particular normalization form. Except in cases in which component names are excluded from normalization-related handling because they are not valid UTF-8 strings, a server MUST make the same choice (as to whether to normalize or not, the target form of normalization, and whether to do normalization-insensitive string comparisons) in the same way for all accesses to a particular file system. Servers SHOULD NOT reject a filename because it does not conform to a particular normalization form, as this may deny access to clients that use a different normalization form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ実装は、見上げたり、ファイルを作成するときに、結果の文字列を使用する前に、特定の正規形に適合するようにファイル名を正規化してもよいです。サーバは、特定の正規化形式に一致するように名前を変更せずに正規化非感受性文字列比較を実行することができます。彼らは有効なUTF-8文字列ではありませんので、コンポーネント名は正規化関連の処理から除外されている場合を除いて、サーバが正常化するかしないかどうかの同じ選択（、正規のターゲットフォームを作成し、どうするかしなければなりません正規と小文字を区別しない文字列比較）すべてについて同じ方法では、特定のファイルシステムにアクセスします。それは、特定の正規化形式に準拠していないので、これは別の正規化形式を使用するクライアントへのアクセスを拒否することができるようサーバーは、ファイル名を拒否すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6. Types with Processing Defined by Other Internet Areas
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.6。その他のインターネットエリアによって定義された処理とタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two types of strings that NFSv4 deals with that are based on domain names. Processing of such strings is defined by other Internet standards, and hence the processing behavior for such strings should be consistent across all server operating systems and server file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のお得な情報をドメイン名に基づいている文字列の2種類があります。このような文字列の処理は、他のインターネット標準で定義され、したがって、そのような文字列の処理動作では、すべてのサーバーオペレーティングシステムおよびサーバーのファイル・システム全体で一貫している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらは以下の通りです：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Server names as they appear in the fs_locations attribute. Note that for most purposes, such server names will only be sent by the server to the client. The exception is the use of the fs_locations attribute in a VERIFY or NVERIFY operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバ名、それらはfs_位置の属性に表示されます。ほとんどの目的のために、そのようなサーバー名のみをサーバからクライアントに送信されることに注意してください。例外はfs_位置の使用が確認またはNVERIFY操作属性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Principal suffixes that are used to denote sets of users and groups, and are in the form of domain names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザおよびグループのセットを示すために使用され、ドメイン名の形態にされている主なサフィックスO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The general rules for handling all of these domain-related strings are similar and independent of the role of the sender or receiver as client or server, although the consequences of failure to obey these rules may be different for client or server. The server can report errors when it is sent invalid strings, whereas the client will simply ignore invalid string or use a default value in their place.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのルールに従うの失敗の結果は、クライアントまたはサーバごとに異なるかもしれないが、これらのドメインに関連するすべての文字列を処理するための一般的な規則は、類似しており、クライアントやサーバなどの送信者または受信者の役割とは無関係です。クライアントは、単に無効な文字列を無視するか、その場所にデフォルト値を使用するのに対し、それは、無効な文字列を送信すると、サーバーはエラーを報告することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The string sent SHOULD be in the form of one or more U-labels as defined by [RFC5890]. If that is impractical, it can instead be in the form of one or more LDH labels [RFC5890] or a UTF-8 domain name that contains labels that are not properly formatted U-labels. The receiver needs to be able to accept domain and server names in any of the formats allowed. The server MUST reject, using the error NFS4ERR_INVAL, a string that is not valid UTF-8, or that contains an ASCII label that is not a valid LDH label, or that contains an XN-label (begins with &#34;xn--&#34;) for which the characters after &#34;xn--&#34; are not valid output of the Punycode algorithm [RFC3492].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5890]で定義されるように送信された文字列は、一つ以上のU-ラベルの形態であるべきです。それは非現実的である場合、それは代わりに、一つ以上のLDHラベル[RFC5890]または適切U-ラベルをフォーマットされていないラベルを含むUTF-8のドメイン名の形態であり得ます。受信機は、許可のいずれかの形式でドメインとサーバー名を受け入れることができるようにする必要があります。サーバーがエラーNFS4ERR_INVAL、有効なUTF-8でない文字列を使用して、拒絶しなければなりません、またはそれが有効なLDHラベルではありませんASCIIラベルが含まれている、またはそれはXN-ラベルが含まれています（「xn--」で始まります）そのため、「xn--」の後の文字はピュニコードアルゴリズム[RFC3492]の有効な出力ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a domain string is part of id@domain or group@domain, there are two possible approaches:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドメインの文字列がID @ドメインまたはグループ@ドメインの一部である場合には、2つの可能性のあるアプローチがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. The server treats the domain string as a series of U-labels. In cases where the domain string is a series of A-labels or Non-Reserved LDH (NR-LDH) labels, it converts them to U-labels using the Punycode algorithm [RFC3492]. In cases where the domain string is a series of other sorts of LDH labels, the server can use the ToUnicode function defined in [RFC3490] to convert the string to a series of labels that generally conform to the U-label syntax. In cases where the domain string is a UTF-8 string that contains non-U-labels, the server can attempt to use the ToASCII function defined in [RFC3490] and then the ToUnicode function on the string to convert it to a series of labels that generally conform to the U-label syntax. As a result, the domain string returned within a user id on a GETATTR may not match that sent when the user id is set using SETATTR, although when this happens, the domain will be in the form that generally conforms to the U-label syntax.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.サーバーは、U-一連のラベルとしてドメイン文字列を扱います。ドメイン文字列は、ラベルまたは非予約LDH（NR-LDH）のラベルの系列である場合には、ピュニコードアルゴリズム[RFC3492]を使用して、U-ラベルに変換します。ドメイン列がLDHラベルの他の種類のシリーズである場合には、サーバは、一般的にUラベル構文に準拠したラベルの一連の文字列を変換するために[RFC3490]で定義されたのToUnicode関数を使用することができます。ドメイン文字列が非U-ラベルを含むUTF-8文字列である場合には、サーバは、ラベルの系列に変換する文字列の[RFC3490]で定義されたもしToASCII機能し、その後のToUnicode関数を使用することを試みることができますそれは、一般的にU-ラベルの構文に準拠しています。結果として、ドメインの文字列がユーザIDがSETATTRを用いて設定されているときにこれが発生した場合、ドメインは、一般的にUラベル構文に準拠した形態であろうが、そのて送信と一致しない場合がありGETATTRにユーザID以内に返さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. The server does not attempt to treat the domain string as a series of U-labels; specifically, it does not map a domain string that is not a U-label into a U-label using the methods described above. As a result, the domain string returned on a GETATTR of the user id MUST be the same as that used when setting the user id by the SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.サーバーは、U-一連のラベルとしてドメイン文字列を処理しようとしません。具体的には、上述の方法を用いて、U-ラベルにUラベルはないドメイン文字列をマッピングしません。結果として、ユーザIDのGETATTRに戻さドメインストリングはSETATTRによってユーザIDを設定する際に用いたものと同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server SHOULD use the first method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、最初のメソッドを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For VERIFY and NVERIFY, additional string processing requirements apply to verification of the owner and owner_group attributes; see Section 5.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ベリファイとNVERIFY、追加の文字列処理の要件は、所有者の属性とowner_group検証に適用されます。 5.9節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7. Errors Related to UTF-8
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.7。 UTF-8に関連するエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where the client sends an invalid UTF-8 string, the server MAY return an NFS4ERR_INVAL error. This includes cases in which inappropriate prefixes are detected and where the count includes trailing bytes that do not constitute a full Universal Multiple-Octet Coded Character Set (UCS) character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが無効なUTF-8文字列を送信する場合、サーバはNFS4ERR_INVALエラーを返すことがあります。これは、不適切なプレフィックスが検出された場合を含み、カウントフルユニバーサル複数オクテットコード化文字セット（UCS）文字を構成しないバイト末尾含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Requirements for server handling of component names that are not valid UTF-8, when a server does not return NFS4ERR_INVAL in response to receiving them, are described in Section 12.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UTF-8、サーバーはそれらの受信に応答してNFS4ERR_INVALを返さない、12.8項で説明されている有効でないコンポーネント名のサーバー処理のための要件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where the string supplied by the client is not rejected with NFS4ERR_INVAL but contains characters that are not supported by the server as a value for that string (e.g., names containing slashes, or characters that do not fit into 16 bits when converted from UTF-8 to a Unicode codepoint), the server should return an NFS4ERR_BADCHAR error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントによって提供される文字列はNFS4ERR_INVALで拒否が、その文字列の値として、サーバでサポートされていない文字（スラッシュを含むたとえば、名前、またはUTF-8から変換されたときに16ビットに収まらない文字が含まれていない場合Unicodeのコードポイント）に、サーバーはNFS4ERR_BADCHARエラーを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where a UTF-8 string is used as a filename, and the file system, while supporting all of the characters within the name, does not allow that particular name to be used, the server should return the error NFS4ERR_BADNAME. This includes such situations as file system prohibitions of &#34;.&#34; and &#34;..&#34; as filenames for certain operations, and similar constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前内の文字のすべてをサポートしながら、UTF-8文字列は、ファイル名、およびファイルシステムとして使用される場合、サーバーはエラーNFS4ERR_BADNAMEを返す必要があり、その特定の名前を使用することはできません。これは、ファイルシステムの禁止などの状況を含んでいます「」そして、「..」特定の操作のためのファイル名、および同様の制約など。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
12.8. Servers That Accept File Component Names That Are Not Valid UTF-8 Strings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
12.8。有効なUTF-8文字列されていないファイルのコンポーネント名を受け入れるサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As stated previously, servers MAY accept, on all or on some subset of the physical file systems exported, component names that are not valid UTF-8 strings. A typical pattern is for a server to use UTF-8-unaware physical file systems that treat component names as uninterpreted strings of bytes, rather than having any awareness of the character set being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
先に述べたように、サーバは、すべての上またはエクスポート物理ファイル・システムのいくつかのサブセットに、有効なUTF-8文字列でないコンポーネント名を受け入れることができます。典型的なパターンではなく、使用されている文字セットのいずれかの意識を持つよりも、バイトの未解釈の文字列としてコンポーネント名を扱うUTF-8非対応の物理ファイル・システムを使用するサーバー用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Such servers SHOULD NOT change the stored representation of component names from those received on the wire and SHOULD use an octet-by-octet comparison of component name strings to determine equivalence (as opposed to any broader notion of string comparison). This is because the server has no knowledge of the character encoding being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのようなサーバは、ワイヤ上で受信されたものからコンポーネント名の格納された表現を変更してはならず、（文字列の比較のいずれかより広い概念とは対照的に）同等性を決定するために、コンポーネント名文字列のオクテットによってオクテット比較を使用すべきです。サーバが使用されている文字エンコーディングの知識を持たないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nonetheless, when such a server uses a broader notion of string equivalence than what is recommended in the preceding paragraph, the following considerations apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それにもかかわらず、そのようなサーバーは、前項で推奨されているものよりも、文字列の等価性のより広範な概念を使用する場合、次の考慮事項が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Outside of 7-bit ASCII, string processing that changes string contents is usually specific to a character set and hence is generally unsafe when the character set is unknown. This processing could change the filename in an unexpected fashion, rendering the file inaccessible to the application or client that created or renamed the file and to others expecting the original filename. Hence, such processing should not be performed, because doing so is likely to result in incorrect string modification or aliasing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O 7ビットのASCII文字列の内容を変更する文字列処理の外側は文字セットに通常特異的であり、したがって、文字セットが不明である場合、一般的に安全ではありません。この処理は、ファイルを作成したり、名前を変更したアプリケーションやクライアントに、元のファイル名を期待して他の人にアクセスできないファイルをレンダリングする、予想外の方法でファイル名を変更することができます。そうすることは正しくない文字列の変更やエイリアシングが発生する可能性があるのでそこで、このような処理は、実行されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Unicode normalization is particularly dangerous, as such processing assumes that the string is UTF-8. When that assumption is false because a different character set was used to create the filename, normalization may corrupt the filename with respect to that character set, rendering the file inaccessible to the application that created it and others expecting the original filename. Hence, Unicode normalization SHOULD NOT be performed, because it may cause incorrect string modification or aliasing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような処理は、文字列がUTF-8であると仮定としてO Unicodeの正規化は、特に危険です。異なる文字セットは、ファイル名を作成するために使用されたため、その仮定が偽である場合には、正規化が破損する可能性があり、その文字セットに関して、元のファイル名を期待して、他を作成したアプリケーションにアクセスできないファイルをレンダリングすると、ファイル名。それは間違った文字列の変更やエイリアシングを引き起こす可能性があるため、したがって、Unicodeの正規化は、実行するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the above recommendations are not followed, the resulting string modification and aliasing can lead to both false negatives and false positives, depending on the strings in question, which can result in security issues such as elevation of privilege and denial of service (see [RFC6943] for further discussion).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の勧告に従わないときは、結果の文字列の修正とエイリアシングは、このような特権の昇格およびサービス拒否などのセキュリティ上の問題をもたらすことが問題になっている文字列に応じて、偽陰性および偽陽性の両方につながることができます（[RFC6943を参照してください]さらなる議論のために）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Error Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.エラー値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS error numbers are assigned to failed operations within a COMPOUND or CB_COMPOUND request. A COMPOUND request contains a number of NFS operations that have their results encoded in sequence in a COMPOUND reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply, and the COMPOUND request will be terminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSエラー番号は、化合物またはCB_COMPOUND要求内で失敗した操作に割り当てられています。複合要求は、それらの結果は、化合物の応答のシーケンスでエンコード有するNFS操作の数を含んでいます。成功した操作の結果は、動作の符号化された結果に続いNFS4_OK状態で構成されます。 NFS操作が失敗した場合、エラー状態は、返信に入力されますと、COMPOUND要求は終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Error Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1。エラーの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +-----------------------------+--------+-------------------+
       | Error                       | Number | Description       |
       +-----------------------------+--------+-------------------+
       | NFS4_OK                     | 0      | Section 13.1.3.1  |
       | NFS4ERR_ACCESS              | 13     | Section 13.1.6.1  |
       | NFS4ERR_ADMIN_REVOKED       | 10047  | Section 13.1.5.1  |
       | NFS4ERR_ATTRNOTSUPP         | 10032  | Section 13.1.11.1 |
       | NFS4ERR_BADCHAR             | 10040  | Section 13.1.7.1  |
       | NFS4ERR_BADHANDLE           | 10001  | Section 13.1.2.1  |
       | NFS4ERR_BADNAME             | 10041  | Section 13.1.7.2  |
       | NFS4ERR_BADOWNER            | 10039  | Section 13.1.11.2 |
       | NFS4ERR_BADTYPE             | 10007  | Section 13.1.4.1  |
       | NFS4ERR_BADXDR              | 10036  | Section 13.1.1.1  |
       | NFS4ERR_BAD_COOKIE          | 10003  | Section 13.1.1.2  |
       | NFS4ERR_BAD_RANGE           | 10042  | Section 13.1.8.1  |
       | NFS4ERR_BAD_SEQID           | 10026  | Section 13.1.8.2  |
       | NFS4ERR_BAD_STATEID         | 10025  | Section 13.1.5.2  |
       | NFS4ERR_CB_PATH_DOWN        | 10048  | Section 13.1.12.1 |
       | NFS4ERR_CLID_INUSE          | 10017  | Section 13.1.10.1 |
       | NFS4ERR_DEADLOCK            | 10045  | Section 13.1.8.3  |
       | NFS4ERR_DELAY               | 10008  | Section 13.1.1.3  |
       | NFS4ERR_DENIED              | 10010  | Section 13.1.8.4  |
       | NFS4ERR_DQUOT               | 69     | Section 13.1.4.2  |
       | NFS4ERR_EXIST               | 17     | Section 13.1.4.3  |
       | NFS4ERR_EXPIRED             | 10011  | Section 13.1.5.3  |
       | NFS4ERR_FBIG                | 27     | Section 13.1.4.4  |
       | NFS4ERR_FHEXPIRED           | 10014  | Section 13.1.2.2  |
       | NFS4ERR_FILE_OPEN           | 10046  | Section 13.1.4.5  |
       | NFS4ERR_GRACE               | 10013  | Section 13.1.9.1  |
       | NFS4ERR_INVAL               | 22     | Section 13.1.1.4  |
       | NFS4ERR_IO                  | 5      | Section 13.1.4.6  |
       | NFS4ERR_ISDIR               | 21     | Section 13.1.2.3  |
       | NFS4ERR_LEASE_MOVED         | 10031  | Section 13.1.5.4  |
       | NFS4ERR_LOCKED              | 10012  | Section 13.1.8.5  |
       | NFS4ERR_LOCKS_HELD          | 10037  | Section 13.1.8.6  |
       | NFS4ERR_LOCK_NOTSUPP        | 10043  | Section 13.1.8.7  |
       | NFS4ERR_LOCK_RANGE          | 10028  | Section 13.1.8.8  |
       | NFS4ERR_MINOR_VERS_MISMATCH | 10021  | Section 13.1.3.2  |
       | NFS4ERR_MLINK               | 31     | Section 13.1.4.7  |
       | NFS4ERR_MOVED               | 10019  | Section 13.1.2.4  |
       | NFS4ERR_NAMETOOLONG         | 63     | Section 13.1.7.3  |
       | NFS4ERR_NOENT               | 2      | Section 13.1.4.8  |
       | NFS4ERR_NOFILEHANDLE        | 10020  | Section 13.1.2.5  |
       | NFS4ERR_NOSPC               | 28     | Section 13.1.4.9  |
       | NFS4ERR_NOTDIR              | 20     | Section 13.1.2.6  |
       | NFS4ERR_NOTEMPTY            | 66     | Section 13.1.4.10 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       | NFS4ERR_NOTSUPP             | 10004  | Section 13.1.1.5  |
       | NFS4ERR_NOT_SAME            | 10027  | Section 13.1.11.3 |
       | NFS4ERR_NO_GRACE            | 10033  | Section 13.1.9.2  |
       | NFS4ERR_NXIO                | 6      | Section 13.1.4.11 |
       | NFS4ERR_OLD_STATEID         | 10024  | Section 13.1.5.5  |
       | NFS4ERR_OPENMODE            | 10038  | Section 13.1.8.9  |
       | NFS4ERR_OP_ILLEGAL          | 10044  | Section 13.1.3.3  |
       | NFS4ERR_PERM                | 1      | Section 13.1.6.2  |
       | NFS4ERR_RECLAIM_BAD         | 10034  | Section 13.1.9.3  |
       | NFS4ERR_RECLAIM_CONFLICT    | 10035  | Section 13.1.9.4  |
       | NFS4ERR_RESOURCE            | 10018  | Section 13.1.3.4  |
       | NFS4ERR_RESTOREFH           | 10030  | Section 13.1.4.12 |
       | NFS4ERR_ROFS                | 30     | Section 13.1.4.13 |
       | NFS4ERR_SAME                | 10009  | Section 13.1.11.4 |
       | NFS4ERR_SERVERFAULT         | 10006  | Section 13.1.1.6  |
       | NFS4ERR_SHARE_DENIED        | 10015  | Section 13.1.8.10 |
       | NFS4ERR_STALE               | 70     | Section 13.1.2.7  |
       | NFS4ERR_STALE_CLIENTID      | 10022  | Section 13.1.10.2 |
       | NFS4ERR_STALE_STATEID       | 10023  | Section 13.1.5.6  |
       | NFS4ERR_SYMLINK             | 10029  | Section 13.1.2.8  |
       | NFS4ERR_TOOSMALL            | 10005  | Section 13.1.1.7  |
       | NFS4ERR_WRONGSEC            | 10016  | Section 13.1.6.3  |
       | NFS4ERR_XDEV                | 18     | Section 13.1.4.14 |
       +-----------------------------+--------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 6: Protocol Error Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表6：プロトコルエラーの定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1. General Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1。一般的なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section deals with errors that are applicable to a broad set of different purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、異なる目的の広範なセットに適用されるエラーを扱っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.1. NFS4ERR_BADXDR (Error Code 10036)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.1。 NFS4ERR_BADXDR（エラーコード10036）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The arguments for this operation do not match those specified in the XDR definition. This includes situations in which the request ends before all the arguments have been seen. Note that this error applies when fixed enumerations (these include booleans) have a value within the input stream that is not valid for the enum. A replier may pre-parse all operations for a COMPOUND procedure before doing any operation execution and return RPC-level XDR errors in that case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作の引数は、XDR定義に指定されたものと一致しません。これは、すべての引数が見られている前に、要求が終了する状況が含まれます。固定の列挙は、（これらはブール値を含む）に列挙型に対して有効ではありません入力ストリーム内の値を持っている場合、このエラーが適用されることに注意してください。リプライヤは、任意の操作の実行を行う前に、COMPOUND手順のためのすべての操作を事前に解析し、その場合のRPCレベルのXDRのエラーを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.2. NFS4ERR_BAD_COOKIE (Error Code 10003)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.2。 NFS4ERR_BAD_COOKIE（エラーコード10003）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This error is used for operations that provide a set of information indexed by some quantity provided by the client or cookie sent by the server for an earlier invocation. Where the value cannot be used for its intended purpose, this error results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このエラーは、以前の呼び出しのためにサーバーによって送信されたクライアントまたはクッキーによって提供されるいくつかの量によってインデックス付け情報のセットを提供する操作に使用されます。値がその意図する目的のために使用することができない場合は、このエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.3. NFS4ERR_DELAY (Error Code 10008)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.3。 NFS4ERR_DELAY（エラーコード10008）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For any of a number of reasons, the replier could not process this operation in what was deemed a reasonable time. The client should wait and then try the request with a new RPC transaction ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの理由のいずれかの場合、リプライヤは、合理的な時間とみなされたもので、この操作を処理できませんでした。クライアントが待機してから、新しいRPCのトランザクションIDとリクエストを試してみてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following are two examples of what might lead to this situation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下では、このような状況につながるかもしれないものの2つの例です：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A server that supports hierarchical storage receives a request to process a file that had been migrated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O階層型ストレージをサポートするサーバーが移行されたファイルを処理するための要求を受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An operation requires a delegation recall to proceed, and waiting for this delegation recall makes processing this request in a timely fashion impossible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O操作を続行するには、委任のリコールを必要とし、この委任のリコールを待っていることは不可能タイムリーに、この要求を処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.4. NFS4ERR_INVAL (Error Code 22)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.4。 NFS4ERR_INVAL（エラーコード22）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The arguments for this operation are not valid for some reason, even though they do match those specified in the XDR definition for the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作の引数は、彼らが要求のためのXDR定義に指定されたものと一致して行うにもかかわらず、何らかの理由で有効ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.5. NFS4ERR_NOTSUPP (Error Code 10004)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.5。 NFS4ERR_NOTSUPP（エラーコード10004）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The operation is not supported, either because the operation is an OPTIONAL one and is not supported by this server or because the operation MUST NOT be implemented in the current minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作はオプション1であり、このサーバーまたは操作は、現在のマイナーバージョンで実装されてはならないので、サポートされていないため、操作はどちらか、サポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.6. NFS4ERR_SERVERFAULT (Error Code 10006)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.6。 NFS4ERR_SERVERFAULT（エラーコード10006）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An error that does not map to any of the specific legal NFSv4 protocol error values occurred on the server. The client should translate this into an appropriate error. UNIX clients may choose to translate this to EIO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定の法的なNFSv4プロトコルエラー値のいずれかにマップされないサーバーでエラーが発生しました。クライアントは、適切なエラーにこれを変換する必要があります。 UNIXクライアントがEIOにこれを翻訳することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.7. NFS4ERR_TOOSMALL (Error Code 10005)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.1.7。 NFS4ERR_TOOSMALL（エラーコード10005）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This error is used where an operation returns a variable amount of data, with a limit specified by the client. Where the data returned cannot be fitted within the limit specified by the client, this error results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
動作は、クライアントによって指定された制限と、データの可変量を返す場合、このエラーは、使用されます。どこに返されたデータは、このエラーの結果は、クライアントによって指定された制限内に装着することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2. Filehandle Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2。ファイルハンドルエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These errors deal with the situation in which the current or saved filehandle, or the filehandle passed to PUTFH intended to become the current filehandle, is invalid in some way. This includes situations in which the filehandle is a valid filehandle in general but is not of the appropriate object type for the current operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのエラーは、現在または保存されたファイルハンドルの状況に対処する、またはPUTFHに渡されたファイルハンドルは、現在のファイルハンドルになることを意図し、何らかの方法で無効です。これは、ファイルハンドルは、一般的に有効でファイルハンドルであるが、現在の操作のための適切なオブジェクトタイプのされていない状況を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where the error description indicates a problem with the current or saved filehandle, it is to be understood that filehandles are only checked for the condition if they are implicit arguments of the operation in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エラーの説明は、現在または保存されたファイルハンドルに問題があることを示す場合、それは彼らが問題の操作の暗黙の引数であればファイルハンドルが唯一の条件をチェックしていることを理解すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.1. NFS4ERR_BADHANDLE (Error Code 10001)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.1。 NFS4ERR_BADHANDLE（エラーコード10001）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This error is generated for an illegal NFS filehandle for the current server. The current filehandle failed internal consistency checks. Once accepted as valid (by PUTFH), no subsequent status change can cause the filehandle to generate this error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このエラーは、現在のサーバの違法なNFSファイルハンドルのために生成されます。現在のファイルハンドルは、内部整合性チェックに失敗しました。一度（PUTFHによって）有効なものとして受け入れられ、後続のステータス変更は、ファイルハンドルは、このエラーを発生させないことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.2. NFS4ERR_FHEXPIRED (Error Code 10014)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.2。 NFS4ERR_FHEXPIRED（エラーコード10014）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A current or saved filehandle that is an argument to the current operation is volatile and has expired at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在の操作の引数で、現在または保存されたファイルハンドルが揮発性であり、サーバーで有効期限が切れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.3. NFS4ERR_ISDIR (Error Code 21)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.3。 NFS4ERR_ISDIR（エラーコード21）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current or saved filehandle designates a directory when the current operation does not allow a directory to be accepted as the target of this operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在または保存されたファイルハンドルは、現在の操作は、ディレクトリは、この操作の対象として受け入れられることはできませんディレクトリを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.4. NFS4ERR_MOVED (Error Code 10019)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.4。 NFS4ERR_MOVED（エラーコード10019）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The file system that contains the current filehandle object is not present at the server. It may have been relocated or migrated to another server, or may have never been present. The client may obtain the new file system location by obtaining the &#34;fs_locations&#34; attribute for the current filehandle. For further discussion, refer to Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルオブジェクトを含むファイルシステムがサーバーに存在しません。これは、移転したり、別のサーバに移行、または存在ではなかったかもしれないされている可能性があります。クライアントは、現在のファイルハンドルのための「fs_位置」属性を取得することによって、新しいファイルシステムの場所を得ることができます。さらなる議論に関しては、セクション8を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.5. NFS4ERR_NOFILEHANDLE (Error Code 10020)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.5。 NFS4ERR_NOFILEHANDLE（エラーコード10020）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The logical current or saved filehandle value is required by the current operation and is not set. This may be a result of a malformed COMPOUND operation (i.e., no PUTFH or PUTROOTFH before an operation that requires that the current filehandle be set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
論理現在または保存されたファイルハンドルの値は、現在の操作で必要とされると設定されていません。これは、（現在のファイルハンドルが設定されている必要があり、操作の前に、すなわち、無PUTFH又はPUTROOTFH）不正な複合操作の結果であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.6. NFS4ERR_NOTDIR (Error Code 20)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.6。 NFS4ERR_NOTDIR（エラーコード20）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current (or saved) filehandle designates an object that is not a directory for an operation in which a directory is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在の（または保存）ファイルハンドルは、ディレクトリが必要とされる動作のディレクトリではないオブジェクトを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.7. NFS4ERR_STALE (Error Code 70)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.7。 NFS4ERR_STALE（エラーコード70）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current or saved filehandle value designating an argument to the current operation is invalid. The file system object referred to by that filehandle no longer exists, or access to it has been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在の操作に引数を指定し、現在または保存されたファイルハンドルの値が無効です。そのファイルハンドルによって参照されるファイル・システム・オブジェクトは、もはや存在しない、またはそれへのアクセスが取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.8. NFS4ERR_SYMLINK (Error Code 10029)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.2.8。 NFS4ERR_SYMLINK（エラーコード10029）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current filehandle designates a symbolic link when the current operation does not allow a symbolic link as the target.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルは、現在の操作が対象としてシンボリックリンクを許可していないシンボリックリンクを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3. Compound Structure Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3。複合構造のエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section deals with errors that relate to the overall structure of a COMPOUND request (by which we mean to include both COMPOUND and CB_COMPOUND), rather than to particular operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションではなく、特定の操作に比べて、（我々は、化合物とCB_COMPOUND両方を含むことを意味していることにより）複合要求の全体的な構造に関するエラーを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are a number of basic constraints on the operations that may appear in a COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND要求に表示される可能性のある操作上の基本的な制約がいくつかあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.1. NFS_OK (Error Code 0)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.1。 NFS_OK（エラーコード0）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS_OK indicates that the operation completed successfully, in that all of the constituent operations completed without error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS_OKはエラーなしで完了した構成の操作の全てにおいて、操作が正常に完了したことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.2. NFS4ERR_MINOR_VERS_MISMATCH (Error Code 10021)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.2。 NFS4ERR_MINOR_VERS_MISMATCH（エラーコード10021）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The minor version specified is not one that the current listener supports. This value is returned in the overall status for the COMPOUND procedure but is not associated with a specific operation, since the results must specify a result count of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定されたマイナーバージョンは、現在のリスナーがサポートするものではありません。この値は、COMPOUND手順の全体的な状態で返されるが、結果がゼロの結果数を指定する必要があるため、特定の操作に関連付けられていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.3. NFS4ERR_OP_ILLEGAL (Error Code 10044)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.3。 NFS4ERR_OP_ILLEGAL（エラーコード10044）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The operation code is not a valid one for the current COMPOUND procedure. The opcode in the result stream matched with this error is the ILLEGAL value, although the value that appears in the request stream may be different. Where an illegal value appears and the replier pre-parses all operations for a COMPOUND procedure before doing any operation execution, an RPC-level XDR error may be returned in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作コードは、現在のCOMPOUND手順のための有効なものではありません。要求ストリームに表示される値が異なっていてもよいが、この誤差と一致する結果ストリームにおけるオペコードは、不正な値です。不正な値が表示され、リプライヤは、任意の操作の実行を行う前に、COMPOUND手順のためのすべての操作を事前に解析した場合、RPCレベルのXDRエラーは、この場合に返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.4. NFS4ERR_RESOURCE (Error Code 10018)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.3.4。 NFS4ERR_RESOURCE（エラーコード10018）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the processing of the COMPOUND procedure, the server may exhaust available resources and cannot continue processing operations within the COMPOUND procedure. This error will be returned from the server in those instances of resource exhaustion related to the processing of the COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順の処理のために、サーバは、利用可能なリソースを使い果たしてもよいし、化合物プロシージャ内の処理動作を継続することができません。このエラーはCOMPOUND手順の処理に関連するリソースの枯渇のこれらの例では、サーバから返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4. File System Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4。ファイルシステムエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These errors describe situations that occurred in the underlying file system implementation rather than in the protocol or any NFSv4.x feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのエラーは、基本的なファイルシステムの実装ではなく、プロトコルまたは任意のNFSv4.x機能で発生した状況を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.1. NFS4ERR_BADTYPE (Error Code 10007)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.1。 NFS4ERR_BADTYPE（エラーコード10007）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An attempt was made to create an object with an inappropriate type specified to CREATE. This may be because the type is undefined; because it is a type not supported by the server; or because it is a type for which create is not intended, such as a regular file or named attribute, for which OPEN is used to do the file creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
試みは、CREATEするために指定された不適切なタイプのオブジェクトを作成しました。タイプが定義されていないためと考えられます。それは、サーバによってサポートされていないタイプですので、またはそれが作成するが、そのようなOPENは、ファイルの作成を行うために使用されている通常のファイルまたは名前付き属性、として、意図されていないタイプですので。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.2. NFS4ERR_DQUOT (Error Code 69)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.2。 NFS4ERR_DQUOT（エラーコード69）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The resource (quota) hard limit has been exceeded. The user&#39;s resource limit on the server has been exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リソース（クォータ）ハード制限を超えました。サーバー上のユーザーのリソース制限を超えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.3. NFS4ERR_EXIST (Error Code 17)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.3。 NFS4ERR_EXIST（エラーコード17）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A file system object of the specified target name (when creating, renaming, or linking) already exists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定されたターゲット名のファイル・システム・オブジェクト（作成時に、名前変更、またはリンク）がすでに存在しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.4. NFS4ERR_FBIG (Error Code 27)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.4。 NFS4ERR_FBIG（エラーコード27）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The file system object is too large. The operation would have caused a file system object to grow beyond the server&#39;s limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイル・システム・オブジェクトが大きすぎます。操作は、ファイルシステムオブジェクトがサーバーの制限を超えて成長させただろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.5. NFS4ERR_FILE_OPEN (Error Code 10046)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.5。 NFS4ERR_FILE_OPEN（エラーコード10046）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The operation is not allowed because a file system object involved in the operation is currently open. Servers may, but are not required to, disallow linking to, removing, or renaming open file system objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作に関連するファイル・システム・オブジェクトが現在開いているため、操作は許可されていません。サーバは、しかし、は、へのリンクを削除するか、開いているファイルシステムオブジェクトの名前を変更できないように要求されないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.6. NFS4ERR_IO (Error Code 5)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.6。 NFS4ERR_IO（エラーコード5）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This indicates that an I/O error occurred for which the file system was unable to provide recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、ファイルシステムが回復を提供することができませんでしたそのためにI / Oエラーが発生したことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.7. NFS4ERR_MLINK (Error Code 31)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.7。 NFS4ERR_MLINK（エラーコード31）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The request would have caused the server&#39;s limit for the number of hard links a file system object may have to be exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求は、ファイルシステムオブジェクトを超えなければならないかもしれないハードリンクの数に対するサーバーの制限を引き起こしているだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.8. NFS4ERR_NOENT (Error Code 2)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.8。 NFS4ERR_NOENT（エラーコード2）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This indicates no such file or directory. The file system object referenced by the name specified does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、そのようなファイルやディレクトリを示していません。指定された名前で参照されるファイル・システム・オブジェクトが存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.9. NFS4ERR_NOSPC (Error Code 28)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.9。 NFS4ERR_NOSPC（エラーコード28）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This indicates no space left on the device. The operation would have caused the server&#39;s file system to exceed its limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、デバイス上に残されたスペースを示していません。操作は、その限界を超えるサーバのファイルシステムを引き起こしているだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.10. NFS4ERR_NOTEMPTY (Error Code 66)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.10。 NFS4ERR_NOTEMPTY（エラーコード66）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An attempt was made to remove a directory that was not empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
試みは、空ではなかったディレクトリを削除しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.11. NFS4ERR_NXIO (Error Code 6)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.11。 NFS4ERR_NXIO（エラーコード6）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This indicates an I/O error. There is no such device or address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、I / Oエラーを示します。そのようなデバイスまたはアドレスはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.12. NFS4ERR_RESTOREFH (Error Code 10030)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.12。 NFS4ERR_RESTOREFH（エラーコード10030）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The RESTOREFH operation does not have a saved filehandle (identified by SAVEFH) to operate upon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RESTOREFH操作は時に動作するように（SAVEFHによって識別される）保存されたファイルハンドルを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.13. NFS4ERR_ROFS (Error Code 30)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.13。 NFS4ERR_ROFS（エラーコード30）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This indicates a read-only file system. A modifying operation was attempted on a read-only file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは読み取り専用のファイルシステムを示します。変更操作は、読み取り専用ファイルシステム上で実行しようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.14. NFS4ERR_XDEV (Error Code 18)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.4.14。 NFS4ERR_XDEV（エラーコード18）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This indicates an attempt to do an operation, such as linking, that inappropriately crosses a boundary. For example, this may be due to a boundary between:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、不適切境界を越えることは、そのようなリンクなど、操作を行うための試みを示しています。例えば、これは、境界に起因し得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o File systems (where the fsids are different).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（fsidsが異なる）Oファイルシステム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Different named attribute directories, or between a named attribute directory and an ordinary directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の名前付き属性ディレクトリO、または名前付き属性ディレクトリと通常のディレクトリの間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Regions of a file system that the file system implementation treats as separate (for example, for space accounting purposes), and where cross-connection between the regions is not allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムの実装の扱いは別として（例えば、空間会計目的のために）、および領域間の相互接続が許可されていないファイルシステムのO領域。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5. State Management Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5。状態管理エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These errors indicate problems with the stateid (or one of the stateids) passed to a given operation. This includes situations in which the stateid is invalid, as well as situations in which the stateid is valid but designates revoked locking state. Depending on the operation, the stateid, when valid, may designate opens, byte-range locks, or file delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのエラーは、のstateid（またはのstateidsの1つ）に問題があることを示す所定の操作に渡されます。これは、のstateidが無効である状況、並びにのstateidが有効であるが、状態をロック失効指示する状況を含みます。操作に応じてのstateid、ときに有効な、指定することができるが、バイト範囲ロック、またはファイルの委任を開きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.1. NFS4ERR_ADMIN_REVOKED (Error Code 10047)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.1。 NFS4ERR_ADMIN_REVOKED（エラーコード10047）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A stateid designates locking state of any type that has been revoked due to administrative interaction, possibly while the lease is valid, or because a delegation was revoked because of failure to return it, while the lease was valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidは、リースが有効である可能性が、原因行政の相互作用に取り消された任意のタイプの状態をロックする指定、またはリースが有効であった代表団は、理由はそれを返すために障害の取り消されたので。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.2. NFS4ERR_BAD_STATEID (Error Code 10025)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.2。 NFS4ERR_BAD_STATEID（エラーコード10025）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A stateid generated by the current server instance was used that either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のサーバインスタンスによって生成されたstateidは、いずれかのことを使用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Does not designate any locking state (either current or superseded) for a current (state-owner, file) pair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
oは電流（状態所有者、ファイル）ペアのための任意のロック状態（電流または置き換えのいずれか）を指定しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Designates locking state that was freed after lease expiration but without any lease cancellation, as may happen in the handling of &#34;courtesy locks&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「礼儀ロック」の取り扱いに起こるかもしれないとoは、リース満了後であるが、任意のリース解約せずに解放されたロック状態を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.3. NFS4ERR_EXPIRED (Error Code 10011)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.3。 NFS4ERR_EXPIRED（エラーコード10011）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A stateid or clientid designates locking state of any type that has been revoked or released due to cancellation of the client&#39;s lease, either immediately upon lease expiration, or following a later request for a conflicting lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidかのClientIDはどちらかすぐにリース満了時に、原因クライアントのリースの解約に取り消さかリリースされている任意のタイプの状態をロックする、または競合するロックの後の要求、次の指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.4. NFS4ERR_LEASE_MOVED (Error Code 10031)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.4。 NFS4ERR_LEASE_MOVED（エラーコード10031）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A lease being renewed is associated with a file system that has been migrated to a new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リニューアルされたリースを新しいサーバに移行されたファイルシステムに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.5. NFS4ERR_OLD_STATEID (Error Code 10024)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.5。 NFS4ERR_OLD_STATEID（エラーコード10024）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A stateid is provided with a seqid value that is not the most current.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidは、最新ではありませんSEQID値が設けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.6. NFS4ERR_STALE_STATEID (Error Code 10023)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.5.6。 NFS4ERR_STALE_STATEID（エラーコード10023）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A stateid generated by an earlier server instance was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以前のサーバインスタンスによって生成されたのstateidを使用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6. Security Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6。セキュリティエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These are the various permission-related errors in NFSv4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらは、NFSv4の中に様々な許可関連のエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.1. NFS4ERR_ACCESS (Error Code 13)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.1。 NFS4ERR_ACCESS（エラーコード13）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This indicates permission denied. The caller does not have the correct permission to perform the requested operation. Contrast this with NFS4ERR_PERM (Section 13.1.6.2), which restricts itself to owner or privileged user permission failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、許可拒否を示しています。呼び出し側は、要求された操作を実行するための正しい権限がありません。所有者または特権ユーザー権限失敗に自分自身を制限NFS4ERR_PERM（セクション13.1.6.2）、とは対照的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.2. NFS4ERR_PERM (Error Code 1)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.2。 NFS4ERR_PERM（エラーコード1）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This indicates that the requester is not the owner. The operation was not allowed because the caller is neither a privileged user (root) nor the owner of the target of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、要求者が所有者ではないことを示しています。呼び出し側が特権ユーザー（root）や操作の対象の所有者でもないため、操作は許可されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.3. NFS4ERR_WRONGSEC (Error Code 10016)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.6.3。 NFS4ERR_WRONGSEC（エラーコード10016）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This indicates that the security mechanism being used by the client for the operation does not match the server&#39;s security policy. The client should change the security mechanism being used and re-send the operation. SECINFO can be used to determine the appropriate mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、操作のために、クライアントによって使用されているセキュリティメカニズムは、サーバーのセキュリティポリシーと一致していないことを示しています。クライアントが使用されているセキュリティ・メカニズムと再送信の動作を変更する必要があります。 SECINFO適切な機構を決定するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7. Name Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7。名前のエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Names in NFSv4 are UTF-8 strings. When the strings are not of length zero, the error NFS4ERR_INVAL results. When they are not valid UTF-8, the error NFS4ERR_INVAL also results, but servers may accommodate file systems with different character formats and not return this error. Besides this, there are a number of other errors to indicate specific problems with names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4の中の名前は、UTF-8文字列です。場合は、文字列は、長さゼロのエラーNFS4ERR_INVAL結果ではありません。彼らは有効なUTF-8でない場合は、エラーNFS4ERR_INVALもなりますが、サーバは異なる文字フォーマットのファイルシステムに対応し、このエラーを返すことがありません。このほかに、名前の特定の問題を示すために、他のエラーの数があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.1. NFS4ERR_BADCHAR (Error Code 10040)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.1。 NFS4ERR_BADCHAR（エラーコード10040）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A UTF-8 string contains a character that is not supported by the server in the context in which it is being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UTF-8文字列は、それが使用されているコンテキスト内のサーバーでサポートされていない文字が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.2. NFS4ERR_BADNAME (Error Code 10041)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.2。 NFS4ERR_BADNAME（エラーコード10041）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A name string in a request consisted of valid UTF-8 characters supported by the server, but the name is not supported by the server as a valid name for current operation. An example might be creating a file or directory named &#34;..&#34; on a server whose file system uses that name for links to parent directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエスト内の名前の文字列は、サーバーでサポートされている有効なUTF-8文字から成っていますが、名前が現在の操作のための有効な名称として、サーバーによってサポートされていません。例では、という名前のファイルまたはディレクトリを作成する可能性がある「..」を持つファイルシステムの親ディレクトリへのリンクについてはその名前を使用するサーバーで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This error should not be returned due to a normalization issue in a string. When a file system keeps names in a particular normalization form, it is the server&#39;s responsibility to do the appropriate normalization, rather than rejecting the name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このエラーは、文字列の正規化の問題に返されるべきではありません。ファイルシステムは、特定の正規化形式で名前を保持するとき、それはむしろ名前を拒絶するよりも、適切な正規化を行うには、サーバの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.3. NFS4ERR_NAMETOOLONG (Error Code 63)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.7.3。 NFS4ERR_NAMETOOLONG（エラーコード63）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is returned when the filename in an operation exceeds the server&#39;s implementation limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、操作中のファイル名は、サーバの実装の制限を超えた場合に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8. Locking Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8。ロックエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section deals with errors related to locking -- both share reservations and byte-range locking. It does not deal with errors specific to the process of reclaiming locks. Those are dealt with in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
株式の予約およびバイト範囲ロックの両方 - このセクションでは、ロックに関連するエラーを扱っています。これは、ロックを再利用するプロセスに固有のエラーに対処しません。それらは次のセクションで扱っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.1. NFS4ERR_BAD_RANGE (Error Code 10042)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.1。 NFS4ERR_BAD_RANGE（エラーコード10042）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The range for a LOCK, LOCKT, or LOCKU operation is not appropriate to the allowable range of offsets for the server. For example, this error results when a server that only supports 32-bit ranges receives a range that cannot be handled by that server. (See Section 16.10.4.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCK、LOCKT、またはLOCKU操作の範囲は、サーバのためのオフセットの許容範囲に適切ではありません。のみ32ビットの範囲をサポートするサーバは、そのサーバによって処理することができない範囲を受信した場合、例えば、このエラーが生じます。 （項16.10.4を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.2. NFS4ERR_BAD_SEQID (Error Code 10026)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.2。 NFS4ERR_BAD_SEQID（エラーコード10026）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sequence number (seqid) in a locking request is neither the next expected number nor the last number processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロック要求のシーケンス番号（SEQID）は次の予想される数も処理された最後の番号でもありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.3. NFS4ERR_DEADLOCK (Error Code 10045)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.3。 NFS4ERR_DEADLOCK（エラーコード10045）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server has been able to determine a file locking deadlock condition for a blocking lock request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、ブロッキングロック要求に対するデッドロック状態をロックするファイルを決定することができました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.4. NFS4ERR_DENIED (Error Code 10010)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.4。 NFS4ERR_DENIED（エラーコード10010）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An attempt to lock a file is denied. Since this may be a temporary condition, the client is encouraged to re-send the lock request until the lock is accepted. See Section 9.4 for a discussion of the re-send.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルをロックしようとする試みは拒否されます。これは一時的な状態であるかもしれないので、クライアントはロックが受理されるまで、ロック要求を再送信することが奨励されます。再送信の議論については、セクション9.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.5. NFS4ERR_LOCKED (Error Code 10012)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.5。 NFS4ERR_LOCKED（エラーコード10012）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A READ or WRITE operation was attempted on a file where there was a conflict between the I/O and an existing lock:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READまたはWRITE操作は、I / Oと既存のロックとの間に矛盾があったファイル上で試行されました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o There is a share reservation inconsistent with the I/O being done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O I / Oが行われていると矛盾シェア予約があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The range to be read or written intersects an existing mandatory byte-range lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
範囲が読み書きさに対するO既存の必須のバイト範囲ロックを交差します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.6. NFS4ERR_LOCKS_HELD (Error Code 10037)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.6。 NFS4ERR_LOCKS_HELD（エラーコード10037）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An operation was prevented by the unexpected presence of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作はロックの予期せぬ存在によって阻止されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.7. NFS4ERR_LOCK_NOTSUPP (Error Code 10043)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.7。 NFS4ERR_LOCK_NOTSUPP（エラーコード10043）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A locking request was attempted that would require the upgrade or downgrade of a lock range already held by the owner when the server does not support atomic upgrade or downgrade of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロック要求は、サーバーがロックの原子アップグレードまたはダウングレードをサポートしていないとき、すでに所有者が保持しているロックレンジのアップグレードまたはダウングレードしている必要があるしようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.8. NFS4ERR_LOCK_RANGE (Error Code 10028)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.8。 NFS4ERR_LOCK_RANGE（エラーコード10028）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A lock request is operating on a range that partially overlaps a currently held lock for the current lock-owner and does not precisely match a single such lock, where the server does not support this type of request and thus does not implement POSIX locking semantics [fcntl]. See Sections 16.10.5, 16.11.5, and 16.12.5 for a discussion of how this applies to LOCK, LOCKT, and LOCKU, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロック要求は、部分的に現在のロック所有者のために現在保持されているロックと重なり、正確[サーバが要求のこのタイプをサポートしていないので、POSIXロックセマンティクスを実装していない単一のそのようなロックを、一致しない範囲で動作していますfcntlの]。これは、それぞれ、LOCKT、およびLOCKUをLOCKに適用する方法の議論については、セクション16.10.5、16.11.5、および16.12.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.9. NFS4ERR_OPENMODE (Error Code 10038)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.9。 NFS4ERR_OPENMODE（エラーコード10038）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client attempted a READ, WRITE, LOCK, or other operation not sanctioned by the stateid passed (e.g., writing to a file opened only for read).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、WRITE、LOCKをREADを実行しようとしました、または他の操作（例えば、ファイルへの書き込みのみ読み取りのためにオープン）のstateid渡さによって認可ません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.10. NFS4ERR_SHARE_DENIED (Error Code 10015)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.8.10。 NFS4ERR_SHARE_DENIED（エラーコード10015）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An attempt to OPEN a file with a share reservation has failed because of a share conflict.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シェア予約でファイルを開こうとは理由共有競合が失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9. Reclaim Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9。エラーを取り戻します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These errors relate to the process of reclaiming locks after a server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのエラーは、サーバの再起動後にロックを再利用するプロセスに関係します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.1. NFS4ERR_GRACE (Error Code 10013)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.1。 NFS4ERR_GRACE（エラーコード10013）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server is in its recovery or grace period, which should at least match the lease period of the server. A locking request other than a reclaim could not be granted during that period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーには、少なくともサーバーのリース期間を一致させる必要があり、その回復または猶予期間、です。再利用以外のロック要求は、その期間中に付与されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.2. NFS4ERR_NO_GRACE (Error Code 10033)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.2。 NFS4ERR_NO_GRACE（エラーコード10033）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server cannot guarantee that it has not granted state to another client that may conflict with this client&#39;s state. No further reclaims from this client will succeed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、このクライアントの状態と競合する可能性があり、別のクライアントに状態を付与していないことを保証することはできません。このクライアントからのさらなる再要求は成功しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.3. NFS4ERR_RECLAIM_BAD (Error Code 10034)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.3。 NFS4ERR_RECLAIM_BAD（エラーコード10034）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server cannot guarantee that it has not granted state to another client that may conflict with the requested state. However, this applies only to the state requested in this call; further reclaims may succeed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、要求された状態と競合する可能性が他のクライアントに状態を付与していないことを保証することはできません。しかし、これが唯一のこの呼び出しで要求された状態に適用されます。さらに再要求が成功する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unlike NFS4ERR_RECLAIM_CONFLICT, this can occur between correctly functioning clients and servers: the &#34;edge condition&#34; scenarios described in Section 9.6.3.4 leave only the server knowing whether the client&#39;s locks are still valid, and NFS4ERR_RECLAIM_BAD is the server&#39;s way of informing the client that they are not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_RECLAIM_CONFLICTとは異なり、これは正しく機能し、クライアントとサーバーの間で発生する可能性があります：セクション9.6.3.4に記載された「縁の条件」のシナリオは、クライアントのロックがまだ有効である、とNFS4ERR_RECLAIM_BADは、彼らのクライアントに通知するサーバの道であるかどうかを知る唯一のサーバーを残しますありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.4. NFS4ERR_RECLAIM_CONFLICT (Error Code 10035)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.9.4。 NFS4ERR_RECLAIM_CONFLICT（エラーコード10035）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The reclaim attempted by the client conflicts with a lock already held by another client. Unlike NFS4ERR_RECLAIM_BAD, this can only occur if one of the clients misbehaved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再利用は、すでに別のクライアントによって保持されたロックを使用してクライアントの競合によりしようとしました。クライアントのいずれかがmisbehaved場合NFS4ERR_RECLAIM_BADとは異なり、これはのみ発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10. Client Management Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10。クライアント管理のエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section deals with errors associated with requests used to create and manage client IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、クライアントIDを作成し、管理するために使用される要求に関連するエラーを扱っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10.1. NFS4ERR_CLID_INUSE (Error Code 10017)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10.1。 NFS4ERR_CLID_INUSE（エラーコード10017）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SETCLIENTID operation has found that a clientid is already in use by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTID操作はのclientidが別のクライアントによってすでに使用中であることを見出しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10.2. NFS4ERR_STALE_CLIENTID (Error Code 10022)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.10.2。 NFS4ERR_STALE_CLIENTID（エラーコード10022）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client ID not recognized by the server was used in a locking or SETCLIENTID_CONFIRM request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが認識していないクライアントIDは、ロックやSETCLIENTID_CONFIRM要求で使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11. Attribute Handling Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11。エラー処理の属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section deals with errors specific to attribute handling within NFSv4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、NFSv4の内ハンドリング属性に特定のエラーを扱っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.1. NFS4ERR_ATTRNOTSUPP (Error Code 10032)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.1。 NFS4ERR_ATTRNOTSUPP（エラーコード10032）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An attribute specified is not supported by the server. This error MUST NOT be returned by the GETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定された属性は、サーバーによってサポートされていません。このエラーはGETATTR操作で返されてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.2. NFS4ERR_BADOWNER (Error Code 10039)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.2。 NFS4ERR_BADOWNER（エラーコード10039）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This error is returned when an owner or owner_group attribute value or the who field of an ace within an ACL attribute value cannot be translated to a local representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACL属性値内の所有者またはowner_group属性値やエースのフィールドは、ローカルの表現に変換することができない場合に、このエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.3. NFS4ERR_NOT_SAME (Error Code 10027)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.3。 NFS4ERR_NOT_SAME（エラーコード10027）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This error is returned by the VERIFY operation to signify that the attributes compared were not the same as those provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このエラーは、比較属性は、クライアントの要求に提供されるものと同じではなかったことを意味するベリファイ動作によって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.4. NFS4ERR_SAME (Error Code 10009)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.11.4。 NFS4ERR_SAME（エラーコード10009）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This error is returned by the NVERIFY operation to signify that the attributes compared were the same as those provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このエラーは、比較属性は、クライアントの要求に提供したものと同じであったことを意味するNVERIFY操作によって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.12. Miscellaneous Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.12。その他のエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.12.1. NFS4ERR_CB_PATH_DOWN (Error Code 10048)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.12.1。 NFS4ERR_CB_PATH_DOWN（エラーコード10048）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is a problem contacting the client via the callback path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コールバックパスを介してクライアントとの接触の問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2。オペレーションとその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section contains a table that gives the valid error returns for each protocol operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all operations except ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、各プロトコルの動作のために有効なエラーリターンを与えるテーブルが含まれています。 （エラーがないことを示す）エラーコードNFS4_OKが表示されていないが、ILLEGAL以外のすべての操作によって返却であると理解されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------------+---------------------------------------------+
   | Operation           | Errors                                      |
   +---------------------+---------------------------------------------+
   | ACCESS              | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_IO, NFS4ERR_MOVED,                  |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |
   |                     |                                             |
   | CLOSE               | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE,   |
   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,         |
   |                     | NFS4ERR_INVAL, NFS4ERR_ISDIR,               |
   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKS_HELD,    |
   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |
   |                     | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE,      |
   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |
   |                     | NFS4ERR_STALE_STATEID                       |
   |                     |                                             |
   | COMMIT              | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |
   |                     | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK              |
   |                     |                                             |
   | CREATE              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |
   |                     | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |
   |                     | NFS4ERR_BADNAME, NFS4ERR_BADOWNER,          |
   |                     | NFS4ERR_BADTYPE, NFS4ERR_BADXDR,            |
   |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,               |
   |                     | NFS4ERR_EXIST, NFS4ERR_FHEXPIRED,           |
   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |
   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOFILEHANDLE,  |
   |                     | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,              |
   |                     | NFS4ERR_PERM, NFS4ERR_RESOURCE,             |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE                               |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| | | | DELEGPURGE | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_LEASE_MOVED, NFS4ERR_NOTSUPP, | | | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE_CLIENTID | | | | | DELEGRETURN | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BAD_STATEID, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_EXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_LEASE_MOVED, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, | | | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_STALE_STATEID | | | | | GETATTR | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE | | | | | GETFH | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE | | | | | ILLEGAL | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL | | | | | LINK | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, | | | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_DQUOT, NFS4ERR_EXIST, | | | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR, | | | NFS4ERR_MLINK, NFS4ERR_MOVED, | | | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC, | | | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP, | | | NFS4ERR_RESOURCE, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_WRONGSEC, NFS4ERR_XDEV | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| | | | DELEGPURGE | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_LEASE_MOVED、NFS4ERR_NOTSUPP、| | | NFS4ERR_RESOURCE、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE_CLIENTID | | | | | DELEGRETURN | NFS4ERR_ADMIN_REVOKED、NFS4ERR_BAD_STATEID、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_EXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_LEASE_MOVED、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTSUPP、| | | NFS4ERR_OLD_STATEID、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_STALE_STATEID | | | | | GETATTR | NFS4ERR_ACCESS、NFS4ERR_BADHANDLE、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE | | | | | GETFH | NFS4ERR_BADHANDLE、NFS4ERR_FHEXPIRED、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_RESOURCE、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE | | | | | ILLEGAL | NFS4ERR_BADXDR、NFS4ERR_OP_ILLEGAL | | | | | LINK | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、| | | NFS4ERR_BADHANDLE、NFS4ERR_BADNAME、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_DQUOT、NFS4ERR_EXIST、| | | NFS4ERR_FHEXPIRED、NFS4ERR_FILE_OPEN、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_ISDIR、| | | NFS4ERR_MLINK、NFS4ERR_MOVED、| | | NFS4ERR_NAMETOOLONG、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOSPC、| | | NFS4ERR_NOTDIR、NFS4ERR_NOTSUPP、| | | NFS4ERR_RESOURCE、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_WRONGSEC、NFS4ERR_XDEV | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| LOCK | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_BADHANDLE, NFS4ERR_BAD_RANGE, | | | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID, | | | NFS4ERR_BADXDR, NFS4ERR_DEADLOCK, | | | NFS4ERR_DELAY, NFS4ERR_DENIED, | | | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, | | | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED, | | | NFS4ERR_LOCK_NOTSUPP, NFS4ERR_LOCK_RANGE, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID, | | | NFS4ERR_OPENMODE, NFS4ERR_RECLAIM_BAD, | | | NFS4ERR_RECLAIM_CONFLICT, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_STALE_CLIENTID, | | | NFS4ERR_STALE_STATEID | | | | | LOCKT | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE, | | | NFS4ERR_BAD_RANGE, NFS4ERR_BADXDR, | | | NFS4ERR_DELAY, NFS4ERR_DENIED, | | | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, | | | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED, | | | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_STALE_CLIENTID | | | | | LOCKU | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_BADHANDLE, NFS4ERR_BAD_RANGE, | | | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, | | | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED, | | | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID, | | | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE, NFS4ERR_STALE_STATEID | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| LOCK | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_BADHANDLE、NFS4ERR_BAD_RANGE、| | | NFS4ERR_BAD_SEQID、NFS4ERR_BAD_STATEID、| | | NFS4ERR_BADXDR、NFS4ERR_DEADLOCK、| | | NFS4ERR_DELAY、NFS4ERR_DENIED、| | | NFS4ERR_EXPIRED、NFS4ERR_FHEXPIRED、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、| | | NFS4ERR_ISDIR、NFS4ERR_LEASE_MOVED、| | | NFS4ERR_LOCK_NOTSUPP、NFS4ERR_LOCK_RANGE、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NO_GRACE、NFS4ERR_OLD_STATEID、| | | NFS4ERR_OPENMODE、NFS4ERR_RECLAIM_BAD、| | | NFS4ERR_RECLAIM_CONFLICT、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_STALE_CLIENTID、| | | NFS4ERR_STALE_STATEID | | | | | LOCKT | NFS4ERR_ACCESS、NFS4ERR_BADHANDLE、| | | NFS4ERR_BAD_RANGE、NFS4ERR_BADXDR、| | | NFS4ERR_DELAY、NFS4ERR_DENIED、| | | NFS4ERR_EXPIRED、NFS4ERR_FHEXPIRED、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、| | | NFS4ERR_ISDIR、NFS4ERR_LEASE_MOVED、| | | NFS4ERR_LOCK_RANGE、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_STALE_CLIENTID | | | | | LOCKU | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_BADHANDLE、NFS4ERR_BAD_RANGE、| | | NFS4ERR_BAD_SEQID、NFS4ERR_BAD_STATEID、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_EXPIRED、NFS4ERR_FHEXPIRED、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、| | | NFS4ERR_ISDIR、NFS4ERR_LEASE_MOVED、| | | NFS4ERR_LOCK_RANGE、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_OLD_STATEID、| | | NFS4ERR_RESOURCE、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE、NFS4ERR_STALE_STATEID | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| LOOKUP | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, | | | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR, | | | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE, NFS4ERR_SYMLINK, | | | NFS4ERR_WRONGSEC | | | | | LOOKUPP | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE, | | | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, | | | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR, | | | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE, NFS4ERR_SYMLINK, | | | NFS4ERR_WRONGSEC | | | | | NVERIFY | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP, | | | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_SAME, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE | | | | | OPEN | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR, | | | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME, | | | NFS4ERR_BADOWNER, NFS4ERR_BAD_SEQID, | | | NFS4ERR_BAD_STATEID, NFS4ERR_BADXDR, | | | NFS4ERR_DELAY, NFS4ERR_DQUOT, | | | NFS4ERR_EXIST, NFS4ERR_EXPIRED, | | | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO, | | | NFS4ERR_ISDIR, NFS4ERR_MOVED, | | | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NO_GRACE, | | | NFS4ERR_NOSPC, NFS4ERR_NOTDIR, | | | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID, | | | NFS4ERR_PERM, NFS4ERR_RECLAIM_BAD, | | | NFS4ERR_RECLAIM_CONFLICT, NFS4ERR_RESOURCE, | | | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT, | | | NFS4ERR_SHARE_DENIED, NFS4ERR_STALE, | | | NFS4ERR_STALE_CLIENTID, NFS4ERR_SYMLINK, | | | NFS4ERR_WRONGSEC | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| LOOKUP | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、| | | NFS4ERR_BADHANDLE、NFS4ERR_BADNAME、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NAMETOOLONG、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTDIR、| | | NFS4ERR_RESOURCE、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE、NFS4ERR_SYMLINK、| | | NFS4ERR_WRONGSEC | | | | | LOOKUPP | NFS4ERR_ACCESS、NFS4ERR_BADHANDLE、| | | NFS4ERR_DELAY、NFS4ERR_FHEXPIRED、| | | NFS4ERR_IO、NFS4ERR_MOVED、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTDIR、| | | NFS4ERR_RESOURCE、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE、NFS4ERR_SYMLINK、| | | NFS4ERR_WRONGSEC | | | | | NVERIFY | NFS4ERR_ACCESS、NFS4ERR_ATTRNOTSUPP、| | | NFS4ERR_BADCHAR、NFS4ERR_BADHANDLE、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_SAME、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE | | | | | OPEN | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_ATTRNOTSUPP、NFS4ERR_BADCHAR、| | | NFS4ERR_BADHANDLE、NFS4ERR_BADNAME、| | | NFS4ERR_BADOWNER、NFS4ERR_BAD_SEQID、| | | NFS4ERR_BAD_STATEID、NFS4ERR_BADXDR、| | | NFS4ERR_DELAY、NFS4ERR_DQUOT、| | | NFS4ERR_EXIST、NFS4ERR_EXPIRED、| | | NFS4ERR_FBIG、NFS4ERR_FHEXPIRED、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、NFS4ERR_IO、| | | NFS4ERR_ISDIR、NFS4ERR_MOVED、| | | NFS4ERR_NAMETOOLONG、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NO_GRACE、| | | NFS4ERR_NOSPC、NFS4ERR_NOTDIR、| | | NFS4ERR_NOTSUPP、NFS4ERR_OLD_STATEID、| | | NFS4ERR_PERM、NFS4ERR_RECLAIM_BAD、| | | NFS4ERR_RECLAIM_CONFLICT、NFS4ERR_RESOURCE、| | | NFS4ERR_ROFS、NFS4ERR_SERVERFAULT、| | | NFS4ERR_SHARE_DENIED、NFS4ERR_STALE、| | | NFS4ERR_STALE_CLIENTID、NFS4ERR_SYMLINK、| | | NFS4ERR_WRONGSEC | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| OPENATTR | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_DQUOT, NFS4ERR_FHEXPIRED, | | | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC, | | | NFS4ERR_NOTSUPP, NFS4ERR_RESOURCE, | | | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE | | | | | OPEN_CONFIRM | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE, | | | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID, | | | NFS4ERR_BADXDR, NFS4ERR_EXPIRED, | | | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_STALE_STATEID | | | | | OPEN_DOWNGRADE | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE, | | | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED, | | | NFS4ERR_INVAL, NFS4ERR_LEASE_MOVED, | | | NFS4ERR_LOCKS_HELD, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID, | | | NFS4ERR_RESOURCE, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_STALE_STATEID | | | | | PUTFH | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, | | | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, | | | NFS4ERR_MOVED, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE, NFS4ERR_WRONGSEC | | | | | PUTPUBFH | NFS4ERR_DELAY, NFS4ERR_SERVERFAULT, | | | NFS4ERR_WRONGSEC | | | | | PUTROOTFH | NFS4ERR_DELAY, NFS4ERR_SERVERFAULT, | | | NFS4ERR_WRONGSEC | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| OPENATTR | NFS4ERR_ACCESS、NFS4ERR_BADHANDLE、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_DQUOT、NFS4ERR_FHEXPIRED、| | | NFS4ERR_IO、NFS4ERR_MOVED、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOSPC、| | | NFS4ERR_NOTSUPP、NFS4ERR_RESOURCE、| | | NFS4ERR_ROFS、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE | | | | |オープン_CONFIRM | NFS4ERR_ADMIN_REVOKED、NFS4ERR_BADHANDLE、| | | NFS4ERR_BAD_SEQID、NFS4ERR_BAD_STATEID、| | | NFS4ERR_BADXDR、NFS4ERR_EXPIRED、| | | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_ISDIR、NFS4ERR_LEASE_MOVED、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OLD_STATEID、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_STALE_STATEID | | | | | OPEN_DOWNGRADE | NFS4ERR_ADMIN_REVOKED、NFS4ERR_BADHANDLE、| | | NFS4ERR_BAD_SEQID、NFS4ERR_BAD_STATEID、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_EXPIRED、NFS4ERR_FHEXPIRED、| | | NFS4ERR_INVAL、NFS4ERR_LEASE_MOVED、| | | NFS4ERR_LOCKS_HELD、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_OLD_STATEID、| | | NFS4ERR_RESOURCE、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_STALE_STATEID | | | | | PUTFH | NFS4ERR_BADHANDLE、NFS4ERR_BADXDR、| | | NFS4ERR_DELAY、NFS4ERR_FHEXPIRED、| | | NFS4ERR_MOVED、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE、NFS4ERR_WRONGSEC | | | | | PUTPUBFH | NFS4ERR_DELAY、NFS4ERR_SERVERFAULT、| | | NFS4ERR_WRONGSEC | | | | | PUTROOTFH | NFS4ERR_DELAY、NFS4ERR_SERVERFAULT、| | | NFS4ERR_WRONGSEC | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| READ | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO, | | | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED, | | | NFS4ERR_LOCKED, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID, | | | NFS4ERR_OPENMODE, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_STALE_STATEID, NFS4ERR_SYMLINK | | | | | READDIR | NFS4ERR_ACCESS, NFS4ERR_BAD_COOKIE, | | | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, | | | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR, | | | NFS4ERR_NOT_SAME, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOOSMALL | | | | | READLINK | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE, | | | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NOTSUPP, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE | | | | | RELEASE_LOCKOWNER | NFS4ERR_BADXDR, NFS4ERR_EXPIRED, | | | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKS_HELD, | | | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE_CLIENTID | | | | | REMOVE | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, | | | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO, | | | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG, | | | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NOTDIR, NFS4ERR_NOTEMPTY, | | | NFS4ERR_RESOURCE, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| READ | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_BADHANDLE、NFS4ERR_BAD_STATEID、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_EXPIRED、NFS4ERR_FHEXPIRED、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、NFS4ERR_IO、| | | NFS4ERR_ISDIR、NFS4ERR_LEASE_MOVED、| | | NFS4ERR_LOCKED、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_OLD_STATEID、| | | NFS4ERR_OPENMODE、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_STALE_STATEID、NFS4ERR_SYMLINK | | | | | READDIR | NFS4ERR_ACCESS、NFS4ERR_BAD_COOKIE、| | | NFS4ERR_BADHANDLE、NFS4ERR_BADXDR、| | | NFS4ERR_DELAY、NFS4ERR_FHEXPIRED、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTDIR、| | | NFS4ERR_NOT_SAME、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOOSMALL | | | | | READLINK | NFS4ERR_ACCESS、NFS4ERR_BADHANDLE、| | | NFS4ERR_DELAY、NFS4ERR_FHEXPIRED、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_ISDIR、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NOTSUPP、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE | | | | | RELEASE_LOCKOWNER | NFS4ERR_BADXDR、NFS4ERR_EXPIRED、| | | NFS4ERR_LEASE_MOVED、NFS4ERR_LOCKS_HELD、| | | NFS4ERR_RESOURCE、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE_CLIENTID | | | | | REMOVE | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、| | | NFS4ERR_BADHANDLE、NFS4ERR_BADNAME、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_FILE_OPEN、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、NFS4ERR_IO、| | | NFS4ERR_MOVED、NFS4ERR_NAMETOOLONG、| | | NFS4ERR_NOENT、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NOTDIR、NFS4ERR_NOTEMPTY、| | | NFS4ERR_RESOURCE、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| RENAME | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, | | | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_DQUOT, NFS4ERR_EXIST, | | | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO, | | | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG, | | | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NOSPC, NFS4ERR_NOTDIR, | | | NFS4ERR_NOTEMPTY, NFS4ERR_RESOURCE, | | | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE, NFS4ERR_WRONGSEC, | | | NFS4ERR_XDEV | | | | | RENEW | NFS4ERR_ACCESS, NFS4ERR_BADXDR, | | | NFS4ERR_CB_PATH_DOWN, NFS4ERR_EXPIRED, | | | NFS4ERR_LEASE_MOVED, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE_CLIENTID | | | | | RESTOREFH | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED, | | | NFS4ERR_MOVED, NFS4ERR_RESOURCE, | | | NFS4ERR_RESTOREFH, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE, NFS4ERR_WRONGSEC | | | | | SAVEFH | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE | | | | | SECINFO | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, | | | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG, | | | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NOTDIR, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| RENAME | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、| | | NFS4ERR_BADHANDLE、NFS4ERR_BADNAME、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_DQUOT、NFS4ERR_EXIST、| | | NFS4ERR_FHEXPIRED、NFS4ERR_FILE_OPEN、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、NFS4ERR_IO、| | | NFS4ERR_MOVED、NFS4ERR_NAMETOOLONG、| | | NFS4ERR_NOENT、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NOSPC、NFS4ERR_NOTDIR、| | | NFS4ERR_NOTEMPTY、NFS4ERR_RESOURCE、| | | NFS4ERR_ROFS、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE、NFS4ERR_WRONGSEC、| | | NFS4ERR_XDEV | | | | | RENEW | NFS4ERR_ACCESS、NFS4ERR_BADXDR、| | | NFS4ERR_CB_PATH_DOWN、NFS4ERR_EXPIRED、| | | NFS4ERR_LEASE_MOVED、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE_CLIENTID | | | | | RESTOREFH | NFS4ERR_BADHANDLE、NFS4ERR_FHEXPIRED、| | | NFS4ERR_MOVED、NFS4ERR_RESOURCE、| | | NFS4ERR_RESTOREFH、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE、NFS4ERR_WRONGSEC | | | | | SAVEFH | NFS4ERR_BADHANDLE、NFS4ERR_FHEXPIRED、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_RESOURCE、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE | | | | | SECINFO | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、| | | NFS4ERR_BADHANDLE、NFS4ERR_BADNAME、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_MOVED、NFS4ERR_NAMETOOLONG、| | | NFS4ERR_NOENT、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NOTDIR、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| SETATTR | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR, | | | NFS4ERR_BADHANDLE, NFS4ERR_BADOWNER, | | | NFS4ERR_BAD_STATEID, NFS4ERR_BADXDR, | | | NFS4ERR_DELAY, NFS4ERR_DQUOT, | | | NFS4ERR_EXPIRED, NFS4ERR_FBIG, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR, | | | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKED, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NOSPC, NFS4ERR_OLD_STATEID, | | | NFS4ERR_OPENMODE, NFS4ERR_PERM, | | | NFS4ERR_RESOURCE, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_STALE_STATEID | | | | | SETCLIENTID | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE, | | | NFS4ERR_DELAY, NFS4ERR_INVAL, | | | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT | | | | | SETCLIENTID_CONFIRM | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE, | | | NFS4ERR_DELAY, NFS4ERR_RESOURCE, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE_CLIENTID | | | | | VERIFY | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP, | | | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE, | | | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOT_SAME, | | | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| SETATTR | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_ATTRNOTSUPP、NFS4ERR_BADCHAR、| | | NFS4ERR_BADHANDLE、NFS4ERR_BADOWNER、| | | NFS4ERR_BAD_STATEID、NFS4ERR_BADXDR、| | | NFS4ERR_DELAY、NFS4ERR_DQUOT、| | | NFS4ERR_EXPIRED、NFS4ERR_FBIG、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_ISDIR、| | | NFS4ERR_LEASE_MOVED、NFS4ERR_LOCKED、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NOSPC、NFS4ERR_OLD_STATEID、| | | NFS4ERR_OPENMODE、NFS4ERR_PERM、| | | NFS4ERR_RESOURCE、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_STALE_STATEID | | | | | SETCLIENTID | NFS4ERR_BADXDR、NFS4ERR_CLID_INUSE、| | | NFS4ERR_DELAY、NFS4ERR_INVAL、| | | NFS4ERR_RESOURCE、NFS4ERR_SERVERFAULT | | | | | SETCLIENTID_CONFIRM | NFS4ERR_BADXDR、NFS4ERR_CLID_INUSE、| | | NFS4ERR_DELAY、NFS4ERR_RESOURCE、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE_CLIENTID | | | | | VERIFY | NFS4ERR_ACCESS、NFS4ERR_ATTRNOTSUPP、| | | NFS4ERR_BADCHAR、NFS4ERR_BADHANDLE、| | | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOT_SAME、| | | NFS4ERR_RESOURCE、NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | WRITE               | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |
   |                     | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,     |
   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |
   |                     | NFS4ERR_DQUOT, NFS4ERR_EXPIRED,             |
   |                     | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,            |
   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |
   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |
   |                     | NFS4ERR_LOCKED, NFS4ERR_MOVED,              |
   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,        |
   |                     | NFS4ERR_NXIO, NFS4ERR_OLD_STATEID,          |
   |                     | NFS4ERR_OPENMODE, NFS4ERR_RESOURCE,         |
   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |
   |                     | NFS4ERR_STALE, NFS4ERR_STALE_STATEID,       |
   |                     | NFS4ERR_SYMLINK                             |
   |                     |                                             |
   +---------------------+---------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 7: Valid Error Returns for Each Protocol Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表7：各プロトコル動作のための有効なエラーを返します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. Callback Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3。コールバックオペレーションとその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section contains a table that gives the valid error returns for each callback operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all callback operations, with the exception of CB_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、各コールバック操作のための有効なエラーリターンを与えるテーブルが含まれています。 （エラーがないことを示す）エラーコードNFS4_OKが記載されていないが、CB_ILLEGALを除いて、すべてのコールバックオペレーションによって返却であると理解されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------+-----------------------------------------------------+
   | Callback    | Errors                                              |
   | Operation   |                                                     |
   +-------------+-----------------------------------------------------+
   | CB_GETATTR  | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, NFS4ERR_DELAY,   |
   |             | NFS4ERR_INVAL, NFS4ERR_SERVERFAULT                  |
   |             |                                                     |
   | CB_ILLEGAL  | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL                  |
   |             |                                                     |
   | CB_RECALL   | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,             |
   |             | NFS4ERR_BADXDR, NFS4ERR_DELAY, NFS4ERR_SERVERFAULT  |
   |             |                                                     |
   +-------------+-----------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 8: Valid Error Returns for Each Protocol Callback Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表8：各プロトコルのコールバック操作のための有効なエラーを返します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. Errors and the Operations That Use Them
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4。エラーおよびそれらを使用する操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------------------------+----------------------------------------+
   | Error                    | Operations                             |
   +--------------------------+----------------------------------------+
   | NFS4ERR_ACCESS           | ACCESS, COMMIT, CREATE, GETATTR, LINK, |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, READ,         |
   |                          | READDIR, READLINK, REMOVE, RENAME,     |
   |                          | RENEW, SECINFO, SETATTR, VERIFY, WRITE |
   |                          |                                        |
   | NFS4ERR_ADMIN_REVOKED    | CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_ATTRNOTSUPP      | CREATE, NVERIFY, OPEN, SETATTR, VERIFY |
   |                          |                                        |
   | NFS4ERR_BADCHAR          | CREATE, LINK, LOOKUP, NVERIFY, OPEN,   |
   |                          | REMOVE, RENAME, SECINFO, SETATTR,      |
   |                          | VERIFY                                 |
   |                          |                                        |
   | NFS4ERR_BADHANDLE        | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |
   |                          | COMMIT, CREATE, GETATTR, GETFH, LINK,  |
   |                          | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |
   |                          | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, |
   |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |
   |                          | READLINK, REMOVE, RENAME, RESTOREFH,   |
   |                          | SAVEFH, SECINFO, SETATTR, VERIFY,      |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_BADNAME          | CREATE, LINK, LOOKUP, OPEN, REMOVE,    |
   |                          | RENAME, SECINFO                        |
   |                          |                                        |
   | NFS4ERR_BADOWNER         | CREATE, OPEN, SETATTR                  |
   |                          |                                        |
   | NFS4ERR_BADTYPE          | CREATE                                 |
   |                          |                                        |
   | NFS4ERR_BADXDR           | ACCESS, CB_GETATTR, CB_ILLEGAL,        |
   |                          | CB_RECALL, CLOSE, COMMIT, CREATE,      |
   |                          | DELEGPURGE, DELEGRETURN, GETATTR,      |
   |                          | ILLEGAL, LINK, LOCK, LOCKT, LOCKU,     |
   |                          | LOOKUP, NVERIFY, OPEN, OPENATTR,       |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, PUTFH,   |
   |                          | READ, READDIR, RELEASE_LOCKOWNER,      |
   |                          | REMOVE, RENAME, RENEW, SECINFO,        |
   |                          | SETATTR, SETCLIENTID,                  |
   |                          | SETCLIENTID_CONFIRM, VERIFY, WRITE     |
   |                          |                                        |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| NFS4ERR_BAD_COOKIE | READDIR | | | | | NFS4ERR_BAD_RANGE | LOCK, LOCKT, LOCKU | | | | | NFS4ERR_BAD_SEQID | CLOSE, LOCK, LOCKU, OPEN, | | | OPEN_CONFIRM, OPEN_DOWNGRADE | | | | | NFS4ERR_BAD_STATEID | CB_RECALL, CLOSE, DELEGRETURN, LOCK, | | | LOCKU, OPEN, OPEN_CONFIRM, | | | OPEN_DOWNGRADE, READ, SETATTR, WRITE | | | | | NFS4ERR_CB_PATH_DOWN | RENEW | | | | | NFS4ERR_CLID_INUSE | SETCLIENTID, SETCLIENTID_CONFIRM | | | | | NFS4ERR_DEADLOCK | LOCK | | | | | NFS4ERR_DELAY | ACCESS, CB_GETATTR, CB_RECALL, CLOSE, | | | COMMIT, CREATE, DELEGPURGE, | | | DELEGRETURN, GETATTR, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, LOOKUPP, | | | NVERIFY, OPEN, OPENATTR, | | | OPEN_DOWNGRADE, PUTFH, PUTPUBFH, | | | PUTROOTFH, READ, READDIR, READLINK, | | | REMOVE, RENAME, SECINFO, SETATTR, | | | SETCLIENTID, SETCLIENTID_CONFIRM, | | | VERIFY, WRITE | | | | | NFS4ERR_DENIED | LOCK, LOCKT | | | | | NFS4ERR_DQUOT | CREATE, LINK, OPEN, OPENATTR, RENAME, | | | SETATTR, WRITE | | | | | NFS4ERR_EXIST | CREATE, LINK, OPEN, RENAME | | | | | NFS4ERR_EXPIRED | CLOSE, DELEGRETURN, LOCK, LOCKT, | | | LOCKU, OPEN, OPEN_CONFIRM, | | | OPEN_DOWNGRADE, READ, | | | RELEASE_LOCKOWNER, RENEW, SETATTR, | | | WRITE | | | | | NFS4ERR_FBIG | OPEN, SETATTR, WRITE | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| NFS4ERR_BAD_COOKIE | READDIR | | | | | NFS4ERR_BAD_RANGE | LOCK、LOCKT、LOCKU | | | | | NFS4ERR_BAD_SEQID | CLOSE、LOCK、LOCKU、OPEN、| | |オープン_CONFIRM、OPEN_DOWNGRADE | | | | | NFS4ERR_BAD_STATEID | CB_RECALL、CLOSE、DELEGRETURN、LOCK、| | | LOCKU、OPEN、オープン_CONFIRM、| | | OPEN_DOWNGRADE、READ、SETATTR、WRITE | | | | | NFS4ERR_CB_PATH_DOWN | RENEW | | | | | NFS4ERR_CLID_INUSE | SETCLIENTID、SETCLIENTID_CONFIRM | | | | | NFS4ERR_DEADLOCK | LOCK | | | | | NFS4ERR_DELAY | ACCESS、CB_GETATTR、CB_RECALL、CLOSE、| | | COMMIT、CREATE、DELEGPURGE、| | | DELEGRETURN、GETATTR、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、LOOKUPP、| | | NVERIFY、OPEN、OPENATTR、| | | OPEN_DOWNGRADE、PUTFH、PUTPUBFH、| | | PUTROOTFH、READ、READDIR、READLINK、| | | REMOVE、RENAME、SECINFO、SETATTR、| | | SETCLIENTID、SETCLIENTID_CONFIRM、| | | WRITE、VERIFY | | | | | NFS4ERR_DENIED | LOCK、LOCKT | | | | | NFS4ERR_DQUOT | 、LINK、OPEN、OPENATTRをCREATE、RENAME、| | | SETATTR、WRITE | | | | | NFS4ERR_EXIST | LINK、OPENは、RENAME、CREATE | | | | | NFS4ERR_EXPIRED | CLOSE、DELEGRETURN、LOCK、LOCKT、| | | LOCKU、OPEN、オープン_CONFIRM、| | | OPEN_DOWNGRADE、READ、| | | RELEASE_LOCKOWNER、RENEW、SETATTR、| | | WRITE | | | | | NFS4ERR_FBIG | OPEN、SETATTR、WRITE | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| NFS4ERR_FHEXPIRED | ACCESS, CLOSE, COMMIT, CREATE, | | | GETATTR, GETFH, LINK, LOCK, LOCKT, | | | LOCKU, LOOKUP, LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_CONFIRM, | | | OPEN_DOWNGRADE, PUTFH, READ, READDIR, | | | READLINK, REMOVE, RENAME, RESTOREFH, | | | SAVEFH, SECINFO, SETATTR, VERIFY, | | | WRITE | | | | | NFS4ERR_FILE_OPEN | LINK, REMOVE, RENAME | | | | | NFS4ERR_GRACE | GETATTR, LOCK, LOCKT, LOCKU, NVERIFY, | | | OPEN, READ, REMOVE, RENAME, SETATTR, | | | VERIFY, WRITE | | | | | NFS4ERR_INVAL | ACCESS, CB_GETATTR, CLOSE, COMMIT, | | | CREATE, DELEGRETURN, GETATTR, LINK, | | | LOCK, LOCKT, LOCKU, LOOKUP, NVERIFY, | | | OPEN, OPEN_CONFIRM, OPEN_DOWNGRADE, | | | READ, READDIR, READLINK, REMOVE, | | | RENAME, SECINFO, SETATTR, SETCLIENTID, | | | VERIFY, WRITE | | | | | NFS4ERR_IO | ACCESS, COMMIT, CREATE, GETATTR, LINK, | | | LOOKUP, LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, READ, READDIR, READLINK, | | | REMOVE, RENAME, SETATTR, VERIFY, WRITE | | | | | NFS4ERR_ISDIR | CLOSE, COMMIT, LINK, LOCK, LOCKT, | | | LOCKU, OPEN, OPEN_CONFIRM, READ, | | | READLINK, SETATTR, WRITE | | | | | NFS4ERR_LEASE_MOVED | CLOSE, DELEGPURGE, DELEGRETURN, LOCK, | | | LOCKT, LOCKU, OPEN_CONFIRM, | | | OPEN_DOWNGRADE, READ, | | | RELEASE_LOCKOWNER, RENEW, SETATTR, | | | WRITE | | | | | NFS4ERR_LOCKED | READ, SETATTR, WRITE | | | | | NFS4ERR_LOCKS_HELD | CLOSE, OPEN_DOWNGRADE, | | | RELEASE_LOCKOWNER | | | | | NFS4ERR_LOCK_NOTSUPP | LOCK | | | | | NFS4ERR_LOCK_RANGE | LOCK, LOCKT, LOCKU | | | | | NFS4ERR_MLINK | LINK |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| NFS4ERR_FHEXPIRED | ACCESS、CLOSE、COMMIT、CREATE、| | | GETATTR、GETFH、LINK、LOCK、LOCKT、| | | LOCKU、LOOKUP、LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、オープン_CONFIRM、| | | OPEN_DOWNGRADE、PUTFH、READ、READDIR、| | | READLINK、REMOVE、RENAME、RESTOREFH、| | | SAVEFH、SECINFO、SETATTR、VERIFY、| | | WRITE | | | | | NFS4ERR_FILE_OPEN | LINK、REMOVE、名前の変更| | | | | NFS4ERR_GRACE | GETATTR、LOCK、LOCKT、LOCKU、NVERIFY、| | | OPENは、READは、SETATTRの名前を変更、削除します| | | WRITE、VERIFY | | | | | NFS4ERR_INVAL | ACCESS、CB_GETATTR、CLOSE、COMMIT、| | | | DELEGRETURN、GETATTR、LINK、CREATE | | LOCK、LOCKT、LOCKU、LOOKUP、NVERIFY、| | | OPEN、オープン_CONFIRM、OPEN_DOWNGRADE、| | | 、READ READDIR、READLINK、REMOVE、| | | RENAME、SECINFO、SETATTR、SETCLIENTID、| | | WRITE、VERIFY | | | | | NFS4ERR_IO | ACCESSは、CREATE、COMMIT GETATTR、LINK、| | | LOOKUP、LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、READ、READDIR、READLINK、| | | REMOVE、RENAME、SETATTR、VERIFY、WRITE | | | | | NFS4ERR_ISDIR | CLOSE、COMMIT、LINK、LOCK、LOCKT、| | | LOCKU、OPEN、オープン_CONFIRM、READ、| | | READLINK、SETATTR、WRITE | | | | | NFS4ERR_LEASE_MOVED | CLOSE、DELEGPURGE、DELEGRETURN、LOCK、| | | LOCKT、LOCKU、オープン_CONFIRM、| | | OPEN_DOWNGRADE、READ、| | | RELEASE_LOCKOWNER、RENEW、SETATTR、| | | WRITE | | | | | NFS4ERR_LOCKED | READ、SETATTRは、WRITE | | | | | NFS4ERR_LOCKS_HELD | CLOSE、OPEN_DOWNGRADE、| | | RELEASE_LOCKOWNER | | | | | NFS4ERR_LOCK_NOTSUPP | LOCK | | | | | NFS4ERR_LOCK_RANGE | LOCK、LOCKT、LOCKU | | | | | NFS4ERR_MLINK | LINK |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| | | | NFS4ERR_MOVED | ACCESS, CLOSE, COMMIT, CREATE, | | | DELEGRETURN, GETATTR, GETFH, LINK, | | | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP, | | | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, | | | OPEN_DOWNGRADE, PUTFH, READ, READDIR, | | | READLINK, REMOVE, RENAME, RESTOREFH, | | | SAVEFH, SECINFO, SETATTR, VERIFY, | | | WRITE | | | | | NFS4ERR_NAMETOOLONG | CREATE, LINK, LOOKUP, OPEN, REMOVE, | | | RENAME, SECINFO | | | | | NFS4ERR_NOENT | LINK, LOOKUP, LOOKUPP, OPEN, OPENATTR, | | | REMOVE, RENAME, SECINFO | | | | | NFS4ERR_NOFILEHANDLE | ACCESS, CLOSE, COMMIT, CREATE, | | | DELEGRETURN, GETATTR, GETFH, LINK, | | | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP, | | | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, | | | OPEN_DOWNGRADE, READ, READDIR, | | | READLINK, REMOVE, RENAME, SAVEFH, | | | SECINFO, SETATTR, VERIFY, WRITE | | | | | NFS4ERR_NOSPC | CREATE, LINK, OPEN, OPENATTR, RENAME, | | | SETATTR, WRITE | | | | | NFS4ERR_NOTDIR | CREATE, LINK, LOOKUP, LOOKUPP, OPEN, | | | READDIR, REMOVE, RENAME, SECINFO | | | | | NFS4ERR_NOTEMPTY | REMOVE, RENAME | | | | | NFS4ERR_NOTSUPP | DELEGPURGE, DELEGRETURN, LINK, OPEN, | | | OPENATTR, READLINK | | | | | NFS4ERR_NOT_SAME | READDIR, VERIFY | | | | | NFS4ERR_NO_GRACE | LOCK, OPEN | | | | | NFS4ERR_NXIO | WRITE | | | | | NFS4ERR_OLD_STATEID | CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, | | | OPEN_CONFIRM, OPEN_DOWNGRADE, READ, | | | SETATTR, WRITE | | | | | NFS4ERR_OPENMODE | LOCK, READ, SETATTR, WRITE | | | | | NFS4ERR_OP_ILLEGAL | CB_ILLEGAL, ILLEGAL |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| | | | NFS4ERR_MOVED | ACCESS、CLOSE、COMMIT、CREATE、| | | DELEGRETURN、GETATTR、GETFH、LINK、| | | LOCK、LOCKT、LOCKU、LOOKUP、LOOKUPP、| | | NVERIFY、OPEN、OPENATTR、オープン_CONFIRM、| | | OPEN_DOWNGRADE、PUTFH、READ、READDIR、| | | READLINK、REMOVE、RENAME、RESTOREFH、| | | SAVEFH、SECINFO、SETATTR、VERIFY、| | | WRITE | | | | | NFS4ERR_NAMETOOLONG | CREATE、LINK、LOOKUP、OPEN、REMOVE、| | | | SECINFO、RENAME | | | | NFS4ERR_NOENT | LINK、LOOKUP、LOOKUPP、OPEN、OPENATTR、| | | REMOVE、RENAME、SECINFO | | | | | NFS4ERR_NOFILEHANDLE | ACCESS、CLOSE、COMMIT、CREATE、| | | DELEGRETURN、GETATTR、GETFH、LINK、| | | LOCK、LOCKT、LOCKU、LOOKUP、LOOKUPP、| | | NVERIFY、OPEN、OPENATTR、オープン_CONFIRM、| | | OPEN_DOWNGRADE、READ、READDIR、| | | READLINK、REMOVE、RENAME、SAVEFH、| | | SECINFO、SETATTR、VERIFY、WRITE | | | | | NFS4ERR_NOSPC | 、LINK、OPEN、OPENATTRをCREATE、RENAME、| | | SETATTR、WRITE | | | | | NFS4ERR_NOTDIR | CREATE、LINK、LOOKUP、LOOKUPP、OPEN、| | | READDIR、RENAME、SECINFOを削除| | | | | NFS4ERR_NOTEMPTY | REMOVE、RENAME | | | | | NFS4ERR_NOTSUPP | DELEGPURGE、DELEGRETURN、LINK、OPEN、| | | OPENATTR、READLINK | | | | | NFS4ERR_NOT_SAME | READDIR、VERIFY | | | | | NFS4ERR_NO_GRACE | LOCK、OPEN | | | | | NFS4ERR_NXIO | WRITE | | | | | NFS4ERR_OLD_STATEID | CLOSE、DELEGRETURN、LOCK、LOCKU、OPEN、| | |オープン_CONFIRM、OPEN_DOWNGRADE、READ、| | | SETATTR、WRITE | | | | | NFS4ERR_OPENMODE | LOCK、READ、SETATTR、WRITE | | | | | NFS4ERR_OP_ILLEGAL | CB_ILLEGAL、ILLEGAL |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| | | | NFS4ERR_PERM | CREATE, OPEN, SETATTR | | | | | NFS4ERR_RECLAIM_BAD | LOCK, OPEN | | | | | NFS4ERR_RECLAIM_CONFLICT | LOCK, OPEN | | | | | NFS4ERR_RESOURCE | ACCESS, CLOSE, COMMIT, CREATE, | | | DELEGPURGE, DELEGRETURN, GETATTR, | | | GETFH, LINK, LOCK, LOCKT, LOCKU, | | | LOOKUP, LOOKUPP, OPEN, OPENATTR, | | | OPEN_CONFIRM, OPEN_DOWNGRADE, READ, | | | READDIR, READLINK, RELEASE_LOCKOWNER, | | | REMOVE, RENAME, RENEW, RESTOREFH, | | | SAVEFH, SECINFO, SETATTR, SETCLIENTID, | | | SETCLIENTID_CONFIRM, VERIFY, WRITE | | | | | NFS4ERR_RESTOREFH | RESTOREFH | | | | | NFS4ERR_ROFS | COMMIT, CREATE, LINK, OPEN, OPENATTR, | | | OPEN_DOWNGRADE, REMOVE, RENAME, | | | SETATTR, WRITE | | | | | NFS4ERR_SAME | NVERIFY | | | | | NFS4ERR_SERVERFAULT | ACCESS, CB_GETATTR, CB_RECALL, CLOSE, | | | COMMIT, CREATE, DELEGPURGE, | | | DELEGRETURN, GETATTR, GETFH, LINK, | | | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP, | | | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, | | | OPEN_DOWNGRADE, PUTFH, PUTPUBFH, | | | PUTROOTFH, READ, READDIR, READLINK, | | | RELEASE_LOCKOWNER, REMOVE, RENAME, | | | RENEW, RESTOREFH, SAVEFH, SECINFO, | | | SETATTR, SETCLIENTID, | | | SETCLIENTID_CONFIRM, VERIFY, WRITE | | | | | NFS4ERR_SHARE_DENIED | OPEN | | | | | NFS4ERR_STALE | ACCESS, CLOSE, COMMIT, CREATE, | | | DELEGRETURN, GETATTR, GETFH, LINK, | | | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP, | | | NVERIFY, OPEN, OPENATTR, OPEN_CONFIRM, | | | OPEN_DOWNGRADE, PUTFH, READ, READDIR, | | | READLINK, REMOVE, RENAME, RESTOREFH, | | | SAVEFH, SECINFO, SETATTR, VERIFY, | | | WRITE | | | |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| | | | NFS4ERR_PERM | CREATE、OPEN、SETATTR | | | | | NFS4ERR_RECLAIM_BAD | LOCK、OPEN | | | | | NFS4ERR_RECLAIM_CONFLICT | LOCK、OPEN | | | | | NFS4ERR_RESOURCE | ACCESS、CLOSE、COMMIT、CREATE、| | | DELEGPURGE、DELEGRETURN、GETATTR、| | | GETFH、LINK、LOCK、LOCKT、LOCKU、| | | LOOKUP、LOOKUPP、OPEN、OPENATTR、| | |オープン_CONFIRM、OPEN_DOWNGRADE、READ、| | | READDIR、READLINK、RELEASE_LOCKOWNER、| | | REMOVE、RENAME、RENEW、RESTOREFH、| | | SAVEFH、SECINFO、SETATTR、SETCLIENTID、| | | | SETCLIENTID_CONFIRMは、WRITE、VERIFY | | | | NFS4ERR_RESTOREFH | RESTOREFH | | | | | NFS4ERR_ROFS | COMMIT、CREATE、LINK、OPEN、OPENATTR、| | | OPEN_DOWNGRADE、REMOVE、RENAME、| | | SETATTR、WRITE | | | | | NFS4ERR_SAME | NVERIFY | | | | | NFS4ERR_SERVERFAULT | ACCESS、CB_GETATTR、CB_RECALL、CLOSE、| | | COMMIT、CREATE、DELEGPURGE、| | | DELEGRETURN、GETATTR、GETFH、LINK、| | | LOCK、LOCKT、LOCKU、LOOKUP、LOOKUPP、| | | NVERIFY、OPEN、OPENATTR、オープン_CONFIRM、| | | OPEN_DOWNGRADE、PUTFH、PUTPUBFH、| | | PUTROOTFH、READ、READDIR、READLINK、| | | RELEASE_LOCKOWNER、REMOVE、RENAME、| | | 、RENEW RESTOREFH、SAVEFH、SECINFO、| | | SETATTR、SETCLIENTID、| | | | SETCLIENTID_CONFIRMは、WRITE、VERIFY | | | | NFS4ERR_SHARE_DENIED | OPEN | | | | | NFS4ERR_STALE | ACCESS、CLOSE、COMMIT、CREATE、| | | DELEGRETURN、GETATTR、GETFH、LINK、| | | LOCK、LOCKT、LOCKU、LOOKUP、LOOKUPP、| | | NVERIFY、OPEN、OPENATTR、オープン_CONFIRM、| | | OPEN_DOWNGRADE、PUTFH、READ、READDIR、| | | READLINK、REMOVE、RENAME、RESTOREFH、| | | SAVEFH、SECINFO、SETATTR、VERIFY、| | | WRITE | | | |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | NFS4ERR_STALE_CLIENTID   | DELEGPURGE, LOCK, LOCKT, OPEN,         |
   |                          | RELEASE_LOCKOWNER, RENEW,              |
   |                          | SETCLIENTID_CONFIRM                    |
   |                          |                                        |
   | NFS4ERR_STALE_STATEID    | CLOSE, DELEGRETURN, LOCK, LOCKU,       |
   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |
   |                          | SETATTR, WRITE                         |
   |                          |                                        |
   | NFS4ERR_SYMLINK          | COMMIT, LOOKUP, LOOKUPP, OPEN, READ,   |
   |                          | WRITE                                  |
   |                          |                                        |
   | NFS4ERR_TOOSMALL         | READDIR                                |
   |                          |                                        |
   | NFS4ERR_WRONGSEC         | LINK, LOOKUP, LOOKUPP, OPEN, PUTFH,    |
   |                          | PUTPUBFH, PUTROOTFH, RENAME, RESTOREFH |
   |                          |                                        |
   | NFS4ERR_XDEV             | LINK, RENAME                           |
   |                          |                                        |
   +--------------------------+----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 9: Errors and the Operations That Use Them
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表9：エラーとそれらを使用する操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. NFSv4 Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. NFSv4の要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the NFSv4 RPC program, there are two traditional RPC procedures: NULL and COMPOUND. All other functionality is defined as a set of operations, and these operations are defined in normal XDR/RPC syntax and semantics. However, these operations are encapsulated within the COMPOUND procedure. This requires that the client combine one or more of the NFSv4 operations into a single request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NULLとCOMPOUND：NFSv4のRPCプログラムの場合は、2つの伝統的なRPCの手順があります。その他のすべての機能は、一連の操作として定義され、これらの操作は、通常のXDR / RPCの構文およびセマンティクスで定義されています。しかし、これらの操作は、COMPOUNDプロシージャ内に封入されています。これにより、クライアントは単一の要求にNFSv4の操作の1つまたは複数を組み合わせることが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFS4_CALLBACK program is used to provide server-to-client signaling and is constructed in a fashion similar to the NFSv4 program. The procedures CB_NULL and CB_COMPOUND are defined in the same way as NULL and COMPOUND are within the NFS program. The CB_COMPOUND request also encapsulates the remaining operations of the NFS4_CALLBACK program. There is no predefined RPC program number for the NFS4_CALLBACK program. It is up to the client to specify a program number in the &#34;transient&#34; program range. The program and port numbers of the NFS4_CALLBACK program are provided by the client as part of the SETCLIENTID/SETCLIENTID_CONFIRM sequence. The program and port can be changed by another SETCLIENTID/SETCLIENTID_CONFIRM sequence, and it is possible to use the sequence to change them within a client incarnation without removing relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CALLBACKプログラムは、サーバからクライアントへのシグナリングを提供するために使用され、NFSv4のプログラムと同様の方法で構築されます。 NULLおよび化合物はNFSプログラム内にあるような手順CB_NULLとCB_COMPOUNDも同様に定義されます。 CB_COMPOUND要求もNFS4_CALLBACKプログラムの残りの操作をカプセル化します。 NFS4_CALLBACKプログラムには事前に定義されたRPCプログラム番号がありません。これは、「一時的な」プログラムの範囲でプログラム番号を指定するには、クライアント次第です。 NFS4_CALLBACKプログラムのプログラムとポート番号がSETCLIENTID / SETCLIENTID_CONFIRMシーケンスの一部として、クライアントによって提供されています。プログラムとポートが別のSETCLIENTID / SETCLIENTID_CONFIRMシーケンスにより変更することができ、そして関連するリースのクライアントの状態を削除せずに、クライアントの化身内でそれらを変更するシーケンスを使用することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. COMPOUND Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1。 COMPOUND手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The COMPOUND procedure provides the opportunity for better performance within high-latency networks. The client can avoid cumulative latency of multiple RPCs by combining multiple dependent operations into a single COMPOUND procedure. A COMPOUND operation may provide for protocol simplification by allowing the client to combine basic procedures into a single request that is customized for the client&#39;s environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順は、高遅延ネットワーク内のパフォーマンス向上のための機会を提供します。クライアントは、単一の化合物の手順に複数の依存の操作を組み合わせることにより、複数のRPCの累積遅延を回避することができます。 COMPOUND操作は、クライアントは、クライアントの環境に合わせてカスタマイズされた単一の要求に基本的な手順を組み合わせてできるようにすることで、プロトコルの簡素化を提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CB_COMPOUND procedure precisely parallels the features of COMPOUND as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記のようにCB_COMPOUND手順は正確化合物の機能に匹敵します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The basic structure of the COMPOUND procedure is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順の基本的な構造は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----+--------------+--------+-----------+-----------+-----------+--
   | tag | minorversion | numops | op + args | op + args | op + args |
   +-----+--------------+--------+-----------+-----------+-----------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
and the reply&#39;s structure is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そして、返信の構造は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +------------+-----+--------+-----------------------+--
     |last status | tag | numres | status + op + results |
     +------------+-----+--------+-----------------------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The numops and numres fields, used in the depiction above, represent the count for the counted array encoding used to signify the number of arguments or results encoded in the request and response. As per the XDR encoding, these counts must match exactly the number of operation arguments or results encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の描写に使用numopsとnumresフィールドは、要求に応答して符号化された引数または結果の数を示すために使用されるカウント配列エンコーディングのカウントを表します。 XDRエンコーディングごとに、これらのカウントは正確にエンコードされた操作の引数や結果の数と一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. Evaluation of a COMPOUND Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2。複合要求の評価
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server will process the COMPOUND procedure by evaluating each of the operations within the COMPOUND procedure in order. Each component operation consists of a 32-bit operation code, followed by the argument of length determined by the type of operation. The results of each operation are encoded in sequence into a reply buffer. The results of each operation are preceded by the opcode and a status code (normally zero). If an operation results in a non-zero status code, the status will be encoded, evaluation of the COMPOUND sequence will halt, and the reply will be returned. Note that evaluation stops even in the event of &#34;non-error&#34; conditions such as NFS4ERR_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、注文中の化合物のプロシージャ内の各操作を評価することにより、化合物手続きを処理します。各コンポーネントの動作は、操作の種類によって決定される長さの引数に続く32ビットのオペコードからなります。各演算の結果が応答バッファ内に順に符号化されます。各演算の結果がオペコードとステータスコード（通常はゼロ）が先行しています。ゼロ以外のステータスコードの動作結果は、ステータスが符号化される場合、化合物配列の評価は停止し、応答が返されます。評価がさえ、このようなNFS4ERR_SAMEなどの「非エラー」の条件の場合に停止することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are no atomicity requirements for the operations contained within the COMPOUND procedure. The operations being evaluated as part of a COMPOUND request may be evaluated simultaneously with other COMPOUND requests that the server receives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順内に含まれる操作にはアトミック要件はありません。複合要求の一部として評価されている操作は、サーバーが受信した他の化合物の要求と同時に評価することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A COMPOUND is not a transaction, and it is the client&#39;s responsibility to recover from any partially completed COMPOUND procedure. These may occur at any point due to errors such as NFS4ERR_RESOURCE and NFS4ERR_DELAY. Note that these errors can occur in an otherwise valid operation string. Further, a server reboot that occurs in the middle of processing a COMPOUND procedure may leave the client with the difficult task of determining how far COMPOUND processing has proceeded. Therefore, the client should avoid overly complex COMPOUND procedures in the event of the failure of an operation within the procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
化合物は、トランザクションはなく、任意の部分的に完成されたCOMPOUND手順から回復するには、クライアントの責任です。これらは、NFS4ERR_RESOURCEとNFS4ERR_DELAYなどのエラーに起因する任意の時点で起こり得ます。これらのエラーは、そうでない場合は有効な操作文字列に発生する可能性があることに注意してください。さらに、COMPOUND手順の処理の途中で発生するサーバーの再起動がはるかCOMPOUND処理が進んでいるかを決定するのは困難な作業でクライアントを残すことができます。そのため、クライアントは、プロシージャ内の動作障害が発生した場合に、過度に複雑なCOMPOUND手順を避ける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each operation assumes a current filehandle and a saved filehandle that are available as part of the execution context of the COMPOUND request. Operations may set, change, or return the current filehandle. The saved filehandle is used for temporary storage of a filehandle value and as operands for the RENAME and LINK operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各操作は、現在のファイルハンドルと複合要求の実行コンテキストの一部として利用可能である保存されたファイルハンドルをとります。操作は、設定変更、または現在のファイルハンドルを返すことがあります。保存されたファイルハンドルは、ファイルハンドルの値を一時的に記憶するため、およびRENAMEとLINK操作のためのオペランドとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. Synchronous Modifying Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3。同期の変更操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4 operations that modify the file system are synchronous. When an operation is successfully completed at the server, the client can trust that any data associated with the request is now in stable storage (the one exception is in the case of the file data in a WRITE operation with the UNSTABLE4 option specified).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルシステムを変更するのNFSv4操作が同期しています。操作が正常にサーバーに完了すると、クライアントは、要求に関連付けられたすべてのデータは、安定したストレージに今あることを信頼することができます（唯一の例外は、指定されたUNSTABLE4オプションとWRITE操作でファイルデータの場合です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This implies that any previous operations within the same COMPOUND request are also reflected in stable storage. This behavior enables the client&#39;s ability to recover from a partially executed COMPOUND request that may have resulted from the failure of the server. For example, if a COMPOUND request contains operations A and B and the server is unable to send a response to the client, then depending on the progress the server made in servicing the request, the result of both operations may be reflected in stable storage or just operation A may be reflected. The server must not have just the results of operation B in stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、同じ化合物の要求内の任意の以前の動作も安定したストレージに反映されていることを意味します。この動作は、サーバの障害に起因している可能性があり、部分的に実行さCOMPOUND要求から回復するためのクライアントの機能を有効にします。複合要求が操作AおよびBを含み、サーバはクライアントに応答を送信することができない場合、例えば、その後進捗要求をサービスで行わサーバーに応じて、両方の操作の結果は、安定記憶装置に反映され得るか、または単に操作Aを反映することができます。サーバーは安定したストレージに操作Bの結果だけを持っていなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. Operation Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4。演算値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The operations encoded in the COMPOUND procedure are identified by operation values. To avoid overlap with the RPC procedure numbers, operations 0 (zero) and 1 are not defined. Operation 2 is not defined but is reserved for future use with minor versioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順で符号化操作は、操作値によって識別されます。 RPCプロシージャ番号の重複を避けるために、操作0（ゼロ）と1が定義されていません。操作2が定義されていないが、マイナーバージョンとの将来の使用のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFSv4 Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFSv4の手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. Procedure 0: NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1。手順0：NULL  - 動作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;null&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;NULL&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Standard NULL procedure. Void argument, void response. This procedure has no functionality associated with it. Because of this, it is sometimes used to measure the overhead of processing a service request. Therefore, the server should ensure that no unnecessary work is done in servicing this procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
標準NULL手続き。ボイド引数、無効応答。この手順は、それに関連付けられた機能を持っていません。このため、時々、サービス要求の処理のオーバーヘッドを測定するために使用されます。そのため、サーバは不要な作業は、この手順を整備中で行われていないことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. Procedure 1: COMPOUND - COMPOUND Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2。手順1：COMPOUND  -  COMPOUND操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
compoundargs -&gt; compoundres
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
compoundargs  - &gt; compoundres
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_argop4 switch (nfs_opnum4 argop) {
             case &lt;OPCODE&gt;: &lt;argument&gt;;
             ...
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           nfs_argop4      argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_resop4 switch (nfs_opnum4 resop) {
             case &lt;OPCODE&gt;: &lt;argument&gt;;
             ...
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMPOUND4res {
           nfsstat4        status;
           utf8str_cs      tag;
           nfs_resop4      resarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The COMPOUND procedure is used to combine one or more of the NFS operations into a single RPC request. The main NFS RPC program has two main procedures: NULL and COMPOUND. All other operations use the COMPOUND procedure as a wrapper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順は、単一のRPC要求にNFS操作の1つまたは複数を組み合わせるために使用されます。 NULLとCOMPOUND：メインNFS RPCプログラムは、主に2つの手順があります。他のすべての操作は、ラッパーとしてCOMPOUNDプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The COMPOUND procedure is used to combine individual operations into a single RPC request. The server interprets each of the operations in turn. If an operation is executed by the server and the status of that operation is NFS4_OK, then the next operation in the COMPOUND procedure is executed. The server continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順は、単一のRPC要求に個々の操作を組み合わせるために使用されます。サーバは、順番にそれぞれの操作を解釈します。動作は、サーバによって実行され、その操作のステータスがNFS4_OKである場合、COMPOUND手順における次の動作が実行されます。が実行されるべきそれ以上の操作がされないかのいずれかの操作がNFS4_OK以外の状態値を有するまで、サーバは、このプロセスを継続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the processing of the COMPOUND procedure, the server may find that it does not have the available resources to execute any or all of the operations within the COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the COMPOUND sequence have been evaluated successfully. The results for all of the evaluated operations must be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND手順の処理では、サーバはそれがCOMPOUND配列内の操作のいずれか、またはすべてを実行するために使用可能なリソースを持っていないことがあります。この場合、エラーNFS4ERR_RESOURCEは、リソースの枯渇が発生しCOMPOUNDプロシージャ内の特定の操作のために返されます。これは、化合物配列内のすべての以前の操作が正常に評価されていることを前提としています。評価したすべての操作の結果はクライアントに返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server will generally choose between two methods of decoding the client&#39;s request. The first would be the traditional one-pass XDR decode, in which decoding of the entire COMPOUND precedes execution of any operation within it. If there is an XDR decoding error in this case, an RPC XDR decode error would be returned. The second method would be to make an initial pass to decode the basic COMPOUND request and then to XDR decode each of the individual operations, as the server is ready to execute it. In this case, the server may encounter an XDR decode error during such an operation decode, after previous operations within the COMPOUND have been executed. In this case, the server would return the error NFS4ERR_BADXDR to signify the decode error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、一般的にクライアントの要求を復号化する二つの方法のどちらかを選択します。最初は、化合物全体の復号がその中に任意の操作の実行に先行する従来のワンパスXDRデコード、あろう。この場合XDRデコードエラーがある場合、RPCのXDRデコードエラーが返されることになります。第二の方法は、塩基性化合物の要求を復号化するための初期のパスを作成し、サーバはそれを実行する準備ができているように、次にXDRに、個々の操作のそれぞれを復号化することであろう。この場合、サーバは、その化合物内の前の操作が実行された後、このような動作デコード中XDRデコードエラーが発生する場合があります。この場合、サーバは、デコードエラーを示すために、エラーNFS4ERR_BADXDRを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The COMPOUND arguments contain a minorversion field. The initial and default value for this field is 0 (zero). This field will be used by future minor versions such that the client can communicate to the server what minor version is being requested. If the server receives a COMPOUND procedure with a minorversion field value that it does not support, the server MUST return an error of NFS4ERR_MINOR_VERS_MISMATCH and a zero-length resultdata array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND引数はMINORVERSIONフィールドが含まれています。このフィールドの初期およびデフォルト値は0（ゼロ）です。このフィールドは、クライアントが要求されているマイナーバージョンをサーバーに伝えることができるように、将来のマイナーバージョンによって使用されます。サーバがサポートしていないMINORVERSIONフィールド値を有する化合物の手続きを受信した場合、サーバはNFS4ERR_MINOR_VERS_MISMATCHの誤差およびゼロ長resultdata配列を返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Contained within the COMPOUND results is a status field. If the results array length is non-zero, this status must be equivalent to the status of the last operation that was executed within the COMPOUND procedure. Therefore, if an operation incurred an error, then the status value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPOUND結果に含まれるステータスフィールドがあります。結果の配列の長さがゼロでない場合、このステータスはCOMPOUND手順の中で実行された最後の操作の状態と同等でなければなりません。操作がエラーを発生した場合、したがって、その後のステータス値は、失敗した操作のために返される同じエラー値となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that operations 0 (zero), 1 (one), and 2 (two) are not defined for the COMPOUND procedure. It is possible that the server receives a request that contains an operation that is less than the first legal operation (OP_ACCESS) or greater than the last legal operation (OP_RELEASE_LOCKOWNER). In this case, the server&#39;s response will encode the opcode OP_ILLEGAL rather than the illegal opcode of the request. The status field in the ILLEGAL return results will be set to NFS4ERR_OP_ILLEGAL. The COMPOUND procedure&#39;s return results will also be NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーション0（ゼロ）、1（1）、2（2）はCOMPOUND手順のために定義されていないことに留意されたいです。サーバが最後の法的な操作（OP_RELEASE_LOCKOWNER）よりも第1の法的動作（OP_ACCESS）未満以上である動作を含む要求を受信することが可能です。この場合、サーバの応答は、オペコードOP_ILLEGALではなく、要求の不正命令コードをエンコードします。 ILLEGALリターン結果のステータスフィールドはNFS4ERR_OP_ILLEGALに設定されます。 COMPOUND手順のリターン結果もNFS4ERR_OP_ILLEGALになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The definition of the &#34;tag&#34; in the request is left to the implementer. It may be used to summarize the content of the COMPOUND request for the benefit of packet sniffers and engineers debugging implementations. However, the value of &#34;tag&#34; in the response SHOULD be the same value as the value provided in the request. This applies to the tag field of the CB_COMPOUND procedure as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエスト内の「タグ」の定義は実装者に任されています。実装をデバッグするパケットスニファやエンジニアの利益のためにCOMPOUND要求の内容を要約するために使用することができます。しかし、応答の「タグ」の値は、リクエストで指定された値と同じ値であるべきです。これは、同様にCB_COMPOUND手順のタグフィールドに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.4.1. Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.4.1。現在のファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current filehandle and the saved filehandle are used throughout the protocol. Most operations implicitly use the current filehandle as an argument, and many set the current filehandle as part of the results. The combination of client-specified sequences of operations and current and saved filehandle arguments and results allows for greater protocol flexibility. The best or easiest example of current filehandle usage is a sequence like the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルと保存されたファイルハンドルは、プロトコルで使用されています。ほとんどの操作は、暗黙のうちに引数として現在のファイルハンドルを使用しており、多くは結果の一部として、現在のファイルハンドルを設定します。操作と、現在、保存されたファイルハンドルを引数と結果のクライアント指定の配列の組み合わせは、より大きなプロトコルの柔軟性を可能にします。現在のファイルハンドルの使用状況の最高または最も簡単な例は、以下のような配列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        PUTFH fh1              {fh1}
                        LOOKUP &#34;compA&#34;         {fh2}
                        GETATTR                {fh2}
                        LOOKUP &#34;compB&#34;         {fh3}
                        GETATTR                {fh3}
                        LOOKUP &#34;compC&#34;         {fh4}
                        GETATTR                {fh4}
                        GETFH
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1: Filehandle Usage Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1：ファイルハンドル使用例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this example, the PUTFH (Section 16.20) operation explicitly sets the current filehandle value, while the result of each LOOKUP operation sets the current filehandle value to the resultant file system object. Also, the client is able to insert GETATTR operations using the current filehandle as an argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ルックアップ操作の結果が得られたファイル・システム・オブジェクトに現在のファイルハンドル値を設定している。この例では、PUTFH（セクション16.20）の動作は、明示的に、現在のファイルハンドルの値を設定しますまた、クライアントは引数として現在のファイルハンドルを使用してGETATTR操作を挿入することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PUTROOTFH (Section 16.22) and PUTPUBFH (Section 16.21) operations also set the current filehandle. The above example would replace &#34;PUTFH fh1&#34; with PUTROOTFH or PUTPUBFH with no filehandle argument in order to achieve the same effect (on the assumption that &#34;compA&#34; is directly below the root of the namespace).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTROOTFH（セクション16.22）とPUTPUBFH（セクション16.21）の操作は、現在のファイルハンドルを設定します。上記の例では、（「コンパ」は、直接、名前空間のルートの下にあると仮定して）同じ効果を達成するために、なしファイルハンドル引数でPUTROOTFHまたはPUTPUBFHで「PUTFH FH1」を置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Along with the current filehandle, there is a saved filehandle. While the current filehandle is set as the result of operations like LOOKUP, the saved filehandle must be set directly with the use of the SAVEFH operation. The SAVEFH operation copies the current filehandle value to the saved value. The saved filehandle value is used in combination with the current filehandle value for the LINK and RENAME operations. The RESTOREFH operation will copy the saved filehandle value to the current filehandle value; as a result, the saved filehandle value may be used as a sort of &#34;scratch&#34; area for the client&#39;s series of operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルとともに、保存されたファイルハンドルがあります。現在のファイルハンドルをLOOKUPなどの操作の結果として設定されているときに、保存されたファイルハンドルはSAVEFH操作を使用して直接設定しなければなりません。 SAVEFH操作コピー保存された値に現在のファイルハンドル値。保存されたファイルハンドル値は、リンクの現在のファイルハンドル値と組み合わせて使用​​され、操作の名前を変更しています。 RESTOREFH操作は、現在のファイルハンドルの値に保存されたファイルハンドル値をコピーします。結果として、保存されたファイルハンドル値は、操作のクライアントのシリーズの「スクラッチ」領域の一種として使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since an error of any type may occur after only a portion of the operations have been evaluated, the client must be prepared to recover from any failure. If the source of an NFS4ERR_RESOURCE error was a complex or lengthy set of operations, it is likely that if the number of operations were reduced the server would be able to evaluate them successfully. Therefore, the client is responsible for dealing with this type of complexity in recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作の一部のみが評価された後、任意のタイプのエラーが発生する可能性があるので、クライアントは、任意の障害から回復するために用意されなければなりません。 NFS4ERR_RESOURCEエラーの原因が業務の複雑または長いセットした場合は、操作の数が減少した場合、サーバーが正常にそれらを評価することができるだろうと思われます。そのため、クライアントは回復における複雑さのこのタイプを扱うための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A single compound should not contain multiple operations that have different values for the clientid field used in OPEN, LOCK, or RENEW. This can cause confusion in cases in which operations that do not contain clientids have potential interactions with operations that do. When only a single clientid has been used, it is clear what client is being referenced. For a particular example involving the interaction of OPEN and GETATTR, see Section 16.16.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一の化合物は、OPEN、LOCKに使用されるクライアントIDフィールドの異なる値を持つ複数の操作を含む、または更新しないはずです。これは、のClientIDが含まれていない操作が行う事業との潜在的な相互作用を持っている場合に混乱を引き起こす可能性があります。唯一の単一のClientIDが使用されている場合は、参照されているものをクライアント明らかです。 OPENとGETATTRの相互作用を含む特定の例については、項16.16.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. NFSv4 Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. NFSv4の操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. Operation 3: ACCESS - Check Access Rights
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1。動作3：アクセス - アクセス権限をチェック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), accessreq -&gt; supported, accessrights
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、accessreq  - &gt;サポート、て、AccessRights
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACCESS4_READ      = 0x00000001;
   const ACCESS4_LOOKUP    = 0x00000002;
   const ACCESS4_MODIFY    = 0x00000004;
   const ACCESS4_EXTEND    = 0x00000008;
   const ACCESS4_DELETE    = 0x00000010;
   const ACCESS4_EXECUTE   = 0x00000020;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4args {
           /* CURRENT_FH: object */
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4resok {
           uint32_t        supported;
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union ACCESS4res switch (nfsstat4 status) {
    case NFS4_OK:
            ACCESS4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS determines the access rights that a user, as identified by the credentials in the RPC request, has with respect to the file system object specified by the current filehandle. The client encodes the set of access rights that are to be checked in the bitmask &#34;access&#34;. The server checks the permissions encoded in the bitmask. If a status of NFS4_OK is returned, two bitmasks are included in the response. The first, &#34;supported&#34;, represents the access rights for which the server can verify reliably. The second, &#34;access&#34;, represents the access rights available to the user for the filehandle provided. On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESSは、RPC要求に資格情報によって識別されるユーザは、現在のファイルハンドルに指定されたファイル・システム・オブジェクトに対して有するアクセス権を決定します。クライアントはビットマスク「アクセス」にチェックされるアクセス権のセットを符号化します。サーバーは、ビットマスクでエンコードされた権限をチェックします。 NFS4_OKのステータスが返された場合、2ビットマスクは、応答に含まれています。 、まず、「サポート」は、サーバが確実に確認することができますするアクセス権を表します。二、「アクセス」、提供ファイルハンドルのためにユーザに利用可能なアクセス権を表します。成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the supported field will contain only as many values as were originally sent in the arguments. For example, if the client sends an ACCESS operation with only the ACCESS4_READ value set and the server supports this value, the server will return only ACCESS4_READ even if it could have reliably checked other values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
元々の引数に送られたとしてサポートフィールドだけのように多くの値が含まれていることに注意してください。クライアントは設定のみACCESS4_READ値にアクセス動作を送信し、サーバーがこの値をサポートしている場合たとえば、サーバーは、それが確実に他の値をチェックすることができた場合でも、唯一のACCESS4_READ戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The results of this operation are necessarily advisory in nature. A return status of NFS4_OK and the appropriate bit set in the bitmask do not imply that such access will be allowed to the file system object in the future. This is because access rights can be revoked by the server at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作の結果は、自然の中で必然的に助言しています。ビットマスクで設定NFS4_OKの戻り状態と適切なビットは、そのようなアクセスは、将来的にファイル・システム・オブジェクトに許可されることを意味するものではありません。アクセス権限は、いつでもサーバーによって取り消すことができるからです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following access permissions may be requested:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のアクセス許可を要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_READ: Read data from file or read a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_READ：ファイルからデータを読み込みまたはディレクトリをお読みください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_LOOKUP: Look up a name in a directory (no meaning for non-directory objects).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_LOOKUP：ディレクトリ（非ディレクトリオブジェクトのための意味無し）で名前を検索します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_MODIFY: Rewrite existing file data or modify existing directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_MODIFY：既存のファイルのデータを書き換えたり、既存のディレクトリエントリを変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_EXTEND: Write new data or add directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_EXTEND：新しいデータを書き込むか、ディレクトリエントリを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_DELETE: Delete an existing directory entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_DELETE：既存のディレクトリエントリを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_EXECUTE: Execute file (no meaning for a directory).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACCESS4_EXECUTE：実行ファイル（ディレクトリの意味無し）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, it is not sufficient for the client to attempt to deduce access permissions by inspecting the uid, gid, and mode fields in the file attributes or by attempting to interpret the contents of the ACL attribute. This is because the server may perform uid or gid mapping or enforce additional access control restrictions. It is also possible that the server may not be in the same ID space as the client. In these cases (and perhaps others), the client cannot reliably perform an access check with only current file attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがファイル属性でUID、GID、およびモードフィールドを検査することによって、またはACL属性の内容を解釈しようとすることで、アクセス権限を推測しようとするために一般的には、それは十分ではありません。サーバーは、UIDまたはGIDマッピングを実行するか、追加のアクセス制御制限を強制する可能性があるためです。サーバがクライアントと同じIDスペースにないかもしれないことも可能です。 （おそらく他）これらの例では、クライアントは確実にのみ、現在のファイル属性とアクセスチェックを実行することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the NFSv2 protocol, the only reliable way to determine whether an operation was allowed was to try it and see if it succeeded or failed. Using the ACCESS operation in the NFSv4 protocol, the client can ask the server to indicate whether or not one or more classes of operations are permitted. The ACCESS operation is provided to allow clients to check before doing a series of operations that might result in an access failure. The OPEN operation provides a point where the server can verify access to the file object and the method to return that information to the client. The ACCESS operation is still useful for directory operations or for use in the case where the UNIX API &#34;access&#34; is used on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv2プロトコルでは、操作が許可されたかどうかを判断する唯一の確実な方法は、それを試してみて、それが成功したか失敗したかどうかを確認することでした。 NFSv4のプロトコルでアクセス動作を使用して、クライアントは操作の1つまたは複数のクラスが許可されているかどうかを示すために、サーバに依頼することができます。アクセス動作は、クライアントがアクセス障害につながる可能性がある一連の操作を行う前にチェックできるようにするために提供されます。 OPEN操作はサーバがクライアントに情報を返すためにファイルオブジェクトとメソッドへのアクセスを確認することができますポイントを提供します。アクセス動作は、まだディレクトリ操作用またはUNIX用API「アクセス」がクライアント上で使用する場合に使用するのに便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The information returned by the server in response to an ACCESS call is not permanent. It was correct at the exact time that the server performed the checks, but not necessarily afterward. The server can revoke access permission at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アクセスの呼び出しに応じてサーバから返された情報は永久的ではありません。それは必ずしも必要ではないが、その後、サーバがチェックを行って正確な時間で正しかったです。サーバーは、いつでもアクセス許可を取り消すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client should use the effective credentials of the user to build the authentication information in the ACCESS request used to determine access rights. It is the effective user and group credentials that are used in subsequent READ and WRITE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、アクセス権を決定するために使用するアクセス要求で認証情報を構築するために、ユーザーの効果的な資格情報を使用する必要があります。これは、その後の読み取りおよび書き込み操作に使用されている有効なユーザおよびグループの資格情報です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many implementations do not directly support the ACCESS4_DELETE permission. Operating systems like UNIX will ignore the ACCESS4_DELETE bit if set on an access request on a non-directory object. In these systems, delete permission on a file is determined by the access permissions on the directory in which the file resides, instead of being determined by the permissions of the file itself. Therefore, the mask returned enumerating which access rights can be supported will have the ACCESS4_DELETE value set to 0. This indicates to the client that the server was unable to check that particular access right. The ACCESS4_DELETE bit in the access mask returned will then be ignored by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くの実装では、直接ACCESS4_DELETE許可をサポートしていません。非ディレクトリ・オブジェクトに対するアクセス要求に設定した場合、UNIXのようなオペレーティングシステムはACCESS4_DELETEビットを無視します。これらのシステムでは、ファイルのアクセス許可を削除する代わりに、ファイル自体の権限によって決定されるのファイルが存在するディレクトリへのアクセス権限によって決定されます。そのため、マスクは、アクセス権がこれは、サーバーがその特定のアクセス権を確認することができなかったことをクライアントに指示する0に設定ACCESS4_DELETE値を持つことになり、サポートすることができます列挙を返しました。返されたアクセスマスクでACCESS4_DELETEビットは、クライアントによって無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. Operation 4: CLOSE - Close File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2。操作4：CLOSE  - ファイルを閉じます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), seqid, open_stateid -&gt; open_stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、SEQID、open_stateid  - &gt; open_stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CLOSE4args {
           /* CURRENT_FH: object */
           seqid4          seqid;
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CLOSE4res switch (nfsstat4 status) {
    case NFS4_OK:
            stateid4       open_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CLOSE operation releases share reservations for the regular or named attribute file as specified by the current filehandle. The share reservations and other state information released at the server as a result of this CLOSE are only associated with the supplied stateid. The sequence id provides for the correct ordering. State associated with other OPENs is not affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルで指定されCLOSE操作は、通常のまたは名前付き属性ファイルの共有の予約を解放します。このCLOSEの結果としてサーバで放出共有の予約および他の状態情報のみ供給のstateidに関連付けられています。シーケンスIDは、正しい順序付けのために用意されています。他のOPENsに関連した状態は影響を受けません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If byte-range locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト範囲ロックが保持されている場合、クライアントはCLOSEを発行する前に、すべてのロックを解除しなければなりません。サーバーは、CLOSE上のすべての未解決のロックを解放するかもしれが、一部のサーバーがまだ開催されたバイト範囲ロックを持つファイルのCLOSEをサポートしていないかもしれません。すべてのロックは、CLOSEの後に存在するならば、サーバーは失敗を返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Even though CLOSE returns a stateid, this stateid is not useful to the client and should be treated as deprecated. CLOSE &#34;shuts down&#34; the state associated with all OPENs for the file by a single open-owner. As noted above, CLOSE will either release all file locking state or return an error. Therefore, the stateid returned by CLOSE is not useful for the operations that follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLOSEがたstateidを返すにもかかわらず、これのstateidは、クライアントにとって有用なものではなく、非推奨として扱われるべきです。 CLOSE単一のオープン所有者がファイルのすべてのOPENsに関連付けられている状態を「シャットダウンします」。上述したように、CLOSE状態をロックするすべてのファイルを解放するか、またはエラーが返されるいずれかです。したがって、CLOSEによって返されたstateidは続く操作のために有用ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3. Operation 5: COMMIT - Commit Cached Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3。操作5：COMMITは - キャッシュされたデータをコミット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), offset, count -&gt; verifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、オフセット、カウント - &gt;検証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMMIT4args {
           /* CURRENT_FH: file */
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMMIT4resok {
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union COMMIT4res switch (nfsstat4 status) {
    case NFS4_OK:
            COMMIT4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The COMMIT operation forces or flushes data to stable storage for the file specified by the current filehandle. The flushed data is that which was previously written with a WRITE operation that had the stable field set to UNSTABLE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルで指定されたファイルのために安定したストレージに操作力やフラッシュのデータをコミットします。フラッシュされたデータは、以前UNSTABLE4に安定したフィールドのセットを持っていたWRITE操作で書かれたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The offset specifies the position within the file where the flush is to begin. An offset value of 0 (zero) means to flush data starting at the beginning of the file. The count specifies the number of bytes of data to flush. If count is 0 (zero), a flush from the offset to the end of the file is done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オフセットは、フラッシュが開始するファイル内の位置を指定します。 0（ゼロ）のオフセット値は、ファイルの先頭からデータをフラッシュすることを意味します。カウントは、フラッシュへのデータのバイト数を指定します。カウントが0（ゼロ）の場合、ファイルの最後にオフセットからのフラッシュが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server returns a write verifier upon successful completion of the COMMIT. The write verifier is used by the client to determine if the server has restarted or rebooted between the initial WRITE(s) and the COMMIT. The client does this by comparing the write verifier returned from the initial writes and the verifier returned by the COMMIT operation. The server must vary the value of the write verifier at each server event or instantiation that may lead to a loss of uncommitted data. Most commonly, this occurs when the server is rebooted; however, other events at the server may result in uncommitted data loss as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、COMMITが正常に完了すると、書き込みベリファイアを返します。書き込みベリファイアは、サーバが再起動または初期WRITE（S）とCOMMITの間再起動しているかどうかを決定するためにクライアントによって使用されます。クライアントは、最初の書き込みとCOMMIT操作によって返された検証者から返された書き込みベリファイアを比較することによって、これを行います。サーバは、コミットされていないデータの損失につながる可能性があり、各サーバイベントまたはインスタンスに書き込み検証の値を変更しなければなりません。サーバーが再起動されたときに最も一般的に、これが発生します。ただし、サーバーで他のイベントも同様にコミットされていないデータが失われることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The COMMIT operation is similar in operation and semantics to the POSIX fsync() [fsync] system call that synchronizes a file&#39;s state with the disk (file data and metadata are flushed to disk or stable storage). COMMIT performs the same operation for a client, flushing any unsynchronized data and metadata on the server to the server&#39;s disk or stable storage for the specified file. Like fsync(), it may be that there is some modified data or no modified data to synchronize. The data may have been synchronized by the server&#39;s normal periodic buffer synchronization activity. COMMIT should return NFS4_OK, unless there has been an unexpected error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
動作をCOMMITディスクにファイルの状態を同期POSIX FSYNC（）FSYNC]システムコール（ファイルデータとメタデータがディスクまたは安定記憶にフラッシュされる）への操作と意味論と同様です。 COMMIT指定されたファイルは、サーバーのディスクにサーバーまたは安定したストレージ上の任意の非同期のデータとメタデータをフラッシュする、クライアントのために同じ操作を実行します。 FSYNC（）のように、それはいくつかの変更されたデータ又は同期させるない変更されたデータが存在することであってもよいです。データは、サーバーの正常な周期的なバッファ同期活動で同期されている可能性があります。予期せぬエラーがあった場合を除き、NFS4_OKを返す必要がCOMMIT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMMIT differs from fsync() in that it is possible for the client to flush a range of the file (most likely triggered by a buffer-reclamation scheme on the client before the file has been completely written).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがファイルの範囲を（ファイルが完全に書き込まれる前に、最も可能性の高いクライアント上のバッファ・再生スキームによってトリガ）フラッシュすることが可能であるという点ではfsync異なるのを（）COMMIT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server implementation of COMMIT is reasonably simple. If the server receives a full file COMMIT request that is starting at offset 0 and count 0, it should do the equivalent of fsync()&#39;ing the file. Otherwise, it should arrange to have the cached data in the range specified by offset and count to be flushed to stable storage. In both cases, any metadata associated with the file must be flushed to stable storage before returning. It is not an error for there to be nothing to flush on the server. This means that the data and metadata that needed to be flushed have already been flushed or lost during the last server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMMITのサーバの実装は合理的に簡単です。サーバーは、完全なファイルがで始まっていることCOMMIT要求をオフセット0と0を数える受信した場合、それはFSYNCの同等の（） &#39;ファイルをINGのを行う必要があります。それ以外の場合は、offsetで指定した範囲のキャッシュされたデータを持っており、安定したストレージにフラッシュされるようにカウントするように手配しなければなりません。どちらの場合も、ファイルに関連付けられたすべてのメタデータが戻る前に、安定したストレージにフラッシュする必要があります。サーバー上で洗い流すことは何もないことはエラーではありません。これはフラッシュするために必要なデータおよびメタデータがすでに最後のサーバ障害時のフラッシュまたは失われていることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client implementation of COMMIT is a little more complex. There are two reasons for wanting to commit a client buffer to stable storage. The first is that the client wants to reuse a buffer. In this case, the offset and count of the buffer are sent to the server in the COMMIT request. The server then flushes any cached data based on the offset and count, and flushes any metadata associated with the file. It then returns the status of the flush and the write verifier. The other reason for the client to generate a COMMIT is for a full file flush, such as may be done at CLOSE. In this case, the client would gather all of the buffers for this file that contain uncommitted data, do the COMMIT operation with an offset of 0 and count of 0, and then free all of those buffers. Any other dirty buffers would be sent to the server in the normal fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMMITのクライアントの実装はもう少し複雑です。安定したストレージにクライアントバッファをコミットしたいのための2つの理由があります。最初は、クライアントがバッファを再利用したいということです。この場合、オフセットおよびバッファのカウントがCOMMITリクエストでサーバーに送信されます。次に、サーバーはオフセットとカウントに基づいてキャッシュされたデータをフラッシュし、ファイルに関連付けられたすべてのメタデータをフラッシュします。その後、フラッシュやライト・ベリファイアの状態を返します。 COMMITを生成するためのクライアントのための他の理由は、CLOSEで行うことができるような、完全なファイルのフラッシュのためです。この場合、クライアントは0の0カウントのオフセット、およびそれらのバッファをすべて、その後自由にCOMMIT操作を行い、コミットされていないデータが含まれているこのファイルのバッファのすべてを収集します。その他のダーティバッファは、通常の方法でサーバに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After a buffer is written by the client with the stable parameter set to UNSTABLE4, the buffer must be considered modified by the client until the buffer has been either flushed via a COMMIT operation or written via a WRITE operation with the stable parameter set to FILE_SYNC4 or DATA_SYNC4. This is done to prevent the buffer from being freed and reused before the data can be flushed to stable storage on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バッファがUNSTABLE4に設定され、安定したパラメータを用いてクライアントによって書き込まれた後、バッファは、バッファがFILE_SYNC4に安定したパラメータセットとWRITE動作を介して操作または書き込みをCOMMITを介してフラッシュどちらかされるまでクライアントによって修飾考慮しなければなりませんDATA_SYNC4。これは、データはサーバー上の安定したストレージにフラッシュする前に解放され、再利用されることから、バッファを防止するために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a response is returned from either a WRITE or a COMMIT operation and it contains a write verifier that is different than previously returned by the server, the client will need to retransmit all of the buffers containing uncommitted cached data to the server. How this is to be done is up to the implementer. If there is only one buffer of interest, then it should probably be sent back over in a WRITE request with the appropriate stable parameter. If there is more than one buffer, it might be worthwhile to retransmit all of the buffers in WRITE requests with the stable parameter set to UNSTABLE4 and then retransmit the COMMIT operation to flush all of the data on the server to stable storage. The timing of these retransmissions is left to the implementer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答がWRITEかCOMMIT操作のいずれかから返されると、それは以前にサーバから返されたと異なる書き込み検証が含まれている場合、クライアントはサーバーにコミットされていないキャッシュされたデータを含む全てのバッファを再送信する必要があります。これを実行する方法を実装次第です。関心の一つだけのバッファが存在する場合、それはおそらく、適切な安定したパラメータを使用してWRITE要求に背を超える送信する必要があります。複数のバッファが存在する場合、UNSTABLE4に設定し、安定したパラメータでWRITE要求内のバッファのすべてを再送信して、安定したストレージにサーバー上のすべてのデータをフラッシュするCOMMIT操作を再送する価値があるかもしれません。これらの再送信のタイミングは、実装者に任されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The above description applies to page-cache-based systems as well as buffer-cache-based systems. In those systems, the virtual memory system will need to be modified instead of the buffer cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の説明は、ページキャッシュベースのシステムと同様に、バッファ・キャッシュベースのシステムに適用されます。これらのシステムでは、仮想メモリシステムは、バッファ・キャッシュの代わりに変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4. Operation 6: CREATE - Create a Non-regular File Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4。操作6：CREATE  - 非正規ファイルオブジェクトを作成します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), name, type, attrs -&gt; (cfh), cinfo, attrset
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、名前、タイプ、ATTRS  - &gt;（CFH）、CINFO、attrset
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union createtype4 switch (nfs_ftype4 type) {
    case NF4LNK:
            linktext4 linkdata;
    case NF4BLK:
    case NF4CHR:
            specdata4 devdata;
    case NF4SOCK:
    case NF4FIFO:
    case NF4DIR:
            void;
    default:
            void;  /* server should return NFS4ERR_BADTYPE */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4args {
           /* CURRENT_FH: directory for creation */
           createtype4     objtype;
           component4      objname;
           fattr4          createattrs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4resok {
           change_info4    cinfo;
           bitmap4         attrset;        /* attributes set */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CREATE4res switch (nfsstat4 status) {
    case NFS4_OK:
            CREATE4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CREATE operation creates a non-regular file object in a directory with a given name. The OPEN operation is used to create a regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CREATE操作は、指定した名前のディレクトリにある非正規ファイルオブジェクトを作成します。 OPEN操作は、通常のファイルを作成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The objname specifies the name for the new object. The objtype determines the type of object to be created: directory, symlink, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
objnameには、新しいオブジェクトの名前を指定します。ディレクトリ、シンボリックリンクなど：OBJTYPEは、作成するオブジェクトの種類を決定します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an object of the same name already exists in the directory, the server will return the error NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じ名前のオブジェクトがすでにディレクトリに存在する場合、サーバーはエラーNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the directory where the new file object was created, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the file object creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいファイルオブジェクトが作成されたディレクトリのために、サーバはcinfoの変化_info4情報を返します。前と後の変更属性はファイルオブジェクトの作成に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the objname is of zero length, NFS4ERR_INVAL will be returned. The objname is also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
objnameには、長さがゼロである場合、NFS4ERR_INVALが返されます。 objnameには、通常のUTF-8文字のサポート、および名前のチェックの対象となります。さらなる議論については項12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current filehandle is replaced by that of the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルは、新しいオブジェクトのものに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The createattrs field specifies the initial set of attributes for the object. The set of attributes may include any writable attribute valid for the object type. When the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
createattrsフィールドは、オブジェクトの属性の初期セットを指定します。一連の属性は、オブジェクト・タイプに対して有効な任意の書き込み可能な属性を含むことができます。操作が成功すると、サーバーはクライアントに正常にオブジェクトに設定された属性の属性マスクの意味を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If createattrs includes neither the owner attribute nor an ACL with an ACE for the owner, and if the server&#39;s file system both supports and requires an owner attribute (or an owner ACE), then the server MUST derive the owner (or the owner ACE). This would typically be from the principal indicated in the RPC credentials of the call, but the server&#39;s operating environment or file system semantics may dictate other methods of derivation. Similarly, if createattrs includes neither the group attribute nor a group ACE, and if the server&#39;s file system both supports and requires the notion of a group attribute (or group ACE), the server MUST derive the group attribute (or the corresponding owner ACE) for the file. This could be from the RPC&#39;s credentials, such as the group principal if the credentials include it (such as with AUTH_SYS), from the group identifier associated with the principal in the credentials (e.g., POSIX systems have a user database [getpwnam] that has the group identifier for every user identifier), inherited from the directory the object is created in, or whatever else the server&#39;s operating environment or file system semantics dictate. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
createattrsは、所有者属性も所有者のACEとのACLでもないが含まれており、サーバのファイルシステムの場合の両方をサポートし、所有者の属性（または所有者のACE）が必要な場合、サーバは、所有者（または所有者のACE）を導出しなければなりません。これは通常、コールのRPC資格で示さ校長からだろうが、サーバーの動作環境やファイルシステムのセマンティクスが派生する他の方法を指示することができます。 createattrsは、グループ属性やグループACE、およびサーバのファイルシステムならば、両方のサポートもないが含まれており、グループ属性（またはグループACE）の概念を必要とする場合も同様に、サーバはグループ属性（または対応する所有者のACE）を導出しなければなりませんファイルの。資格情報が（例えばAUTH_SYSのように）を含む場合、これはクレデンシャル（例えば、で主に関連付けられたグループ識別子から、POSIXシステムが有するユーザデータベース【のgetpwnam]を有する、そのようなグループプリンシパルとしてRPCの資格、からとすることができますすべてのユーザ識別子のためのグループ識別子）、オブジェクトが中に作成されたディレクトリから継承された、または任意の他のサーバの動作環境やファイルシステムのセマンティクスが決まります。これは、あまりにもOPEN操作に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Conversely, it is possible the client will specify in createattrs an owner attribute, group attribute, or ACL that the principal indicated the RPC&#39;s credentials does not have permissions to create files for. The error to be returned in this instance is NFS4ERR_PERM. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
逆に、クライアントがcreateattrsに本人がためにファイルを作成する権限を持っていないRPCの資格を示したことを、所有者の属性、グループ属性、またはACLを指定しますことも可能です。この例で返されるエラーはNFS4ERR_PERMです。これは、あまりにもOPEN操作に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client desires to set attribute values after the create, a SETATTR operation can be added to the COMPOUND request so that the appropriate attributes will be set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが作成した後、属性値を設定したい場合、適切な属性が設定されるように、SETATTR操作はCOMPOUND要求に追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5. Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5。操作7：DELEGPURGE  - 回復を待ちパージ代表団
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
clientid -&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientIDを - &gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGPURGE4args {
           clientid4       clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGPURGE4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.5.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DELEGPURGE purges all of the delegations awaiting recovery for a given client. This is useful for clients that do not commit delegation information to stable storage, to indicate that conflicting requests need not be delayed by the server awaiting recovery of delegation information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DELEGPURGEは、指定されたクライアントの回復を待っている代表団のすべてを消去します。これは矛盾する要求が委任情報の回復を待って、サーバーによって遅延される必要がないことを示すために、安定したストレージへの委任情報をコミットしていないクライアントのために有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is provided to support clients that record delegation information in stable storage on the client. In this case, DELEGPURGE should be issued immediately after doing delegation recovery (using CLAIM_DELEGATE_PREV) on all delegations known to the client. Doing so will notify the server that no additional delegations for the client will be recovered, allowing it to free resources and avoid delaying other clients who make requests that conflict with the unrecovered delegations. All clients SHOULD use DELEGPURGE as part of recovery once it is known that no further CLAIM_DELEGATE_PREV recovery will be done. This includes clients that do not record delegation information in stable storage, who would then do a DELEGPURGE immediately after SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作は、クライアント上の安定したストレージにそのレコード委任情報クライアントをサポートするために提供されます。この場合、DELEGPURGEは、クライアントに知られている全ての代表団に（CLAIM_DELEGATE_PREVを使用して）委任リカバリを実行した直後に発行されなければなりません。そうすることでリソースを解放することを許可する、クライアントのための追加の代表団が回収されませんサーバーに通知し、その未回収の代表団との競合要求を行う他のクライアントを遅らせる避けることができます。それ以上CLAIM_DELEGATE_PREV回復が行われないことを知られたら、すべてのクライアントが回復の一環としてDELEGPURGEを使用すべきです。これは、その後、SETCLIENTID_CONFIRM直後DELEGPURGEを行うだろう安定したストレージに委任情報を記録していないクライアントが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The set of delegations known to the server and the client may be different. The reasons for this include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバとクライアントに知られている代表団のセットが異なる場合があります。その理由は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A client may fail after making a request that resulted in delegation but before it received the results and committed them to the client&#39;s stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントは、委任が生じたが、それは結果を受信し、クライアントの安定した記憶領域にそれらをコミットする前に要求を行った後、失敗することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A client may fail after deleting its indication that a delegation exists but before the delegation return is fully processed by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントは、代表団が存在するが、委任リターンの前に完全にサーバーで処理され、その表示を削除した後に失敗することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In the case in which the server and the client restart, the server may have limited persistent recording of delegations to a subset of those in existence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oでのサーバーとクライアントを再起動する場合には、サーバが存在におけるそれらのサブセットに代表団の永続的な記録を制限されている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A client may have only persistently recorded information about a subset of delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントは、代表団の一部についてのみ永続的に記録された情報を有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MAY support DELEGPURGE, but its support or non-support should match that of CLAIM_DELEGATE_PREV:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーはDELEGPURGEをサポートするかもしれが、そのサポートまたは非サポートはCLAIM_DELEGATE_PREVのものと一致する必要があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A server may support both DELEGPURGE and CLAIM_DELEGATE_PREV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OサーバーはDELEGPURGEとCLAIM_DELEGATE_PREVの両方をサポートすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A server may support neither DELEGPURGE nor CLAIM_DELEGATE_PREV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OサーバはどちらDELEGPURGEもCLAIM_DELEGATE_PREVをサポートすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This fact allows a client starting up to determine if the server is prepared to support persistent storage of delegation information and thus whether it may use write-back caching to local persistent storage, relying on CLAIM_DELEGATE_PREV recovery to allow such changed data to be flushed safely to the server in the event of client restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この事実は、それは、そのような変更されたデータは、に安全にフラッシュすることができるようにCLAIM_DELEGATE_PREV回復に頼って、ローカル永続ストレージにライトバックキャッシュを使用するかどうかので、クライアントは、サーバが委任情報の永続ストレージをサポートする用意があるかどうかを判断するために起動することができますし、クライアントの再起動のイベントでサーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6. Operation 8: DELEGRETURN - Return Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6。操作8：DELEGRETURN  - 戻る委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), stateid -&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、のstateid  - &gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGRETURN4args {
           /* CURRENT_FH: delegated file */
           stateid4        deleg_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGRETURN4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.6.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DELEGRETURN returns the delegation represented by the current filehandle and stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DELEGRETURNは、現在のファイルハンドルとのstateidで表さ委任を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Delegations may be returned when recalled or voluntarily (i.e., before the server has recalled them). In either case, the client must properly propagate state changed under the context of the delegation to the server before returning the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（サーバは、それらをリコールしている、すなわち、前に）自発的にリコール又は場合委任が返されてもよいです。いずれの場合も、クライアントは正常に状態を伝播しなければならない委任を返す前に、サーバーへの委任のコンテキストで変更。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7. Operation 9: GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7。操作9：GETATTR  - 属性を取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), attrbits -&gt; attrbits, attrvals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、attrbits  - &gt; attrbits、attrvals
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETATTR4args {
           /* CURRENT_FH: directory or file */
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETATTR4resok {
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETATTR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The GETATTR operation will obtain attributes for the file system object specified by the current filehandle. The client sets a bit in the bitmap argument for each attribute value that it would like the server to return. The server returns an attribute bitmap that indicates the attribute values for which it was able to return values, followed by the attribute values ordered lowest attribute number first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETATTR操作は、現在のファイルハンドルで指定されたファイル・システム・オブジェクトの属性を取得します。クライアントは、サーバーが返すしたい各属性値のビットマップ引数のビットを設定します。サーバーは、最初に最低の属性番号を注文した属性値に続いて、値を返すことができた対象の属性値を示す属性ビットマップを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MUST return a value for each attribute that the client requests if the attribute is supported by the server. If the server does not support an attribute or cannot approximate a useful value, then it MUST NOT return the attribute value and MUST NOT set the attribute bit in the result bitmap. The server MUST return an error if it supports an attribute on the target but cannot obtain its value. In that case, no attribute values will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性は、サーバーによってサポートされている場合、サーバーはクライアントの要求する各属性の値を返さなければなりません。サーバーが属性をサポートしていないか、有益な値に近づけることができない場合、それは属性値を返してはならないと、結果のビットマップ内の属性ビットを設定してはいけません。それは、ターゲットの属性をサポートしていますが、その値を取得できない場合、サーバーはエラーを返さなければなりません。その場合には、何の属性値は返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
File systems that are absent should be treated as having support for a very small set of attributes as described in Section 8.3.1 -- even if previously, when the file system was present, more attributes were supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
先にいる場合、ファイルシステムが存在した場合、より多くの属性がサポートされていた - 存在しないファイルシステムは、セクション8.3.1に記載したように、属性の非常に小さなセットのための支持体を有するものとして扱われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All servers MUST support the REQUIRED attributes, as specified in Section 5, for all file systems, with the exception of absent file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不在のファイルシステムを除いて、すべてのファイルシステムのために、第5節で指定されているすべてのサーバーは、必要な属性をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.7.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suppose there is an OPEN_DELEGATE_WRITE delegation held by another client for the file in question, and size and/or change are among the set of attributes being interrogated. The server has two choices. First, the server can obtain the actual current value of these attributes from the client holding the delegation by using the CB_GETATTR callback. Second, the server, particularly when the delegated client is unresponsive, can recall the delegation in question. The GETATTR MUST NOT proceed until one of the following occurs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
問題のファイルのために別のクライアントが保持しているOPEN_DELEGATE_WRITE代表団があるとし、かつ属性のセットが尋問されている間のサイズおよび/または変更があります。サーバーは、2つの選択肢があります。まず、サーバはCB_GETATTRコールバックを使用して委任を保持しているクライアントからこれらの属性の実際の電流値を得ることができます。第二に、サーバは、委任クライアントが応答しない場合は特に、問題の委任を思い出すことができます。以下のいずれかが発生するまでGETATTRが進んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The requested attribute values are returned in the response to CB_GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O要求された属性値はCB_GETATTRへの応答で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The OPEN_DELEGATE_WRITE delegation is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O OPEN_DELEGATE_WRITE代表団が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The OPEN_DELEGATE_WRITE delegation is revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O OPEN_DELEGATE_WRITE委任が取り消されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unless one of the above happens very quickly, one or more NFS4ERR_DELAY errors will be returned while a delegation is outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記のいずれかが非常に迅速に起こる場合を除き代表団が顕著である一方で、一つ以上のNFS4ERR_DELAYエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8. Operation 10: GETFH - Get Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8。操作10：GETFH  - 現在のファイルハンドルを取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh) -&gt; filehandle
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH） - &gt;ファイルハンドル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETFH4resok {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETFH4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETFH4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation returns the current filehandle value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作は、現在のファイルハンドル値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.8.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operations that change the current filehandle, like LOOKUP or CREATE, do not automatically return the new filehandle as a result. For instance, if a client needs to look up a directory entry and obtain its filehandle, then the following request is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOOKUPのように、現在のファイルハンドルを変更したり、CREATE操作は、自動的に結果として新しいファイルハンドルを返しません。クライアントは、ディレクトリエントリを検索し、そのファイルハンドルを取得する必要がある場合、つぎのよう要求が必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH (directory filehandle) LOOKUP (entry name) GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH（ディレクトリのファイルハンドル）LOOKUP（エントリ名）GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9. Operation 11: LINK - Create Link to a File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9。操作11：LINK  - ファイルへのリンクを作成します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(sfh), (cfh), newname -&gt; (cfh), cinfo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（SFH）、（CFH）、NEWNAME  - &gt;（CFH）、CINFO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LINK4args {
           /* SAVED_FH: source object */
           /* CURRENT_FH: target directory */
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LINK4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The LINK operation creates an additional newname for the file represented by the saved filehandle, as set by the SAVEFH operation, in the directory represented by the current filehandle. The existing file and the target directory must reside within the same file system on the server. On success, the current filehandle will continue to be the target directory. If an object exists in the target directory with the same name as newname, the server must return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルによって表されるディレクトリに、SAVEFH操作によって設定されたLINK操作は、保存されたファイルハンドルによって表されるファイルのための追加NEWNAMEを作成します。既存のファイルとターゲット・ディレクトリは、サーバー上の同じファイルシステム内に存在する必要があります。成功すると、現在のファイルハンドルは、ターゲットディレクトリであり続けるだろう。オブジェクトがNEWNAMEと同じ名前のターゲットディレクトリに存在する場合、サーバはNFS4ERR_EXISTを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ターゲットディレクトリの場合、サーバはcinfoの変化_info4情報を返します。前と後の変更属性がリンク作成に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If newname has a length of 0 (zero), or if newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NEWNAMEが0（ゼロ）の長さを有する場合、またはNEWNAMEがUTF-8定義に従わない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.9.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Changes to any property of the &#34;hard&#34; linked files are reflected in all of the linked files. When a link is made to a file, the attributes for the file should have a value for numlinks that is one greater than the value before the LINK operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ハード」リンクされたファイルの任意のプロパティを変更すると、リンクされたファイルのすべてに反映されています。リンクをファイルにするとき、ファイルの属性はLINK操作前の値より1大きいnumlinksの値を持つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The statement &#34;file and the target directory must reside within the same file system on the server&#34; means that the fsid fields in the attributes for the objects are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned. This error may be returned by some servers when there is an internal partitioning of a file system that the LINK operation would violate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
声明「ファイルとターゲット・ディレクトリは、サーバー上の同じファイルシステム内に存在しなければならない」オブジェクトの属性でFSIDフィールドが同じであることを意味します。彼らは異なるファイルシステム上に存在する場合は、エラーNFS4ERR_XDEVが返されます。 LINK操作が違反するファイルシステムの内部パーティションがある場合に、このエラーが一部のサーバーによって返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On some servers, &#34;.&#34; and &#34;..&#34; are illegal values for newname, and the error NFS4ERR_BADNAME will be returned if they are specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のサーバでは、「」そして、「..」newnameのために不正な値であり、それらが指定されている場合、エラーNFS4ERR_BADNAMEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is not a named attribute for the same object, the error NFS4ERR_XDEV MUST be returned. When the saved filehandle designates a named attribute and the current filehandle is not the appropriate named attribute directory, the error NFS4ERR_XDEV MUST also be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルが指定された属性のディレクトリを指定してリンクするオブジェクト（保存されたファイルハンドル）は、同じオブジェクトの名前付き属性でない場合は、エラーNFS4ERR_XDEVを返さなければなりません。保存されたファイルハンドルは、名前の属性を指定し、現在のファイルハンドルが属性という名前のディレクトリ適切でない場合は、エラーNFS4ERR_XDEVも返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is a named attribute within that directory, the server MAY return the error NFS4ERR_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルが指定された属性のディレクトリを指定してリンクするオブジェクト（保存されたファイルハンドル）がそのディレクトリ内の名前付き属性である場合には、サーバがエラーNFS4ERR_NOTSUPPが返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case that newname is already linked to the file represented by the saved filehandle, the server will return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NEWNAMEがすでに保存されたファイルハンドルによって表されるファイルにリンクされている場合には、サーバがNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that symbolic links are created with the CREATE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シンボリックリンクが作成操作で作成されていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10. Operation 12: LOCK - Create Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10。操作12：LOCK  - ロックを作成します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh) locktype, reclaim, offset, length, locker -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）種類のLockType、再利用、オフセット、長さ、ロッカー - &gt;のstateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum nfs_lock_type4 {
           READ_LT         = 1,
           WRITE_LT        = 2,
           READW_LT        = 3,    /* blocking read */
           WRITEW_LT       = 4     /* blocking write */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, transition from open_owner to new lock_owner
    */
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid;
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, existing lock_owner continues to request file locks
    */
   struct exist_lock_owner4 {
           stateid4        lock_stateid;
           seqid4          lock_seqid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union locker4 switch (bool new_lock_owner) {
    case TRUE:
            open_to_lock_owner4     open_owner;
    case FALSE:
            exist_lock_owner4       lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LOCK/LOCKT/LOCKU: Record lock management
    */
   struct LOCK4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           bool            reclaim;
           offset4         offset;
           length4         length;
           locker4         locker;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4denied {
           offset4         offset;
           length4         length;
           nfs_lock_type4  locktype;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4resok {
           stateid4        lock_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LOCK4resok     resok4;
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The LOCK operation requests a byte-range lock for the byte range specified by the offset and length parameters. The lock type is also specified to be one of the nfs_lock_type4s. If this is a reclaim request, the reclaim parameter will be TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCK操作は、オフセットおよび長さパラメータで指定されたバイト範囲のバイト範囲ロックを要求します。ロックタイプもnfs_lock_type4sの一つであることが指定されています。これは再利用要求がある場合は、再利用パラメータがTRUEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bytes in a file may be locked even if those bytes are not currently allocated to the file. To lock the file from a specific offset through the end-of-file (no matter how long the file actually is), use a length field with all bits set to 1 (one). If the length is zero, or if a length that is not all bits set to one is specified, and the length when added to the offset exceeds the maximum 64-bit unsigned integer value, the error NFS4ERR_INVAL will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それらのバイトが現在のファイルに割り当てられていない場合でも、ファイル内のバイトをロックすることができます。ファイルの終わりを介して特定のオフセット（ファイルが実際にどのくらいの時間に関係なく）からファイルをロックするために、1（1）に設定されたすべてのビットと長さフィールドを使用します。長さがゼロである、または全てのビットが1に設定されていない長さを指定し、オフセットに追加の長さが最大64ビットの符号なし整数値を超えている場合、エラーNFS4ERR_INVALが生じる。場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
32-bit servers are servers that support locking for byte offsets that fit within 32 bits (i.e., less than or equal to NFS4_UINT32_MAX). If the client specifies a range that overlaps one or more bytes beyond offset NFS4_UINT32_MAX but does not end at offset NFS4_UINT64_MAX, then such a 32-bit server MUST return the error NFS4ERR_BAD_RANGE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
32ビット・サーバは32ビット内に（すなわち、より少ない又はNFS4_UINT32_MAXに等しい）を取り付けバイトオフセットのロックサポートするサーバーです。クライアントオフセットNFS4_UINT32_MAX超えて1バイト以上に重なるが、オフセットNFS4_UINT64_MAXで終了しない範囲を指定した場合、そのような32ビット・サーバはエラーNFS4ERR_BAD_RANGEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case that the lock is denied, the owner, offset, and length of a conflicting lock are returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロックが拒否された場合に、競合するロックの所有者、オフセット、および長さが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.10.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. Section 9 contains a full description of this and the other file locking operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは競合ロックの正確なオフセットと長さを決定することができない場合は、引数に与えたのと同じオフセットと長さが拒否された結果で返されるべきです。第9章は、これの完全な説明や操作をロックし、他のファイルが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCK operations are subject to permission checks and to checks against the access type of the associated file. However, the specific rights and modes required for various types of locks reflect the semantics of the server-exported file system, and are not specified by the protocol. For example, Windows 2000 allows a write lock of a file open for READ, while a POSIX-compliant system does not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCK操作は、権限チェックにと関連付けられたファイルのアクセスタイプに対するチェックの対象となります。しかし、具体的な権利とロックの様々なタイプのために必要なモードでは、サーバー・エクスポートされたファイルシステムのセマンティクスを反映しており、プロトコルによって指定されていません。 POSIX準拠のシステムではそうではないたとえば、Windows 2000は、READのために開いているファイルの書き込みロックを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client makes a lock request that corresponds to a range that the lock-owner has locked already (with the same or different lock type), or to a sub-region of such a range, or to a region that includes multiple locks already granted to that lock-owner, in whole or in part, and the server does not support such locking operations (i.e., does not support POSIX locking semantics), the server will return the error NFS4ERR_LOCK_RANGE. In that case, the client may return an error, or it may emulate the required operations, using only LOCK for ranges that do not include any bytes already locked by that lock-owner and LOCKU of locks held by that lock-owner (specifying an exactly matching range and type). Similarly, when the client makes a lock request that amounts to upgrading (changing from a read lock to a write lock) or downgrading (changing from a write lock to a read lock) an existing record lock and the server does not support such a lock, the server will return NFS4ERR_LOCK_NOTSUPP. Such operations may not perfectly reflect the required semantics in the face of conflicting lock requests from other clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがこのような範囲のサブ領域に、又は既に複数のロックを含む領域にロック所有者は、（同一または異なるロックタイプで）既にロックされた範囲に対応する、またはロック要求を行うと（つまり、POSIXロックのセマンティクスをサポートしていません）全体的または部分的に、そのロックの所有者に付与され、サーバは、このようなロック操作をサポートしていない、サーバーはエラーNFS4ERR_LOCK_RANGEを返します。その場合には、（既にロック所有者が保持しているロックのロック所有者とLOCKUによってロック任意のバイトを含まない範囲のロックを指定するだけ用い、クライアントは、エラーを返すことがあり、あるいは、必要な操作をエミュレートすることができます正確に）範囲およびタイプ一致。同様に、クライアントがアップグレードになるロック要求があった場合、（書き込みロックに読み取りロックから変更）または（読み込みロックへの書き込みロックから変更）既存のレコードロックをダウングレードすると、サーバーは、そのようなロックをサポートしていません。 、サーバーはNFS4ERR_LOCK_NOTSUPPを返します。このような操作は完全に他のクライアントから競合ロック要求の顔に必要なセマンティクスを反映していないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client holds an OPEN_DELEGATE_WRITE delegation, the client holding that delegation is assured that there are no opens by other clients. Thus, there can be no conflicting LOCK operations from such clients. Therefore, the client may be handling locking requests locally, without doing LOCK operations on the server. If it does that, it must be prepared to update the lock status on the server by sending appropriate LOCK and LOCKU operations before returning the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合は、その委任を保持しているクライアントは、他のクライアントで開く何が存在しないことが保証されます。したがって、そのようなクライアントからの競合LOCK操作がないことができます。そのため、クライアントは、サーバ上のLOCK操作を行うことなく、ローカルにロック要求を処理することができます。それはそれを行う場合は、委任を返す前に、適切なLOCKとLOCKU操作を送信することで、サーバー上のロック・ステータスを更新するために準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When one or more clients hold OPEN_DELEGATE_READ delegations, any LOCK operation where the server is implementing mandatory locking semantics MUST result in the recall of all such delegations. The LOCK operation may not be granted until all such delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1つ以上のクライアントがOPEN_DELEGATE_READ代表団を保持する場合、サーバは強制ロックセマンティクスを実装している任意のLOCK操作はすべて、このような代表団のリコールをもたらさなければなりません。このようなすべての代表団が返されるか取り消されるまでLOCK操作は許可されない場合があります。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The locker argument specifies the lock-owner that is associated with the LOCK request. The locker4 structure is a switched union that indicates whether the client has already created byte-range locking state associated with the current open file and lock-owner. There are multiple cases to be considered, corresponding to possible combinations of whether locking state has been created for the current open file and lock-owner, and whether the boolean new_lock_owner is set. In all of the cases, there is a lock_seqid specified, whether the lock-owner is specified explicitly or implicitly. This seqid value is used for checking lock-owner sequencing/replay issues. When the given lock-owner is not known to the server, this establishes an initial sequence value for the new lock-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロッカー引数はLOCK要求に関連付けられているロックの所有者を指定します。 locker4構造は、クライアントがすでに現在開いているファイルに関連付けられているバイト範囲ロック状態とロック所有者が作成したかどうかを示す切り替え組合です。考慮すべき複数の場合はロック状態は、現在開いているファイルとロック所有者のために作成され、ブールnew_lock_ownerが設定されているかされているかどうかの可能な組み合わせに対応し、そこです。例すべてにおいて、ロック所有者が明示的または暗黙的に指定されているかどうかを、指定されたlock_seqidあります。このSEQID値は、ロック所有者シーケンシング/リプレイの問題をチェックするために使用されます。与えられたロック所有者がサーバに知られていない場合、これは新しいロック所有者のための初期シーケンス値を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In the case in which the state has been created and the boolean is false, the only part of the argument other than lock_seqid is just a stateid representing the set of locks associated with that open file and lock-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O状態が作成され、ブーリアンが偽である場合には、lock_seqid以外の引数の一部のみがそのファイルを開き、ロック所有者に関連付けられているロックのセットを表すだけのstateidあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In the case in which the state has been created and the boolean is true, the server rejects the request with the error NFS4ERR_BAD_SEQID. The only exception is where there is a retransmission of a previous request in which the boolean was true. In this case, the lock_seqid will match the original request, and the response will reflect the final case, below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O状態が作成されたブールが真である場合、サーバはエラーNFS4ERR_BAD_SEQIDで要求を拒否する。ブール値がtrueであった中で、前の要求の再送信がある場合は例外です。この場合、lock_seqidは、元の要求と一致し、応答は、以下の最終的なケースを反映します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In the case where no byte-range locking state has been established and the boolean is true, the argument contains an open_to_lock_owner structure that specifies the stateid of the open file and the lock-owner to be used for the lock. Note that although the open-owner is not given explicitly, the open_seqid associated with it is used to check for open-owner sequencing issues. This case provides a method to use the established state of the open_stateid to transition to the use of a lock stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O何バイト範囲ロック状態が確立されていないとブールが真である場合には、引数が開いているファイルののstateidを指定し、ロック所有者がロックに使用するopen_to_lock_owner構造を含んでいます。オープン所有者が明示的に指定されていないが、それに関連付けられopen_seqidがオープン所有者のシーケンスの問題をチェックするために使用されていることに注意してください。この場合は、ロックのstateidの使用に移行するopen_stateidの確立された状態を使用する方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11. Operation 13: LOCKT - Test for Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.16。操作13：ルアー - ロックのテスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh) locktype, offset, length, owner -&gt; {void, NFS4ERR_DENIED -&gt;
     owner}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKT4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           offset4         offset;
           length4         length;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKT4res switch (nfsstat4 status) {
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    case NFS4_OK:
            void;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The LOCKT operation tests the lock as specified in the arguments. If a conflicting lock exists, the owner, offset, length, and type of the conflicting lock are returned; if no lock is held, nothing other than NFS4_OK is returned. Lock types READ_LT and READW_LT are processed in the same way in that a conflicting lock test is done without regard to blocking or non-blocking. The same is true for WRITE_LT and WRITEW_LT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCKT操作は、引数で指定されたロックをテストします。競合するロックが存在する場合、所有者は、競合するロックのオフセット、長さ、およびタイプが戻されます。何もロックが保持されていない場合、NFS4_OK以外何も返されません。ロックタイプREAD_LTとREADW_LTがその矛盾するロックテストで同じように処理されているが、ブロッキングまたは非ブロッキングとは関係なく行われます。同じことがWRITE_LTとWRITEW_LTについても同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
範囲はLOCK用として指定されています。 NFS4ERR_INVALとNFS4ERR_BAD_RANGEエラーがLOCKと同じ状況下で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.11.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. Section 9 contains further discussion of the file locking mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは競合ロックの正確なオフセットと長さを決定することができない場合は、引数に与えたのと同じオフセットと長さが拒否された結果で返されるべきです。第9章では、ファイルロック機構のさらなる議論が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCKT uses a lock_owner4, rather than a stateid4 as is used in LOCK, to identify the owner. This is because the client does not have to open the file to test for the existence of a lock, so a stateid may not be available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCKTはなく所有者を識別するために、LOCKに使用されるstateid4より、lock_owner4を使用します。クライアントはロックが存在するかどうかをテストするためにファイルを開く必要がないので、のstateidは使用できない可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The test for conflicting locks SHOULD exclude locks for the current lock-owner. Note that since such locks are not examined the possible existence of overlapping ranges may not affect the results of LOCKT. If the server does examine locks that match the lock-owner for the purpose of range checking, NFS4ERR_LOCK_RANGE may be returned. In the event that it returns NFS4_OK, clients may do a LOCK and receive NFS4ERR_LOCK_RANGE on the LOCK request because of the flexibility provided to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
競合するロックのためのテストは、現在のロック所有者のためのロックを除外する必要があります。このようなロックが検討されていないので、重複範囲の可能な存在はLOCKTの結果に影響を与えないかもしれないことに留意されたいです。サーバは範囲検査の目的のためにロック所有者と一致ロックを調べていた場合は、NFS4ERR_LOCK_RANGEが返されることがあります。それはNFS4_OKを返したときに、クライアントはLOCKを行うことができますし、ためにサーバに提供される柔軟性のLOCK要求にNFS4ERR_LOCK_RANGEを受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 16.10.5) to handle LOCK requests locally. In such a case, LOCKT requests will similarly be handled locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合は、ローカルでLOCK要求を処理するために（セクション16.10.5を参照）を選択することができます。このような場合には、LOCKT要求は同様にローカルに処理されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12. Operation 14: LOCKU - Unlock File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12。操作14：LOCKU  - ファイルのロックを解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh) type, seqid, stateid, offset, length -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）タイプ、SEQID、のstateid、オフセット、長さ - &gt;のstateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKU4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           seqid4          seqid;
           stateid4        lock_stateid;
           offset4         offset;
           length4         length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKU4res switch (nfsstat4 status) {
    case NFS4_OK:
            stateid4       lock_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The LOCKU operation unlocks the byte-range lock specified by the parameters. The client may set the locktype field to any value that is legal for the nfs_lock_type4 enumerated type, and the server MUST accept any legal value for locktype. Any legal value for locktype has no effect on the success or failure of the LOCKU operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOCKU操作は、パラメータで指定されたバイト範囲ロックを解除します。クライアントはnfs_lock_type4列挙型のために合法的である任意の値にLockTypeのフィールドを設定すること、およびサーバーがのLockTypeのための法的な価値を受け入れなければなりません。 LockTypeのための任意の有効な値はLOCKU操作の成功または失敗には影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
範囲はLOCK用として指定されています。 NFS4ERR_INVALとNFS4ERR_BAD_RANGEエラーがLOCKと同じ状況下で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.12.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the area to be unlocked does not correspond exactly to a lock actually held by the lock-owner, the server may return the error NFS4ERR_LOCK_RANGE. This includes the cases where (1) the area is not locked, (2) the area is a sub-range of the area locked, (3) it overlaps the area locked without matching exactly, or (4) the area specified includes multiple locks held by the lock-owner. In all of these cases, allowed by POSIX locking [fcntl] semantics, a client receiving this error should, if it desires support for such operations, simulate the operation using LOCKU on ranges corresponding to locks it actually holds, possibly followed by LOCK requests for the sub-ranges not being unlocked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロックを解除するための領域が実際にロック所有者が保持しているロックに正確に対応していない場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返すことがあります。これは、（1）領域がロックされていない場合を含む、（2）領域（3）が正確に一致せずにロックされた領域と重なる、または（4）指定された領域が複数含まれ、ロックされた領域のサブ領域でありますロック所有者が保持しているロック。そのような操作をサポートしたい場合これらの場合の全てにおいて、POSIXロック【のfcntl]意味論によって許さ、このエラーを受信したクライアントは、それをロックするために対応する範囲にLOCKUを使用して動作をシミュレートする必要があり、実際に可能性のロック要求に続いて、保持しています小範囲のロックが解除されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 16.10.5) to handle LOCK requests locally. In such a case, LOCKU requests will similarly be handled locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがOPEN_DELEGATE_WRITE委任を保持している場合は、ローカルでLOCK要求を処理するために（セクション16.10.5を参照）を選択することができます。このような場合には、LOCKU要求は同様にローカルに処理されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13. Operation 15: LOOKUP - Look Up Filename
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13。操作15：LOOKUP  - ファイル名を見上げます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), component -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、成分 - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUP4args {
           /* CURRENT_FH: directory */
           component4      objname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUP4res {
           /* CURRENT_FH: object */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation performs a LOOKUP or finds a file system object using the directory specified by the current filehandle. LOOKUP evaluates the component and if the object exists the current filehandle is replaced with the component&#39;s filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作は、ルックアップを実行するか、現在のファイルハンドルによって指定されたディレクトリを使用してファイル・システム・オブジェクトを見つけます。 LOOKUPは、コンポーネントを評価したオブジェクトが存在する場合、現在のファイルハンドルは、コンポーネントのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the component cannot be evaluated because either it does not exist or the client does not have permission to evaluate it, then an error will be returned, and the current filehandle will be unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンポーネントは評価できない場合はどちらかが存在しないか、クライアントがそれを評価する権限を持っていないため、エラーが返され、現在のファイルハンドルは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the component is of zero length, NFS4ERR_INVAL will be returned. The component is also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンポーネントは、長さゼロである場合、NFS4ERR_INVALが返されます。コンポーネントは、通常のUTF-8文字のサポート、および名前のチェックの対象となります。さらなる議論については項12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.13.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client wants to achieve the effect of a multi-component lookup, it may construct a COMPOUND request such as the following (and obtain each filehandle):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、多成分のルックアップの効果を実現したい場合は、次のような複合要求を構築（および各ファイルハンドルを得る）ことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH (directory filehandle) LOOKUP &#34;pub&#34; GETFH LOOKUP &#34;foo&#34; GETFH LOOKUP &#34;bar&#34; GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH（ディレクトリファイルハンドル）LOOKUP &#34;パブ&#34; GETFH LOOKUP &#34;foo&#34; というGETFH LOOKUP &#34;バー&#34; GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4 servers depart from the semantics of previous NFS versions in allowing LOOKUP requests to cross mount points on the server. The client can detect a mount point crossing by comparing the fsid attribute of the directory with the fsid attribute of the directory looked up. If the fsids are different, then the new directory is a server mount point. UNIX clients that detect a mount point crossing will need to mount the server&#39;s file system. This needs to be done to maintain the file object identity-checking mechanisms common to UNIX clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4サーバーは、LOOKUP要求がサーバー上のマウントポイントを横断できるようにするには、以前のNFSバージョンの意味論から出発します。ディレクトリのFSID属性を持つディレクトリのFSID属性を比較することにより、マウントポイントの交差を検出することができ、クライアントは見上げました。 fsidsが異なる場合は、新しいディレクトリがマウントポイントサーバーです。マウントポイントの交差点を検出するUNIXクライアントは、サーバーのファイルシステムをマウントする必要があります。これは、UNIXクライアントに共通のファイルオブジェクトのIDチェックのメカニズムを維持するために行われる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers that limit NFS access to &#34;shares&#34; or &#34;exported&#34; file systems should provide a pseudo-file system into which the exported file systems can be integrated, so that clients can browse the server&#39;s namespace. The clients&#39; view of a pseudo-file system will be limited to paths that lead to exported file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「株式」または「エクスポート」ファイルシステムへのNFSアクセスを制限するサーバは、クライアントがサーバーの名前空間を参照できるように、エクスポートされたファイルシステムは、統合することができますその中に擬似ファイルシステムを提供する必要があります。擬似ファイルシステムのクライアントのビューは、エクスポートされたファイルシステムにつながるパスに制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Previous versions of the protocol assigned special semantics to the names &#34;.&#34; and &#34;..&#34;. NFSv4 assigns no special semantics to these names. The LOOKUPP operator must be used to look up a parent directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：名前に特別な意味を割り当てるプロトコルの以前のバージョン「」そして、 &#34;..&#34;。 NFSv4のは、これらの名前に特別な意味を割り当てません。 LOOKUPP演算子は、親ディレクトリを検索するために使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that this operation does not follow symbolic links. The client is responsible for all parsing of filenames, including filenames that are modified by symbolic links encountered during the lookup process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作はシンボリックリンクをたどらないことに注意してください。クライアントは、ルックアップ・プロセス中に遭遇したシンボリックリンクで変更されたファイル名を含むファイル名のすべての解析、責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the current filehandle supplied is not a directory but a symbolic link, NFS4ERR_SYMLINK is returned as the error. For all other non-directory file types, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
供給される電流のファイルハンドルがディレクトリが、シンボリックリンクではない場合は、NFS4ERR_SYMLINKはエラーとして返されます。他のすべてのディレクトリ以外のファイルタイプの場合は、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14. Operation 16: LOOKUPP - Look Up Parent Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14。操作16：LOOKUPP  - 親ディレクトリをルックアップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh) -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH） - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: object */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUPP4res {
           /* CURRENT_FH: directory */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current filehandle is assumed to refer to a regular directory or a named attribute directory. LOOKUPP assigns the filehandle for its parent directory to be the current filehandle. If there is no parent directory, an NFS4ERR_NOENT error must be returned. Therefore, NFS4ERR_NOENT will be returned by the server when the current filehandle is at the root or top of the server&#39;s file tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルは通常のディレクトリや名前付き属性のディレクトリを参照すると想定されます。 LOOKUPPは、現在のファイルハンドルであることを、その親ディレクトリのファイルハンドルを割り当てます。親ディレクトリが存在しない場合は、NFS4ERR_NOENTエラーが返されなければなりません。現在のファイルハンドルは、ルートまたはサーバーのファイルツリーの最上部にあるときにそのため、NFS4ERR_NOENTは、サーバーによって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.14.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As for LOOKUP, LOOKUPP will also cross mount points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LOOKUPについては、LOOKUPPもマウントポイントを横断します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the current filehandle is not a directory or named attribute directory, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルがディレクトリまたは名前付き属性ディレクトリでない場合は、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the current filehandle is a named attribute directory that is associated with a file system object via OPENATTR (i.e., not a subdirectory of a named attribute directory), LOOKUPP SHOULD return the filehandle of the associated file system object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルがOPENATTRを介してファイル・システム・オブジェクトに関連付けられている名前付き属性のディレクトリである場合（すなわち、指定された属性ディレクトリのサブディレクトリではない）、LOOKUPPは、関連するファイル・システム・オブジェクトのファイルハンドルを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15. Operation 17: NVERIFY - Verify Difference in Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15。操作17：NVERIFY  - 属性の違いを確認してください
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), fattr -&gt; -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、fattr  - &gt;  - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct NVERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct NVERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is used to prefix a sequence of operations to be performed if one or more attributes have changed on some file system object. If all the attributes match, then the error NFS4ERR_SAME must be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作は、1つ以上の属性は、いくつかのファイル・システム・オブジェクトに変更した場合に実行する一連の操作の前に付けるために使用されます。すべての属性が一致する場合、エラーNFS4ERR_SAMEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.15.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is useful as a cache validation operator. If the object to which the attributes belong has changed, then the following operations may obtain new data associated with that object -- for instance, to check if a file has been changed and obtain new data if it has:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作は、キャッシュ検証オペレーターとして有用です。 ：、例えば、ファイルが変更されているかどうかを確認するために、それが持っている場合、新たなデータを取得する - 属性が所属するオブジェクトが変更された場合は、以下の操作は、そのオブジェクトに関連付けられた新しいデータを得ることができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH (public) LOOKUP &#34;foobar&#34; NVERIFY attrbits attrs READ 0 32767
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH（パブリック）LOOKUP &#34;foobarの&#34; NVERIFY attrbits attrsには0 32767をREAD
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case that a RECOMMENDED attribute is specified in the NVERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
推奨属性がNVERIFY操作で指定され、サーバがファイル・システム・オブジェクトのためにその属性をサポートしていない場合は、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the attribute rdattr_error or any write-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性rdattr_errorまたは任意の書き込み専用の属性（例えば、time_modify_set）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16. Operation 18: OPEN - Open a Regular File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16。操作18：OPEN  - は、通常のファイルを開きます。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh), seqid, share_access, share_deny, owner, openhow, claim -&gt;
     (cfh), stateid, cinfo, rflags, attrset, delegation
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Various definitions for OPEN
    */
   enum createmode4 {
           UNCHECKED4      = 0,
           GUARDED4        = 1,
           EXCLUSIVE4      = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union createhow4 switch (createmode4 mode) {
    case UNCHECKED4:
    case GUARDED4:
            fattr4         createattrs;
    case EXCLUSIVE4:
            verifier4      createverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum opentype4 { OPEN4_NOCREATE = 0, OPEN4_CREATE = 1 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙opentype4 {OPEN4_NOCREATE = 0、OPEN4_CREATE = 1}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union openflag4 switch (opentype4 opentype) {
    case OPEN4_CREATE:
            createhow4     how;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Next definitions used for OPEN delegation */
   enum limit_by4 {
           NFS_LIMIT_SIZE          = 1,
           NFS_LIMIT_BLOCKS        = 2
           /* others as needed */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_modified_limit4 {
           uint32_t        num_blocks;
           uint32_t        bytes_per_block;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_space_limit4 switch (limit_by4 limitby) {
    /* limit specified as file size */
    case NFS_LIMIT_SIZE:
            uint64_t               filesize;
    /* limit specified by number of blocks */
    case NFS_LIMIT_BLOCKS:
            nfs_modified_limit4    mod_blocks;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum open_delegation_type4 { OPEN_DELEGATE_NONE = 0, OPEN_DELEGATE_READ = 1, OPEN_DELEGATE_WRITE = 2 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙open_delegation_type4 {OPEN_DELEGATE_NONE = 0、OPEN_DELEGATE_READ = 1、OPEN_DELEGATE_WRITE = 2}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum open_claim_type4 { CLAIM_NULL = 0, CLAIM_PREVIOUS = 1, CLAIM_DELEGATE_CUR = 2, CLAIM_DELEGATE_PREV = 3 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙open_claim_type4 {CLAIM_NULL = 0、CLAIM_PREVIOUS = 1、CLAIM_DELEGATE_CUR = 2、CLAIM_DELEGATE_PREV = 3}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_claim_delegate_cur4 {
           stateid4        delegate_stateid;
           component4      file;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_claim4 switch (open_claim_type4 claim) {
    /*
     * No special rights to file.
     * Ordinary OPEN of the specified file.
     */
    case CLAIM_NULL:
            /* CURRENT_FH: directory */
            component4      file;
    /*
     * Right to the file established by an
     * open previous to server reboot.  File
     * identified by filehandle obtained at
     * that time rather than by name.
     */
    case CLAIM_PREVIOUS:
            /* CURRENT_FH: file being reclaimed */
            open_delegation_type4   delegate_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to file based on a delegation
     * granted by the server.  File is
     * specified by name.
     */
    case CLAIM_DELEGATE_CUR:
            /* CURRENT_FH: directory */
            open_claim_delegate_cur4        delegate_cur_info;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to file based on a delegation
     * granted to a previous boot instance
     * of the client.  File is specified by name.
     */
    case CLAIM_DELEGATE_PREV:
            /* CURRENT_FH: directory */
            component4      file_delegate_prev;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPEN: Open a file, potentially receiving an open delegation
    */
   struct OPEN4args {
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
           open_owner4     owner;
           openflag4       openhow;
           open_claim4     claim;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_read_delegation4 {
    stateid4 stateid;    /* Stateid for delegation */
    bool     recall;     /* Pre-recalled flag for
                            delegations obtained
                            by reclaim (CLAIM_PREVIOUS) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    nfsace4 permissions; /* Defines users who don&#39;t
                            need an ACCESS call to
                            open for read */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_write_delegation4 {
    stateid4 stateid;      /* Stateid for delegation */
    bool     recall;       /* Pre-recalled flag for
                              delegations obtained
                              by reclaim
                              (CLAIM_PREVIOUS) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    nfs_space_limit4
              space_limit; /* Defines condition that
                              the client must check to
                              determine whether the
                              file needs to be flushed
                              to the server on close */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    nfsace4   permissions; /* Defines users who don&#39;t
                              need an ACCESS call as
                              part of a delegated
                              open */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_delegation4 switch
      (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Result flags
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Client must confirm open */
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   /* Type of file locking behavior at the server */
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN4resok {
    stateid4       stateid;      /* Stateid for open */
    change_info4   cinfo;        /* Directory change info */
    uint32_t       rflags;       /* Result flags */
    bitmap4        attrset;      /* attribute set for create */
    open_delegation4 delegation; /* Info on any open
                                    delegation */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
            /* CURRENT_FH: opened file */
            OPEN4resok      resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.4. Warning to Client Implementers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.4。クライアントの実装者に警告
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN resembles LOOKUP in that it generates a filehandle for the client to use. Unlike LOOKUP, though, OPEN creates server state on the filehandle. In normal circumstances, the client can only release this state with a CLOSE operation. CLOSE uses the current filehandle to determine which file to close. Therefore, the client MUST follow every OPEN operation with a GETFH operation in the same COMPOUND procedure. This will supply the client with the filehandle such that CLOSE can be used appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN似ているが、それは、クライアントが使用するファイルハンドルを生成するルックアップ。 LOOKUPとは異なり、しかし、OPENはファイルハンドルの上にサーバの状態を作成します。通常の状況では、クライアントはCLOSE操作で、この状態を解除することができます。 CLOSEは閉鎖するファイルを決定するために、現在のファイルハンドルを使用しています。そのため、クライアントは同じCOMPOUND手順でGETFH操作ですべてのOPEN操作に従わなければなりません。これは、CLOSEを適切に使用することができるように、ファイルハンドルをクライアントに提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Simply waiting for the lease on the file to expire is insufficient because the server may maintain the state indefinitely as long as another client does not attempt to make a conflicting access to the same file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが無期限に限り、別のクライアントが同じファイルへの競合アクセスを作るしようとしないような状態を維持することができるので、単純に期限切れにするファイルのリースを待っていることは不十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.5. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.5。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OPEN operation creates and/or opens a regular file in a directory with the provided name. If the file does not exist at the server and creation is desired, specification of the method of creation is provided by the openhow parameter. The client has the choice of three creation methods: UNCHECKED4, GUARDED4, or EXCLUSIVE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN操作が作成および/または提供された名前のディレクトリにある通常のファイルを開きます。ファイルがサーバーに存在しないと作成を希望する場合、作成方法の指定は、openhowパラメータによって提供されます。 UNCHECKED4、GUARDED4、またはEXCLUSIVE4：クライアントが3つの作成方法の選択肢を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the current filehandle is a named attribute directory, OPEN will then create or open a named attribute file. Note that exclusive create of a named attribute is not supported. If the createmode is EXCLUSIVE4 and the current filehandle is a named attribute directory, the server will return EINVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルが指定された属性ディレクトリである場合、OPENは、名前の属性ファイルを作成または開きます。排他的にサポートされていないという属性を作成することに注意してください。 createmodeがEXCLUSIVE4であり、現在のファイルハンドルが指定された属性ディレクトリである場合、サーバはEINVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNCHECKED4 means that the file should be created if a file of that name does not exist and encountering an existing regular file of that name is not an error. For this type of create, createattrs specifies the initial set of attributes for the file. The set of attributes may include any writable attribute valid for regular files. When an UNCHECKED4 create encounters an existing file, the attributes specified by createattrs are not used, except that when a size of zero is specified, the existing file is truncated. If GUARDED4 is specified, the server checks for the presence of a duplicate object by name before performing the create. If a duplicate exists, an error of NFS4ERR_EXIST is returned as the status. If the object does not exist, the request is performed as described for UNCHECKED4. For each of these cases (UNCHECKED4 and GUARDED4), where the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNCHECKED4は、その名前のファイルが存在しない場合、ファイルが作成されなければならないことを意味し、その名前の既存の通常のファイルに遭遇すると、エラーではありません。作成のこのタイプのため、createattrsは、ファイルの属性の初期セットを指定します。属性のセットは、通常のファイルに有効な任意の書き込み可能な属性を含むことができます。 UNCHECKED4は、既存のファイルの出会いを作成すると、createattrsによって指定された属性は、ゼロのサイズが指定されている場合、既存のファイルが切り捨てられることを除いて、使用されていません。 GUARDED4を作成実行する前に、名前の重複したオブジェクトが存在するサーバーのチェックを指定された場合。重複が存在する場合は、NFS4ERR_EXISTの誤差がステータスとして返されます。オブジェクトが存在しない場合UNCHECKED4について説明したように、要求が行われます。このような場合、操作が成功した（UNCHECKED4とGUARDED4）、のそれぞれについて、サーバがクライアントに正常にオブジェクトに設定された属性の属性マスクの意味を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EXCLUSIVE4 specifies that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. The server should check for the presence of a duplicate object by name. If the object does not exist, the server creates the object and stores the verifier with the object. If the object does exist and the stored verifier matches the verifier provided by the client, the server uses the existing object as the newly created object. If the stored verifier does not match, then an error of NFS4ERR_EXIST is returned. No attributes may be provided in this case, since the server may use an attribute of the target object to store the verifier. If the server uses an attribute to store the exclusive create verifier, it will signify which attribute was used by setting the appropriate bit in the attribute mask that is returned in the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
EXCLUSIVE4は、サーバがターゲットの排他的な作成を確保するために検証を使用して、排他的な作成のセマンティクスに従うことであることを指定します。サーバーは名前で重複したオブジェクトが存在するかどうかをチェックする必要があります。オブジェクトが存在しない場合は、サーバーはオブジェクトを作成し、オブジェクトに検証を保存します。オブジェクトが存在しないと保存された検証は、クライアントが提供する検証と一致した場合、サーバーは、新しく作成されたオブジェクトとして既存のオブジェクトを使用しています。保存された検証が一致しない場合は、NFS4ERR_EXISTのエラーが返されます。サーバーが検証を保存するために、ターゲットオブジェクトの属性を使用することができるので、何の属性が、この場合に設けなくてもよいです。サーバが排他作成、検証を格納する属性を使用している場合、それが結果に返される属性マスクに適切なビットを設定することにより、使用された属性を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ターゲットディレクトリの場合、サーバはcinfoの変化_info4情報を返します。前と後の変更属性がリンク作成に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon successful creation, the current filehandle is replaced by that of the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
作成に成功すると、現在のファイルハンドルは、新しいオブジェクトのものに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OPEN operation provides for Windows share reservation capability with the use of the share_access and share_deny fields of the OPEN arguments. The client specifies at OPEN the required share_access and share_deny modes. For clients that do not directly support SHAREs (i.e., UNIX), the expected deny value is DENY_NONE. In the case that there is an existing share reservation that conflicts with the OPEN request, the server returns the error NFS4ERR_SHARE_DENIED. For a complete SHARE request, the client must provide values for the owner and seqid fields for the OPEN argument. For additional discussion of share semantics, see Section 9.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN操作がOPEN引数のshare_accessとshare_denyフィールドを使用して、Windowsのシェア予約機能を提供します。クライアントは、OPENで必要share_accessとshare_denyモードを指定します。直接株（すなわち、UNIX）をサポートしていないクライアントの場合、期待値はDENY_NONEで否定しています。 OPEN要求と競合する既存の共有の予約がある場合には、サーバがエラーNFS4ERR_SHARE_DENIEDを返します。完全SHARE要求の場合、クライアントがOPEN引数の所有者およびSEQIDフィールドの値を指定する必要があります。共有セマンティクスの追加の議論については、セクション9.9を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case that the client is recovering state from a server failure, the claim field of the OPEN argument is used to signify that the request is meant to reclaim state previously held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがサーバー障害から状態を回復している場合には、OPEN引数の請求フィールドには、要求が以前に開催された状態を取り戻すことを意図していることを意味するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The claim field of the OPEN argument is used to specify the file to be opened and the state information that the client claims to possess. There are four basic claim types that cover the various situations for an OPEN. They are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN引数の請求場がオープンするファイルとクライアントが持っていると主張する状態情報を指定するために使用されます。 OPENのための様々な状況をカバーする四つの基本的な要求の種類があります。それらは次の通りです：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_NULL: For the client, this is a new OPEN request, and there is no previous state associated with the file for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_NULL：クライアントの場合、これは新しいOPENのリクエストで、クライアント用のファイルに関連付けられた以前の状態は存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_PREVIOUS: The client is claiming basic OPEN state for a file that was held previous to a server reboot. This is generally used when a server is returning persistent filehandles; the client may not have the filename to reclaim the OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_PREVIOUS：クライアントは、サーバーの再起動に以前開催されたファイルのための基本的なOPEN状態を主張しています。これは、一般的に、サーバーが永続的なファイルハンドルを返すときに使用されます。クライアントは、OPENを再利用するファイル名を持っていないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_DELEGATE_CUR: The client is claiming a delegation for OPEN as granted by the server. This is generally done as part of recalling a delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_DELEGATE_CUR：サーバーによって付与されたとして、クライアントがOPENのための委任を主張しています。これは、一般的に委任のリコールの一部として行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_DELEGATE_PREV: The client is claiming a delegation granted to a previous client instance. This claim type is for use after a SETCLIENTID_CONFIRM and before the corresponding DELEGPURGE in two situations: after a client reboot and after a lease expiration that resulted in loss of all lock state. The server MAY support CLAIM_DELEGATE_PREV. If it does support CLAIM_DELEGATE_PREV, SETCLIENTID_CONFIRM MUST NOT remove the client&#39;s delegation state, and the server MUST support the DELEGPURGE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLAIM_DELEGATE_PREV：クライアントは、以前のクライアントインスタンスに付与された委任を主張しています。この主張の種類はSETCLIENTID_CONFIRM後との2つの状況での対応DELEGPURGE前に使用するためのものです：クライアントの再起動後に、すべてのロック状態が失われたリース満了後。サーバーはCLAIM_DELEGATE_PREVをサポートするかもしれません。それはCLAIM_DELEGATE_PREVをサポートしている場合、SETCLIENTID_CONFIRMはクライアントの委任状態を削除してはならない、とサーバがDELEGPURGE操作をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following errors apply to use of the CLAIM_DELEGATE_PREV claim type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のエラーがCLAIM_DELEGATE_PREV請求タイプの使用に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NFS4ERR_NOTSUPP is returned if the server does not support this claim type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、この要求の種類をサポートしていない場合はO NFS4ERR_NOTSUPPが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NFS4ERR_INVAL is returned if the reclaim is done at an inappropriate time, e.g., after DELEGPURGE has been done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DELEGPURGEが行われた後に再利用は、例えば、不適切な時間で行われる場合、O NFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o NFS4ERR_BAD_RECLAIM is returned if the other error conditions do not apply and the server has no record of the delegation whose reclaim is being attempted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O他のエラー条件が適用されない場合NFS4ERR_BAD_RECLAIMが返され、サーバーが再利用しようとしている代表団のレコードがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For OPEN requests whose claim type is other than CLAIM_PREVIOUS (i.e., requests other than those devoted to reclaiming opens after a server reboot) that reach the server during its grace or lease expiration period, the server returns an error of NFS4ERR_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その猶予又はリース満了期間中にサーバに到達し、そのクレームタイプCLAIM_PREVIOUS以外のオープン要求（すなわち、再利用に専念以外の要求サーバーの再起動後に開く）ために、サーバはNFS4ERR_GRACEのエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For any OPEN request, the server may return an open delegation, which allows further opens and closes to be handled locally on the client as described in Section 10.4. Note that delegation is up to the server to decide. The client should never assume that delegation will or will not be granted in a particular instance. It should always be prepared for either case. A partial exception is the reclaim (CLAIM_PREVIOUS) case, in which a delegation type is claimed. In this case, delegation will always be granted, although the server may specify an immediate recall in the delegation structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意のOPEN要求の場合、サーバーはさらに可能に開き、セクション10.4で説明したように、クライアント上でローカルに処理されるように閉じ、開いている委譲を返すことがあります。代表団が決定するサーバー次第であることに注意してください。クライアントは、代表団は、または特定のインスタンスで付与されないだろうと想定してはいけません。それは、常にどちらかの場合のために準備する必要があります。部分的な例外は、委譲タイプが記載されて再利用（CLAIM_PREVIOUS）場合、です。サーバが委任構造で即時リコールを指定することもできますが、この場合には、代表団は常に、付与されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The rflags returned by a successful OPEN allow the server to return information governing how the open file is to be handled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功OPENによって返さRFLAGSは、サーバが開いているファイルを処理する方法を規定する情報を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN4_RESULT_CONFIRM indicates that the client MUST execute an OPEN_CONFIRM operation before using the open file. OPEN4_RESULT_LOCKTYPE_POSIX indicates that the server&#39;s file locking behavior supports the complete set of POSIX locking techniques [fcntl]. From this, the client can choose to manage file locking state in such a way as to handle a mismatch of file locking management.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN4_RESULT_CONFIRMは、クライアントが開いているファイルを使用する前に、オープン_CONFIRM操作を実行しなければならないことを示しています。 OPEN4_RESULT_LOCKTYPE_POSIXは、サーバのファイルロック動作が技術[のfcntl]をロックPOSIXの完全なセットをサポートしていることを示しています。このことから、クライアントは、ファイルロック管理の不一致を処理するような方法でファイルのロック状態を管理するために選択することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the component is of zero length, NFS4ERR_INVAL will be returned. The component is also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンポーネントは、長さゼロである場合、NFS4ERR_INVALが返されます。コンポーネントは、通常のUTF-8文字のサポート、および名前のチェックの対象となります。さらなる議論については項12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an OPEN is done and the specified open-owner already has the resulting filehandle open, the result is to &#34;OR&#34; together the new share and deny status, together with the existing status. In this case, only a single CLOSE need be done, even though multiple OPENs were completed. When such an OPEN is done, checking of share reservations for the new OPEN proceeds normally, with no exception for the existing OPEN held by the same owner. In this case, the stateid returned has an &#34;other&#34; field that matches that of the previous open, while the seqid field is incremented to reflect the changed status due to the new open (Section 9.1.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENが行われ、指定されたオープン所有者が既に開いたファイルハンドルを持っている場合、結果は一緒に、既存の状態で、「OR」一緒に新しい共有とステータスを拒否することです。この場合、単一のCLOSEは、複数のOPENsが完了したにもかかわらず、行われる必要があります。そのようなOPENが行われると、同じ所有者が保有する既存のOPENのための例外なく、通常は新しいOPEN収益の共有予約の確認。 SEQIDフィールドが原因新しいオープン（9.1.4項）に変更されたステータスを反映するためにインクリメントされながら、この場合、返されるのstateidは、その前のオープンで一致した「その他」の欄があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the underlying file system at the server is only accessible in a read-only mode and the OPEN request has specified OPEN4_SHARE_ACCESS_WRITE or OPEN4_SHARE_ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-only file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーの基本となるファイルシステムが読み取り専用モードでのみアクセス可能で、OPEN要求がOPEN4_SHARE_ACCESS_WRITEまたはOPEN4_SHARE_ACCESS_BOTHを指定した場合、サーバーは、読み取り専用ファイルシステムを示すためにNFS4ERR_ROFSを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As with the CREATE operation, the server MUST derive the owner, owner ACE, group, or group ACE if any of the four attributes are required and supported by the server&#39;s file system. For an OPEN with the EXCLUSIVE4 createmode, the server has no choice, since such OPEN calls do not include the createattrs field. Conversely, if createattrs is specified and includes owner or group (or corresponding ACEs) that the principal in the RPC&#39;s credentials does not have authorization to create files for, then the server may return NFS4ERR_PERM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4つの属性のいずれかが必要とサーバのファイルシステムによってサポートされている場合は、CREATE操作と同じように、サーバは、所有者、所有者のACE、グループ、またはグループのACEを導出しなければなりません。 EXCLUSIVE4のcreatemodeとOPENの場合、サーバーは、OPEN呼び出しがcreateattrsフィールドが含まれないので、選択の余地はありません。 createattrsは、RPCの資格でプリンシパルがためのファイルを作成する権限を持っていないことを指定し、所有者またはグループ（またはACEを相当）が含まれている場合は逆に、サーバはNFS4ERR_PERMを返すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case where an OPEN specifies a size of zero (e.g., truncation) and the file has named attributes, the named attributes are left as is. They are not removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENがゼロ（例えば、切り捨て）のサイズを指定し、ファイル属性を指名した場合には、名前付き属性はそのまま残されます。彼らは削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.6. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.16.6。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OPEN operation contains support for EXCLUSIVE4 create. The mechanism is similar to the support in NFSv3 [RFC1813]. As in NFSv3, this mechanism provides reliable exclusive creation. Exclusive create is invoked when the how parameter is EXCLUSIVE4. In this case, the client provides a verifier that can reasonably be expected to be unique. A combination of a client identifier, perhaps the client network address, and a unique number generated by the client, perhaps the RPC transaction identifier, may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN操作はEXCLUSIVE4を作成するためのサポートが含まれています。機構はNFSv3の[RFC1813]でサポートと同様です。 NFSv3のと同様に、このメカニズムは、信頼できる排他的な創造を提供します。独占は、どのようにパラメータがEXCLUSIVE4ときに呼び出されます作成します。この場合、クライアントは、合理的に一意であることが期待できる検証を提供します。クライアント識別子の組み合わせ、恐らくクライアントネットワークアドレス、およびクライアントによって生成された固有の番号、恐らくRPCトランザクション識別子は、適切であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the object does not exist, the server creates the object and stores the verifier in stable storage. For file systems that do not provide a mechanism for the storage of arbitrary file attributes, the server may use one or more elements of the object metadata to store the verifier. The verifier must be stored in stable storage to prevent erroneous failure on retransmission of the request. It is assumed that an exclusive create is being performed because exclusive semantics are critical to the application. Because of the expected usage, exclusive create does not rely solely on the normally volatile duplicate request cache for storage of the verifier. The duplicate request cache in volatile storage does not survive a crash and may actually flush on a long network partition, opening failure windows. In the UNIX local file system environment, the expected storage location for the verifier on creation is the metadata (timestamps) of the object. For this reason, an exclusive object create may not include initial attributes because the server would have nowhere to store the verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクトが存在しない場合は、サーバーはオブジェクトを作成し、安定したストレージに検証を保存します。任意のファイル属性を格納するためのメカニズムを提供しないファイルシステムでは、サーバは、検証を格納するオブジェクトのメタデータの1つのまたは複数の要素を使用することができます。検証者は、要求の再送に誤った故障を防ぐために、安定したストレージに格納されなければなりません。排他的な意味はアプリケーションに不可欠であるため、排他が行われて作成することを想定しています。そのため、予想される使用法の、排他的な検証の記憶のため、通常は揮発性の重複要求キャッシュのみに依存しません作成します。揮発性記憶装置内の重複要求キャッシュは、クラッシュを存続しないと、実際に障害の窓を開け、長いネットワークパーティションにフラッシュすることがあります。 UNIXローカル・ファイル・システム環境では、作成時に検証者の期待記憶場所は、オブジェクトのメタデータ（タイムスタンプ）です。このため、排他的なオブジェクトは、サーバには、検証を保存する場所がないでしょう、したがって、初期の属性を含まないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server cannot support these exclusive create semantics, possibly because of the requirement to commit the verifier to stable storage, it should fail the OPEN request with the error NFS4ERR_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはこれらの排他はおそらく安定したストレージへの検証をコミットするための要件の、セマンティクスを作成サポートできない場合は、エラーNFS4ERR_NOTSUPPとOPEN要求を失敗するはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
During an exclusive CREATE request, if the object already exists, the server reconstructs the object&#39;s verifier and compares it with the verifier in the request. If they match, the server treats the request as a success. The request is presumed to be a duplicate of an earlier, successful request for which the reply was lost and that the server duplicate request cache mechanism did not detect. If the verifiers do not match, the request is rejected with the status NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクトがすでに存在する場合、排他的、CREATE要求の間に、サーバーは、オブジェクトの検証を再構築し、要求で検証とそれを比較します。それらが一致した場合、サーバは成功として要求を処理します。要求は応答が失われたとサーバーの重複要求キャッシュメカニズムが検出されなかったことをそのため、以前、成功した要求の重複であると推定されます。検証が一致しない場合、要求はステータスNFS4ERR_EXISTで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once the client has performed a successful exclusive create, it must issue a SETATTR to set the correct object attributes. Until it does so, it should not rely upon any of the object attributes, since the server implementation may need to overload object metadata to store the verifier. The subsequent SETATTR must not occur in the same COMPOUND request as the OPEN. This separation will guarantee that the exclusive create mechanism will continue to function properly in the face of retransmission of the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが作成した排他的な成功を行った後、それが正しいオブジェクトの属性を設定するSETATTRを発行する必要があります。それはそうするまで、サーバの実装は、検証を格納するオブジェクトのメタデータをオーバーロードする必要があるかもしれないので、それは、オブジェクトの属性のいずれかに頼るべきではありません。その後のSETATTRはOPENと同じCOMPOUND要求で発生してはなりません。この分離は、排他的な作成メカニズムは、要求の再送信の顔に適切に機能し続けることを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Use of the GUARDED4 attribute does not provide &#34;exactly-once&#34; semantics. In particular, if a reply is lost and the server does not detect the retransmission of the request, the operation can fail with NFS4ERR_EXIST, even though the create was performed successfully. The client would use this behavior in the case that the application has not requested an exclusive create but has asked to have the file truncated when the file is opened. In the case of the client timing out and retransmitting the create request, the client can use GUARDED4 to prevent a sequence such as create, write, create (retransmitted) from occurring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GUARDED4属性の使用は、「まさにワンス」のセマンティクスを提供していません。回答が失われ、サーバが要求の再送信を検出しない場合は特に、操作が正常に実行されました作成していても、NFS4ERR_EXISTで失敗する可能性があります。クライアントは、アプリケーションが排他的に作成し、要求されていませんが、ファイルを開いたときに切り捨てられたファイルを持っているように頼まれた場合には、この動作を使用します。クライアントのタイムアウトの場合には、要求を作成して再送信、クライアントは、作成、書き込み、発生する（再送信）を作成するようなシーケンスを防止するGUARDED4を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For share reservations (see Section 9.9), the client must specify a value for share_access that is one of OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH. For share_deny, the client must specify one of OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH. If the client fails to do this, the server must return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
株式の予約（セクション9.9を参照）の場合、クライアントはOPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTHの一つであるshare_accessの値を指定する必要があります。 share_denyのために、クライアントはOPEN4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_READ、OPEN4_SHARE_DENY_WRITE、またはOPEN4_SHARE_DENY_BOTHのいずれかを指定する必要があります。クライアントはこれを行うに失敗した場合、サーバーはNFS4ERR_INVALを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Based on the share_access value (OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH), the client should check that the requester has the proper access rights to perform the specified operation. This would generally be the results of applying the ACL access rules to the file for the current requester. However, just as with the ACCESS operation, the client should not attempt to second-guess the server&#39;s decisions, as access rights may change and may be subject to server administrative controls outside the ACL framework. If the requester is not authorized to READ or WRITE (depending on the share_access value), the server must return NFS4ERR_ACCESS. Note that since the NFSv4 protocol does not impose any requirement that READs and WRITEs issued for an open file have the same credentials as the OPEN itself, the server still must do appropriate access checking on the READs and WRITEs themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
share_access値（OPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTH）に基づいて、クライアントは、要求者が指定した操作を実行するための適切なアクセス権を持っていることを確認する必要があります。これは、一般的に、現在の要求者用のファイルにACLのアクセスルールを適用した結果だろう。しかし、単にアクセス動作と同様に、クライアントは、アクセス権が変更される可能性とACLのフレームワーク外部のサーバ管理統制を受ける可能性があるとして、サーバーの決定を第二推測を試みるべきではありません。依頼者は、（share_access値に応じて）読み出しまたは書き込みを許可されていない場合、サーバーはNFS4ERR_ACCESSを返さなければなりません。 NFSv4のプロトコルが読み込み、開いているファイルに対して発行された書き込みはOPEN自体と同じ資格情報を持っているどのような要件を課していないので、サーバはまだ読み込み、自分の書き込みを行うにチェックし、適切なアクセスを行う必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the component provided to OPEN resolves to something other than a regular file (or a named attribute), an error will be returned to the client. If it is a directory, NFS4ERR_ISDIR is returned; otherwise, NFS4ERR_SYMLINK is returned. Note that NFS4ERR_SYMLINK is returned for both symlinks and for special files of other types; NFS4ERR_INVAL would be inappropriate, since the arguments provided by the client were correct, and the client cannot necessarily know at the time it sent the OPEN that the component would resolve to a non-regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENに提供コンポーネントは、通常のファイル（または名前付き属性）以外に解決された場合、エラーがクライアントに返されます。それがディレクトリの場合、NFS4ERR_ISDIRが返されます。そうでない場合は、NFS4ERR_SYMLINKが返されます。 NFS4ERR_SYMLINKは、両方のシンボリックリンク用および他のタイプの特殊ファイルに返されることに注意してください。クライアントが提供する引数が正しかったことからNFS4ERR_INVALは、不適切である、とクライアントは必ずしもコンポーネントが非正規のファイルに解決することをそれがOPENを送った時点で知ることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the current filehandle is not a directory, the error NFS4ERR_NOTDIR will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルがディレクトリでない場合は、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a COMPOUND contains an OPEN that establishes an OPEN_DELEGATE_WRITE delegation, then subsequent GETATTRs normally result in a CB_GETATTR being sent to the client holding the delegation. However, in the case in which the OPEN and GETATTR are part of the same COMPOUND, the server SHOULD understand that the operations are for the same client ID and avoid querying the client, which will not be able to respond. This sequence of OPEN and GETATTR SHOULD be understood to be the retrieval of the size and change attributes at the time of OPEN. Further, as explained in Section 15.2.5, the client should not construct a COMPOUND that mixes operations for different client IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
化合物がOPEN_DELEGATE_WRITE委任を確立OPENが含まれている場合は、その後のGETATTRsは通常、委任を保持しているクライアントに送信されCB_GETATTRになります。しかし、OPENとGETATTRが同じ化合物の一部である場合には、サーバー操作は同じクライアントIDのためのものであることを理解し、対応することができなくなり、クライアントを、照会することは避けてください。 OPENとGETATTRのこの配列は、OPENの時に大きさ及び変化属性の検索であると理解されるべきです。さらに、15.2.5項で説明したように、クライアントは異なるクライアントIDの操作をミックスする化合物を構築するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17. Operation 19: OPENATTR - Open Named Attribute Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17。操作19：OPENATTR  - オープン名前付き属性ディレクトリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh) createdir -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）createdir  - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPENATTR4args {
           /* CURRENT_FH: object */
           bool    createdir;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPENATTR4res {
           /* CURRENT_FH: named attr directory */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OPENATTR operation is used to obtain the filehandle of the named attribute directory associated with the current filehandle. The result of the OPENATTR will be a filehandle to an object of type NF4ATTRDIR. From this filehandle, READDIR and LOOKUP operations can be used to obtain filehandles for the various named attributes associated with the original file system object. Filehandles returned within the named attribute directory will have a type of NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENATTR操作は、現在のファイルハンドルに関連付けられた名前の属性ディレクトリのファイルハンドルを取得するために使用されます。 OPENATTRの結果は、タイプNF4ATTRDIRのオブジェクトへのファイルハンドルであろう。このファイルハンドルから、READDIRとLOOKUP操作は、元のファイル・システム・オブジェクトに関連付けられたさまざまな名前の属性のファイルハンドルを取得するために使用することができます。ファイルハンドルはNF4NAMEDATTRの種類がありますという名前の属性ディレクトリに戻りました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The createdir argument allows the client to signify if a named attribute directory should be created as a result of the OPENATTR operation. Some clients may use the OPENATTR operation with a value of FALSE for createdir to determine if any named attributes exist for the object. If none exist, then NFS4ERR_NOENT will be returned. If createdir has a value of TRUE and no named attribute directory exists, one is created. The creation of a named attribute directory assumes that the server has implemented named attribute support in this fashion and is not required to do so by this definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
createdir引数が指定された属性ディレクトリがOPENATTR操作の結果として作成されなければならない場合、クライアントが意味することができます。任意の名前の属性がオブジェクトのために存在している場合、一部のクライアントが決定するためにcreatedirためFALSEの値でOPENATTR操作を使用することができます。何も存在しない場合、NFS4ERR_NOENTが返されます。 createdirがTRUEの値を持ち、何という名前の属性ディレクトリが存在しない場合は、新たに作成されます。名前の属性ディレクトリの作成は、サーバが、このやり方でという名前の属性のサポートを実装しており、この定義によってそうするために必要とされていないことを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.17.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server does not support named attributes for the current filehandle, an error of NFS4ERR_NOTSUPP will be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、現在のファイルハンドルの名前が付いた属性をサポートしていない場合は、NFS4ERR_NOTSUPPのエラーがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18. Operation 20: OPEN_CONFIRM - Confirm Open
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18。操作20：オープン_CONFIRM  - 確認開きます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), seqid, stateid -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、SEQID、のstateid  - &gt;のstateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_CONFIRM4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_CONFIRM4resok {
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN_CONFIRM4res switch (nfsstat4 status) {
    case NFS4_OK:
            OPEN_CONFIRM4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is used to confirm the sequence id usage for the first time that an open-owner is used by a client. The stateid returned from the OPEN operation is used as the argument for this operation along with the next sequence id for the open-owner. The sequence id passed to the OPEN_CONFIRM must be 1 (one) greater than the seqid passed to the OPEN operation (Section 9.1.4). If the server receives an unexpected sequence id with respect to the original OPEN, then the server assumes that the client will not confirm the original OPEN and all state associated with the original OPEN is released by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この動作は、オープン所有者がクライアントによって使用される最初の時間のシーケンス番号の使用状況を確認するために使用されます。 OPEN操作から返さのstateidはオープン所有者のための次のシーケンスIDとともに、この操作の引数として使用されます。オープン_CONFIRMに渡されたシーケンス番号は、OPEN操作（セクション9.1.4）に渡さSEQIDより1（1）大きくなければなりません。サーバは、元OPENに関して予想外シーケンスIDを受信した場合、サーバは、クライアントがサーバーによって解放され、元のOPENと元OPENに関連するすべての状態を確認しないことを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.18.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A given client might generate many open_owner4 data structures for a given client ID. The client will periodically either dispose of its open_owner4s or stop using them for indefinite periods of time. The latter situation is why the NFSv4 protocol does not have an explicit operation to exit an open_owner4: such an operation is of no use in that situation. Instead, to avoid unbounded memory use, the server needs to implement a strategy for disposing of open_owner4s that have no current open state for any files and have not been used recently. The time period used to determine when to dispose of open_owner4s is an implementation choice. The time period should certainly be no less than the lease time plus any grace period the server wishes to implement beyond a lease time. The OPEN_CONFIRM operation allows the server to safely dispose of unused open_owner4 data structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
与えられたクライアントは、指定されたクライアントIDのための多くのopen_owner4データ構造を生成することがあります。クライアントは、定期的にどちらかのopen_owner4sを処分または無期限の期間のためにそれらを使用して停止します。 NFSv4のプロトコルはopen_owner4を終了するには明示的な操作を持っていない理由は、後者の状況は次のとおりです。そのような操作は、そのような状況では役に立ちません。代わりに、無限のメモリ使用を避けるために、サーバはすべてのファイルには、現在開いている状態を持っていないし、最近使用されていないopen_owner4sの処分のための戦略を実装する必要があります。ときopen_owner4sの処分を決定するために使用される期間は、実装の選択です。期間は確かにリース時間を加えたサーバがリース時間を超えて実施することを希望する任意の猶予期間よりも少なくないはずです。オープン_CONFIRM操作は、サーバーが安全に使用されていないopen_owner4データ構造を処分することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case that a client issues an OPEN operation and the server no longer has a record of the open_owner4, the server needs to ensure that this is a new OPEN and not a replay or retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはもはやOPEN操作して、サーバを発行open_owner4の記録を持っている場合、サーバは、これは再生や再送信、新規OPENとされていないことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers MUST NOT require confirmation on OPENs that grant delegations or are doing reclaim operations. See Section 9.1.11 for details. The server can easily avoid this by noting whether it has disposed of one open_owner4 for the given client ID. If the server does not support delegation, it might simply maintain a single bit that notes whether any open_owner4 (for any client) has been disposed of.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは委託を付与したり再生操作をしているのOPENsの確認を要求してはなりません。詳細については、セクション9.1.11を参照してください。サーバーは簡単にそれが与えられたクライアントIDのために1 open_owner4を処分したかどうかに注目することによってこれを避けることができます。サーバは委任をサポートしていない場合、それは単に（任意のクライアントのための）任意のopen_owner4が破棄されているかどうかを指摘し、単一のビットを維持する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server must hold unconfirmed OPEN state until one of three events occurs. First, the client sends an OPEN_CONFIRM request with the appropriate sequence id and stateid within the lease period. In this case, the OPEN state on the server goes to confirmed, and the open_owner4 on the server is fully established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3つのイベントのいずれかが発生するまで、サーバは未確認OPEN状態を保持しなければなりません。まず、クライアントはリース期間内の適切なシーケンスidとのstateidとのオープン_CONFIRM要求を送信します。この場合、サーバー上のOPEN状態を確認に行くと、サーバー上のopen_owner4が完全に確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Second, the client sends another OPEN request with a sequence id that is incorrect for the open_owner4 (out of sequence). In this case, the server assumes the second OPEN request is valid and the first one is a replay. The server cancels the OPEN state of the first OPEN request, establishes an unconfirmed OPEN state for the second OPEN request, and responds to the second OPEN request with an indication that an OPEN_CONFIRM is needed. The process then repeats itself. While there is a potential for a denial-of-service attack on the client, it is mitigated if the client and server require the use of a security flavor based on Kerberos V5 or some other flavor that uses cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第二に、クライアントは、（シーケンスのうち）open_owner4について間違っているシーケンスIDを持つ別のOPEN要求を送信します。この場合、サーバは、2番目のOPEN要求が有効であるとみなし、最初のものはリプレイです。サーバは、最初のOPEN要求のOPEN状態を解除する第二のOPEN要求の未確認OPEN状態を確立し、オープン_CONFIRMが必要であるという指示を有する第二OPEN要求に応答します。プロセスはその後、自分自身を繰り返します。クライアント上のサービス拒否攻撃の可能性がありますが、クライアントとサーバーがKerberos V5または暗号を使用して、いくつかの他のフレーバーに基づくセキュリティ風味を使用する必要があれば、それが軽減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
What if the server is in the unconfirmed OPEN state for a given open_owner4, and it receives an operation on the open_owner4 that has a stateid but the operation is not OPEN, or it is OPEN_CONFIRM but with the wrong stateid? Then, even if the seqid is correct, the server returns NFS4ERR_BAD_STATEID, because the server assumes the operation is a replay: if the server has no established OPEN state, then there is no way, for example, a LOCK operation could be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どのようなサーバーが指定されたopen_owner4ため未確認OPEN状態にあり、それはたstateidを持っていますが、操作が開いていない、またはそれがオープン_CONFIRMあるopen_owner4ではなく、間違ったstateidを使用して操作を受信した場合？サーバが何の確立OPEN状態を持っていない場合、方法はありません、例えば、LOCK操作が有効である可能性：SEQIDが正しい場合でも、サーバーは操作がリプレイであると仮定しているため、その後、サーバは、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Third, neither of the two aforementioned events occurs for the open_owner4 within the lease period. In this case, the OPEN state is canceled and disposal of the open_owner4 can occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第三に、上記の2つのイベントのどちらもリース期間内open_owner4のために発生します。この場合、OPEN状態が解除され、open_owner4の廃棄が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19。操作21：OPEN_DOWNGRADE  - オープンファイルアクセスを削減
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), stateid, seqid, access, deny -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、のstateid、SEQID、アクセス、拒否 - &gt;のstateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_DOWNGRADE4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_DOWNGRADE4resok {
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN_DOWNGRADE4res switch (nfsstat4 status) {
    case NFS4_OK:
            OPEN_DOWNGRADE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.19.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is used to adjust the share_access and share_deny bits for a given open. This is necessary when a given open-owner opens the same file multiple times with different share_access and share_deny flags. In this situation, a close of one of the opens may change the appropriate share_access and share_deny flags to remove bits associated with opens no longer in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この動作は、指定された開放のためshare_accessとshare_denyビットを調整するために使用されます。与えられたオープン所有者が異なるshare_accessとshare_deny旗と同じファイルを複数回開いたときに、これが必要です。この状況では、開きの一つの近くには有効でなくなった開きに関連するビットを除去するために適切なshare_accessとshare_denyフラグを変更することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The share_access and share_deny bits specified in this operation replace the current ones for the specified open file. The share_access and share_deny bits specified must be exactly equal to the union of the share_access and share_deny bits specified for some subset of the OPENs in effect for the current open-owner on the current file. If that constraint is not respected, the error NFS4ERR_INVAL should be returned. Since share_access and share_deny bits are subsets of those already granted, it is not possible for this request to be denied because of conflicting share reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作で指定share_accessとshare_denyビットが指定されたオープンファイルの現在のものを交換してください。指定share_accessとshare_denyビットは、現在のファイルの現在のオープン所有者のための効果で開きのサブセットに指定share_accessとshare_denyビットの和集合に正確に等しくなければなりません。その制約が尊重されていない場合は、エラーNFS4ERR_INVALが返されます。 share_accessとshare_denyビットが既に許可されたもののサブセットであるので、この要求があるため、競合シェアの予約を拒否されるため、それは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As the OPEN_DOWNGRADE may change a file to be not-open-for-write and a write byte-range lock might be held, the server may have to reject the OPEN_DOWNGRADE with an NFS4ERR_LOCKS_HELD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN_DOWNGRADEがオープンした非書き込みするファイルを変更することができ、書き込みバイト範囲ロックが開催されるかもしれませんが、サーバーはNFS4ERR_LOCKS_HELDでOPEN_DOWNGRADEを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20. Operation 22: PUTFH - Set Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20。操作22：PUTFH  - 設定された現在のファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
filehandle -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルハンドル - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTFH4args {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTFH4res {
           /* CURRENT_FH: */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH replaces the current filehandle with the filehandle provided as an argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFHは、引数として与えられたファイルハンドルと、現在のファイルハンドルを置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the security mechanism used by the requester does not meet the requirements of the filehandle provided to this operation, the server MUST return NFS4ERR_WRONGSEC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
依頼者が使用するセキュリティ・メカニズムは、この操作に提供されるファイルハンドルの要件を満たしていない場合、サーバーはNFS4ERR_WRONGSECを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See Section 15.2.4.1 for more details on the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルの詳細については、セクション15.2.4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.20.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH is commonly used as the first operator in an NFS request to set the context for operations that follow it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFHは、一般的にそれに続く操作のためのコンテキストを設定するNFS要求の最初のオペレータとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21. Operation 23: PUTPUBFH - Set Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21。操作23：PUTPUBFH  - セットの公開ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -   - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTPUBFH4res {
           /* CURRENT_FH: public fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTPUBFH replaces the current filehandle with the filehandle that represents the public filehandle of the server&#39;s namespace. This filehandle may be different from the root filehandle, which may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTPUBFHは、サーバーの名前空間の公開ファイルハンドルを表し、ファイルハンドルと、現在のファイルハンドルを置き換えます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けすることができるルートファイルハンドル、異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The public filehandle concept was introduced in [RFC2054], [RFC2055], and [RFC2224]. The intent for NFSv4 is that the public filehandle (represented by the PUTPUBFH operation) be used as a method of providing compatibility with the WebNFS server of NFSv2 and NFSv3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
公共ファイルハンドルの概念は、[RFC2054]、[RFC2055]、および[RFC2224]で紹介されました。 NFSv4のための意図は、（PUTPUBFH動作によって表される）は、公開ファイルハンドルをのNFSv2とNFSv3ののWebNFSのサーバとの互換性を提供する方法として使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The public filehandle and the root filehandle (represented by the PUTROOTFH operation) should be equivalent. If the public and root filehandles are not equivalent, then the public filehandle MUST be a descendant of the root filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（PUTROOTFH操作によって表される）は、公開ファイルハンドルとルートファイルハンドルは、同等であるべきです。公共とルートファイルハンドルが等しくない場合には、公共ファイルハンドルはルートファイルハンドルの子孫でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.21.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTPUBFH is used as the first operator in an NFS request to set the context for operations that follow it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTPUBFHは、それに続く操作のためのコンテキストを設定するNFS要求の最初のオペレータとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the NFSv2 and NFSv3 public filehandle, the client is able to specify whether the pathname provided in the LOOKUP should be evaluated as either an absolute path relative to the server&#39;s root or relative to the public filehandle. [RFC2224] contains further discussion of the functionality. With NFSv4, that type of specification is not directly available in the LOOKUP operation. The reason for this is because the component separators needed to specify absolute versus relative are not allowed in NFSv4. Therefore, the client is responsible for constructing its request such that either PUTROOTFH or PUTPUBFH is used to signify absolute or relative evaluation of an NFS URL, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv2とNFSv3の公共ファイルハンドルを使用すると、クライアントはLOOKUPで提供パス名は、サーバのルートからの相対または公共ファイルハンドルからの相対、絶対パスのいずれかのように評価されるべきかどうかを指定することができます。 [RFC2224]は機能のさらなる議論を含んでいます。 NFSv4ではでは、仕様のそのタイプはLOOKUP操作で直接使用できません。相対対絶対指定するために必要な成分セパレータはNFSv4のに許可されていないためです。そのため、クライアントはPUTROOTFHまたはPUTPUBFHいずれかがそれぞれ、NFS URLの絶対的または相対的な評価を示すために使用されるようにその要求を構築するための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that there are warnings mentioned in [RFC2224] with respect to the use of absolute evaluation and the restrictions the server may place on that evaluation with respect to how much of its namespace has been made available. These same warnings apply to NFSv4. It is likely, therefore, that because of server implementation details an NFSv3 absolute public filehandle lookup may behave differently than an NFSv4 absolute resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
絶対評価の使用に関して、[RFC2224]で述べた警告とサーバが利用可能になってきたどのくらいその名前空間のに対し、評価の上に置くことの制限があることに注意してください。これらの同じ警告はNFSv4のに適用されます。これは、サーバーの実装の詳細を表示するため、NFSv3の絶対的な公共ファイルハンドル・ルックアップはNFSv4の絶対的な解像度とは異なる動作をする場合がありということ、そのため、可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is a form of security negotiation as described in [RFC2755] that uses the public filehandle as a method of employing the Simple and Protected GSS-API Negotiation Mechanism (SNEGO) [RFC4178]. This method is not available with NFSv4, as filehandles are not overloaded with special meaning and therefore do not provide the same framework as NFSv2 and NFSv3. Clients should therefore use the security negotiation mechanisms described in this RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単純で保護GSS-APIネゴシエーションメカニズム（SNEGO）[RFC4178]を使用する方法として公共ファイルハンドルを使用して、[RFC2755]に記載されているようにセキュリティネゴシエーションの形態があります。ファイルハンドルは特別な意味を持つオーバーロードされないためのNFSv2とNFSv3のと同じフレームワークを提供していないので、この方法では、NFSv4では使用できません。クライアントは、それゆえ、このRFCで説明されているセキュリティ交渉メカニズムを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22. Operation 24: PUTROOTFH - Set Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22。操作24：PUTROOTFH  - セットのルートファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -   - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTROOTFH4res {
           /* CURRENT_FH: root fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTROOTFH replaces the current filehandle with the filehandle that represents the root of the server&#39;s namespace. From this filehandle, a LOOKUP operation can locate any other filehandle on the server. This filehandle may be different from the public filehandle, which may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTROOTFHは、サーバーの名前空間のルートを表すファイルハンドルと、現在のファイルハンドルを置き換えます。このファイルハンドルから、LOOKUP操作は、サーバー上の他のファイルハンドルを見つけることができます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けすることができる公共ファイルハンドル、異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See Section 15.2.4.1 for more details on the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルの詳細については、セクション15.2.4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.22.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTROOTFH is commonly used as the first operator in an NFS request to set the context for operations that follow it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTROOTFHは、一般的にそれに続く操作のためのコンテキストを設定するNFS要求の最初のオペレータとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23. Operation 25: READ - Read from File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23。操作25：READ  - ファイルから読み込みます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), stateid, offset, count -&gt; eof, data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、のstateid、オフセットは、カウント - &gt; EOF、データ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ4resok {
           bool            eof;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READ4res switch (nfsstat4 status) {
    case NFS4_OK:
            READ4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The READ operation reads data from the regular file identified by the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ操作は、現在のファイルハンドルで識別される通常のファイルからデータを読み込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client provides an offset of where the READ is to start and a count of how many bytes are to be read. An offset of 0 (zero) means to read data starting at the beginning of the file. If the offset is greater than or equal to the size of the file, the status, NFS4_OK, is returned with a data length set to 0 (zero), and eof is set to TRUE. The READ is subject to access permissions checking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはREADが開始することで、どのように多くのバイト数を読み取ることがどこのオフセットを提供します。 0（ゼロ）のオフセットをファイルの先頭から始まるデータを読み取ることを意味します。オフセットよりも大きいかまたはファイルのサイズに等しい場合、ステータス、NFS4_OKは、0（ゼロ）に設定されたデータ長で返され、EOFがTRUEに設定されています。 READは、チェックアクセス許可の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client specifies a count value of 0 (zero), the READ succeeds and returns 0 (zero) bytes of data (subject to access permissions checking). The server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、0（ゼロ）のカウント値を指定した場合、READは成功し、データの0（ゼロ）バイト（チェックアクセス許可の対象）を返します。サーバーは、クライアントによって指定されたよりも少ないバイト数を返すように選択することができます。クライアントは、この状態を確認し、適切な条件を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The stateid value for a READ request represents a value returned from a previous byte-range lock or share reservation request, or the stateid associated with a delegation. The stateid is used by the server to verify that the associated share reservation and any byte-range locks are still valid and to update lease timeouts for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ要求のためのstateid値は、以前のバイト範囲ロックまたは共有の予約要求、又は委任に関連付けられたstateidから返された値を表します。 stateidは、関連する株式の予約と任意のバイト範囲ロックがまだ有効であることを確認するために、クライアントのリースのタイムアウトを更新するためにサーバによって使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the READ ended at the end-of-file (formally, in a correctly formed READ request, if offset + count is equal to the size of the file), or the READ request extends beyond the size of the file (if offset + count is greater than the size of the file), eof is returned as TRUE; otherwise, it is FALSE. A successful READ of an empty file will always return eof as TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（オフセット+カウントは、ファイルのサイズと等しい場合、正しく形成さREAD要求で、正式に）、または+オフセットがREAD要求は（ファイルのサイズを超えて拡張READはファイルの終わりで終了した場合カウントは、EOFがTRUEとして返され、）ファイルのサイズよりも大きいです。それ以外の場合はFALSEです。空のファイルの成功READは常にEOFとしてTRUEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the current filehandle is not a regular file, an error will be returned to the client. In the case where the current filehandle represents a directory, NFS4ERR_ISDIR is returned; otherwise, NFS4ERR_INVAL is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルが通常のファイルでない場合は、エラーがクライアントに返されます。現在のファイルハンドルがディレクトリを表す場合には、NFS4ERR_ISDIRが返されます。そうでない場合は、NFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a READ using the special anonymous stateid, the server MAY allow the READ to be serviced subject to mandatory file locks or the current share_deny modes for the file. For a READ using the special READ bypass stateid, the server MAY allow READ operations to bypass locking checks at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別な匿名たstateidを使用してREADの場合、サーバーは、READが必須のファイルロックまたはファイルの現在のshare_denyモードの対象にサービスを提供できるようにすることができます。特別READバイパスのstateidを使用して読み取るために、サーバは、READ操作はサーバにロックチェックをバイパスすることを可能にし得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.23.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server returns a &#34;short read&#34; (i.e., less data than requested and eof is set to FALSE), the client should send another READ to get the remaining data. A server may return less data than requested under several circumstances. The file may have been truncated by another client or perhaps on the server itself, changing the file size from what the requesting client believes to be the case. This would reduce the actual amount of data available to the client. It is possible that the server reduces the transfer size and so returns a short read result. Server resource exhaustion may also result in a short read.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは「短い読み取り」（要求されたとEOFがFALSEに設定されているよりも、すなわち、少ないデータ）を返した場合、クライアントは残りのデータを取得するために別のREADを送信する必要があります。サーバーには、いくつかの状況下で要求されたよりも少ないデータを返すことがあります。ファイルが要求しているクライアントは、ケースのように信じているから、ファイルサイズを変更し、別のクライアントによって、またはおそらく、サーバー自体に切り捨てられている可能性があります。これは、クライアントが利用可能なデータの実際の量を減少させるであろう。サーバーが転送サイズを削減し、短いので、読み取り結果を返すことも可能です。サーバーリソースの枯渇も短い読み取りをもたらすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If mandatory byte-range locking is in effect for the file, and if the byte range corresponding to the data to be read from the file is WRITE_LT locked by an owner not associated with the stateid, the server will return the NFS4ERR_LOCKED error. The client should try to get the appropriate READ_LT via the LOCK operation before re-attempting the READ. When the READ completes, the client should release the byte-range lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必須のバイト範囲ロックは、ファイルのための有効であり、データに対応するバイト範囲がファイルから読み出される場合のstateidに関連付けられていない所有者によってロックWRITE_LTされている場合、サーバはNFS4ERR_LOCKEDエラーを返します。クライアントはREADを再試行する前にLOCK操作を経由して、適切なREAD_LTを取得しようとする必要があります。 READが完了すると、クライアントはLOCKU経由バイト範囲ロックを解除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If another client has an OPEN_DELEGATE_WRITE delegation for the file being read, the delegation must be recalled, and the operation cannot proceed until that delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding. Normally, delegations will not be recalled as a result of a READ operation, since the recall will occur as a result of an earlier OPEN. However, since it is possible for a READ to be done with a special stateid, the server needs to check for this case even though the client should have done an OPEN previously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別のクライアントが読み込まれるファイルのOPEN_DELEGATE_WRITE委任を持っている場合は、委任をリコールする必要があり、その代表団が返さまたは取り消されるまで操作を続行できません。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。リコールは、以前のOPENの結果として発生しますので、通常、代表団は、READ操作の結果としてリコールされることはありません。 READは、特別なstateidで行われることが可能であるので、サーバーは、クライアントが以前にOPENを行っている必要があるにもかかわらず、このような場合のためにチェックする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24. Operation 26: READDIR - Read Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24。操作26：READDIR  - 読むディレクトリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     (cfh), cookie, cookieverf, dircount, maxcount, attr_request -&gt;
     cookieverf { cookie, name, attrs }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READDIR4args {
           /* CURRENT_FH: directory */
           nfs_cookie4     cookie;
           verifier4       cookieverf;
           count4          dircount;
           count4          maxcount;
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct entry4 {
           nfs_cookie4     cookie;
           component4      name;
           fattr4          attrs;
           entry4          *nextentry;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dirlist4 {
           entry4          *entries;
           bool            eof;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READDIR4resok {
           verifier4       cookieverf;
           dirlist4        reply;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READDIR4res switch (nfsstat4 status) {
    case NFS4_OK:
            READDIR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The READDIR operation retrieves a variable number of entries from a file system directory and for each entry returns attributes that were requested by the client, along with information to allow the client to request additional directory entries in a subsequent READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READDIR操作は、ファイル・システム・ディレクトリのエントリの可変数を検索し、エントリごとにクライアントがその後のREADDIRに追加のディレクトリエントリを要求することを可能にする情報とともに、クライアントから要求された属性を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The arguments contain a cookie value that represents where the READDIR should start within the directory. A value of 0 (zero) for the cookie is used to start reading at the beginning of the directory. For subsequent READDIR requests, the client specifies a cookie value that is provided by the server in a previous READDIR request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数はREADDIRがディレクトリ内の開始すべき場所を表すクッキー値が含まれています。 Cookieの0（ゼロ）の値は、ディレクトリの始めに読み始めるために使用されます。その後のREADDIR要求の場合、クライアントは前のREADDIR要求でサーバーから提供されたクッキーの値を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cookieverf value should be set to 0 (zero) when the cookie value is 0 (zero) (first directory read). On subsequent requests, it should be a cookieverf as returned by the server. The cookieverf must match that returned by the READDIR in which the cookie was acquired. If the server determines that the cookieverf is no longer valid for the directory, the error NFS4ERR_NOT_SAME must be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クッキー値が0（ゼロ）である場合にcookieverf値（最初のディレクトリは、読み取り）0（ゼロ）に設定されるべきです。後続の要求では、サーバで返すようにcookieverfでなければなりません。 cookieverfはクッキーが取得されたREADDIRによって返されたものと一致する必要があります。サーバはにcookieverfは、もはや有効なディレクトリのためではないと判断した場合、エラーNFS4ERR_NOT_SAMEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The dircount portion of the argument is a hint of the maximum number of bytes of directory information that should be returned. This value represents the length of the names of the directory entries and the cookie value for these entries. This length represents the XDR encoding of the data (names and cookies) and not the length in the native format of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数のdircount部分が返されるべきであるディレクトリ情報のバイトの最大数のヒントです。この値は、ディレクトリエントリとこれらのエントリのクッキー値の名前の長さを表しています。この長さは、XDRデータ（名前およびクッキー）の符号化ではなく、サーバのネイティブフォーマットにおける長さを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The maxcount value of the argument is the maximum number of bytes for the result. This maximum size represents all of the data being returned within the READDIR4resok structure and includes the XDR overhead. The server may return less data. If the server is unable to return a single directory entry within the maxcount limit, the error NFS4ERR_TOOSMALL will be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数のMAXCOUNT値は、結果の最大バイト数です。この最大サイズはREADDIR4resok構造内に返されるすべてのデータを表し、XDRオーバーヘッドを含みます。サーバーは、少ないデータを返すことがあります。サーバがMAXCOUNT限度内の単一のディレクトリエントリを返すことができない場合は、エラーNFS4ERR_TOOSMALLがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finally, attr_request represents the list of attributes to be returned for each directory entry supplied by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後に、attr_requestは、サーバによって供給される各ディレクトリエントリのために返される属性のリストを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On successful return, the server&#39;s response will provide a list of directory entries. Each of these entries contains the name of the directory entry, a cookie value for that entry, and the associated attributes as requested. The &#34;eof&#34; flag has a value of TRUE if there are no more entries in the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功のリターンで、サーバの応答は、ディレクトリエントリのリストを提供します。要求に応じてこれらの各エントリには、ディレクトリエントリ、そのエントリのクッキー値、および関連する属性の名前が含まれています。ディレクトリには複数のエントリが存在しない場合は、「EOF」フラグがTRUEの値を持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cookie value is only meaningful to the server and is used as a &#34;bookmark&#34; for the directory entry. As mentioned, this cookie is used by the client for subsequent READDIR operations so that it may continue reading a directory. The cookie is similar in concept to a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クッキー値は、サーバーにのみ意味があり、ディレクトリエントリの「しおり」として使用されています。前述のように、それはディレクトリを読み続けることができるように、このクッキーは、その後のREADDIR操作のためにクライアントによって使用されます。クッキーは、とコンセプトが似ています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ offset but should not be interpreted as such by the client. The server SHOULD try to accept cookie values issued with READDIR responses even if the directory has been modified between the READDIR calls but MAY return NFS4ERR_NOT_VALID if this is not possible, as might be the case if the server has rebooted in the interim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READは、オフセットが、クライアントによってそのように解釈すべきではありません。サーバーは、ディレクトリがREADDIRの呼び出しの間で変更された場合でも、READDIR応答して発行されたクッキー値を受け入れるように試みるべきであるが、これが不可能な場合は、サーバーが暫定的に再起動した場合場合であるかもしれないとして、NFS4ERR_NOT_VALIDを返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In some cases, the server may encounter an error while obtaining the attributes for a directory entry. Instead of returning an error for the entire READDIR operation, the server can instead return the attribute &#39;fattr4_rdattr_error&#39;. With this, the server is able to communicate the failure to the client and not fail the entire operation in the instance of what might be a transient failure. Obviously, the client must request the fattr4_rdattr_error attribute for this method to work properly. If the client does not request the attribute, the server has no choice but to return failure for the entire READDIR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディレクトリエントリの属性を取得しながら、いくつかのケースでは、サーバがエラーが発生することがあります。代わりに、全体のREADDIR操作のためのエラーを返すので、サーバーではなく、属性「fattr4_rdattr_error」を返すことができます。これにより、サーバはクライアントに障害が発生して通信し、一時的な障害であるかもしれないもののインスタンスで全体の動作を失敗しないことが可能です。もちろん、クライアントは正常に動作するために、このメソッドのfattr4_rdattr_error属性を要求する必要があります。クライアントが属性を要求しない場合、サーバは全体のREADDIR操作のために失敗を返すしかありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For some file system environments, the directory entries &#34;.&#34; and &#34;..&#34; have special meaning, and in other environments, they may not. If the server supports these special entries within a directory, they should not be returned to the client as part of the READDIR response. To enable some client environments, the cookie values of 0, 1, and 2 are to be considered reserved. Note that the UNIX client will use these values when combining the server&#39;s response and local representations to enable a fully formed UNIX directory presentation to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのファイルシステム環境では、ディレクトリエントリ「」そして、「..」は特別な意味を持っており、他の環境では、彼らはないかもしれません。サーバーは、ディレクトリ内のこれらの特別項目をサポートしている場合、彼らはREADDIR応答の一部としてクライアントに返すべきではありません。いくつかのクライアント環境を有効にするには、0、1、および2のクッキー値は、予約された考慮されるべきです。アプリケーションに完全に形成されたUNIXディレクトリのプレゼンテーションを可能にするために、サーバーの応答とローカル表現を組み合わせる場合、UNIXクライアントはこれらの値を使用することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For READDIR arguments, cookie values of 1 and 2 SHOULD NOT be used, and for READDIR results, cookie values of 0, 1, and 2 MUST NOT be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READDIRの引数の場合、1と2のクッキー値が使用されるべきではなく、及びREADDIR結果、クッキーの値を0、1、2が返されてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.24.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server&#39;s file system directory representations can differ greatly. A client&#39;s programming interfaces may also be bound to the local operating environment in a way that does not translate well into the NFS protocol. Therefore, the dircount and maxcount fields are provided to allow the client the ability to provide guidelines to the server. If the client is aggressive about attribute collection during a READDIR, the server has an idea of how to limit the encoded response. The dircount field provides a hint on the number of entries based solely on the names of the directory entries. Since it is a hint, it may be possible that a dircount value is zero. In this case, the server is free to ignore the dircount value and return directory information based on the specified maxcount value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバのファイルシステムのディレクトリ表現は大きく異なることができます。クライアントのプログラミング・インタフェースは、NFSプロトコルにうまく変換されないように、ローカルの動作環境に結合させることができます。したがって、dircountとMAXCOUNTフィールドは、クライアントにサーバーへの指針を提供する能力を可能にするために提供されています。クライアントは、READDIR時の属性コレクションについて積極的である場合、サーバーはエンコードされた応答を制限する方法のアイデアを持っています。 dircountフィールドは、単にディレクトリエントリの名前に基づいてエントリの数にヒントを提供します。それはヒントなので、dircount値がゼロであることが可能であってもよいです。この場合、サーバはdircount値を無視し、指定されたMAXCOUNT値に基づいて、ディレクトリ情報を返すために自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As there is no way for the client to indicate that a cookie value, once received, will not be subsequently used, server implementations should avoid schemes that allocate memory corresponding to a returned cookie. Such allocation can be avoided if the server bases cookie values on a value such as the offset within the directory where the scan is to be resumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、一度、受け取ったクッキー値は、その後に使用されないことを示す方法はありませんように、サーバの実装は、返されたクッキーに対応したメモリを割り当てるスキームを避ける必要があります。スキャンが再開されるディレクトリ内のオフセットのような割り当ては、そのような値上のサーバベースのクッキー値場合に回避することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cookies generated by such techniques should be designed to remain valid despite modification of the associated directory. If a server were to invalidate a cookie because of a directory modification, READDIRs of large directories might never finish.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような技術によって生成されたクッキーは、関連するディレクトリの変更にもかかわらず、有効なままに設計する必要があります。サーバがあるため、ディレクトリの変更のクッキーを無効にした場合、大きなディレクトリのREADDIRsが終了しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a directory is deleted after the client has carried out one or more READDIR operations on the directory, the cookies returned will become invalid; however, the server does not need to be concerned, as the directory filehandle used previously would have become stale and would be reported as such on subsequent READDIR operations. The server would not need to check the cookie verifier in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがディレクトリ上の一つ以上のREADDIR操作を実施した後に、ディレクトリが削除された場合、返されたクッキーが無効になります。しかし、サーバが以前に使用したディレクトリのファイルハンドルが古くなっているだろうと、後続のREADDIR操作上のように報告されるように、心配する必要はありません。サーバーは、この場合にはクッキーの検証をチェックする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, certain reorganization operations on a directory (including directory compaction) may invalidate READDIR cookies previously given out. When such a situation occurs, the server should modify the cookie verifier so as to disallow the use of cookies that would otherwise no longer be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、（ディレクトリ圧縮を含む）のディレクトリに特定の再編成操作は、以前に配らREADDIRクッキーを無効にすることができます。このような状況が発生した場合は、特に有効でなくなり、クッキーの使用を禁止するように、サーバは、クッキーの検証を変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cookieverf may be used by the server to help manage cookie values that may become stale. It should be a rare occurrence that a server is unable to continue properly reading a directory with the provided cookie/cookieverf pair. The server should make every effort to avoid this condition since the application at the client may not be able to properly handle this type of failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cookieverfは古くなる可能性がクッキー値の管理を支援するためにサーバが使用することができます。これは、サーバーが提供するクッキー/にcookieverfペアでディレクトリを読み、適切に継続することができないまれな出来事でなければなりません。サーバーは、クライアントのアプリケーションが正常にこのタイプの障害を処理することができない場合がありますので、この状態を回避するためにあらゆる努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The use of the cookieverf will also protect the client from using READDIR cookie values that may be stale. For example, if the file system has been migrated, the server may or may not be able to use the same cookie values to service READDIR as the previous server used. With the client providing the cookieverf, the server is able to provide the appropriate response to the client. This prevents the case where the server may accept a cookie value but the underlying directory has changed and the response is invalid from the client&#39;s context of its previous READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cookieverfの使用も古いかもしれREADDIRクッキー値を使用してからクライアントを保護します。ファイルシステムが移行された場合、例えば、サーバは、または使用前サーバーとしてREADDIRにサービスを提供するために、同じクッキー値を使用することであってもなくてもよいです。クライアントがにcookieverfを提供すると、サーバはクライアントに適切な応答を提供することができます。これは、サーバがクッキー値を受け入れるかもしれませんが、基本となるディレクトリが変更されたとの応答がその前のREADDIRのクライアントの文脈から無効である場合を防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since some servers will not be returning &#34;.&#34; and &#34;..&#34; entries as has been done with previous versions of the NFS protocol, the client that requires these entries be present in READDIR responses must fabricate them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのサーバは戻ることはありませんので、「」そして、「..」エントリNFSプロトコルの以前のバージョンで行われているように、これらのエントリはREADDIR応答に存在することが必要とするクライアントは、それらを製作しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25. Operation 27: READLINK - Read Symbolic Link
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25。操作27：READLINK  - シンボリックリンクを読みます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh) -&gt; linktext
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH） - &gt;リンクテキスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: symlink */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READLINK4resok {
           linktext4       link;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READLINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            READLINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READLINK reads the data associated with a symbolic link. The data is a UTF-8 string that is opaque to the server. That is, whether created by an NFS client or created locally on the server, the data in a symbolic link is not interpreted when created but is simply stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READLINKは、シンボリックリンクに関連付けられたデータを読み込みます。データはサーバに不透明であるUTF-8文字列です。これは、NFSクライアントによって作成されたか、サーバー上でローカルに作成され、シンボリックリンクのデータが作成されるときに解釈されていませんが、単純に記憶されているかどうか、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.25.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A symbolic link is nominally a pointer to another file. The data is not necessarily interpreted by the server; it is just stored in the file. It is possible for a client implementation to store a pathname that is not meaningful to the server operating system in a symbolic link. A READLINK operation returns the data to the client for interpretation. If different implementations want to share access to symbolic links, then they must agree on the interpretation of the data in the symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シンボリックリンクは、名目上は別のファイルへのポインタです。データは、必ずしもサーバによって解釈されません。それは単にファイルに格納されています。クライアントの実装がシンボリックリンクで、サーバーのオペレーティングシステムには意味がありませんパス名を保存することが可能です。 READLINK操作は、解釈のために、クライアントにデータを返します。異なる実装がシンボリックリンクへのアクセスを共有したい場合は、それらはシンボリックリンクでのデータの解釈に同意しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The READLINK operation is only allowed on objects of type NF4LNK. The server should return the error NFS4ERR_INVAL if the object is not of type NF4LNK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READLINK操作は、タイプがNF4LNKのオブジェクトに許可されています。オブジェクトの型がNF4LNKでない場合、サーバーはエラーNFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26. Operation 28: REMOVE - Remove File System Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26。操作28：REMOVE  - ファイルシステムオブジェクトを削除します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), filename -&gt; change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、ファイル名 - &gt; change_info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct REMOVE4args {
           /* CURRENT_FH: directory */
           component4      target;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct REMOVE4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union REMOVE4res switch (nfsstat4 status) {
    case NFS4_OK:
            REMOVE4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The REMOVE operation removes (deletes) a directory entry named by filename from the directory corresponding to the current filehandle. If the entry in the directory was the last reference to the corresponding file system object, the object may be destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
REMOVE操作は、現在のファイルハンドルに対応するディレクトリからファイル名で指定されたディレクトリエントリを削除（消去します）。ディレクトリ内のエントリは、対応するファイル・システム・オブジェクトへの最後の参照であった場合、オブジェクトが破棄されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the directory where the filename was removed, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the removal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイル名が削除されたディレクトリのために、サーバはcinfoの変化_info4情報を返します。前と後の変更属性が除去に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the target is of zero length, NFS4ERR_INVAL will be returned. The target is also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ターゲットの長さがゼロである場合、NFS4ERR_INVALが返されます。ターゲットは、通常のUTF-8文字のサポート、および名前のチェックの対象となります。さらなる議論については項12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.26.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv3 required a different operator -- RMDIR -- for directory removal, and REMOVE for non-directory removal. This allowed clients to skip checking the file type when being passed a non-directory delete system call (e.g., unlink() [unlink] in POSIX) to remove a directory, as well as the converse (e.g., a rmdir() on a non-directory), because they knew the server would check the file type. NFSv4 REMOVE can be used to delete any directory entry, independent of its file type. The implementer of an NFSv4 client&#39;s entry points from the unlink() and rmdir() system calls should first check the file type against the types the system call is allowed to remove before issuing a REMOVE. Alternatively, the implementer can produce a COMPOUND call that includes a LOOKUP/VERIFY sequence to verify the file type before a REMOVE operation in the same COMPOUND call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RMDIR  -   -  NFSv3のは、別のオペレータ必要なディレクトリを除去するために、非ディレクトリの除去のために削除します。これは上のディレクトリだけでなく、その逆（例えば、RMDIR（）を削除するには非ディレクトリは、システムコールを削除渡されるとき、クライアントが（例えば、POSIXで[リンク解除]）（リンク解除）ファイルの種類をチェックするスキップすることができ非ディレクトリ）、彼らは、サーバーがファイルの種類を確認することを知っていたので。 NFSv4 REMOVEは、そのファイルの種類とは無関係に、任意のディレクトリエントリを削除するために使用することができます。リンク解除（）とは、rmdir（）システムコールからのNFSv4クライアントのエントリポイントの実装者は、最初のシステムコールがREMOVEを発行する前に削除することが許可されているタイプに対してファイルの種類を確認する必要があります。代替として、実装者は、同じ化合物の呼び出しでREMOVE操作の前にファイルの種類を確認するために配列を検証/ LOOKUPを含む化合物のコールを生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The concept of last reference is server specific. However, if the numlinks field in the previous attributes of the object had the value 1, the client should not rely on referring to the object via a filehandle. Likewise, the client should not rely on the resources (disk space, directory entry, and so on) formerly associated with the object becoming immediately available. Thus, if a client needs to be able to continue to access a file after using REMOVE to remove it, the client should take steps to make sure that the file will still be accessible. The usual mechanism used is to RENAME the file from its old name to a new hidden name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後の参照の概念は、サーバ固有のものです。オブジェクトの前の属性でnumlinksフィールドが値1を持っていた場合は、クライアントがファイルハンドルを経由してオブジェクトを参照するに頼るべきではありません。同様に、クライアントは以前すぐに利用可能になってきたオブジェクトに関連付けられたリソース（ディスク容量、ディレクトリエントリなど）に依存しないでください。クライアントは、それを削除するREMOVEを使用した後、ファイルへのアクセスを継続できるようにする必要がある場合はこのように、クライアントは、ファイルがまだアクセス可能になることを確認する手順を実行する必要があります。使用される通常のメカニズムは、新しい隠された名前に古い名前からファイルの名前を変更することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server finds that the file is still open when the REMOVE arrives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、REMOVEが到着したときにファイルがまだ開いていることを発見した場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server SHOULD NOT delete the file&#39;s directory entry if the file was opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれた場合、Oサーバは、ファイルのディレクトリエントリを削除しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the file was not opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, the server SHOULD delete the file&#39;s directory entry. However, until the last CLOSE of the file, the server MAY continue to allow access to the file via its filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれていない場合は、O、サーバーは、ファイルのディレクトリエントリを削除する必要があります。ただし、ファイルの最後のCLOSEまで、サーバーはそのファイルハンドルを経由してファイルへのアクセスを許可し続けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27. Operation 29: RENAME - Rename Directory Entry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27。操作29：RENAME  - ディレクトリエントリの名前を変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(sfh), oldname, (cfh), newname -&gt; source_cinfo, target_cinfo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（SFH）、OLDNAME、（CFH）、NEWNAME  - &gt; source_cinfo、target_cinfo
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENAME4args {
           /* SAVED_FH: source directory */
           component4      oldname;
           /* CURRENT_FH: target directory */
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENAME4resok {
           change_info4    source_cinfo;
           change_info4    target_cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union RENAME4res switch (nfsstat4 status) {
    case NFS4_OK:
            RENAME4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The RENAME operation renames the object identified by oldname in the source directory corresponding to the saved filehandle, as set by the SAVEFH operation, to newname in the target directory corresponding to the current filehandle. The operation is required to be atomic to the client. Source and target directories must reside on the same file system on the server. On success, the current filehandle will continue to be the target directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルに対応するターゲットディレクトリにnewnameに、SAVEFH操作によって設定さRENAME操作は、保存されたファイルハンドルに対応するソースディレクトリにOLDNAMEによって識別されたオブジェクトの名前を変更します。操作は、クライアント原子であることが必要です。ソースとターゲットのディレクトリには、サーバー上の同じファイルシステム上に存在する必要があります。成功すると、現在のファイルハンドルは、ターゲットディレクトリであり続けるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the target directory already contains an entry with the name newname, the source object must be compatible with the target: either both are non-directories, or both are directories, and the target must be empty. If compatible, the existing target is removed before the rename occurs (see Section 16.26 for client and server actions whenever a target is removed). If they are not compatible or if the target is a directory but not empty, the server will return the error NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ターゲットディレクトリが既に名前NEWNAMEのエントリが含まれている場合は、ソースオブジェクトがターゲットと互換性がなければならない：両方が非ディレクトリであるか、あるいは両方がディレクトリであり、ターゲットは空である必要があります。名前の変更が発生する前に、既存のターゲットが削除された互換性のある場合（ターゲットが削除されるたびに、クライアントとサーバーのアクションのセクション16.26を参照してください）。彼らは互換性がないか、ターゲットがディレクトリが、空でない場合ならば、サーバはエラーNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If oldname and newname both refer to the same file (they might be hard links of each other), then RENAME should perform no action and return success.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OLDNAMEとnewnameの両方が同じファイルを参照する場合は、何もアクションを実行しないと成功を返す必要がありRENAME（彼らはお互いのハードリンクであるかもしれません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For both directories involved in the RENAME, the server returns change_info4 information. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the rename.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RENAMEにかかわる両方のディレクトリの場合、サーバーは変化_info4情報を返します。前と後の変更属性が名前の変更に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the oldname refers to a named attribute and the saved and current filehandles refer to the named attribute directories of different file system objects, the server will return NFS4ERR_XDEV, just as if the saved and current filehandles represented directories on different file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OLDNAMEという名前の属性を参照し、保存され、現在のファイルハンドルは異なるファイル・システム・オブジェクトの名前付き属性のディレクトリを参照する場合、サーバーが保存され、現在のファイルハンドルは異なるファイルシステム上のディレクトリを表すかのように、NFS4ERR_XDEVを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the oldname or newname is of zero length, NFS4ERR_INVAL will be returned. The oldname and newname are also subject to the normal UTF-8, character support, and name checks. See Section 12.7 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OLDNAMEまたはNEWNAMEの長さがゼロである場合、NFS4ERR_INVALが返されます。 OLDNAMEとnewnameのは、通常のUTF-8文字のサポート、および名前のチェックの対象となります。さらなる議論については項12.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.27.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The RENAME operation must be atomic to the client. The statement &#34;source and target directories must reside on the same file system on the server&#34; means that the fsid fields in the attributes for the directories are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RENAME操作はクライアントにアトミックでなければなりません。声明「ソースとターゲットのディレクトリサーバー上の同じファイルシステム上に存在する必要があり、」ディレクトリの属性におけるFSIDフィールドが同じであることを意味します。彼らは異なるファイルシステム上に存在する場合は、エラーNFS4ERR_XDEVが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Based on the value of the fh_expire_type attribute for the object, the filehandle may or may not expire on a RENAME. However, server implementers are strongly encouraged to attempt to keep filehandles from expiring in this fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクトのfh_expire_type属性の値に基づいて、ファイルハンドルは、名前の変更には有効期限が切れていない場合があります。ただし、サーバーの実装者は強く、この方法で期限切れからファイルハンドルを維持しようとすることが奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On some servers, the filenames &#34;.&#34; and &#34;..&#34; are illegal as either oldname or newname and will result in the error NFS4ERR_BADNAME. In addition, on many servers the case of oldname or newname being an alias for the source directory will be checked for. Such servers will return the error NFS4ERR_INVAL in these cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のサーバーでは、ファイル名「」そして、「..」OLDNAMEかnewnameのいずれかとして違法であるとのエラーNFS4ERR_BADNAMEになります。また、多くのサーバ上OLDNAMEまたはnewnameのソースディレクトリの別名であることの場合は、チェックされます。このようなサーバは、これらの場合にエラーNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If either of the source or target filehandles are not directories, the server will return NFS4ERR_NOTDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースまたはターゲットファイルハンドルのいずれかがディレクトリでない場合、サーバはNFS4ERR_NOTDIRを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28. Operation 30: RENEW - Renew a Lease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28。操作30：RENEW  - リースを更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
clientid -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientIDを - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENEW4args {
           clientid4       clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENEW4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The RENEW operation is used by the client to renew leases that it currently holds at a server. In processing the RENEW request, the server renews all leases associated with the client. The associated leases are determined by the clientid provided via the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RENEW操作は、それが現在のサーバで保持しているリースを更新するために、クライアントによって使用されます。 RENEW要求を処理するには、サーバーは、クライアントに関連付けられているすべてのリースを更新します。関連リースはSETCLIENTID操作を介して提供されるクライアントIDによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.28.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client holds delegations, it needs to use RENEW to detect when the server has determined that the callback path is down. When the server has made such a determination, only the RENEW operation will renew the lease on delegations. If the server determines the callback path is down, it returns NFS4ERR_CB_PATH_DOWN. Even though it returns NFS4ERR_CB_PATH_DOWN, the server MUST renew the lease on the byte-range locks and share reservations that the client has established on the server. If for some reason the lock and share reservation lease cannot be renewed, then the server MUST return an error other than NFS4ERR_CB_PATH_DOWN, even if the callback path is also down. In the event that the server has conditions such that it could return either NFS4ERR_CB_PATH_DOWN or NFS4ERR_LEASE_MOVED, NFS4ERR_LEASE_MOVED MUST be handled first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが代表団を保持しているときは、サーバーがコールバックパスがダウンしていると判断したときを検出するためにRENEWを使用する必要があります。サーバは、このような決意をしたときに、唯一のRENEW操作は代表団のリースを更新します。サーバーがコールバックパスがダウンしていると判断した場合、それはNFS4ERR_CB_PATH_DOWNを返します。それはNFS4ERR_CB_PATH_DOWNを返すにもかかわらず、サーバーは、クライアントがサーバー上で確立しているバイト範囲ロックと共有の予約にリースを更新しなければなりません。何らかの理由でロックと共有予約のリースを更新することができない場合、サーバは、コールバックパスがダウンしても場合でも、NFS4ERR_CB_PATH_DOWN以外のエラーを返さなければなりません。サーバはそれがNFS4ERR_CB_PATH_DOWNまたはNFS4ERR_LEASE_MOVEDのいずれかを返すことができるような条件を持っている場合には、NFS4ERR_LEASE_MOVEDは、最初に処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client that issues RENEW MUST choose the principal, RPC security flavor, and, if applicable, GSS-API mechanism and service via one of the following algorithms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
問題はRENEWクライアントは、次のアルゴリズムのうちの1つを介して、プリンシパルを選択するRPCセキュリティ風味、及び、該当する場合、GSS-APIメカニズムとサービスをしなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client uses the same principal, RPC security flavor, and -- if the flavor was RPCSEC_GSS -- the same mechanism and service that were used when the client ID was established via SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントが同じプリンシパルを使用して、RPCセキュリティ風味、および - クライアントIDがSETCLIENTID_CONFIRMを介して確立された際に使用したのと同じメカニズム及びサービス - 味がRPCSEC_GSSた場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client uses any principal, RPC security flavor, mechanism, and service combination that currently has an OPEN file on the server. That is, the same principal had a successful OPEN operation; the file is still open by that principal; and the flavor, mechanism, and service of RENEW match that of the previous OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントは現在、サーバー上のファイルを開いているすべての主要な、RPCセキュリティ風味、メカニズム、およびサービスの組み合わせを使用しています。これは、同じ主体が成功OPEN操作を持っていた、です。ファイルには、その元本でまだ開いています。そして、の風味、メカニズム、およびサービスは、その前のOPENの試合をRENEW。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MUST reject a RENEW that does not use one of the aforementioned algorithms, with the error NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーはエラーNFS4ERR_ACCESSで、前述のアルゴリズムのいずれかを使用しないことRENEWを拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29. Operation 31: RESTOREFH - Restore Saved Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29。操作31：RESTOREFH  - 保存されたファイルハンドルを復元
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(sfh) -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（SFH） - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* SAVED_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RESTOREFH4res {
           /* CURRENT_FH: value of saved fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Set the current filehandle to the value in the saved filehandle. If there is no saved filehandle, then return the error NFS4ERR_RESTOREFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
保存されたファイルハンドルの値に現在のファイルハンドルを設定します。何も保存されたファイルハンドルが存在しない場合、エラーNFS4ERR_RESTOREFHを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.29.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operations like OPEN and LOOKUP use the current filehandle to represent a directory and replace it with a new filehandle. Assuming that the previous filehandle was saved with a SAVEFH operator, the previous filehandle can be restored as the current filehandle. This is commonly used to obtain post-operation attributes for the directory, e.g.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENとLOOKUPのような操作は、ディレクトリを表し、新しいファイルハンドルでそれを置き換えるために、現在のファイルハンドルを使用します。以前のファイルハンドルをSAVEFHオペレータで保存されたと仮定すると、以前のファイルハンドルは、現在のファイルハンドルとして復元することができます。これは、一般的に、術後は、例えば、ディレクトリの属性を取得するために使用されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH (directory filehandle) SAVEFH GETATTR attrbits (pre-op dir attrs) CREATE optbits &#34;foo&#34; attrs GETATTR attrbits (file attributes) RESTOREFH GETATTR attrbits (post-op dir attrs)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH（ディレクトリのファイルハンドル）SAVEFH GETATTRのattrbits（術前DIR attrsに）CREATE optbits &#34;foo&#34; というattrsにはattrbits（ファイル属性）RESTOREFH GETATTRのattrbitsをGETATTR（術後DIR attrsに）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30. Operation 32: SAVEFH - Save Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30。操作32：SAVEFH  - 保存現在のファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh) -&gt; (sfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH） - &gt;（SFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SAVEFH4res {
           /* SAVED_FH: value of current fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Save the current filehandle. If a previous filehandle was saved, then it is no longer accessible. The saved filehandle can be restored as the current filehandle with the RESTOREFH operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルを保存します。以前のファイルハンドルを保存した場合、それはアクセスできなくなります。保存されたファイルハンドルはRESTOREFH演算子で、現在のファイルハンドルとして復元することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.30.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31. Operation 33: SECINFO - Obtain Available Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31。操作33：SECINFO  - 利用可能なセキュリティを取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), name -&gt; { secinfo }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、名前 - &gt; {} SECINFO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SECINFO4args {
           /* CURRENT_FH: directory */
           component4      name;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * From RFC 2203
    */
   enum rpc_gss_svc_t {
           RPC_GSS_SVC_NONE        = 1,
           RPC_GSS_SVC_INTEGRITY   = 2,
           RPC_GSS_SVC_PRIVACY     = 3
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rpcsec_gss_info {
           sec_oid4        oid;
           qop4            qop;
           rpc_gss_svc_t   service;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* RPCSEC_GSS has a value of &#39;6&#39;.  See RFC 2203 */
   union secinfo4 switch (uint32_t flavor) {
    case RPCSEC_GSS:
            rpcsec_gss_info        flavor_info;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef secinfo4 SECINFO4resok&lt;&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefのsecinfo4 SECINFO4resok &lt;&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SECINFO4res switch (nfsstat4 status) {
    case NFS4_OK:
            SECINFO4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SECINFO operation is used by the client to obtain a list of valid RPC authentication flavors for a specific directory filehandle, filename pair. SECINFO should apply the same access methodology used for LOOKUP when evaluating the name. Therefore, if the requester does not have the appropriate access to perform a LOOKUP for the name, then SECINFO must behave the same way and return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SECINFO操作は特定のディレクトリのファイルハンドルのための有効なRPC認証味、ファイル名のペアのリストを取得するために、クライアントによって使用されます。名前を評価するときSECINFOは、LOOKUPのために使用したのと同じアクセス方法論を適用する必要があります。依頼者は、名前のルックアップを実行するための適切なアクセス権を持っていない場合、したがって、その後、SECINFO同じように動作し、NFS4ERR_ACCESSを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The result will contain an array that represents the security mechanisms available, with an order corresponding to the server&#39;s preferences, the most preferred being first in the array. The client is free to pick whatever security mechanism it both desires and supports, or to pick -- in the server&#39;s preference order -- the first one it supports. The array entries are represented by the secinfo4 structure. The field &#39;flavor&#39; will contain a value of AUTH_NONE, AUTH_SYS (as defined in [RFC5531]), or RPCSEC_GSS (as defined in [RFC2203]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
結果が最も好ましいが、アレイ内の最初であり、サーバの好みに対応する順序で、セキュリティメカニズムが利用可能で表す配列を含むであろう。それがサポートする最初の1  - サーバーの優先順位で - クライアントは、どんなセキュリティメカニズム、それの両方の欲望とサポートを選択するか、選択する自由です。アレイエントリはsecinfo4構造によって表されます。フィールド &#39;風味&#39;（[RFC2203]で定義されるように）AUTH_NONE、AUTH_SYS（[RFC5531]で定義される）の値を含む、またはRPCSEC_GSSう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the flavors AUTH_NONE and AUTH_SYS, no additional security information is returned. For a return value of RPCSEC_GSS, a security triple is returned that contains the mechanism object id (as defined in [RFC2743]), the quality of protection (as defined in [RFC2743]), and the service type (as defined in [RFC2203]). It is possible for SECINFO to return multiple entries with flavor equal to RPCSEC_GSS, with different security triple values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
味AUTH_NONEおよびAUTH_SYSの場合は、追加のセキュリティ情報が返されません。 RPCSEC_GSSの戻り値を、三重セキュリティはそれは[RFC2203で定義されている機構のオブジェクトID（[RFC2743]で定義されるように）、保護の品質（[RFC2743]で定義されるように）、およびサービスタイプを（含ま戻されます]）。 SECINFOが異なるセキュリティトリプル値で、RPCSEC_GSSに等しい味で複数のエントリを返すことが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the name has a length of 0 (zero), or if the name does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前は、0（ゼロ）の長さを持っている場合は名前がUTF-8定義に従わない場合、または、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.31.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SECINFO operation is expected to be used by the NFS client when the error value of NFS4ERR_WRONGSEC is returned from another NFS operation. This signifies to the client that the server&#39;s security policy is different from what the client is currently using. At this point, the client is expected to obtain a list of possible security flavors and choose what best suits its policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SECINFO操作はNFS4ERR_WRONGSECのエラー値が別のNFS操作から返されたNFSクライアントによって使用されることが期待されます。これは、サーバーのセキュリティポリシーは、クライアントが現在使用しているものと異なっていることをクライアントに示します。この時点で、クライアントが可能なセキュリティ風味のリストを取得し、最高のは、そのポリシーに合ったものを選択することが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As mentioned, the server&#39;s security policies will determine when a client request receives NFS4ERR_WRONGSEC. The operations that may receive this error are LINK, LOOKUP, LOOKUPP, OPEN, PUTFH, PUTPUBFH, PUTROOTFH, RENAME, RESTOREFH, and, indirectly, READDIR. LINK and RENAME will only receive this error if the security used for the operation is inappropriate for the saved filehandle. With the exception of READDIR, these operations represent the point at which the client can instantiate a filehandle into the current filehandle at the server. The filehandle is either provided by the client (PUTFH, PUTPUBFH, PUTROOTFH) or generated as a result of a name-to-filehandle translation (LOOKUP and OPEN). RESTOREFH is different because the filehandle is a result of a previous SAVEFH. Even though the filehandle, for RESTOREFH, might have previously passed the server&#39;s inspection for a security match, the server will check it again on RESTOREFH to ensure that the security policy has not changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前述のように、クライアントの要求がNFS4ERR_WRONGSECを受信したときに、サーバーのセキュリティポリシーが決定されます。このエラーが発生する可能性のある操作はLINK、LOOKUP、LOOKUPP、OPEN、PUTFH、PUTPUBFH、PUTROOTFH、RENAME、RESTOREFH、および、間接的、READDIRです。操作のために使用されるセキュリティは、保存されたファイルハンドルに不適切な場合LINKとRENAMEのみ、このエラーが発生します。 READDIRを除いて、これらの操作は、クライアントがサーバーでの現在のファイルハンドルにファイルハンドルをインスタンス化することができた時点を表します。ファイルハンドルは、いずれかのクライアント（PUTFH、PUTPUBFH、PUTROOTFH）によって提供されるか、または名前からファイルハンドル翻訳（LOOKUPとOPEN）の結果として生成されます。ファイルハンドルが前SAVEFHの結果であるため、RESTOREFHが異なっています。ファイルハンドルは、RESTOREFHのために、以前にセキュリティの試合のために、サーバーの検査に合格した場合でも、サーバーは、セキュリティポリシーが変更されていないことを確認するためにRESTOREFHに再びそれをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client wants to resolve an error return of NFS4ERR_WRONGSEC, the following will occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはNFS4ERR_WRONGSECのエラーリターンを解決したい場合は、次のことが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For LOOKUP and OPEN, the client will use SECINFO with the same current filehandle and name as provided in the original LOOKUP or OPEN to enumerate the available security triples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
利用可能なセキュリティトリプルを列挙するために、元のLOOKUPまたはOPENで提供されるO LOOKUPとOPENの場合、クライアントは同じ電流ファイルハンドルと名前をSECINFOを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For LINK, PUTFH, RENAME, and RESTOREFH, the client will use SECINFO and provide the parent directory filehandle and the object name that corresponds to the filehandle originally provided by the PUTFH or RESTOREFH, or, for LINK and RENAME, the SAVEFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O LINKについて、PUTFH、RENAME、およびRESTOREFHは、クライアントがSECINFOを使用して、元々PUTFHまたはRESTOREFHが提供するファイルハンドルに対応親ディレクトリのファイルハンドルとオブジェクト名を指定する、または、LINKのための名前の変更、SAVEFHます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o For LOOKUPP, PUTROOTFH, and PUTPUBFH, the client will be unable to use the SECINFO operation since SECINFO requires a current filehandle and none exist for these three operations. Therefore, the client must iterate through the security triples available at the client and re-attempt the PUTROOTFH or PUTPUBFH operation. In the unfortunate event that none of the MANDATORY security triples are supported by the client and server, the client SHOULD try using others that support integrity. Failing that, the client can try using AUTH_NONE, but because such forms lack integrity checks, this puts the client at risk. Nonetheless, the server SHOULD allow the client to use whatever security form the client requests and the server supports, since the risks of doing so are on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SECINFO現在のファイルハンドルを必要とし、いずれもこれら3つの動作のために存在しないため、O LOOKUPP、PUTROOTFH、及びPUTPUBFHために、クライアントはSECINFO操作を使用することができません。そのため、クライアントは、クライアントで利用可能なセキュリティトリプルと再試行しPUTROOTFHまたはPUTPUBFH操作を繰り返し処理しなければなりません。 MANDATORYセキュリティトリプルのどれもが、クライアントとサーバによってサポートされていないことを不幸な出来事では、クライアントは、整合性をサポートする他の人を使用してみてください。それに失敗すると、クライアントはAUTH_NONEを使用して試すことができますが、このようなフォームは、整合性チェックがないため、これは危険でクライアントを置きます。それにもかかわらず、サーバーは、クライアントがそうすることのリスクは、クライアント上にあることから、クライアントの要求とサーバのサポートを形成するものは何でもセキュリティを使用できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The READDIR operation will not directly return the NFS4ERR_WRONGSEC error. However, if the READDIR request included a request for attributes, it is possible that the READDIR request&#39;s security triple does not match that of a directory entry. If this is the case and the client has requested the rdattr_error attribute, the server will return the NFS4ERR_WRONGSEC error in rdattr_error for the entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READDIR操作は直接NFS4ERR_WRONGSECエラーを返しません。 READDIR要求が属性を要求が含まれている場合しかし、READDIR要求のセキュリティはトリプルディレクトリエントリと一致しないことも可能です。このような場合は、クライアントがrdattr_error属性を要求した場合、サーバはエントリのrdattr_errorにNFS4ERR_WRONGSECエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that a server MAY use the AUTH_NONE flavor to signify that the client is allowed to attempt to use authentication flavors that are not explicitly listed in the SECINFO results. Instead of using a listed flavor, the client might then, for instance, opt to use an otherwise unlisted RPCSEC_GSS mechanism instead of AUTH_NONE. It may wish to do so in order to meet an application requirement for data integrity or privacy. In choosing to use an unlisted flavor, the client SHOULD always be prepared to handle a failure by falling back to using AUTH_NONE or another listed flavor. It cannot assume that identity mapping is supported and should be prepared for the fact that its identity is squashed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、クライアントが明示的にSECINFO結果に表示されていない認証タイプを使用しようとすることが許可されていることを意味するAUTH_NONE風味を使用することができることに注意してください。代わりにリストされた風味を使用すると、クライアントはその後、例えば、代わりにAUTH_NONEのそれ以外の場合は非上場RPCSEC_GSSメカニズムを使用することを選ぶかもしれません。これは、データの整合性やプライバシーのためのアプリケーション要件を満たすためにそうすることを望むかもしれません。非上場のフレーバーを使用することを選択する際に、クライアントは常にバックAUTH_NONEか、別の列挙された風味を使用する落下による故障を処理するために準備する必要があります。これは、そのIDマッピングがサポートされており、そのアイデンティティが押しつぶされているという事実のために準備されるべきであると仮定することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See Section 19 for a discussion on the recommendations for security flavors used by SECINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SECINFOで使用されるセキュリティの味のための勧告に関する議論については、セクション19を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32. Operation 34: SETATTR - Set Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32。操作34：SETATTR  - 属性セット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), stateid, attrmask, attr_vals -&gt; attrsset
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、のstateid、attrmask、attr_vals  - &gt; attrsset
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETATTR4args {
           /* CURRENT_FH: target object */
           stateid4        stateid;
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETATTR4res {
           nfsstat4        status;
           bitmap4         attrsset;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SETATTR operation changes one or more of the attributes of a file system object. The new attributes are specified with a bitmap and the attributes that follow the bitmap in bit order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTR操作は、ファイル・システム・オブジェクトの属性の一つ以上を変更します。新しい属性は、ビットマップとビット順にビットマップに従った属性で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The stateid argument for SETATTR is used to provide byte-range locking context that is necessary for SETATTR requests that set the size attribute. Since setting the size attribute modifies the file&#39;s data, it has the same locking requirements as a corresponding WRITE. Any SETATTR that sets the size attribute is incompatible with a share reservation that specifies OPEN4_SHARE_DENY_WRITE. The area between the old end-of-file and the new end-of-file is considered to be modified just as would have been the case had the area in question been specified as the target of WRITE, for the purpose of checking conflicts with byte-range locks, for those cases in which a server is implementing mandatory byte-range locking behavior. A valid stateid SHOULD always be specified. When the file size attribute is not set, the special anonymous stateid MAY be passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTRのためのstateid引数は、サイズ属性を設定するSETATTR要求するために必要なバイト範囲ロックのコンテキストを提供するために使用されます。サイズ属性を設定すると、ファイルのデータを変更するので、それは、対応するWRITEと同じロッキング要件があります。サイズ属性を設定し、任意のSETATTRはOPEN4_SHARE_DENY_WRITEを指定シェア予約と互換性がありません。問題の領域はWRITEの対象として指定されていた場合であったであろうと、古いファイルの終わりと新しいファイルの終端との間の領域は、との衝突をチェックする目的のために、単に変更されていると考えられますサーバは必須バイト範囲ロック動作を実現しているような場合のためにバイト範囲ロック、。有効なstateidは必ず指定する必要があります。ファイルサイズ属性が設定されていない場合は、特別な匿名のstateidを渡すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On either success or failure of the operation, the server will return the attrsset bitmask to represent what (if any) attributes were successfully set. The attrsset in the response is a subset of the bitmap4 that is part of the obj_attributes in the argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性正常に設定された（もしあれば）は、操作の成功または失敗のいずれかで、サーバが何を表現するためにattrssetビットマスクを返します。応答attrssetは、引数でobj_属性の一部であるbitmap4のサブセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.32.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the request specifies the owner attribute to be set, the server SHOULD allow the operation to succeed if the current owner of the object matches the value specified in the request. Some servers may be implemented in such a way as to prohibit the setting of the owner attribute unless the requester has the privilege to do so. If the server is lenient in this one case of matching owner values, the client implementation may be simplified in cases of creation of an object (e.g., an exclusive create via OPEN) followed by a SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求を設定する所有者属性を指定している場合、サーバーはオブジェクトの現在の所有者がリクエストで指定された値と一致した場合、操作が成功できるようにする必要があります。一部のサーバーは、要求者がそうする権限を持っていない限り、所有者属性の設定を禁止するような方法で実施することができます。サーバが一致する所有者値のこの一つの場合に寛大である場合、クライアントの実装はSETATTR続くオブジェクト（例えば、排他的ではOPENを介して作成）の作成の場合に簡素化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The file size attribute is used to request changes to the size of a file. A value of zero causes the file to be truncated, a value less than the current size of the file causes data from the new size to the end of the file to be discarded, and a size greater than the current size of the file causes logically zeroed data bytes to be added to the end of the file. Servers are free to implement this using holes or actual zero data bytes. Clients should not make any assumptions regarding a server&#39;s implementation of this feature, beyond that the bytes returned will be zeroed. Servers MUST support extending the file size via SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルサイズ属性は、ファイルのサイズの変更を要求するために使用されます。ゼロの値は、ファイルがファイルの現在のサイズより小さい値を廃棄するファイルの末尾に新たなサイズのデータ​​を生じ、切り捨て、およびファイルの現在のサイズよりも大きいサイズを論理的に生じさせますファイルの末尾に追加されるデータのバイト数をゼロに。サーバはこの使用して穴や実際のゼロデータのバイト数を自由に実装できます。クライアントは、返されたバイトがゼロにされることを超えて、この機能のサーバの実装に関するいかなる仮定を行うべきではありません。サーバはSETATTRを経由してファイルサイズを拡張サポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTR is not guaranteed atomic. A failed SETATTR may partially change a file&#39;s attributes -- hence, the reason why the reply always includes the status and the list of attributes that were set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTRは原子保証されません。失敗したSETATTRは、部分的にファイルの属性を変更すること - それゆえ、応答が常にステータスと設定された属性のリストが含まれている理由を。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the object whose attributes are being changed has a file delegation that is held by a client other than the one doing the SETATTR, the delegation(s) must be recalled, and the operation cannot proceed to actually change an attribute until each such delegation is returned or revoked. In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while the delegation(s) remains outstanding, although it might not do that if the delegations are returned quickly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性が変更されているオブジェクトがSETATTRをやっ以外のクライアントによって保持されているファイルの委任がある場合は、代表団（S）がリコールされている必要があり、このような各代表団があるまで、操作は、実際の属性を変更するために進むことができません返却または取り消します。代表団がリコールされているすべての場合において、サーバは、委任（s）は、優れたまま、それは代表団がすぐに返される場合があることを行うではないかもしれないが、一つ以上のNFS4ERR_DELAYエラーを返す可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Changing the size of a file with SETATTR indirectly changes the time_modify and change attributes. A client must account for this, as size changes can result in data deletion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETATTRとファイルのサイズを変更すると、間接的にtime_modifyと変更属性を変更します。サイズの変更は、データの削除につながることができますように、クライアントは、このことを考慮しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The attributes time_access_set and time_modify_set are write-only attributes constructed as a switched union so the client can direct the server in setting the time values. If the switched union specifies SET_TO_CLIENT_TIME4, the client has provided an nfstime4 to be used for the operation. If the switch union does not specify SET_TO_CLIENT_TIME4, the server is to use its current time for the SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性time_access_setとtime_modify_setは、クライアントが時間値を設定することで、サーバーに指示することができるように切り替え組合として構成書き込み専用属性です。切り替え組合がSET_TO_CLIENT_TIME4を指定した場合、クライアントは、操作に使用するnfstime4を提供してきました。スイッチ組合がSET_TO_CLIENT_TIME4を指定しない場合、サーバはSETATTR操作のために、現在の時刻を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If server and client times differ, programs that compare client times to file times can break. A time maintenance protocol should be used to limit client/server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーとクライアントの時間が異なる場合は、回を提出し、クライアントの時間を比較するプログラムを破ることができます。タイムメンテナンスプロトコルは、クライアント/サーバ時間スキューを制限するために使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Use of a COMPOUND containing a VERIFY operation specifying only the change attribute, immediately followed by a SETATTR, provides a means whereby a client may specify a request that emulates the functionality of the SETATTR guard mechanism of NFSv3. Since the function of the guard mechanism is to avoid changes to the file attributes based on stale information, delays between checking of the guard condition and the setting of the attributes have the potential to compromise this function, as would the corresponding delay in the NFSv4 emulation. Therefore, NFSv4 servers should take care to avoid such delays, to the degree possible, when executing such a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すぐにSETATTRが続くだけ変化属性を指定して検証動作を含む化合物の使用は、クライアントがNFSv3ののSETATTRガード機構の機能をエミュレート要求を指定するおそれが手段を提供します。ガード機構の機能は古い情報に基づいてファイルの属性への変更を回避することであるので同じように、ガード条件の確認と属性の設定間の遅延は、この機能を妥協する可能性を秘めているNFSv4のエミュレーションで対応する遅延。そのため、NFSv4のサーバは、そのような要求を実行する際に、可能な程度まで、このような遅延を避けるために注意を払う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server does not support an attribute as requested by the client, the server should return NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントによって要求されるように、サーバが属性をサポートしていない場合、サーバーはNFS4ERR_ATTRNOTSUPPを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A mask of the attributes actually set is returned by SETATTR in all cases. That mask MUST NOT include attribute bits not requested to be set by the client. If the attribute masks in the request and reply are equal, the status field in the reply MUST be NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実際に設定された属性のマスクは、すべての場合にSETATTRによって返されます。そのマスクは、クライアントによって設定されるように要求していない属性ビットを含んではいけません。要求と応答の属性マスクが等しい場合、応答のステータス・フィールドはNFS4_OKでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33. Operation 35: SETCLIENTID - Negotiate Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33。操作35：SETCLIENTID  - クライアントIDをネゴシエート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client, callback, callback_ident -&gt; clientid, setclientid_confirm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント、コールバック、callback_ident  - &gt;のClientID、SETCLIENTID_CONFIRM
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID4args {
           nfs_client_id4  client;
           cb_client4      callback;
           uint32_t        callback_ident;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID4resok {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SETCLIENTID4res switch (nfsstat4 status) {
    case NFS4_OK:
            SETCLIENTID4resok      resok4;
    case NFS4ERR_CLID_INUSE:
            clientaddr4    client_using;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client uses the SETCLIENTID operation to notify the server of its intention to use a particular client identifier, callback, and callback_ident for subsequent requests that entail creating lock, share reservation, and delegation state on the server. Upon successful completion the server will return a shorthand client ID that, if confirmed via a separate step, will be used in subsequent file locking and file open requests. Confirmation of the client ID must be done via the SETCLIENTID_CONFIRM operation to return the client ID and setclientid_confirm values, as verifiers, to the server. Two verifiers are necessary because it is possible to use SETCLIENTID and SETCLIENTID_CONFIRM to modify the callback and callback_ident information but not the shorthand client ID. In that event, the setclientid_confirm value is effectively the only verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバー上のロック、共有予約、および委任状態を作り出す伴う後続の要求のために、特定のクライアント識別子、コールバック、およびcallback_identを使用する意向をサーバに通知するためにSETCLIENTID操作を使用しています。正常に完了すると、サーバーは、別の工程を経て確認した場合、その後のファイルのロックに使用し、オープン要求を提出します速記クライアントのIDを返します。クライアントIDの確認は、サーバーに、検証として、クライアントIDとSETCLIENTID_CONFIRM値を返すためにSETCLIENTID_CONFIRM操作を介して行われなければなりません。コールバックとcallback_ident情報ではなく、速記、クライアントのIDを変更するSETCLIENTIDとSETCLIENTID_CONFIRMを使用することが可能であるため、二つの検証が必要です。その場合には、SETCLIENTID_CONFIRM値は事実のみ検証です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The callback information provided in this operation will be used if the client is provided an open delegation at a future point. Therefore, the client must correctly reflect the program and port numbers for the callback program at the time SETCLIENTID is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、将来の時点で開いている委譲を提供する場合は、この操作で提供されるコールバック情報が使用されます。したがって、クライアントが正しくSETCLIENTIDが使用されている時にコールバックプログラムのためのプログラムとポート番号を反映しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The callback_ident value is used by the server on the callback. The client can leverage the callback_ident to eliminate the need for more than one callback RPC program number, while still being able to determine which server is initiating the callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
callback_ident値はコールバック上のサーバーで使用されています。クライアントはコールバックを開始しているサーバーを決定することが可能でありながら、複数のコールバックRPCプログラム番号の必要性を排除するためにcallback_identを活用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.33.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To understand how to implement SETCLIENTID, make the following notations. Let:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTIDを実装する方法を理解するには、次の表記を作ります。してみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
x be the value of the client.id subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
X SETCLIENTID4args構造のclient.idサブフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
v be the value of the client.verifier subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
V SETCLIENTID4args構造のclient.verifierサブフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c be the value of the client ID field returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTID4resok構造で返されるクライアントIDフィールドの値をc。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
k represent the value combination of the callback and callback_ident fields of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
kはSETCLIENTID4args構造のコールバックとcallback_identフィールドの値の組み合わせを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
s be the setclientid_confirm value returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
S SETCLIENTID4resok構造体に返さSETCLIENTID_CONFIRM値で。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
{ v, x, c, k, s } be a quintuple for a client record. A client record is confirmed if there has been a SETCLIENTID_CONFIRM operation to confirm it. Otherwise, it is unconfirmed. An unconfirmed record is established by a SETCLIENTID call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
{V、X、C、K、S}は、クライアントレコードの五重です。それを確認するSETCLIENTID_CONFIRM操作があった場合、クライアントのレコードが確認されました。それ以外の場合は、未確認です。未確認のレコードがSETCLIENTID呼び出しによって確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since SETCLIENTID is a non-idempotent operation, let us assume that the server is implementing the duplicate request cache (DRC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTIDが非冪等操作ですので、私たちは、サーバが重複要求キャッシュ（DRC）を実施していると仮定しましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server gets a SETCLIENTID { v, x, k } request, it processes it in the following manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはSETCLIENTID {V、X、K}の要求を受け取ると、それは次のようにそれを処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o It first looks up the request in the DRC. If there is a hit, it returns the result cached in the DRC. The server does NOT remove client state (locks, shares, delegations), nor does it modify any recorded callback and callback_ident information for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれは最初のDRCで要求を検索します。ヒットがあれば、それはDRCにキャッシュされた結果を返します。サーバーは、クライアントの状態（ロック、株式、代表団を）削除しません。また、クライアント{X}のための任意の記録コールバックとcallback_ident情報を変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For any DRC miss, the server takes the client ID string x, and searches for client records for x that the server may have recorded from previous SETCLIENTID calls. For any confirmed record with the same id string x, if the recorded principal does not match that of the SETCLIENTID call, then the server returns an NFS4ERR_CLID_INUSE error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれのDRCミスの場合、サーバーはクライアントのID文字列xを取り、サーバーが以前のSETCLIENTID呼び出しから記録されている可能性がxのクライアントレコードを検索。同じid列Xと任意の確認記録のために、記録されたプリンシパルがSETCLIENTID呼び出しと一致しない場合、サーバーはNFS4ERR_CLID_INUSEエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For brevity of discussion, the remaining description of the processing assumes that there was a DRC miss, and that where the server has previously recorded a confirmed record for client x, the aforementioned principal check has successfully passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
議論を簡単にするために、処理の残りの説明はDRCミスがあったこと、およびサーバーが以前のクライアントxの確認記録を記録したところ、前述の主なチェックに合格していることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server checks if it has recorded a confirmed record for { v, x, c, l, s }, where l may or may not equal k. If so, and since the id verifier v of the request matches that which is confirmed and recorded, the server treats this as a probable callback information update and records an unconfirmed { v, x, c, k, t } and leaves the confirmed { v, x, c, l, s } in place, such that t != s. It does not matter whether k equals l or not. Any pre-existing unconfirmed { v, x, c, *, * } is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバチェックoをそれが{V、X、C、L、S}、Lよいかよい等しいkに対する確認レコードが記録されている場合。もしそうであれば、リクエストのID検証vが確認され、記録されるものと一致しているので、サーバの可能性のコールバック情報の更新として扱いこれとは未確認{V、X、C、K、T}を記録し、確認した葉{代わりにV、X、C、L、S}、例えば、T！= sです。 kはLと等しいかどうかは問題ではありません。任意の既存の未確認{V、X、C、*、*}が除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server returns { c, t }. It is indeed returning the old clientid4 value c, because the client apparently only wants to update callback value k to value l. It&#39;s possible this request is one from the Byzantine router that has stale callback information, but this is not a problem. The callback information update is only confirmed if followed up by a SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ復帰{C、T}。クライアントが明らかにのみ値lにコールバック値kを更新したいので、それは確かに、古いclientid4値cを返しています。これは、この要求が古いコールバック情報を持っているビザンチンルータから1であることは可能ですが、これは問題ではありません。 SETCLIENTID_CONFIRM {C、T}によって追跡場合、コールバック情報の更新のみが確認されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server awaits confirmation of k via SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはSETCLIENTID_CONFIRM {C、T}介しkの確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and has not recorded any unconfirmed { *, x, *, *, * } record for x. The server records an unconfirmed { v, x, d, k, t } (d != c, t != s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが以前にそのようなV！= U、Lよいかよい等しいKことが確認{U、X、C、L、S}レコードを記録しており、*、*、任意未確認{*、Xを記録していない、O *} xについて記録します。サーバは、未確認{V、X、D、K、T}（D！= C、T！= S）を記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ復帰{D、T}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはSETCLIENTID_CONFIRM {D、T}介し{D、K}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and recorded an unconfirmed { w, x, d, m, t } record such that c != d, t != s, m may or may not equal k, m may or may not equal l, and k may or may not equal l. Whether w == v or w != v makes no difference. The server simply removes the unconfirmed { w, x, d, m, t } record and replaces it with an unconfirmed { v, x, e, k, r } record, such that e != d, e != c, r != t, r != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバは、以前に、U、Lかもしれまたはかもしれない等しいK =！Vように確認{U、X、C、L、S}レコードを記録し、未確認{W、X、D、M、T}を記録していますレコード例えばC！= D、T！= sで、Mかもしれまたはかもしれない等しいK、MまたはLよい等しくなくてもよく、Kよいかよい等しいLています。 == Vまたはwのかどうか！= vが違いはありません。サーバは単にように、E！= D、E！= Cを、R、未確認{W、X、D、M、T}レコードを削除し、未確認{V、X、E、K、R}レコードに置き換え！= T、R！= sで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server returns { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ復帰{E、R}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server awaits confirmation of { e, k } via SETCLIENTID_CONFIRM { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはSETCLIENTID_CONFIRM {E、R}介し{E、K}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server has no confirmed { *, x, *, *, * } for x. It may or may not have recorded an unconfirmed { u, x, c, l, s }, where l may or may not equal k, and u may or may not equal v. Any unconfirmed record { u, x, c, l, * }, regardless of whether u == v or l == k, is replaced with an unconfirmed record { v, x, d, k, t } where d != c, t != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバは全く認識していxに対して{*、*、*、*、xはありません}。これはまたは、ここで、Lよいかよい等しいKおよびUよいかよい等しいVを未確認{U、X、C、L、S}を記録しなくてもよい。任意の未確認のレコード{U、X、C、Lを、*}にかかわらず、UはVまたはL == kは==かどうか、未確認のレコード{V、X、D、K、T} D！= C、T！= Sに置換されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ復帰{D、T}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }. The server does NOT remove client (lock/share/ delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはSETCLIENTIDが確認介し{D、K}、へ}の確認を待ちます。サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server generates the clientid and setclientid_confirm values and must take care to ensure that these values are extremely unlikely to ever be regenerated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはclientidにとSETCLIENTID_CONFIRM値を生成し、これらの値は、これまでに再生することが極めてそうにないように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34. Operation 36: SETCLIENTID_CONFIRM - Confirm Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34。操作36：SETCLIENTIDのCONFIRM  - クライアントIDを確認してください
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
clientid, setclientid_confirm -&gt; -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientIDが、SETCLIENTID_CONFIRM  - &gt;  - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID_CONFIRM4args {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID_CONFIRM4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is used by the client to confirm the results from a previous call to SETCLIENTID. The client provides the server-supplied (from a SETCLIENTID response) client ID. The server responds with a simple status of success or failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作は、SETCLIENTIDへの以前の呼び出しからの結果を確認するために、クライアントによって使用されます。クライアントは、サーバが提供する（SETCLIENTID応答から）クライアントIDを提供します。サーバーは、成功か失敗かの簡単な状況で応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.34.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client must use the SETCLIENTID_CONFIRM operation to confirm the following two distinct cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、次の2つの異なる例を確認するためにSETCLIENTID_CONFIRM操作を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client&#39;s use of a new shorthand client identifier (as returned from the server in the response to SETCLIENTID), a new callback value (as specified in the arguments to SETCLIENTID), and a new callback_ident value (as specified in the arguments to SETCLIENTID). The client&#39;s use of SETCLIENTID_CONFIRM in this case also confirms the removal of any of the client&#39;s previous relevant leased state. Relevant leased client state includes byte-range locks, share reservations, and -- where the server does not support the CLAIM_DELEGATE_PREV claim type -- delegations. If the server supports CLAIM_DELEGATE_PREV, then SETCLIENTID_CONFIRM MUST NOT remove delegations for this client; relevant leased client state would then just include byte-range locks and share reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい速記クライアント識別子のクライアントの使用O（SETCLIENTIDに応じてサーバから返される）、新しいコールバック値（SETCLIENTIDへの引数に指定されている）、および新しいcallback_ident値（SETCLIENTIDへの引数に指定されています）。この場合SETCLIENTID_CONFIRMのクライアントの使用はまた、クライアントの以前の関連するリースの状態のいずれかを除去することを確認します。代表団 - サーバがCLAIM_DELEGATE_PREV請求タイプをサポートしていません - 関連リースクライアントの状態は、バイト範囲ロック、シェアの予約などが含まれます。サーバがCLAIM_DELEGATE_PREVをサポートしている場合は、SETCLIENTID_CONFIRMは、このクライアントのために代表団を削除してはなりません。関連するリースクライアントの状態は、単なるバイト範囲ロックと共有の予約が含まれるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client&#39;s reuse of an old, previously confirmed shorthand client identifier; a new callback value; and a new callback_ident value. The client&#39;s use of SETCLIENTID_CONFIRM in this case MUST NOT result in the removal of any previous leased state (locks, share reservations, and delegations).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O古い、以前に確認した速記クライアントIDのクライアントの再利用。新しいコールバック値。そして新しいcallback_ident値。この場合SETCLIENTID_CONFIRMのクライアントの使用は、以前のリースの状態（ロック、シェアの予約、および代表団）の除去につながるなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We use the same notation and definitions for v, x, c, k, s, and unconfirmed and confirmed client records as introduced in the description of the SETCLIENTID operation. The arguments to SETCLIENTID_CONFIRM are indicated by the notation { c, s }, where c is a value of type clientid4, and s is a value of type verifier4 corresponding to the setclientid_confirm field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
我々は、V、X、C、K、S、および未確認のために同じ表記法および定義を使用し、SETCLIENTID操作の説明に導入されるようクライアントレコードを確認しました。 SETCLIENTID_CONFIRMへの引数は、Cは、タイプclientid4の値であり、sはSETCLIENTID_CONFIRMフィールドに対応するverifier4タイプの値で表記{C、S}で示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As with SETCLIENTID, SETCLIENTID_CONFIRM is a non-idempotent operation, and we assume that the server is implementing the duplicate request cache (DRC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTIDと同じように、SETCLIENTID_CONFIRMは非冪等操作であり、私たちは、サーバが重複要求キャッシュ（DRC）を実装していることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server gets a SETCLIENTID_CONFIRM { c, s } request, it processes it in the following manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはSETCLIENTID_CONFIRM {C、S}要求を受け取ると、それは次のようにそれを処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o It first looks up the request in the DRC. If there is a hit, it returns the result cached in the DRC. The server does not remove any relevant leased client state, nor does it modify any recorded callback and callback_ident information for client { x } as represented by the shorthand value c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれは最初のDRCで要求を検索します。ヒットがあれば、それはDRCにキャッシュされた結果を返します。サーバは、任意の関連する専用クライアントの状態を削除しません。また、{X}速記値cによって表されるように、クライアントのために任意の記録されたコールバックとcallback_ident情報を変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a DRC miss, the server checks for client records that match the shorthand value c. The processing cases are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DRCミス、速記値cに一致するクライアントレコードのためのサーバーをチェックしてください。次のように処理例は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server has recorded an unconfirmed { v, x, c, k, s } record and a confirmed { v, x, c, l, t } record, such that s != t. If the principals of the records do not match that of the SETCLIENTID_CONFIRM, the server returns NFS4ERR_CLID_INUSE, and no relevant leased client state is removed and no recorded callback and callback_ident information for client { x } is changed. Otherwise, the confirmed { v, x, c, l, t } record is removed and the unconfirmed { v, x, c, k, s } is marked as confirmed, thereby modifying recorded and confirmed callback and callback_ident information for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバは未確認{V、X、C、K、S}レコードと確認{V、X、C、L、T}レコード、ようだ！= Tが記録されています。レコードのプリンシパルがSETCLIENTID_CONFIRMのものと一致しない場合、サーバはNFS4ERR_CLID_INUSEを返し、該当専用クライアント状態が除去されず、クライアント{X}のための記録のコールバックとcallback_ident情報が変更されません。そうでなければ、確認{V、X、C、L、T}レコードが除去され、それによって記録修正、確認されるように未確認{V、X、C、K、S}はマークされ、クライアント{Xのコールバックとcallback_ident情報を確認しました}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server does not remove any relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、関連するすべてのリースクライアントの状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server has not recorded an unconfirmed { v, x, c, *, * } and has recorded a confirmed { v, x, c, *, s }. If the principals of the record and of SETCLIENTID_CONFIRM do not match, the server returns NFS4ERR_CLID_INUSE without removing any relevant leased client state, and without changing recorded callback and callback_ident values for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバは、{*、*、V、X、C}未確認を記録していないと確認{V、X、C、*、S}を記録しました。レコードのとSETCLIENTID_CONFIRMのプリンシパルが一致しない場合、サーバは、クライアント{X}について記録のコールバックとcallback_ident値を変更することなく、任意の関連する専用のクライアント状態を除去することなくNFS4ERR_CLID_INUSEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the principals match, then what has likely happened is that the client never got the response from the SETCLIENTID_CONFIRM, and the DRC entry has been purged. Whatever the scenario, since the principals match, as well as { c, s } matching a confirmed record, the server leaves client x&#39;s relevant leased client state intact, leaves its callback and callback_ident values unmodified, and returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プリンシパルが一致する場合、どのような可能性が起こったことは、クライアントがSETCLIENTID_CONFIRMからの応答をやったことがなかった、とDRCエントリが削除されたことです。どのようなシナリオでは、プリンシパルが一致するので、同様に確認されたレコードに一致{C、S}、サーバは、未修飾のコールバックとcallback_ident値を残し、無傷のクライアントXの関連する専用クライアントの状態を離れ、そしてNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server has not recorded a confirmed { *, *, c, *, * } and has recorded an unconfirmed { *, x, c, k, s }. Even if this is a retry from the client, nonetheless the client&#39;s first SETCLIENTID_CONFIRM attempt was not received by the server. Retry or not, the server doesn&#39;t know, but it processes it as if it were a first try. If the principal of the unconfirmed { *, x, c, k, s } record mismatches that of the SETCLIENTID_CONFIRM request, the server returns NFS4ERR_CLID_INUSE without removing any relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバは、{*、*、*、*、C}確認を記録していないと未確認{*、X、C、K、S}を記録しました。これは、クライアントからのリトライであっても、それにもかかわらず、クライアントの最初のSETCLIENTID_CONFIRMの試みは、サーバーによって受信されませんでした。再試行するかどうか、サーバーは知りませんが、それは最初の試みであるかのようにそれを処理します。そのSETCLIENTID_CONFIRM要求の未確認{*、X、C、K、S}レコード不一致の主要場合、サーバは、任意の関連する専用のクライアント状態を除去することなくNFS4ERR_CLID_INUSEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Otherwise, the server records a confirmed { *, x, c, k, s }. If there is also a confirmed { *, x, d, *, t }, the server MUST remove client x&#39;s relevant leased client state and overwrite the callback state with k. The confirmed record { *, x, d, *, t } is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうでない場合、サーバは、確認{*、X、C、K、S}を記録します。また、確認した{*、X、D、*、T}が存在する場合、サーバはクライアントXの関連リースクライアントの状態を削除し、kはコールバック状態を上書きする必要があります。確認レコード{*、X、D、*、T}が除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server has no record of a confirmed or unconfirmed { *, *, c, *, s }. The server returns NFS4ERR_STALE_CLIENTID. The server does not remove any relevant leased client state, nor does it modify any recorded callback and callback_ident information for any client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバは、確認または未確認{*、*、C *、S}のレコードがありません。サーバーはNFS4ERR_STALE_CLIENTIDを返します。サーバは、関連するすべてのリースクライアントの状態を削除しません。また、任意のクライアントのための任意の記録コールバックとcallback_ident情報を変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server needs to cache unconfirmed { v, x, c, k, s } client records and await for some time their confirmation. As should be clear from the discussions of record processing for SETCLIENTID and SETCLIENTID_CONFIRM, there are cases where the server does not deterministically remove unconfirmed client records. To avoid running out of resources, the server is not required to hold unconfirmed records indefinitely. One strategy the server might use is to set a limit on how many unconfirmed client records it will maintain and then, when the limit would be exceeded, remove the oldest record. Another strategy might be to remove an unconfirmed record when some amount of time has elapsed. The choice of the amount of time is fairly arbitrary, but it is surely no higher than the server&#39;s lease time period. Consider that leases need to be renewed before the lease time expires via an operation from the client. If the client cannot issue a SETCLIENTID_CONFIRM after a SETCLIENTID before a period of time equal to a lease expiration time, then the client is unlikely to be able to maintain state on the server during steady-state operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは未確認{V、X、C、K、S}クライアントレコードをキャッシュし、しばらくの間その確認のために待機する必要があります。 SETCLIENTIDとSETCLIENTID_CONFIRMのレコード処理の議論から明らかであるように、サーバは、決定論未確認のクライアントレコードを削除しない場合があります。リソースの不足を回避するために、サーバーは無期限に未確認のレコードを保持するために必要とされていません。サーバが使用する可能性の1つの戦略は、それが維持し、制限を超えてしまうときに、最も古いレコードを削除しますどのように多くの未確認のクライアントレコードに制限を設定することです。別の戦略は、ある程度の時間が経過したときに未確認のレコードを削除するかもしれません。時間の量の選択はかなり任意であるが、それは確かに、サーバーのリース期間よりも高くありません。リースは、リース時間は、クライアントからの操作を経て有効期限が切れる前に更新する必要があることを考えてみましょう。クライアントは、リース満了時間に等しい時間の期間の前にSETCLIENTID後SETCLIENTID_CONFIRMを発行することができない場合、クライアントは定常動作時にサーバー上の状態を維持することができることはほとんどありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client does send a SETCLIENTID_CONFIRM for an unconfirmed record that the server has already deleted, the client will get NFS4ERR_STALE_CLIENTID back. If so, the client should then start over, and send SETCLIENTID to re-establish an unconfirmed client record and get back an unconfirmed client ID and setclientid_confirm verifier. The client should then send the SETCLIENTID_CONFIRM to confirm the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバーが既に削除されたことを未確認のレコードのSETCLIENTID_CONFIRMを送信した場合、クライアントはバックNFS4ERR_STALE_CLIENTIDを取得します。もしそうなら、次にクライアントは、最初からやり直し、および未確認のクライアントレコードを再確立し、未確認のクライアントIDとSETCLIENTID_CONFIRM検証を取り戻すためにSETCLIENTIDを送信する必要があります。クライアントは、クライアントのIDを確認するためにSETCLIENTID_CONFIRMを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTID_CONFIRM does not establish or renew a lease. However, if SETCLIENTID_CONFIRM removes relevant leased client state, and that state does not include existing delegations, the server MUST allow the client a period of time no less than the value of the lease_time attribute, to reclaim (via the CLAIM_DELEGATE_PREV claim type of the OPEN operation) its delegations before removing unreclaimed delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTID_CONFIRM確立またはリースを更新しません。 SETCLIENTID_CONFIRMは、関連するリースクライアントの状態を削除し、その状態は、既存の委任が含まれていない場合は、サーバーはクライアントにOPENのCLAIM_DELEGATE_PREV請求タイプを経由してlease_time属性の値を下回らない一定の期間、再利用するが（許容しなければなりません操作）unreclaimed委任を削除する前に、その代表団。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35. Operation 37: VERIFY - Verify Same Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35。操作37：VERIFY  - 同じ属性を確認してください
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), fattr -&gt; -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、fattr  - &gt;  - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct VERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct VERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The VERIFY operation is used to verify that attributes have a value assumed by the client before proceeding with subsequent operations in the COMPOUND request. If any of the attributes do not match, then the error NFS4ERR_NOT_SAME must be returned. The current filehandle retains its value after successful completion of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ベリファイ動作は、属性が複合要求における後続の操作を開始する前にクライアントによって仮定値を有することを確認するために使用されます。属性のいずれかが一致しない場合、エラーNFS4ERR_NOT_SAMEを返さなければなりません。現在のファイルハンドルは、操作が正常に完了した後にその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.35.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One possible use of the VERIFY operation is the following COMPOUND sequence. With this, the client is attempting to verify that the file being removed will match what the client expects to be removed. This sequence can help prevent the unintended deletion of a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ベリファイ動作の一つの可能​​な使用は、下記の化合物配列です。これにより、クライアントが削除されたファイルは、クライアントが削除されることを想定しているものと一致することを検証しようとしています。このシーケンスは、ファイルの意図しない削除を防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH (directory filehandle) LOOKUP (filename) VERIFY (filehandle == fh) PUTFH (directory filehandle) REMOVE (filename)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTFH（ディレクトリのファイルハンドル）LOOKUP（ファイル名）を確認します（ファイルハンドル== FH）PUTFH（ディレクトリのファイルハンドル）REMOVE（ファイル名）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This sequence does not prevent a second client from removing and creating a new file in the middle of this sequence, but it does help avoid the unintended result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このシーケンスは、このシーケンスの途中で新しいファイルを削除し、作成から2番目のクライアントを防ぐことはできませんが、それは予期しない結果を回避するのに役立つん。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case that a RECOMMENDED attribute is specified in the VERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
推奨属性がVERIFY操作で指定され、サーバがファイル・システム・オブジェクトのためにその属性をサポートしていない場合は、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the attribute rdattr_error or any write-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性rdattr_errorまたは任意の書き込み専用の属性（例えば、time_modify_set）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36. Operation 38: WRITE - Write to File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36。操作38：WRITE  - ファイルに書き込みます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(cfh), stateid, offset, stable, data -&gt; count, committed, writeverf
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（CFH）、のstateid、オフセット、安定した、データ - &gt;数、コミット、writeverf
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum stable_how4 { UNSTABLE4 = 0, DATA_SYNC4 = 1, FILE_SYNC4 = 2 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙stable_how4 {UNSTABLE4 = 0、DATA_SYNC4 = 1、FILE_SYNC4 = 2}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           stable_how4     stable;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4resok {
           count4          count;
           stable_how4     committed;
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union WRITE4res switch (nfsstat4 status) {
    case NFS4_OK:
            WRITE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The WRITE operation is used to write data to a regular file. The target file is specified by the current filehandle. The offset specifies the offset where the data should be written. An offset of 0 (zero) specifies that the write should start at the beginning of the file. The count, as encoded as part of the opaque data parameter, represents the number of bytes of data that are to be written. If the count is 0 (zero), the WRITE will succeed and return a count of 0 (zero) subject to permissions checking. The server may choose to write fewer bytes than requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE操作は、通常のファイルにデータを書き込むために使用されます。対象のファイルは、現在のファイルハンドルで指定されています。オフセットは、データが書き込まれるべき場所オフセットを指定します。 0（ゼロ）のオフセットを書き込み、ファイルの先頭から開始することを指定します。カウントは、不透明なデータパラメータの一部として符号化として、書き込まれるデータのバイト数を表します。カウントが0（ゼロ）の場合、WRITEは成功し、チェック権限に0（ゼロ）は、被験者の数を返します。サーバは、クライアントから要求されたよりも少ないバイトを書くことを選んでもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Part of the WRITE request is a specification of how the WRITE is to be performed. The client specifies with the stable parameter the method of how the data is to be processed by the server. If stable is FILE_SYNC4, the server must commit the data written plus all file system metadata to stable storage before returning results. This corresponds to the NFSv2 protocol semantics. Any other behavior constitutes a protocol violation. If stable is DATA_SYNC4, then the server must commit all of the data to stable storage and enough of the metadata to retrieve the data before returning. The server implementer is free to implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a possible performance drop. If stable is UNSTABLE4, the server is free to commit any part of the data and the metadata to stable storage, including all or none, before returning a reply to the client. There is no guarantee whether or when any uncommitted data will subsequently be committed to stable storage. The only guarantees made by the server are that it will not destroy any data without changing the value of verf and that it will not commit the data and metadata at a level less than that requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE要求の一部は、書き込みが行われるべきかの仕様です。クライアントは、安定したパラメータを使用してデータがサーバによって処理されるかの方法を指定します。安定がFILE_SYNC4であれば、サーバは結果を返す前に、安定したストレージに書き込まれたデータに加えて、すべてのファイルシステムのメタデータをコミットする必要があります。これは、のNFSv2プロトコルのセマンティクスに対応しています。その他の動作は、プロトコル違反を構成しています。安定がDATA_SYNC4ある場合、サーバーは安定して保管し、返す前にデータを取得するメタデータの十分にすべてのデータをコミットする必要があります。サーバーの実装者はFILE_SYNC4と同じように、しかし、可能性、パフォーマンスの低下とDATA_SYNC4を実装して自由です。安定がUNSTABLE4ある場合、サーバーはクライアントへの応答を返す前に、すべてまたはnoneを含む安定したストレージへのデータの任意の部分とメタデータをコミットして自由です。コミットされていないデータは、その後安定したストレージにコミットするかどうかとき保証はありません。サーバによって作られた唯一の保証は、それがVERFの値を変更することなく、任意のデータを破壊し、それがクライアントによって要求されたよりも低いレベルでのデータとメタデータをコミットしていないということではないだろうということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The stateid value for a WRITE request represents a value returned from a previous byte-range lock or share reservation request or the stateid associated with a delegation. The stateid is used by the server to verify that the associated share reservation and any byte-range locks are still valid and to update lease timeouts for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE要求のためのstateid値は、以前のバイト範囲ロックまたは共有の予約要求又は委任に関連付けられたstateidから返された値を表します。 stateidは、関連する株式の予約と任意のバイト範囲ロックがまだ有効であることを確認するために、クライアントのリースのタイムアウトを更新するためにサーバによって使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon successful completion, the following results are returned. The count result is the number of bytes of data written to the file. The server may write fewer bytes than requested. If so, the actual number of bytes written starting at location, offset, is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
正常に完了すると、次の結果が返されます。カウント結果はファイルに書き込まれたデータのバイト数です。サーバーは、要求されたよりも少ないバイトを書き込むことができます。その場合、位置から始まる書き込まれたバイトの実際の数は、オフセット、戻されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server also returns an indication of the level of commitment of the data and metadata via committed. If the server committed all data and metadata to stable storage, committed should be set to FILE_SYNC4. If the level of commitment was at least as strong as DATA_SYNC4, then committed should be set to DATA_SYNC4. Otherwise, committed must be returned as UNSTABLE4. If stable was FILE4_SYNC, then committed must also be FILE_SYNC4: anything else constitutes a protocol violation. If stable was DATA_SYNC4, then committed may be FILE_SYNC4 or DATA_SYNC4: anything else constitutes a protocol violation. If stable was UNSTABLE4, then committed may be either FILE_SYNC4, DATA_SYNC4, or UNSTABLE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、サーバーはコミットを介したデータおよびメタデータのコミットメントのレベルを示す値を返します。サーバーが安定したストレージにすべてのデータとメタデータを犯した場合、コミットはFILE_SYNC4に設定する必要があります。コミットメントのレベルがDATA_SYNC4と少なくとも同じくらい強かった場合、コミットはDATA_SYNC4に設定する必要があります。そうでない場合、コミットはUNSTABLE4として返さなければなりません。安定したがFILE4_SYNCた場合は、コミットもFILE_SYNC4でなければなりません：他の何かがプロトコル違反を構成しています。安定したがDATA_SYNC4た場合は、コミットFILE_SYNC4またはDATA_SYNC4ことがあります何か他のものは、プロトコル違反を構成しています。安定したがUNSTABLE4た場合は、コミットFILE_SYNC4、DATA_SYNC4、またはUNSTABLE4のいずれであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The final portion of the result is the write verifier. The write verifier is a cookie that the client can use to determine whether the server has changed instance (boot) state between a call to WRITE and a subsequent call to either WRITE or COMMIT. This cookie must be consistent during a single instance of the NFSv4 protocol service and must be unique between instances of the NFSv4 protocol server, where uncommitted data may be lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
結果の最後の部分は、書き込み検証です。書き込み検証は、クライアントが、サーバが書き込みの呼び出しとWRITEまたはCOMMITのいずれかへのその後の呼び出しの間インスタンス（ブート）状態に変化したか否かを判断するために使用できるクッキーです。このクッキーは、NFSv4のプロトコルサービスの単一のインスタンス間に一貫性がなければならず、コミットされていないデータが失われる可能性のNFSv4プロトコルサーバのインスタンス間で一意でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a client writes data to the server with the stable argument set to UNSTABLE4 and the reply yields a committed response of DATA_SYNC4 or UNSTABLE4, the client will follow up at some time in the future with a COMMIT operation to synchronize outstanding asynchronous data and metadata with the server&#39;s stable storage, barring client error. It is possible that due to client crash or other error a subsequent COMMIT will not be received by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがUNSTABLE4に設定された安定した引数を使用してサーバにデータを書き込み、返信がDATA_SYNC4またはUNSTABLE4のコミット応答を生成する場合は、クライアントが持つ優れた非同期データおよびメタデータを同期させるためにCOMMIT操作で将来のある時点でフォローアップしますサーバの安定したストレージ、クライアントエラーがなければ。原因クライアントのクラッシュやその他のエラーにCOMMIT、その後は、サーバによって受信されない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a WRITE using the special anonymous stateid, the server MAY allow the WRITE to be serviced subject to mandatory file locks or the current share deny modes for the file. For a WRITE using the special READ bypass stateid, the server MUST NOT allow the WRITE operation to bypass locking checks at the server, and the WRITE is treated exactly the same as if the anonymous stateid were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別な匿名たstateidを使用したWRITEの場合、サーバーは、WRITEが必須のファイルロックまたは現在のシェアは、ファイルのモードを拒否の対象にサービスを提供できるようにすることができます。特別READバイパスのstateidを用いてWRITEため、サーバは、サーバでのロックのチェックを迂回するように書き込み動作を許可してはいけません、そして書き込みは匿名のstateidを使用した場合と全く同様に扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.36.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is possible for the server to write fewer bytes of data than requested by the client. In this case, the server should not return an error unless no data was written at all. If the server writes less than the number of bytes specified, the client should issue another WRITE to write the remaining data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、クライアントから要求されたよりも少ないデータのバイト数を書き込むことが可能です。データが全く書かれていない限りこの場合、サーバがエラーを返すべきではありません。サーバーは、指定されたバイト数よりも少ないが書き込まれた場合、クライアントは残りのデータを書き込むために、別のWRITEを発行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is assumed that the act of writing data to a file will cause the time_modify attribute of the file to be updated. However, the time_modify attribute of the file should not be changed unless the contents of the file are changed. Thus, a WRITE request with count set to 0 should not cause the time_modify attribute of the file to be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルにデータを書き込む行為は、ファイルのtime_modify属性が更新されますと仮定されます。ファイルの内容が変更されない限りただし、ファイルのtime_modify属性を変更すべきではありません。このように、0に設定されたカウントと書き込み要求がファイルのtime_modify属性をアップデートするべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The definition of stable storage has been historically a point of contention. The following expected properties of stable storage may help in resolving design issues in the implementation. Stable storage is persistent storage that survives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
貯蔵安定性の定義は歴史的に競合のポイントとなっています。安定したストレージの以下の期待される特性は、実装に設計上の問題の解決に役立つことがあります。安定したストレージは生き残る永続的なストレージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Repeated power failures.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.繰り返し停電。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Hardware failures (of any board, power supply, etc.).
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
（任意ボード、電源などの）2.ハードウェア障害。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Repeated software crashes, including reboot cycle.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
再起動のサイクルを含む3繰り返しソフトウェアがクラッシュしました、。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This definition does not address failure of the stable storage module itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この定義は、安定したストレージモジュール自体の故障に対応していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The verifier is defined to allow a client to detect different instances of an NFSv4 protocol server over which cached, uncommitted data may be lost. In the most likely case, the verifier allows the client to detect server reboots. This information is required so that the client can safely determine whether the server could have lost cached data. If the server fails unexpectedly and the client has uncommitted data from previous WRITE requests (done with the stable argument set to UNSTABLE4 and in which the result committed was returned as UNSTABLE4 as well), it may not have flushed cached data to stable storage. The burden of recovery is on the client, and the client will need to retransmit the data to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
検証者は、コミットされていないデータが失われる可能性があり、クライアントがキャッシュされ、その上のNFSv4プロトコルサーバの異なるインスタンスを検出できるように定義されます。最も可能性が高い場合には、検証は、クライアントがサーバーの再起動を検出することができます。クライアントが安全にサーバがキャッシュされたデータを失っていることができるかどうかを判断できるように、この情報が必要になります。サーバーが予期せずに失敗し、クライアントは、前のWRITE要求（UNSTABLE4に設定された安定した引数で行われ、結果はコミットしているが、同様UNSTABLE4として返された）からのコミットされていないデータがある場合、それは安定したストレージにキャッシュされたデータをフラッシュしていない可能性があり。回復の負担は、クライアント上で、クライアントがサーバにデータを再送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One suggested way to use the verifier would be to use the time that the server was booted or the time the server was last started (if restarting the server without a reboot results in lost buffers).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
検証を使用するための一つの提案の方法は、（失われたバッファにリブート結果なしでサーバーを再起動した場合）、サーバが最後に起動されたサーバが起動された時刻や時間を用いることであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The committed field in the results allows the client to do more effective caching. If the server is committing all WRITE requests to stable storage, then it should return with committed set to FILE_SYNC4, regardless of the value of the stable field in the arguments. A server that uses an NVRAM accelerator may choose to implement this policy. The client can use this to increase the effectiveness of the cache by discarding cached data that has already been committed on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
結果内のコミットフィールドは、クライアントがより効果的なキャッシングを行うことができます。サーバーが安定したストレージにすべてのWRITE要求をコミットしている場合、それは関係なく、引数で安定したフィールドの値の、FILE_SYNC4にコミット設定して返す必要があります。 NVRAMアクセラレータを使用するサーバーは、このポリシーを実装することを選択できます。クライアントがすでにサーバーにコミットされたキャッシュされたデータを破棄することにより、キャッシュの有効性を高めるためにこれを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some implementations may return NFS4ERR_NOSPC instead of NFS4ERR_DQUOT when a user&#39;s quota is exceeded. In the case that the current filehandle is a directory, the server will return NFS4ERR_ISDIR. If the current filehandle is not a regular file or a directory, the server will return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザのクォータを超えた場合、いくつかの実装がNFS4ERR_DQUOTの代わりにNFS4ERR_NOSPCを返すことがあります。現在のファイルハンドルがディレクトリである場合、サーバはNFS4ERR_ISDIRを返します。現在のファイルハンドルは通常のファイルまたはディレクトリでない場合、サーバはNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If mandatory file locking is on for the file, and a corresponding record of the data to be written to file is read or write locked by an owner that is not associated with the stateid, the server will return NFS4ERR_LOCKED. If so, the client must check if the owner corresponding to the stateid used with the WRITE operation has a conflicting read lock that overlaps with the region that was to be written. If the stateid&#39;s owner has no conflicting read lock, then the client should try to get the appropriate write byte-range lock via the LOCK operation before re-attempting the WRITE. When the WRITE completes, the client should release the byte-range lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必須のファイルのロックは、ファイルのためであり、データの対応するレコードが読み出されるか、のstateidに関連付けられていない所有者によってロックライトファイルに書き込まれる場合、サーバはNFS4ERR_LOCKEDを返します。もしそうであればWRITE動作と使用のstateidに対応する所有者が書き込まれることになっていた領域と重なる競合読み取りロックを有している場合、クライアントはチェックしなければなりません。 stateidの所有者が競合する読み取りロックを持っていない場合、クライアントは再試行する前に、WRITE LOCK操作を介して適切な書き込みバイト範囲ロックを取得しようとする必要があります。 WRITEが完了すると、クライアントはLOCKU経由バイト範囲ロックを解除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the stateid&#39;s owner had a conflicting read lock, then the client has no choice but to return an error to the application that attempted the WRITE. The reason is that since the stateid&#39;s owner had a read lock, the server either (1) attempted to temporarily effectively upgrade this read lock to a write lock or (2) has no upgrade capability. If the server attempted to upgrade the read lock and failed, it is pointless for the client to re-attempt the upgrade via the LOCK operation, because there might be another client also trying to upgrade. If two clients are blocked trying to upgrade the same lock, the clients deadlock. If the server has no upgrade capability, then it is pointless to try a LOCK operation to upgrade.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidの所有者は、矛盾する読み取りロックを持っていた場合、クライアントはWRITEを試みたアプリケーションにエラーを返すしかありません。その理由はのstateidの所有者は、読み取りロック、（1）一時的に効果的に、これは書き込みロックまたは（2）持っていないアップグレード機能にロックを読んでアップグレードしようとしたいずれかのサーバーを持っていたからです。サーバーは、読み取りロックをアップグレードしようとして失敗した場合は、別のクライアントもアップグレードしようとしているがあるかもしれないので、クライアントは、LOCK操作を経由してアップグレードを再試行するために、それは無意味です。 2つのクライアントが同じロックをアップグレードしようとしてブロックされている場合、クライアントがデッドロック。サーバが何のアップグレード機能を持っていない場合、アップグレードするためにLOCK操作を試して無意味です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37. Operation 39: RELEASE_LOCKOWNER - Release Lock-Owner State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37。操作39：RELEASE_LOCKOWNER  - リリースロック所有者の状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
lock-owner -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロック所有者 - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RELEASE_LOCKOWNER4args {
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RELEASE_LOCKOWNER4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is used to notify the server that the lock_owner is no longer in use by the client and that future client requests will not reference this lock_owner. This allows the server to release cached state related to the specified lock_owner. If file locks associated with the lock_owner are held at the server, the error NFS4ERR_LOCKS_HELD will be returned and no further action will be taken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作は、lock_ownerはもはやクライアントによって使用されているサーバーに通知するために使用され、将来のクライアント要求は、このlock_ownerを参照しないこと。これは、サーバーが指定されたlock_ownerに関連するキャッシュされた状態を解除することができます。 lock_ownerに関連付けられたファイルロックがサーバーに保持されている場合は、エラーNFS4ERR_LOCKS_HELDが返され、それ以上のアクションは取られません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.37.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client may choose to use this operation to ease the amount of server state that is held. Information that can be released when a RELEASE_LOCKOWNER is done includes the specified lock-owner string, the seqid associated with the lock-owner, any saved reply for the lock-owner, and any lock stateids associated with that lock-owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが保持されているサーバーの状態の量を容易にするために、この操作を使用することもできます。 RELEASE_LOCKOWNERが行われたときに解放することができます情報は、指定されたロック所有者文字列、ロック所有者、ロック所有者のための任意の保存された応答、及びそのロックの所有者に関連付けられたすべてのロックのstateidsに関連したSEQIDが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Depending on the behavior of applications at the client, it may be important for the client to use this operation since the server has certain obligations with respect to holding a reference to lock-owner-associated state as long as an associated file is open. Therefore, if the client knows for certain that the lock_owner will no longer be used to either reference existing lock stateids associated with the lock-owner or create new ones, it should use RELEASE_LOCKOWNER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバが特定の義務を持っているため、クライアントはロック所有者に関連する状態を限り、関連するファイルを開いているように、参照を保持に関して、この操作を使用するため、クライアントでのアプリケーションの動作に応じて、それは重要であるかもしれません。クライアントが特定のために知っていればそのため、lock_ownerは、もはやロック所有者に関連付けられているいずれかの参照既存のロックのstateidsに使用されていないか、または新しいものを作成されること、それはRELEASE_LOCKOWNERを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38. Operation 10044: ILLEGAL - Illegal Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38。オペレーション10044：ILLEGAL  - 無効な操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;null&gt; -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;ヌル&gt;  - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See Section 15.2.4 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作はサポートされていない化合物内のオペレーションコードを送信したクライアントの場合を処理するために結果を符号化するためのプレースホルダです。詳細は、15.2.4項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The status field of ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.38.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client will probably not send an operation with code OP_ILLEGAL, but if it does, the response will be ILLEGAL4res, just as it would be with any other invalid operation code. Note that if the server gets an illegal operation code that is not OP_ILLEGAL, and if the server checks for legal operation codes during the XDR decode phase, then the ILLEGAL4res would not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、おそらくコードOP_ILLEGALで操作を送信しませんが、それがない場合、応答は、それが他の不正なオペレーションコードを持つことと同じように、ILLEGAL4resになります。注意サーバがOP_ILLEGALない不正な操作コードを取得した場合、およびXDRデコード段階の間法的操作コードのサーバをチェックし、次にILLEGAL4resが返されない場合に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. NFSv4 Callback Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. NFSv4のコールバック手続き
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The procedures used for callbacks are defined in the following sections. In the interest of clarity, the terms &#34;client&#34; and &#34;server&#34; refer to NFS clients and servers, despite the fact that for an individual callback RPC, the sense of these terms would be precisely the opposite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コールバックのために使用される手順は、次のセクションで定義されています。明瞭にするために、用語「クライアント」と「サーバー」は、個々のコールバックRPCのために、これらの用語の意味は正反対になるという事実にもかかわらず、NFSクライアントとサーバを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. Procedure 0: CB_NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1。手順0：CB_NULL  - 動作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;null&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;NULL&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Standard NULL procedure. Void argument, void response. Even though there is no direct functionality associated with this procedure, the server will use CB_NULL to confirm the existence of a path for RPCs from server to client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
標準NULL手続き。ボイド引数、無効応答。この手順に関連した直接的な機能はありませんにもかかわらず、サーバは、サーバからクライアントへのRPCのパスの存在を確認するためにCB_NULLを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. Procedure 1: CB_COMPOUND - COMPOUND Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2。手順1：CB_COMPOUND  -  COMPOUND操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
compoundargs -&gt; compoundres
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
compoundargs  - &gt; compoundres
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum nfs_cb_opnum4 { OP_CB_GETATTR = 3, OP_CB_RECALL = 4, OP_CB_ILLEGAL = 10044 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙{nfs_cb_opnum4 OP_CB_GETATTR = 3、OP_CB_RECALL = 4、OP_CB_ILLEGAL = 10044}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_argop4 switch (unsigned argop) {
    case OP_CB_GETATTR:
         CB_GETATTR4args           opcbgetattr;
    case OP_CB_RECALL:
         CB_RECALL4args            opcbrecall;
    case OP_CB_ILLEGAL:            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           uint32_t        callback_ident;
           nfs_cb_argop4   argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_resop4 switch (unsigned resop) {
    case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4res {
           nfsstat4        status;
           utf8str_cs      tag;
           nfs_cb_resop4   resarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CB_COMPOUND procedure is used to combine one or more of the callback procedures into a single RPC request. The main callback RPC program has two main procedures: CB_NULL and CB_COMPOUND. All other operations use the CB_COMPOUND procedure as a wrapper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_COMPOUND手順は、単一のRPC要求にコールバック手続きの一つ以上を組み合わせるために使用されます。 CB_NULLとCB_COMPOUND：メインのコールバックRPCプログラムは、主に2つの手順があります。他のすべての操作は、ラッパーとしてCB_COMPOUNDプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the processing of the CB_COMPOUND procedure, the client may find that it does not have the available resources to execute any or all of the operations within the CB_COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the CB_COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the CB_COMPOUND sequence have been evaluated successfully.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_COMPOUND手順の処理では、クライアントは、それがCB_COMPOUND配列内の操作のいずれか、またはすべてを実行するために使用可能なリソースを持っていないことがあります。この場合、エラーNFS4ERR_RESOURCEは、リソースの枯渇が発生しCB_COMPOUNDプロシージャ内の特定の操作のために返されます。これはCB_COMPOUND配列内のすべての以前の操作が正常に評価されていることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Contained within the CB_COMPOUND results is a status field. This status must be equivalent to the status of the last operation that was executed within the CB_COMPOUND procedure. Therefore, if an operation incurred an error, then the status value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_COMPOUND結果に含まれるステータスフィールドがあります。このステータスはCB_COMPOUND手順の中で実行された最後の操作の状態と同等でなければなりません。操作がエラーを発生した場合、したがって、その後のステータス値は、失敗した操作のために返される同じエラー値となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the definition of the tag field, see Section 15.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タグフィールドの定義については、15.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The value of callback_ident is supplied by the client during SETCLIENTID. The server must use the client-supplied callback_ident during the CB_COMPOUND to allow the client to properly identify the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
callback_identの値はSETCLIENTID中に、クライアントによって供給されています。サーバーは、クライアントがサーバーを正しく識別できるようにするためにCB_COMPOUND中にクライアントが提供callback_identを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Illegal operation codes are handled in the same way as they are handled for the COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不正操作コードは、それらは、化合物処置のために処理されるのと同じ方法で処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CB_COMPOUND procedure is used to combine individual operations into a single RPC request. The client interprets each of the operations in turn. If an operation is executed by the client and the status of that operation is NFS4_OK, then the next operation in the CB_COMPOUND procedure is executed. The client continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_COMPOUND手順は、単一のRPC要求に個々の操作を組み合わせるために使用されます。クライアントは、順番にそれぞれの操作を解釈します。操作は、クライアントで実行されると、その操作のステータスがNFS4_OKでされている場合は、CB_COMPOUNDの手順の次の動作が実行されます。が実行されるべきそれ以上の操作がされないかのいずれかの操作がNFS4_OK以外の状態値を有するまで、クライアントは、このプロセスを継続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. NFSv4 Callback Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. NFSv4のコールバックオペレーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. Operation 3: CB_GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1。動作3：CB_GETATTR  - 属性を取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fh, attr_request -&gt; attrmask, attr_vals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FH、attr_request  - &gt; attrmask、attr_vals
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_GETATTR4args {
           nfs_fh4 fh;
           bitmap4 attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_GETATTR4resok {
           fattr4  obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CB_GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            CB_GETATTR4resok       resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CB_GETATTR operation is used by the server to obtain the current modified state of a file that has been OPEN_DELEGATE_WRITE delegated. The size attribute and the change attribute are the only ones guaranteed to be serviced by the client. See Section 10.4.3 for a full description of how the client and server are to interact with the use of CB_GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_GETATTR動作がOPEN_DELEGATE_WRITE委任されたファイルの現在の修正された状態を得るためにサーバによって使用されます。サイズ属性と変更属性は、クライアントがサービスを提供することが保証だけです。クライアントとサーバがCB_GETATTRの使用と対話するある方法の完全な記述については10.4.3項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the filehandle specified is not one for which the client holds an OPEN_DELEGATE_WRITE delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定されたファイルハンドルは、クライアントがOPEN_DELEGATE_WRITE委任を保持するためのものではない場合は、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client returns attrmask bits and the associated attribute values only for the change attribute, and attributes that it may change (time_modify and size).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント戻ってのみ変更属性のビットと関連付けられた属性値をattrmask、それが（time_modifyおよびサイズ）を変更してもよいこと属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. Operation 4: CB_RECALL - Recall an Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2。操作4：CB_RECALL  - オープン委任を思い出してください
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateid, truncate, fh -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateid、切り捨て、FH  - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL4args {
           stateid4        stateid;
           bool            truncate;
           nfs_fh4         fh;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CB_RECALL operation is used to begin the process of recalling an open delegation and returning it to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_RECALL操作が開いている委譲を想起し、それをサーバーに戻す処理を開​​始するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The truncate flag is used to optimize a recall for a file that is about to be truncated to zero. When it is set, the client is freed of obligation to propagate modified data for the file to the server, since this data is irrelevant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TRUNCATEフラグはゼロに切り捨てされようとしているファイルの回収を最適化するために使用されます。それが設定されている場合、クライアントは、このデータは無関係であるため、サーバーへのファイルのために変更されたデータを伝播する義務が除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the handle specified is not one for which the client holds an open delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定されたハンドルは、クライアントが開いている委譲を保持するためのものではない場合は、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the stateid specified is not one corresponding to an open delegation for the file specified by the filehandle, an NFS4ERR_BAD_STATEID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定されたstateidは、ファイルハンドルで指定されたファイルのオープン委譲に対応していないものである場合、NFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client should reply to the callback immediately. Replying does not complete the recall, except when an error was returned. The recall is not complete until the delegation is returned using a DELEGRETURN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはすぐにコールバックに返信する必要があります。返信するには、エラーが返された場合を除き、リコールを完了していません。代表団はDELEGRETURNを使用して返されるまで、リコールは完全ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3. Operation 10044: CB_ILLEGAL - Illegal Callback Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3。オペレーション10044：CB_ILLEGAL  - 不正なコールバックの操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.1。 SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;null&gt; -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;ヌル&gt;  - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.2。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.3。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CB_ILLEGAL: Response for illegal operation numbers
    */
   struct CB_ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See Section 15.2.4 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作はサポートされていない化合物内のオペレーションコードを送信したクライアントの場合を処理するために結果を符号化するためのプレースホルダです。詳細は、15.2.4項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The status field of CB_ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3.5。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server will probably not send an operation with code OP_CB_ILLEGAL, but if it does, the response will be CB_ILLEGAL4res, just as it would be with any other invalid operation code. Note that if the client gets an illegal operation code that is not OP_ILLEGAL, and if the client checks for legal operation codes during the XDR decode phase, then the CB_ILLEGAL4res would not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、おそらくコードOP_CB_ILLEGALで操作を送信しませんが、それがない場合、応答は、それが他の不正なオペレーションコードを持つことと同じように、CB_ILLEGAL4resになります。注クライアントがOP_ILLEGALない不正な操作コードを取得した場合、およびXDRデコード段階の間法的操作コードのクライアントチェックは、その後CB_ILLEGAL4resが返されない場合に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS has historically used a model where, from an authentication perspective, the client was the entire machine, or at least the source IP address of the machine. The NFS server relied on the NFS client to make the proper authentication of the end-user. The NFS server in turn shared its files only to specific clients, as identified by the client&#39;s source IP address. Given this model, the AUTH_SYS RPC security flavor simply identified the end-user using the client to the NFS server. When processing NFS responses, the client ensured that the responses came from the same IP address and port number that the request was sent to. While such a model is easy to implement and simple to deploy and use, it is certainly not a safe model. Thus, NFSv4 mandates that implementations support a security model that uses end-to-end authentication, where an end-user on a client mutually authenticates (via cryptographic schemes that do not expose passwords or keys in the clear on the network) to a principal on an NFS server. Consideration should also be given to the integrity and privacy of NFS requests and responses. The issues of end-to-end mutual authentication, integrity, and privacy are discussed as part of Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSは、歴史的に、認証の観点から、クライアントはマシン全体、または機械の少なくとも送信元IPアドレスだった、モデルを使用しています。 NFSサーバーは、エンドユーザーの適切な認証を行うためにNFSクライアントに依存していました。クライアントのソースIPアドレスによって識別されるように順番にNFSサーバは、特定のクライアントだけにそのファイルを共有しました。このモデルを考えると、AUTH_SYS RPCセキュリティ風味は、単純にNFSサーバーにクライアントを使用して、エンドユーザを特定しました。 NFS応答を処理する場合、クライアントは応答が要求が送られた同じIPアドレスとポート番号から来たことを確実にしました。このようなモデルを展開し、使用するために実装するのは簡単でシンプルですが、それは確かに安全なモデルではありません。したがって、実装は主にクライアント上でエンドユーザが相互に（ネットワーク上明らかにパスワードまたはキーを公開していない暗号スキームを介して）認証、エンドツーエンドの認証を、使用するセキュリティモデルをサポートするのNFSv4義務NFSサーバー上。配慮もNFS要求と応答の整合性とプライバシーに与えられるべきです。エンド・ツー・エンドの相互認証、整合性、およびプライバシーの問題は、第3節の一部として議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an NFSv4 mandated security model is used and a security principal or an NFSv4 name in user@dns_domain form needs to be translated to or from a local representation as described in Section 5.9, the translation SHOULD be done in a secure manner that preserves the integrity of the translation. For communication with a name service such as the Lightweight Directory Access Protocol (LDAP) ([RFC4511]), this means employing a security service that uses authentication and data integrity. Kerberos and Transport Layer Security (TLS) ([RFC5246]) are examples of such a security service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4の義務付けられたセキュリティモデルが使用され、セキュリティプリンシパルまたはユーザーの@ dns_domainフォームでのNFSv4名は、セクション5.9で説明したように、ローカルな表現から翻訳する必要がある場合、翻訳が整合性を維持する安全な方法で行われるべきです翻訳の。そのようなライトウェイトディレクトリアクセスプロトコル（LDAP）（[RFC4511]）などのネームサービスとの通信のために、これは認証とデータの整合性を使用したセキュリティサービスを利用することを意味します。 Kerberosとトランスポート層セキュリティ（TLS）（[RFC5246]）などのセキュリティサービスの例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that being REQUIRED to implement does not mean REQUIRED to use; AUTH_SYS can be used by NFSv4 clients and servers. However, AUTH_SYS is merely an OPTIONAL security flavor in NFSv4, and so interoperability via AUTH_SYS is not assured.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
使用するために必要なことを意味しない実装するために必要とされていることに注意してください。 AUTH_SYSは、NFSv4のクライアントとサーバで使用することができます。しかし、AUTH_SYSはNFSv4の中だけでオプションのセキュリティ風味などAUTH_SYSを経由して相互運用性が保証されていないです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For reasons of reduced administration overhead, better performance, and/or reduction of CPU utilization, users of NFSv4 implementations may choose to not use security mechanisms that enable integrity protection on each remote procedure call and response. The use of mechanisms without integrity leaves the customer vulnerable to an attacker in between the NFS client and server that modifies the RPC request and/or the response. While implementations are free to provide the option to use weaker security mechanisms, there are two operations in particular that warrant the implementation overriding user choices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
削減管理オーバーヘッド、より良い性能、および/またはCPU使用率の削減の理由から、NFSv4の実装のユーザーは、各リモート・プロシージャ・コールとレスポンスの完全性保護を可能にするセキュリティ・メカニズムを使用しないことを選択できます。整合性のないメカニズムを使用すると、RPC要求および/または応答を変更するNFSクライアントとサーバの間で、攻撃者に対して脆弱顧客を残します。実装が弱いセキュリティメカニズムを使用するためのオプションを提供するために自由ですが、ユーザーの選択をオーバーライド実装を保証し、特に2つの操作があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first such operation is SECINFO. It is recommended that the client issue the SECINFO call such that it is protected with a security flavor that has integrity protection, such as RPCSEC_GSS with a security triple that uses either rpc_gss_svc_integrity or rpc_gss_svc_privacy (rpc_gss_svc_privacy includes integrity protection) service. Without integrity protection encapsulating SECINFO and therefore its results, an attacker in the middle could modify results such that the client might select a weaker algorithm in the set allowed by the server, making the client and/or server vulnerable to further attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のそのような操作はSECINFOあります。それは推奨されているクライアントの問題、それがrpc_gss_svc_integrityまたはrpc_gss_svc_privacyのいずれかを使用して、セキュリティ、トリプルでそのようなRPCSEC_GSSなど完全性保護、（rpc_gss_svc_privacyは、完全性保護を含みます）のサービスがあり、セキュリティの味で保護されるようにSECINFOコール。 SECINFOため、その結果をカプセル化する完全性保護がなければ、途中で攻撃者がさらなる攻撃へのクライアントおよび/またはサーバが脆弱作り、クライアントがサーバーによって許可されたセットの中の弱いアルゴリズムを選択するかもしれないような結果を修正することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The second operation that SHOULD use integrity protection is any GETATTR for the fs_locations attribute. The attack has two steps. First, the attacker modifies the unprotected results of some operation to return NFS4ERR_MOVED. Second, when the client follows up with a GETATTR for the fs_locations attribute, the attacker modifies the results to cause the client to migrate its traffic to a server controlled by the attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全性保護を使用すべきである第2の動作はfs_位置の属性のいずれかのGETATTRです。攻撃は、2つのステップがあります。まず、攻撃者はNFS4ERR_MOVEDを返すために、いくつかの操作の保護されていない結果を変更します。クライアントは、属性fs_位置のためのGETATTRをフォローアップしたときに第二に、攻撃者は、結果は、クライアントが攻撃者によって制御されるサーバーへのトラフィックを移行させるために変更されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because the operations SETCLIENTID/SETCLIENTID_CONFIRM are responsible for the release of client state, it is imperative that the principal used for these operations is checked against and matches with the previous use of these operations. See Section 9.1.1 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SETCLIENTID / SETCLIENTID_CONFIRM操作は、クライアント状態の解除を担当しているので、これらの操作のために使用される主はに対してチェックし、これらの操作の以前の使用と一致していることが不可欠です。さらなる議論については、セクション9.1.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unicode in the form of UTF-8 is used for file component names (i.e., both directory and file components), as well as the owner and owner_group attributes; other character sets may also be allowed for file component names. String processing (e.g., Unicode normalization) raises security concerns for string comparison. See Sections 5.9 and 12 for further discussion, and see [RFC6943] for related identifier comparison security considerations. File component names are identifiers with respect to the identifier comparison discussion in [RFC6943] because they are used to identify the objects to which ACLs are applied; see Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UTF-8形式のUnicodeファイルのコンポーネント名（すなわち、両方のディレクトリとファイルの構成要素）に使用され、同様に所有者とowner_group属性。他の文字セットは、ファイルコンポーネント名に許可することができます。文字列処理（例えば、Unicode正規化）は、文字列比較のためのセキュリティ上の問題を提起します。さらなる議論のためのセクション5.9および12を参照してください、との関連識別子比較セキュリティの考慮事項については、[RFC6943]を参照してください。ファイルコンポーネント名は、ACLが適用されるオブジェクトを識別するために使用されているため、[RFC6943]に識別子比較議論に対する識別子です。第6章を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section uses terms that are defined in [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、[RFC5226]で定義される用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1. Named Attribute Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1。名前の属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA has created a registry called the &#34;NFSv4 Named Attribute Definitions Registry&#34; for [RFC3530] and [RFC5661]. This section introduces no new changes, but it does recap the intent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、レジストリは、[RFC3530]と[RFC5661]のための「NFSv4の名前の属性の定義レジストリ」と呼ばれる作成しました。このセクションでは、新たな変化が導入されていないが、それは意図をおさらいしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4 protocol supports the association of a file with zero or more named attributes. The namespace identifiers for these attributes are defined as string names. The protocol does not define the specific assignment of the namespace for these file attributes. The IANA registry promotes interoperability where common interests exist. While application developers are allowed to define and use attributes as needed, they are encouraged to register the attributes with IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のプロトコルは、ゼロ以上の名前付き属性を持つファイルの関連付けをサポートしています。これらの属性の名前空間識別子は、文字列名として定義されています。プロトコルは、これらのファイル属性の名前空間の特定の割り当てを定義していません。 IANAレジストリは共通の利益が存在し、相互運用性を促進します。アプリケーション開発者は、必要に応じて属性を定義して使用することを許可されているが、それらは、IANAで属性を登録することが奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Such registered named attributes are presumed to apply to all minor versions of NFSv4, including those defined subsequently to the registration. Where the named attribute is intended to be limited with regard to the minor versions for which they are not to be used, the assignment in the registry will clearly state the applicable limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような登録された名前の属性が登録に続いて定義されているものを含めNFSv4のすべてのマイナーバージョンに適用すると推定されています。名前の属性は、それらが使用されるされないためにマイナーバージョンに関して限定されるものである場合は、レジストリ内の割り当ては、適用限界を明確に述べるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The registry is to be maintained using the Specification Required policy as defined in Section 4.1 of [RFC5226].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レジストリは、[RFC5226]のセクション4.1で定義されている仕様必要なポリシーを使用して維持されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Under the NFSv4 specification, the name of a named attribute can in theory be up to 2^32 - 1 bytes in length, but in practice NFSv4 clients and servers will be unable to handle a string that long. IANA should reject any assignment request with a named attribute that exceeds 128 UTF-8 characters. To give the IESG the flexibility to set up bases of assignment of Experimental Use and Standards Action, the prefixes of &#34;EXPE&#34; and &#34;STDS&#34; are Reserved. The zero-length named attribute name is Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
長さは1バイトで、実際にはNFSv4のクライアントとサーバは長く、その文字列を処理することができません - のNFSv4仕様では、指定された属性の名前は、理論的には、最大2 ^ 32することができます。 IANAは128 UTF-8文字を超える名前の属性を持つ任意の割り当て要求を拒否しなければなりません。 IESGに実験的使用と標準アクションの割り当ての拠点を設置するための柔軟性を与えるために、「EXPE」と「性感染症」のプレフィックスが予約されています。長さがゼロという名前の属性名は予約済みです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The prefix &#34;PRIV&#34; is allocated for Private Use. A site that wants to make use of unregistered named attributes without risk of conflicting with an assignment in IANA&#39;s registry should use the prefix &#34;PRIV&#34; in all of its named attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接頭辞「PRIVは、」私的使用のために割り当てられています。 IANAのレジストリに割り当てと競合する危険なしに未登録の名前の属性を使用するように望んでいるサイトでは、その名前の属性すべてに接頭辞「PRIV」を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because some NFSv4 clients and servers have case-insensitive semantics, the fifteen additional lowercase and mixed-case permutations of each of &#34;EXPE&#34;, &#34;PRIV&#34;, and &#34;STDS&#34; are Reserved (e.g., &#34;expe&#34;, &#34;expE&#34;, &#34;exPe&#34;, etc. are Reserved). Similarly, IANA must not allow two assignments that would conflict if both named attributes were converted to a common case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のNFSv4クライアントとサーバは、大文字と小文字を区別しない意味を持っているので、「EXPE」、「PRIV」、および「性感染症」のそれぞれの15追加の小文字と大文字小文字混在順列が予約されている（例えば、「EXPE」、「EXPE」、 &#34; EXPE」、など）に予約されています。同様に、IANAは、両方の名前の属性が一般的なケースに変換された場合に競合する2つの割り当てを許可してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The registry of named attributes is a list of assignments, each containing three fields for each assignment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前の属性のレジストリは、各割り当てについて、各含む3つのフィールド割り当てのリストです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. A US-ASCII string name that is the actual name of the attribute. This name must be unique. This string name can be 1 to 128 UTF-8 characters long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性の実際の名前です。1. A US-ASCII文字列名。この名前は一意である必要があります。この文字列名は1〜128 UTF-8文字の長さにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. A reference to the specification of the named attribute. The reference can consume up to 256 bytes (or more, if IANA permits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.指定された属性の仕様を参照します。 （IANAが許可する場合、またはそれ以上）の参照は、256のバイトまで消費することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. The point of contact of the registrant. The point of contact can consume up to 256 bytes (or more, if IANA permits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.登録者の接触点。 （IANAが許可する場合、またはそれ以上）の接触点は、256のバイトまで消費することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.1. Initial Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.1。初期のレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is no initial registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何の初期のレジストリはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.2. Updating Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1.2。登録の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The registrant is always permitted to update the point of contact field. To make any other change will require Expert Review or IESG Approval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
登録者は、常に連絡先フィールドのポイントを更新することが許可されています。その他の変更を行うには、専門家のレビューやIESGの承認が必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2. Updates to Existing IANA Registries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2。既存のIANA・レジストリーの更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, because this document obsoletes RFC 3530, IANA has
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書はRFC 3530を廃止するため、また、IANAがあり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o replaced all references to RFC 3530 in the Network Identifier (r_netid) registry with references to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oこのドキュメントを参照してネットワーク識別子（r_netid）レジストリ内のRFC 3530へのすべての参照を置き換え。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o replaced the reference to the nfs registration&#39;s reference to RFC 3530 in the GSSAPI/Kerberos/SASL Service names registry with a reference to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oこのドキュメントを参照してGSSAPI / Kerberosの/ SASLサービス名レジストリのRFC 3530にNFS登録の参照への参照を置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC20] Cerf, V., &#34;ASCII format for network interchange&#34;, STD 80, RFC 20, October 1969, &lt;http://www.rfc-editor.org/info/rfc20&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC20]サーフ、V.、 &#34;ネットワークの交換のためのASCIIフォーマット&#34;、STD 80、RFC 20、1969年10月、&lt;http://www.rfc-editor.org/info/rfc20&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月、&lt;http://www.rfc-editor.org/info/rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2203] Eisler, M., Chiu, A., and L. Ling, &#34;RPCSEC_GSS Protocol Specification&#34;, RFC 2203, September 1997, &lt;http://www.rfc-editor.org/info/rfc2203&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2203]アイスラー、M.、チウ、A.、およびL.リン、 &#34;RPCSEC_GSSプロトコル仕様&#34;、RFC 2203、1997年9月、&lt;http://www.rfc-editor.org/info/rfc2203&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2743] Linn, J., &#34;Generic Security Service Application Program Interface Version 2, Update 1&#34;, RFC 2743, January 2000, &lt;http://www.rfc-editor.org/info/rfc2743&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2743]リン、J.、 &#34;ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1&#34;、RFC 2743、2000年1月、&lt;http://www.rfc-editor.org/info/rfc2743&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3490] Faltstrom, P., Hoffman, P., and A. Costello, &#34;Internationalizing Domain Names in Applications (IDNA)&#34;, RFC 3490, March 2003, &lt;http://www.rfc-editor.org/info/rfc3490&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3490] Faltstrom、P.、ホフマン、P.、およびA.コステロ、 &#34;アプリケーションにおける国際化ドメイン名（IDNA）&#34;、RFC 3490、2003年3月、&lt;http://www.rfc-editor.org/info/ RFC3490&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3492] Costello, A., &#34;Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)&#34;, RFC 3492, March 2003, &lt;http://www.rfc-editor.org/info/rfc3492&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3492]コステロ、A.、 &#34;ピュニコード：アプリケーションにおける国際化ドメイン名のUnicodeのブートストリングのエンコード（IDNA）&#34;、RFC 3492、2003年3月、&lt;http://www.rfc-editor.org/info/rfc3492&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3629] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, STD 63, RFC 3629, November 2003, &lt;http://www.rfc-editor.org/info/rfc3629&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3629] Yergeau、F.、 &#34;UTF-8、ISO 10646の変換フォーマット&#34;、STD 63、RFC 3629、2003年11月、&lt;http://www.rfc-editor.org/info/rfc3629&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5226] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 5226, May 2008, &lt;http://www.rfc-editor.org/info/rfc5226&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5226] Narten氏、T.とH. Alvestrand、 &#34;RFCsにIANA問題部に書くためのガイドライン&#34;、BCP 26、RFC 5226、2008年5月、&lt;http://www.rfc-editor.org/info/rfc5226&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5403] Eisler, M., &#34;RPCSEC_GSS Version 2&#34;, RFC 5403, February 2009, &lt;http://www.rfc-editor.org/info/rfc5403&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5403]アイスラー、M.、 &#34;RPCSEC_GSSバージョン2&#34;、RFC 5403、2009年2月、&lt;http://www.rfc-editor.org/info/rfc5403&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5531] Thurlow, R., &#34;RPC: Remote Procedure Call Protocol Specification Version 2&#34;, RFC 5531, May 2009, &lt;http://www.rfc-editor.org/info/rfc5531&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5531] Thurlow、R.、 &#34;RPC：リモートプロシージャコールプロトコル仕様バージョン2&#34;、RFC 5531、2009年5月、&lt;http://www.rfc-editor.org/info/rfc5531&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5665] Eisler, M., &#34;IANA Considerations for Remote Procedure Call (RPC) Network Identifiers and Universal Address Formats&#34;, RFC 5665, January 2010, &lt;http://www.rfc-editor.org/info/rfc5665&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5665]アイスラー、M.、RFC 5665、2010年1月 &#34;リモートプロシージャコール（RPC）のネットワーク識別子とユニバーサルアドレス形式用IANAの考慮事項&#34;、&lt;http://www.rfc-editor.org/info/rfc5665&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5890] Klensin, J., &#34;Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework&#34;, RFC 5890, August 2010, &lt;http://www.rfc-editor.org/info/rfc5890&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5890] Klensin、J.、 &#34;アプリケーション（IDNA）のための国際化ドメイン名：定義とドキュメントフレームワーク&#34;、RFC 5890、2010年8月、&lt;http://www.rfc-editor.org/info/rfc5890&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5891] Klensin, J., &#34;Internationalized Domain Names in Applications (IDNA): Protocol&#34;, RFC 5891, August 2010, &lt;http://www.rfc-editor.org/info/rfc5891&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5891] Klensin、J.、 &#34;国際化ドメイン名のアプリケーション（IDNA）で：プロトコル&#34;、RFC 5891、2010年8月、&lt;http://www.rfc-editor.org/info/rfc5891&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6649] Hornquist Astrand, L. and T. Yu, &#34;Deprecate DES, RC4-HMAC-EXP, and Other Weak Cryptographic Algorithms in Kerberos&#34;, BCP 179, RFC 6649, July 2012, &lt;http://www.rfc-editor.org/info/rfc6649&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6649] Hornquist Astrand、L.とT.ゆう、 &#34;廃止DES、RC4-HMAC-EXP、およびKerberosの他の弱い暗号アルゴリズム&#34;、BCP 179、RFC 6649、2012年7月、&lt;のhttp：//www.rfc- editor.org/info/rfc6649&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7531] Haynes, T., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 External Data Representation Standard (XDR) Description&#34;, RFC 7531, March 2015, &lt;http://www.rfc-editor.org/info/rfc7531&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。[RFC7531]ヘインズ、T.、エド、およびD. Noveck、エド、 &#34;ネットワークファイルシステム（NFS）バージョン4外部データ表現標準（XDR）の説明&#34;、RFC 7531、2015年3月、&lt;のhttp：// WWW .rfc-editor.org /情報/ rfc7531&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SPECIALCASING] The Unicode Consortium, &#34;SpecialCasing-7.0.0.txt&#34;, Unicode Character Database, March 2014, &lt;http://www.unicode.org/ Public/UCD/latest/ucd/SpecialCasing.txt&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SPECIALCASING]はUnicodeコンソーシアム、 &#34;SpecialCasing-7.0.0.txt&#34;、Unicode文字データベース、2014年3月、&lt;http://www.unicode.org/公開/ UCD /最新/ UCD / SpecialCasing.txt&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[UNICODE] The Unicode Consortium, &#34;The Unicode Standard, Version 7.0.0&#34;, (Mountain View, CA: The Unicode Consortium, 2014 ISBN 978-1-936213-09-2), June 2014, &lt;http://www.unicode.org/versions/latest/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[UNICODE]のUnicodeコンソーシアム、 &#34;Unicode標準、バージョン7.0.0&#34;、（カリフォルニア州マウンテンビュー：ユニコードコンソーシアム、2014 ISBN 978-1-936213-09-2）、2014年6月、&lt;のhttp：// WWW .unicode.org /バージョン/最新/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[openg_symlink] The Open Group, &#34;Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[openg_symlink]オープングループ、 &#34;Open Groupの基本仕様問題7の基本定義の章3節3.372&#34;、IEEE STD 1003.1、2013年版（HTML版）、ISBN 1937218287、2013年4月、&lt;のhttp：// WWW。 opengroup.org/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Chet] Juszczak, C., &#34;Improving the Performance and Correctness of an NFS Server&#34;, USENIX Conference Proceedings, June 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[チェット] Juszczak、C.、「パフォーマンスとNFSサーバーの正しさを改善」、USENIX会議議事録、1990年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Floyd] Floyd, S. and V. Jacobson, &#34;The Synchronization of Periodic Routing Messages&#34;, IEEE/ACM Transactions on Networking 2(2), pp. 122-136, April 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[フロイド]フロイド、S.およびV. Jacobsonの &#34;周期的ルーティングメッセージの同期&#34;、ネットワーク2（2）、頁122から136まで、1994年4月にIEEE / ACMトランザクション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IESG_ERRATA] IESG, &#34;IESG Processing of RFC Errata for the IETF Stream&#34;, July 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IESG_ERRATA] IESG、 &#34;IETF RFCストリームのための正誤表のIESG処理&#34;、2008年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MS-SMB] Microsoft Corporation, &#34;Server Message Block (SMB) Protocol Specification&#34;, MS-SMB 43.0, May 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MS-SMB]マイクロソフトコーポレーション、 &#34;サーバーメッセージブロック（SMB）プロトコル仕様&#34;、MS-SMB 43.0、2014年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[P1003.1e] Institute of Electrical and Electronics Engineers, Inc., &#34;IEEE Draft P1003.1e&#34;, 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[P1003.1e]電気電子技術株式会社、 &#34;IEEEドラフトP1003.1e&#34;、1997年の研究所。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1094] Nowicki, B., &#34;NFS: Network File System Protocol specification&#34;, RFC 1094, March 1989, &lt;http://www.rfc-editor.org/info/rfc1094&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1094] Nowicki、B.、 &#34;NFS：ネットワークシステムプロトコル仕様書ファイル&#34;、RFC 1094、1989年3月、&lt;http://www.rfc-editor.org/info/rfc1094&gt;を。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1813] Callaghan, B., Pawlowski, B., and P. Staubach, &#34;NFS Version 3 Protocol Specification&#34;, RFC 1813, June 1995, &lt;http://www.rfc-editor.org/info/rfc1813&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1813]キャラハン、B.、ポロウスキー、B.、およびP.ストーバック、 &#34;NFSバージョン3プロトコル仕様&#34;、RFC 1813、1995年6月、&lt;http://www.rfc-editor.org/info/rfc1813&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1833] Srinivasan, R., &#34;Binding Protocols for ONC RPC Version 2&#34;, RFC 1833, August 1995, &lt;http://www.rfc-editor.org/info/rfc1833&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1833]スリニバサン、R.、 &#34;ONC RPCバージョン2のプロトコルのバインド&#34;、RFC 1833、1995年8月、&lt;http://www.rfc-editor.org/info/rfc1833&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2054] Callaghan, B., &#34;WebNFS Client Specification&#34;, RFC 2054, October 1996, &lt;http://www.rfc-editor.org/info/rfc2054&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2054]キャラハン、B.、 &#34;WebNFSのクライアント仕様&#34;、RFC 2054、1996年10月、&lt;http://www.rfc-editor.org/info/rfc2054&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2055] Callaghan, B., &#34;WebNFS Server Specification&#34;, RFC 2055, October 1996, &lt;http://www.rfc-editor.org/info/rfc2055&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2055]キャラハン、B.、 &#34;WebNFSのサーバー仕様&#34;、RFC 2055、1996年10月、&lt;http://www.rfc-editor.org/info/rfc2055&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2224] Callaghan, B., &#34;NFS URL Scheme&#34;, RFC 2224, October 1997, &lt;http://www.rfc-editor.org/info/rfc2224&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2224]キャラハン、B.、 &#34;NFS URLスキーム&#34;、RFC 2224、1997年10月、&lt;http://www.rfc-editor.org/info/rfc2224&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2623] Eisler, M., &#34;NFS Version 2 and Version 3 Security Issues and the NFS Protocol&#39;s Use of RPCSEC_GSS and Kerberos V5&#34;, RFC 2623, June 1999, &lt;http://www.rfc-editor.org/info/rfc2623&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2623]アイスラー、M.、 &#34;NFSバージョン2およびバージョン3のセキュリティ問題とRPCSEC_GSSとケルベロスV5のNFSプロトコルの使用&#34;、RFC 2623、1999年6月、&lt;http://www.rfc-editor.org/info/ rfc2623&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2624] Shepler, S., &#34;NFS Version 4 Design Considerations&#34;, RFC 2624, June 1999, &lt;http://www.rfc-editor.org/info/rfc2624&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2624] Shepler、S.、 &#34;NFSバージョン4の設計上の考慮事項&#34;、RFC 2624、1999年6月、&lt;http://www.rfc-editor.org/info/rfc2624&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2755] Chiu, A., Eisler, M., and B. Callaghan, &#34;Security Negotiation for WebNFS&#34;, RFC 2755, January 2000, &lt;http://www.rfc-editor.org/info/rfc2755&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2755]チウ、A.、アイスラー、M.、およびB.キャラハン、 &#34;WebNFSのためのセキュリティネゴシエーション&#34;、RFC 2755、2000年1月、&lt;http://www.rfc-editor.org/info/rfc2755&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3010] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, &#34;NFS version 4 Protocol&#34;, RFC 3010, December 2000, &lt;http://www.rfc-editor.org/info/rfc3010&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3010] Shepler、S.、キャラハン、B.、ロビンソン、D.、Thurlow、R.、Beame、C.、アイスラー、M.、およびD. Noveck、 &#34;NFSバージョン4プロトコル&#34;、RFC 3010、2000年12月、&lt;http://www.rfc-editor.org/info/rfc3010&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3232] Reynolds, J., Ed., &#34;Assigned Numbers: RFC 1700 is Replaced by an On-line Database&#34;, RFC 3232, January 2002, &lt;http://www.rfc-editor.org/info/rfc3232&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3232]レイノルズ、J.、エド、 &#34;番号が割り当てられ：RFC 1700は、オンラインデータベースで置き換えられる&#34;。、RFC 3232、2002年1月、&lt;http://www.rfc-editor.org/info/rfc3232&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3530] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, &#34;Network File System (NFS) version 4 Protocol&#34;, RFC 3530, April 2003, &lt;http://www.rfc-editor.org/info/rfc3530&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3530] Shepler、S.、キャラハン、B.、ロビンソン、D.、Thurlow、R.、Beame、C.、アイスラー、M.、およびD. Noveck、 &#34;ネットワークファイルシステム（NFS）バージョン4プロトコル&#34;、 RFC 3530、2003年4月、&lt;http://www.rfc-editor.org/info/rfc3530&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, &#34;The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2&#34;, RFC 4121, July 2005, &lt;http://www.rfc-editor.org/info/rfc4121&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4121]朱、L.、Jaganathan、K.、およびS.ハートマン、 &#34;Kerberosバージョン5の汎用セキュリティサービスアプリケーションプログラムインタフェース（GSS-API）メカニズム：バージョン2&#34;、RFC 4121、2005年7月、&lt;のhttp：/ /www.rfc-editor.org/info/rfc4121&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4178] Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &#34;The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism&#34;, RFC 4178, October 2005, &lt;http://www.rfc-editor.org/info/rfc4178&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4178]朱、L.、リーチ、P.、Jaganathan、K.、およびW.インガーソル、 &#34;単純で保護された一般的なセキュリティサービスアプリケーションプログラムインタフェース（GSS-API）交渉メカニズム&#34;、RFC 4178、2005年10月、&lt; http://www.rfc-editor.org/info/rfc4178&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4506] Eisler, M., Ed., &#34;XDR: External Data Representation Standard&#34;, STD 67, RFC 4506, May 2006, &lt;http://www.rfc-editor.org/info/rfc4506&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4506]アイスラー、M.、エド、 &#34;XDR：外部データ表現標準&#34;。、STD 67、RFC 4506、2006年5月、&lt;http://www.rfc-editor.org/info/rfc4506&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4511] Sermersheim, J., Ed., &#34;Lightweight Directory Access Protocol (LDAP): The Protocol&#34;, RFC 4511, June 2006, &lt;http://www.rfc-editor.org/info/rfc4511&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4511] Sermersheim、J.、エド、 &#34;ライトウェイトディレクトリアクセスプロトコル（LDAP）：プロトコル&#34;、RFC 4511、2006年6月、&lt;http://www.rfc-editor.org/info/rfc4511&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, August 2008, &lt;http://www.rfc-editor.org/info/rfc5246&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5246]ダークス、T.およびE.レスコラ、 &#34;トランスポート層セキュリティ（TLS）プロトコルバージョン1.2&#34;、RFC 5246、2008年8月、&lt;http://www.rfc-editor.org/info/rfc5246&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 Protocol&#34;, RFC 5661, January 2010, &lt;http://www.rfc-editor.org/info/rfc5661&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5661] Shepler、S.、エド。、アイスラー、M.、エド。、およびD. Noveck、エド。、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル&#34;、RFC 5661、2010年1月、&lt;HTTP ：//www.rfc-editor.org/info/rfc5661&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6365] Hoffman, P. and J. Klensin, &#34;Terminology Used in Internationalization in the IETF&#34;, BCP 166, RFC 6365, September 2011, &lt;http://www.rfc-editor.org/info/rfc6365&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6365]ホフマン、P.およびJ. Klensin、 &#34;IETFでの国際化に使用される用語&#34;、BCP 166、RFC 6365、2011年9月、&lt;http://www.rfc-editor.org/info/rfc6365&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6943] Thaler, D., Ed., &#34;Issues in Identifier Comparison for Security Purposes&#34;, RFC 6943, May 2013, &lt;http://www.rfc-editor.org/info/rfc6943&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6943]ターラー、D.編、 &#34;セキュリティ目的のための識別子の比較では問題&#34;、RFC 6943、2013年5月、&lt;http://www.rfc-editor.org/info/rfc6943&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[fcntl] The Open Group, &#34;Section &#39;fcntl()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[fcntlの] &#34;Open Groupの基本仕様問題7のシステムインターフェースのセクション &#39;のfcntl（）&#39;&#34; Open Groupの、IEEE STD 1003.1、2013年版（HTML版）、ISBN 1937218287、2013年4月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[fsync] The Open Group, &#34;Section &#39;fsync()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[fsyncを] &#34;Open Groupの基本仕様問題7のシステムインターフェースのセクション &#39;にfsync（）&#39;&#34; Open Groupの、IEEE STD 1003.1、2013年版（HTML版）、ISBN 1937218287、2013年4月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[getpwnam] The Open Group, &#34;Section &#39;getpwnam()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[のgetpwnam] &#34;Open Groupの基本仕様問題7のシステムインターフェースのセクション &#39;のgetpwnam（）&#39;&#34; Open Groupの、IEEE STD 1003.1、2013年版（HTML版）、ISBN 1937218287、2013年4月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[read_api] The Open Group, &#34;Section &#39;read()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[read_api]オープングループ、 &#34;セクション &#39;（読み込み）&#39; システムOpen Groupの基本仕様問題7のインターフェースの&#34;、IEEE STD 1003.1、2013年版（HTML版）、ISBN 1937218287、2013年4月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[readdir_api] The Open Group, &#34;Section &#39;readdir()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[readdir_api] &#34;Open Groupの基本仕様問題7のシステムインターフェースのセクション &#39;のreaddir（）&#39;&#34; Open Groupの、IEEE STD 1003.1、2013年版（HTML版）、ISBN 1937218287、2013年4月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[stat] The Open Group, &#34;Section &#39;stat()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[STAT]オープングループ、 &#34;節 &#39;のstat（）&#39; Open Groupの基本仕様問題7のシステムインターフェースの&#34;、IEEE STD 1003.1、2013年版（HTML版）、ISBN 1937218287、2013年4月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[unlink] The Open Group, &#34;Section &#39;unlink()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;Open Groupの基本仕様問題7のシステムインターフェースのセクション &#39;リンク解除（）&#39;&#34; [リンク解除]オープングループ、IEEE STD 1003.1、2013年版（HTML版）、ISBN 1937218287、2013年4月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[write_api] The Open Group, &#34;Section &#39;write()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287, April 2013, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[write_api] &#34;Open Groupの基本仕様問題7のシステムインターフェースのセクション &#39;書き込み（）&#39;&#34; Open Groupの、IEEE STD 1003.1、2013年版（HTML版）、ISBN 1937218287、2013年4月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[xnfs] The Open Group, &#34;Protocols for Interworking: XNFS, Version 3W, ISBN 1-85912-184-5&#34;, February 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[xnfs]オープングループ、 &#34;インターワーキングのためのプロトコル：XNFS、バージョン3W、ISBN 1-85912-184-5&#34;、1998年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A bis is certainly built on the shoulders of the first attempt. Spencer Shepler, Brent Callaghan, David Robinson, Robert Thurlow, Carl Beame, Mike Eisler, and David Noveck are responsible for a great deal of the effort in this work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビスは、確かに最初の試みの肩の上に構築されています。スペンサーShepler、ブレントキャラハン、デビッド・ロビンソン、ロバートThurlow、カールBeame、マイク・アイスラー、とDavid Noveckが、この作品では多大な労力を担当しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tom Haynes would like to thank NetApp, Inc. for its funding of his time on this project.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トム・ヘインズは、このプロジェクトの自分の時間の資金調達のためのNetApp、Inc.に感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rob Thurlow clarified how a client should contact a new server if a migration has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロブThurlowは、移行が発生した場合、クライアントは新しいサーバに接続する方法を明らかにしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Black, Nico Williams, Mike Eisler, Trond Myklebust, James Lentini, and Mike Kupfer read many earlier draft versions of Section 12 and contributed numerous useful suggestions, without which the necessary revision of that section for this document would not have been possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デビッド・ブラック、ニコ・ウィリアムズ、マイク・アイスラー、トロンMyklebust、ジェームズレンティーニ、およびマイク・クッパーは、第12節の多くの以前のドラフト版を読んで、この文書のそのセクションの必要な改正ができなかったであろうことなく、多数の有益な提案を、貢献しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Peter Staubach read almost all of the earlier draft versions of Section 12, leading to the published result, and his numerous comments were always useful and contributed substantially to improving the quality of the final result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピーター・ストーバックは、公表された結果につながる、ほぼすべてのセクション12の以前のドラフトバージョンのを読んで、そして彼の数多くのコメントは常に有用であったと最終結果の質の向上に大きく貢献しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Peter Saint-Andre was gracious enough to read the most recent draft version of Section 12 and provided some key insight as to the concerns of the Internationalization community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピーターサンアンドレは、第12節の最も最近のドラフト版を読むのに十分な優雅だったし、国際社会の懸念になど、いくつかの重要な洞察を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
James Lentini graciously read the rewrite of Section 8, and his comments were vital in improving the quality of that effort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジェームズ・レンティーニは優雅にセクション8の書き換えを読んで、彼のコメントは、その努力の質の向上に不可欠でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rob Thurlow, Sorin Faibish, James Lentini, Bruce Fields, and Trond Myklebust were faithful attendants of the biweekly triage meeting and accepted many an action item.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロブThurlow、ソリンFaibish、ジェームズ・レンティーニ、ブルース・フィールド、およびトロンMyklebustは隔週トリアージ会の忠実な従者であり、多くのアクションアイテムを受け入れました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bruce Fields was a good sounding board for both the third edge condition and courtesy locks in general. He was also the leading advocate of stamping out backport issues from [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブルース・フィールドは第三のエッジ条件と一般に礼儀ロックの両方に優れたサウンドボードでした。彼はまた、[RFC5661]からのバックポートの問題を打ち抜いの主要な提唱者でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Marcel Telka was a champion of straightening out the difference between a lock-owner and an open-owner. He has also been diligent in reviewing the final document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルセルTelkaは、ロック所有者とオープン所有者の間の差を矯正のチャンピオンになりました。彼はまた、最終的な文書のレビューに勤勉されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Benjamin Kaduk reminded us that DES is dead, and Nico Williams helped us close the lid on the coffin.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ベンジャミンKadukはDESが死んでいることを私たちに思い出させ、そしてニコ・ウィリアムズは、私たちは棺の上に蓋を閉じて助けました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Elwyn Davies provided a very thorough and engaging Gen-ART review; thanks!
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エルウィン・デイヴィスは非常に徹底した魅力のGen-ARTのレビューを提供します。ありがとう！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thomas Haynes (editor) Primary Data, Inc. 4300 El Camino Real Ste 100 Los Altos, CA 94022 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トーマス・ヘインズ（編集者）プライマリ・データ、株式会社4300エル・カミノレアルサント100ロスアルトス、CA 94022米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 408 215 1519 EMail: thomas.haynes@primarydata.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 408 215 1519 Eメール：thomas.haynes@primarydata.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Noveck (editor) Dell 300 Innovative Way Nashua, NH 03062 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デビッドNoveck（エディタ）のDell 300革新的な方法ナシュア、ニューハンプシャー03062米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 781 572 8038 EMail: dave_noveck@dell.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 781 572 8038 Eメール：dave_noveck@dell.com
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
