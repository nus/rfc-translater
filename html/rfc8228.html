<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8228 - Guidance on Designing Label Generation Rulesets (LGRs) Supporting Variant Labels 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8228</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc8228">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8228 - Guidance on Designing Label Generation Rulesets (LGRs) Supporting Variant Labels 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8228">
              https://tools.ietf.org/html/rfc8228
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8228 - ラベル生成ルールセット（LGRs）バリアントラベルをサポートする設計上の指針</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                        A. Freytag
Request for Comments: 8228                                   August 2017
Category: Informational
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Guidance on Designing Label Generation Rulesets (LGRs) Supporting Variant Labels
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベル生成ルールセット（LGRs）バリアントラベルをサポートする設計上の指針
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rules for validating identifier labels and alternate representations of those labels (variants) are known as Label Generation Rulesets (LGRs); they are used for the implementation of identifier systems such as Internationalized Domain Names (IDNs). This document describes ways to design LGRs to support variant labels. In designing LGRs, it is important to ensure that the label generation rules are consistent and well behaved in the presence of variants. The design decisions can then be expressed using the XML representation of LGRs that is defined in RFC 7940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別子ラベル及びこれらのラベル（変異体）の代替表現を検証するための規則は、ラベル生成ルールセット（LGRs）として知られています。それらは、国際化ドメイン名（IDNドメイン）などの識別子システムの実装のために使用されます。この文書では、バリアントのラベルをサポートするためにLGRsを設計する方法を説明します。 LGRsの設計では、ラベル生成ルールは一貫してうまく変異体の存在に振る舞っていることを確認することが重要です。設計の決定は、その後RFC 7940で定義されてLGRsのXML表現を用いて表現することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8228.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8228で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Variant Relations . . . . . . . . . . . . . . . . . . . . . .   4
   3.  Symmetry and Transitivity . . . . . . . . . . . . . . . . . .   5
   4.  A Word on Notation  . . . . . . . . . . . . . . . . . . . . .   5
   5.  Variant Mappings  . . . . . . . . . . . . . . . . . . . . . .   6
   6.  Variant Labels  . . . . . . . . . . . . . . . . . . . . . . .   7
   7.  Variant Types and Label Dispositions  . . . . . . . . . . . .   7
   8.  Allocatable Variants  . . . . . . . . . . . . . . . . . . . .   8
   9.  Blocked Variants  . . . . . . . . . . . . . . . . . . . . . .   9
   10. Pure Variant Labels . . . . . . . . . . . . . . . . . . . . .  10
   11. Reflexive Variants  . . . . . . . . . . . . . . . . . . . . .  11
   12. Limiting Allocatable Variants by Subtyping  . . . . . . . . .  12
   13. Allowing Mixed Originals  . . . . . . . . . . . . . . . . . .  14
   14. Handling Out-of-Repertoire Variants . . . . . . . . . . . . .  15
   15. Conditional Variants  . . . . . . . . . . . . . . . . . . . .  16
   16. Making Conditional Variants Well Behaved  . . . . . . . . . .  18
   17. Variants for Sequences  . . . . . . . . . . . . . . . . . . .  19
   18. Corresponding XML Notation  . . . . . . . . . . . . . . . . .  21
   19. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  22
   20. Security Considerations . . . . . . . . . . . . . . . . . . .  23
   21. References  . . . . . . . . . . . . . . . . . . . . . . . . .  23
     21.1.  Normative References . . . . . . . . . . . . . . . . . .  23
     21.2.  Informative References . . . . . . . . . . . . . . . . .  23
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  24
   Author&#39;s Address  . . . . . . . . . . . . . . . . . . . . . . . .  24
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Label Generation Rulesets (LGRs) that define the set of permissible labels may be applied to identifier systems that rely on labels, such as the Domain Name System (DNS) [RFC1034] [RFC1035]. To date, LGRs have mostly been used to define policies for implementing Internationalized Domain Names (IDNs) using IDNA2008 [RFC5890] [RFC5891] [RFC5892] [RFC5893] [RFC5894] in the DNS. This document aims to discuss the generation of LGRs for such circumstances, but the techniques and considerations here are almost certainly applicable to a wider range of internationalized identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
許容ラベルのセットを定義するラベル生成ルールセット（LGRs）は、ドメインネームシステム（DNS）[RFC1034]、[RFC1035]のような標識に依存しているシステムを、識別子に適用されてもよいです。現在までに、LGRsは主にDNSに[RFC5891] [RFC5892] [RFC5893] [RFC5894] IDNA2008 [RFC5890]を使用して国際化ドメイン名（IDNの）を実装するためのポリシーを定義するために使用されています。この文書では、このような状況のためLGRsの生成を議論することを目指していますが、ここでは技術と注意事項は、ほぼ確実に国際化識別子の広い範囲に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to determining whether a given label is eligible, LGRs may also define the condition under which alternate representations of these labels, so-called &#34;variant labels&#34;, may exist and their status (disposition). In the most general sense, variant labels are typically labels that are either visually or semantically indistinguishable from another label in the context of the writing system or script supported by the LGR. Unlike merely similar labels, where there may be a measurable degree of similarity, variant labels considered here represent a form of equivalence in meaning or appearance. What constitutes an appropriate variant in any writing system or given context, particularly in the DNS, is assumed to have been determined ahead of time and therefore is not a subject of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所定のラベルが適格であるかどうかを決定することに加えて、LGRsはまた、これらのラベルの代替表現、いわゆる「変異体ラベル」は、存在するとその状態（配置）可能性がある条件を定義することができます。最も一般的な意味では、変異体ラベルは、視覚的にまたはLGRでサポートされている書き込み方式またはスクリプトのコンテキストで別のラベルから意味的に区別できないラベルは、典型的には。類似の測定可能な程度があるかもしれない単に同様のラベルとは異なり、ここで考慮さバリアントラベルは意味や外観等価の形態を表します。どのような任意の書記体系または所与の文脈における適切な変形例を構成する、特にDNSに、前もって決定されていると仮定され、従って、本書の主題ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once identified, variant labels are typically delegated to some entity together with the applied-for label, or permanently reserved, based on the disposition derived from the LGR. Correctly defined, variant labels can improve the security of an LGR, yet successfully defining variant rules for an LGR so that the result is well behaved is not always trivial. This document describes the basic considerations and constraints that must be taken into account and gives examples of what might be use cases for different types of variant specifications in an LGR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦同定されると、バリアントのラベルは、一般的に適用される-のラベルと一緒にいくつかのエンティティに委任されている、または恒久的にLGR由来処分に基づいて、予約済み。正しく定義され、バリアントラベルはLGRのセキュリティを向上させることができ、まだ行儀され、結果は必ずしも容易ではありませんように成功LGRのためのバリアントルールを定義します。この文書では、考慮されなければならない基本的な考慮事項と制約について説明し、LGRでバリアント仕様のさまざまな種類の使用例かもしれないものの例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not address whether variants are an appropriate means to solve any given issue or the basis on which they should be defined. It is intended to explain in more detail the effects of various declarations and the trade-offs in making design choices. It implicitly assumes that any LGR will be expressed using the XML representation defined in [RFC7940] and therefore conforms to any requirements stated therein. Purely for clarity of exposition, examples in this document use a more compact notation than the XML syntax defined in [RFC7940]. However, the reader is expected to have some familiarity with the concepts described in that RFC (see Section 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、変異体は、任意の問題や、それが定義されるべきで基礎を解決するための適切な手段であるかどうか対応していません。より詳細に設計上の選択を行うことで、様々な宣言とトレードオフの効果を説明することを意図しています。これは、暗黙的に、任意のLGRは、[RFC7940]で定義されたXML表現を用いて表現し、その中に記載の任意の要件に適合されることを想定しています。純粋に説明の明確化のために、このドキュメントの例は、[RFC7940]で定義されたXML構文よりもコンパクトな表記法を使用します。しかし、読者がそのRFCに記載の概念をある程度の知識を有することが期待される（セクション4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user of any identifier system, such as the DNS, interacts with it in the context of labels; variants are experienced as variant labels, i.e., two (or more) labels that are functionally &#34;same as&#34; under the conventions of the writing system used, even though their code point sequences are different. An LGR specification, on the other hand, defines variant mappings between code points and, only in a secondary step, derives the variant labels from these mappings. For a discussion of this process, see [RFC7940].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DNSなどの任意の識別子システムのユーザは、ラベルの文脈でそれと相互作用します。変異体は、変異体ラベル、すなわち、2つ（またはそれ以上）、それらのコードポイント配列が異なっていても、機能的に使用される書き込みシステムの規則の下で「同じ」であるラベルとして経験されます。 LGR仕様は、一方で、コード・ポイントとの間で変異のマッピングを定義し、唯一二ステップにおいて、これらのマッピングから変異体ラベルを導出します。このプロセスの議論に関しては、[RFC7940]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The designer of an LGR can control whether some or all of the variant labels created from an original label should be allocatable, i.e., available for allocation (to the original applicant), or whether some or all of these labels should be blocked instead, i.e., remain not allocatable (to anyone). This document describes how this choice of label disposition is accomplished (see Section 7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LGRの設計者は、元のラベルから作成された変異型のラベルの一部または全部が（元申請者に）割り当てのために利用できる、すなわち、割り当て可能にするかどうかを制御することができ、またはこれらのラベルの一部または全部が、つまり代わりにブロックされるべきかどうか、（誰に）割り当て可能ではないまま。このドキュメントでは、ラベル配置のこの選択は（セクション7を参照）が達成される方法を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The choice of desired label disposition would be based on the expectations of the users of the particular zone; it is not the subject of this document. Likewise, this document does not address the possibility of an LGR defining custom label dispositions. Instead, this document suggests ways of designing an LGR to achieve the selected design choice for handling variants in the context of the two standard label dispositions: &#34;allocatable&#34; and &#34;blocked&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
希望ラベル配置の選択は、特定のゾーンのユーザーの期待に基づいてされるだろう。それは、このドキュメントの対象ではありません。同様に、このドキュメントは、カスタムラベルの処分を定義LGRの可能性を言及していません。代わりに、この文書は、2つの標準的なラベル処分の文脈でバリアントを処理するために選択された設計上の選択を達成するためのLGRを設計する方法を提案している：「割付け」と「ブロック」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information in this document is based on operational experience gained in developing LGRs for a wide number of languages and scripts using RFC 7940. This information is provided here as a benefit to the wider community. It does not alter or change the specification found in RFC 7940 in any way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの情報は、運用経験に基づいています。この情報は、より広いコミュニティへの特典として、ここで提供されるRFC 7940を使用して言語やスクリプトの広い数のLGRsの開発で培いました。それはどのような方法でRFC 7940で見つかった仕様を変更したり、変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Variant Relations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.バリアントの関係
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A variant relation is fundamentally a &#34;same as&#34; relation; in other words, it is an equivalence relation. Now, the strictest sense of &#34;same as&#34; would be equality, and for any equality, we have both symmetry
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアント関係は、基本的関係「と同じ」です。言い換えれば、それは同値関係です。さて、「同じ」の厳密な意味では平等になり、そして任意の平等のために、我々は両方の対称性を持っています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A = B =&gt; B = A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A = B =&gt; B = A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and transitivity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして、推移
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A = B and B = C =&gt; A = C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A = B及びB = C =&gt; A = C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The variant relation with its functional sense of &#34;same as&#34; must really satisfy the same constraint. Once we say A is the &#34;same as&#34; B, we also assert that B is the &#34;same as&#34; A. In this document, the symbol &#34;~&#34; means &#34;has a variant relation with&#34;. Thus, we get
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「同じ」のその機能的意味を持つ変種関係は実際には同じ制約を満たさなければなりません。私たちは、AはB「と同じ」であると言ったら、我々はまた、Bは、本文書にA.、記号「〜」を意味し、「バリアントと関係を持っている」「同じ」である主張しています。したがって、我々が得ます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A ~ B =&gt; B ~ A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A〜B =&gt; B〜A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Likewise, if we make the same claim for B and C (B ~ C), then we get A ~ C, because if B is the &#34;same as&#34; both A and C, then A must be the &#34;same as&#34; C:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
：私たちはBとC（B〜C）のために同じ請求を行う場合はBはAとCの両方「同じ」である場合、C「と同じ」でなければならないので同様に、我々は、〜Cを得ます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A ~ B and B ~ C =&gt; A ~ C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
〜BとB〜C =&gt; A〜C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Symmetry and Transitivity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.対称性と推移性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Not all potential relations between labels constitute equivalence, and those that do not are not transitive and may not be symmetric. For example, the degree to which labels are confusable is not transitive: two labels can be confusingly similar to a third without necessarily being confusable with each other, such as when the third one has a shape that is &#34;in between&#34; the other two. In contrast, a relation based on identical or effectively identical appearance would meet the criterion of transitivity, and we would consider it a variant relation. Examples of variant relations include other forms of equivalence, such as semantic equivalence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベル間のすべての潜在的な関係は、同値を構成し、かつ推移的ではありませんしていないと対称ではないかもしれないものではありません。例えば、ラベルが混同されている程度は推移的でない2つの標識は、第三の一つが他の二つの「間に」ある形状を有する場合のように、必ずしも互いに混同することなく、第三に紛らわしいことができます。これとは対照的に、同一または効果的に同じ外観に基づく関係は推移性の基準を満たすだろう、と私たちはそれバリアント関係を検討します。バリアント関係の例としては、セマンティック等価として等価の他の形態を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using [RFC7940], a set of mappings could be defined that is neither symmetric nor transitive; such a specification would be formally valid. However, a symmetric and transitive set of mappings is strongly preferred as a basis for an LGR, not least because of the benefits from an implementation point of view; for example, if all mappings are symmetric and transitive, it greatly simplifies the check for collisions between labels with variants. For this reason, we will limit the discussion in this document to those relations that are symmetric and transitive. Incidentally, it is often straightforward to verify mechanically whether an LGR is symmetric and/or transitive and to compute any mappings required to make it so (but see Section 15).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940]を使用して、マッピングのセットは、対称でも推移的でもないように定義することができます。そのような仕様は、正式に有効となります。しかし、マッピングの対称と推移セットは強くなく、少なくともため、実装の観点から利点のLGRのための基礎として好ましいです。すべてのマッピングが対称と推移している場合例えば、それは非常にバリエーションを持つラベル間の衝突のチェックを簡素化します。このような理由から、我々は対称と推移しているそれらの関係には、この文書の議論を制限します。なお、LGRが対称および/または推移的であるかどうかを機械的に検証するので、それを行う（ただし、セクション15を参照）に必要な任意のマッピングを計算することがしばしば容易です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. A Word on Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
表記上の4 AのWord
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940] defines an XML schema for Label Generation Rulesets in general and variant code points and sequences in particular (see Section 18). That notation is rather verbose and can easily obscure salient features to anyone not trained to read XML. For this reason, this document uses a symbolic shorthand notation in presenting the examples for discussion. This shorthand is merely a didactic tool for presentation and is not intended as an alternative to or replacement for the XML syntax that is used in formally specifying an LGR under [RFC7940].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940]は一般バリアントコードポイントと配列（特に、セクション18を参照）におけるラベル生成ルールセットのXMLスキーマを定義します。その表記はかなり冗長であり、容易にXMLを読み取るために訓練を受けていない人には顕著な特徴を不明瞭することができます。このため、このドキュメントは、議論のための例を提示するシンボリック省略表記を使用しています。この速記は、単にプレゼンテーションのための教訓的なツールであると正式に[RFC7940]の下LGRを指定する際に使用されるXML構文についての代替または交換するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When it comes time to capture the LGR in a formal definition, the notation used for any of the examples in this document can be converted to the XML format as described in Section 18.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは正式な定義でLGRをキャプチャする時間が来るとき、セクション18で説明したように、このドキュメントの例のいずれかのために使用される表記法は、XML形式に変換することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Variant Mappings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.バリアントマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So far, we have treated variant relations as simple &#34;same as&#34; relations, ignoring that each relation representing equivalence would consist of a symmetric pair of reciprocal mappings. In this document, the symbol &#34;--&gt;&#34; means &#34;maps to&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのところ、我々が扱ってきバリアントの関係のような単純な等価性を表す各関係は相互のマッピングの対称ペアで構成されますことを無視して関係、「同じ」。この文書では、記号「 - &gt;」手段「のマップへ」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ~ B =&gt; A --&gt; B, B --&gt; A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A〜B =&gt; A  - &gt; B、B  - &gt; A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In an LGR, these mappings are not defined directly between labels but between code points (or code point sequences; see Section 17). In the transitive case, given
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LGRでは、これらのマッピングは、ラベル間が、コード・ポイント間で直接定義されていない（またはコードポイント配列;セクション17を参照します）。推移場合には、与えられました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ~ B =&gt; A --&gt; B, B --&gt; A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A〜B =&gt; A  - &gt; B、B  - &gt; A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ~ C =&gt; A --&gt; C, C --&gt; A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
〜C =&gt; A  - &gt; C、C  - &gt; A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
we also get
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々はまた、取得します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B ~ C =&gt; B --&gt; C, C --&gt; B
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B〜C =&gt; B  - &gt; C、C  - &gt; B
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
for a total of six possible mappings. Conventionally, these are listed in tables in order of the source code point, like so:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6つの可能なマッピングの合計。従来、これらのようなので、ソース・コード・ポイントの順序で表に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A --&gt; B A --&gt; C B --&gt; A B --&gt; C C --&gt; A C --&gt; B
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
 - &gt; B A  - &gt; C B  - &gt; B  - &gt; C C  - &gt; A C  - &gt; B
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As we can see, A, B, and C can each be mapped two ways.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々が見ることができるように、A、B、及びCは、それぞれ2つの方法でマッピングすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Variant Labels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.バリアントラベル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To create a variant label, each code point in the original label is successively replaced by all variant code points defined by a mapping from the original code point. For a label AAA (the letter &#34;A&#34; three times), the variant labels (given the mappings from the transitive example above) would be
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変異体ラベルを作成するには、元のラベルの各コードポイントを順次元のコードポイントからのマッピングによって定義されたすべてのバリアントコードポイントによって置き換えられます。ラベルAAA（文字「」三回）のために、（上記の推移の例からマッピング与えられた）変異体ラベルは次のようになり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAB ABA ABB BAA BAB BBA BBB AAC ... CCC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
アラクラブや両親...両親は、腫瘍のバラCCCが来ました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So far, we have merely defined what the variant labels are, but we have not considered their possible dispositions. In the next section, we discuss how to set up the variant mappings so that some variant labels are mutually exclusive (blocked), but some may be allocated to the same applicant as the original label (allocatable).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのところ、我々は単にバリアントのラベルが何であるかを定義しているが、我々は彼らの可能な処分を検討していません。次のセクションでは、我々はいくつかのバリエーションラベルが（ブロック）相互に排他的ですが、いくつかは、元のラベル（割り当て可能）と同じ申請者に割り当てることができるように変種のマッピングを設定する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Variant Types and Label Dispositions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.バリアントタイプとラベルの処分
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assume we wanted to allow a variant relation between code points O and A, and perhaps between O and B or O and C as well. Assuming transitivity, this would give us:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は同様に、おそらくO及びB又はOとCの間のコード点OとAとの間の変異の関係を可能にするように望んでいたと仮定する。推移性を仮定すると、これは私たちを与えるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
O ~ A ~ B ~ C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
O〜A〜B〜C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, further assume that we would like to distinguish the case where someone applies for OOO from the case where someone applies for the label ABC. In this case, we would like to allocate only the applied-for label OOO, but in the latter case, we would like to also allow the allocation of either the label OOO or the variant label ABC, or both, but not of any of the other possible variant labels, like OAO, BCO, or the like. (A real-world example might be the case where O represents an unaccented letter, while A, B, and C might represent various accented forms of the same letter. Because unaccented letters are a common fallback, there might be a desire to allocate an unaccented label as a variant, but not the other way around.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さて、さらに私たちは、誰かが誰かがラベルABCに適用されるケースからOOOに適用される場合を区別したいと仮定します。ではないのいずれかの、この場合には、我々は唯一の印加のラベルOOOを割り当てたいが、後者の場合、我々はまた、ラベルOOOまたは変異体ラベルABC、または両方の割り当てを可能にしたいと思い他の可能な変形のラベル、OAO、BCO、などなどです。 A、B、及びCは、同じ文字の様々なアクセント形態を表すかもしれないが（現実世界の例では、アクセントのない文字は共通のフォールバックであるため、割り当てる願望があるかもしれない。、Oはアクセントのない文字を表す場合であるかもしれませんアクセントのないバリアントとしてラベルではなく、他の方法で回避。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
How would we specify such a distinction?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どのように我々は、そのような区別を指定するのでしょうか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The answer lies in labeling the mappings A --&gt; O, B --&gt; O, and C --&gt; O with the type &#34;allocatable&#34; and the mappings O --&gt; A, O --&gt; B, and O --&gt; C with the type &#34;blocked&#34;. In this document, the symbol &#34;x--&gt;&#34; means &#34;maps with type blocked&#34;, and the symbol &#34;a--&gt;&#34; means &#34;maps with type allocatable&#34;. Thus:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
答えはマッピングAラベリングにある - &gt;をO、B  - &gt; O、およびC  - &gt; O型の &#34;割り当て可能&#34; とのマッピングを持つO  - &gt; A、O  - &gt; B、およびO  - &gt;「ブロック」タイプC。この文書では、記号「X  - &gt;」手段「ブロックされたタイプのマップ」、および記号「 - &gt;」手段「割付けタイプのマップ」。したがって
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     O x--&gt; A O x--&gt; B O x--&gt; C A a--&gt; O B a--&gt; O C a--&gt; O
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When we generate all permutations of labels, we use mappings with different types depending on which code points we start from. The set of all permuted variant labels would be the same, but the disposition of the variant label depends on which label we start from (we call that label the &#34;original&#34; or &#34;applied-for&#34; label).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、ラベルのすべての順列を生成するとき、私たちはから開始されたコードポイントに応じて、異なるタイプのマッピングを使用します。すべての並べ替えバリエーションラベルのセットは同じになりますが、（私たちはそのラベル「を適用-ための」ラベル「オリジナル」またはお電話）から、我々は開始ラベルれている変異型ラベルの配置が異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In creating an LGR with variants, all variant mappings should always be labeled with a type ([RFC7940] does not formally require a type, but any well-behaved LGR would be fully typed). By default, these types correspond directly to the dispositions for variant labels, with the most restrictive type determining the disposition of the variant label. However, as we shall see later, it is sometimes useful to assign types from a wider array of values than the final dispositions for the labels and then define explicitly how to derive label dispositions from them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントとLGRを作成するには、すべてのバリアントマッピングは常にタイプ（[RFC7940]正式タイプを必要としませんが、任意の行儀LGRが完全に入力されたことになる）で標識されなければなりません。デフォルトでは、これらのタイプは、バリアントのラベルの配置を決定する最も制限タイプで、バリアントラベルの処分に直接対応します。私たちは、後に見るようにしかし、ラベルのための最終的な処分よりも値の広い配列からタイプを割り当てし、それらからラベル処分を導出する方法を明示的に定義すると便利な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Allocatable Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.割り付けバリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If we start with AAA and use the mappings from Section 7, the permutation OOO will be the result of applying the mapping A a--&gt; O at each code point. That is, only mappings with type &#34;a&#34; (allocatable) were used. To know whether we can allocate both the label OOO and the original label AAA, we track the types of the mappings used in generating the label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各コードポイントで&gt; O  - 、我々はAAAで始まり、第7章からのマッピングを使用する場合、置換OOOはマッピングA Aを適用した結果であろう。これは、タイプ「A」（割り当て可能）を有する唯一のマッピングを使用した、です。我々は、ラベルOOOとオリジナルラベルAAAの両方を割り当てることができるかどうかを知るために、我々は、ラベルの生成に使用するマッピングの種類を追跡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We record the variant types for each of the variant mappings used in creating the permutation in an ordered list. Such an ordered list of variant types is called a &#34;variant type list&#34;. In running text, we often show it enclosed in square brackets. For example, [a x -] means the variant label was derived from a variant mapping with the &#34;a&#34; variant type in the first code point position, &#34;x&#34; in the second code point position, and the original code point in the third position (&#34;-&#34; means &#34;no variant mapping&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、順序付けられたリストの順列を作成する際に使用バリアントのマッピングごとにバリアント型を記録します。バリアント型のような順序付きリストは、「バリアント型のリスト」と呼ばれています。テキストを実行するには、私たちはしばしば、それが角括弧で囲まれて表示されます。例えば、[Axが - ]バリアントラベルは最初のコードポイントの位置に「」バリアント型と変異体のマッピングから誘導されたことを意味し、「X」は第2のコードポイントの位置、および第三の位置における元のコードポイントに（「 - 」「何のバリアントマッピング」を意味しません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For our example permutation, we get the following variant type list (brackets dropped):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例の順列のために、我々は（括弧はドロップ）以下のバリアント型のリストを取得します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAA --&gt; OOO : a a a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAA  - &gt; OOO：A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the variant type list, we derive a &#34;variant type set&#34;, denoted by curly braces, that contains an unordered set of unique variant types in the variant type list. For the variant type list for the given permutation, [a a a], the variant type set is { a }, which has a single element &#34;a&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアント型の一覧から、我々はバリアント型のリストでユニークなバリアント型の順不同のセットが含まれて中括弧で示される「バリアント型セット」を、導き出します。所与の順列のための変異型のリストについては、[A A A]は、変異型の組は、単一の要素「A」を有し、{A}です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Deciding whether to allow the allocation of a variant label then amounts to deriving a disposition for the variant label from the variant type set created from the variant mappings that were used to create the label. For example, the derivation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントラベルの割り当てを許可するかどうかを決めるのは、ラベルを作成するために使用されたバリアントのマッピングから作成されたバリアント型セットからバリアントラベルの配置を導き出すになります。例えば、導出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
if &#34;all variants&#34; = &#34;a&#34; =&gt; set label disposition to &#34;allocatable&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
「すべての亜種」=「」=&gt;セット・ラベルの処分に「割り当て可能」であれば
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
would allow OOO to be allocated, because the types of all variant mappings used to create that variant label from AAA are &#34;a&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AAAからそのバリエーションラベルを作成するために使用されるすべてのバリアントマッピングのタイプは「A」であるため、OOOを割り当てることができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;all-variants&#34; condition is tolerant of an extra &#34;-&#34; in the variant set (unlike the &#34;only-variants&#34; condition described in Section 10). So, had we started with AOA, OAA, or AAO, the variant set for the permuted variant OOO would have been { a - } because in each case one of the code points remains the same code point as the original. The &#34;-&#34; means that because of the absence of a mapping O --&gt; O, there is no variant type for the O in each of these labels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「全変異体」の条件は、余分の寛容である「 - 」は、変異体セットで（第10項に記載された「唯一の変種」の条件とは異なります）。だから、私達はAOA、OAA、またはAAOで開始した、置換変異OOOに設定された変異体があったであろう、{ - }、それぞれの場合に、コードポイントの一つは、元と同じコードポイント残っているため。 「 - 」 - &gt; O、これらのラベルのそれぞれにおけるOのためのバリアント型が存在しないため、マッピングOが存在しない場合のことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;all-variants&#34; = &#34;a&#34; condition ignores the &#34;-&#34;, so using the derivation from above, we find that OOO is an allocatable variant for each of the labels AOA, OAA, or AAO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「 - 」「すべての変種」=「」条件は無視するので、上からの導出を使用して、私たちはOOOラベルAOA、OAA、またはAAOのそれぞれに割り当て可能バリアントであることがわかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allocatable variant labels, especially large numbers of allocatable variants per label, incur a certain cost to users of the LGR. A well-behaved LGR will minimize the number of allocatable variants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
割付けバリアントラベル、ラベルごとに割り当て可能な変種の特に大きな数字は、LGRのユーザーに一定のコストが発生します。行儀LGRは、割り当て可能なバリエーションの数を最小限に抑えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Blocked Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.ブロックされたバリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Blocked variants are not available to another registrant. They therefore protect the applicant of the original label from someone else registering a label that is the &#34;same as&#34; under some user-perceived metric. Blocked variants can be a useful tool even for scripts for which no allocatable labels are ever defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックされた変異体は、他の登録者には利用できません。したがって、これらは、いくつかのユーザ知覚メトリックの下に「同じ」であるラベルを登録し、他の誰かからオリジナルラベルの申請者を保護します。ブロックされた変異体がなくても、割り当て可能ラベルは、これまでに定義されていないそのためのスクリプトのための便利なツールとなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If we start with OOO and use the mappings from Section 7, the permutation AAA will have been the result of applying only mappings with type &#34;blocked&#34;, and we cannot allocate the label AAA, only the original label OOO. This corresponds to the following derivation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちはOOOで始まり、第7節からのマッピングを使用する場合は、順列AAAは、「ブロック」タイプでのみマッピングを適用した結果となっているだろう、と私たちはラベルAAA、唯一のオリジナルラベルOOOを割り当てることができません。これは、以下の導出に対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
if &#34;any variants&#34; = &#34;x&#34; =&gt; set label disposition to &#34;blocked&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
「任意の変種」=「X」=&gt;セット・ラベルの配置は、「ブロック」する場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, to prevent allocating ABO as a variant label for AAA, we need to make sure that the mapping A --&gt; B has been defined with type &#34;blocked&#34;, as in
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、AAAのバリアントラベルとしてABOを割り当てる防ぐために、我々は確認する必要があり、そのマッピングA  - &gt; Bは、のように、「ブロック」型で定義されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A x--&gt; B
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
X  - &gt; B
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
so that
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのため
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAA --&gt; ABO: - x a.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAAは - &gt; ABO：X  - 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the set {x a} contains at least one &#34;x&#34; and satisfies the derivation of a blocked disposition for ABO when AAA is applied for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AAAのために適用されたときにこのように、セット{X A}は、少なくとも1つの「X」を満たすABO用遮断配置の導出を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an LGR results in a symmetric and transitive set of variant labels, then the task of determining whether a label or its variants collide with another label or its variants can be implemented very efficiently. Symmetry and transitivity imply that sets of labels that are mutual variants of each other are disjoint from all other such sets. Only labels within the same set can be variants of each other. Identifying the variant set can be an O(1) operation, and enumerating all variants is not necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もし変異体ラベル、ラベル又はその変異体は、別のラベルと衝突又はその変異体は、非常に効率的に実装することができるかどうかを決定する、タスクの対称と推移セットにおけるLGRをもたらします。対称性と推移性は、お互いの相互の変異体であるラベルのセットは、他のすべてのようなセットから互いに素であることを示唆しています。同じセット内のラベルのみが互いの変形することができます。バリアント・セットを識別することはO（1）操作することができ、全ての変異体を列挙することは必要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Pure Variant Labels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.ピュアバリアントラベル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, if we wanted to prevent allocation of AOA when we start from AAA, we would need a rule disallowing a mix of original code points and variant code points; this is easily accomplished by use of the &#34;only-variants&#34; qualifier, which requires that the label consist entirely of variants and that all the variants are from the same set of types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々はAAAから起動したときAOAの割り当てを防止したい場合は今、私たちは、元のコード・ポイントとバリアントコード・ポイントの混在を許可しないルールが必要になります。これは簡単にラベルがバリアントの完全構成されていることを必要とする「唯一の変種」修飾子を使用することによって達成されると、全ての変異体は、種類の同じセットからのものであること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
if &#34;only-variants&#34; = &#34;a&#34; =&gt; set label disposition to &#34;allocatable&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
「唯一の変種」=「」=&gt;セット・ラベルの処分に「割り当て可能」であれば
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two code points A in AOA are not arrived at by variant mappings, because the code points are unchanged and no variant mappings are defined for A --&gt; A. So, in our example, the set of variant mapping types is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&gt; A.だから、私たちの例では、バリアントマッピングタイプのセットがある -  AOAでの2つのコード・ポイントのAは、コード・ポイントは変更されず、何のバリアントのマッピングが定義されていないため、バリアントのマッピングによって到達されていません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAA --&gt; AOA: - a -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAA  - &gt; AOA： -   - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
but unlike the &#34;all-variants&#34; condition, &#34;only-variants&#34; requires a variant type set { a } corresponding to a variant type list [a a a] (no - allowed). By adding a final derivation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、「全変異体」状態、「のみ、変異体」とは異なり、{A}バリアント型リストに対応する変異型のセットを[A A A]（ - 不可）を必要とします。最終的な導出を添加することにより
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
else if &#34;any-variants&#34; = &#34;a&#34; =&gt; set label disposition to &#34;blocked&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
「ブロック」するために、他の「任意の変種」の場合=「」=&gt;セット・ラベル処分
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and executing that derivation only on any remaining labels, we disallow AOA when starting from AAA but still allow OOO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして残りのラベルにのみその導出を実行し、我々はAAAから起動する場合には、AOAを許可しないが、それでもOOOを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Derivation conditions are always applied in order, with later derivations only applying to labels that did not match any earlier conditions, as indicated by the use of &#34;else&#34; in the last example. In other words, they form a cascade.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
導出条件は常に後で派生のみ最後の例では「他」の使用によって示されるように、任意の以前の条件に一致しなかったラベルを適用すると、順番に適用されます。言い換えれば、彼らは、カスケードを形成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Reflexive Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.再帰バリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But what if we started from AOA? We would expect the original label OOO to be allocatable, but, using the mappings from Section 7, the variant type set would be
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、我々はAOAから始めたらどう？私たちは、7節からのマッピングを使用して、オリジナルのラベルOOOが割り当て可能であることを期待だろうが、バリアント型のセットは次のようになります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AOA --&gt; OOO: a - a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AOA  - &gt; OOO： - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
because the middle O is unchanged from the original code point. Here is where we use a reflexive mapping. Realizing that O is the &#34;same as&#34; O, we can map it to itself. This is normally redundant, but adding an explicit reflexive mapping allows us to specify a disposition on that mapping:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中間Oは、元のコード・ポイントから変更されていないためです。我々は再帰マッピングを使用するのはここです。そのOを実現することはO、我々は自分自身にそれをマッピングすることができる「と同じ」です。これは、通常は冗長ですが、明示的な再帰マッピングを追加すると、私たちはそのマッピングの配置を指定することができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
O a--&gt; O
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A  - &gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With that, the variant type list for AOA --&gt; OOO becomes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それによって、AOAのためのバリアント型のリスト - &gt; OOOは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AOA --&gt; OOO: a a a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AOA  - &gt; OOO：A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and the label OOO again passes the derivation condition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベルOOOは再び導出条件を渡します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
if &#34;only-variants&#34; = &#34;a&#34; =&gt; set label disposition to &#34;allocatable&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
「唯一の変種」=「」=&gt;セット・ラベルの処分に「割り当て可能」であれば
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
as desired. This use of reflexive variants is typical whenever derivations with the &#34;only-variants&#34; qualifier are used. If any code point uses a reflexive variant, a well-behaved LGR would specify an appropriate reflexive variant for all code points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
望んだ通りに。 「唯一の変種」修飾子と派生が使用されるたびに再帰変種のこの使用が一般的です。任意のコードポイントが再帰変異体を使用する場合、行儀LGRは、すべてのコードポイントのための適切な再帰バリアントを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Limiting Allocatable Variants by Subtyping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
サブタイピングによって割り当て可能バリアントを制限する12
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As we have seen, the number of variant labels can potentially be large, due to combinatorics. Sometimes it is possible to divide variants into categories and to stipulate that only variant labels with variants from the same category should be allocatable. For some LGRs, this constraint can be implemented by a rule that disallows code points from different categories to occur in the same allocatable label. For other LGRs, the appropriate mechanism may be dividing the allocatable variants into subtypes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちが見てきたように、変異型ラベルの数は、潜在的組合せ論のために、大きくすることができます。時にはカテゴリにバリアントを分割すると、同じカテゴリのバリエーションを持つ唯一のバリアントのラベルが割り当て可能であることを規定することが可能です。一部LGRsため、この制約は、同じ割り当てラベルで発生する異なるカテゴリからのコードポイントを禁止ルールによって実現することができます。他のLGRsために、適切な機構がサブタイプに割り当て可能な変異体を分割することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To recap, in the standard case, a code point C can have (up to) two types of variant mappings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約に、標準的な場合に、コードポイントCは、変異のマッピングの二種類（最大）を有することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x--&gt; X C a--&gt; A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C X  - &gt; X C A  - &gt; A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where a--&gt; means a variant mapping with type &#34;allocatable&#34; and x--&gt; means &#34;blocked&#34;. For the purpose of the following discussion, we name the target code point with the corresponding uppercase letter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここ - &gt;「割り当て」タイプの変異のマッピングを意味し、X  - &gt;は「ブロック」を意味します。以下の議論の目的のために、我々は、対応する大文字とターゲット・コード・ポイントに名前を付けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subtyping allows us to distinguish among different types of allocatable variants. For example, we can define three new types: &#34;s&#34;, &#34;t&#34;, and &#34;b&#34;. Of these, &#34;s&#34; and &#34;t&#34; are mutually incompatible, but &#34;b&#34; is compatible with either &#34;s&#34; or &#34;t&#34; (in this case, &#34;b&#34; stands for &#34;both&#34;). A real-world example for this might be variant mappings appropriate for &#34;simplified&#34; or &#34;traditional&#34; Chinese variants, or appropriate for both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブタイプは、私たちが割り当て可能な変種の異なる種類を区別することができます。 「S」、「T」、および「B」：例えば、我々は3つの新しい型を定義することができます。これらの中で、「S」と「T」は、相互に互換性がないが、「B」が「S」又は「T」のいずれかに対応している（この場合、「B」は、「両方」を意味します）。このため、現実世界の例では、「簡略化」や「伝統的な」中国の変異体、またはその両方に適しのための適切なバリアントのマッピングであるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With subtypes defined as above, a code point C might have (up to) four types of variant mappings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように定義されるサブタイプで、コード点Cは、（まで）変異マッピングの4種類があるかもしれません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x--&gt; X C s--&gt; S C t--&gt; T C b--&gt; B
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C X  - &gt; X C S  - &gt; S CのT  - &gt; T CのB  - &gt; B
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and explicit reflexive mappings of one of these types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのタイプのいずれかの明示的な再帰マッピング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C s--&gt; C C t--&gt; C C b--&gt; C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C S  - &gt; C C T  - &gt; C CのB  - &gt; C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As before, all mappings must have one and only one type, but each code point may map to any number of other code points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前と同じように、すべてのマッピングは、唯一のタイプを有していなければならないが、各コードポイントは、他のコードポイントの任意の数にマッピングすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We define the compatibility of &#34;b&#34; with &#34;t&#34; or &#34;s&#34; by our choice of derivation conditions as follows
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように私たちは、派生条件の私達の選択によって、「T」と「B」または「S」の互換性を定義します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
if &#34;any-variants&#34; = &#34;x&#34; =&gt; blocked else if &#34;only-variants&#34; = &#34;s&#34; or &#34;b&#34; =&gt; allocatable else if &#34;only-variants&#34; = &#34;t&#34; or &#34;b&#34; =&gt; allocatable else if &#34;any-variants&#34; = &#34;s&#34; or &#34;t&#34; or &#34;b&#34; =&gt; blocked
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
もし、「任意の変種」=「X」=&gt;他のブロックされた場合「のみ、バリアント」=「S」または「B」=&gt;他に割り当て可能であれば「唯一の変種」=「T」または「B」=&gt;他の割付け「任意の変種」=「S」または「T」または「b」は=&gt;ブロックされている場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An original label of four code points
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4つのコードポイントのオリジナルラベル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
may have many variant labels, such as this example listed with its corresponding variant type list:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その対応する変異型のリストとリストされているような本実施例のような多くの変異体標識を有していてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC --&gt; XSTB : x s t b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC  - &gt; XSTB：X S T B
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This variant label is blocked because to get from C to B required x--&gt;. (Because variant mappings are defined for specific source code points, we need to show the starting label for each of these examples, not merely the code points in the variant label.) The variant label
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&gt;  - この変種のラベルが必要なのxをBにCから取得するので、ブロックされています。 （変異のマッピングは、特定のソースコードポイントに対して定義されているので、我々は、変異体ラベルに過ぎないコードポイント、これらの例のそれぞれの開始ラベルを表示する必要はない。）変異体ラベル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC --&gt; SSBB : s s b b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC  - &gt;スマブラX：S、S、BのB
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is allocatable, because the variant type list contains only allocatable mappings of subtype &#34;s&#34; or &#34;b&#34;, which we have defined as being compatible by our choice of derivations. The actual set of variant types {s, b} has only two members, but the examples are easier to follow if we list each type. The label
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアント型のリストは、我々は派生の我々の選択によって、互換性のあるものとして定義されているサブタイプ「S」または「B」の唯一の割り当て可能マッピングを、含まれているため、割り当て可能です。バリアント型の実際の集合{Sは、B}のみ二つの部材を有しているが、我々は、各タイプをリスト場合の例を以下にするのが容易です。ラベル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC --&gt; TTBB : t t b b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC  - &gt; TTBB：トントンBはB
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is again allocatable, because the variant type set {t, b} contains only allocatable mappings of the mutually compatible allocatable subtypes &#34;t&#34; or &#34;b&#34;. In contrast,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアント型セットは、{T、B}両立割り当てサブタイプ「T」又は「B」のみ割り当てマッピングを含んでいるので、再び割り当て可能です。対照的に、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC --&gt; SSTT : s s t t
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC  - &gt; SSTT：S秒トントン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is not allocatable, because the type set contains incompatible subtypes &#34;t&#34; and &#34;s&#34; and thus would be blocked by the final derivation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプセットが互換性のないサブタイプ「T」および「S」を含み、したがって、最終的な誘導によって遮断されるため、割り当てません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The variant labels
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントのラベル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC --&gt; CSBB : c s b b CCCC --&gt; CTBB : c t b b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC  - &gt; CSBB：C、S、BのBのCCCC  - &gt; CTBB：C tのbのbの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
are only allocatable based on the subtype for the C --&gt; C mapping, which is denoted here by &#34;c&#34; and (depending on what was chosen for the type of the reflexive mapping) could correspond to &#34;s&#34;, &#34;t&#34;, or &#34;b&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
のみ割り当てCのためのサブタイプに基づいている - 「C」によりここで示され&gt; Cのマッピング、および（再帰マッピングのタイプのために選択されたものに応じて）「S」、「T」に対応することができ、または &#34;B&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the subtype is &#34;s&#34;, the first of these two labels is allocatable; if it is &#34;t&#34;, the second of these two labels is allocatable; if it is &#34;b&#34;, both labels are allocatable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブタイプが「S」である場合には、これら2つのラベルの最初は、割り当て可能です。それは「T」であるならば、これら2つのラベルの第二は、割り当て可能です。それが「B」であれば、両方のラベルが割り当て可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So far, the scheme does not seem to have brought any huge reduction in allocatable variant labels, but that is because we tacitly assumed that C could have all three types of allocatable variants &#34;s&#34;, &#34;t&#34;, and &#34;b&#34; at the same time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのところ、スキームは、割り当て可能なバリアントのラベルのいずれかの巨大な削減を持ってきたようには見えませんが、我々は暗黙のうちにCがですべての3つの割り当て可能な変異型のタイプ「S」、「T」、および「b」を持つことができると仮定しているためです同時。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a real-world example, the types &#34;s&#34;, &#34;t&#34;, and &#34;b&#34; are assigned so that each code point C normally has, at most, one non-reflexive variant mapping labeled with one of these subtypes, and all other mappings would be assigned type &#34;x&#34; (blocked). This holds true for most code points in existing tables (such as those used in current IDN Top-Level Domains (TLDs)), although certain code points have exceptionally complex variant relations and may have an extra mapping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各コードポイントCは、通常、最大で、これらのサブタイプのいずれか、および全てで標識された一つの非再帰バリアントマッピングを有するように、現実世界の例では、タイプ「S」、「T」及び「B」が割り当てられています他のマッピングは、タイプ「X」（ブロック）が割り当てられます。特定のコード・ポイントは、非常に複雑なバリアント関係を持っており、余分なマッピングを有することができるが、これは、（例えば、現在のIDNトップレベルドメイン（TLDの）で使用されるものなど）、既存のテーブルのほとんどのコード・ポイントにも当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Allowing Mixed Originals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.許可混載原稿
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the desire is to allow original labels (but not variant labels) that are s/t mixed, then the scheme needs to be slightly refined to distinguish between reflexive and non-reflexive variants. In this document, the symbol &#34;r-n&#34; means &#34;a reflexive (identity) mapping of type &#39;n&#39;&#34;. The reflexive mappings of the preceding section thus become:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
欲求がS / Tに混合され、元のラベル（ただし変異体ラベル）を可能にすることである場合、スキームは、わずかに再帰と非再帰変異体を区別するために精製する必要があります。この文書では、記号「R-N」は「タイプの再帰（アイデンティティ）マッピング 『N』」を意味します。前節の再帰マッピングはこのようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C r-s--&gt; C C r-t--&gt; C C r-b--&gt; C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C R-S  - &gt; C C R-T  - &gt; C C R-B  - &gt; C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With this convention, and redefining the derivations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この大会では、と導出を再定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
if &#34;any-variants&#34; = &#34;x&#34; =&gt; blocked else if &#34;only-variants&#34; = &#34;s&#34; or &#34;r-s&#34; or &#34;b&#34; or &#34;r-b&#34; =&gt; allocatable else if &#34;only-variants&#34; = &#34;t&#34; or &#34;r-t&#34; or &#34;b&#34; or &#34;r-b&#34; =&gt; allocatable else if &#34;any-variants&#34; = &#34;s&#34; or &#34;t&#34; or &#34;b&#34; =&gt; blocked else =&gt; allocatable any labels that contain only reflexive mappings of otherwise mixed type (in other words, any mixed original label) now fall through, and their disposition is set to &#34;allocatable&#34; in the final derivation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もし、「任意の変種」=「X」=&gt;「のみ-変異体」=「S」または「RS」または「B」または「RB」場合は、他のブロックされた=&gt;他に割り当て可能であれば「唯一の変種」=「T」それ以外の唯一の再帰マッピングを含むまたは「RT」または「B」または「RB」=&gt;他に割り当て可能であれば「任意の変種」=「S」または「T」または「B」=&gt;他のブロックされた=&gt;割り当て可能な任意のラベル（換言すれば、任意の混合オリジナルラベル）混合型は現在フォールスルー、およびそれらの配置は、最終導出に「割り当て」に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a well-behaved LGR, it is preferable to explicitly define the derivation for allocatable labels instead of using a fall through. In the derivation above, code points without any variant mappings fall through and become allocatable by default if they are part of an original label. Especially in a large repertoire, it can be difficult to identify which code points are affected. Instead, it is preferable to mark them with their own reflexive mapping type &#34;neither&#34; or &#34;r-n&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
行儀LGRでは、明示的介して落下を使用する代わりに、割り当てラベルの導出を定義することが好ましいです。上記の導出では、任意のバリアントマッピングなしのコードポイントが通って落下し、彼らがオリジナルラベルの一部である場合、デフォルトで割り当て可能になります。特に大規模なレパートリーでは、コード・ポイントが影響を受けるかを識別することは困難であることができます。代わりに、自分自身の再帰マッピングタイプ「もない」または「R-N」でそれらをマークすることが好ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C r-n--&gt; C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C E-N  - &gt; C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With that, we can change
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それによって、我々は変更することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
else =&gt; allocatable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
他に=&gt;割り当て可能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
と
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
else if &#34;only-variants&#34; = &#34;r-s&#34; or &#34;r-t&#34; or &#34;r-b&#34; or &#34;r-n&#34; =&gt; allocatable else =&gt; invalid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
他に &#34;唯一の変種&#34; = &#34;R-S&#34; または &#34;R-T&#34; または &#34;R-B&#34; または &#34;R-N&#34; =&gt;他の割り当て可能=&gt;無効な場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This makes the intent more explicit, and by ensuring that all code points in the LGR have a reflexive mapping of some kind, it is easier to verify the correct assignment of their types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは意図がより明確になり、そしてLGRのすべてのコードポイントはいくつかの種類の再帰マッピングを持っていることを確実にすることによって、彼らの種類の正しい割り当てを検証することが容易です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Handling Out-of-Repertoire Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.取扱いアウト・オブ・レパートリーバリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At first, it may seem counterintuitive to define variants that map to code points that are not part of the repertoire. However, for zones for which multiple LGRs are defined, there may be situations where labels valid under one LGR should be blocked if a label under another LGR is already delegated. This situation can arise whether or not the repertoires of the affected LGRs overlap and, where repertoires overlap, whether or not the labels are both restricted to the common subset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初は、レパートリーの一部ではない点をコーディングするマップのバリアントを定義するために直感に反するように思えるかもしれません。しかし、複数のLGRsが定義されているゾーンのために、1つのLGRの下で有効なラベルを付ける場面があるかもしれない別のLGRの下にラベルがすでに委任された場合にブロックする必要があります。この状況は、ラベルが両方とも共通のサブセットに制限されているか否か、罹患LGRsのレパートリーが重なると、レパートリーが重なる場所かどうかを生じ得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to handle this exclusion relation through definition of variants, it is necessary to be able to specify variant mappings to some code point X that is outside an LGR&#39;s repertoire, R:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントの定義によって、この排他関係を処理するためには、LGRのレパートリーの外にあるいくつかのコードポイントXにRをバリアントマッピングを指定できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x--&gt; X : where C = elementOf(R) and X != elementOf(R)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C X  - &gt; X：ここで、C = elementOf（R）及びX = elementOf（R）！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because of symmetry, it is necessary to also specify the inverse mapping in the LGR:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称性のため、また、LGRに逆マッピングを指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
X x--&gt; C : where X != elementOf(R) and C = elementOf(R)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
X X  - &gt; C：X = elementOf（R）及びC = elementOf（R）！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This makes X a source of variant mappings, and it becomes necessary to identify X as being outside the repertoire, so that any attempt to apply for a label containing X will lead to a disposition of &#34;invalid&#34;, just as if X had never been listed in the LGR. The mechanism to do this uses reflexive variants but with a new type of reflexive mapping of &#34;out-of-repertoire-var&#34;, shown as &#34;r-o--&gt;&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Xを含むラベルの申請をしようとするが、Xがされていなかったかのように、「無効」の処分につながるように、これは、変異型のマッピングのXソースを作り、それがレパートリーの外にあるものとしてXを識別することが必要になりますLGRに記載されています。これを行うためのメカニズムは、反射的バリアントを使用していますが、「アウト・オブ・レパートリー-VAR」として示され、再帰のマッピングの新しいタイプの「R-O  - &gt;」：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
X r-o--&gt; X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Ｘ ｒーおーー＞ Ｘ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates X != elementOf(R), as long as the LGR is provided with a suitable derivation, so that any label containing &#34;r-o--&gt;&#34; is assigned a disposition of &#34;invalid&#34;, just as if X was any other code point not part of the repertoire. The derivation used is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Xは、任意の他のコードであったかのように、「無効」の配置が割り当てられている！ - 「&gt; RO」を含む任意のラベルがそのように、これは、限りLGRは、適切な導出が設けられているように、X = elementOf（R）を示していますレパートリーの一部ではないと指摘しています。使用導出は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
if &#34;any-variant&#34; = &#34;out-of-repertoire-var&#34; =&gt; invalid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&#34;任意のバリアント&#34; = &#34;アウト・オブ・レパートリー-VAR&#34; =&gt;無効な場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is inserted ahead of any other derivation of the &#34;any-variant&#34; kind in the chain of derivations. As a result, instead of the minimum two symmetric variants, for any out-of-repertoire variants, there are a minimum of three variant mappings defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、先に導出の鎖における「任意バリアント」種類の任意の他の派生の挿入されています。その結果、代わりに最小2つの対称変形の、いずれかの外のレパートリー変種のために、定義された3つのバリアントマッピングの最小があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x--&gt; X X x--&gt; C X r-o--&gt; X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CのX  - &gt; X X X  - &gt; C X R-O  - &gt; X
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where C = elementOf(R) and X != elementOf(R).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、C = elementOf（R）とX！= elementOf（R）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because no variant label with any code point outside the repertoire could ever be allocated, the only logical choice for the non-reflexive mappings to out-of-repertoire code points is &#34;blocked&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レパートリー外のコードポイントとはバリアントラベルは、これまで割り当てられていない可能性があるため、アウト・オブ・レパートリーコード・ポイントへの非再帰マッピングのための唯一の論理的な選択は、「ブロック」されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Conditional Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.条件付きバリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variant mappings are based on whether code points are &#34;same as&#34; to the user. In some writing systems, code points change shape based on where they occur in the word (positional forms). Some code points have matching shapes in some positions but not in others. In such cases, the variant mapping exists only for some possible positions or, more generally, only for some contexts. For other contexts, the variant mapping does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変異のマッピングは、コード・ポイントは、ユーザが「同じ」であるかどうかに基づいています。いくつかの書き込みシステムでは、コード・ポイントは、それらが単語（位置型）で発生場所に基づいて形状を変化させます。一部のコードポイントは、いくつかの位置ではなく、他の一致する形状を有しています。このような場合には、変異のマッピングは、より一般的には、一部のみのコンテキストのためのいくつかの可能な位置、または、に対する必要性が存在します。他の文脈では、変異型マッピングが存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, take two code points that have the same shape at the end of a label (or in final position) but not in any other position. In that case, they are variants only when they occur in the final position, something we indicate like this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、はなく、他の位置でラベル（又は最終位置における）の端部に同じ形状を有する2つのコードポイントを取ります。その場合には、彼らは、彼らが最終的な位置で発生した場合にのみ、我々はこのような何かを示す変異体です：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
final: C --&gt; D
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
最終：C  - &gt; D
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cursively connected scripts, like Arabic, a code point may take its final form when next to any following code point that interrupts the cursive connection, not just at the end of a label. (We ignore the isolated form to keep the discussion simple; if included, &#34;final&#34; might be &#34;final-or-isolate&#34;, for example).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
走り書き接続スクリプトでは、アラビア語のように、コード・ポイントは、時に次のラベルの末尾にだけではなく筆記体の接続を中断任意の次のコード・ポイントへの最終的な形をとることができます。 （我々は、議論を単純に保つために、単離された形態を無視し、含まれている場合、「最終的な」は、「単離最終または、」かもしれない、など）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From symmetry, we expect that the mapping D --&gt; C should also exist only when the code point D is in final position. (Similar considerations apply to transitivity.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードポイントDが最終位置にあるときにのみ&gt; Cも存在しなければならない - 対称性から、我々は、マッピング・Dは、と予想しています。 （同様の考察が推移に適用されます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sometimes a code point has a final form that is practically the same as that of some other code point while sharing initial and medial forms with another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時々コードポイントは、実質的に相互に初期及び中間形式を共有しながら、いくつかの他のコードポイントと同じである最終的な形状を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
final: C --&gt; D !final: C --&gt; E
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
最終：C  - &gt; D最終：C  - &gt; E！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, the case where the condition is the opposite of final is shown as &#34;!final&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、条件が最終の反対である場合には、「！ファイナル」として示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because shapes differ by position, when a context is applied to a variant mapping, it is treated independently from the same mapping in other contexts. This extends to the assignment of types. For example, the mapping C --&gt; F may be &#34;allocatable&#34; in final position but &#34;blocked&#34; in any other context:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
形状が位置によって異なるので、コンテキストはバリアントマッピングに適用する場合、それは他の状況で同じマッピングから独立して処理されます。これは、種類の割り当てに及びます。例えば、マッピングC  - &gt; Fは最終位置に「割り当て」であってもよいが、他の文脈で「ブロック」：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
final: C a--&gt; F !final: C x--&gt; F
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
最終：C  - &gt; F最終：！C X  - &gt; F
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, the type assigned to the forward mapping is independent of the reverse symmetric mapping or any transitive mappings. Imagine a situation where the symmetric mapping is defined as F a--&gt; C, that is, all mappings from F to C are &#34;allocatable&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さて、前方マッピングに割り当てられたタイプは、逆対称マッピングまたは任意の推移マッピングとは無関係です。対称マッピングはFのように定義されるような状況を想像して - &gt; C、つまり、FからCへのすべてのマッピングは、「割り当て可能」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
final: F a--&gt; C !final: F a--&gt;C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
最終：F  - &gt; C最終：F  - &gt; C！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Why not simply write F a--&gt; C? Because the forward mapping is divided by context. Adding a context makes the two forward variant mappings distinct, and that needs to be accounted for explicitly in the reverse mappings so that human and machine readers can easily verify symmetry and transitivity of the variant mappings in the LGR. (This is true even though the two opposite contexts of &#34;final&#34; and &#34;!final&#34; should together cover all possible cases.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&gt; C  - なぜ単にF書き込めませんか？前方マッピングは、文脈によって分割されているので。コンテキストを追加すると、異なる2つの順方向変異のマッピングを行い、人間と機械読者が容易LGRにおける変異のマッピングの対称性と推移を検証することができるように、その逆マッピングで明示的に考慮される必要があります。 （これは本当であるにもかかわらずの二つの対向するコンテキスト「最終」と「！最後の」一緒にすべての可能なケースをカバーする必要があります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. Making Conditional Variants Well Behaved
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.条件付きバリアント行儀を作ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure that LGR with contextual variants is well behaved, it is best to always use &#34;fully qualified&#34; variant mappings that always agree in the names of the context rules for forward and reverse mappings. It is also necessary to ensure that no label can match more than one context for the same mapping. Using mutually exclusive contexts, such as &#34;final&#34; and &#34;!final&#34;, is an easy way to ensure that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文脈のバリアントとLGRが行儀されていることを確実にするために、それは常に、常に前方のコンテキストルールの名前に同意し、マッピングを逆に「完全修飾」は、変異体のマッピングを使用するのが最適です。ラベルが同じマッピングのために複数のコンテキストが一致しないことを確実にするためにも必要です。こうした「最終」と「！ファイナル」として、相互に排他的なコンテキストを使用して、次のことを確認する簡単な方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, it is not always necessary to define dual or multiple contexts that together cover all possible cases. For example, here are two contexts that do not cover all possible positional contexts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、一緒にすべての可能なケースをカバーするデュアルまたは複数のコンテキストを定義することは必ずしも必要ではありません。例えば、ここではすべての可能な位置文脈をカバーしていない2つのコンテキストは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
final: C --&gt; D initial: C --&gt; D.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
最終：C  - &gt; Dイニシャル：C  - &gt; D.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A well-behaved LGR using these two contexts would define all symmetric and transitive mappings involving C, D, and their variants consistently in terms of the two conditions &#34;final&#34; and &#34;initial&#34; and ensure that both cannot be satisfied at the same time by some label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これら二つのコンテキストを使用して、行儀LGRは、「最終」と「初期」の二つの条件の観点からC、D、および一貫してその変異体を含むすべての対称と推移マッピングを定義し、どちらも同時に満たすことができないことを保証しますいくつかのラベル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to never defining the same mapping with two contexts that may be satisfied by the same label, a well-behaved LGR never combines a variant mapping with a context with the same variant mapping without a context:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じラベルで満足することができる2つのコンテキストと同じマッピングを定義することはありませんに加えて、行儀LGRは、コンテキストなしで同じバリアントマッピングとコンテキストを持つ変異型のマッピングを組み合わせたことはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
context: C --&gt; D C --&gt; D
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
コンテキスト：C  - &gt; D C  - &gt; D
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inadvertent mixing of conditional and unconditional variants can be detected and flagged by a parser, but verifying that two formally distinct contexts are never satisfied by the same label would depend on the interaction between labels and context rules, which means that it will be up to the LGR designer to ensure that the LGR is well behaved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
条件付きと無条件の変種の不注意な混合は、パーサーによって検出し、フラグを立てることができますが、2つの正式に別々のコンテキストが同じラベルによって満たされないことを検証することは、次第になることを意味し、ラベルやコンテキストルール間の相互作用に依存するであろうLGRの設計者は、LGRが行儀されていることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A well-behaved LGR never assigns conditions on a reflexive variant, as that is effectively no different from having a context on the code point itself; the latter is preferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはコードポイント自体のコンテキストを有することから効果的に違いはありませんように行儀LGRは、再帰バリアントに条件を割り当てることはありません。後者が好ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, for symmetry to work as expected, the context must be defined such that it is satisfied for both the original code point in the context of the original label and for the variant code point in the variant label. In other words, the context should be &#34;stable under variant substitution&#34; anywhere in the label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、期待どおりに動作する対称性のため、コンテキストは、それが元のラベルの文脈においておよび変異ラベルにおけるバリアントコードポイントの元のコードポイントの両方のために満たされるように定義されなければなりません。言い換えれば、コンテキストはどこでもラベルの「バリアント置換下で安定」である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Positional contexts usually satisfy this last condition; for example, a code point that interrupts a cursive connection would likely share this property with any of its variants. However, as it is possible in principle to define other kinds of contexts, it is necessary to make sure that the LGR is well behaved in this aspect at the time the LGR is designed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
位置コンテキストは通常​​、この最後の条件を満たし、例えば、筆記体の接続を遮断し、コード・ポイントは、おそらくその変種のいずれかを使用してこのプロパティを共有します。それは文脈の他の種類を定義することが原理的には可能であるしかし、LGRがLGRが設計された時点で、この局面では行儀であることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to the difficulty in verifying these constraints mechanically, it is essential that an LGR designer document the reasons why the LGR can be expected to meet them and the details of the techniques used to ensure that outcome. This information should be found in the description element of the LGR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機械的にこれらの制約を検証することの難しさに起因する、それが不可欠であることLGRデザイナー文書LGRがそれらを満たすことが期待できる理由とその成果を確実にするために使用される技術の詳細が表示されます。この情報はLGRの記述要素に記載されていなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, conditional contexts can be useful for some cases, but additional care must be taken to ensure that an LGR containing conditional contexts is well behaved. LGR designers would be well advised to avoid using conditional contexts and to prefer unconditional rules whenever practical, even though it will doubtlessly reduce the number of labels practically available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、条件付きコンテキストは、いくつかのケースのために役立つことができますが、追加の注意が条件付きコンテキストを含むLGRがうまく動作していることを保証するために注意しなければなりません。 LGRの設計者はよく、それは間違いなく実用的なラベルの数を削減するにもかかわらず、条件付きのコンテキストを使用しないようにし、いつでも実用的な無条件のルールを好むように助言されるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Variants for Sequences
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
シーケンス17.バリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variant mappings can be defined between sequences or between a code point and a sequence. For example, one might define a &#34;blocked&#34; variant between the sequence &#34;rn&#34; and the code point &#34;m&#34; because they are practically indistinguishable in common UI fonts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変異のマッピングは、配列間またはコードポイントと配列との間に定義することができます。それらは共通のUIフォントに実質的に区別できないため、例えば、一方は「ブロック」は、配列間の変異体「RN」とコードポイント「M」を定義する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such variants are no different from variants defined between single code points, except if a sequence is defined such that there is a code point or shorter sequence that is a prefix (initial subsequence) and both it and the remainder are also part of the repertoire. In that case, it is possible to create duplicate variants with conflicting dispositions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスはプレフィックス（初期シーケンスを）であり、残りの両方もレパートリーの一部であるコードポイントまたはより短い配列が存在するように定義される場合を除いて、このような変異体は、単一のコードポイントとの間に画定された変異体からの違いはありません。その場合には、競合処分と重複バリアントを作成することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following shows such an example resulting in conflicting reflexive variants:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような例では、競合再帰変異体が得られ、次のショー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A a--&gt; C AB x--&gt; CD
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
あ あーー＞ Ｃ あＢ ｘーー＞ ＣＤ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where AB is a sequence with an initial subsequence of A. For example, B might be a combining code point used in sequence AB. If B only occurs in the sequence, there is no issue, but if B also occurs by itself, for example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ABは、例えば、Aの最初のサブシーケンスを有する配列であり、Bは、シーケンスABで使用される合成コードポイントであるかもしれません。 Bは配列のみで発生した場合、問題はないが、Bは、例えば、それ自体で発生した場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
B a--&gt; D
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
BのA  - &gt; D
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
then a label &#34;AB&#34; might correspond to either {A}{B}, that is, the two code points, or {AB}, the sequence, where the curly braces show the sequence boundaries as they would be applied during label validation and variant mapping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その後、ラベル「AB」は、{A}、{B}のいずれかに対応する、すなわち、2つのコード・ポイント、またはかもしれ{AB}、それらがラベルの検証中に適用されるように、中括弧は配列の境界を示す配列、及びバリアントマッピング。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A label AB would then generate the &#34;allocatable&#34; variant label {C}{D} and the &#34;blocked&#34; variant label {CD}, thus creating two variant labels with conflicting dispositions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベルABは、次いでこうして競合処分を持つ2枚の変異体ラベルを作成、「割り当て」変異体ラベル{C}、{D}と「ブロック」変異ラベル{CD}を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the example of a blocked variant between &#34;m&#34; and &#34;rn&#34; (and vice versa), there is no issue as long as &#34;r&#34; and &#34;n&#34; do not have variant mappings of their own, so that there cannot be multiple variant labels for the same input. However, it is preferable to avoid ambiguities altogether where possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「M」および「RN」（及びその逆）の間でブロックされた変異体の例については、何ら問題が複数存在することができないので、自分のの変形マッピングを持たない「R」および「n」は限りがありません同じ入力のバリアントのラベル。しかし、可能な限り完全にあいまいさを避けることが好ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The easiest way to avoid an ambiguous segmentation into sequences is by never allowing both a sequence and all of its constituent parts simultaneously as independent parts of the repertoire, for example, by not defining B by itself as a member of the repertoire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスにあいまいなセグメント化を回避する最も簡単な方法は、同時にレパートリーの独立した部分として配列及びその構成部品のすべての両方を可能にすることがないことにより、例えば、レパートリーのメンバーとして単独でBを定義しないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sequences are often used for combining sequences that consist of a base character B followed by one or more combining marks C. By enumerating all sequences in which a certain combining mark is expected and by not listing the combining mark by itself in the LGR, the mark cannot occur outside of these specifically enumerated contexts. In cases where enumeration is not possible or practicable, other techniques can be used to prevent ambiguous segmentation, for example, a context rule on code points that disallows B preceding C in any label except as part of a predefined sequence or class of sequences. The details of such techniques are outside the scope of this document (see [RFC7940] for information on context rules for code points).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配列は、多くの場合、特定の組み合わせマークが、マーク予想によってLGRに単独で結合マークをリストされていない全ての配列を列挙することによって、1つ以上の組み合わせマークC.続い基本文字Bから成る配列を合成するために使用されますこれらの具体的に列挙したコンテキストの外側で発生することはできません。列挙が可能または実用的でない場合には、他の技術は、例えば、あいまいなセグメント化を防止するために使用することができ、配列の所定のシーケンスまたはクラスの一部として以外の任意のラベルでCの前にBを禁止コード・ポイントのコンテキストルール。そのような技術の詳細は、（コード・ポイントのコンテキストルールについては[RFC7940]を参照）は、この文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. Corresponding XML Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.対応するXML表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The XML format defined in [RFC7940] corresponds fairly directly to the notation used for variant mappings in this document. (There is no notation in the RFC for variant type sets). In an LGR document, a simple member of a repertoire that does not have any variants is listed as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940]で定義されたXML形式はこの文書の変異のマッピングのために使用される表記法にかなり直接対応します。 （バリアント型セットのRFCには表記はありません）。 LGRの文書では、任意のバリアントを持っていないレパートリーの簡単なメンバーは次のようにリストされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;char cp=&#34;nnnn&#34; /&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;シャアのCP = &#34;NNNN&#34; /&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where nnnn is the [UNICODE] code point value in the standard uppercase hexadecimal notation padded to at least 4 digits and without leading &#34;U+&#34;. For a code point sequence of length 2, the XML notation becomes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでNNNNは、標準的な大文字の16進数で[UNICODE]コードポイント値は、少なくとも4桁にし、先頭に「U +」なしにパディングされます。長さ2の符号点列に対して、XML表記は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;char cp=&#34;uuuu vvvvv&#34; /&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;シャアのCP = &#34;UUUU vvvvv&#34; /&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variant mappings are defined by nesting &lt;var&gt; elements inside the &lt;char&gt; element. For example, a variant relation of type &#34;blocked&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変異のマッピングは、&lt;チャー&gt;要素内の&lt;VAR&gt;要素を入れ子にすることによって定義されます。例えば、タイプの変異体の関係は「ブロック」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x--&gt; X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C X  - &gt; X
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is expressed as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;char cp=&#34;nnnn&#34;&gt; &lt;var cp=&#34;mmmm&#34; type=&#34;blocked&#34; /&gt; &lt;/char&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;チャーCP = &#34;NNNN&#34;&gt; &lt;VAR CP = &#34;MMMM&#34; タイプ= &#34;遮断&#34; /&gt; &lt;/チャー&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where &#34;x--&gt;&#34; identifies a &#34;blocked&#34; type. (Other types include &#34;a--&gt;&#34; for &#34;allocatable&#34;, for example. Here, nnnn and mmmm are the [UNICODE] code point values for C and X, respectively. Either C or X could be a code point sequence or a single code point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、「X  - &gt;」を識別する「ブロック」型。 （他のタイプは、「 - &gt;」は、例えば、「割り当て」ここで、NNNNとMMMMは[UNICODE] C及びX、それぞれいずれCまたはXのコードポイント値とすることができるコードポイント配列またはあるため。単一のコードポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reflexive mapping is specified the same way, except that it always uses the same code point value for both the &lt;char&gt; and &lt;var&gt; element, for example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再帰マッピングは、それが常に、例えば、両方の&lt;チャー&gt;と&lt;VAR&gt;要素のために同じコードポイント値を使用することを除いて、同じように指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
X r-o--&gt; X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Ｘ ｒーおーー＞ Ｘ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
would correspond to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
に相当するであろう
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;char cp=&#34;nnnn&#34;&gt;&lt;var cp=&#34;nnnn&#34; type=&#34;out-of-repertoire-var&#34; /&gt;&lt;/char&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;チャーCP = &#34;NNNN&#34;&gt; &lt;ここで、CP = &#34;NNNN&#34; タイプ= &#34;アウトオブレパートリーがあった&#34; /&gt; &lt;/チャー&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple &lt;var&gt; elements may be nested inside a single &lt;char&gt; element, but their &#34;cp&#34; values must be distinct (unless attributes for context rules are present and the combination of &#34;cp&#34; value and context attributes are distinct).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数の&lt;VAR&gt;要素は、単一の&lt;チャー&gt;要素内にネストされてもよいが、（コンテキストルールの属性が存在し、「CP」値とコンテキスト属性の組み合わせが異なっている場合を除き）それらの「CP」の値は別個でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;char cp=&#34;nnnn&#34;&gt; &lt;var cp=&#34;kkkk&#34; type=&#34;allocatable&#34; /&gt; &lt;var cp=&#34;mmmm&#34; type=&#34;blocked&#34; /&gt; &lt;/char&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;チャーCP = &#34;NNNN&#34;&gt; &lt;VAR CP = &#34;KKKK&#34; タイプ= &#34;割り当て&#34; /&gt; &lt;VAR CP = &#34;MMMM&#34; タイプ= &#34;遮断&#34; /&gt; &lt;/チャー&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A set of conditional variants like
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のような条件付きの変異体セット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
final: C a--&gt; K !final: C x--&gt; K
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
最終：C、A  - &gt; Kファイナル：！C X  - &gt; K
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
would correspond to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
に相当するであろう
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;var cp=&#34;kkkk&#34; when=&#34;final&#34; type=&#34;allocatable&#34; /&gt; &lt;var cp=&#34;kkkk&#34; not-when=&#34;final&#34; type=&#34;blocked&#34; /&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;VARのCP = &#34;KKKK&#34; 未場合= &#34;最終的な&#34; タイプ= &#34;遮断&#34; /&gt; &lt;= &#34;最終的な&#34; タイプ= &#34;割り当て&#34; の/ var CP = &#34;KKKK&#34;&gt;が
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the string &#34;final&#34; references a name of a context rule. Context rules are defined in [RFC7940]; they conceptually correspond to regular expressions. The details of how to create and define these rules are outside the scope of this document. If the label matches the context defined in the rule, the variant mapping is valid and takes part in further processing. Otherwise, it is invalid and ignored. Using the &#34;not-when&#34; attribute inverts the sense of the match. The two attributes are mutually exclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこの文字列は「最終」のコンテキストルールの名前を参照します。コンテキストルールは[RFC7940]で定義されています。彼らは、概念的には、正規表現に対応しています。作成し、これらのルールを定義する方法の詳細は、このドキュメントの範囲外です。ラベルがルールで定義されたコンテキストと一致する場合は、バリアントマッピングが有効であり、さらに処理に参加しています。それ以外の場合は、無効と無視されています。使用「ではない - とき」属性は、マッチの意味を反転します。 2つの属性が相互に排他的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A derivation of a variant label disposition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントラベル配置の導出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
if &#34;only-variants&#34; = &#34;s&#34; or &#34;b&#34; =&gt; allocatable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
「唯一の変種」=「S」または「B」の場合=&gt;割り当て可能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is expressed as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;action disp=&#34;allocatable&#34; only-variants= &#34;s b&#34; /&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;アクションDISP = &#34;割り当て可能&#34; のみ、バリアント= &#34;S B&#34; /&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead of using &#34;if&#34; and &#34;else if&#34;, the &lt;action&gt; elements implicitly form a cascade, where the first action triggered defines the disposition of the label. The order of action elements is thus significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その代わりと「それ以外の場合」、&lt;アクション&gt;要素は暗黙のうち最初のアクションは、ラベルの配置を定義するトリガーカスケードを形成し、「場合」を使用しての。アクション要素の順序は、このように重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the full specification of the XML format, see [RFC7940].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML形式の完全な仕様については、[RFC7940]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not require any IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IANAのアクションを必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in [RFC7940], variants may be used as a tool to reduce certain avenues of attack in security-relevant identifiers by allowing certain labels to be &#34;mutually exclusive or registered only to the same user&#34;. However, if indiscriminately designed, variants may themselves contribute to risks to the security or usability of the identifiers, whether resulting from an ambiguous definition or from allowing too many allocatable variants per label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940]に記載されているように、変異体は、特定のラベルが「相互に排他的なまたは唯一の同じユーザに登録」することができるようにすることで、セキュリティ関連識別子の攻撃の特定の道を低減するためのツールとして使用することができます。無差別に設計された場合には、変異体は、それ自体があいまいな定義から生じたかどうかをラベルごとにあまりにも多くの割付け変形が可能で、識別子のセキュリティや利便性へのリスクに寄与することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information in this document is intended to allow the reader to design a specification of an LGR that is &#34;well behaved&#34; with respect to variants; as used here, this term refers to an LGR that is predictable in its effects to the LGR author (and reviewer) and more reliable in its implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の情報は、読者が変異体に関して「行儀」されるLGRの仕様を設計することができるように意図されています。ここで使用されるように、この用語は、その実装におけるLGRの著者（および校閲）にその効果が予測可能でより信頼性のあるLGRを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A well-behaved LGR is not merely one that can be expressed in [RFC7940], but, in addition, it actively avoids certain edge cases not prevented by the schema, such as those that would result in ambiguities in the specification of the intended disposition for some variant labels. By applying the additional considerations introduced in this document, including adding certain declarations that are optional under the schema and may not alter the results of processing a label, such an LGR becomes easier to review and its implementations easier to verify.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
行儀LGRは、さらに、それは積極的にそのような意図された配置の仕様に曖昧さをもたらすものとしてスキーマによって妨げられない特定のエッジケースを回避し、単に[RFC7940]で表すことができるものではないが、いくつかのバリエーションラベルの。スキーマの下に任意であり、ラベルの処理の結果を変更しないことがあり、特定の宣言を追加することを含め、この文書に導入される追加の考慮事項を適用することによって、そのようなLGRを確認し、その実装容易に確認することが容易になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that variants are an important part, but only a part, of an LGR design. There are many other features of an LGR that this document does not touch upon. Also, the question of whether to define variants at all, or what labels are to be considered variants of each other, is not addressed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変異体はLGR設計の重要な部分はなく、一部のみ、あることに留意すべきです。この文書は触れていませんLGRの他の多くの機能があります。また、すべてのバリアントを定義、または互いのバリエーションと考えることが何であるかをラベルするかどうかの質問は、ここで扱われていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940] Davies, K. and A. Freytag, &#34;Representing Label Generation Rulesets Using XML&#34;, RFC 7940, DOI 10.17487/RFC7940, August 2016, &lt;https://www.rfc-editor.org/info/rfc7940&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940]デイヴィス、K.とA.フライターク、RFC 7940、DOI 10.17487 / RFC7940 &#34;XMLを使用したラベル生成ルールセットの表現&#34; を、2016年8月、&lt;https://www.rfc-editor.org/info/rfc7940&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris, P., &#34;Domain names - concepts and facilities&#34;, STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987, &lt;https://www.rfc-editor.org/info/rfc1034&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris、P.、 &#34;ドメイン名 - 概念と設備&#34;、STD 13、RFC 1034、DOI 10.17487 / RFC1034、1987年11月、&lt;https://www.rfc-editor.org/info/rfc1034&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1035] Mockapetris, P., &#34;Domain names - implementation and specification&#34;, STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987, &lt;https://www.rfc-editor.org/info/rfc1035&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1035] Mockapetris、P.、 &#34;ドメイン名 - 実装及び仕様&#34;、STD 13、RFC 1035、DOI 10.17487 / RFC1035、1987年11月、&lt;https://www.rfc-editor.org/info/rfc1035&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5890] Klensin, J., &#34;Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework&#34;, RFC 5890, DOI 10.17487/RFC5890, August 2010, &lt;https://www.rfc-editor.org/info/rfc5890&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5890] Klensin、J.、 &#34;アプリケーション（IDNA）のための国際化ドメイン名：定義とドキュメントフレームワーク&#34;、RFC 5890、DOI 10.17487 / RFC5890、2010年8月、&lt;https://www.rfc-editor.org/info/ rfc5890&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5891] Klensin, J., &#34;Internationalized Domain Names in Applications (IDNA): Protocol&#34;, RFC 5891, DOI 10.17487/RFC5891, August 2010, &lt;https://www.rfc-editor.org/info/rfc5891&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5891] Klensin、J.、 &#34;アプリケーション（IDNA）で国際化ドメイン名：プロトコル&#34;、RFC 5891、DOI 10.17487 / RFC5891、2010年8月、&lt;https://www.rfc-editor.org/info/rfc5891&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5892] Faltstrom, P., Ed., &#34;The Unicode Code Points and Internationalized Domain Names for Applications (IDNA)&#34;, RFC 5892, DOI 10.17487/RFC5892, August 2010, &lt;https://www.rfc-editor.org/info/rfc5892&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5892] Faltstrom、P.、エド。、 &#34;Unicodeのコードポイントとアプリケーションのための国際化ドメイン名（IDNA）&#34;、RFC 5892、DOI 10.17487 / RFC5892、2010年8月、&lt;https://www.rfc-editor.org /情報/ rfc5892&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5893] Alvestrand, H., Ed. and C. Karp, &#34;Right-to-Left Scripts for Internationalized Domain Names for Applications (IDNA)&#34;, RFC 5893, DOI 10.17487/RFC5893, August 2010, &lt;https://www.rfc-editor.org/info/rfc5893&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5893] Alvestrand、H.、エド。そして、C.カープ、 &#34;右から左のアプリケーションのための国際化ドメイン名のためのスクリプト（IDNA）&#34;、RFC 5893、DOI 10.17487 / RFC5893、2010年8月、&lt;https://www.rfc-editor.org/info/rfc5893 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5894] Klensin, J., &#34;Internationalized Domain Names for Applications (IDNA): Background, Explanation, and Rationale&#34;, RFC 5894, DOI 10.17487/RFC5894, August 2010, &lt;https://www.rfc-editor.org/info/rfc5894&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5894] Klensin、J.、 &#34;アプリケーション（IDNA）のための国際化ドメイン名：背景、説明、及び根拠&#34;、RFC 5894、DOI 10.17487 / RFC5894、2010年8月、&lt;https://www.rfc-editor.org/情報/ rfc5894&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE] The Unicode Consortium, &#34;The Unicode Standard&#34;, &lt;http://www.unicode.org/versions/latest/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE]ユニコードコンソーシアム、 &#34;Unicode規格&#34;、&lt;http://www.unicode.org/versions/latest/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contributions that have shaped this document have been provided by Marc Blanchet, Ben Campbell, Patrik Faltstrom, Scott Hollenbeck, Mirja Kuehlewind, Sarmad Hussain, John Klensin, Alexey Melnikov, Nicholas Ostler, Michel Suignard, Andrew Sullivan, Wil Tan, and Suzanne Woolf.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントを形作ってきた貢献はマルク・ブランシェ、ベン・キャンベル、パトリックFaltstrom、スコットホレンベック、Mirja Kuehlewind、Sarmadフセイン、ジョン・クレンシン、アレクセイ・メルニコフ、ニコラス・オストラ、ミシェルSuignard、アンドリュー・サリバン、ウィルタン、とスザンヌウルフによって提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Asmus Freytag
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Asmusフライターク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: asmus@unicode.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：asmus@unicode.org
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
