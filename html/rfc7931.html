<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7931 - NFSv4.0 Migration: Specification Update 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7931</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc7931">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7931 - NFSv4.0 Migration: Specification Update 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7931">
              https://tools.ietf.org/html/rfc7931
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7931 - NFSv4.0移行：スペック・アップデート</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                    D. Noveck, Ed.
Request for Comments: 7931                                           HPE
Updates: 7530                                                  P. Shivam
Category: Standards Track                                       C. Lever
ISSN: 2070-1721                                                 B. Baker
                                                                  ORACLE
                                                               July 2016
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                NFSv4.0 Migration: Specification Update
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The migration feature of NFSv4 allows the transfer of responsibility for a single file system from one server to another without disruption to clients. Recent implementation experience has shown problems in the existing specification for this feature in NFSv4.0. This document identifies the problem areas and provides revised specification text that updates the NFSv4.0 specification in RFC 7530.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4のの移行機能は、クライアントを中断せずに別のサーバーから単一のファイルシステムのための責任の転送を可能にします。最近の実装経験がNFSv4.0でこの機能のための既存の仕様上の問題を示しています。この文書では、問題領域を識別し、RFC 7530にNFSv4.0仕様を更新改定基準のテキストを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7931.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7931で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Conventions . . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  Definitions . . . . . . . . . . . . . . . . . . . . . . . . .   3
     3.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   3
     3.2.  Data Type Definitions . . . . . . . . . . . . . . . . . .   5
   4.  Background  . . . . . . . . . . . . . . . . . . . . . . . . .   5
   5.  Client Identity Definition  . . . . . . . . . . . . . . . . .   7
     5.1.  Differences from Replaced Sections  . . . . . . . . . . .   7
     5.2.  Client Identity Data Items  . . . . . . . . . . . . . . .   8
       5.2.1.  Client Identity Structure . . . . . . . . . . . . . .   9
       5.2.2.  Client Identity Shorthand . . . . . . . . . . . . . .  11
     5.3.  Server Release of Client ID . . . . . . . . . . . . . . .  13
     5.4.  Client ID String Approaches . . . . . . . . . . . . . . .  14
     5.5.  Non-uniform Client ID String Approach . . . . . . . . . .  16
     5.6.  Uniform Client ID String Approach . . . . . . . . . . . .  16
     5.7.  Mixing Client ID String Approaches  . . . . . . . . . . .  18
     5.8.  Trunking Determination when Using Uniform Client ID
           Strings . . . . . . . . . . . . . . . . . . . . . . . . .  20
     5.9.  Client ID String Construction Details . . . . . . . . . .  26
   6.  Locking and Multi-Server Namespace  . . . . . . . . . . . . .  28
     6.1.  Lock State and File System Transitions  . . . . . . . . .  28
       6.1.1.  Migration and State . . . . . . . . . . . . . . . . .  29
         6.1.1.1.  Migration and Client IDs  . . . . . . . . . . . .  31
         6.1.1.2.  Migration and State Owner Information . . . . . .  32
       6.1.2.  Replication and State . . . . . . . . . . . . . . . .  36
       6.1.3.  Notification of Migrated Lease  . . . . . . . . . . .  36
       6.1.4.  Migration and the lease_time Attribute  . . . . . . .  39
   7.  Server Implementation Considerations  . . . . . . . . . . . .  39
     7.1.  Relation of Locking State Transfer to Other Aspects of
           File System Motion  . . . . . . . . . . . . . . . . . . .  39
     7.2.  Preventing Locking State Modification during Transfer . .  41
   8.  Additional Changes  . . . . . . . . . . . . . . . . . . . . .  44
     8.1.  Summary of Additional Changes from Previous Documents . .  45
     8.2.  NFS4ERR_CLID_INUSE Definition . . . . . . . . . . . . . .  45
     8.3.  NFS4ERR_DELAY Return from RELEASE_LOCKOWNER . . . . . . .  45
     8.4.  Operation 35: SETCLIENTID -- Negotiate Client ID  . . . .  46
     8.5.  Security Considerations for Inter-server Information
           Transfer  . . . . . . . . . . . . . . . . . . . . . . . .  51
     8.6.  Security Considerations Revision  . . . . . . . . . . . .  51
   9.  Security Considerations . . . . . . . . . . . . . . . . . . .  52
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  52
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  52
     10.2.  Informative References . . . . . . . . . . . . . . . . .  52
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  53
   Authors&#39; Addresses  . . . . . . . . . . . . . . . . . . . . . . .  54
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This Standards Track document corrects the existing definitive specification of the NFSv4.0 protocol described in [RFC7530]. Given this fact, one should take the current document into account when learning about NFSv4.0, particularly if one is concerned with issues that relate to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この標準化過程ドキュメントは[RFC7530]で説明NFSv4.0プロトコルの既存の決定的な仕様を修正します。一つはに関連する問題に関係している場合は特に、NFSv4.0について学ぶ際にこの事実を考えると、1のアカウントに現在の文書を取る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o File system migration, particularly when it involves transparent state migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oファイルシステムの移行、それが透明状態の移行を必要とする場合は特に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The construction and interpretation of the nfs_client_id4 structure and particularly the requirements on the id string within it, referred to below as a &#34;client ID string&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_client_id4構造の構築と解釈Oおよびその中のID列に特に要件、「クライアントID列」と称し。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Conventions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります[RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following definitions are included to provide an appropriate context for the reader. This section is derived from Section 1.5 of [RFC7530] but has been adapted to the needs of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の定義は、読者のために適切なコンテキストを提供するために含まれています。このセクションでは、[RFC7530]のセクション1.5に由来しているが、この文書のニーズに適応されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Boot Instance Id: A boot instance id is an identifier, such as a boot time, allowing two different instances of the same client to be reliably distinguished. A boot instance id is opaque to the server and is often used as the verifier field in the nfs_client_id4 structure, which identifies the client to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブートインスタンスIdは：ブート・インスタンスIDは、同じクライアントの2つの異なるインスタンスを確実に区別できるように、このような起動時間と、識別子です。ブート・インスタンスIDは、サーバに不透明であり、多くの場合、サーバにクライアントを識別するnfs_client_id4構造における検証フィールドとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client: A client is an entity that accesses the NFS server&#39;s resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント：クライアントは、NFSサーバーのリソースにアクセスするエンティティです。クライアントは直接NFSサーバーにアクセスするためのロジックが含まれているアプリケーションであってもよいです。また、クライアントはアプリケーションのセットのためにリモートファイルシステムのサービスを提供し、伝統的なオペレーティングシステムのクライアントであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
With reference to byte-range locking, the client is also the entity that maintains a set of locks on behalf of one or more applications. This client is responsible for crash or failure recovery for those locks it manages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バイト範囲ロックを参照すると、クライアントは、1つ以上のアプリケーションのためにロックのセットを保持するエンティティです。このクライアントは、それが管理し、それらのロックのクラッシュや障害復旧のために責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that multiple clients may share the same transport and connection, and multiple clients may exist on the same network node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
複数のクライアントが同じトランスポートおよび接続を共有してもよいことに留意されたい、及び複数のクライアントが同一のネットワーク・ノードに存在してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client ID: A client ID is a 64-bit quantity (in the form of a clientid4) used as a unique, shorthand reference to a particular client instance, identified by a client-supplied verifier (in the form of a boot instance id) and client ID string. The server is responsible for supplying the client ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントID：クライアントIDは、（ブート・インスタンスIDの形式で）クライアントが提供する検証者によって識別された特定のクライアントインスタンスに固有の、速記参照として使用（clientid4の形で）64ビット量でありますクライアントのID文字列。サーバーは、クライアントのIDを供給するための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
File System: A file system is the collection of objects on a server that share the same fsid attribute (see Section 5.8.1.9 of [RFC7530]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステム：ファイルシステム（[RFC7530]のセクション5.8.1.9を参照）と同じFSID属性を共有し、サーバ上のオブジェクトのコレクションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Grace Period: A grace period is an interval of time during which the server will only grant locking requests to reclaim existing locks but not those that create new locks. This gives clients an opportunity to re-establish locking state in response to a potentially disruptive event. The grace period may be general to help deal with server reboot, or it may be specific to a file system to deal with file system migration when transparent state migration is not provided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
猶予期間は：猶予期間は、サーバが唯一の既存のロックではなく、新しいロックを作成したものを再利用するために、ロック要求を許可します、その間の時間間隔です。これは、クライアントに潜在的に破壊的なイベントに応答してロック状態を再確立する機会を与えてくれます。猶予期間は、サーバーの再起動に対処するのが一般的であってもよいし、透明状態の移行が提供されていないときに、ファイルシステムの移行に対処するためのファイルシステムに特異的であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lease: A lease is an interval of time defined by the server for which the client is irrevocably granted a lock. At the end of a lease period, the lock may be revoked if the lease has not been extended. The lock must be revoked if a conflicting lock has been granted after the lease interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リース：リースは、クライアントが取り返しのつかないロックを付与されているサーバーで定義された時間間隔です。リースが拡張されていない場合は、リース期間の終了時に、ロックを取り消すことができます。競合ロックがリース期間の後に付与されている場合はロックが取り消されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
All leases granted by a server have the same fixed duration. Note that the fixed interval duration was chosen to alleviate the expense a server would have in maintaining state about variable-length leases across server failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバによって付与されたすべてのリースは同じ固定期間を有します。固定された間隔の持続時間は、サーバは、サーバの障害を横切る可変長リースについての状態を維持するであろう費用を軽減するために選択されたことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lock: The term &#34;lock&#34; is used to refer to record (byte-range) locks as well as share reservations unless specifically stated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック：特に断りのない限り、用語「ロック」は、レコード（バイト範囲）ロックだけでなく、共有の予約を参照するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lock-Owner: Each byte-range lock is associated with a specific lock-owner and an open-owner. The lock-owner consists of a client ID and an opaque owner string. The client presents this to the server to establish the ownership of the byte-range lock as needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック所有者：各バイト範囲ロックは、特定のロック所有者とのオープン所有者に関連付けられています。ロック所有者は、クライアントIDと不透明な所有者文字列で構成されています。クライアントは、必要に応じてバイト範囲ロックの所有権を確立するために、サーバーにこれを提示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Open-Owner: Each open file is associated with a specific open-owner, which consists of a client ID and an opaque owner string. The client presents this to the server to establish the ownership of the open as needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン所有者：それぞれの開いているファイルは、クライアントIDと不透明な所有者文字列で構成され、特定のオープン所有者、関連付けられています。クライアントは、必要に応じて、オープンの所有権を確立するために、サーバーにこれを提示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server: A server is an entity responsible for coordinating client access to a set of file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー：サーバーは、ファイル・システムのセットへのクライアントアクセスの調整を担当するエンティティです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid: A stateid is a 128-bit quantity returned by a server that uniquely identifies the open and locking states provided by the server for a specific open-owner or lock-owner/open-owner pair for a specific file and type of lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidは：のstateid一意特定のファイルとロックの種類に特異的なオープン所有者またはロック所有者/オープン所有者ペアのサーバーによって提供されるオープンとロック状態を識別し、サーバによって返された128ビットの量です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Trunking: A situation in which multiple physical addresses are connected to the same logical server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランキング：複数の物理アドレスが同じ論理サーバに接続されている状況。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Verifier: A verifier is a quantity, in the form of a verifier4, that allows one party to an interaction to be aware of a reinitialization or other significant change to the state of the other party. In [RFC7530], this term most often designates the verifier field of an nfs_client_id4, in which a boot instance id is placed to allow the server to determine when there has been a client reboot, making it necessary to eliminate locking state associated with the previous instance of the same client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
検証：検証者が対話に一方の当事者が再初期化または他の当事者の状態に他の有意な変化を認識することを可能にするverifier4の形態で、量です。 [RFC7530]では、この用語は、ほとんどの場合、それが必要以前に関連付けられたロック状態を解消すること、ブート・インスタンスIDは、クライアントの再起動があった場合、サーバが判断できるように配置されたnfs_client_id4の検証フィールドを指定します同じクライアントのインスタンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Data Type Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. データ型定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a table that shows where data types referred to in this document are defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、本書で参照されるデータ型が定義される示す表を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +-----------------+--------------------------------+
           | Item            | Section                        |
           +-----------------+--------------------------------+
           | cb_client4      | Section 2.2.11 in [RFC7530]    |
           | clientaddr4     | Section 2.2.10 in [RFC7530]    |
           | clientid4       | Section 2.1 in [RFC7530]       |
           | lock_owner4     | Section 2.2.14 in [RFC7530]    |
           | nfs_client_id4  | Section 5.2.1 (this document)  |
           | open_owner4     | Section 2.2.13 in [RFC7530]    |
           | verifier4       | Section 2.1 in [RFC7530]       |
           +-----------------+--------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.背景
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation experience with transparent state migration has exposed a number of problems with the then existing specifications of this feature in [RFC7530] and predecessors. The symptoms were:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
透明状態の移行と実装の経験は、[RFC7530]でこの機能を、既存の仕様に問題と前任者の数を公開しました。症状は以下の通りでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o After migration of a file system, a reboot of the associated client was not appropriately dealt with, in that the state associated with the rebooting client was not promptly freed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oファイルシステムの移行後、関連するクライアントのリブートを適宜再起動クライアントに関連付けられている状態を速やかに解放されなかったことで、扱っていませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Situations can arise whereby a given server has multiple leases with the same nfs_client_id4 (consisting of id and verifier fields), when the protocol clearly assumes there can be only one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルは明らか一つだけが存在することができるとなると、所与のサーバが、同じnfs_client_id4（IDと検証フィールドからなる）を有する複数のリースを有していることにより、O状況が生じ得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Excessive client implementation complexity since clients have to deal with situations in which a single client can wind up with its locking state with a given server divided among multiple leases each with its own clientid4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O過度のクライアント実装の複雑クライアントは、単一のクライアントが複数のリース独自のclientid4とそれぞれの間で分割指定されたサーバーとそのロック状態で巻き上げることが可能な状況に対処する必要があるため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An analysis of these symptoms leads to the conclusion that existing specifications have erred. They assume that locking state, including both state ids and clientid4s, should be transferred as part of transparent state migration. The troubling symptoms arise from the failure to describe how migrating state is to be integrated with existing client definition structures on the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの症状の分析では、既存の仕様が誤っているという結論につながります。これらは、状態IDとclientid4s両方を含むロック状態は、透明状態移行の一部として転送されなければならないと仮定する。厄介な症状は、状態を移行する先サーバー上の既存のクライアント定義構造と統合する方法を説明するための障害から生じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The need for the server to appropriately merge stateids associated with a common client boot instance encounters a difficult problem. The issue is that the common client practice with regard to the presentation of unique strings specifying client identity makes it essentially impossible for the client to determine whether or not two stateids, originally generated on different servers, are referable to the same client. This practice is allowed and endorsed by the existing NFSv4.0 specification [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適切な一般的なクライアントのブートインスタンスに関連付けられているのstateidsをマージするには、サーバーの必要性は、困難な問題に遭遇しました。問題は、クライアントIDを指定するユニークな文字列のプレゼンテーションに関して共通クライアントの練習は、それが本質的に不可能クライアントが最初に異なるサーバ上で生成された2つのstateidsは、同じクライアントに参照可能かどうかを判断することを可能にするということです。このような行為は許可され、既存のNFSv4.0仕様[RFC7530]によって承認されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, upon the prototyping of clients implementing an alternative approach, it has been found that there exist servers that do not work well with these new clients. It appears that current circumstances, in which a particular client implementation pattern had been adopted universally, have resulted in some servers not being able to interoperate against alternate client implementation patterns. As a result, we have a situation that requires careful attention to untangling compatibility issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、別のアプローチを実装するクライアントのプロトタイピング時に、これらの新しいクライアントとうまく動作しないサーバが存在することが判明しました。特定のクライアントの実装パターンが普遍的に採用されていた中で、現在の状況は、代替クライアントの実装パターンに対して相互運用することができないいくつかのサーバーをもたらしたことが表示されます。その結果、我々はuntangling互換性の問題に注意を要する状況があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document updates the existing NFSv4.0 specification [RFC7530] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにこの文書では、既存のNFSv4.0仕様[RFC7530]を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It makes clear that NFSv4.0 supports multiple approaches to the construction of client ID strings, including those formerly endorsed by existing NFSV4.0 specifications and those currently being widely deployed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OそれはNFSv4.0は、以前は、既存のNFSV4.0仕様によって承認ものと、現在広く展開されているものも含めたクライアントIDの文字列の構築に複数のアプローチをサポートしていることが明らかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It explains how clients can effectively use client ID strings that are presented to multiple servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれはクライアントが効果的に複数のサーバに提示されたクライアントIDの文字列を使用する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It addresses the potential compatibility issues that might arise for clients adopting a previously non-favored client ID string construction approach including the existence of servers that have problems with the new approach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは、クライアントが新しいアプローチで問題が発生したサーバーの存在を含め、以前に非好まクライアントのID文字列の建設的なアプローチを採用するために発生する可能性のある潜在的な互換性の問題に対処します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It gives some guidance regarding the factors that might govern clients&#39; choice of a client ID string construction approach and recommends that clients construct client ID strings in a manner that supports lease merger if they intend to support transparent state migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oこれは、クライアントのID文字列の建設的なアプローチの顧客の選択を支配する可能性がある要因についてのいくつかのガイダンスを提供し、クライアントは、彼らが透明状態の移行をサポートする場合は、リースの合併をサポートしている方法で、クライアントのID文字列を構築することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It specifies how state is to be transparently migrated, including defining how state that arrives at a new server as part of migration is to be merged into existing leases for clients connected to the target server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは状態が透過的に移行の一部であるように、新しいサーバーに到着した状態で、ターゲットサーバに接続しているクライアントのために、既存のリースにマージする方法を定義を含め、移行する方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It makes further clarifications and corrections to address cases where the specification text does not take proper account of the issues raised by state migration or where it has been found that the existing text is insufficiently clear. This includes a revised definition of the SETCLIENTID operation in Section 8.4, which replaces Section 16.33 in [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは、仕様テキストは、状態の移行や場所、既存のテキストが不十分明確であることが判明しているが提起した問題を適切に考慮していない場合に対処するために、さらに明確化し、補正を行います。これは[RFC7530]セクション16.33を置換セクション8.4でSETCLIENTID操作の改訂定義を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a more complete explanation of the choices made in addressing these issues, see [INFO-MIGR].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの問題に対処する上で行った選択のより完全な説明については、[INFO-MIGR]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Client Identity Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.クライアントIDの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is a replacement for Sections 9.1.1 and 9.1.2 in [RFC7530]. The replaced sections are named &#34;Client ID&#34; and &#34;Server Release of Client ID&#34;, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションは、セクション9.1.1および9.1.2 [RFC7530]での代替です。置き換えセクションは、それぞれ、「クライアントID」と「クライアントIDのServerリリース」と命名されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It supersedes the replaced sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、置き換えセクションに取って代わります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Differences from Replaced Sections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 置き換えセクションとの違い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because of the need for greater attention to and careful description of this area, this section is much larger than the sections it replaces. The principal changes/additions made by this section are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大きな関心とこの地域の慎重な記述の必要性のため、このセクションでは、それが置き換わる部分よりもはるかに大きいです。このセクションで作られた主な変更/追加は、以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It corrects inconsistencies regarding the possible role or non-role of the client IP address in construction of client ID strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oこれは、クライアントのID文字列の建設で、クライアントのIPアドレスの可能な役割または非役割に関する矛盾を修正します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It clearly addresses the need to maintain a non-volatile record across reboots of client ID strings or any changeable values that are used in their construction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは明らかにクライアントIDの文字列やその構築に使用されているすべての変更値を再起動しても、不揮発性の記録を維持する必要性に対処しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It provides a more complete description of circumstances leading to clientid4 invalidity and the appropriate recovery actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは無効と適切な回復アクションをclientid4につながる状況のより完全な説明を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It presents, as valid alternatives, two approaches to client ID string construction (named &#34;uniform&#34; and &#34;non-uniform&#34;) and gives some implementation guidance to help implementers choose one or the other of these.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは有効な選択肢、クライアントIDの文字列の構築には、2つの方法（名前の「制服」と「非一様」）として、提示し、実装者は、これらのどちらか一方を選択するため、いくつかの実装ガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It adds a discussion of issues involved for clients in interacting with servers whose behavior is not consistent with use of uniform client ID strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは、その動作が均一クライアントのID文字列の使用と一致していないサーバとの対話で、クライアントのためにかかわる問題の議論を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It adds a description of how server behavior might be used by the client to determine when multiple server IP addresses correspond to the same server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oこれは、サーバーの動作が複数のサーバーのIPアドレスが同じサーバに対応する場合を決定するために、クライアントによって使用される可能性のある方法の説明を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Client Identity Data Items
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. クライアントアイデンティティデータ項目
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFSv4 protocol contains a number of protocol entities to identify clients and client-based entities for locking-related purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4のプロトコルは、ロックに関連する目的のために、クライアントとクライアントベースのエンティティを識別するために、プロトコルエンティティの数が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The nfs_client_id4 structure, which uniquely identifies a specific client boot instance. That identification is presented to the server by doing a SETCLIENTID operation. The SETCLIENTID operation is described in Section 8.4, which modifies a description in Section 16.33 of [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一意に特定クライアントブートインスタンスを識別するnfs_client_id4構造、O。その識別はSETCLIENTID操作を行うことによって、サーバーに提示されます。 SETCLIENTID操作は[RFC7530]のセクション16.33に記述を変更8.4節に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The clientid4, which is returned by the server upon completion of a successful SETCLIENTID operation. This id is used by the client to identify itself when doing subsequent locking-related operations. A clientid4 is associated with a particular lease whereby a client instance holds state on a server instance and may become invalid due to client reboot, server reboot, or other circumstances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功SETCLIENTID操作の完了時に、サーバによって返されclientid4、O。このIDは、後続のロック関連の操作を行う際に自分自身を識別するためにクライアントによって使用されます。 clientid4は、クライアント・インスタンスがサーバーインスタンスに状態を保持し、クライアントによる再起動、サーバの再起動、又は他の状況に無効になるおそれが特定のリースに関連しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Opaque arrays, which are used together with the clientid4 to designate within-client entities (e.g., processes) as the owners of opens (open-owners) and owners of byte-range locks (lock-owners).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O clientid4と一緒に使用される不透明アレイは、指定する内部クライアント開く（オープン所有者）の所有者とバイト範囲ロック（ロック所有者）の所有者などのエンティティ（例えば、プロセス）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1. Client Identity Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1. クライアントIDの構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basis of the client identification infrastructure is encapsulated in the following data structure, which also appears in Section 9.1.1 of [RFC7530]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント識別インフラ基盤はまた、[RFC7530]のセクション9.1.1に表示される次のデータ構造内にカプセル化されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs_client_id4 structure uniquely defines a particular client boot instance as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにnfs_client_id4構造を一意に特定のクライアントのブート・インスタンスを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The id field is a variable-length string that uniquely identifies a specific client. Although it is described here as a string and is often referred to as a &#34;client string&#34;, it should be understood that the protocol defines this as opaque data. In particular, those receiving such an id should not assume that it will be in the UTF-8 encoding. Servers MUST NOT reject an nfs_client_id4 simply because the id string does not follow the rules of UTF-8 encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O IDフィールドは、一意に特定のクライアントを識別する可変長の文字列です。それは文字列としてここに記載されており、しばしば「クライアント文字列」と呼ばれるが、プロトコルは、このような不透明なデータを定義することを理解すべきです。特に、そのようなIDを受信したものは、UTF-8エンコーディングであろうと仮定してはなりません。 id文字列がUTF-8エンコーディングの規則に従っていないため、サーバは単にnfs_client_id4を拒否してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The encoding and decoding processes for this field (e.g., use of network byte order) need to result in the same internal representation whatever the endianness of the originating and receiving machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このフィールドの符号化および復号化プロセスが（例えば、ネットワークバイト順を使用する）は、同じ内部表現をもたらすために必要どの発信及び受信機のエンディアン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The verifier field contains a client boot instance identifier that is used by the server to detect client reboots. Only if the boot instance is different from that which the server has previously recorded in connection with the client (as identified by the id field) does the server cancel the client&#39;s leased state. This cancellation occurs once it receives confirmation of the new nfs_clientd4 via SETCLIENTID_CONFIRM. The SETCLIENTID_CONFIRM operation is described in Section 16.34 of [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O検証フィールドは、クライアントの再起動を検出するために、サーバーによって使用されているクライアントのブートインスタンス識別子が含まれています。ブートインスタンスは（idフィールドによって識別される）サーバは、以前にクライアントとの接続に記録されていたものと異なる場合にのみ、サーバーはクライアントのリース状態を解除ありません。それはSETCLIENTID_CONFIRM経由で新しいnfs_clientd4の確認を受信すると、このキャンセルが発生します。 SETCLIENTID_CONFIRM動作は[RFC7530]のセクション16.34に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In order to prevent the possibility of malicious destruction of the locking state associated with a client, the server MUST NOT cancel a client&#39;s leased state if the principal that established the state for a given id string is not the same as the principal issuing the SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
与えられたid文字列の状態を確立プリンシパルがSETCLIENTIDを発行する元本と同じでない場合は、クライアントに関連付けられているロック状態の悪意の破壊の可能性を防ぐために、サーバはクライアントのリース状態を解除してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several considerations for how the client generates the id string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがID文字列を生成する方法にはいくつかの考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be unique so that multiple clients do not present the same string. The consequences of two clients presenting the same string range from one client getting an error to one client having its leased state abruptly and unexpectedly canceled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のクライアントが同じ文字列を提示しないように、文字列が一意である必要がありますoを。 1つのクライアントにエラーを取得して1つのクライアントから同じ文字列の範囲を提示する2つのクライアントの結果は、そのリース状態が突然と予期せずにキャンセルされました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be selected so that subsequent incarnations (e.g., reboots) of the same client cause the client to present the same string. The implementer is cautioned against an approach that requires the string to be recorded in a local file because this precludes the use of the implementation in an environment where there is no local disk and all file access is from an NFSv4 server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O文字列は、同じクライアントの後続の化身（例えば、リブート）クライアントが同じ文字列を提示させるように選択されるべきです。実装者は、これはローカルディスクがない環境での実装の使用を排除し、すべてのファイルアクセスは、NFSv4サーバからあるので、ローカルファイルに記録される文字列を必要としたアプローチに警告を発しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string MAY be different for each server network address that the client accesses rather than common to all server network addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの文字列は、クライアントがすべてのサーバのネットワークアドレスにではなく、共通のよりアクセスする各サーバーネットワークアドレスの異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The considerations that might influence a client to use different strings for different network server addresses are explained in Section 5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
別のネットワークサーバーのアドレスごとに異なる文字列を使用するようにクライアントに影響を与える可能性の考慮事項は、5.4節で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The algorithm for generating the string should not assume that the clients&#39; network addresses will remain the same for any set period of time. Even while the client is still running in its current incarnation, changes might occur between client incarnations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oを、文字列を生成するためのアルゴリズムは、クライアントのネットワークアドレスは、時間の任意のセット期間に同じままであることを仮定するべきではありません。クライアントが現在の化身で実行されている間も、変更がクライアント・インカネーションの間で発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Changes to the client ID string due to network address changes would result in successive SETCLIENTID operations for the same client appearing as from different clients, interfering with the use of the nfs_client_id4 verifier field to cancel state associated with previous boot instances of the same client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ネットワークアドレスの変更は、同じクライアントの以前のブートインスタンスに関連付けられている状態を解除するnfs_client_id4検証フィールドの使用に干渉し、異なるクライアントからのように見える、同じクライアントのための連続したSETCLIENTID操作につながるによるクライアントIDの文字列に変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The difficulty is more severe if the client address is the only client-based information in the client ID string. In such a case, there is a real risk that after the client gives up the network address, another client, using the same algorithm, would generate a conflicting id string. This would be likely to cause an inappropriate loss of locking state. See Section 5.9 for detailed guidance regarding client ID string construction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントアドレスは、クライアントのID文字列にのみクライアントベースの情報である場合には難易度がより深刻です。このような場合、クライアントは同じアルゴリズムを使用して、ネットワークアドレス、他のクライアントを放棄した後、競合id文字列を生成することを本当の危険性があります。これは、状態をロックの不適切な損失を引き起こす可能性が高いだろう。クライアントIDの文字列の構築に関する詳細なガイダンスについては、セクション5.9を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2. Client Identity Shorthand
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2. クライアントのアイデンティティ速記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a SETCLIENTID and SETCLIENTID_CONFIRM sequence has successfully completed, the client uses the shorthand client identifier, of type clientid4, instead of the longer and less compact nfs_client_id4 structure. This shorthand client identifier (a client ID) is assigned by the server and should be chosen so that it will not conflict with a client ID previously assigned by the same server and, to the degree practicable, by other servers as well. This applies across server restarts or reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDとSETCLIENTID_CONFIRMシーケンスが正常に完了すると、クライアントはタイプclientid4の代わりに、より長く、より少ないコンパクトなnfs_client_id4構造のため、速記クライアント識別子を使用しています。この速記クライアント識別子（クライアントID）は、サーバーによって割り当てられ、それは同様に他のサーバによって、実用的な程度に、以前に同じサーバによって割り当てられたクライアントIDと競合してないように選択する必要があります。これは、サーバの再起動または再起動しても適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Establishment of the client ID by a new incarnation of the client also has the effect of immediately breaking any leased state that a previous incarnation of the client might have had on the server, as opposed to forcing the new client incarnation to wait for the leases to expire. Breaking the lease state amounts to the server removing all locks, share reservations, and delegation states not requested using the CLAIM_DELEGATE_PREV claim type associated with a client having the same identity. For a discussion of delegation state recovery, see Section 10.2.1 of [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの新しいインカネーションによって、クライアントIDの確立もすぐにリースを待つために新しいクライアント化身を強制的に対立するものとして、クライアントの前身は、サーバー上で持っていたかもしれないことをすべてのリース状態を壊す効果を持ちます有効期限が切れます。同じIDを持つクライアントに関連付けられているCLAIM_DELEGATE_PREV請求タイプを使用して要求していないすべてのロック、共有の予約、および委任状態を削除するサーバーにリース状態量を破ります。委任状態の回復の議論に関しては、[RFC7530]のセクション10.2.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the SETCLIENTID and SETCLIENTID_CONFIRM operations have a secondary purpose of establishing the information the server needs to make callbacks to the client for the purpose of supporting delegations. The client is able to change this information via SETCLIENTID and SETCLIENTID_CONFIRM within the same incarnation of the client without causing removal of the client&#39;s leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDとSETCLIENTID_CONFIRM操作は、サーバーがサポートする代表団の目的のために、クライアントへのコールバックを行うために必要な情報を確立する二次的な目的を持っていることに注意してください。クライアントは、クライアントのリース状態の除去を引き起こすことなく、クライアントの同じ化身内SETCLIENTIDとSETCLIENTID_CONFIRMを経由してこの情報を変更することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Distinct servers MAY assign clientid4s independently, and they will generally do so. Therefore, a client has to be prepared to deal with multiple instances of the same clientid4 value received on distinct IP addresses, denoting separate entities. When trunking of server IP addresses is not a consideration, a client should keep track of &lt;IP-address, clientid4&gt; pairs, so that each pair is distinct. For a discussion of how to address the issue in the face of possible trunking of server IP addresses, see Section 5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個別のサーバーは独立してclientid4sを割り当てることができ、そして、彼らは一般的にそうなります。したがって、クライアントは、別々のエンティティを表す、個別のIPアドレス上で受信された同じclientid4値の複数のインスタンスを扱うように準備されなければなりません。サーバーのIPアドレスのトランキングが考慮事項ではない場合は、各ペアは別個のものであるように、クライアントは、&lt;IPアドレス、clientid4&gt;ペアを追跡する必要があります。サーバーのIPアドレスの可能性トランキングの顔に問題に対処する方法の議論については、5.4節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Owners of opens and owners of byte-range locks are separate entities and remain separate even if the same opaque arrays are used to designate owners of each. The protocol distinguishes between open-owners (represented by open_owner4 structures) and lock-owners (represented by lock_owner4 structures).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープンおよびバイト範囲ロックの所有者の所有者が同じ不透明アレイはそれぞれの所有者を指定するために使用されていても、別個のエンティティであり、別個のままです。プロトコルは、オープン所有者（open_owner4構造によって表される）と（lock_owner4構造によって表される）ロック所有者を区別する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both sorts of owners consist of a clientid4 and an opaque owner string. For each client, there is a set of distinct owner values used with that client which constitutes the set of known owners of that type, for the given client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者の両方の種類はclientid4と不透明な所有者文字列で構成されています。クライアントごとに、特定のクライアントのために、そのタイプ、既知の所有者のセットを構成するクライアントで使用される個別の所有者の値のセットがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each open is associated with a specific open-owner while each byte-range lock is associated with a lock-owner and an open-owner, the latter being the open-owner associated with the open file under which the LOCK operation was done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各バイト範囲ロックがロック所有者とオープン所有者は、ロック操作が行われたときのオープンファイルに関連付けられている後者はオープン所有者に関連付けられている間に、各オープンは、特定のオープン所有者に関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a clientid4 is presented to a server and that clientid4 is not valid, the server will reject the request with an error that depends on the reason for clientid4 invalidity. The error NFS4ERR_ADMIN_REVOKED is returned when the invalidation is the result of administrative action. When the clientid4 is unrecognizable, the error NFS4ERR_STALE_CLIENTID or NFS4ERR_EXPIRED may be returned. An unrecognizable clientid4 can occur for a number of reasons:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid4がサーバーに提示し、そのclientid4が有効でないと、サーバーはclientid4無効の理由に依存エラーで要求を拒否します。無効化は行政行為の結果であるとするとエラーNFS4ERR_ADMIN_REVOKEDが返されます。 clientid4が認識できない場合は、エラーNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_EXPIREDが返されることがあります。認識できないclientid4はいくつかの理由で発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A server reboot causing loss of the server&#39;s knowledge of the client. (Always returns NFS4ERR_STALE_CLIENTID.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバーの再起動は、クライアントのサーバーの知識の損失が発生します。 （常にNFS4ERR_STALE_CLIENTIDを返します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Client error sending an incorrect clientid4 or a valid clientid4 to the wrong server. (May return either error.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
間違ったclientid4または誤ったサーバーへの有効なclientid4を送信oクライアントエラー。 （どちらかのエラーが返されることがあります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Loss of lease state due to lease expiration. (Always returns NFS4ERR_EXPIRED.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有効期限をリースによるリース状態のO損失。 （常にNFS4ERR_EXPIREDを返します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Client or server error causing the server to believe that the client has rebooted (i.e., receiving a SETCLIENTID with an nfs_client_id4 that has a matching id string and a non-matching boot instance id as the verifier). (May return either error.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが再起動したことを信じるようにサーバーを引き起こしOクライアントまたはサーバー・エラー（即ち、マッチングID列と検証などの非マッチングブート・インスタンスIDを持つnfs_client_id4とSETCLIENTIDを受信します）。 （どちらかのエラーが返されることがあります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Migration of all state under the associated lease causes its non-existence to be recognized on the source server. (Always returns NFS4ERR_STALE_CLIENTID.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O関連リースの下にあるすべての状態の移行は、その非存在は、ソースサーバ上で認識させます。 （常にNFS4ERR_STALE_CLIENTIDを返します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Merger of state under the associated lease with another lease under a different client ID causes the clientid4 serving as the source of the merge to cease being recognized on its server. (Always returns NFS4ERR_STALE_CLIENTID.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるクライアントIDの下に別のリースに関連付けられリース下状態のO合併は、そのサーバ上で認識されて停止するマージのソースとしてclientid4を引き起こします。 （常にNFS4ERR_STALE_CLIENTIDを返します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event of a server reboot, loss of lease state due to lease expiration, or administrative revocation of a clientid4, the client must obtain a new clientid4 by use of the SETCLIENTID operation and then proceed to any other necessary recovery for the server reboot case (see Section 9.6.2 in [RFC7530]). In cases of server or client error resulting in a clientid4 becoming unusable, use of SETCLIENTID to establish a new lease is desirable as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの再起動が発生した場合、有効期限、またはclientid4の行政取り消しをリースによるリース状態の損失は、クライアントはSETCLIENTID操作の使用によって、新しいclientid4を取得する必要がありますし、サーバーの再起動の場合のために、他の必要な回復に進んで（[RFC7530]セクション9.6.2を参照）。サーバーまたは使用できなくなってきてclientid4その結果、クライアントエラーの例では、新しいリースを確立するSETCLIENTIDの使用も同様に望ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases in which loss of server knowledge of a clientid4 is the result of migration, different recovery procedures are required. See Section 6.1.1 for details. Note that in cases in which there is any uncertainty about which sort of handling is applicable, the distinguishing characteristic is that in reboot-like cases, the clientid4 and all associated stateids cease to exist while in migration-related cases, the clientid4 ceases to exist while the stateids are still valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid4のサーバ知識の損失は、移行の結果である場合には、異なるリカバリ手順が必要です。詳細については、6.1.1項を参照してください。移行関連の例では、clientid4が存在しなくなりながら、取り扱いの並べ替えが適用されるかについての不確実性が存在している場合には、際立った特徴は、再起動のようなケースでは、clientid4および関連するすべてのstateids停戦が存在するということであることに注意してくださいstateidsはまだ有効である間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client must also employ the SETCLIENTID operation when it receives an NFS4ERR_STALE_STATEID error using a stateid derived from its current clientid4, since this indicates a situation, such as a server reboot that has invalidated the existing clientid4 and associated stateids (see Section 9.1.5 in [RFC7530] for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、現在のclientid4由来のstateidを使用してNFS4ERR_STALE_STATEIDエラーを受信したときに、クライアントにも、このような既存のclientid4および関連のstateidsを無効にしているサーバーの再起動などの状況を、示しているため（セクション9.1.5を参照してください、SETCLIENTID操作を使用しなければなりません詳細については[RFC7530]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the detailed descriptions of SETCLIENTID (in Section 8.4) and SETCLIENTID_CONFIRM (in Section 16.34 of [RFC7530]) for a complete specification of these operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの操作の完全な仕様のために（セクション8.4）SETCLIENTIDの詳細な説明を参照し、（[RFC7530]のセクション16.34に）SETCLIENTID_CONFIRM。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Server Release of Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. クライアントIDのサーバ・リリース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server determines that the client holds no associated state for its clientid4, the server may choose to release that clientid4. The server may make this choice for an inactive client so that resources are not consumed by those intermittently active clients. If the client contacts the server after this release, the server must ensure the client receives the appropriate error so that it will use the SETCLIENTID/SETCLIENTID_CONFIRM sequence to establish a new identity. It should be clear that the server must be very hesitant to release a client ID since the resulting work on the client to recover from such an event will be the same burden as if the server had failed and restarted. Typically, a server would not release a client ID unless there had been no activity from that client for many minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントがそのclientid4のための関連した状態を保持していないと判断した場合、サーバーはそのclientid4を解放することもできます。リソースは、これらの断続的にアクティブなクライアントによって消費されないように、サーバーは非アクティブクライアントのためにこの選択を行うことができます。クライアントは、このリリースの後にサーバー場合は、サーバーは、それが新しいアイデンティティを確立するためにSETCLIENTID / SETCLIENTID_CONFIRMシーケンスを使用するようにクライアントに適切なエラーを受け取るようにする必要があります。サーバーが失敗し、再起動したかのようなイベントから回復するには、クライアント上の結果の作業は同じ負担になりますので、サーバがクライアントのIDを解放するために非常に躊躇しなければならないことは明らかです。多く分間そのクライアントからの活動がなかった場合を除き一般的に、サーバはクライアントのIDを解放しないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the id string in a SETCLIENTID request is properly constructed, and if the client takes care to use the same principal for each successive use of SETCLIENTID, then, barring an active denial-of-service attack, NFS4ERR_CLID_INUSE should never be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID要求のid列が適切に構築されている場合、クライアントはSETCLIENTIDの各連続使用のために同じプリンシパルを使用するように世話をしている場合、および、その後、アクティブなサービス拒否攻撃がなければ、NFS4ERR_CLID_INUSEが返されることはありませんように注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, client bugs, server bugs, or perhaps a deliberate change of the principal owner of the id string (such as may occur in the case in which a client changes security flavors, and under the new flavor, there is no mapping to the previous owner) will in rare cases result in NFS4ERR_CLID_INUSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、クライアントのバグは、サーバのバグは、または多分ID列の主所有者の意図的変化（例えば、クライアントがセキュリティ風味を変更する場合に発生する可能性があり、新たな味の下で、前へのマッピングが存在しません所有者は）まれにNFS4ERR_CLID_INUSEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In situations in which there is an apparent change of principal, when the server gets a SETCLIENTID specifying a client ID string for which the server has a clientid4 that currently has no state, or for which it has state, but where the lease has expired, the server MUST allow the SETCLIENTID rather than returning NFS4ERR_CLID_INUSE. The server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、サーバには現在の状態を持っていないclientid4を持っているか、そのためには状態を持っていますが、リースが期限切れになったところそのため、クライアントのID文字列を指定SETCLIENTIDを取得元本の明らかな変化がある状況では、サーバーはNFS4ERR_CLID_INUSEを返すのではなく、SETCLIENTIDを許容しなければなりません。サーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MUST then confirm the new client ID if followed by the appropriate SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適切なSETCLIENTID_CONFIRMが続くならば、新しいクライアントIDを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Client ID String Approaches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. クライアントIDの文字列のアプローチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One particular aspect of the construction of the nfs_client_id4 string has proved recurrently troublesome. The client has a choice of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_client_id4文字列の建設の特定の一態様は、反復的に面倒であることが判明しました。クライアントは、の選択肢があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Presenting the same id string to multiple server addresses. This is referred to as the &#34;uniform client ID string approach&#34; and is discussed in Section 5.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のサーバーアドレスに同じID文字列を提示O。これは、「均一クライアントIDの文字列のアプローチ」と呼ばれ、5.6節で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Presenting different id strings to multiple server addresses. This is referred to as the &#34;non-uniform client ID string approach&#34; and is discussed in Section 5.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のサーバーアドレスに異なるID文字列を提示O。これは、「非一様クライアントIDの文字列のアプローチ」と呼ばれ、5.5項で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that implementation considerations, including compatibility with existing servers, may make it desirable for a client to use both approaches, based on configuration information, such as mount options. This issue will be discussed in Section 5.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、既存のサーバとの互換性を含め、その実装の考慮事項に注意してください、それが望ましい、そのようなマウントオプションとして設定情報に基づいて、クライアントは両方のアプローチを使用するために作ることがあります。この問題は、5.7節で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Construction of the client ID string has arisen as a difficult issue because of the way in which the NFS protocols have evolved. It is useful to consider two points in that evolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDの文字列の建設があるため、NFSプロトコルが進化してきた方法のために困難な問題として生じています。その進化に二つの点を考慮することが有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv3 as a stateless protocol had no need to identify the state shared by a particular client-server pair (see [RFC1813]). Thus, there was no need to consider the question of whether a set of requests come from the same client or whether two server IP addresses are connected to the same server. As the environment was one in which the user supplied the target server IP address as part of incorporating the remote file system in the client&#39;s file namespace, there was no occasion to take note of server trunking. Within a stateless protocol, the situation was symmetrical. The client has no server identity information, and the server has no client identity information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv3のoをステートレスプロトコルとして（[RFC1813]を参照）、特定のクライアント - サーバ対によって共有状態を特定する必要がなかったです。このように、要求のセットは、同じクライアントからか、2つのサーバーのIPアドレスが同じサーバーに接続されているかどうか来るかどうかの問題を検討する必要はありませんでした。環境は、ユーザがクライアントのファイル名前空間にリモートファイルシステムを組み込んだの一環として、ターゲットサーバーのIPアドレスを供給するものであったように、サーバのトランキングのノートを取るために何の機会がなかったです。ステートレスなプロトコルの中で、状況は対称的でした。クライアントには、サーバの身元情報を持っていない、とサーバーには、クライアントの識別情報を持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1 is a stateful protocol with full support for client and server identity determination (see [RFC5661]). This enables the server to be aware when two requests come from the same client (they are on sessions sharing a clientid4) and the client to be aware when two server IP addresses are connected to the same server. Section 2.10.5.1 of [RFC5661] explains how the client is able to assure itself that the connections are to the same logical server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O NFSv4.1は（[RFC5661]を参照）は、クライアントとサーバの同一性判定を完全にサポートしてステートフルなプロトコルです。これは、2つの要求が2つのサーバーのIPアドレスが同じサーバーに接続されている場合に注意する同じクライアント（彼らはclientid4を共有するセッションである）と、クライアントから来たときに、サーバーが認識することができます。 [RFC5661]のセクション2.10.5.1は、クライアントが接続が同じ論理サーバにあること自体を保証することができます方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.0 is unfortunately halfway between these two. It introduced new requirements such as the need to identify specific clients and client instances without addressing server identity issues. The two client ID string approaches have arisen in attempts to deal with the changing requirements of the protocol as implementation has proceeded, and features that were not very substantial in early implementations of NFSv4.0 became more substantial as implementation proceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4.0は、残念ながら途中でこれら二つの間にあります。このようなサーバIDの問題に対処することなく、特定のクライアントおよびクライアント・インスタンスを識別するために必要として、新しい要件を導入しました。 2つのクライアントIDの文字列のアプローチは実装が進行するにつれて、より実質的になりました実装が進んでいるようなプロトコルの変化する要件に対処しようとし、NFSv4.0の初期の実装では非常に実質的ではなかった機能で生じています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the absence of any implementation of features related to fs_locations (replication, referral, and migration), the situation is very similar to that of NFSv3 (see Section 8.1 and the subsections within Section 8.4 of [RFC7530] for discussion of these features). In this case, locking state has been added, but there is no need for concern about the provision of accurate client and server identity determination. This is the situation that gave rise to the non-uniform client ID string approach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O fs_位置（複製、照会、および移動）に関連する特徴の任意の実装が存在しない場合、状況はNFSv3のと非常に類似している（これらの機能の説明については、[RFC7530]のセクション8.4内のセクション8.1およびサブセクションを参照のこと） 。この場合、ロック状態が追加されていますが、正確なクライアントとサーバーの同一性判定の提供について懸念する必要はありません。これは、不均一なクライアントIDの文字列アプローチをもたらした状況です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the presence of replication and referrals, the client may have occasion to take advantage of knowledge of server trunking information. Even more important, transparent state migration, by transferring state among servers, causes difficulties for the non-uniform client ID string approach, in that the two different client ID strings sent to different IP addresses may wind up being processed by the same logical server, adding confusion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O複製および紹介の存在下では、クライアントはサーバーのトランキング情報の知識を活用するための機会を持つことができます。さらに重要なのは、透明状態の移行、サーバー間で状態を転送することにより、不均一なクライアントIDの文字列アプローチの困難を引き起こし、その中に巻くことが異なるIPアドレスに送信された二つの異なるクライアントIDの文字列は、同じ論理サーバによって処理されています混乱を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A further consideration is that client implementations typically provide NFSv4.1 by augmenting their existing NFSv4.0 implementation, not by providing two separate implementations. Thus, the more NFSv4.0 and NFSv4.1 can work alike, the less complex the clients are. This is a key reason why those implementing NFSv4.0 clients might prefer using the uniform client string model, even if they have chosen not to provide fs_locations-related features in their NFSv4.0 client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oさらに考慮すべきことは、クライアントインプリメンテーションは、典型的には二つの別々の実装を提供することによって、既存のNFSv4.0実装を増強することによってNFSv4.1を提供することです。このように、より多くのNFSv4.0とNFSv4.1を問わず動作することができ、あまり複雑でないクライアントがあります。これは、NFSv4.0のクライアントを実装するものは、彼らがNFSv4.0のクライアントにfs_位置に関連した機能を提供しないことを選択した場合でも、均一なクライアントストリングモデルを使用して好むかもしれない主な理由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both approaches have to deal with the asymmetry in client and server identity information between client and server. Each seeks to make the client&#39;s and the server&#39;s views match. In the process, each encounters some combination of inelegant protocol features and/or implementation difficulties. The choice of which to use is up to the client implementer, and the sections below try to give some useful guidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方のアプローチは、クライアントとサーバーの間で、クライアントとサーバの身元情報の非対称性に対処する必要があります。各クライアントのサーバーとの見解を一致させることを目指しています。プロセスでは、それぞれが洗練プロトコル機能および/または実装の困難のいくつかの組み合わせに遭遇します。使用するかの選択は、クライアントの実装次第であり、以下のセクションでは、いくつかの有用な指針を与えることを試みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Non-uniform Client ID String Approach
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. 不均一なクライアントID文字列のアプローチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The non-uniform client ID string approach is an attempt to handle these matters in NFSv4.0 client implementations in as NFSv3-like a way as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不均一なクライアントIDの文字列のアプローチは、可能な限りのNFSv3のような方法などでNFSv4.0のクライアントの実装では、これらの問題に対処しようとする試みです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a client using the non-uniform approach, all internal recording of clientid4 values is to include, whether explicitly or implicitly, the server IP address so that one always has an &lt;IP-address, clientid4&gt; pair. Two such pairs from different servers are always distinct even when the clientid4 values are the same, as they may occasionally be. In this approach, such equality is always treated as simple happenstance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不均一なアプローチを使用してクライアントの場合、clientid4値のすべての内部記録はその1は、常に&lt;IPアドレス、clientid4&gt;ペアを持っているので、明示的かどうか、暗黙的に、サーバーのIPアドレスを含めることです。 clientid4値が同じであっても、彼らは時折かもしれとして異なるサーバからの二つのそのようなペアは、常に異なっています。このアプローチでは、このような平等は常に簡単な偶然として扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Making the client ID string different on different server IP addresses results in a situation in which a server has no way of tying together information from the same client, when the client accesses multiple server IP addresses. As a result, it will treat a single client as multiple clients with separate leases for each server network address. Since there is no way in the protocol for the client to determine if two network addresses are connected to the same server, the resulting lack of knowledge is symmetrical and can result in simpler client implementations in which there is a single clientid4/lease per server network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが複数のサーバーのIPアドレスにアクセスしたときに、サーバーが、同じクライアントからの情報を一緒に結ぶ方法がありませんしている状況で異なるサーバーのIPアドレス結果の異なるクライアントIDの文字列を作ります。その結果、各サーバのネットワークアドレスに個別のリースで、複数のクライアントとして単一のクライアントを扱います。 2つのネットワークアドレスが同じサーバに接続されている場合、クライアントが決定するためのプロトコルに方法がないので、知識が得られないことは対称であり、サーバ・ネットワークごとに単一clientid4 /リースが存在する単純なクライアントの実装をもたらすことができます住所。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Support for migration, particularly with transparent state migration, is more complex in the case of non-uniform client ID strings. For example, migration of a lease can result in multiple leases for the same client accessing the same server addresses, vitiating many of the advantages of this approach. Therefore, client implementations that support migration with transparent state migration are likely to experience difficulties using the non-uniform client ID string approach and should not do so, except where it is necessary for compatibility with existing server implementations (for details of arranging use of multiple client ID string approaches, see Section 5.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に透明状態の移行と移行のサポートは、不均一なクライアントのID文字列の場合には、より複雑です。たとえば、リースの移行は、このアプローチの利点の多くをvitiating、同じサーバのアドレスにアクセスして、同じクライアントに対して複数のリースをもたらす可能性があります。そのため、透明状態の移行と移行をサポートし、クライアントの実装では、不均一なクライアントIDの文字列のアプローチを使用して問題が発生する可能性があると、それは、複数の使用を配置する詳細については、（サーバーの実装を既存の互換性のために必要である場合を除いて、そうするべきではありませんクライアントIDの文字列のアプローチ、5.7節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. Uniform Client ID String Approach
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. 制服クライアントID文字列のアプローチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client ID string is kept uniform, the server has the basis to have a single clientid4/lease for each distinct client. The problem that has to be addressed is the lack of explicit server identity information, which was made available in NFSv4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントIDの文字列が均一に維持されている場合、サーバは、各個別のクライアントのための単一のclientid4 /リースを持っている根拠を持っています。取り組まなければならないという問題がNFSv4.1で利用できるようになりました明示的なサーバーID情報の欠如です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the same client ID string is given to multiple IP addresses, the client can determine whether two IP addresses correspond to a single server, based on the server&#39;s behavior. This is the inverse of the strategy adopted for the non-uniform approach in which different server IP addresses are told about different clients, simply to prevent a server from manifesting behavior that is inconsistent with there being a single server for each IP address, in line with the traditions of NFS. So, to compare:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じクライアントIDの文字列が複数のIPアドレスを付与された場合、クライアントは2つのIPアドレスは、サーバの動作に基づいて、単一のサーバーに対応するかどうかを判断することができます。これはラインで、異なるサーバーのIPアドレスがそこには、IPアドレスごとに単一のサーバであることと矛盾する行動を発現からサーバーを防ぐために、単純に、異なるクライアントについて告げられた不均一なアプローチを採用した戦略の逆数でありますNFSの伝統を持ちます。だから、比較します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the non-uniform approach, servers are told about different clients because, if the server were to use accurate client identity information, two IP addresses on the same server would behave as if they were talking to the same client, which might prove disconcerting to a client not expecting such behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、彼らが同じクライアントに話していたかのように動作するのと同じサーバー上で、2つのIPアドレスを正確にクライアントの識別情報を使用した場合に、当惑を証明するかもしれないので、O不均一なアプローチでは、サーバは異なるクライアントについて語っていますクライアントにそのような行動を期待していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the uniform approach, the servers are told about there being a single client, which is, after all, the truth. Then, when the server uses this information, two IP addresses on the same server will behave as if they are talking to the same client, and this difference in behavior allows the client to infer the server IP address trunking configuration, even though NFSv4.0 does not explicitly provide this information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O均一なアプローチでは、サーバはそこには、結局、真実である単一のクライアント、あることについて語っています。その後、サーバは、彼らが同じクライアントに話しているかのように、同じサーバー上の2つのIPアドレスが動作します、この情報を使用し、そして行動の違いもNFSv4.0かかわらず、クライアントがサーバのIPアドレスのトランキングの設定を推論することを可能にするとき明示的にこの情報を提供していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The approach given in the section below shows one example of how this might be done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下のセクションで与えられたアプローチは、これが行われるかもしれない方法の一例を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The uniform client ID string approach makes it necessary to exercise more care in the definition of the boot instance id sent as the verifier field in an nfs_client_id4:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
均一なクライアントIDの文字列アプローチがnfs_client_id4で検証フィールドとして送信されたブート・インスタンスIDの定義に、より注意を払うすることが必要になり：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In [RFC7530], the client is told to change the verifier field value when reboot occurs, but there is no explicit statement as to the converse, so that any requirement to keep the verifier field constant unless rebooting is only present by implication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oで[RFC7530]、クライアントは、再起動が発生したときに検証フィールドの値を変更するように言われますが、再起動は暗黙的にのみ存在しなければどのような要件が一定の検証の場を維持するように、明示的なステートメントは、逆にようがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Many existing clients change the boot instance id every time they destroy and recreate the data structure that tracks an &lt;IP-address, clientid4&gt; pair. This might happen if the last mount of a particular server is removed, and then a fresh mount is created. Also, note that this might result in each &lt;IP-address, clientid4&gt; pair having its own boot instance id that is independent of the others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O多くの既存のクライアントがブートインスタンスIDに彼らが破壊するたびに変更し、&lt;IPアドレス、clientid4&gt;ペアを追跡するデータ構造を再作成します。特定のサーバの最後のマウントが削除された場合に発生する可能性があります、その後、新鮮なマウントが作成されます。また、これは他の人とは独立した独自のブートインスタンスIDを持つ各&lt;IPアドレス、clientid4&gt;ペアになるかもしれないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Within the uniform client ID string approach, an nfs_client_id4 designates a globally known client instance, so that the verifier field should change if and only if a new client instance is created, typically as a result of a reboot.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして新しいクライアント・インスタンスが作成された場合だけ、検証フィールドは、典型的には、再起動の結果として、変更すべきであるように、均一なクライアントID列アプローチ内で、O、nfs_client_id4は、世界的に知られているクライアントのインスタンスを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Clients using the uniform client ID string approach are therefore well advised to use a verifier established only once for each reboot, typically at reboot time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
均一なクライアントIDの文字列のアプローチを使用しているクライアントは、そのためだけでなく、通常の再起動時には、それぞれの再起動を一度だけ確立検証を使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following are advantages for the implementation of using the uniform client ID string approach:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、均一なクライアントIDの文字列のアプローチを使用しての実施のための利点は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clients can take advantage of server trunking (and clustering with single-server-equivalent semantics) to increase bandwidth or reliability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントは、帯域幅や信頼性を高めるために（単一サーバと同等の意味を持つとクラスタリング）サーバーのトランキングを利用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There are advantages in state management so that, for example, one never has a delegation under one clientid4 revoked because of a reference to the same file from the same client under a different clientid4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそのような状態の管理に利点があり、例えば、1が異なるためclientid4の下で同じクライアントから同じファイルへの参照を取り消さ1 clientid4下の委任を持っていることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The uniform client ID string approach allows the server to do any necessary automatic lease merger in connection with transparent state migration, without requiring any client involvement. This consideration is of sufficient weight to cause us to recommend use of the uniform client ID string approach for clients supporting transparent state migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O均一なクライアントID列アプローチは、任意のクライアントの関与を必要とせず、サーバが透明状態の移行に関連して必要な自動リース合併を行うことを可能にします。この考慮事項は、透明状態の移行をサポートするクライアントのための均一なクライアントIDの文字列アプローチの使用を推奨するために私達を引き起こすのに十分な量です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following implementation considerations might cause issues for client implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の実装の考慮事項は、クライアント実装のための問題を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o This approach is considerably different from the non-uniform approach, which most client implementations have been following. Until substantial implementation experience is obtained with this approach, reluctance to embrace something so new is to be expected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oこのアプローチは、ほとんどのクライアントの実装は、次のされている不均一なアプローチ、大きく異なります。かなりの実装経験が、このアプローチで得られるまで、それほど新しいものを受け入れるための抵抗が予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Mapping between server network addresses and leases is more complicated in that it is no longer a one-to-one mapping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはもはや1対1のマッピングであるという点でOサーバ・ネットワーク・アドレスの間のマッピングとリースは、より複雑ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another set of relevant considerations relate to privacy concerns, which users of the client might have in that use of the uniform client ID string approach would enable multiple servers acting in concert to determine when multiple requests received at different times derive from the same NFSv4.0 client. For example, this might enable determination that multiple distinct user identities in fact are likely to correspond to requests made by the same person, even when those requests are directed to different servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連する考察の別のセットは、同じNFSv4.0から派生したクライアントのユーザーが複数の要求が異なる時間に受信ときを決定するために協調して作用する複数のサーバを可能にする均一なクライアントIDの文字列アプローチの利用に必要がある場合がありますプライバシーの問題に関連してクライアント。例えば、これは、これらの要求を別のサーバーに向けられている場合でも、実際には複数の異なるユーザーIDが同じ人によって行われた要求に対応する可能性がある決定を可能にするかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
How to balance these considerations depends on implementation goals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの考慮事項のバランスをとる方法の実装目標によって変わります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. Mixing Client ID String Approaches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. クライアントIDの文字列のアプローチをミキシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted above, a client that needs to use the uniform client ID string approach (e.g., to support migration) may also need to support existing servers with implementations that do not work properly in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述したように、均一なクライアントIDの文字列のアプローチを使用する必要があるクライアントは、（例えば、移行をサポートするため）この場合にも正常に動作しない実装で既存のサーバーをサポートする必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some examples of such server issues include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなサーバーの問題のいくつかの例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Some existing NFSv4.0 server implementations of IP address failover depend on clients&#39; use of a non-uniform client ID string approach. In particular, when a server supports both its own IP address and one failed over from a partner server, it may have separate sets of state applicable to the two IP addresses, owned by different servers but residing on a single one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O IPアドレスのフェイルオーバーのいくつかの既存のNFSv4.0サーバーの実装は、不均一なクライアントIDの文字列アプローチのクライアントの使用に依存します。サーバは両方をサポートし、独自のIPアドレスと1つは、パートナーサーバからフェイルオーバ時に特に、それは別のサーバーが所有する2つのIPアドレスに適用される状態の別のセットを、持っているかもしれませんが、単一のものに常駐しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In this situation, some servers have relied on clients&#39; use of the non-uniform client ID string approach, as suggested but not mandated by [RFC7530], to keep these sets of state separate, and they will have problems handling clients using the uniform client ID string approach, in that such clients will see changes in trunking relationships whenever server failover and giveback occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このような状況では、一部のサーバが別々の状態のこれらのセットを維持するために、提案したが[RFC7530]で義務付けられていないとして、不均一なクライアントIDの文字列アプローチのクライアントの使用に頼ってきた、と彼らは問題が制服を使用してクライアントを扱う必要がありますサーバーのフェイルオーバーとギブバックが発生するたびに、このようなクライアントでクライアントのID文字列のアプローチは、トランキングの関係の変化を見ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Some existing servers incorrectly return NFS4ERR_CLID_INUSE simply because there already exists a clientid4 for the same client, established using a different IP address. This causes difficulty for a multihomed client using the uniform client ID string approach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oいくつかの既存のサーバーが誤っすでに別のIPアドレスを使用して確立し、同じクライアントのためのclientid4が存在するというだけの理由NFS4ERR_CLID_INUSEを返します。これは、均一なクライアントIDの文字列のアプローチを使用してマルチホームのクライアントのために困難になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Although this behavior is not correct, such servers still exist, and this specification should give clients guidance about dealing with the situation, as well as making the correct behavior clear.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この動作は正しくありませんが、そのようなサーバはまだ存在しており、この仕様は、クライアントに、状況に対処についてのガイダンスを与えるだけでなく、正しい行動が明確になっていなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to support use of these sorts of servers, the client can use different client ID string approaches for different mounts, in order to assure that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバのこれらの種類の使用をサポートするために、クライアントはそれを確実にするために、異なるマウントの異なるクライアントIDの文字列のアプローチを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The uniform client ID string approach is used when accessing servers that may return NFS4ERR_MOVED and when the client wishes to enable transparent state migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oをNFS4ERR_MOVEDを返すことがあり、サーバにアクセスする際に均一なクライアントIDの文字列のアプローチが使用され、クライアントが透明状態の移行を可能にしたい場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The non-uniform client ID string approach is used when accessing servers whose implementations make them incompatible with the uniform client ID string approach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その実装均一クライアントIDの文字列のアプローチと彼らは互換性のないするサーバーにアクセスする際に、不均一なクライアントIDの文字列のアプローチが使用され、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the client cannot easily determine which of the above are true, implementations are likely to rely on user-specified mount options to select the appropriate approach to use, in cases in which a client supports simultaneous use of multiple approaches. Choice of a default to use in such cases is up to the client implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが簡単に真である上記のどれかを決定することができないので、実装は、クライアントが複数のアプローチの同時使用をサポートしている場合には、使用するために適切なアプローチを選択するために、ユーザーが指定したマウントオプションに依存する可能性があります。このような場合に使用するデフォルトの選択は、クライアントの実装に任されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case in which the same server has multiple mounts, and both approaches are specified for the same server, the client could have multiple clientid4s corresponding to the same server, one for each approach, and would then have to keep these separate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じサーバーに複数のマウントを有し、両方のアプローチは、同じサーバーに指定された場合には、クライアントは、同じサーバー、各アプローチのための1つに対応する複数のclientid4sを有することができ、その後、これらの別々に維持しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. Trunking Determination when Using Uniform Client ID Strings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. 制服クライアントIDの文字列を使用する際の決定をトランキング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides an example of how trunking determination could be done by a client following the uniform client ID string approach (whether this is used for all mounts or not). Clients need not follow this procedure, but implementers should make sure that the issues dealt with by this procedure are all properly addressed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、トランキング決意が均一クライアントID列アプローチ（これは、すべてのマウントのために用いるか否かに拘わらず）は、次のクライアントによって行うことができる方法の例を提供します。クライアントは、この手順を行う必要はありませんが、実装者は、この手順によって対処の問題がすべて適切に対処されていることを確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is best to clarify here the various possible purposes of trunking determination and the corresponding requirements as to server behavior. The following points should be noted:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここは、トランキングの決定とサーバーの動作に対応するような要件の様々な可能性のある目的を明確にすることが最善です。次の点に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The primary purpose of the trunking determination algorithm is to make sure that, if the server treats client requests on two IP addresses as part of the same client, the client will not be surprised and encounter disconcerting server behavior, as mentioned in Section 5.6. Such behavior could occur if the client were unaware that all of its client requests for the two IP addresses were being handled as part of a single client talking to a single server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oトランキング決意アルゴリズムの主な目的は、5.6節で述べたように、2つのIPアドレス上のサーバーの扱いのクライアント要求が同じクライアントの一部として、クライアントは驚かないだろう場合は、ことを確認し、当惑サーバーの動作に遭遇することです。クライアントは、2つのIPアドレスのためにそのクライアント要求のすべてが単一のサーバーに話し単一のクライアントの一部として扱われていたことを知らなかった場合、このような動作が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A second purpose is to be able to use knowledge of trunking relationships for better performance, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの第二の目的は、良好な性能、等のトランキングの関係の知識を使用することができることです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a server were to give out distinct clientid4s in response to receiving the same nfs_client_id4 on different network addresses, and acted as if these were separate clients, the primary purpose of trunking determination would be met, as long as the server did not treat them as part of the same client. In this case, the server would be acting, with regard to that client, as if it were two distinct servers. This would interfere with the secondary purpose of trunking determination, but there is nothing the client can do about that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバーは、異なるネットワークアドレスに同じnfs_client_id4を受信することに応答して明確なclientid4sを与えるためにあったが、これらは別々のクライアントであれば、トランキング決定の主な目的は、限り、サーバーがそれらを扱うなかったので、会ったことと同じように行動した場合同じクライアントの一部として。それは二つの異なるサーバであるかのようにこの場合、サーバは、そのクライアントに関連して、演技することでしょう。これは、トランキング決定の第2の目的を妨げるだろうが、クライアントはそれについてできることは何もありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Suppose a server were to give such a client two different clientid4s but act as if they were one. That is the only way that the server could behave in a way that would defeat the primary purpose of the trunking determination algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは、彼らが1であるかのようなクライアントに二つの異なるclientid4sが、行為を与えることをしたとします。これは、サーバーがトランキング決定アルゴリズムの第一の目的を台無しにしてしまうように動作することができる唯一の方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Servers MUST NOT behave that way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバはそのように動作してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a client using the uniform approach, clientid4 values are treated as important information in determining server trunking patterns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
均一なアプローチを使用して、クライアントのために、clientid4値はサーバトランキングパターンを決定する上で重要な情報として扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For two different IP addresses to return the same clientid4 value is a necessary, though not a sufficient condition for them to be considered as connected to the same server. As a result, when two different IP addresses return the same clientid4, the client needs to determine, using the procedure given below or otherwise, whether the IP addresses are connected to the same server. For such clients, all internal recording of clientid4 values needs to include, whether explicitly or implicitly, identification of the server from which the clientid4 was received so that one always has a (server, clientid4) pair. Two such pairs from different servers are always considered distinct even when the clientid4 values are the same, as they may occasionally be.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じサーバーに接続されているとして、彼らのためではない十分条件が考慮されるものの2つの異なるIPアドレスが同じclientid4値を返すためには、必要です。二つの異なるIPアドレスが同じclientid4を返す場合、結果として、クライアントは、IPアドレスが同じサーバに接続されているかどうか、以下か、そうでなければ指定された手順を使用して、決定する必要があります。そのようなクライアントのために、clientid4値のすべての内部記録かどうかを明示的または暗黙的に含む必要があり、その一つは常に（サーバ、clientid4）ペアを有するようclientid4を受信したサーバの識別。 clientid4値が同じであっても、彼らは時折かもしれとして異なるサーバからの二つのそのようなペアは常に、明確な考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to make this approach work, the client must have certain information accessible for each nfs_client_id4 used by the uniform approach (only one in general). The client needs to maintain a list of all server IP addresses, together with the associated clientid4 values, SETCLIENTID principals, and authentication flavors. As a part of the associated data structures, there should be the ability to mark a server IP structure as having the same server as another and to mark an IP address as currently unresolved. One way to do this is to allow each such entry to point to another with the pointer value being one of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアプローチの作品を作るために、クライアントは、均一なアプローチ（一般的には一つだけ）で使用される各nfs_client_id4のためにアクセス特定の情報を持っている必要があります。クライアントは、一緒に関連するclientid4値、SETCLIENTIDプリンシパル、および認証タイプで、すべてのサーバーのIPアドレスのリストを維持する必要があります。関連するデータ構造の一部として、別のと同じサーバを有するものとしてサーバIP構造をマークするために、現在未解決のようなIPアドレスをマークする能力がなければなりません。これを行う1つの方法は、ポインタ値の一つであると別の点への各そのようなエントリを可能にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A pointer to another entry for an IP address associated with the same server, where that IP address is the first one referenced to access that server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのIPアドレスがそのサーバにアクセスするために参照される最初のものであり、同一のサーバに関連付けられたIPアドレスのための別のエントリへのポインタO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A pointer to the current entry if there is no earlier IP address associated with the same server, i.e., where the current IP address is the first one referenced to access that server. The text below refers to such an IP address as the lead IP address for a given server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O現在のIPアドレスがそのサーバにアクセスするために参照される最初のものであり、同一のサーバ、すなわち、関連付けられた以前のIPアドレスが存在しない場合、現在のエントリへのポインタ。下のテキストは、特定のサーバー用のリードIPアドレスなどのIPアドレスを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value NULL if the address&#39;s server identity is currently unresolved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アドレスのサーバーIDが現在未解決である場合、値NULL O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to keep the above information current, in the interests of the most effective trunking determination, RENEWs should be periodically done on each server. However, even if this is not done, the primary purpose of the trunking determination algorithm, to prevent confusion due to trunking hidden from the client, will be achieved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の情報を最新に保つために、最も効果的なトランキング決定の利益のために、更新は定期的に各サーバー上で実行する必要があります。しかし、これを行わない場合であっても、トランキング決定アルゴリズムの主な目的は、原因クライアントから隠さトランキングに混乱を防ぐために、達成されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given this apparatus, when a SETCLIENTID is done and a clientid4 returned, the data structure can be searched for a matching clientid4 and if such is found, further processing can be done to determine whether the clientid4 match is accidental, or the result of trunking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDが行われclientid4が返され、この装置は、所与のデータ構造は、マッチングclientid4を検索することができ、そのようなが見つかった場合、さらなる処理がclientid4マッチが偶発的、またはトランキングの結果であるかどうかを決定するために行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this algorithm, when SETCLIENTID is done initially, it will use the common nfs_client_id4 and specify the current target IP address as callback.cb_location within the callback parameters. We call the clientid4 and SETCLIENTID verifier returned by this operation XC and XV, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムでは、SETCLIENTIDが最初に行われたときに、それは共通nfs_client_id4を使用すると、コールバックパラメータの範囲内callback.cb_locationとして現在のターゲットIPアドレスを指定します。私たちは、それぞれ、この操作XCとXVによって返さclientid4とSETCLIENTID検証を呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This choice of callback parameters is provisional and reflects the client&#39;s preferences in the event that the IP address is not trunked with other IP addresses. The algorithm is constructed so that only the appropriate callback parameters, reflecting observed trunking patterns, are actually confirmed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックパラメータのこの選択は暫定で、IPアドレスは、他のIPアドレスとトランク接続されていない場合で、クライアントの好みを反映しています。観察されたトランキングパターンを反映のみ適切なコールバックパラメータは、実際に確認されるように、アルゴリズムが構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when the client has done previous SETCLIENTIDs to any IP addresses, with more than one principal or authentication flavor, one has the possibility of receiving NFS4ERR_CLID_INUSE, since it is not yet known which of the connections with existing IP addresses might be trunked with the current one. In the event that the SETCLIENTID fails with NFS4ERR_CLID_INUSE, one must try all other combinations of principals and authentication flavors currently in use, and eventually one will be correct and not return NFS4ERR_CLID_INUSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが複数の元本または認証味で、任意のIPアドレスに以前SETCLIENTIDsを行っているとき、まだとトランク接続されるかもしれない既存のIPアドレスとの接続のどの知られていないので、1は、NFS4ERR_CLID_INUSEを受ける可能性があることに注意してください現在1。 SETCLIENTIDはNFS4ERR_CLID_INUSEで障害が発生した場合、1は、現在使用中のプリンシパルと認証味の他のすべての組み合わせを試す必要があり、最終的には1が正しいだろうとNFS4ERR_CLID_INUSEを返しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that at this point, no SETCLIENTID_CONFIRM has yet been done. This is because the SETCLIENTID just done has either established a new clientid4 on a previously unknown server or changed the callback parameters on a clientid4 associated with some already known server. Given it is undesirable to confirm something that should not happen, what is to be done next depends on information about existing clientid4s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点では、何のSETCLIENTID_CONFIRMはまだ行われていないことに注意してください。ちょうど行わSETCLIENTIDは、以前に未知のサーバー上に新しいclientid4を確立したり、いくつかの既知のサーバーに関連付けられているclientid4にコールバックパラメータを変更したいずれかのためです。それは起こるべきではありません、何かを確認することは望ましくない考えると、次の行わ既存clientid4sの情報に依存するようにするものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If no matching clientid4 is found, the IP address X and clientid4 XC are added to the list and considered as having no existing known IP addresses trunked with it. The IP address is marked as a lead IP address for a new server. A SETCLIENTID_CONFIRM is done using XC and XV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一致するclientid4が見つからない場合、O、IPアドレスXとclientid4 XCは、リストに追加し、それを既存の既知のIPアドレストランクを持たないと考えられます。 IPアドレスは新しいサーバー用のリードIPアドレスとしてマークされています。 SETCLIENTID_CONFIRMはXCとXVを使用して行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a matching clientid4 is found that is marked unresolved, processing on the new IP address is suspended. In order to simplify processing, there can only be one unresolved IP address for any given clientid4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oのマッチングclientid4が未解決マークされていることを発見された場合、新しいIPアドレス上の処理が中断されます。処理を簡単にするために、唯一の任意のclientid4のための1つの未解決のIPアドレスが存在することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If one or more matching clientid4s are found, none of which are marked unresolved, the new IP address X is entered and marked unresolved. A SETCLIENTID_CONFIRM is done to X using XC and XV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O一つ以上のマッチングclientid4sが未解決マークされているいずれも、検出された場合、新しいIPアドレスXを入力して未解決マークされています。 SETCLIENTID_CONFIRMはXCとXVを使用してXに行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When, as a result of encountering the last of the three cases shown above, an unresolved IP address exists, further processing is required. After applying the steps below to each of the lead IP addresses with a matching clientid4, the address will have been resolved: It may have been determined to be part of an already known server as a new IP address to be added to an existing set of IP addresses for that server. Otherwise, it will be recognized as a new server. At the point at which this determination is made, the unresolved indication is cleared and any suspended SETCLIENTID processing is restarted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未解決のIPアドレスが存在する場合、上記に示した3例の最後に遭遇した結果として、さらなる処理が必要です。一致clientid4とリードIPアドレスのそれぞれに、以下の手順を適用した後、アドレスが解決されています：新しいIPアドレスは、既存のセットに追加するように、既に知られているサーバの一部であることが決定されている可能性がありIPは、そのサーバのアドレス。それ以外の場合は、新しいサーバとして認識されます。この決意がなされた時点で、未解決の表示がクリアされ、任意の中断SETCLIENTID処理が再開されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each lead IP address IPn with a clientid4 matching XC, the following steps are done. Because the Remote Procedure Call (RPC) to do a SETCLIENTID could take considerable time, it is desirable for the client to perform these operations in parallel. Note that because the clientid4 is a 64-bit value, the number of such IP addresses that would need to be tested is expected to be quite small, even when the client is interacting with many NFSv4.0 servers. Thus, while parallel processing is desirable, it is not necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XCに一致clientid4と各リードIPアドレスのIPnについては、以下のステップが実行されます。 SETCLIENTIDを行うためのリモートプロシージャコール（RPC）はかなりの時間がかかる可能性があるため、クライアントが並行してこれらの操作を実行することが望ましいです。 clientid4は、64ビットの値であるので、テストする必要があるだろう、このようなIPアドレスの数は、クライアントが多くNFSv4.0サーバと対話している場合でも、非常に小さくなることが期待されていることに注意してください。並列処理が望ましいつつ、それは必要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the principal for IPn does not match that for X, the IP address is skipped, since it is impossible for IPn and X to be trunked in these circumstances. If the principal does match but the authentication flavor does not, the authentication flavor already used should be used for address X as well. This will avoid any possibility that NFS4ERR_CLID_INUSE will be returned for the SETCLIENTID and SETCLIENTID_CONFIRM to be done below, as long as the server(s) at IP addresses IPn and X is correctly implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPnの主はX用のものと一致しない場合のIPnとXがこのような状況でトランク接続することが不可能であるため、O、IPアドレスは、スキップされます。プリンシパルが一致していますが、認証の味がしない場合は、既に使用されている認証の風味は、同様にアドレスXを使用する必要があります。これはNFS4ERR_CLID_INUSEは限りIPのサーバ（複数可）のIPnに対処し、Xが正しく実装されたとして、以下行われるSETCLIENTIDとSETCLIENTID_CONFIRMのために返される可能性を避けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A SETCLIENTID is done to update the callback parameters to reflect the possibility that X will be marked as associated with the server whose lead IP address is IPn. The specific callback parameters chosen, in terms of cb_client4 and callback_ident, are up to the client and should reflect its preferences as to callback handling for the common clientid4, in the event that X and IPn are trunked together. When a SETCLIENTID is done on IP address IPn, a setclientid_confirm value (in the form of a verifier4) is returned, which will be referred to as SCn.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SETCLIENTIDは、そのリードIPアドレスのIPnあるサーバーに関連付けられているように、Xがマークされます可能性を反映するために、コールバックパラメータを更新するために行われます。 cb_client4とcallback_identの面で、選択した特定のコールバックパラメータは、クライアント次第であり、XとのIPnが一緒にトランク接続されている場合には、共通clientid4ため取り扱いcallbackにとしての好みを反映すべきです。 SETCLIENTIDは、IPアドレスのIPnで行われる場合、（verifier4の形で）SETCLIENTID_CONFIRM値はSCnにと称する、戻されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that the NFSv4.0 specification requires the server to make sure that such verifiers are very unlikely to be regenerated. Given that it is already highly unlikely that the clientid4 XC is duplicated by distinct servers, the probability that SCn is duplicated as well has to be considered vanishingly small. Note also that the callback update procedure can be repeated multiple times to reduce the probability of further spurious matches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFSv4.0仕様は、このような検証を再生するために非常にそうにないことを確認するためにサーバーが必要であることに注意してください。すでにclientid4のXCが別個のサーバで重複している可能性はほとんどありませんことを考えると、SCNは同様に重複していている確率は無視できるほど小さいと考えられます。コールバックの更新手順は、さらにスプリアスマッチの確率を低減するために複数回繰り返すことができることにも注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The setclientid_confirm value SCn is saved for later use in confirming the SETCLIENTID done to IPn.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID_CONFIRM値oをSCNがのIPnに行わSETCLIENTIDを確認して、後で使用するために保存されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the SCn values are gathered up by the procedure above, they are each tested by being used as the verifier for a SETCLIENTID_CONFIRM operation directed to the original IP address X, whose trunking relationships are to be determined. These RPC operations may be done in parallel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCN値は、上記の手順でまとめられると、それらは、それぞれ、そのトランク関係が決定されるべき元のIPアドレスXに向けSETCLIENTID_CONFIRM動作のための検証として使用されることによってテストされます。これらのRPC操作が並行して行われてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of things that should be noted at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で注意しなければならない事柄がいくつかあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The SETCLIENTID operations done on the various IPn addresses in the procedure above will never be confirmed by SETCLIENTID_CONFIRM operations directed to the various IPn addresses. If these callback updates are to be confirmed, they will be confirmed by SETCLIENTID_CONFIRM operations directed at the original IP address X, which can only happen if SCn was generated by an IPn that was trunked with X, allowing the SETCLIENTID to be successfully confirmed and allowing us to infer the existence of that trunking relationship.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の手順で様々なのIPNアドレスで行わO SETCLIENTID操作は、各種のIPNアドレスに向けSETCLIENTID_CONFIRM操作によって確認されることはありません。これらのコールバックの更新を確認する場合、彼らは化SCNはSETCLIENTIDを正常に確認することが可能とできるように、Xとトランク接続したことのIPnによって生成された場合にのみ発生する可能性があり、元のIPアドレスX、に向けSETCLIENTID_CONFIRM操作によって確認されます私たちは、そのトランク関係の存在を推測します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The number of successful SETCLIENTID_CONFIRM operations done should never be more than one. If both SCn and SCm are accepted by X, then it indicates that both IPn and IPm are trunked with X, but that is only possible if IPn and IPm are trunked together. Since these two addresses were earlier recognized as not trunked together, this should be impossible, if the servers in question are implemented correctly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O行わ成功SETCLIENTID_CONFIRM操作の数は、複数であってはなりません。電極SCnとしSCm双方がXによって受け入れられる場合、それはのIPnとIPMの両方がXとトランクであることを示しているが、のIPnとIPMが一緒にトランク接続されている場合にのみ可能です。これら2つのアドレスが、以前一緒にトランクされていないと認識したので、当該サーバが正しく実装されている場合、これは、不可能でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Further processing depends on the success or failure of the various SETCLIENTD_CONFIRM operations done in the step above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更なる処理は、上記ステップで行う各種SETCLIENTD_CONFIRM操作の成功または失敗に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the setclientid_confirm value generated by a particular IPn is accepted on X, then X and IPn are recognized as connected to the same server, and the entry for X is marked as associated with IPn.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O特定のIPnによって生成SETCLIENTID_CONFIRM値がXに受け入れられている場合、XとのIPnは、同じサーバーに接続として認識され、そしてのIPnに関連付けられたとしてXのエントリがマークされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If none of the confirm operations are accepted, then X is recognized as a distinct server. Its callback parameters will remain as the ones established by the original SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認操作のどれも受け入れられていない場合、O、次いでXは、別個のサーバとして認識されます。そのコールバックパラメータは、元のSETCLIENTIDによって確立されたものとして残ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In either of the cases, the entry is considered resolved and processing can be restarted for IP addresses whose clientid4 matched XC but whose resolution had been deferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらの場合にも、エントリは解決とみなされ、処理は、そのclientid4一致XCが、その解像度延期されていたIPアドレスのために再起動することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedure described above must be performed so as to exclude the possibility that multiple SETCLIENTIDs done to different server IP addresses and returning the same clientid4 might &#34;race&#34; in such a fashion that there is no explicit determination of whether they correspond to the same server. The following possibilities for serialization are all valid, and implementers may choose among them based on a tradeoff between performance and complexity. They are listed in order of increasing parallelism:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数SETCLIENTIDsは異なるサーバーIPアドレスに行う可能性を排除し、それらが同一のサーバに対応するかどうかの明示的な決意が存在しないような様式で同じclientid4かもしれない「レース」を返すように、上述の手順を実行しなければなりません。直列化のための以下の可能性がすべて有効であり、実装者は、性能と複雑さとの間のトレードオフに基づいて、それらの間で選択することができます。彼らは増加し、並列処理の順にリストされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An NFSv4.0 client might serialize all instances of SETCLIENTID/ SETCLIENTID_CONFIRM processing, either directly or by serializing mount operations involving use of NFSv4.0. While doing so will prevent the races mentioned above, this degree of serialization can cause performance issues when there is a high volume of mount operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O NFSv4.0のクライアントは、直接またはNFSv4.0の使用を伴うマウント操作をシリアル化することで、SETCLIENTID / SETCLIENTID_CONFIRM処理のすべてのインスタンスをシリアライズすることがあります。そうすることが、上記のレースを防ぎますが、マウント操作の高いボリュームがある場合に、シリアライズのこの度は、パフォーマンスの問題を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o One might instead serialize the period of processing that begins when the clientid4 received from the server is processed and ends when all trunking determination for that server is completed. This prevents the races mentioned above, without adding to delay except when trunking determination is common.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O一つは、代わりに、サーバから受信clientid4が処理されるときに開始され、そのサーバーのすべてのトランキング決意が完了したときに終了処理の期間をシリアライズ可能性があります。この判定をトランキングすることが一般的である場合を除いて遅延させるために添加することなく、上述したレースを防止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o One might avoid much of the serialization implied above, by allowing trunking determination for distinct clientid4 values to happen in parallel, with serialization of trunking determination happening independently for each distinct clientid4 value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O一つは、それぞれ別個clientid4値に対して独立起こっ決意トランキングのシリアライゼーションと、並行して発生する異なるclientid4値のトランキング決意を可能にすることによって、上記暗示シリアライゼーションの多くを回避するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedure above has made no explicit mention of the possibility that server reboot can occur at any time. To address this possibility, the client should make sure the following steps are taken:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の手順は、サーバーの再起動はいつでも発生する可能性の明示的な言及がなされていません。この可能性に対処するために、クライアントは、次の手順がとられていることを確認しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a SETCLIENTID_CONFIRM is rejected by a given IPn, the client should be aware of the possibility that the rejection is due to XC (rather than XV) being invalid. This situation can be addressed by doing a RENEW specifying XC directed to the IP address X. If that operation succeeds, then the rejection is to be acted on normally since either XV is invalid on IPn or XC has become invalid on IPn while it is valid on X, showing that IPn and X are not trunked. If, on the other hand, XC is not valid on X, then the trunking detection process should be restarted once a new client ID is established on X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID_CONFIRMが与えられたのIPnによって拒否された場合には、O、クライアントは拒絶が無効であるXC（というよりもXV）によるものである可能性に注意する必要があります。この状況は、その操作が成功した場合のIPアドレスXに向けRENEW指定XCを行うことによって対処することができ、その後、拒否のいずれかXVは、それが有効な間のIPnに無効になったのIPnまたはXC上無効であるため、通常の作用を受けることがありますX上で、のIPnとXがトランク接続されないことを示しています。一方、XCはX上で有効でない場合、新しいクライアントIDがX上で確立されると、その後、トランキング検出プロセスを再起動する必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the event of a reboot detected on any server-lead IP, the set of IP addresses associated with the server should not change, and state should be re-established for the lease as a whole, using all available connected server IP addresses. It is prudent to verify connectivity by doing a RENEW using the new clientid4 on each such server address before using it, however.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意のサーバリードIP上で検出された再起動の場合には、サーバに関連付けられたIPアドレスのセットは変更されないO、および状態は、利用可能なすべての接続されたサーバのIPアドレスを使用して、全体としてリースのために再確立されなければなりません。しかし、それを使用する前に、このような各サーバーのアドレスに新しいclientid4を使用してRENEW実行して接続を確認するのが賢明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another situation not discussed explicitly above is the possibility that a SETCLIENTID done to one of the IPn addresses might take so long that it is necessary to time out the operation, to prevent unacceptably delaying the MOUNT operation. One simple possibility is to simply fail the MOUNT at this point. Because the average number of IP addresses that might have to be tested is quite small, this will not greatly increase the probability of MOUNT failure. Other possible approaches are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の状況は、上記で明示的に説明されていない、許容できないほどMOUNT操作を遅らせないようにするSETCLIENTIDはそれが操作アウト時に必要であると時間がかかる可能性があるのIPNアドレスの1つに行われている可能性があります。一つの簡単な可能性は、単にこの時点でMOUNTに失敗することです。テストする必要がある場合がありますIPアドレスの平均数は非常に小さいので、これは非常にMOUNT失敗の確率を高めることはありません。他の可能なアプローチは、以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the IPn has sufficient state in existence, the existing stateids and sequence values might be validated by being used on IP address X. In the event of success, X and IPn should be considered trunked together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPnが存在し、十分な状態を持っている場合は、既存のstateidsおよびシーケンス値が成功した場合にはIPアドレスXに使用されていることによって検証される可能性がありますO、XとのIPnが一緒にトランク接続を考慮すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
What constitutes &#34;sufficient&#34; state in this context is an implementation decision that is affected by the implementer&#39;s willingness to fail the MOUNT in an uncertain case and the strength of the state verification procedure implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
何この文脈で「十分な」状態を構成することは不確実な場合、実装状態の検証手順の強さにMOUNTを失敗する実装の意欲に影響され、実装決定です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If IPn has no locking state in existence, X could be recorded as a lead IP address on a provisional basis, subject to trunking being tested again, once IPn starts becoming responsive. To avoid confusion between IPn and X, and the need to merge distinct state corpora for X and IPn at a later point, this retest of trunking should occur after RENEWs on IPn are responded to and before establishing any new state for either IPn as a separate server or for IPn considered as a server address trunked with X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPnは存在にはロック状態を持っていない場合は、O、XはのIPnが応答になって開始されると、再びテストされているトランキングの対象に、暫定的にリードIPアドレスとして記録することができます。 IPnの更新をすると、別としてのIPnのいずれかのために任意の新しい状態を確立する前に、応答された後のIPnとX、および後の時点でXとのIPnのための明確な状態コーパスをマージする必要があるとの混同を避けるために、トランキングのこの再試験が行われるべきサーバーまたはのIPnのためには、Xとサーバアドレストランキングとして考え
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client locking-related code could be made more tolerant of what would otherwise be considered anomalous results due to an unrecognized trunking relationship. The client could use the appearance of behavior explainable by a previously unknown trunking relationship as the cue to consider the addresses as trunked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのロック関連コードoをそれ以外の原因認識されていないトランキングの関係に異常な結果と考えられるものの、より寛容作ることができます。クライアントは、トランキングとしてアドレスを検討する手がかりとして、以前に未知のトランキングの関係によって説明できる行動の外観を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This choice has a lot of complexity associated with it, and it is likely that few implementations will use it. When the set of locking state on IPn is small (e.g., a single stateid) but not empty, most client implementations are likely to either fail the MOUNT or implement a more stringent verification procedure using the existing stateid on IPn as a basis to generate further state as raw material for the trunking verification process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この選択は、それに関連する複雑さをたくさん持っている、そしていくつかの実装がそれを使用する可能性があります。 IPnに状態をロックのセットが小さい場合（例えば、単一のstateid）が、空ではない、ほとんどのクライアントの実装は、MOUNTに失敗したり、さらに生成するための基礎としてのIPn上の既存のstateidを使用して、より厳格な検証手順を実行するのいずれかに可能性がありますトランキング検証プロセスの原料としての状態。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9. Client ID String Construction Details
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9. クライアントIDの文字列建設詳細
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section gives more detailed guidance on client ID string construction. The guidance in this section will cover cases in which either the uniform or the non-uniform approach to the client ID string is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、クライアントのID文字列の構築に関する詳細なガイダンスを提供します。このセクションのガイダンスは、均一またはクライアントIDの文字列への不均一なアプローチのいずれかが使用されているケースをカバーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that among the items suggested for inclusion, there are many that may conceivably change. In order for the client ID string to remain valid in such circumstances, the client SHOULD either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
含めるための提案項目の中で、おそらく変更される可能性があり、その多くがあることに注意してください。このような状況で有効なままにするクライアントのID文字列のためには、クライアントSHOULDのいずれか：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Use a saved copy of such value rather than the changeable value itself, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oではなく、変更値そのものよりも、そのような値の保存されたコピーを使用しますか、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Save the constructed client ID string rather than constructing it anew at SETCLIENTID time, based on unchangeable parameters and saved copies of changeable data items.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O不変のパラメータと変更データ項目の保存されたコピーに基づいて、SETCLIENTID時に改めてそれを構築するのではなく、構築されたクライアントIDの文字列を保存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A file is not always a valid choice to store such information, given the existence of diskless clients. In such situations, whatever facilities exist for a client to store configuration information such as boot arguments should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルには、ディスクレスクライアントの存在を与えられ、常にそのような情報を格納するための有効な選択肢ではありません。このようブート引数などの施設がストアの構成情報へのクライアントのために存在するものは何でも、このような状況では、使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the considerations listed in Section 5.2.1, an id string would be one that includes as its basis:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5.2.1項に記載されている注意事項を考えると、id文字列は、その基礎として含むもので、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An identifier uniquely associated with the node on which the client is running.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一意にクライアントが実行されているノードに関連付けられた識別子O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For a user-level NFSv4.0 client, it should contain additional information to distinguish the client from a kernel-based client and from other user-level clients running on the same node, such as a universally unique identifier (UUID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OユーザーレベルNFSv4.0のクライアントのためには、カーネルベースのクライアントからこのような汎用一意識別子（UUID）と同じノードで実行されている他のユーザーレベルのクライアントからクライアントを区別するために付加的な情報を含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Where the non-uniform approach is to be used, the IP address of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O不均一なアプローチは、使用するサーバーのIPアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Additional information that tends to be unique, such as one or more of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようの一つ以上のように、ユニークになりがちO追加情報：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The timestamp of when the NFSv4 software was first installed on the client (though this is subject to the previously mentioned caution about using information that is stored in a file, because the file might only be accessible over NFSv4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
*（ファイルのみのNFSv4経由でアクセス可能であるかもしれないので、これはファイルに格納された情報を、使用について前述の注意の対象となるが）NFSv4のソフトウェアが最初のクライアントにインストールしたときのタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* A true random number, generally established once and saved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
*真の乱数、一般的に一度確立されて保存。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With regard to the identifier associated with the node on which the client is running, the following possibilities are likely candidates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが実行されているノードに関連した識別子に関して、以下の可能性がありそうな候補です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client machine&#39;s serial number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント・マシンのシリアル番号、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s IP address. Note that this SHOULD be treated as a changeable value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのIPアドレス、O。これは可変値として扱われるべきであることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A Media Access Control (MAC) address. Note that this also should be considered a changeable value because of the possibility of configuration changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メディアアクセス制御（MAC）アドレス、O。これはまたための構成変更の可能性の変化値を考慮すべきであることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Privacy concerns may be an issue if some of the items above (e.g., machine serial number and MAC address) are used. When it is necessary to use such items to ensure uniqueness, application of a one-way hash function is desirable. When the non-uniform approach is used, that hash function should be applied to all of the components chosen as a unit rather than to particular individual elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（例えば、機械シリアル番号とMACアドレス）上記項目の一部が使用される場合、プライバシーの懸念が問題であってもよいです。それは一意性を保証するために、そのようなアイテムを使用する必要がある場合に、一方向ハッシュ関数の適用が望ましいです。不均一なアプローチが使用される場合、そのハッシュ関数は、ユニットとしてではなく、特定の個々の要素に選択されたすべてのコンポーネントに適用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Locking and Multi-Server Namespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.ロックとマルチサーバーの名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a replacement for Section 9.14 of [RFC7530], &#34;Migration, Replication, and State&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、[RFC7530]、「移行、レプリケーション、および国家」のセクション9.14の交換が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The replacement is in Section 6.1 and supersedes the replaced section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
交換は、セクション6.1であり、交換セクションに取って代わります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The changes made can be briefly summarized as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように行われた変更を簡単に要約することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Adding text to address the case of stateid conflict on migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイグレーション上のstateid矛盾する場合に対処するためのテキストを追加O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Specifying that when leases are moved, as a result of file system migration, they are to be merged with leases on the destination server that are connected to the same client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースが移動されたときにことを指定するO、ファイルシステムの移行の結果として、彼らは同じクライアントに接続されている先のサーバー上のリースと合併することになっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Adding text that deals with the case of a clientid4 being changed on state transfer as a result of conflict with an existing clientid4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid4の場合を扱うテキストの追加O既存clientid4との競合の結果としての状態の伝達に変更されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Adding a section describing how information associated with open-owners and lock-owners is to be managed with regard to migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oオープン所有者およびロック所有者に関連する情報は、移行に関して管理する方法を説明するセクションを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The description of handling of the NFS4ERR_LEASE_MOVED has been rewritten for greater clarity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O NFS4ERR_LEASE_MOVEDの取り扱いの説明がより明確にするために書き直されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Lock State and File System Transitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. システム移行の状態をロックし、ファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
File systems may transition to a different server in several circumstances:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムは、いくつかの状況では別のサーバーに移行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Responsibility for handling a given file system is transferred to a new server via migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O指定したファイルシステムを扱うための責任は、移行を経て、新しいサーバーに転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A client may choose to use an alternate server (e.g., in response to server unresponsiveness) in the context of file system replication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントは、ファイルシステムレプリケーションのコンテキストで（サーバ不応答に応じて、例えば）代替サーバーを使用することを選択することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In such cases, the appropriate handling of state shared between the client and server (i.e., locks, leases, stateids, and client IDs) is as described below. The handling differs between migration and replication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような場合には、状態の適切な取り扱いは、クライアントとサーバー（即ち、ロック、リース、のstateids、及びクライアントID）の間で共有以下に記載の通りです。取り扱いは、移行と複製の間で異なっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server replica or a server immigrating a file system agrees to, or is expected to, accept opaque values from the client that originated from another server, then it is a wise implementation practice for the servers to encode the &#34;opaque&#34; values in network byte order (i.e., in a big-endian format). When doing so, servers acting as replicas or immigrating file systems will be able to parse values like stateids, directory cookies, filehandles, etc., even if their native byte order is different from that of other servers cooperating in the replication and migration of the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの複製またはファイルシステムを移住サーバがすることに同意し、または、別のサーバーから発信クライアントからの不透明な値を受け入れることが予想される場合、それはサーバーがネットワークに「不透明」の値を符号化するための賢明な実装の練習ですバイトオーダー（すなわち、ビッグエンディアン形式で）。その際、レプリカや移住のファイルシステムとして動作するサーバーは、ネイティブのバイト順序は、レプリケーションに協力し、他のサーバーとは異なるとの移行であっても、その他のstateids、ディレクトリクッキー、ファイルハンドル、のような値を解析することができるようになりますファイルシステム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. Migration and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. 移行と国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of migration, the servers involved in the migration of a file system should transfer all server state associated with the migrating file system from source to the destination server. If state is transferred, this MUST be done in a way that is transparent to the client. This state transfer will ease the client&#39;s transition when a file system migration occurs. If the servers are successful in transferring all state, the client will continue to use stateids assigned by the original server. Therefore, the new server must recognize these stateids as valid and treat them as representing the same locks as they did on the source server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行の場合には、ファイルシステムのマイグレーションに関与するサーバは、宛先サーバへのソースからの移行ファイルシステムに関連付けられているすべてのサーバの状態を転送しなければなりません。状態が転送された場合、これはクライアントに対して透過的な方法で行う必要があります。ファイルシステムの移行が発生したときに、この状態転送は、クライアントの移行を容易にします。サーバはすべての状態を転送することに成功している場合、クライアントは元のサーバーによって割り当てられたのstateidsを使用し続けます。そのため、新しいサーバーは有効なものとしてこれらのstateidsを認識し、それらがソースサーバ上でやったのと同じロックを表すものとして扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this context, the phrase &#34;the same locks&#34; means that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文脈では、語句「同じロック」は、その意味します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o They are associated with the same file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oこれらは同じファイルに関連付けされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o They represent the same types of locks, whether opens, delegations, advisory byte-range locks, or mandatory byte-range locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれらは、代表団、アドバイザリーバイト範囲ロック、または必須のバイト範囲ロックを開くかどうか、ロックの同じタイプを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o They have the same lock particulars, including such things as access modes, deny modes, and byte ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O彼らは、アクセスモード、モードを否定し、バイト範囲のようなものを含む、同じロックの詳細を、持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o They are associated with the same owner string(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれらは同一の所有者文字列（複数可）に関連しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If transferring stateids from server to server would result in a conflict for an existing stateid for the destination server with the existing client, transparent state migration MUST NOT happen for that client. Servers participating in using transparent state migration should coordinate their stateid assignment policies to make this situation unlikely or impossible. The means by which this might be done, like all of the inter-server interactions for migration, are not specified by the NFS version 4.0 protocol (neither in [RFC7530] nor this update).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバにサーバからのstateidsを転送すると、既存のクライアントと送信先サーバのための既存のstateidのための紛争につながる場合は、透明状態の移行は、そのクライアントのために起こるなりません。透明状態の移行を使用して参加するサーバーは、この状況がそうか不可能にするために彼らのstateid割り当てポリシーを調整する必要があります。この移行のためのサーバ間の相互作用のすべてのように行われるかもしれないれる手段は、NFSバージョン4.0プロトコル（いずれも[RFC7530]にもこの更新）によって指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may determine the disposition of migrated state by using a stateid associated with the migrated state on the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、新しいサーバー上の移行状態に関連付けられたstateidを使用して移行状態の処分を決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the stateid is not valid and an error NFS4ERR_BAD_STATEID is received, either transparent state migration has not occurred or the state was purged due to a mismatch in the verifier (i.e., the boot instance id).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oのstateidが有効でないとエラーNFS4ERR_BAD_STATEIDが原因検証のミスマッチ（すなわち、ブート・インスタンスID）と、受信されたいずれかの透明状態の移行が発生していない、または状態をパージした場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the stateid is valid, transparent state migration has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidが有効な場合、O、透明状態の移行が発生しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since responsibility for an entire file system is transferred with a migration event, there is no possibility that conflicts will arise on the destination server as a result of the transfer of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステム全体の責任を移行イベントに転送されるため、競合がロックの転送の結果としての宛先サーバに生じてしまうことはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The servers may choose not to transfer the state information upon migration. However, this choice is discouraged, except where specific issues such as stateid conflicts make it necessary. When a server implements migration and it does not transfer state information, it MUST provide a file-system-specific grace period, to allow clients to reclaim locks associated with files in the migrated file system. If it did not do so, clients would have to re-obtain locks, with no assurance that a conflicting lock was not granted after the file system was migrated and before the lock was re-obtained.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、移行時に状態情報を転送しないこともできます。しかし、この選択は、このようなのstateidの競合などの特定の問題は、それが必要で作る場合を除いて、落胆しています。サーバー移行を実装し、それが状態情報を転送しない場合は、クライアントは、移行ファイルシステム内のファイルに関連付けられたロックを再利用できるようにするために、ファイル・システム固有の猶予期間を提供しなければなりません。それはそうしなかった場合、クライアントは、ファイルシステムが移行された後、ロックが再取得される前に、競合するロックが許可されていないことを保証し、再取得しロックする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of migration without state transfer, when the client presents state information from the original server (e.g., in a RENEW operation or a READ operation of zero length), the client must be prepared to receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_BAD_STATEID from the new server. The client should then recover its state information as it normally would in response to a server failure. The new server must take care to allow for the recovery of state information as it would in the event of server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、元のサーバからの状態情報を提示する場合、状態転送せずに移動する場合には、（例えば、RENEW操作またはゼロ長のREAD動作で）、クライアントは、新しいサーバーからNFS4ERR_STALE_CLIENTID又はNFS4ERR_BAD_STATEIDいずれかを受けるように準備されなければなりません。それは通常、サーバーの障害に応じて同じように、クライアントは、その状態情報を復元する必要があります。新しいサーバーは、サーバーの再起動のイベントと同じように状態情報の復旧を可能にするように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In those situations in which state has not been transferred, as shown by a return of NFS4ERR_BAD_STATEID, the client may attempt to reclaim locks in order to take advantage of cases in which the destination server has set up a file-system-specific grace period in support of the migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_STATEIDの復帰によって示されているような状態は、転送されなかったような状況では、クライアントは、接続先サーバがファイル・システム固有の猶予期間中に設定していたに例を利用するためにロックを再要求することを試みることができます移行のサポート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1.1. Migration and Client IDs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1.1。移行とクライアントのID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handling of clientid4 values is similar to that for stateids. However, there are some differences that derive from the fact that a clientid4 is an object that spans multiple file systems while a stateid is inherently limited to a single file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid4値の処理はのstateidsのためのものと同様です。しかし、clientid4はのstateidは、本質的に単一のファイルシステムに制限されている間、複数のファイルシステムにまたがるオブジェクトであるという事実から派生するいくつかの違いがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The clientid4 and nfs_client_id4 information (id string and boot instance id) will be transferred with the rest of the state information, and the destination server should use that information to determine appropriate clientid4 handling. Although the destination server may make state stored under an existing lease available under the clientid4 used on the source server, the client should not assume that this is always so. In particular,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid4とnfs_client_id4情報（ID列とブートインスタンスID）は、状態情報の残りの部分で転送され、宛先サーバが適切なclientid4処理を決定するためにその情報を使用すべきです。先のサーバが状態はソースサーバ上で使用clientid4下で利用可能な既存のリースの下に格納させることがありますが、クライアントはこれがそう常にであることを仮定するべきではありません。特に、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is an existing lease with an nfs_client_id4 that matches a migrated lease (same id string and verifier), the server SHOULD merge the two, making the union of the sets of stateids available under the clientid4 for the existing lease. As part of the lease merger, the expiration time of the lease will reflect renewal done within either of the ancestor leases (and so will reflect the latest of the renewals).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイグレーションリース（同じID列とベリファイア）と一致nfs_client_id4有する既存のリースが存在する場合、O、サーバは、既存のリースのclientid4下のstateidsのセットの組合を利用できるよう、両者をマージすべきです。リースの合併の一環として、リースの有効期限は、先祖リースのいずれかの内で行わ更新を反映します（ので、更新の最新情報を反映します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is an existing lease with an nfs_client_id4 that partially matches a migrated lease (same id string and a different (boot) verifier), the server MUST eliminate one of the two, possibly invalidating one of the ancestor clientid4s. Since boot instance ids are not ordered, the later lease renewal time will prevail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
部分的に移行されたリース（同じID文字列と異なる（ブート）検証者）と一致nfs_client_id4有する既存のリースが存在する場合、O、サーバは、おそらく祖先clientid4sのいずれかを無効化、二つのうちの一つを排除しなければなりません。ブートインスタンスIDが注文されていないので、後のリース更新時間が優先されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the destination server already has the transferred clientid4 in use for another purpose, it is free to substitute a different clientid4 and associate that with the transferred nfs_client_id4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先サーバがすでに別の目的のために使用されて転送さclientid4を持っている場合は、O、その転送nfs_client_id4と異なるclientid4と関連付けるで代用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When leases are not merged, the transfer of state should result in creation of a confirmed client record with empty callback information but matching the {v, x, c} with v and x derived from the transferred client information and c chosen by the destination server. For a description of this notation, see Section 8.4.5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースがマージされていない場合、状態の転送は、空のコールバック情報を確認したクライアントレコードが作成されるが、必要がありマッチング{V、X、C}宛先サーバによって選択された転送されたクライアント情報及びC由来のVおよびXと。この表記法の説明については、8.4.5項を参照してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In such cases, the client SHOULD re-establish new callback information with the new server as soon as possible, according to sequences described in sections &#34;Operation 35: SETCLIENTID -- Negotiate Client ID&#34; and &#34;Operation 36: SETCLIENTID_CONFIRM -- Confirm Client ID&#34;. This ensures that server operations are not delayed due to an inability to recall delegations and prevents the unwanted revocation of existing delegations. The client can determine the new clientid4 (the value c) from the response to SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような場合には、クライアントはセクションで説明するシーケンスに従って、できるだけ早く新しいサーバーで新しいコールバック情報を再確立しなければならない「操作35：SETCLIENTID  - クライアントIDをネゴシエート」と「運用36：SETCLIENTID_CONFIRMを - クライアントIDを確認してください」。これは、サーバーの操作が原因の代表団を思い出すことができないことに遅れていないことを保証し、既存の代表団の不要な失効を防ぐことができます。クライアントはSETCLIENTIDへの応答から新しいclientid4（値c）を決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can use its own information about leases with the destination server to see if lease merger should have happened. When there is any ambiguity, the client MAY use the above procedure to set the proper callback information and find out, as part of the process, the correct value of its clientid4 with respect to the server in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、リースの合併が起こっている必要がありますかどうかを確認するために、宛先サーバーとのリースに関する独自の情報を使用することができます。すべての曖昧さがある場合、クライアントは、プロセスの一部として、適切なコールバック情報を設定し、見つけるために、問題のサーバーに関するそのclientid4の正しい値を上記の手順を使用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1.2. Migration and State Owner Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1.2。移行と国家所有者情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to stateids, the locks they represent, and client identity information, servers also need to transfer information related to the current status of open-owners and lock-owners.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateids、それらが表すロック、およびクライアントの識別情報に加えて、サーバは、オープン・オーナーとロック所有者の現在の状況に関連した情報を転送する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This information includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この情報が含まれています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The sequence number of the last operation associated with the particular owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の所有者に関連付けられた最後の操作のシーケンス番号O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Sufficient information regarding the results of the last operation to allow reissued operations to be correctly responded to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O最後の操作の結果に関する十分な情報が再発行の操作が正しくに対応することができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When individual open-owners and lock-owners have only been used in connection with a particular file system, the server SHOULD transfer this information together with the lock state. The owner ceases to exist on the source server and is reconstituted on the destination server. This will happen in the case of clients that have been written to isolate each owner to a specific file system, but it may happen for other clients as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個別のオープン所有者やロック所有者は、特定のファイルシステムに関連して使用されている場合は、サーバがロック状態と一緒にこの情報を転送する必要があります。所有者は、ソースサーバ上に存在しなくなると、宛先サーバに再構成されています。これは、特定のファイルシステムに、それぞれの所有者を隔離するために書かれているクライアントの場合に起こりますが、それは、他のクライアントのために起こるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when servers take this approach for all owners whose state is limited to the particular file system being migrated, doing so will not cause difficulties for clients not adhering to an approach in which owners are isolated to particular file systems. As long as the client recognizes the loss of transferred state, the protocol allows the owner in question to disappear, and the client may have to deal with an owner confirmation request that would not have occurred in the absence of the migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは状態特定のファイルシステムに制限されている移行されるすべての所有者のために、このアプローチを取るとき、そうすることが、クライアントは所有者が特定のファイルシステムに隔離されているアプローチに付着していないために困難を生じさせないことに注意してください。限り、クライアントが転送状態の損失を認識するように、プロトコルは、問題の所有者が消えることを可能にする、そしてクライアントは、移行が存在しない場合に発生していないだろう、所有者の確認要求に対処する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When migration occurs and the source server discovers an owner whose state includes the migrated file system but other file systems as well, it cannot transfer the associated owner state. Instead, the existing owner state stays in place, but propagation of owner state is done as specified below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイグレーションが発生し、ソース・サーバーは、その状態も移行されたファイルシステムが、他のファイルシステムを含む所有者を発見すると、それは、関連所有者の状態を転送することはできません。代わりに、既存の所有者の状態が所定の位置に残りますが、以下の指定された所有者の状態の伝播が行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the current seqid for an owner represents an operation associated with the file system being migrated, owner status SHOULD be propagated to the destination file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者の現在SEQIDが移行されるファイルシステムに関連する操作を表すとき、O、所有者ステータスは、目的ファイルシステムに伝播されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the current seqid for an owner does not represent an operation associated with the file system being migrated, owner status MAY be propagated to the destination file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者の現在SEQIDが移行されるファイルシステムに関連付けられた動作を表していない場合には、O、所有者ステータスは、目的ファイルシステムに伝播されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the owner in question has never been used for an operation involving the migrated file system, the owner information SHOULD NOT be propagated to the destination file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題の所有者が移行されたファイルシステムを含む演算に使用されていない場合には、O、所有者情報は、宛先ファイルシステムに伝播されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that a server may obey all of the conditions above without the overhead of keeping track of a set of file systems that any particular owner has been associated with. Consider a situation in which the source server has decided to keep lock-related state associated with a file system fixed, preparatory to propagating it to the destination file system. If a client is free to create new locks associated with existing owners on other file systems, the owner information may be propagated to the destination file system, even though, at the time the file system migration is recognized by the client to have occurred, the last operation associated with the owner may not be associated with the migrating file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、特定の所有者に関連付けられているファイルシステムのセットのトラックを維持するオーバーヘッドなしに上記の条件のすべてに従うことができることに留意されたいです。ソースサーバは、先のファイルシステムにそれを伝播する準備固定ファイルシステムに関連付けられたロック関連の状態を維持することを決定した状況を考えてみましょう。クライアントは、他のファイルシステム上の既存の所有者に関連付けられた新しいロックを作成して自由である場合は、所有者情報は、一度ファイルシステムの移行が発生したために、クライアントによって認識されていても、かかわらず、先のファイルシステムに伝播することができます所有者に関連付けられた最後の操作は、移行ファイルシステムに関連しなくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a source server propagates owner-related state associated with owners that span multiple file systems, it will propagate the owner sequence value to the destination server, while retaining it on the source server, as long as there exists state associated with the owner. When owner information is propagated in this way, source and destination servers start with the same owner sequence value that is then updated independently, as the client makes owner-related requests to the servers. Note that each server will have some period in which the associated sequence value for an owner is identical to the one transferred as part of migration. At those times, when a server receives a request with a matching owner sequence value, it MUST NOT respond with the associated stored response if the associated file system is not, when the reissued request is received, part of the set of file systems handled by that server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースサーバは複数のファイルシステムにまたがる所有者に関連付けられた所有者に関連する状態を伝搬する際に限り、所有者に関連付けられている状態が存在するように、ソースサーバ上に保持しながら、それは、宛先サーバへの所有者シーケンス値を伝播します。所有者情報がこのように伝播される場合には、送信元と送信先のサーバーは、クライアントがサーバーへの所有者に関連する要求を行うのように、独立して更新されているのと同じ所有者のシーケンス値で始まります。各サーバが所有者に関連付けられたシーケンス値がマイグレーションの一部として転送ものと同じであるいくつかの期間を有するであろうことに留意されたいです。関連付けられたファイルシステムは、再発行要求を受信したとき、で扱うファイルシステムのセットの一部でない場合、サーバは、一致する所有者シーケンス値を持つリクエストを受信するもの回で、それが関連する記憶された応答で応答してはいけませんそのサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One sort of case may require more complex handling. When multiple file systems are migrated, in sequence, to a specific destination server, an owner may be migrated to a destination server, on which it was already present, leading to the issue of how the resident owner information and that being newly migrated are to be reconciled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例一つの並べ替えは、より複雑な処理を必要とするかもしれません。複数のファイルシステムが移行される場合には、順番に、特定の宛先サーバに、所有者は、それがすでに存在していた上でどのように住民所有者情報の問題につながる、先サーバーに移行することができるし、新たに移行されていることにあります仲直りします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If file system migration encounters a situation where owner information needs to be merged, it MAY decline to transfer such state, even if it chooses to handle other cases in which locks for a given owner are spread among multiple file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの移行は、所有者情報をマージする必要のある状況に遭遇した場合、それは特定の所有者のためにロックが複数のファイルシステムに分散されている他の例を処理することを選択した場合でも、このような状態を転送するために低下する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a way of understanding the situations that need to be addressed when owner information needs to be merged, consider the following scenario:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者情報をマージする必要がある場合に対処する必要がある状況を理解する方法として、次のシナリオを検討してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is client C and two servers, X and Y. There are two clientid4s designating C, which are referred to as CX and CY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O CXとCYと呼ばれているCを指定する2 clientid4sがありますが、クライアントCと二つのサーバ、XとYがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Initially, server X supports file systems F1, F2, F3, and F4. These will be migrated, one at a time, to server Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O当初、サーバXは、ファイルシステムF1、F2、F3、およびF4をサポートしています。これらは、サーバYに、一度に1つずつ移行されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o While these migrations are proceeding, the client makes locking requests for file systems F1 through F4 on behalf of owner O (either a lock-owner or an open-owner), with each request going to X or Y depending on where the relevant file system is being supported at the time the request is made.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの移行が進行している間、クライアントは、各要求は、該当する場合、ファイルに応じてXまたはYに行くと、所有者O（いずれかのロック所有者またはオープン所有者）に代わって、F4を介してファイルシステムF1の要求をロックすることができるoをシステムは、要求が行われた時点ではサポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Once the first migration event occurs, client C will maintain two instances for owner O, one for each server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の移行イベントが発生すると、O、クライアントCは、所有者O、各サーバに対して1つのための2つのインスタンスを維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is always possible that C may make a request of server X relating to owner O, and before receiving a response, it finds the target file system has moved to Y and needs to reissue the request to server Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OはCがX所有者Oに関連するサーバの要求を行うことができ、応答を受信する前に、それがターゲット・ファイル・システムがYに移動し、サーバYに要求を再発行する必要た見つけることは常に可能です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o At the same time, C may make a request of server Y relating to owner O, and this too may encounter a lost-response situation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同時に、O、Cは、オーナーOに関連するサーバYの要求を行うことができ、これはあまりにも失われた応答状況が発生することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result of such merger situations, the server will need to provide support for dealing with retransmission of owner-sequenced requests that diverge from the typical model in which there is support for retransmission of replies only for a request whose sequence value exactly matches the last one sent. In some situations, there may be two requests, each of which had the last sequence when it was issued. As a result of migration and owner merger, one of those will no longer be the last by sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような合併の状況の結果として、サーバーは応答の再送信のためのサポートは唯一、その配列値が正確に一致する最後の要求のためにそこにある、典型的なモデルから発散する所有者順の要求の再送信に対処するためのサポートを提供する必要があります。送信された1。いくつかの状況では、それが発行された時に最後のシーケンスを持っていたそれぞれの2つの要求があってもよいです。移行と所有者の合併の結果として、それらの一つは、もはやシーケンスで最後になることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When servers do support such merger of owner information on the destination server, the following rules are to be adhered to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが送信先サーバー上の所有者情報のこうした合併を支援実行すると、次の規則がに付着することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When an owner sequence value is propagated to a destination server where it already exists, the resulting sequence value is to be the greater of the one present on the destination server and the one being propagated as part of migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者シーケンス値は、それが既に存在している先のサーバに伝播されると、O、得られた配列値は、マイグレーションの一部として伝搬される宛先サーバと1つ上の一本の大きいことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the event that an owner sequence value on a server represents a request applying to a file system currently present on the server, it is not to be rendered invalid simply because that sequence value is changed as a result of owner information propagation as part of file system migration. Instead, it is retained until it can be deduced that the client in question has received the reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバ上の所有者シーケンス値が現在存在するサーバ上のファイルシステムに適用する要求を示し、それは、シーケンス値がの一部として所有者情報の伝播の結果として変更されたというだけの理由で無効とされるべきでない場合にはファイルシステムの移行。問題のクライアントが応答を受信したことを推測することができるまで、その代わりに、それが保持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result of the operation of these rules, there are three ways in which there can be more reply data than what is typically present, i.e., data for a single request per owner whose sequence is the last one received, where the next sequence to be used is one beyond that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのルールの動作の結果として、典型的に存在するものよりも多くの応答データが存在することができる3つの方法、シーケンスの最後の一つが受信された所有者ごとに単一の要求のために、すなわち、データ、次のシーケンスには存在し使用されるものを超えたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the owner sequence value for a migrating file system is greater than the corresponding value on the destination server, the last request for the owner in effect at the destination server needs to be retained, even though it is no longer one less than the next sequence to be received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイグレーションファイルシステムの所有者シーケンス値は、宛先サーバ上の対応する値よりも大きい場合には、O、宛先サーバで有効な所有者の最後の要求は、それがもはや次未満のものであるにも関わらず、保持する必要がありませんシーケンスが受信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the owner sequence value for a migrating file system is less than the corresponding value on the destination server, the sequence number for last request for the owner in effect on the migrating file system needs to be retained, even though it is no longer than one less the next sequence to be received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイグレーションファイルシステムの所有者シーケンス値は、宛先サーバ上の対応する値未満である場合、O、マイグレーションファイルシステムに有効な所有者の最後の要求のシーケンス番号は、それがもはやよりも、保持する必要がありません受信されるべき次のシーケンス1以下です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the owner sequence value for a migrating file system is equal to the corresponding value on the destination server, one has two different &#34;last&#34; requests that both must be retained. The next sequence value to be used is one beyond the sequence value shared by these two requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイグレーションファイルシステムの所有者シーケンス値は、宛先サーバ上の対応する値に等しいとき、O、一つは両方が保持されなければならない2つの異なる「最後」の要求を有しています。使用される次のシーケンス値は、これら2つの要求によって共有される配列値を超えたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here are some guidelines as to when servers can drop such additional reply data, which is created as part of owner information migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、サーバは、所有者情報の移行の一環として作成されたこのような追加の応答データを、ドロップすることができたときになど、いくつかのガイドラインがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server SHOULD NOT drop this information simply because it receives a new sequence value for the owner in question, since that request may have been issued before the client was aware of the migration event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、移行イベントの知っていた前に、その要求が発行されている可能性があるため、それは、問題の所有者のための新しいシーケンス値を受け取るので、Oサーバは、単にこの情報をドロップすべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server SHOULD drop this information if it receives a new sequence value for the owner in question, and the request relates to the same file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが問題の所有者のための新しいシーケンス値を受け取り、要求が同じファイルシステムに関連する場合、Oサーバは、この情報を削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server SHOULD drop the part of this information that relates to non-migrated file systems if it receives a new sequence value for the owner in question, and the request relates to a non-migrated file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは、それが問題の所有者のための新しいシーケンス値を受け取り、その要求は、非マイグレーション済みファイル・システムに関連する場合、非移行されたファイルシステムに関連するこの情報の一部を削除すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server MAY drop this information when it receives a new sequence value for the owner in question for a considerable period of time (more than one or two lease periods) after the migration occurs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、移行が発生した後の時間（1つのまたは2つ以上のリース期間）のかなりの期間、当該所有者のための新しいシーケンス値を受信したときに、Oサーバは、この情報を削除でき。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. Replication and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. レプリケーションと国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since client switch-over in the case of replication is not under server control, the handling of state is different. In this case, leases, stateids, and client IDs do not have validity across a transition from one server to another. The client must re-establish its locks on the new server. This can be compared to the re-establishment of locks by means of reclaim-type requests after a server reboot. The difference is that the server has no provision to distinguish requests reclaiming locks from those obtaining new locks or to defer the latter. Thus, a client re-establishing a lock on the new server (by means of a LOCK or OPEN request) may have the requests denied due to a conflicting lock. Since replication is intended for read-only use of file systems, such denial of locks should not pose large difficulties in practice. When an attempt to re-establish a lock on a new server is denied, the client should treat the situation as if its original lock had been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複製の場合のクライアントスイッチオーバーは、サーバーの管理下にはないので、状態の取り扱いが異なっています。この場合、リース、のstateids、およびクライアントIDは1サーバーから別のサーバーへの移行全体の妥当性を持っていません。クライアントは、新しいサーバー上のロックを再確立する必要があります。これは、サーバの再起動後に再利用型リクエストによってロックの再確立と比較することができます。違いは、サーバーがそれらの取得新しいロックからロックを再利用要求を区別するか、後者を延期することを想定していませんということです。このように、クライアントの再確立新しいサーバーのロックを（LOCKまたはOPENのリクエストによる）が競合ロックが原因で拒否されたリクエストを有することができます。複製は、ファイル・システムの読み取り専用の使用を意図しているので、ロックのように否定は実際には大きな困難をもたらすべきではありません。新しいサーバーにロックを再確立しようとする試みが拒否された場合は、元のロックが取り消されたかのように、クライアントは状況を扱うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3. Notification of Migrated Lease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3. 移行したリースの通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A file system can be migrated to another server while a client that has state related to that file system is not actively submitting requests to it. In this case, the migration is reported to the client during lease renewal. Lease renewal can occur either explicitly via a RENEW operation or implicitly when the client performs a lease-renewing operation on another file system on that server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのファイルシステムに関連する状態を持つクライアントが積極的に要求を提出していない間にファイルシステムが別のサーバに移行することができます。この場合、移行はリース更新時にクライアントに報告されます。リース更新が発生し、明示的にクライアントがそのサーバー上の別のファイルシステム上のリース更新操作を行うと、暗黙的に操作を更新するかを経由することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order for the client to schedule renewal of leases that may have been relocated to the new server, the client must find out about lease relocation before those leases expire. Similarly, when migration occurs but there has not been transparent state migration, the client needs to find out about the change soon enough to be able to reclaim the lock within the destination server&#39;s grace period. To accomplish this, all operations that implicitly renew leases for a client (such as OPEN, CLOSE, READ, WRITE, RENEW, LOCK, and others) will return the error NFS4ERR_LEASE_MOVED if responsibility for any of the leases to be renewed has been transferred to a new server. Note that when the transfer of responsibility leaves remaining state for that lease on the source server, the lease is renewed just as it would have been in the NFS4ERR_OK case, despite returning the error. The transfer of responsibility happens when the server receives a GETATTR(fs_locations) from the client for each file system for which a lease has been moved to a new server. Normally, it does this after receiving an NFS4ERR_MOVED for an access to the file system, but the server is not required to verify that this happens in order to terminate the return of NFS4ERR_LEASE_MOVED. By convention, the compounds containing GETATTR(fs_locations) SHOULD include an appended RENEW operation to permit the server to identify the client getting the information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのリース期限が切れる前に新しいサーバーに移転されている可能性がリースの更新をスケジュールするクライアントのために、クライアントは、リースの再配置を知る必要があります。移行が発生したが、透明状態の移行がなかった場合も同様に、クライアントは、接続先サーバーの猶予期間内にロックを再利用することができることはすぐに十分な変更を知る必要があります。更新するリースのいずれかの責任がに転送された場合は、これを達成するために、暗黙的に（例えばOPEN、CLOSE、READ、WRITE、RENEW、LOCK、および他のような）クライアントのリースを更新するすべての操作はエラーNFS4ERR_LEASE_MOVEDを返します。新しいサーバー。責任の転送は、ソースサーバ上のリースの状態を、残りの離れたとき、それはエラーを返すにもかかわらず、NFS4ERR_OKケースにされているのと同じように、リースが更新されることに注意してください。サーバがリースを新しいサーバーに移動された各ファイルシステムのクライアントからGETATTR（fs_位置）を受信したときの責任の転送が発生します。通常は、ファイルシステムにアクセスするためのNFS4ERR_MOVEDを受け取った後にこれを行いますが、サーバーは、これはNFS4ERR_LEASE_MOVEDのリターンを終了させるために起こっていることを確認する必要はありません。慣例により、GETATTR（fs_位置）を含む化合物は、情報を取得し、クライアントを識別するために、サーバーを許可する操作をRENEW追加含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the NFS4ERR_LEASE_MOVED error is required only when responsibility for at least one stateid has been affected. In the case of a null lease, where the only associated state is a clientid4, an NFS4ERR_LEASE_MOVED error SHOULD NOT be generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LEASE_MOVEDエラーが少なくとも一つのstateidのために責任が影響を受けているときにのみ必要であることに注意してください。唯一の関連する状態はclientid4あるヌルリースの場合には、NFS4ERR_LEASE_MOVEDエラーが生成されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving the NFS4ERR_LEASE_MOVED error, a client that supports file system migration MUST perform the necessary GETATTR operation for each of the file systems containing state that have been migrated, so it gives the server evidence that it is aware of the migration of the file system. Once the client has done this for all migrated file systems on which the client holds state, the server MUST resume normal handling of stateful requests from that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、ファイルシステムの移行を認識していることをサーバー証拠を与えるようNFS4ERR_LEASE_MOVEDエラーを受信すると、ファイルシステムの移行をサポートしているクライアントは、移行された状態を含むファイル・システムごとに必要なGETATTR操作を実行しなければなりません。クライアントは、クライアントが状態を保持する上で移行されたすべてのファイルシステムに対してこれを行った後、サーバーはそのクライアントからステートフル要求の通常の取り扱いを再開しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One way in which clients can do this efficiently in the presence of large numbers of file systems is described below. This approach divides the process into two phases: one devoted to finding the migrated file systems, and the second devoted to doing the necessary GETATTRs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ファイル・システムの多数の存在下で、これを効率的に行うことが可能な一つの方法は、以下に説明します。このアプローチは、2つのフェーズにプロセスを分割：移行したファイルシステムを見つけることに専念1、および必要なGETATTRsをやって2番目の献身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can find the migrated file systems by building and issuing one or more COMPOUND requests, each consisting of a set of PUTFH/ GETFH pairs, each pair using a filehandle in one of the file systems in question. All such COMPOUND requests can be done in parallel. The successful completion of such a request indicates that none of the file systems interrogated have been migrated while termination with NFS4ERR_MOVED indicates that the file system getting the error has migrated while those interrogated before it in the same COMPOUND have not. Those whose interrogation follows the error remain in an uncertain state and can be interrogated by restarting the requests from after the point at which NFS4ERR_MOVED was returned or by issuing a new set of COMPOUND requests for the file systems that remain in an uncertain state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、問題のファイルシステムの1つにファイルハンドルを使用して、それぞれがPUTFH / GETFHペアのセットから成る、各ペアを1つまたはそれ以上の化合物の要求を構築し、発行することにより、移行ファイルシステムを見つけることができます。すべてのそのような化合物の要求を並行して行うことができます。そのような要求が正常に完了はNFS4ERR_MOVEDと終了が同一の化合物で、その前に尋問ものは持っていない間、エラーを取得して、ファイルシステムが移行したことを示しながら、尋問のファイルシステムのどれもが移行されていないことを示しています。その尋問エラーを次のものが不確かな状態のままとNFS4ERR_MOVEDが返された時点の後や不確定な状態のままファイルシステムのCOMPOUND要求の新しいセットを発行してから要求を再起動することによって調べることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the migrated file systems have been found, all that is needed is for the client to give evidence to the server that it is aware of the migrated status of file systems found by this process, by interrogating the fs_locations attribute for a filehandle within each of the migrated file systems. The client can do this by building and issuing one or more COMPOUND requests, each of which consists of a set of PUTFH operations, each followed by a GETATTR of the fs_locations attribute. A RENEW is necessary to enable the operations to be associated with the lease returning NFS4ERR_LEASE_MOVED. Once the client has done this for all migrated file systems on which the client holds state, the server will resume normal handling of stateful requests from that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行されたファイル・システムが必要とされていることすべてが、それはこのプロセスによって見つかったファイル・システムの移行状態を認識しているサーバーに証拠を与えるために、クライアントのためにある、発見されたら、fs_位置を問い合わせることによって、それぞれの中にファイルハンドルの属性移行されたファイルシステム。クライアントは、それぞれがfs_位置の属性のGETATTR、続いてPUTFH操作のセットで構成され、それぞれが一つ以上の化合物の要求を、構築し、発行してこれを行うことができます。 A RENEW NFS4ERR_LEASE_MOVEDを返すリースに関連付けられる操作を有効にする必要があります。クライアントは、クライアントが状態を保持する上で移行されたすべてのファイルシステムに対してこれを行った後、サーバーはそのクライアントからステートフル要求の通常の取り扱いを再開します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to support legacy clients that do not handle the NFS4ERR_LEASE_MOVED error correctly, the server SHOULD time out after a wait of at least two lease periods, at which time it will resume normal handling of stateful requests from all clients. If a client attempts to access the migrated files, the server MUST reply with NFS4ERR_MOVED. In this situation, it is likely that the client would find its lease expired, although a server may use &#34;courtesy&#34; locks (as described in Section 9.6.3.1 of [RFC7530]) to mitigate the issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正しくNFS4ERR_LEASE_MOVEDのエラーを処理していないレガシークライアントをサポートするために、サーバーは、それがすべてのクライアントからのリクエストのステートフルの通常の取り扱いを再開しますその時点で少なくとも二つのリース期間の待機後にタイムアウトすべきです。クライアントが移行されたファイルにアクセスしようとすると、サーバはNFS4ERR_MOVEDに返答しなければなりません。このような状況では、クライアントは、サーバーが問題を軽減するために、「礼儀」のロックを（[RFC7530]のセクション9.6.3.1で説明したように）使用することができますが、そのリースは、期限が切れ見つけるだろうと思われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client receives an NFS4ERR_MOVED error, the client can follow the normal process to obtain the destination server information (through the fs_locations attribute) and perform renewal of those leases on the new server. If the server has not had state transferred to it transparently, the client will receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server, as described above. The client can then recover state information as it does in the event of server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_MOVEDエラーを受信した場合、クライアントは、（fs_位置の属性で）先サーバの情報を取得するために、通常のプロセスに従うと、新しいサーバー上のリースの更新を行うことができます。サーバは状態が透過的に転送されなかった場合は、上記のように、クライアントは、新しいサーバーからNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_STALE_STATEIDのいずれかを受け取ることになります。それは、サーバーに障害が発生した場合に行うように、クライアントは、状態情報を復元することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Aside from recovering from a migration, there are other reasons a client may wish to retrieve fs_locations information from a server. When a server becomes unresponsive, for example, a client may use cached fs_locations data to discover an alternate server hosting the same file system data. A client may periodically request fs_locations data from a server in order to keep its cache of fs_locations data fresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別に移行からの回復から、クライアントがサーバからfs_位置情報を取得することを望むかもしれない他の理由があります。サーバーが応答しなくなった場合、例えば、クライアントが同じファイル・システム・データをホスティングする代替サーバを発見するためにキャッシュされたfs_位置データを使用することができます。クライアントは、定期的に新鮮なfs_位置データのキャッシュを維持するために、サーバからfs_位置データを要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since a GETATTR(fs_locations) operation would be used for refreshing cached fs_locations data, a server could mistake such a request as indicating recognition of an NFS4ERR_LEASE_MOVED condition. Therefore, a compound that is not intended to signal that a client has recognized a migrated lease SHOULD be prefixed with a guard operation that fails with NFS4ERR_MOVED if the filehandle being queried is no longer present on the server. The guard can be as simple as a GETFH operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTR（fs_位置）操作は、キャッシュされたfs_位置データをリフレッシュするために使用されるので、サーバはNFS4ERR_LEASE_MOVED状態の認識を示すものとして、そのような要求を間違える可能性があります。そのため、クライアントは移行リースを認識していることを知らせるために意図されていない化合物が照会されるファイルハンドルがサーバー上存在しなくなった場合NFS4ERR_MOVEDで失敗しないガード操作で始めなければなりません。ガードはGETFH動作ほどシンプルにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Though unlikely, it is possible that the target of such a compound could be migrated in the time after the guard operation is executed on the server but before the GETATTR(fs_locations) operation is encountered. When a client issues a GETATTR(fs_locations) operation as part of a compound not intended to signal recognition of a migrated lease, it SHOULD be prepared to process fs_locations data in the reply that shows the current location of the file system is gone.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そうけれども、ガード操作がサーバー上ではなく、GETATTR（fs_位置）操作が検出される前に実行された後に、このような化合物のターゲットは、時間内に移行される可能性があります。クライアントは、マイグレーションリースの認識をシグナリングすることを意図していない化合物の一部としてGETATTR（fs_位置）オペレーションを発行するときは、ファイルシステムの現在位置がなくなっていることを示す応答でfs_位置データを処理するために準備されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.4. Migration and the lease_time Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.4. 移行とlease_time属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order that the client may appropriately manage its leases in the case of migration, the destination server must establish proper values for the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが適切に移行した場合にそのリースを管理できるように、送信先サーバーはlease_time属性の適切な値を確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When state is transferred transparently, that state should include the correct value of the lease_time attribute. The lease_time attribute on the destination server must never be less than that on the source since this would result in premature expiration of leases granted by the source server. Upon migration in which state is transferred transparently, the client is under no obligation to refetch the lease_time attribute and may continue to use the value previously fetched (on the source server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態が透過的に転送されると、その状態はlease_time属性の正しい値を含むべきです。これは、ソースサーバによって付与されたリースの早期満了ことになるので、先サーバー上のlease_time属性は、ソース上のそれよりも少ないにすることはできません。マイグレーション時に透過的に転送された状態で、クライアントはlease_time属性を再フェッチし、（ソースサーバ上の）以前にフェッチされた値を使用し続けるかもしれない義務です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case in which lease merger occurs as part of state transfer, the lease_time attribute of the destination lease remains in effect. The client can simply renew that lease with its existing lease_time attribute. State in the source lease is renewed at the time of transfer so that it cannot expire, as long as the destination lease is appropriately renewed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リース合併状態転送の一部として発生した場合には、先のリースのlease_time属性が有効なまま。クライアントは、単に既存のlease_time属性でそのリースを更新することができます。それは有効期限が切れないように、先のリースが適切に更新されるように、ソース・リース状態が長いと、転送時に更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If state has not been transferred transparently (i.e., the client needs to reclaim or re-obtain its locks), the client should fetch the value of lease_time on the new (i.e., destination) server, and use it for subsequent locking requests. However, the server must respect a grace period at least as long as the lease_time on the source server, in order to ensure that clients have ample time to reclaim their locks before potentially conflicting non-reclaimed locks are granted. The means by which the new server obtains the value of lease_time on the old server is left to the server implementations. It is not specified by the NFS version 4.0 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態（すなわち、クライアントが再利用又はそのロックを再取得する必要がある）透過的に転送されていない場合、クライアントは、新しい（すなわち、宛先）サーバ上lease_timeの値を取得し、その後のロック要求のためにそれを使用すべきです。ただし、サーバは潜在的に競合非埋立ロックが付与される前に、クライアントがロックを取り戻すために十分な時間を持っていることを確実にするためには、少なくとも限り、ソースサーバー上のlease_timeとして、猶予期間を尊重しなければなりません。新しいサーバーは、古いサーバー上lease_timeの値を取得する手段は、サーバの実装に任されています。これは、NFSバージョン4.0のプロトコルによって指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Server Implementation Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.サーバの実装に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides suggestions to help server implementers deal with issues involved in the transparent transfer of file-system-related data between servers. Servers are not obliged to follow these suggestions but should be sure that their approach to the issues handle all the potential problems addressed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、サーバー間でファイル・システム関連のデータの透過転送にかかわる問題でサーバの実装の契約を支援するための提案を提供します。サーバはこれらの提案に従う義務はありませんが、問題へのアプローチは、すべての潜在的な問題は、以下の対処扱うことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
7.1. Relation of Locking State Transfer to Other Aspects of File System Motion
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
7.1. ファイルシステムの運動の他の態様にロック状態転送の関係
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In many cases, state transfer will be part of a larger function wherein the contents of a file system are transferred from server to server. Although specifics will vary with the implementation, the relation between the transfer of persistent file data and metadata and the transfer of state will typically be described by one of the cases below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの場合、状態転送は、ファイルシステムの内容がサーバからサーバに転送される、より大きな機能の一部となります。詳細は実装に応じて変化するが、永続ファイルデータとメタデータの転送および状態の転送との間の関係は、典型的には、以下のいずれかの場合に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In some implementations, access to the on-disk contents of a file system can be transferred from server to server by making the storage devices on which the file system resides physically accessible from multiple servers, and transferring the right and responsibility for handling that file system from server to server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oいくつかの実装では、ファイルシステムのディスク上のコンテンツへのアクセスは、ファイルシステムが複数のサーバから物理的にアクセス常駐しているストレージ・デバイスを作成し、そのファイルを処理するための権利と責任を転送することにより、サーバーへのサーバーから転送することができますサーバからサーバへのシステム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In such implementations, the transfer of locking state happens on its own, as described in Section 7.2. The transfer of physical access to the file system happens after the locking state is transferred and before any subsequent access to the file system. In cases where such transfer is not instantaneous, there will be a period in which all operations on the file system are held off, either by having the operations themselves return NFS4ERR_DELAY or, where this is not allowed, by using the techniques described below in Section 7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
セクション7.2で説明したようにそのような実装では、ロック状態の転送は、独自に起こります。ロック状態が転送され、ファイルシステムへのその後のアクセスの前にされた後、ファイルシステムへの物理的アクセスの転送が起こります。そのような転送は、瞬時でない場合には、ファイルシステム上のすべての操作は、いずれかのセクションで以下に記載された技術を用いて、それ自体は、これが許可されていない場合、NFS4ERR_DELAYを返すまたは動作を有することにより、オフ保持されている期間が存在することになります7.2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In other implementations, file system data and metadata must be copied from the server where they have existed to the destination server. Because of the typical amounts of data involved, it is generally not practical to hold off access to the file system while this transfer is going on. Normal access to the file system, including modifying operations, will generally happen while the transfer is going on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O他の実装では、ファイルシステムのデータとメタデータは、それらが先サーバーに存在していたサーバーからコピーする必要があります。この転送が起こっている間ので、関連するデータの典型的な量の、ファイルシステムへのアクセスをオフに保持するために、一般的には実用的ではありません。転送が起こっている間に変更する操作を含むファイルシステムへの通常のアクセスは、一般的に起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Eventually, the file system copying process will complete. At this point, there will be two valid copies of the file system, one on each of the source and destination servers. Servers may maintain that state of affairs by making sure that each modification to file system data is done on both the source and destination servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
最終的には、ファイルシステムのコピー処理が完了します。この時点で、ファイルシステムの2つの有効なコピーを、送信元と送信先のサーバに1つずつ存在します。サーバーは、ファイル・システム・データへの各変更は、送信元と送信先サーバーの両方で行われていることを確認することで事務のその状態を維持することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Although the transfer of locking state can begin before the above state of affairs is reached, servers will often wait until it is arrived at to begin transfer of locking state. Once the transfer of locking state is completed, as described in the section below, clients may be notified of the migration event and access the destination file system on the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
事務のこの状態に到達する前に、ロック状態の転送を開始することもできますが、状態をロックの転送を開始するために到着するまで、サーバは、多くの場合、待機します。ロック状態の転送が完了すると以下のセクションで説明したように、クライアントは、移行イベントの通知および宛先サーバにコピー先ファイルシステムにアクセスすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Another case in which file system data and metadata must be copied from server to server involves a variant of the pattern above. In cases in which a single file system moves between or among a small set of servers, it will transition to a server on which a previous instantiation of that same file system existed before. In such cases, it is often more efficient to update the previous file system instance to reflect changes made while the active file system was residing elsewhere rather than copying the file system data anew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oファイルシステムデータとメタデータがサーバにサーバからコピーする必要がある別の場合は、上記のパターンの変形を含みます。単一のファイルシステムは、サーバの小さなセット間、または間で移動する場合には、その同じファイルシステムの以前のインスタンス化の前に存在しているサーバーに移行します。このような場合には、多くの場合、アクティブファイルシステムは、他の場所に存在するのではなく、新たにファイル・システム・データをコピーしている間に行われた変更を反映するために、以前のファイル・システム・インスタンスを更新する方が効率的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In such cases, the copying of file system data and metadata is replaced by a process that validates each visible file system object, copying new objects and updating those that have changed since the file system was last present on the destination server. Although this process is generally shorter than a complete copy, it is generally long enough that it is not practical to hold off access to the file system while this update is going on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このような場合には、ファイル・システム・データおよびメタデータのコピーが各可視ファイル・システム・オブジェクトを検証するプロセスに置き換えられ、新しいオブジェクトをコピーし、ファイルシステム以降に変更されたものを更新する宛先サーバの最後に存在しました。このプロセスは完全なコピーよりも、一般的に短いですが、このアップデートが起こっている間、ファイルシステムへのアクセスをオフに保持することは現実的ではないことが一般的に十分な長さです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Eventually, the file system updating process will complete. At this point, there will be two valid copies of the file system, one on each of the source and destination servers. Servers may maintain that state of affairs just as is done in the previous case. Similarly, the transfer of locking state, once it is complete, allows the clients to be notified of the migration event and access the destination file system on the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
最終的には、ファイルシステムの更新処理が完了します。この時点で、ファイルシステムの2つの有効なコピーを、送信元と送信先のサーバに1つずつ存在します。前のケースで行われるようにサーバは単に事務のその状態を維持することができます。それが完了すると同様に、ロック状態の転送は、クライアントが移行イベントを通知し、宛先サーバにコピー先ファイルシステムにアクセスすることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Preventing Locking State Modification during Transfer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 転送中にロック状態変更の防止
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When transferring locking state from the source to a destination server, there will be occasions when the source server will need to prevent operations that modify the state being transferred. For example, if the locking state at time T is sent to the destination server, any state change that occurs on the source server after that time but before the file system transfer is made effective will mean that the state on the destination server will differ from that on the source server, which matches what the client would expect to see.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先サーバーにソースからロック状態を転送するときに、ソースサーバーが転送される状態を変更する操作を防止する必要がある場合には、機会があるだろう。時刻Tにおけるロック状態が宛先サーバに送信される場合、例えば、その時点の後であるが、ファイルシステムの転送前にソースサーバ上で発生するすべての状態の変更が有効とされている先のサーバ上の状態が異なるであろうことを意味しますクライアントが見ることを期待するものと一致するソースサーバ、上のこと。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, a server can prevent some set of server-maintained data from changing by returning NFS4ERR_DELAY on operations that attempt to change that data. In the case of locking state for NFSv4.0, there are two specific issues that might interfere:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的に、サーバは、そのデータを変更しようとする操作にNFS4ERR_DELAYを返すことによって変化からサーバ保守のデータのいくつかのセットを防止することができます。 NFSv4.0の状態をロックする場合、干渉する可能性のある2つの特定の問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Returning NFS4ERR_DELAY will not prevent state from changing in that owner-based sequence values will still change, even though NFS4ERR_DELAY is returned. For example, OPEN and LOCK will change state (in the form of owner seqid values) even when they return NFS4ERR_DELAY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DELAYを返すoをNFS4ERR_DELAYが返されても、まだ変更されている所有者ベースのシーケンス値に変化するから状態を防ぐことはできません。例えば、OPENとLOCKは、それらがNFS4ERR_DELAYを返すも（所有者SEQID値の形で）状態を変化させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Some operations that modify locking state are not allowed to return NFS4ERR_DELAY (i.e., OPEN_CONFIRM, RELEASE_LOCKOWNER, and RENEW).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O状態をロック修正一部の操作はNFS4ERR_DELAY（すなわち、オープン_CONFIRM、RELEASE_LOCKOWNER、及びRENEW）を返すことは許されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the first problem and most instances of the second can be addressed by returning NFS4ERR_DELAY on the operations that establish a filehandle within the target as one of the filehandles associated with the request, i.e., as either the current or saved filehandle. This would require returning NFS4ERR_DELAY under the following circumstances:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第一の問題点と第二のほとんどの場合は、いずれかの現在または保存されたファイルハンドルのように、すなわち、要求に関連付けられたファイルハンドルの一つとして、ターゲット内のファイルハンドルを確立する操作にNFS4ERR_DELAYを返すことによって対処することができることに留意されたいです。これは、次の状況下でNFS4ERR_DELAYを返す必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On a PUTFH that specifies a filehandle within the target file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲット・ファイル・システム内のファイルハンドルを指定しPUTFHオンO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On a LOOKUP or LOOKUPP that crosses into the target file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲット・ファイル・システムに交差LOOKUPまたはLOOKUPPでO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result of doing this, OPEN_CONFIRM is dealt with, leaving only RELEASE_LOCKOWNER and RENEW still to be dealt with.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これを実行した結果、オープン_CONFIRMだけRELEASE_LOCKOWNERを残し、に対処し、対処されることはまだRENEWされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the server establishes and maintains a situation in which no request has, as either the current or saved filehandle, a filehandle within the target file system, no special handling of SAVEFH or RESTOREFH is required. Thus, the fact that these operations cannot return NFS4ERR_DELAY is not a problem since neither will establish a filehandle in the target file system as the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが確立し、何の要求は、現在または保存されたファイルハンドル、ターゲット・ファイル・システム内のファイルハンドルのいずれかとし、持っていないような状況を維持している場合、SAVEFHまたはRESTOREFHの特別な処理が必要とされないことに注意してください。したがって、これらの操作はNFS4ERR_DELAY返すことができないという事実が問題ではないのでどちらも現在のファイルハンドルとしてターゲット・ファイル・システム内のファイルハンドルを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is to establish the situation described above, it may have to take special note of long-running requests that started before state migration. Part of any solution to this issue will involve distinguishing two separate points in time at which handling for the target file system will change. Let us distinguish:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、上記のような状況を確立することであるならば、それは状態の移行の前に開始した長時間実行要求の特別な注意を取らなければならないことがあります。この問題への解決策の一部は、ターゲット・ファイル・システムのため取り扱いが変更する時刻に2つの別々のポイントを区別伴います。私たちは区別してみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A time T after which the previously mentioned operations will return NFS4ERR_DELAY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述の動作はNFS4ERR_DELAYが返された後の時間T O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A later time T&#39; at which the server can consider file system locking state fixed, making it possible for it to be sent to the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは、それが可能それが宛先サーバに送信することができるようにすること、ファイル・システムのロック状態が固定考慮可能な後の時間T」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a server to decide on T&#39;, it must ensure that requests started before T cannot change target file system locking state, given that all those started after T are dealt with by returning NFS4ERR_DELAY upon setting filehandles within the target file system. Among the ways of doing this are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは「Tを決定するためには、TがT後に開始されたすべてのものはターゲット・ファイル・システム内のファイルハンドルを設定するとNFS4ERR_DELAYを返すことによって対処されることを考えると、状態のロック対象のファイルシステムを変更することはできません前に、要求が開始されていることを確認する必要があります。これを行う方法の中で、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Keeping track of the earliest request started that is still in execution (for example, by keeping a list of active requests ordered by request start time). Requests that started before and are still in progress at time T may potentially affect the locking state; once the starting time of the earliest-started active request is later than T, the starting time of the first such request can be chosen as T&#39; by the server since any request in progress after T&#39; started after time T. Accordingly, it would not have been allowed to change locking state for the migrating file system and would have returned NFS4ERR_DELAY had it tried to make a change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最も初期の要求のOキーピングトラックは、それが（例えば、要求開始時刻順アクティブな要求のリストを維持することによって）実行中である始めました。前に開始し、Tは、潜在的にロック状態に影響を与える可能性がある時点でまだ進行中である要求。最早開始アクティブ要求の開始時刻がTよりも後により時間T後に開始し、最初のそのような要求の開始時間は、「Tは後に進行中の要求ためサーバによって」Tとして選択することができ、それだろう移行ファイルシステムの状態をロック変更することが許可されているとNFS4ERR_DELAYが、それは変更を作ってみました戻っているだろうではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Keeping track of the count of requests started before time T that have a filehandle within the target file system as either the current or saved filehandle. The server can then define T&#39; to be the first time after T at which the count is zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求の数を追跡するoを、現在または保存されたファイルハンドルのいずれかのように、ターゲット・ファイル・システム内のファイルハンドルを持って、時間Tの前に開始しました。その後、サーバは、カウントがゼロであるT後の最初の時間であることをT」を定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of operations that change locking state include two that cannot be dealt with by the above approach, because they are not specific to a particular file system and do not use a current filehandle as an implicit parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック状態変更オペレーションのセットは、それらが特定のファイルシステムに固有のものではなく、暗黙のパラメータとして現在のファイルハンドルを使用しないため、上記の手法で対処することができない2が挙げられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENEW can be dealt with by applying the renewal to state for non-transitioning file systems. The effect of renewal for the transitioning file system can be ignored, as long as the servers make sure that the lease on the destination server has an expiration time that is no earlier than the latest renewal done on the source server. This can be easily accomplished by making the lease expiration on the destination server equal to the time in which the state transfer was completed plus the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RENEWは非移行ファイルシステムのための状態に更新を適用することで対処することができます。移行ファイルシステムのリニューアルの効果がある限り、サーバは、送信先サーバーのリースは、ソースサーバ上で行われた最新の更新よりも早い有効期限を持っていることを確認すると、無視することができます。これは簡単に状態の転送が完了した時間を加えたリース期間に等しい宛先サーバのリース期限を作ることによって達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELEASE_LOCKOWNER can be handled by propagating the fact of the lock-owner deletion (e.g., by using an RPC) to the destination server. Such a propagation RPC can be done as part of the operation, or the existence of the deletion can be recorded locally and propagation of owner deletions to the destination server done as a batch later. In either case, the actual deletions on the destination server have to be delayed until all of the other state information has been transferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入出力RELEASE_LOCKOWNERは、宛先サーバに（例えば、RPCを使用して）ロック所有者の削除の旨を伝播させることによって処理することができます。そのような伝搬RPCは、操作の一部として実行することができ、または欠失の存在をローカルに記録することができ、宛先サーバに所有者欠失の伝播は、後でバッチとして行います。いずれの場合も、宛先サーバ上の実際の欠失は、他の状態情報の全てが転送されるまで遅延されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Alternatively, RELEASE_LOCKOWNER can be dealt with by returning NFS4ERR_DELAY. In order to avoid compatibility issues for clients not prepared to accept NFS4ERR_DELAY in response to RELEASE_LOCKOWNER, care must be exercised. (See Section 8.3 for details.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
また、RELEASE_LOCKOWNERはNFS4ERR_DELAYを返すことで対処することができます。 RELEASE_LOCKOWNERに応じてNFS4ERR_DELAYを受け入れる準備ができていないクライアントのために互換性の問題を避けるために、注意が必要。 （詳細はセクション8.3を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The approach outlined above, wherein NFS4ERR_DELAY is returned based primarily on the use of current and saved filehandles in the file system, prevents all reference to the transitioning file system rather than limiting the delayed operations to those that change locking state on the transitioning file system. Because of this, servers may choose to limit the time during which this broad approach is used by adopting a layered approach to the issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DELAYは、主に現在の使用に基づいて戻され、ファイルシステム内のファイルハンドルを保存している上記で概説したアプローチは、すべての遷移のファイルシステムへの参照ではなく、遷移ファイルシステムにロック状態に変更するものに遅延操作を制限することを防止します。このため、サーバーは、この広範なアプローチは、問題への階層化アプローチを採用することにより、使用する時間を制限することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o During the preparatory phase, operations that change, create, or destroy locks or modify the valid set of stateids will return NFS4ERR_DELAY. During this phase, owner-associated seqids may change, and the identity of the file system associated with the last request for a given owner may change as well. Also, RELEASE_LOCKOWNER operations may be processed without returning NFS4ERR_DELAY as long as the fact of the lock-owner deletion is recorded locally for later transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの準備段階では、操作が変更、作成、またはロックを破壊したりNFS4ERR_DELAYを返しますのstateidsの有効なセットを変更すること。このフェーズでは、所有者に関連seqidsが変わることがあり、そして同様に変更することができる所定の所有者のための最後の要求に関連付けられたファイルシステムの識別。また、RELEASE_LOCKOWNER操作は、ロック所有者の削除の事実は、後の送信のためにローカルに記録されている限りNFS4ERR_DELAYを返さずに処理することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o During the restrictive phase, operations that change locking state for the file system in transition are prevented by returning NFS4ERR_DELAY on any attempt to make a filehandle within that file system either the current or saved filehandle for a request. RELEASE_LOCKOWNER operations may return NFS4ERR_DELAY, but if they are processed, the lock-owner deletion needs to be communicated immediately to the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O制限フェーズでは、移行中のファイルシステムの状態をロック変更する操作は、ファイルシステム内のファイルハンドル要求の現在または保存されたファイルハンドルのいずれかを作る試みにNFS4ERR_DELAYを返すことによって防止されます。 RELEASE_LOCKOWNER操作はNFS4ERR_DELAYを返すことがありますが、それらが処理される場合には、ロック所有者の削除が先サーバーに即座に伝達する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A possible sequence would be the following.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能なシーケンスは、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server enters the preparatory phase for the transitioning file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバーは、移行ファイルシステムのための準備段階に入ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o At this point, locking state, including stateids, locks, and owner strings, is transferred to the destination server. The seqids associated with owners are either not transferred or transferred on a provisional basis, subject to later change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点でのstateids、ロック、および所有者文字列を含む、状態をロックO、宛先サーバに転送されます。所有者に関連付けられseqidsは、いずれかの後変化を受け、仮基づいて転送または転送されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o After the above has been transferred, the server may enter the restrictive phase for the file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記転送された後、O、サーバは、ファイルシステムの制限相に入ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o At this point, the updated seqid values may be sent to the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で、O、更新SEQID値は、宛先サーバに送信されても​​よいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Reporting regarding pending owner deletions (as a result of RELEASE_LOCKOWNER operations) can be communicated at the same time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
保留中の所有者欠失（RELEASE_LOCKOWNER操作の結果として）について報告すると同時に通信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Once it is known that all of this information has been transferred to the destination server, and there are no pending RELEASE_LOCKOWNER notifications outstanding, the source server may treat the file system transition as having occurred and return NFS4ERR_MOVED when an attempt is made to access it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oこの情報のすべてが先サーバーに転送されてきた、そして卓越した保留中RELEASE_LOCKOWNER通知が存在しないことが知られると、ソースサーバが発生したとして、ファイルシステムの移行を扱うことと試みがそれにアクセスするためになされたときNFS4ERR_MOVEDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Additional Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.その他の変更点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains a number of items that relate to the changes in the section above, but which, for one reason or another, exist in different portions of the specification to be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、上のセクションの変化に関連するアイテムの数を含むが、何らかの理由で、更新される仕様の異なる部分に存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Summary of Additional Changes from Previous Documents
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 前のドキュメントからの追加変更の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Summarized here are all the remaining changes, not included in the two main sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ない2つのメインセクションに含まれ、残りのすべての変更は、ここに要約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o New definition of the error NFS4ERR_CLID_INUSE, appearing in Section 8.2. This replaces the definition in Section 13.1.10.1 in [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーNFS4ERR_CLID_INUSEの新しい定義O、8.2節に登場します。これは、[RFC7530]でセクション13.1.10.1での定義を置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A revision of the error definitions section to allow RELEASE_LOCKOWNER to return NFS4ERR_DELAY, with appropriate constraints to assure interoperability with clients not expecting this error to be returned. These changes are discussed in Section 8.2 and modify the error tables in Sections 13.2 and 13.4 in [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oエラー定義セクションの改正はRELEASE_LOCKOWNERは、クライアントが返されるこのエラーは期待していないとの相互運用性を確保するために適切な制約で、NFS4ERR_DELAYを返すことができるようにします。これらの変更は、8.2節で議論し、セクション13.2と13.4 [RFC7530]でエラーテーブルを変更しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A revised description of SETCLIENTID, appearing in Section 8.4. This brings the description into sync with the rest of the specification regarding NFS4ERR_CLID_INUSE. The revised description replaces the one in Section 16.33 of [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDの改定についてO、8.4節に登場します。これはNFS4ERR_CLID_INUSEに関する仕様の残りの部分との同期に説明をもたらします。改訂された説明は、[RFC7530]のセクション16.33で1を置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Some security-related changes appear in Sections 8.5 and 8.6. The Security Considerations section of this document (Section 9) describes the effect on the corresponding section (Section 19) in [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O一部のセキュリティ関連の変更は、セクション8.5と8.6に表示されます。この文書（第9）のセキュリティの考慮事項のセクションは[RFC7530]の対応するセクション（セクション19）に対する効果を記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. NFS4ERR_CLID_INUSE Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.  NFS4ERR_CLID_INUSE定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of this error is now as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにこのエラーの定義は以下のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The SETCLIENTID operation has found that the id string within the specified nfs_client_id4 was previously presented with a different principal and that client instance currently holds an active lease. A server MAY return this error if the same principal is used, but a change in authentication flavor gives good reason to reject the new SETCLIENTID operation as not bona fide.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SETCLIENTID操作は、指定されたnfs_client_id4内のID文字列が以前異なるプリンシパルを提示し、クライアントのインスタンスが現在アクティブなリースを保持していることがわかりました。同じプリンシパルが使用されている場合、サーバーは、このエラーが返されることがありますが、認証の味の変化はない正真正銘のような新しいSETCLIENTID操作を拒否するための良い理由を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. NFS4ERR_DELAY Return from RELEASE_LOCKOWNER
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.  RELEASE_LOCKOWNERからNFS4ERR_DELAY戻ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The existing error tables should be considered modified to allow NFS4ERR_DELAY to be returned by RELEASE_LOCKOWNER. However, the scope of this addition is limited and is not to be considered as making this error return generally acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のエラーテーブルはNFS4ERR_DELAYがRELEASE_LOCKOWNERで返すことができるように変更を考慮すべきです。しかしながら、この添加の範囲は限られており、このエラー復帰は、一般的に許容可能な製造と見なされるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It needs to be made clear that servers may not return this error to clients not prepared to support file system migration. Such clients may be following the error specifications in [RFC7530] and so might not expect NFS4ERR_DELAY to be returned on RELEASE_LOCKOWNER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、サーバは、ファイルシステムの移行をサポートするために用意されていないクライアントにこのエラーを返さないことを明らかにする必要があります。このようなクライアントは、[RFC7530]でエラーの仕様を以下することができるので、NFS4ERR_DELAYがRELEASE_LOCKOWNERに返されることを期待しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following constraint applies to this additional error return, as if it were a note appearing together with the newly allowed error code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、新たに許可されたエラーコードと一緒に登場するノートであるかのように、次の制約は、この追加のエラーリターンに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In order to make server state fixed for a file system being migrated, a server MAY return NFS4ERR_DELAY in response to a RELEASE_LOCKOWNER that will affect locking state being propagated to a destination server. The source server MUST NOT do so unless it is likely that it will later return NFS4ERR_MOVED for the file system in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバの状態が移行されるファイルシステムに固定させるためには、サーバが宛先サーバに伝播されているロック状態に影響を与えますRELEASE_LOCKOWNERに応じてNFS4ERR_DELAYを返すことがあります。後で問題のファイルシステムのためのNFS4ERR_MOVEDを返しれる可能性がある場合を除き、ソース・サーバーは、そうはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the context of lock-owner release, the set of file systems, such that server state being made fixed can result in NFS4ERR_DELAY, must include the file system on which the operation associated with the current lock-owner seqid was performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ロック所有者放出の文脈では、ファイルシステムのセットは、サーバ状態がNFS4ERR_DELAYをもたらすことができる固定行われように、現在のロック所有者SEQIDに関連付けられた動作が実行されたファイル・システムを含んでいなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In addition, this set may include other file systems on which an operation associated with an earlier seqid for the current lock-owner seqid was performed, since servers will have to deal with the issue of an owner being used in succession for multiple file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
また、このセットは、サーバが複数のファイルシステムのために連続して使用されている所有者の問題に対処する必要がありますので、現在のロック所有者SEQIDため、以前のSEQIDに関連した操作が、実行された他のファイルシステムを含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Thus, if a client is prepared to receive NFS4ERR_MOVED after creating state associated with a given file system, it also needs to be prepared to receive NFS4ERR_DELAY in response to RELEASE_LOCKOWNER, if it has used that owner in connection with a file on that file system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントが特定のファイルシステムに関連する状態を作成した後NFS4ERR_MOVEDを受け取るように準備される場合、それはまた、それがそのファイルシステム上のファイルとの関連で、その所有者を使用した場合、RELEASE_LOCKOWNERに応答しNFS4ERR_DELAYを受信するために用意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. Operation 35: SETCLIENTID -- Negotiate Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. 操作35：SETCLIENTID  - クライアントIDをネゴシエート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.1. SYNOPSIS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.1.  SYNOPSIS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
client, callback, callback_ident -&gt; clientid, setclientid_confirm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
クライアント、コールバック、callback_ident  - &gt;のClientID、SETCLIENTID_CONFIRM
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.2. 引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID4args {
           nfs_client_id4  client;
           cb_client4      callback;
           uint32_t        callback_ident;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.3. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.3. 結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID4resok {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SETCLIENTID4res switch (nfsstat4 status) {
    case NFS4_OK:
            SETCLIENTID4resok      resok4;
    case NFS4ERR_CLID_INUSE:
            clientaddr4    client_using;
   default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.4.  DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client uses the SETCLIENTID operation to notify the server of its intention to use a particular client identifier, callback, and callback_ident for subsequent requests that entail creating lock, share reservation, and delegation state on the server. Upon successful completion, the server will return a shorthand client ID that, if confirmed via a separate step, will be used in subsequent file locking and file open requests. Confirmation of the client ID must be done via the SETCLIENTID_CONFIRM operation to return the client ID and setclientid_confirm values, as verifiers, to the server. The reason why two verifiers are necessary is that it is possible to use SETCLIENTID and SETCLIENTID_CONFIRM to modify the callback and callback_ident information but not the shorthand client ID. In that event, the setclientid_confirm value is effectively the only verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバー上のロック、共有予約、および委任状態を作り出す伴う後続の要求のために、特定のクライアント識別子、コールバック、およびcallback_identを使用する意向をサーバに通知するためにSETCLIENTID操作を使用しています。正常に完了すると、サーバーは、別の工程を経て確認した場合、その後のファイルのロックに使用し、オープン要求を提出します速記クライアントのIDを返します。クライアントIDの確認は、サーバーに、検証として、クライアントIDとSETCLIENTID_CONFIRM値を返すためにSETCLIENTID_CONFIRM操作を介して行われなければなりません。 2つの検証が必要な理由は、コールバックとcallback_ident情報ではなく、速記、クライアントのIDを変更するSETCLIENTIDとSETCLIENTID_CONFIRMを使用することが可能であるということです。その場合には、SETCLIENTID_CONFIRM値は事実のみ検証です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback information provided in this operation will be used if the client is provided an open delegation at a future point. Therefore, the client must correctly reflect the program and port numbers for the callback program at the time SETCLIENTID is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、将来の時点で開いている委譲を提供する場合は、この操作で提供されるコールバック情報が使用されます。したがって、クライアントが正しくSETCLIENTIDが使用されている時にコールバックプログラムのためのプログラムとポート番号を反映しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback_ident value is used by the server on the callback. The client can leverage the callback_ident to eliminate the need for more than one callback RPC program number, while still being able to determine which server is initiating the callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
callback_ident値はコールバック上のサーバーで使用されています。クライアントはコールバックを開始しているサーバーを決定することが可能でありながら、複数のコールバックRPCプログラム番号の必要性を排除するためにcallback_identを活用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.5. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.5. 実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To specify the implementation of SETCLIENTID, the following notations are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDの実装を指定するには、次の表記が使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
してみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
x be the value of the client.id subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X SETCLIENTID4args構造のclient.idサブフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
v be the value of the client.verifier subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
V SETCLIENTID4args構造のclient.verifierサブフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c be the value of the client ID field returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID4resok構造で返されるクライアントIDフィールドの値をc。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
k represent the value combination of the callback and callback_ident fields of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kはSETCLIENTID4args構造のコールバックとcallback_identフィールドの値の組み合わせを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
s be the setclientid_confirm value returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S SETCLIENTID4resok構造体に返さSETCLIENTID_CONFIRM値で。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ v, x, c, k, s } be a quintuple for a client record. A client record is confirmed if there has been a SETCLIENTID_CONFIRM operation to confirm it. Otherwise, it is unconfirmed. An unconfirmed record is established by a SETCLIENTID call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{V、X、C、K、S}は、クライアントレコードの五重です。それを確認するSETCLIENTID_CONFIRM操作があった場合、クライアントのレコードが確認されました。それ以外の場合は、未確認です。未確認のレコードがSETCLIENTID呼び出しによって確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.5.1. IMPLEMENTATION (Preparatory Phase)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.5.1。実装（準備段階）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since SETCLIENTID is a non-idempotent operation, our treatment assumes use of a duplicate request cache (DRC). For a discussion of the DRC, see Section 9.1.7 of [RFC7530].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDが非冪等操作ですので、私たちの治療には、重複要求キャッシュ（DRC）の使用を前提としています。 DRCの議論に関しては、[RFC7530]のセクション9.1.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server gets a SETCLIENTID { v, x, k } request, it first does a number of preliminary checks as listed below before proceeding to the main part of SETCLIENTID processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはSETCLIENTID {V、X、K}の要求を受け取ると、それは最初SETCLIENTID処理の主要部分に進む前に、下記のように予備チェックの数を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It first looks up the request in the DRC. If there is a hit, it returns the result cached in the DRC. The server does NOT remove client state (locks, shares, delegations) nor does it modify any recorded callback and callback_ident information for client { x }. The server now proceeds to the main part of SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは最初のDRCで要求を検索します。ヒットがあれば、それはDRCにキャッシュされた結果を返します。サーバーは、クライアントの状態（ロック、株式、代表団を）削除しておらず、クライアント{X}のための任意の記録コールバックとcallback_ident情報を変更しません。サーバーは現在、SETCLIENTIDの主要部分に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise (i.e., in the case of any DRC miss), the server takes the client ID string x and searches for confirmed client records for x that the server may have recorded from previous SETCLIENTID calls. If there are no such records, or if all such records have a recorded principal that matches that of the current request&#39;s principal, then the preparatory phase proceeds as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそうでない場合（すなわち、任意のDRCミスの場合）、サーバは、サーバが以前のSETCLIENTID呼び出しから記録されている可能性がxについて確認したクライアントレコードのクライアントIDの文字列xと検索を取ります。そのようなレコードが存在しない場合、または次のように全てのそのような記録は、準備段階が進む、現在の要求の主体のものと一致した録画プリンシパルを持っている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If there is a confirmed client record with a matching client ID string and a non-matching principal, the server checks the current state of the associated lease. If there is no associated state for the lease, or the lease has expired, the server proceeds to the main part of SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
一致するクライアントIDの文字列と一致しない元本と確認したクライアントレコードがある場合は*、サーバーは、関連するリースの現在の状態をチェックします。そこには関連した状態がリースのためではない、またはリースの有効期限が切れている場合、サーバーはSETCLIENTIDの主要部分に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Otherwise, the server is being asked to do a SETCLIENTID for a client by a non-matching principal while there is active state. In this case, the server rejects the SETCLIENTID request returning an NFS4ERR_CLID_INUSE error, since use of a single client with multiple principals is not allowed. Note that even though the previously used clientaddr4 is returned with this error, the use of the same id string with multiple clientaddr4s is not prohibited, while its use with multiple principals is prohibited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
*それ以外の場合は、サーバがアクティブな状態が存在する間、一致しないプリンシパルによってクライアントのSETCLIENTIDを行うように求められています。複数のプリンシパルを持つ単一のクライアントの使用が許可されていないので、この場合、サーバは、NFS4ERR_CLID_INUSEエラーを返すSETCLIENTID要求を拒否します。以前使用clientaddr4は、このエラーで返されても、複数のプリンシパルとの使用が禁止されている間、複数のclientaddr4sと同じID文字列の使用は、禁止されていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.5.2. IMPLEMENTATION (Main Phase)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.5.2。実装（メインフェイズ）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the SETCLIENTID has not been dealt with by DRC processing, and has not been rejected with an NFS4ERR_CLID_INUSE error, then the main part of SETCLIENTID processing proceeds, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDは、DRC処理によって対処されておらず、以下に説明するように、NFS4ERR_CLID_INUSE誤差、SETCLIENTID処理進行のメイン部分で拒否されていない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server checks if it has recorded a confirmed record for { v, x, c, l, s }, where l may or may not equal k. If so, and since the id verifier v of the request matches that which is confirmed and recorded, the server treats this as a probable callback information update and records an unconfirmed { v, x, c, k, t } and leaves the confirmed { v, x, c, l, s } in place, such that t != s. It does not matter if k equals l or not. Any pre-existing unconfirmed { v, x, c, *, * } is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバチェックoをそれが{V、X、C、L、S}、Lよいかよい等しいkに対する確認レコードが記録されている場合。もしそうであれば、リクエストのID検証vが確認され、記録されるものと一致しているので、サーバの可能性のコールバック情報の更新として扱いこれとは未確認{V、X、C、K、T}を記録し、確認した葉{代わりにV、X、C、L、S}、例えば、T！= sです。 kはLと等しいかどうかは関係ありません。任意の既存の未確認{V、X、C、*、*}が除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { c, t }. It is indeed returning the old clientid4 value c, because the client apparently only wants to update callback value k to value l. It&#39;s possible this request is one from the Byzantine router that has stale callback information, but this is not a problem. The callback information update is only confirmed if followed up by a SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバ復帰{C、T}。クライアントが明らかにのみ値lにコールバック値kを更新したいので、それは確かに、古いclientid4値cを返しています。これは、この要求が古いコールバック情報を持っているビザンチンルータから1であることは可能ですが、これは問題ではありません。 SETCLIENTID_CONFIRM {C、T}によって追跡場合、コールバック情報の更新のみが確認されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of k via SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバはSETCLIENTID_CONFIRM {C、T}介しkの確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and has not recorded any unconfirmed { *, x, *, *, * } record for x. The server records an unconfirmed { v, x, d, k, t } (d != c, t != s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが以前にそのようなV！= U、Lよいかよい等しいKことが確認{U、X、C、L、S}レコードを記録しており、*、*、任意未確認{*、Xを記録していない、O *} xについて記録します。サーバは、未確認{V、X、D、K、T}（D！= C、T！= S）を記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバ復帰{D、T}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバはSETCLIENTID_CONFIRM {D、T}介し{D、K}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and recorded an unconfirmed { w, x, d, m, t } record such that c != d, t != s, m may or may not equal k, m may or may not equal l, and k may or may not equal l. Whether w == v or w != v makes no difference. The server simply removes the unconfirmed { w, x, d, m, t } record and replaces it with an unconfirmed { v, x, e, k, r } record, such that e != d, e != c, r != t, r != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは、以前に、U、Lかもしれまたはかもしれない等しいK =！Vように確認{U、X、C、L、S}レコードを記録し、未確認{W、X、D、M、T}を記録していますレコード例えばC！= D、T！= sで、Mかもしれまたはかもしれない等しいK、MまたはLよい等しくなくてもよく、Kよいかよい等しいLています。 == Vまたはwのかどうか！= vが違いはありません。サーバは単にように、E！= D、E！= Cを、R、未確認{W、X、D、M、T}レコードを削除し、未確認{V、X、E、K、R}レコードに置き換え！= T、R！= sで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバ復帰{E、R}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { e, k } via SETCLIENTID_CONFIRM { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバはSETCLIENTID_CONFIRM {E、R}介し{E、K}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has no confirmed { *, x, *, *, * } for x. It may or may not have recorded an unconfirmed { u, x, c, l, s }, where l may or may not equal k, and u may or may not equal v. Any unconfirmed record { u, x, c, l, * }, regardless whether u == v or l == k, is replaced with an unconfirmed record { v, x, d, k, t } where d != c, t != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは全く認識していxに対して{*、*、*、*、xはありません}。これはまたは、ここで、Lよいかよい等しいKおよびUよいかよい等しいVを未確認{U、X、C、L、S}を記録しなくてもよい。任意の未確認のレコード{U、X、C、Lを、*}にかかわらず、UはVまたはL == kは==かどうか、未確認のレコード{V、X、D、K、T} D！= C、T！= Sに置換されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバ復帰{D、T}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }. The server does NOT remove client (lock/share/ delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバはSETCLIENTIDが確認介し{D、K}、へ}の確認を待ちます。サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server generates the clientid and setclientid_confirm values and must take care to ensure that these values are extremely unlikely to ever be regenerated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはclientidにとSETCLIENTID_CONFIRM値を生成し、これらの値は、これまでに再生することが極めてそうにないように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. Security Considerations for Inter-server Information Transfer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. サーバ間の情報転送のためのセキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the means by which the source and destination server communicate is not specified by NFSv4.0, the following security-related considerations for inter-server communication should be noted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信元と宛先のサーバが通信する手段をNFSv4.0で指定されていないが、サーバ間通信のために、以下のセキュリティ関連の考慮事項に留意すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Communication between source and destination servers needs to be carried out in a secure manner, with protection against deliberate modification of data in transit provided by using either a private network or a security mechanism that ensures integrity. In many cases, privacy will also be required, requiring a strengthened security mechanism if a private network is not used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O送信元と送信先サーバ間の通信は、プライベートネットワークまたは整合性を確保し、セキュリティ・メカニズムのいずれかを使用することにより提供中のデータの意図的な変更から保護して、安全な方法で行う必要があります。多くの場合、プライバシーにも、プライベートネットワークが使用されていない場合は強化セキュリティ・メカニズムを必要とし、必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Effective implementation of the file system migration function requires that a trust relationship exist between source and destination servers. The details of that trust relationship depend on the specifics of the inter-server transfer protocol, which is outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oファイルシステムのマイグレーション機能の効果的な実施は、信頼関係が送信元と送信先サーバの間に存在することが必要です。その信頼関係の詳細は、本明細書の範囲外であるサーバ間の転送プロトコルの仕様に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The source server may communicate to the destination server security-related information in order to allow it to more rigorously validate clients&#39; identity. For example, the destination server might reject a SETCLIENTID done with a different principal or with a different IP address than was done previously by the client on the source server. However, the destination server MUST NOT use this information to allow any operation to be performed by the client that would not be allowed otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oソースサーバは、より厳密にクライアントのIDを検証できるようにするために、送信先サーバのセキュリティ関連情報を通信することができます。例えば、送信先サーバーは、異なる校長またはソースサーバ上のクライアントによって以前に行われたとは異なるIPアドレスで行わSETCLIENTIDを拒否することがあります。しかし、先のサーバが何らかの操作がそうでなければ許可されませんクライアントによって実行することができるようにするには、この情報を使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. Security Considerations Revision
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. セキュリティの考慮事項改訂
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The penultimate paragraph of Section 19 of [RFC7530] should be revised to read as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7530]のセクション19の最後から二番目の段落は、次のように読み取るために改訂する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Because the operations SETCLIENTID/SETCLIENTID_CONFIRM are responsible for the release of client state, it is imperative that the principal used for these operations be checked against and match the previous use of these operations. In addition, use of integrity protection is desirable on the SETCLIENTID operation, to prevent an attack whereby a change in the boot instance id (verifier) forces an undesired loss of client state. See Section 5 for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SETCLIENTID / SETCLIENTID_CONFIRM操作はクライアントの状態の解除に責任があるので、これらの操作に使用されるプリンシパルが照合さとこれらの操作の以前の使用と一致することが不可欠です。また、完全性保護の使用は、ブート・インスタンスID（検証）の変化は、クライアントの状態の望ましくない損失を強制することにより、攻撃を防ぐために、SETCLIENTID操作上望ましいです。さらなる議論については、セクション5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security considerations of [RFC7530] remain appropriate with the exception of the modification to the penultimate paragraph specified in Section 8.6 of this document and the addition of the material in Section 8.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7530]のセキュリティ上の考慮事項は、このドキュメントのセクション8.6とセクション8.5での材料の他に、指定された最後から二番目の段落の変更を除いて適切なまま。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7530] Haynes, T., Ed. and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Protocol&#34;, RFC 7530, DOI 10.17487/RFC7530, March 2015, &lt;http://www.rfc-editor.org/info/rfc7530&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7530]ヘインズ、T.、エド。そして、D. Noveck、エド。、 &#34;ネットワークファイルシステム（NFS）バージョン4プロトコル&#34;、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、&lt;http://www.rfc-editor.org/info/rfc7530&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INFO-MIGR] Noveck, D., Ed., Shivam, P., Lever, C., and B. Baker, &#34;NFSv4 migration: Implementation experience and spec issues to resolve&#34;, Work in Progress, draft-ietf-nfsv4- migration-issues-09, February 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INFO-MIGR] Noveck、D.、エド、Shivam、P.、レバー、C.、およびB.ベイカー、。 &#34;NFSv4の移行：インプリメンテーションの経験とスペックの問題解決する&#34; が進行中で働いて、ドラフト-IETF-のNFSv4 - 移行問題-09、2016年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813] Callaghan, B., Pawlowski, B., and P. Staubach, &#34;NFS Version 3 Protocol Specification&#34;, RFC 1813, DOI 10.17487/RFC1813, June 1995, &lt;http://www.rfc-editor.org/info/rfc1813&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813]キャラハン、B.、ポロウスキー、B.、およびP.ストーバック、 &#34;NFSバージョン3プロトコル仕様&#34;、RFC 1813、DOI 10.17487 / RFC1813、1995年6月、&lt;http://www.rfc-editor.org/情報/ RFC1813&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 Protocol&#34;, RFC 5661, DOI 10.17487/RFC5661, January 2010, &lt;http://www.rfc-editor.org/info/rfc5661&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] Shepler、S.編、アイスラー、M.編、及びNoveck D.編、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル&#34;、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、&lt;http://www.rfc-editor.org/info/rfc5661&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The editor and authors of this document gratefully acknowledge the contributions of Trond Myklebust of Primary Data and Robert Thurlow of Oracle. We also thank Tom Haynes of Primary Data and Spencer Shepler of Microsoft for their guidance and suggestions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの編集者と著者は感謝して、プライマリ・データとOracleのロバート・ThurlowのトロンMyklebustの貢献を認めます。我々はまた、彼らの指導や提案の一次データのトム・ヘインズとMicrosoftのスペンサーSheplerに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special thanks go to members of the Oracle Solaris NFS team, especially Rick Mesta and James Wahlig, for their work implementing an NFSv4.0 migration prototype and identifying many of the issues addressed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な感謝は、自分の仕事がNFSv4.0移行のプロトタイプを実装し、ここで取り上げた問題の多くを識別するために、OracleのSolarisのNFSチームのメンバー、特にリックメスタとジェームズWahligに行きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Noveck (editor) Hewlett Packard Enterprise 165 Dascomb Road Andover, MA 01810 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デビッドNoveck（編集者）アメリカのヒューレット・パッカードエンタープライズ165 Dascombロードアンドーバー、MA 01810米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 978 474 2011 Email: davenoveck@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 978 474 2011 Eメール：davenoveck@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Piyush Shivam Oracle Corporation 5300 Riata Park Ct. Austin, TX 78727 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Piyush Shivamオラクル・コーポレーション5300 Riata公園のCt。・アメリカのオースティン、TX 78727米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 512 401 1019 Email: piyush.shivam@oracle.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 512 401 1019 Eメール：piyush.shivam@oracle.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Charles Lever Oracle Corporation 1015 Granger Avenue Ann Arbor, MI 48104 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャールズ・レバーオラクル・コーポレーション1015グレンジャーアベニューアナーバー、ミシガンアメリカの48104米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 734 274 2396 Email: chuck.lever@oracle.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 734 274 2396 Eメール：chuck.lever@oracle.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bill Baker Oracle Corporation 5300 Riata Park Ct. Austin, TX 78727 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビル・ベイカーオラクル・コーポレーション5300 Riata公園のCt。・アメリカのオースティン、TX 78727米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 512 401 1081 Email: bill.baker@oracle.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 512 401 1081 Eメール：bill.baker@oracle.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
