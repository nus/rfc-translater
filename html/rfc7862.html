<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7862 - Network File System (NFS) Version 4 Minor Version 2 Protocol 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7862</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7862 - Network File System (NFS) Version 4 Minor Version 2 Protocol 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7862">
              https://tools.ietf.org/html/rfc7862
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7862 - ネットワークファイルシステム（NFS）バージョン4マイナーバージョン2プロトコル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         T. Haynes
Request for Comments: 7862                                  Primary Data
Category: Standards Track                                  November 2016
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Network File System (NFS) Version 4 Minor Version 2 Protocol
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes NFS version 4 minor version 2; it describes the protocol extensions made from NFS version 4 minor version 1. Major extensions introduced in NFS version 4 minor version 2 include the following: Server-Side Copy, Application Input/Output (I/O) Advise, Space Reservations, Sparse Files, Application Data Blocks, and Labeled NFS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントでは、NFSバージョン4のマイナーバージョン2を説明します。 、サーバー側のコピー、アプリケーションの入力/出力（I / O）アドバイス、スペース予約、スパースファイル：それはNFSバージョン4のマイナーバージョン2で導入された4つのマイナーバージョン1.主な機能拡張は、次のものがあり、NFSバージョンから作られたプロトコルの拡張機能について説明しますアプリケーションのデータ・ブロック、および標識NFS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7862.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7862で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................4
      1.1. Requirements Language ......................................4
      1.2. Scope of This Document .....................................5
      1.3. NFSv4.2 Goals ..............................................5
      1.4. Overview of NFSv4.2 Features ...............................6
           1.4.1. Server-Side Clone and Copy ..........................6
           1.4.2. Application Input/Output (I/O) Advise ...............6
           1.4.3. Sparse Files ........................................6
           1.4.4. Space Reservation ...................................7
           1.4.5. Application Data Block (ADB) Support ................7
           1.4.6. Labeled NFS .........................................7
           1.4.7. Layout Enhancements .................................7
      1.5. Enhancements to Minor Versioning Model .....................7
   2. Minor Versioning ................................................8
   3. pNFS Considerations for New Operations ..........................9
      3.1. Atomicity for ALLOCATE and DEALLOCATE ......................9
      3.2. Sharing of Stateids with NFSv4.1 ...........................9
      3.3. NFSv4.2 as a Storage Protocol in pNFS: The File
           Layout Type ................................................9
           3.3.1. Operations Sent to NFSv4.2 Data Servers .............9
   4. Server-Side Copy ...............................................10
      4.1. Protocol Overview .........................................10
           4.1.1. COPY Operations ....................................11
           4.1.2. Requirements for Operations ........................11
      4.2. Requirements for Inter-Server Copy ........................13
      4.3. Implementation Considerations .............................13
           4.3.1. Locking the Files ..................................13
           4.3.2. Client Caches ......................................14
      4.4. Intra-Server Copy .........................................14
      4.5. Inter-Server Copy .........................................16
      4.6. Server-to-Server Copy Protocol ............................19
           4.6.1. Considerations on Selecting a Copy Protocol ........19
           4.6.2. Using NFSv4.x as the Copy Protocol .................19
           4.6.3. Using an Alternative Copy Protocol .................20
      4.7. netloc4 - Network Locations ...............................21
      4.8. Copy Offload Stateids .....................................21
      4.9. Security Considerations for Server-Side Copy ..............22
           4.9.1. Inter-Server Copy Security .........................22
   5. Support for Application I/O Hints ..............................30
   6. Sparse Files ...................................................30
      6.1. Terminology ...............................................31
      6.2. New Operations ............................................32
           6.2.1. READ_PLUS ..........................................32
           6.2.2. DEALLOCATE .........................................32
   7. Space Reservation ..............................................32
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   8. Application Data Block Support .................................34
      8.1. Generic Framework .........................................35
           8.1.1. Data Block Representation ..........................36
      8.2. An Example of Detecting Corruption ........................36
      8.3. An Example of READ_PLUS ...................................38
      8.4. An Example of Zeroing Space ...............................39
   9. Labeled NFS ....................................................39
      9.1. Definitions ...............................................40
      9.2. MAC Security Attribute ....................................41
           9.2.1. Delegations ........................................41
           9.2.2. Permission Checking ................................42
           9.2.3. Object Creation ....................................42
           9.2.4. Existing Objects ...................................42
           9.2.5. Label Changes ......................................42
      9.3. pNFS Considerations .......................................43
      9.4. Discovery of Server Labeled NFS Support ...................43
      9.5. MAC Security NFS Modes of Operation .......................43
           9.5.1. Full Mode ..........................................44
           9.5.2. Limited Server Mode ................................45
           9.5.3. Guest Mode .........................................45
      9.6. Security Considerations for Labeled NFS ...................46
   10. Sharing Change Attribute Implementation Characteristics
       with NFSv4 Clients ............................................46
   11. Error Values ..................................................47
      11.1. Error Definitions ........................................47
           11.1.1. General Errors ....................................47
           11.1.2. Server-to-Server Copy Errors ......................47
           11.1.3. Labeled NFS Errors ................................48
      11.2. New Operations and Their Valid Errors ....................49
      11.3. New Callback Operations and Their Valid Errors ...........53
   12. New File Attributes ...........................................54
      12.1. New RECOMMENDED Attributes - List and Definition
            References ...............................................54
      12.2. Attribute Definitions ....................................54
   13. Operations: REQUIRED, RECOMMENDED, or OPTIONAL ................57
   14. Modifications to NFSv4.1 Operations ...........................61
      14.1. Operation 42: EXCHANGE_ID - Instantiate the client ID ....61
      14.2. Operation 48: GETDEVICELIST - Get all device
            mappings for a file system ...............................63
   15. NFSv4.2 Operations ............................................64
      15.1. Operation 59: ALLOCATE - Reserve space in a
            region of a file .........................................64
      15.2. Operation 60: COPY - Initiate a server-side copy .........65
      15.3. Operation 61: COPY_NOTIFY - Notify a source
            server of a future copy ..................................70
      15.4. Operation 62: DEALLOCATE - Unreserve space in a
            region of a file .........................................72
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      15.5. Operation 63: IO_ADVISE - Send client I/O access
            pattern hints to the server ..............................73
      15.6. Operation 64: LAYOUTERROR - Provide errors for
            the layout ...............................................79
      15.7. Operation 65: LAYOUTSTATS - Provide statistics
            for the layout ...........................................82
      15.8. Operation 66: OFFLOAD_CANCEL - Stop an offloaded
            operation ................................................84
      15.9. Operation 67: OFFLOAD_STATUS - Poll for the
            status of an asynchronous operation ......................85
      15.10. Operation 68: READ_PLUS - READ data or holes
             from a file .............................................86
      15.11. Operation 69: SEEK - Find the next data or hole .........91
      15.12. Operation 70: WRITE_SAME - WRITE an ADB multiple
             times to a file .........................................92
      15.13. Operation 71: CLONE - Clone a range of a file
             into another file .......................................96
   16. NFSv4.2 Callback Operations ...................................98
      16.1. Operation 15: CB_OFFLOAD - Report the results of
            an asynchronous operation ................................98
   17. Security Considerations .......................................99
   18. IANA Considerations ...........................................99
   19. References ...................................................100
      19.1. Normative References ....................................100
      19.2. Informative References ..................................101
   Acknowledgments ..................................................103
   Author&#39;s Address .................................................104
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFS version 4 minor version 2 (NFSv4.2) protocol is the third minor version of the NFS version 4 (NFSv4) protocol. The first minor version, NFSv4.0, is described in [RFC7530], and the second minor version, NFSv4.1, is described in [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSバージョン4マイナーバージョン2（NFSv4.2）プロトコルは、NFSバージョン4（NFSv4の）プロトコルの第三のマイナーバージョンです。最初のマイナーバージョン、NFSv4.0は、[RFC7530]に記載され、そして第二のマイナーバージョン、NFSv4.1は、[RFC5661]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a minor version, NFSv4.2 is consistent with the overall goals for NFSv4, but NFSv4.2 extends the protocol so as to better meet those goals, based on experiences with NFSv4.1. In addition, NFSv4.2 has adopted some additional goals, which motivate some of the major extensions in NFSv4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マイナーバージョンとして、NFSv4.2は、NFSv4のための全体的な目標と一致しているが、より良いNFSv4.1と経験に基づいてこれらの目標を満たすようにNFSv4.2は、プロトコルを拡張します。また、NFSv4.2はNFSv4.2の主要な拡張の一部をやる気いくつかの追加の目標を、採用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますRFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Scope of This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。この文書の範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes the NFSv4.2 protocol as a set of extensions to the specification for NFSv4.1. That specification remains current and forms the basis for the additions defined herein. The specification for NFSv4.0 remains current as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、NFSv4.1の仕様の拡張セットとして、NFSv4.2プロトコルを記述します。その仕様は、現在のままであり、本明細書で定義される追加のための基礎を形成します。 NFSv4.0の仕様も同様に、現在残っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is necessary to implement all the REQUIRED features of NFSv4.1 before adding NFSv4.2 features to the implementation. With respect to NFSv4.0 and NFSv4.1, this document does not:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装にNFSv4.2機能を追加する前に、NFSv4.1の必要なすべての機能を実装する必要があります。 NFSv4.0とNFSv4.1に関しては、この文書はしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o describe the NFSv4.0 or NFSv4.1 protocols, except where needed to contrast with NFSv4.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NFSv4.2と対比するために必要な場合を除いて、NFSv4.0やNFSv4.1プロトコルを記述
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o modify the specification of the NFSv4.0 or NFSv4.1 protocols
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NFSv4.0やNFSv4.1プロトコルの仕様を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o clarify the NFSv4.0 or NFSv4.1 protocols -- that is, any clarifications made here apply only to NFSv4.2 and not to NFSv4.0 or NFSv4.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NFSv4.0やNFSv4.1プロトコルを明確に - つまり、ここで作られた任意の明確化のみNFSv4.2に及びませんNFSv4.0やNFSv4.1に適用されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2 is a superset of NFSv4.1, with all of the new features being optional. As such, NFSv4.2 maintains the same compatibility that NFSv4.1 had with NFSv4.0. Any interactions of a new feature with NFSv4.1 semantics is described in the relevant text.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2は、新機能のすべてがオプションであることと、NFSv4.1のスーパーセットです。そのため、NFSv4.2はNFSv4.1はNFSv4.0としていた同じ互換性を維持します。 NFSv4.1の意味での新機能の任意の相互作用は、関連するテキストで記述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The full External Data Representation (XDR) [RFC4506] for NFSv4.2 is presented in [RFC7863].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2のための完全な外部データ表現（XDR）[RFC4506]は、[RFC7863]に提示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. NFSv4.2 Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3。 NFSv4.2目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A major goal of the enhancements provided in NFSv4.2 is to take common local file system features that have not been available through earlier versions of NFS and to offer them remotely. These features might
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2で提供機能強化の主な目標は、NFSの以前のバージョンを介して利用されていない共通のローカルファイルシステム機能を取るようにしてリモートでそれらを提供することです。これらの機能かもしれません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o already be available on the servers, e.g., sparse files
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oすでにサーバ、例えば、スパースファイル上で利用できるように
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o be under development as a new standard, e.g., SEEK pulls in both SEEK_HOLE and SEEK_DATA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O、新しい標準として開発中である、例えば、SEEK_HOLEとSEEK_DATA両方を引き込むをSEEK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o be used by clients with the servers via some proprietary means, e.g., Labeled NFS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oいくつかの独自の手段を介してサーバとクライアントが使用され、例えば、NFS標識
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2 provides means for clients to leverage these features on the server in cases in which such leveraging had previously not been possible within the confines of the NFS protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2は、このような活用が以前NFSプロトコルの範囲内で可能ではなかったした場合には、サーバー上でこれらの機能を活用するクライアントのための手段を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Overview of NFSv4.2 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4。 NFSv4.2機能の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1. Server-Side Clone and Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1。サーバサイドクローンおよびコピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A traditional file copy of a remotely accessed file, whether from one server to another or between locations in the same server, results in the data being put on the network twice -- source to client and then client to destination. New operations are introduced to allow unnecessary traffic to be eliminated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リモートアクセス、ファイルの伝統的なファイルコピー、一つのサーバから別の、または同じサーバ内の場所の間、ネットワークに置かれているデータで結果を二回か - 先にクライアントへのソースと、クライアント。新しい操作が不要なトラフィックを排除することができるようにするために導入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The intra-server CLONE feature allows the client to request a synchronous cloning, perhaps by copy-on-write semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバ内CLONE機能は、クライアントがコピー・オン・ライトの意味で、おそらく、同期クローニングを要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The intra-server COPY feature allows the client to request the server to perform the copy internally, avoiding unnecessary network traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバ内のコピー機能は、クライアントが不要なネットワークトラフィックを避け、内部でコピーを実行するためにサーバーを要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The inter-server COPY feature allows the client to authorize the source and destination servers to interact directly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバ間のコピー機能は、クライアントが直接対話する送信元と送信先のサーバを認証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As such copies can be lengthy, asynchronous support is also provided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのようなコピーが長くなるように、非同期サポートも提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2. Application Input/Output (I/O) Advise
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2。アプリケーションの入力/出力（I / O）アドバイス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Applications and clients want to advise the server as to expected I/O behavior. Using IO_ADVISE (see Section 15.5) to communicate future I/O behavior such as whether a file will be accessed sequentially or randomly, and whether a file will or will not be accessed in the near future, allows servers to optimize future I/O requests for a file by, for example, prefetching or evicting data. This operation can be used to support the posix_fadvise() [posix_fadvise] function. In addition, it may be helpful to applications such as databases and video editors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションとクライアントが予想I / O動作に、サーバを助言したいです。 、そのようなファイルを順次またはランダムにアクセスされるかどうか、将来のI / O動作を通信するIO_ADVISE（セクション15.5を参照）を使用して、ファイルをするか、または近い将来にアクセスされないかどうかをサーバが将来のI / O要求を最適化することができ例えば、プリフェッチまたは追い出すデータによるファイルの。この操作はposix_fadvise（）[posix_fadvise]機能をサポートするために使用することができます。また、そのようなデータベースやビデオ編集などのアプリケーションに役立つかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3. Sparse Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3。スパースファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sparse files are files that have unallocated or uninitialized data blocks as holes in the file. Such holes are typically transferred as zeros when read from the file. READ_PLUS (see Section 15.10) allows a server to send back to the client metadata describing the hole, and DEALLOCATE (see Section 15.4) allows the client to punch holes into a file. In addition, SEEK (see Section 15.11) is provided to scan for the next hole or data from a given location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スパースファイルは、ファイル内の穴のように割り当てられていないか、初期化されていないデータ・ブロックを持つファイルです。ファイルから読み込む場合、このような穴は、典型的にはゼロとして転送されます。 READ_PLUS（項15.10を参照）、サーバーが穴を記述したメタデータのクライアントに送り返すことを可能にする、とDEALLOCATE（15.4節を参照）は、クライアントがファイルに穴をパンチすることができます。加えて、所定の位置から次の穴又はデータをスキャンするために設けられている（セクション15.11を参照）を求めています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4. Space Reservation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4。スペース予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a file is sparse, one concern that applications have is ensuring that there will always be enough data blocks available for the file during future writes. ALLOCATE (see Section 15.1) allows a client to request a guarantee that space will be available. Also, DEALLOCATE (see Section 15.4) allows the client to punch a hole into a file, thus releasing a space reservation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルがまばらである場合には、アプリケーションが持っている一つの懸念は常に将来の書き込み時にファイルに利用可能な十分なデータ・ブロックが存在するであろうことを確実にすることです。 ALLOCATE（項15.1を参照）、クライアントはスペースが利用できるようになります保証を要求することができます。また、DEALLOCATEは（15.4項を参照）ので、スペースの予約を解放し、クライアントがファイルに穴をパンチすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5. Application Data Block (ADB) Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5。アプリケーションのデータ・ブロック（ADB）のサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some applications treat a file as if it were a disk and as such want to initialize (or format) the file image. The WRITE_SAME operation (see Section 15.12) is introduced to send this metadata to the server to allow it to write the block contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のアプリケーションは、それがディスクであるかのようにファイルを扱い、などのファイルイメージを初期化する（またはフォーマット）します。 WRITE_SAME操作は（項15.12を参照）、それはブロックの内容を書き込むことができるように、サーバーには、このメタデータを送信するために導入されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6. Labeled NFS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6。標識NFS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While both clients and servers can employ Mandatory Access Control (MAC) security models to enforce data access, there has been no protocol support for interoperability. A new file object attribute, sec_label (see Section 12.2.4), allows the server to store MAC labels on files, which the client retrieves and uses to enforce data access (see Section 9.5.3). The format of the sec_label accommodates any MAC security system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
両方のクライアントとサーバーがデータアクセスを強制するために強制アクセス制御（MAC）セキュリティモデルを採用することができますが、相互運用性のためのプロトコルのサポートがなかったです。新しいファイル・オブジェクト属性、sec_l​​abel（項12.2.4を参照）、（9.5.3項を参照）、クライアントが取得したデータへのアクセスを強制するために使用する、サーバーがファイルのMACラベルを保存することができます。 sec_l​​abelの形式は、任意のMACセキュリティシステムに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.7. Layout Enhancements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.7。レイアウト機能強化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the parallel NFS implementations of NFSv4.1 (see Section 12 of [RFC5661]), the client cannot communicate back to the metadata server any errors or performance characteristics with the storage devices. NFSv4.2 provides two new operations to do so: LAYOUTERROR (see Section 15.6) and LAYOUTSTATS (see Section 15.7), respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.1のパラレルNFS実装（[RFC5661]のセクション12を参照）では、クライアントは、ストレージデバイスとバックメタデータサーバにエラーや性能特性を通信することができません。それぞれ、（項15.7を参照してください）LAYOUTERROR（15.6節を参照）、LAYOUTSTATS：NFSv4.2は、そうするには、2つの新しい操作を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. Enhancements to Minor Versioning Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5。マイナーバージョン管理モデルへの拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In NFSv4.1, the only way to introduce new variants of an operation was to introduce a new operation. For instance, READ would have to be replaced or supplemented by, say, either READ2 or READ_PLUS. With the use of discriminated unions as parameters for such functions in NFSv4.2, it is possible to add a new &#34;arm&#34; (i.e., a new entry in the union and a corresponding new field in the structure) in a subsequent minor version. It is also possible to move such an operation from OPTIONAL/RECOMMENDED to REQUIRED. Forcing an implementation to adopt each arm of a discriminated union at such a time does not meet the spirit of the minor versioning rules. As such, new arms of a discriminated union MUST follow the same guidelines for minor versioning as operations in NFSv4.1 -- i.e., they may not be made REQUIRED. To support this, a new error code, NFS4ERR_UNION_NOTSUPP, allows the server to communicate to the client that the operation is supported but the specific arm of the discriminated union is not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.1では、操作の新しい亜種を導入する唯一の方法は、新しい操作を導入することでした。例えば、READはREAD2またはREAD_PLUSのいずれか、たとえば、置き換えられたり補足しなければならないであろう。 NFSv4.2でそのような関数のパラメータとして判別共用体を使用して、それ以降のマイナーバージョンの新しい「アーム」（ユニオンにすなわち、新しいエントリおよび構造に対応する新しいフィールド）を追加することが可能です。 REQUIREDすることをお勧めします/オプションから、このような操作を移動することも可能です。そのような時に区別組合の各アームを採用し、実装を強制すると、マイナーバージョン管理ルールの精神を満たしていません。差別組合のように、新しい武器がNFSv4.1の動作とマイナーバージョンのために同じガイドラインに従わなければならないとして - すなわち、彼らはREQUIREDを作ったことがないかもしれません。これをサポートするために、新しいエラーコード、NFS4ERR_UNION_NOTSUPPは、サーバは操作がサポートされているが、差別組合の具体的な腕がないクライアントに通信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Minor Versioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.マイナーバージョン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2 is a minor version of NFSv4 and is built upon NFSv4.1 as documented in [RFC5661] and [RFC5662].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2は、NFSv4ののマイナーバージョンであり、[RFC5661]と[RFC5662]に記載されているようにNFSv4.1に基づいて構築されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2 does not modify the rules applicable to the NFSv4 versioning process and follows the rules set out in [RFC5661] or in Standards Track documents updating that document (e.g., in an RFC based on [NFSv4-Versioning]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2は、NFSv4のバージョン管理プロセスに適用可能なルールを変更して、[RFC5661]、または（例えば、[NFSv4の-バージョン]に基づいて、RFCで）その文書を更新する標準化過程の文書に記載された規則に従いません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2 only defines extensions to NFSv4.1, each of which may be supported (or not) independently. It does not
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2は、その各々が独立して（又はしない）に支持されてもよい、NFSv4.1への拡張を定義します。それはしていません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o introduce infrastructural features
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oインフラの機能を紹介
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o make existing features MANDATORY to NOT implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oを実装しないように、既存の機能が必須に
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o change the status of existing features (i.e., by changing their status among OPTIONAL, RECOMMENDED, REQUIRED)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O既存の機能のステータスを変更する（推奨、すなわち、OPTIONALの間その状態を変化させることによって必要とされます）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following versioning-related considerations should be noted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のバージョン管理関連の考慮事項に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o When a new case is added to an existing switch, servers need to report non-support of that new case by returning NFS4ERR_UNION_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいケースは、既存のスイッチに追加されると、O、サーバはNFS4ERR_UNION_NOTSUPPを返すことによって、新しい例非サポートを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o As regards the potential cross-minor-version transfer of stateids, Parallel NFS (pNFS) (see Section 12 of [RFC5661]) implementations of the file-mapping type may support the use of an NFSv4.2 metadata server (see Sections 1.7.2.2 and 12.2.2 of [RFC5661]) with NFSv4.1 data servers. In this context, a stateid returned by an NFSv4.2 COMPOUND will be used in an NFSv4.1 COMPOUND directed to the data server (see Sections 3.2 and 3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（[RFC5661]のセクション12を参照）のstateidsの潜在的な交差マイナーバージョン転送、パラレルNFS（pNFSのを）に関してファイルマッピングタイプの実装はNFSv4.2メタデータサーバの使用をサポートすることができるO（セクション1.7参照.2.2と[RFC5661]）NFSv4.1データサーバーとの12.2.2。この文脈において、NFSv4.2化合物によって返さのstateidは（セクション3.2および3.3を参照）は、データ・サーバに向けNFSv4.1化合物に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. pNFS Considerations for New Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
新規事業のための3のpNFSの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The interactions of the new operations with non-pNFS functionality are straightforward and are covered in the relevant sections. However, the interactions of the new operations with pNFS are more complicated. This section provides an overview.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非pNFSの機能を備えた新しい操作の相互作用は単純明快であり、関連セクションで説明されています。しかし、pNFSの持つ新しい事業の相互作用は、より複雑です。このセクションでは、概要を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Atomicity for ALLOCATE and DEALLOCATE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。 ALLOCATEとDEALLOCATEのための不可分性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Both ALLOCATE (see Section 15.1) and DEALLOCATE (see Section 15.4) are sent to the metadata server, which is responsible for coordinating the changes onto the storage devices. In particular, both operations must either fully succeed or fail; it cannot be the case that one storage device succeeds whilst another fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
両方が（15.4項を参照）を割り当てる（セクション15.1を参照）、DEALLOCATEは、ストレージデバイス上の変更を調整するための責任があるメタデータサーバに送られます。具体的には、両方の操作は、完全に成功するか失敗する必要があります。それは別の障害が発生しながら、一つの記憶デバイスが成功した場合にはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Sharing of Stateids with NFSv4.1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。 NFSv4.1とのstateidsの共有
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An NFSv4.2 metadata server can hand out a layout to an NFSv4.1 storage device. Section 13.9.1 of [RFC5661] discusses how the client gets a stateid from the metadata server to present to a storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2のメタデータサーバは、NFSv4.1ストレージデバイスへのレイアウトを配ることができます。 [RFC5661]のセクション13.9.1は、クライアントがストレージデバイスに提示するメタデータサーバからのstateidを取得する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. NFSv4.2 as a Storage Protocol in pNFS: The File Layout Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。ファイルのレイアウトタイプ：pNFSの中ストレージプロトコルとしてNFSv4.2
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A file layout provided by an NFSv4.2 server may refer to either (1) a storage device that only implements NFSv4.1 as specified in [RFC5661] or (2) a storage device that implements additions from NFSv4.2, in which case the rules in Section 3.3.1 apply. As the file layout type does not provide a means for informing the client as to which minor version a particular storage device is providing, the client will have to negotiate this with the storage device via the normal Remote Procedure Call (RPC) semantics of major and minor version discovery. For example, as per Section 16.2.3 of [RFC5661], the client could try a COMPOUND with a minorversion field value of 2; if it gets NFS4ERR_MINOR_VERS_MISMATCH, it would drop back to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2サーバによって提供されるファイルのレイアウトは、その場合には、[RFC5661]またはNFSv4.2から追加を実装（2）記憶装置に指定されるようにのみNFSv4.1を実装（1）記憶装置のいずれかを指すことができますセクション3.3.1のルールが適用されます。ファイルのレイアウトタイプは、特定のストレージデバイスが提供されるマイナーバージョンこれまでのようにクライアントに通知するための手段を提供しないように、クライアントは大手の通常のリモートプロシージャコール（RPC）のセマンティクスを介して記憶装置とこれを交渉する必要がありますし、マイナーバージョン発見。例えば、[RFC5661]の16.2.3項に従って、クライアントは2のMINORVERSIONフィールド値を持つ化合物を試みることができます。それはNFS4ERR_MINOR_VERS_MISMATCHを取得する場合、それは1に戻ってドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. Operations Sent to NFSv4.2 Data Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1。 NFSv4.2データサーバーに送信操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to the commands listed in [RFC5661], NFSv4.2 data servers MAY accept a COMPOUND containing the following additional operations: IO_ADVISE (see Section 15.5), READ_PLUS (see Section 15.10), WRITE_SAME (see Section 15.12), and SEEK (see Section 15.11), which will be treated like the subset specified as &#34;Operations Sent to NFSv4.1 Data Servers&#34; in Section 13.6 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5661]に記載されているコマンドに加えて、NFSv4.2データサーバーは、次の追加の操作を含む化合物を受け入れることがあります。IO_ADVISEは、READ_PLUS（セクション15.5を参照）（WRITE_SAME（セクション15.12を参照）、（セクション15.10を参照）、シーク[RFC5661]のセクション13.6に「NFSv4.1データサーバーに送信操作」として指定されたサブセットのように扱われるセクション15.11）を参照されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Additional details on the implementation of these operations in a pNFS context are documented in the operation-specific sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSのコンテキストでこれらの操作の実施に関する追加の詳細は、操作固有のセクションに記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Server-Side Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.サーバー側のコピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server-side copy features provide mechanisms that allow an NFS client to copy file data on a server or between two servers without the data being transmitted back and forth over the network through the NFS client. Without these features, an NFS client would copy data from one location to another by reading the data from the source server over the network and then writing the data back over the network to the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー側のコピー機能は、NFSクライアントがNFSクライアントを介してネットワーク上で前後に送信されたデータせずにサーバー上、または2つのサーバー間のファイルデータをコピーできるようにするメカニズムを提供します。これらの機能がないと、NFSクライアントは、ネットワークを介して、ソースサーバからデータを読み込み、その後、バック先サーバーにネットワーク経由でデータを書き込むことによって、ある場所から別の場所にデータをコピーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the source object and destination object are on different file servers, the file servers will communicate with one another to perform the COPY operation. The server-to-server protocol by which this is accomplished is not defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースオブジェクトと宛先オブジェクトは異なるファイルサーバー上にある場合は、ファイルサーバには、コピー操作を実行するために互いに通信します。これが達成されるサーバー間のプロトコルは、この文書で定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The copy feature allows the server to perform the copying either synchronously or asynchronously. The client can request synchronous copying, but the server may not be able to honor this request. If the server intends to perform asynchronous copying, it supplies the client with a request identifier that the client can use to monitor the progress of the copying and, if appropriate, cancel a request in progress. The request identifier is a stateid representing the internal state held by the server while the copying is performed. Multiple asynchronous copies of all or part of a file may be in progress in parallel on a server; the stateid request identifier allows monitoring and canceling to be applied to the correct request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コピー機能は、サーバーが同期または非同期コピーを実行することができます。クライアントが同期コピーを要求することができますが、サーバーはこの要求を尊重することはできないかもしれません。サーバは、非同期コピーを行おうとする場合は、クライアントは、コピーの進行状況を監視するために使用すると、適切であれば、進行中のリクエストをキャンセルすることができ、要求識別子をクライアントに提供します。要求識別子は、コピーが行われている間、サーバが保持している内部状態を表すのstateidあります。ファイルの全部または一部の複数の非同期コピーが、サーバ上で並行して進行中であってもよいです。 stateid要求識別子は、監視し、正しい要求に適用されるキャンセルすることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server-side copy offload operations support both intra-server and inter-server file copies. An intra-server copy is a copy in which the source file and destination file reside on the same server. In an inter-server copy, the source file and destination file are on different servers. In both cases, the copy may be performed synchronously or asynchronously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー側のコピー操作は、イントラサーバとサーバ間のファイルコピーの両方をサポートしてオフロード。サーバ内のコピーは、元のファイルとコピー先ファイルが同じサーバー上に存在したコピーです。サーバ間のコピーでは、元のファイルとコピー先のファイルは、異なるサーバ上にあります。どちらの場合も、コピーは、同期または非同期で実行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, the CLONE operation provides COPY-like functionality in the intra-server case, which is both synchronous and atomic in that other operations may not see the target file in any state between the state before the CLONE operation and the state after it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
加えて、クローン操作は、後のクローン操作前の状態の間の任意の状態で対象ファイルと状態が表示されないかもしれない他の動作に同期および原子の両方でイントラサーバーケース内のコピーのような機能を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Throughout the rest of this document, the NFS server containing the source file is referred to as the &#34;source server&#34; and the NFS server to which the file is transferred as the &#34;destination server&#34;. In the case of an intra-server copy, the source server and destination server are the same server. Therefore, in the context of an intra-server copy, the terms &#34;source server&#34; and &#34;destination server&#34; refer to the single server performing the copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書の残りの部分を通して、ソースファイルを含むNFSサーバーは、ファイルを「宛先サーバ」として転写された「ソースサーバ」とNFSサーバと呼ばれます。イントラサーバーコピーの場合には、ソースサーバと宛先サーバは同じサーバです。したがって、イントラサーバーコピーの文脈において、用語「ソースサーバー」と「送信先サーバ」は、コピーを実行する単一のサーバーを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The new operations are designed to copy files or regions within them. Other file system objects can be copied by building on these operations or using other techniques. For example, if a user wishes to copy a directory, the client can synthesize a directory COPY operation by first creating the destination directory and the individual (empty) files within it and then copying the contents of the source directory&#39;s files to files in the new destination directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい操作は、それらの内のファイルまたは領域をコピーするように設計されています。その他のファイル・システム・オブジェクトは、これらの操作上の建物やその他の技術を使用してコピーすることができます。ユーザーがディレクトリをコピーしたい場合たとえば、クライアントが最初にその中に先ディレクトリと、個々の（空の）ファイルを作成し、新しい内のファイルをソースディレクトリのファイルの内容をコピーしたディレクトリのコピー操作を合成することができます先ディレクトリ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the inter-server copy, the operations are defined to be compatible with the traditional copy authorization approach. The client and user are authorized at the source for reading. Then, they are authorized at the destination for writing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ間コピーの場合、操作は従来のコピー許可のアプローチと互換性があるように定義されています。クライアントとユーザーが読み取りのためのソースで許可されています。その後、彼らは書き込みのために先に認可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. COPY Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1。コピー操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLONE: Used by the client to request a synchronous atomic COPY-like operation. (Section 15.13)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLONE：同期アトミックCOPYのような操作を要求するために、クライアントによって使用されます。 （セクション15.13）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPY_NOTIFY: Used by the client to request the source server to authorize a future file copy that will be made by a given destination server on behalf of the given user. (Section 15.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPY_NOTIFY：指定したユーザーの代わりに与えられた宛先サーバによってなされる将来のファイルのコピーを許可するソースサーバを要求するために、クライアントによって使用されます。 （15.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPY: Used by the client to request a file copy. (Section 15.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPY：ファイルのコピーを要求するために、クライアントによって使用されます。 （15.2項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_CANCEL: Used by the client to terminate an asynchronous file copy. (Section 15.8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_CANCEL：非同期ファイルのコピーを終了するために、クライアントによって使用されます。 （セクション15.8）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_STATUS: Used by the client to poll the status of an asynchronous file copy. (Section 15.9)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_STATUS：非同期ファイルコピーの状態をポーリングするために、クライアントによって使用されます。 （15.9項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_OFFLOAD: Used by the destination server to report the results of an asynchronous file copy to the client. (Section 16.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_OFFLOAD：クライアントへの非同期ファイルコピーの結果を報告するために、宛先サーバーによって使用されます。 （16.1節）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Requirements for Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2。操作のための要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Inter-server copy, intra-server copy, and intra-server clone are each OPTIONAL features in the context of server-side copy. A server may choose independently to implement any of them. A server implementing any of these features may be REQUIRED to implement certain operations. Other operations are OPTIONAL in the context of a particular feature (see Table 5 in Section 13) but may become REQUIRED, depending on server behavior. Clients need to use these operations to successfully copy a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ間のコピー、サーバ内のコピー、およびサーバ内のクローンは、サーバー側のコピーのコンテキスト内の各オプション機能です。サーバーは、それらのいずれかを実装するために独立して選択することができます。これらの機能を実装するサーバは、特定の操作を実装するために必要とすることができます。その他の動作は特定の特徴の文脈において任意である（第13表5を参照）が、サーバーの動作に応じて必要になることができます。クライアントが正常にファイルをコピーするために、これらの操作を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a client to do an intra-server file copy, it needs to use either the COPY or the CLONE operation. If COPY is used, the client MUST support the CB_OFFLOAD operation. If COPY is used and it returns a stateid, then the client MAY use the OFFLOAD_CANCEL and OFFLOAD_STATUS operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがサーバ内のファイルのコピーを行うためには、COPYまたはクローン操作のいずれかを使用する必要があります。 COPYを使用する場合、クライアントはCB_OFFLOAD操作をサポートしなければなりません。 COPYが使用され、それがたstateidを返した場合、クライアントはOFFLOAD_CANCELとOFFLOAD_STATUS操作を使用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a client to do an inter-server file copy, it needs to use the COPY and COPY_NOTIFY operations and MUST support the CB_OFFLOAD operation. If COPY returns a stateid, then the client MAY use the OFFLOAD_CANCEL and OFFLOAD_STATUS operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ間のファイルコピーを行うためのクライアントのために、それはCOPYとCOPY_NOTIFY操作を使用する必要があるとCB_OFFLOAD操作をサポートしなければなりません。 COPYがたstateidを返した場合、クライアントはOFFLOAD_CANCELとOFFLOAD_STATUS操作を使用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a server supports the intra-server COPY feature, then the server MUST support the COPY operation. If a server&#39;s COPY operation returns a stateid, then the server MUST also support these operations: CB_OFFLOAD, OFFLOAD_CANCEL, and OFFLOAD_STATUS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはサーバ内COPY機能をサポートしている場合、サーバはコピー操作をサポートしなければなりません。 CB_OFFLOAD、OFFLOAD_CANCEL、およびOFFLOAD_STATUS：サーバーのコピー操作がのstateidを返す場合、サーバーは、これらの操作をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a server supports the CLONE feature, then it MUST support the CLONE operation and the clone_blksize attribute on any file system on which CLONE is supported (as either source or destination file).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはクローン機能をサポートしている場合、それはCLONE動作と（ソースまたは宛先のいずれかのファイルとして）がサポートされているCLONE上の任意のファイルシステム上のclone_blksize属性をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a source server supports the inter-server COPY feature, then it MUST support the COPY_NOTIFY and OFFLOAD_CANCEL operations. If a destination server supports the inter-server COPY feature, then it MUST support the COPY operation. If a destination server&#39;s COPY operation returns a stateid, then the destination server MUST also support these operations: CB_OFFLOAD, OFFLOAD_CANCEL, COPY_NOTIFY, and OFFLOAD_STATUS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースサーバは、サーバ間のコピー機能をサポートしている場合、それはCOPY_NOTIFYとOFFLOAD_CANCEL操作をサポートしなければなりません。先のサーバがサーバ間コピー機能をサポートしている場合、それはコピー操作をサポートしなければなりません。 CB_OFFLOAD、OFFLOAD_CANCEL、COPY_NOTIFY、およびOFFLOAD_STATUS：先サーバーのコピー操作がのstateidを返す場合、宛先サーバは、これらの操作をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each operation is performed in the context of the user identified by the Open Network Computing (ONC) RPC credential in the RPC request containing the COMPOUND or CB_COMPOUND request. For example, an OFFLOAD_CANCEL operation issued by a given user indicates that a specified COPY operation initiated by the same user is to be canceled. Therefore, an OFFLOAD_CANCEL MUST NOT interfere with a copy of the same file initiated by another user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各操作は、化合物またはCB_COMPOUND要求を含むRPC要求におけるオープンネットワークコンピューティング（ONC）RPCクレデンシャルによって識別されるユーザのコンテキストで実行されます。例えば、所与のユーザが発行したOFFLOAD_CANCEL動作が同じユーザによって開始された指定されたコピー操作が解除されることを示します。したがって、OFFLOAD_CANCELは、別のユーザーによって開始され、同じファイルのコピーを妨害してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An NFS server MAY allow an administrative user to monitor or cancel COPY operations using an implementation-specific interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSサーバは、管理ユーザが実装固有のインターフェイスを使用してコピー操作を監視またはキャンセルすることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Requirements for Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。サーバー間コピーするための要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The specification of the inter-server copy is driven by several requirements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ間コピーの仕様は、いくつかの要件によって駆動されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The specification MUST NOT mandate the server-to-server protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O仕様では、サーバ間のプロトコルを強制してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The specification MUST provide guidance for using NFSv4.x as a copy protocol. For those source and destination servers willing to use NFSv4.x, there are specific security considerations that the specification MUST address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O仕様は、コピープロトコルとしてNFSv4.xを使用するためのガイダンスを提供しなければなりません。 NFSv4.xを使用して喜んでそれらの送信元と送信先サーバの場合は、仕様が対処しなければならない特定のセキュリティの考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The specification MUST NOT mandate preconfiguration between the source and destination servers. Requiring that the source and destination servers first have a &#34;copying relationship&#34; increases the administrative burden. However, the specification MUST NOT preclude implementations that require preconfiguration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O仕様は、送信元と送信先サーバ間の事前設定を強制してはなりません。送信元と送信先のサーバーが最初に「コピー関係」を持っていることを要求する管理上の負担が増加します。ただし、仕様は事前設定が必要な実装を排除してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The specification MUST NOT mandate a trust relationship between the source and destination servers. The NFSv4 security model requires mutual authentication between a principal on an NFS client and a principal on an NFS server. This model MUST continue with the introduction of COPY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O仕様は、送信元と送信先サーバ間の信頼関係を強制してはなりません。 NFSv4のセキュリティモデルは、NFSクライアント上の元本およびNFSサーバ上の元本間の相互認証が必要です。このモデルは、COPYの導入を継続しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Implementation Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。実装に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. Locking the Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1。ファイルをロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Both the source file and the destination file may need to be locked to protect the content during the COPY operations. A client can achieve this by a combination of OPEN and LOCK operations. That is, either share locks or byte-range locks might be desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースファイルとコピー先のファイルの両方がコピー操作中にコンテンツを保護するためにロックする必要があるかもしれません。クライアントは、OPENとLOCK操作の組み合わせによってこれを達成することができます。これは、共有ロックまたはバイト範囲ロックのいずれかを希望されるかもしれない、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that when the client establishes a lock stateid on the source, the context of that stateid is for the client and not the destination. As such, there might already be an outstanding stateid, issued to the destination as the client of the source, with the same value as that provided for the lock stateid. The source MUST interpret the lock stateid as that of the client, i.e., when the destination presents it in the context of an inter-server copy, it is on behalf of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは元のロックのstateidを確立するとき、そののstateidのコンテキストは、クライアントではなく目的地のためのものであることに注意してください。そのため、すでにロックのstateidのために提供されるものと同じ値のソースのクライアントとして先に発行済のstateid、あるかもしれません。ソースはクライアント、つまり、宛先がサーバ間コピーのコンテキストでそれを提示したときに、それがクライアントに代わっているのとロックのstateidを解釈する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. Client Caches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2。クライアントキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In a traditional copy, if the client is in the process of writing to the file before the copy (and perhaps with a write delegation), it will be straightforward to update the destination server. With an inter-server copy, the source has no insight into the changes cached on the client. The client SHOULD write the data back to the source. If it does not do so, it is possible that the destination will receive a corrupt copy of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
伝統的なコピーでは、クライアントは（そしておそらく書き込み代表団を）コピーする前に、ファイルへの書き込みのプロセスである場合、先のサーバーを更新する簡単されます。サーバ間のコピーでは、元はクライアントにキャッシュ変化に何の洞察力を持っていません。クライアントは、ソースにデータを書き込む必要があります。それはそうしない場合、先がファイルの破損したコピーを受け取ることも可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Intra-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4。サーバ内のコピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To copy a file on a single server, the client uses a COPY operation. The server may respond to the COPY operation with the final results of the copy, or it may perform the copy asynchronously and deliver the results using a CB_OFFLOAD callback operation. If the copy is performed asynchronously, the client may poll the status of the copy using OFFLOAD_STATUS or cancel the copy using OFFLOAD_CANCEL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一のサーバー上のファイルをコピーするには、クライアントは、コピー操作を使用しています。サーバーは、コピーの最終結果でCOPY操作に応答することができる、またはそれは、非同期コピーを実行し、CB_OFFLOADコールバック操作を使用して結果を配信することができます。コピーが非同期に実行された場合、クライアントはOFFLOAD_STATUSを使用してコピーの状態をポーリングするかOFFLOAD_CANCELを使用してコピーを取り消すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A synchronous intra-server copy is shown in Figure 1. In this example, the NFS server chooses to perform the copy synchronously. The COPY operation is completed, either successfully or unsuccessfully, before the server replies to the client&#39;s request. The server&#39;s reply contains the final result of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同期イントラサーバーコピーこの例では図1に示されている、NFSサーバは同期コピーを実行することを選択しました。サーバーがクライアントの要求に応答する前に、コピー操作は、正常終了または失敗し、完了します。サーバの応答は、操作の最終的な結果が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                                  Server
        +                                      +
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the source file
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the destination file
        |                                      |
        |--- COPY ----------------------------&gt;| Client requests
        |&lt;------------------------------------/| a file copy
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the destination file
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the source file
        |                                      |
        |                                      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1: A Synchronous Intra-Server Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1：同期サーバ内のコピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An asynchronous intra-server copy is shown in Figure 2. In this example, the NFS server performs the copy asynchronously. The server&#39;s reply to the copy request indicates that the COPY operation was initiated and the final result will be delivered at a later time. The server&#39;s reply also contains a copy stateid. The client may use this copy stateid to poll for status information (as shown) or to cancel the copy using an OFFLOAD_CANCEL. When the server completes the copy, the server performs a callback to the client and reports the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非同期イントラサーバーコピーこの例では図2に示されている、NFSサーバは非同期コピーを行います。コピー要求に対するサーバの応答は、COPY操作が開始された、最終的な結果は後日配信されることを示しています。サーバの応答はまた、コピーのstateidが含まれています。クライアントは、（示されるように）、ステータス情報をポーリングするかOFFLOAD_CANCELを使用してコピーをキャンセルするために、このコピーのstateidを使用することができます。サーバがコピーを完了すると、サーバーは、クライアントへのコールバックを実行し、結果を報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                                  Server
        +                                      +
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the source file
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the destination file
        |                                      |
        |--- COPY ----------------------------&gt;| Client requests
        |&lt;------------------------------------/| a file copy
        |                                      |
        |                                      |
        |--- OFFLOAD_STATUS ------------------&gt;| Client may poll
        |&lt;------------------------------------/| for status
        |                                      |
        |                  .                   | Multiple OFFLOAD_STATUS
        |                  .                   | operations may be sent
        |                  .                   |
        |                                      |
        |&lt;-- CB_OFFLOAD -----------------------| Server reports results
        |\------------------------------------&gt;|
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the destination file
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the source file
        |                                      |
        |                                      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 2: An Asynchronous Intra-Server Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図2：非同期サーバ内のコピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5。サーバ間のコピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A copy may also be performed between two servers. The copy protocol is designed to accommodate a variety of network topologies. As shown in Figure 3, the client and servers may be connected by multiple networks. In particular, the servers may be connected by a specialized, high-speed network (network 192.0.2.0/24 in the diagram) that does not include the client. The protocol allows the client to set up the copy between the servers (over network 203.0.113.0/24 in the diagram) and for the servers to communicate on the high-speed network if they choose to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コピーはまた、2つのサーバー間で行われてもよいです。コピープロトコルは、さまざまなネットワークトポロジに対応するように設計されています。図3に示すように、クライアントとサーバは、複数のネットワークによって接続されてもよいです。具体的には、サーバは、クライアントが含まれていない特殊な、高速ネットワーク（図中のネットワーク192.0.2.0/24）によって接続することもできます。プロトコルは、クライアントが（図中のネットワーク203.0.113.0/24以上）サーバー間でのコピーをセットアップすると、彼らがそうすることを選択した場合、サーバ用の高速ネットワーク上で通信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             192.0.2.0/24
                 +-------------------------------------+
                 |                                     |
                 |                                     |
                 | 192.0.2.18                          | 192.0.2.56
         +-------+------+                       +------+------+
         |     Source   |                       | Destination |
         +-------+------+                       +------+------+
                 | 203.0.113.18                        | 203.0.113.56
                 |                                     |
                 |                                     |
                 |             203.0.113.0/24          |
                 +------------------+------------------+
                                    |
                                    |
                                    | 203.0.113.243
                              +-----+-----+
                              |   Client  |
                              +-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 3: An Example Inter-Server Network Topology
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図3：例サーバ間のネットワークトポロジ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For an inter-server copy, the client notifies the source server that a file will be copied by the destination server using a COPY_NOTIFY operation. The client then initiates the copy by sending the COPY operation to the destination server. The destination server may perform the copy synchronously or asynchronously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ間コピーの場合、クライアントは、ファイルがCOPY_NOTIFY操作を使用して宛先サーバによってコピーされますソースサーバーに通知します。次に、クライアントは接続先のサーバーにコピー操作を送信することで、コピーを開始します。送信先サーバーは、同期または非同期コピーを行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A synchronous inter-server copy is shown in Figure 4. In this case, the destination server chooses to perform the copy before responding to the client&#39;s COPY request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同期サーバ間のコピーはこの場合、図4に示され、宛先サーバーは、クライアントのコピー要求に応答する前にコピーを実行することを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                Source         Destination
        +                    +                 +
        |                    |                 |
        |--- OPEN        ---&gt;|                 | Returns
        |&lt;------------------/|                 | open state os1
        |                    |                 |
        |--- COPY_NOTIFY ---&gt;|                 |
        |&lt;------------------/|                 |
        |                    |                 |
        |--- OPEN ----------------------------&gt;| Returns
        |&lt;------------------------------------/| open state os2
        |                    |                 |
        |--- COPY ----------------------------&gt;|
        |                    |                 |
        |                    |                 |
        |                    |&lt;----- READ -----|
        |                    |\---------------&gt;|
        |                    |                 |
        |                    |        .        | Multiple READs may
        |                    |        .        | be necessary
        |                    |        .        |
        |                    |                 |
        |                    |                 |
        |&lt;------------------------------------/| Destination replies
        |                    |                 | to COPY
        |                    |                 |
        |--- CLOSE ---------------------------&gt;| Release os2
        |&lt;------------------------------------/|
        |                    |                 |
        |--- CLOSE       ---&gt;|                 | Release os1
        |&lt;------------------/|                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 4: A Synchronous Inter-Server Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図4：同期サーバ間のコピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An asynchronous inter-server copy is shown in Figure 5. In this case, the destination server chooses to respond to the client&#39;s COPY request immediately and then perform the copy asynchronously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非同期サーバ間のコピーはこの場合、図5に示されているが、送信先サーバーはすぐにクライアントのCOPY要求に応答して、非同期コピーを実行することを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                Source         Destination
       +                    +                 +
       |                    |                 |
       |--- OPEN        ---&gt;|                 | Returns
       |&lt;------------------/|                 | open state os1
       |                    |                 |
       |--- LOCK        ---&gt;|                 | Optional; could be done
       |&lt;------------------/|                 | with a share lock
       |                    |                 |
       |--- COPY_NOTIFY ---&gt;|                 | Need to pass in
       |&lt;------------------/|                 | os1 or lock state
       |                    |                 |
       |                    |                 |
       |                    |                 |
       |--- OPEN ----------------------------&gt;| Returns
       |&lt;------------------------------------/| open state os2
       |                    |                 |
       |--- LOCK ----------------------------&gt;| Optional ...
       |&lt;------------------------------------/|
       |                    |                 |
       |--- COPY ----------------------------&gt;| Need to pass in
       |&lt;------------------------------------/| os2 or lock state
       |                    |                 |
       |                    |                 |
       |                    |&lt;----- READ -----|
       |                    |\---------------&gt;|
       |                    |                 |
       |                    |        .        | Multiple READs may
       |                    |        .        | be necessary
       |                    |        .        |
       |                    |                 |
       |                    |                 |
       |--- OFFLOAD_STATUS ------------------&gt;| Client may poll
       |&lt;------------------------------------/| for status
       |                    |                 |
       |                    |        .        | Multiple OFFLOAD_STATUS
       |                    |        .        | operations may be sent
       |                    |        .        |
       |                    |                 |
       |                    |                 |
       |                    |                 |
       |&lt;-- CB_OFFLOAD -----------------------| Destination reports
       |\------------------------------------&gt;| results
       |                    |                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       |--- LOCKU ---------------------------&gt;| Only if LOCK was done
       |&lt;------------------------------------/|
       |                    |                 |
       |--- CLOSE ---------------------------&gt;| Release os2
       |&lt;------------------------------------/|
       |                    |                 |
       |--- LOCKU       ---&gt;|                 | Only if LOCK was done
       |&lt;------------------/|                 |
       |                    |                 |
       |--- CLOSE       ---&gt;|                 | Release os1
       |&lt;------------------/|                 |
       |                    |                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 5: An Asynchronous Inter-Server Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図5：非同期サーバ間のコピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Server-to-Server Copy Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6。サーバー間コピープロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The choice of what protocol to use in an inter-server copy is ultimately the destination server&#39;s decision. However, the destination server has to be cognizant that it is working on behalf of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ間のコピーに使用するどのようなプロトコルの選択は、最終的には、宛先サーバの決定です。しかし、先のサーバは、クライアントに代わって動作していることを認識しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. Considerations on Selecting a Copy Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1。コピープロトコルの選択に関する考察
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client can have requirements over both the size of transactions and error recovery semantics. It may want to split the copy up such that each chunk is synchronously transferred. It may want the copy protocol to copy the bytes in consecutive order such that upon an error the client can restart the copy at the last known good offset. If the destination server cannot meet these requirements, the client may prefer the traditional copy mechanism such that it can meet those requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、トランザクションのサイズとエラー回復セマンティクスの両方の上に要件を持つことができます。これは、各チャンクが同期転送されるように、コピーアップを分割することもできます。これは、コピープロトコルはエラー時にクライアントがオフセット前回正常にコピーを再開することができるように、連続した順序でバイトをコピーすることもできます。宛先サーバーがこれらの要件を満たすことができない場合、クライアントは、それがこれらの要件を満たすことができるように、従来のコピーメカニズムを好むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. Using NFSv4.x as the Copy Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2。コピープロトコルとしてNFSv4.xを使用します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The destination server MAY use standard NFSv4.x (where x &gt;= 1) operations to read the data from the source server. If NFSv4.x is used for the server-to-server copy protocol, the destination server can use the source filehandle and ca_src_stateid provided in the COPY request with standard NFSv4.x operations to read data from the source server. Note that the ca_src_stateid MUST be the cnr_stateid returned from the source via the COPY_NOTIFY (Section 15.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
先サーバは、ソースサーバからデータを読み取るために、標準的なNFSv4.x（X&gt; = 1）操作を使用するかもしれません。 NFSv4.xは、サーバー間のコピープロトコルに使用される場合、宛先サーバは、ソースサーバからデータを読み取るために、標準的なNFSv4.x操作にCOPY要求に提供されたソースファイルハンドルとca_src_stateidを使用することができます。 ca_src_stateidはcnr_stateidはCOPY_NOTIFY（セクション15.3）を介してソースから返さなければならないことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. Using an Alternative Copy Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3。代替コピープロトコルを使用して
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In a homogeneous environment, the source and destination servers might be able to perform the file copy extremely efficiently using specialized protocols. For example, the source and destination servers might be two nodes sharing a common file system format for the source and destination file systems. Thus, the source and destination are in an ideal position to efficiently render the image of the source file to the destination file by replicating the file system formats at the block level. Another possibility is that the source and destination might be two nodes sharing a common storage area network, and thus there is no need to copy any data at all; instead, ownership of the file and its contents might simply be reassigned to the destination. To allow for these possibilities, the destination server is allowed to use a server-to-server copy protocol of its choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
均質な環境では、送信元と送信先のサーバーは、特殊なプロトコルを使用して、非常に効率的にファイルのコピーを実行することができるかもしれません。例えば、送信元および宛先のサーバがソースおよび宛先ファイルシステムの一般的なファイルシステムフォーマットを共有する二つのノードであるかもしれません。したがって、送信元と宛先を効率的にブロックレベルでファイルシステムフォーマットを複製することにより、宛先ファイルにソースファイルの画像をレンダリングするための理想的な位置にあります。別の可能性は、ソースおよび宛先は、2つのノードの共通ストレージ・エリア・ネットワークを共有し、したがって、まったくデータをコピーする必要がないかもしれないということです。代わりに、ファイルとその内容の所有権は単に先に再割り当てされる可能性があります。これらの可能性を可能にするため、先のサーバは、その選択肢のサーバ間のコピープロトコルを使用することが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In a heterogeneous environment, using a protocol other than NFSv4.x (e.g., HTTP [RFC7230] or FTP [RFC959]) presents some challenges. In particular, the destination server is presented with the challenge of accessing the source file given only an NFSv4.x filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
異機種環境では、NFSv4.x以外のプロトコル（例えば、HTTP [RFC7230]またはFTP [RFC959]）を使用していくつかの課題を提示します。具体的には、宛先サーバーにのみNFSv4.xファイルハンドルを指定したソースファイルにアクセスするという課題が提示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One option for protocols that identify source files with pathnames is to use an ASCII hexadecimal representation of the source filehandle as the filename.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パス名とソースファイルを特定のプロトコルのための1つのオプションは、ファイル名として、ソースファイルハンドルのASCIIの16進数表記を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another option for the source server is to use URLs to direct the destination server to a specialized service. For example, the response to COPY_NOTIFY could include the URL &lt;ftp://s1.example.com:9999/_FH/0x12345&gt;, where 0x12345 is the ASCII hexadecimal representation of the source filehandle. When the destination server receives the source server&#39;s URL, it would use &#34;_FH/0x12345&#34; as the filename to pass to the FTP server listening on port 9999 of s1.example.com. On port 9999 there would be a special instance of the FTP service that understands how to convert NFS filehandles to an open file descriptor (in many operating systems, this would require a new system call, one that is the inverse of the makefh() function that the pre-NFSv4 MOUNT service needs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースサーバのための別のオプションは、専門的なサービスに送信先サーバを指示するためにURLを使用することです。例えば、COPY_NOTIFYへの応答は0x12345は、ソースファイルハンドルのASCII 16進表現であるURL &lt;ftp://s1.example.com:9999/_FH/0x12345&gt;を、含むことができます。宛先サーバーがソースサーバのURLを受信すると、それはs1.example.comのポート9999でリッスンしてFTPサーバーに渡すファイル名として「_FH / 0x12345」を使用します。ポート9999上で（多くのオペレーティング・システムでは、これは新しいシステムコールを必要とするオープンファイル記述子へのNFSファイルハンドルを変換する方法を理解してFTPサービス、makefh（）関数の逆数である1の特別なインスタンスが存在することになります前のNFSv4 MOUNTサービスが必要とします）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authenticating and identifying the destination server to the source server is also a challenge. One solution would be to construct unique URLs for each destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証およびソースサーバーに送信先サーバを特定することも課題となっています。一つの解決策は、各送信先サーバーの一意のURLを作成することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. netloc4 - Network Locations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7。 netloc4  - ネットワークロケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server-side COPY operations specify network locations using the netloc4 data type shown below (see [RFC7863]):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバ側のコピー操作は、（[RFC7863]を参照）、以下に示すnetloc4データ型を使用してネットワーク上の場所を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum netloc_type4 { NL4_NAME = 1, NL4_URL = 2, NL4_NETADDR = 3 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙{netloc_type4 NL4_NAME = 1 NL4_URL = 2 NL4_NETADDR = 3}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union netloc4 switch (netloc_type4 nl_type) {
           case NL4_NAME:          utf8str_cis nl_name;
           case NL4_URL:           utf8str_cis nl_url;
           case NL4_NETADDR:       netaddr4    nl_addr;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the netloc4 is of type NL4_NAME, the nl_name field MUST be specified as a UTF-8 string. The nl_name is expected to be resolved to a network address via DNS, the Lightweight Directory Access Protocol (LDAP), the Network Information Service (NIS), /etc/hosts, or some other means. If the netloc4 is of type NL4_URL, a server URL [RFC3986] appropriate for the server-to-server COPY operation is specified as a UTF-8 string. If the netloc4 is of type NL4_NETADDR, the nl_addr field MUST contain a valid netaddr4 as defined in Section 3.3.9 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
netloc4がタイプNL4_NAMEのであれば、nl_nameフィールドはUTF-8文字列として指定する必要があります。 nl_nameがDNSを介してネットワークアドレスに解決されることが予想され、LDAP（Lightweight Directory Access Protocol）を、ネットワーク情報サービス（NIS）、/ etc / hostsファイル、またはいくつかの他の手段。 netloc4がタイプNL4_URLである場合、サーバ間COPY動作のための適切なサーバURL [RFC3986]はUTF-8文字列として指定されています。 netloc4がタイプNL4_NETADDRである場合、[RFC5661]のセクション3.3.9で定義され、nl_addrフィールドが有効なnetaddr4を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When netloc4 values are used for an inter-server copy as shown in Figure 3, their values may be evaluated on the source server, destination server, and client. The network environment in which these systems operate should be configured so that the netloc4 values are interpreted as intended on each system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図3に示すようにnetloc4値は、サーバ間のコピーのために使用される場合、それらの値は、ソース・サーバは、宛先サーバ、およびクライアント上で評価することができます。 netloc4値は、各システム上で意図したとおりに解釈されるように、これらのシステムが動作するネットワーク環境を構成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. Copy Offload Stateids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8。コピーオフロードのstateids
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server may perform a copy offload operation asynchronously. An asynchronous copy is tracked using a copy offload stateid. Copy offload stateids are included in the COPY, OFFLOAD_CANCEL, OFFLOAD_STATUS, and CB_OFFLOAD operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、非同期コピーオフロード操作を行うことができます。非同期コピーはコピーオフロードのstateidを使用して追跡されます。コピーのstateidsはCOPY、OFFLOAD_CANCEL、OFFLOAD_STATUS、およびCB_OFFLOAD操作に含まれているオフロード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A copy offload stateid will be valid until either (A) the client or server restarts or (B) the client returns the resource by issuing an OFFLOAD_CANCEL operation or the client replies to a CB_OFFLOAD operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（A）は、クライアントまたはサーバの再起動または（B）のいずれかは、クライアントがOFFLOAD_CANCEL操作を発行することによって、リソースを返したり、クライアントがCB_OFFLOAD操作に応答するまで、コピーのオフロードのstateidが有効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A copy offload stateid&#39;s seqid MUST NOT be zero. In the context of a copy offload operation, it is inappropriate to indicate &#34;the most recent copy offload operation&#34; using a stateid with a seqid of zero (see Section 8.2.2 of [RFC5661]). It is inappropriate because the stateid refers to internal state in the server and there may be several asynchronous COPY operations being performed in parallel on the same file by the server. Therefore, a copy offload stateid with a seqid of zero MUST be considered invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コピーオフロードのstateidのSEQIDはゼロであるはずがありません。コピーオフロード動作の文脈では、それはゼロのSEQIDとのstateidを使用して「最新のコピーオフロード操作」を示すために不適切である（[RFC5661]のセクション8.2.2を参照）。 stateidはサーバ内の内部状態を参照し、サーバによって同じファイル上で並列に実行されるいくつかの非同期コピー操作があるかもしれないので、それは不適切です。したがって、ゼロのSEQIDでコピーオフロードのstateidは無効であると見なされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9. Security Considerations for Server-Side Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9。サーバー側のコピーのためのセキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All security considerations pertaining to NFSv4.1 [RFC5661] apply to this section; as such, the standard security mechanisms used by the protocol can be used to secure the server-to-server operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.1に関連するすべてのセキュリティ上の考慮事項は、[RFC5661]は、このセクションに適用されます。など、プロトコルによって使用される標準のセキュリティメカニズムは、サーバー間の動作を確保するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4 clients and servers supporting the inter-server COPY operations described in this section are REQUIRED to implement the mechanism described in Section 4.9.1.1 and to support rejecting COPY_NOTIFY requests that do not use the RPC security protocol (RPCSEC_GSS) [RFC7861] with privacy. If the server-to-server copy protocol is based on ONC RPC, the servers are also REQUIRED to implement [RFC7861], including the RPCSEC_GSSv3 &#34;copy_to_auth&#34;, &#34;copy_from_auth&#34;, and &#34;copy_confirm_auth&#34; structured privileges. This requirement to implement is not a requirement to use; for example, a server may, depending on configuration, also allow COPY_NOTIFY requests that use only AUTH_SYS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションで説明するサーバ間のコピー操作をサポートするのNFSv4クライアントとサーバは、セクション4.9.1.1で説明したメカニズムを実装し、プライバシーとRPCのセキュリティプロトコル（RPCSEC_GSS）[RFC7861]を使用していないCOPY_NOTIFY要求を拒否サポートする必要があります。サーバー間のコピープロトコルはONC RPCに基づいている場合、サーバもRPCSEC_GSSv3「copy_to_auth」、「copy_from_auth」、および「copy_confirm_auth」構造化された権限を含め、[RFC7861]を実装する必要があります。実装するためにこの要件は、使用する必要はありません。例えば、サーバーは、構成に応じて、また、唯一のAUTH_SYSを使用COPY_NOTIFY要求を可能にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a server requires the use of an RPCSEC_GSSv3 copy_to_auth, copy_from_auth, or copy_confirm_auth privilege and it is not used, the server will reject the request with NFS4ERR_PARTNER_NO_AUTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがRPCSEC_GSSv3のcopy_to_auth、copy_from_auth、またはcopy_confirm_auth権限を使用する必要があり、それが使用されていない場合、サーバはNFS4ERR_PARTNER_NO_AUTHで要求を拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1. Inter-Server Copy Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1。サーバ間コピーセキュリティー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1. Inter-Server Copy via ONC RPC with RPCSEC_GSSv3
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1。 RPCSEC_GSSv3とONC RPC経由でサーバ間のコピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client sends a COPY_NOTIFY to the source server to expect the destination to attempt to copy data from the source server, it is expected that this copy is being done on behalf of the principal (called the &#34;user principal&#34;) that sent the RPC request that encloses the COMPOUND procedure that contains the COPY_NOTIFY operation. The user principal is identified by the RPC credentials. A mechanism that allows the user principal to authorize the destination server to perform the copy, lets the source server properly authenticate the destination&#39;s copy, and does not allow the destination server to exceed this authorization is necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがソースサーバーからのデータをコピーしようとする先を期待するソースサーバーにCOPY_NOTIFYを送信すると、このコピーはRPCを送った（「ユーザープリンシパル」と呼ばれる）校長に代わって行われていることが期待されますCOPY_NOTIFY操作を含む化合物の手続きを囲む要求。ユーザープリンシパルは、RPCの資格情報によって識別されます。ユーザープリンシパルがコピーを実行するには、宛先サーバーを承認することを可能にするメカニズムは、ソースサーバが正常に送信先のコピーを認証することができますし、先のサーバは、この許可が必要である超過することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An approach that sends delegated credentials of the client&#39;s user principal to the destination server is not used for the following reason. If the client&#39;s user delegated its credentials, the destination would authenticate as the user principal. If the destination were using the NFSv4 protocol to perform the copy, then the source server would authenticate the destination server as the user principal, and the file copy would securely proceed. However, this approach would allow the destination server to copy other files. The user principal would have to trust the destination server to not do so. This is counter to the requirements and therefore is not considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
宛先サーバーへのクライアントのユーザープリンシパルの委任資格情報を送信したアプローチは、次の理由のために使用されていません。クライアントのユーザーは、その資格情報を委任した場合、送信先のユーザープリンシパルとして認証します。宛先がコピーを実行するためのNFSv4プロトコルを使用していた場合、ソース・サーバーは、ユーザープリンシパルとして先サーバを認証なり、ファイルのコピーが確実に進行します。しかし、このアプローチは、宛先サーバーが他のファイルをコピーすることが可能になります。ユーザープリンシパルはそうしないように先のサーバーを信頼する必要があります。これは、要件にカウンタであるためと考えられていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Instead, a feature of the RPCSEC_GSSv3 protocol [RFC7861] can be used: RPC-application-defined structured privilege assertion. This feature allows the destination server to authenticate to the source server as acting on behalf of the user principal and to authorize the destination server to perform READs of the file to be copied from the source on behalf of the user principal. Once the copy is complete, the client can destroy the RPCSEC_GSSv3 handles to end the authorization of both the source and destination servers to copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代わりに、RPCSEC_GSSv3プロトコル[RFC7861]の特徴を使用することができる：RPCアプリケーション定義構造特権を主張。この機能は、宛先サーバーは、ユーザー本人の代わりに行動するように、ソースサーバーへの認証にして実行するには、宛先サーバがユーザプリンシパルの代わりにソースからコピーするファイルの読み取り許可することができます。コピーが完了すると、クライアントはRPCSEC_GSSv3をコピーするために、両方の送信元と送信先サーバの認証を終了するにはハンドルを破壊することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For each structured privilege assertion defined by an RPC application, RPCSEC_GSSv3 requires the application to define a name string and a data structure that will be encoded and passed between client and server as opaque data. For NFSv4, the data structures specified below MUST be serialized using XDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RPCアプリケーションによって定義された各構成特権アサーションに、RPCSEC_GSSv3は、名前の文字列と符号化され、不透明なデータとして、クライアントとサーバとの間で渡されるデータ構造を定義するためのアプリケーションを必要とします。 NFSv4のために、以下の指定されたデータ構造は、XDRを使用して直列化されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Three RPCSEC_GSSv3 structured privilege assertions that work together to authorize the copy are defined here. For each of the assertions, the description starts with the name string passed in the rp_name field of the rgss3_privs structure defined in Section 2.7.1.4 of [RFC7861] and specifies the XDR encoding of the associated structured data passed via the rp_privilege field of the structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コピーを許可するために一緒に働く三のRPCSEC_GSSv3構造特権アサーションはここで定義されています。アサーションのそれぞれについて、説明は[RFC7861]のセクション2.7.1.4で定義されたrgss3_privs構造のrp_nameフィールドに渡された名前の文字列で始まり、構造のrp_privilegeフィールドを介して渡された関連する構造化データのXDRエンコーディングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
copy_from_auth: A user principal is authorizing a source principal (&#34;nfs@&lt;source&gt;&#34;) to allow a destination principal (&#34;nfs@&lt;destination&gt;&#34;) to set up the copy_confirm_auth privilege required to copy a file from the source to the destination on behalf of the user principal. This privilege is established on the source server before the user principal sends a COPY_NOTIFY operation to the source server, and the resultant RPCSEC_GSSv3 context is used to secure the COPY_NOTIFY operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
copy_from_auth：ユーザープリンシパルは、送信元から宛先へファイルをコピーするために必要なcopy_confirm_auth権限を設定するには、宛先プリンシパル（「&lt;送信先&gt; @ NFS」）を可能にするために、ソースプリンシパル（「&lt;ソース&gt; @ NFS」を）許可されましたユーザープリンシパルに代わって。この権限は、ユーザープリンシパルがソースサーバーにCOPY_NOTIFY操作を送信する前に、ソースサーバー上で確立され、得られたRPCSEC_GSSv3コンテキストはCOPY_NOTIFYの動作を確保するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct copy_from_auth_priv {
           secret4             cfap_shared_secret;
           netloc4             cfap_destination;
           /* the NFSv4 user name that the user principal maps to */
           utf8str_mixed       cfap_username;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cfap_shared_secret is an automatically generated random number secret value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cfap_shared_secretは自動的に生成された乱数秘密値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
copy_to_auth: A user principal is authorizing a destination principal (&#34;nfs@&lt;destination&gt;&#34;) to set up a copy_confirm_auth privilege with a source principal (&#34;nfs@&lt;source&gt;&#34;) to allow it to copy a file from the source to the destination on behalf of the user principal. This privilege is established on the destination server before the user principal sends a COPY operation to the destination server, and the resultant RPCSEC_GSSv3 context is used to secure the COPY operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
copy_to_auth：ユーザープリンシパルは、それが元からファイルをコピーできるようにするために、ソースプリンシパル（「&lt;ソース&gt; @ NFS」）とcopy_confirm_auth権限を設定するには、宛先プリンシパル（「&lt;送信先&gt; @ NFS」）を許可されますユーザープリンシパルに代わって先。ユーザープリンシパル先サーバーにコピー操作を送信する前にこの特権は、送信先サーバー上で確立され、得られたRPCSEC_GSSv3コンテキストはコピー操作を保護するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct copy_to_auth_priv {
           /* equal to cfap_shared_secret */
           secret4              ctap_shared_secret;
           netloc4              ctap_source&lt;&gt;;
           /* the NFSv4 user name that the user principal maps to */
           utf8str_mixed        ctap_username;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ctap_shared_secret is the automatically generated secret value used to establish the copy_from_auth privilege with the source principal. See Section 4.9.1.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ctap_shared_secretは、元校長とcopy_from_auth権限を確立するために使用される自動的に生成された秘密の値です。セクション4.9.1.1.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
copy_confirm_auth: A destination principal (&#34;nfs@&lt;destination&gt;&#34;) is confirming with the source principal (&#34;nfs@&lt;source&gt;&#34;) that it is authorized to copy data from the source. This privilege is established on the destination server before the file is copied from the source to the destination. The resultant RPCSEC_GSSv3 context is used to secure the READ operations from the source to the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
copy_confirm_auth：先のプリンシパル（「NFS @ &lt;送信先&gt;」）元校長で確認された（「NFS @ &lt;ソース&gt;」）ソースからデータをコピーするために許可されていること。ファイルはソースから宛先へコピーされる前に、この権限は、送信先サーバー上で確立されています。得られRPCSEC_GSSv3コンテキストが宛先サーバにソースからの読み出し動作を確保するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct copy_confirm_auth_priv {
           /* equal to GSS_GetMIC() of cfap_shared_secret */
           opaque              ccap_shared_secret_mic&lt;&gt;;
           /* the NFSv4 user name that the user principal maps to */
           utf8str_mixed       ccap_username;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.1. Establishing a Security Context
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.1。セキュリティコンテキストの確立
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the user principal wants to copy a file between two servers, if it has not established copy_from_auth and copy_to_auth privileges on the servers, it establishes them as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それがサーバー上でcopy_from_authとcopy_to_auth権限を確立していない場合は、ユーザープリンシパルは、2つのサーバー間でファイルをコピーしたい場合は、以下のように、それはそれらを確立します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o As noted in [RFC7861], the client uses an existing RPCSEC_GSSv3 context termed the &#34;parent&#34; handle to establish and protect RPCSEC_GSSv3 structured privilege assertion exchanges. The copy_from_auth privilege will use the context established between the user principal and the source server used to OPEN the source file as the RPCSEC_GSSv3 parent handle. The copy_to_auth privilege will use the context established between the user principal and the destination server used to OPEN the destination file as the RPCSEC_GSSv3 parent handle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7861]で述べたように、O、クライアントは既存のRPCSEC_GSSv3コンテキストが確立しRPCSEC_GSSv3構造特権アサーション交換を保護するために、「親」のハンドルと呼ばれる使用しています。 copy_from_auth権限は、ユーザ・プリンシパルとRPCSEC_GSSv3の親ハンドルとしてソースファイルを開くために使用したソースサーバの間で確立されたコンテキストを使用します。 copy_to_auth権限は、ユーザ・プリンシパルとRPCSEC_GSSv3の親ハンドルとして先のファイルを開くために使用される宛先サーバーの間で確立されたコンテキストを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A random number is generated to use as a secret to be shared between the two servers. Note that the random number SHOULD NOT be reused between establishing different security contexts. The resulting shared secret will be placed in the copy_from_auth_priv cfap_shared_secret field and the copy_to_auth_priv ctap_shared_secret field. Because of this shared_secret, the RPCSEC_GSS3_CREATE control messages for copy_from_auth and copy_to_auth MUST use a Quality of Protection (QoP) of rpc_gss_svc_privacy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O乱数は、2台のサーバー間で共有される秘密として使用するために生成されます。乱数が異なるセキュリティコンテキストを確立する間で再利用されるべきでないことに注意してください。得られた共有秘密はcopy_from_auth_privのcfap_shared_secretフィールドとcopy_to_auth_privのctap_shared_secretフィールドに配置されます。このためshared_secretの、copy_from_authとcopy_to_authためRPCSEC_GSS3_CREATE制御メッセージはrpc_gss_svc_privacyの保護品質（QoP）のを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An instance of copy_from_auth_priv is filled in with the shared secret, the destination server, and the NFSv4 user id of the user principal and is placed in rpc_gss3_create_args assertions[0].privs.privilege. The string &#34;copy_from_auth&#34; is placed in assertions[0].privs.name. The source server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE payload and verifies that the NFSv4 user id being asserted matches the source server&#39;s mapping of the user principal. If it does, the privilege is established on the source server as &lt;copy_from_auth, user id, destination&gt;. The field &#34;handle&#34; in a successful reply is the RPCSEC_GSSv3 copy_from_auth &#34;child&#34; handle that the client will use in COPY_NOTIFY requests to the source server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O copy_from_auth_privのインスタンスは、共有秘密、宛先サーバ、およびユーザプリンシパルのNFSv4のユーザIDで充填され、rpc_gss3_create_argsアサーション[0] .privs.privilegeに配置されます。文字列「copy_from_authは」アサーション[0] .privs.nameに配置されます。ソースサーバはrpc_gss_svc_privacyのRPCSEC_GSS3_CREATEペイロードをアンラップし、アサートされNFSv4のユーザIDは、ユーザプリンシパルのソースサーバのマッピングと一致することを検証します。それがない場合は、権限が&lt;copy_from_auth、ユーザID、目的地&gt;としてソースサーバー上で確立されています。フィールドには、正常な応答で「ハンドル」RPCSEC_GSSv3のcopy_from_auth「子」は、クライアントがソースサーバーにCOPY_NOTIFYリクエストで使用することを扱うです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An instance of copy_to_auth_priv is filled in with the shared secret, the cnr_source_server list returned by COPY_NOTIFY, and the NFSv4 user id of the user principal. The copy_to_auth_priv instance is placed in rpc_gss3_create_args assertions[0].privs.privilege. The string &#34;copy_to_auth&#34; is placed in assertions[0].privs.name. The destination server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE payload and verifies that the NFSv4 user id being asserted matches the destination server&#39;s mapping of the user principal. If it does, the privilege is established on the destination server as &lt;copy_to_auth, user id, source list&gt;. The field &#34;handle&#34; in a successful reply is the RPCSEC_GSSv3 copy_to_auth child handle that the client will use in COPY requests to the destination server involving the source server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O copy_to_auth_privのインスタンスは、共有秘密、COPY_NOTIFYによって返さcnr_source_serverリスト、およびユーザプリンシパルのNFSv4のユーザIDで充填されています。 copy_to_auth_privインスタンスはrpc_gss3_create_argsアサーション[0] .privs.privilegeに配置されます。文字列「copy_to_authは」アサーション[0] .privs.nameに配置されます。宛先サーバがrpc_gss_svc_privacyのRPCSEC_GSS3_CREATEペイロードをアンラップし、アサートされNFSv4のユーザIDは、ユーザ本人の先サーバのマッピングと一致することを検証します。それがない場合は、権限が&lt;copy_to_auth、ユーザID、ソースリスト&gt;として先サーバー上で確立されています。正常な応答でフィールド「ハンドル」RPCSEC_GSSv3のcopy_to_authの子は、クライアントがソースサーバーが関与先サーバーにCOPY要求で使用することを扱うです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As noted in Section 2.7.1 of [RFC7861] (&#34;New Control Procedure - RPCSEC_GSS_CREATE&#34;), both the client and the source server should associate the RPCSEC_GSSv3 child handle with the parent RPCSEC_GSSv3 handle used to create the RPCSEC_GSSv3 child handle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7861]（「新制御手順 -  RPCSEC_GSS_CREATE」）の2.7.1項で述べたように、クライアントとソースサーバーの両方がRPCSEC_GSSv3の子供がRPCSEC_GSSv3子ハンドルを作成するために使用さRPCSEC_GSSv3が取り扱う親とハンドル関連付ける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.2. Starting a Secure Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.2。セキュアサーバ間のコピーを開始
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client sends a COPY_NOTIFY request to the source server, it uses the privileged copy_from_auth RPCSEC_GSSv3 handle. cna_destination_server in the COPY_NOTIFY MUST be the same as cfap_destination specified in copy_from_auth_priv. Otherwise, the COPY_NOTIFY will fail with NFS4ERR_ACCESS. The source server verifies that the privilege &lt;copy_from_auth, user id, destination&gt; exists and annotates it with the source filehandle, if the user principal has read access to the source file and if administrative policies give the user principal and the NFS client read access to the source file (i.e., if the ACCESS operation would grant read access). Otherwise, the COPY_NOTIFY will fail with NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがソースサーバーにCOPY_NOTIFY要求を送信すると、それは特権copy_from_authのRPCSEC_GSSv3ハンドルを使用しています。 COPY_NOTIFYでcna_destination_serverはcopy_from_auth_privで指定cfap_destinationと同じでなければなりません。それ以外の場合は、COPY_NOTIFYはNFS4ERR_ACCESSで失敗します。ユーザープリンシパルは、ソースファイルへのアクセスを読み取った場合、管理ポリシーがユーザー・プリンシパルとNFSクライアントがアクセス権を読んで与える場合は、ソースサーバは、特権&lt;copy_from_auth、ユーザID、送信先&gt;が存在し、ソースファイルハンドルでそれを注釈を付けていることを確認しますソースファイル（つまり、アクセス動作が読み取りアクセスを許可するかどう）。それ以外の場合は、COPY_NOTIFYはNFS4ERR_ACCESSで失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client sends a COPY request to the destination server, it uses the privileged copy_to_auth RPCSEC_GSSv3 handle. ca_source_server list in the COPY MUST be the same as ctap_source list specified in copy_to_auth_priv. Otherwise, the COPY will fail with NFS4ERR_ACCESS. The destination server verifies that the privilege &lt;copy_to_auth, user id, source list&gt; exists and annotates it with the source and destination filehandles. If the COPY returns a wr_callback_id, then this is an asynchronous copy and the wr_callback_id must also must be annotated to the copy_to_auth privilege. If the client has failed to establish the copy_to_auth privilege, it will reject the request with NFS4ERR_PARTNER_NO_AUTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが接続先サーバーへのCOPY要求を送信すると、それは特権copy_to_authのRPCSEC_GSSv3ハンドルを使用しています。 COPYでca_source_serverリストはcopy_to_auth_privに指定されたctap_sourceリストと同じでなければなりません。そうでない場合、COPYはNFS4ERR_ACCESSで失敗します。送信先サーバーは、特権&lt;copy_to_auth、ユーザID、ソースリスト&gt;が存在し、送信元と送信先のファイルハンドルでそれ注釈を付けていることを確認します。 COPYはwr_callback_idを返す場合、これは、非同期コピーであるとwr_callback_idもcopy_to_auth権限に注釈を付けなければなりませんしなければなりません。クライアントがcopy_to_auth権限を確立するために失敗した場合、それはNFS4ERR_PARTNER_NO_AUTHで要求を拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If either the COPY_NOTIFY operation or the COPY operations fail, the associated copy_from_auth and copy_to_auth RPCSEC_GSSv3 handles MUST be destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPY_NOTIFY操作またはコピー操作のいずれかが失敗した場合、関連copy_from_authとcopy_to_auth RPCSEC_GSSv3ハンドルが破棄されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.3. Securing ONC RPC Server-to-Server Copy Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.3。 ONCのRPCサーバーとサーバーコピーのプロトコルのセキュリティ保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After a destination server has a copy_to_auth privilege established on it and it receives a COPY request, if it knows it will use an ONC RPC protocol to copy data, it will establish a copy_confirm_auth privilege on the source server prior to responding to the COPY operation, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信先サーバーがそれに設立copy_to_auth権限を持っており、それはそれはそれは前COPY操作への応答にソースサーバ上のcopy_confirm_auth権限を確立し、データをコピーするためにONC RPCプロトコルを使用します知っている場合には、COPY要求を受信した後、次のように：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Before establishing an RPCSEC_GSSv3 context, a parent context needs to exist between nfs@&lt;destination&gt; as the initiator principal and nfs@&lt;source&gt; as the target principal. If NFS is to be used as the copy protocol, this means that the destination server must mount the source server using RPCSEC_GSSv3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O RPCSEC_GSSv3コンテキストを確立する前に、親コンテキストはターゲットプリンシパルとして&lt;ソース&gt; @開始プリンシパルとNFSとして&lt;宛先&gt; @ NFSの間に存在する必要があります。 NFSは、コピープロトコルとして使用する場合、これは、宛先サーバーがRPCSEC_GSSv3を使用してソースサーバをマウントしなければならないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An instance of copy_confirm_auth_priv is filled in with information from the established copy_to_auth privilege. The value of the ccap_shared_secret_mic field is a GSS_GetMIC() of the ctap_shared_secret in the copy_to_auth privilege using the parent handle context. The ccap_username field is the mapping of the user principal to an NFSv4 user name (&#34;user&#34;@&#34;domain&#34; form) and MUST be the same as the ctap_username in the copy_to_auth privilege. The copy_confirm_auth_priv instance is placed in rpc_gss3_create_args assertions[0].privs.privilege. The string &#34;copy_confirm_auth&#34; is placed in assertions[0].privs.name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O copy_confirm_auth_privのインスタンスが確立copy_to_auth権限からの情報で満たされています。 ccap_shared_secret_micフィールドの値は、親ハンドルコンテキストを使用してcopy_to_auth権限でctap_shared_secretのGSS_GetMIC（）です。 ccap_usernameフィールドはNFSv4のユーザ名（「ユーザ」@「ドメイン」形態）にユーザプリンシパルのマッピングであり、copy_to_auth特権でctap_usernameと同じでなければなりません。 copy_confirm_auth_privインスタンスはrpc_gss3_create_argsアサーション[0] .privs.privilegeに配置されます。文字列「copy_confirm_authは」アサーション[0] .privs.nameに配置されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The RPCSEC_GSS3_CREATE copy_from_auth message is sent to the source server with a QoP of rpc_gss_svc_privacy. The source server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE payload and verifies the cap_shared_secret_mic by calling GSS_VerifyMIC() using the parent context on the cfap_shared_secret from the established copy_from_auth privilege, and verifies that the ccap_username equals the cfap_username.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O RPCSEC_GSS3_CREATEのcopy_from_authメッセージはrpc_gss_svc_privacyのたQoPとソースサーバに送信されます。ソースサーバはrpc_gss_svc_privacyのRPCSEC_GSS3_CREATEペイロードをアンラップし、確立copy_from_auth権限からcfap_shared_secretの親コンテキストを使用して）（GSS_VerifyMICを呼び出すことによってcap_shared_secret_micを検証し、ccap_usernameはcfap_usernameに等しいことを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If all verifications succeed, the copy_confirm_auth privilege is established on the source server as &lt;copy_confirm_auth, shared_secret_mic, user id&gt;. Because the shared secret has been verified, the resultant copy_confirm_auth RPCSEC_GSSv3 child handle is noted to be acting on behalf of the user principal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての検証が成功した場合、O、copy_confirm_auth権限は&lt;copy_confirm_auth、shared_secret_mic、ユーザID&gt;としてソースサーバ上で確立されています。共有秘密は検証されているので、RPCSEC_GSSv3子ハンドルcopy_confirm_auth結果は、ユーザー本人の代わりに行動することが注目されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the source server fails to verify the copy_from_auth privilege, the COPY_NOTIFY operation will be rejected with NFS4ERR_PARTNER_NO_AUTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースサーバがcopy_from_auth権限を確認するために失敗した場合、O、COPY_NOTIFY操作がNFS4ERR_PARTNER_NO_AUTHで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the destination server fails to verify the copy_to_auth or copy_confirm_auth privilege, the COPY will be rejected with NFS4ERR_PARTNER_NO_AUTH, causing the client to destroy the associated copy_from_auth and copy_to_auth RPCSEC_GSSv3 structured privilege assertion handles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
宛先サーバーがcopy_to_authまたはcopy_confirm_auth権限を確認するために失敗した場合、O、COPYは、関連copy_from_authとcopy_to_auth RPCSEC_GSSv3構造特権アサーションハンドルを破壊するために、クライアントを引き起こし、NFS4ERR_PARTNER_NO_AUTHで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o All subsequent ONC RPC READ requests sent from the destination to copy data from the source to the destination will use the RPCSEC_GSSv3 copy_confirm_auth child handle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oソースから宛先へデータをコピーする先から送られた後続のすべてのONC RPC READ要求がRPCSEC_GSSv3 copy_confirm_auth子ハンドルを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the use of the copy_confirm_auth privilege accomplishes the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
copy_confirm_auth権限の使用は、以下を達成していることに注意してください：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If a protocol like NFS is being used with export policies, the export policies can be overridden if the destination server is not authorized to act as an NFS client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSのようなプロトコルは、輸出ポリシーに使用されている場合、宛先サーバがNFSクライアントとして動作するように許可されていない場合は、O、輸出政策を上書きすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Manual configuration to allow a copy relationship between the source and destination is not needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O送信元と宛先間のコピー関係を許可する手動設定は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.4. Maintaining a Secure Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.4。セキュアサーバ間のコピーを保持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client determines that either the copy_from_auth or the copy_to_auth handle becomes invalid during a copy, then the copy MUST be aborted by the client sending an OFFLOAD_CANCEL to both the source and destination servers and destroying the respective copy-related context handles as described in Section 4.9.1.1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがcopy_from_authまたはcopy_to_authハンドルがコピー中は無効となり、そのコピーは、クライアントによって中止されなければならないのどちらかと判断した場合、両方の送信元と送信先のサーバにOFFLOAD_CANCELを送信し、それぞれのコピーに関連したコンテキストを破壊するセクションで説明したように処理します4.9.1.1.5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.5. Finishing or Stopping a Secure Inter-Server Copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.1.5。仕上げまたはセキュアサーバ間のコピーを停止
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Under normal operation, the client MUST destroy the copy_from_auth and the copy_to_auth RPCSEC_GSSv3 handle once the COPY operation returns for a synchronous inter-server copy or a CB_OFFLOAD reports the result of an asynchronous copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
通常の操作では、クライアントはcopy_from_authとコピー操作は、同期サーバ間のコピーのために返すかCB_OFFLOADは非同期コピーの結果を報告した後に処理RPCSEC_GSSv3 copy_to_authを破棄しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The copy_confirm_auth privilege is constructed from information held by the copy_to_auth privilege and MUST be destroyed by the destination server (via an RPCSEC_GSS3_DESTROY call) when the copy_to_auth RPCSEC_GSSv3 handle is destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
copy_confirm_auth権限がcopy_to_auth特権が保持する情報から構成され、copy_to_authのRPCSEC_GSSv3ハンドルが破棄されるとき（RPCSEC_GSS3_DESTROYコールを介して）送信先サーバによって破壊されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The copy_confirm_auth RPCSEC_GSS3 handle is associated with a copy_from_auth RPCSEC_GSS3 handle on the source server via the shared secret and MUST be locally destroyed (there is no RPCSEC_GSS3_DESTROY, as the source server is not the initiator) when the copy_from_auth RPCSEC_GSSv3 handle is destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
copy_confirm_authのRPCSEC_GSS3ハンドルは、共有秘密を介してソースサーバ上のcopy_from_authのRPCSEC_GSS3ハンドルに関連付けられているとcopy_from_authのRPCSEC_GSSv3ハンドルが破棄されたときに（ソース・サーバーが開始しないように、何RPCSEC_GSS3_DESTROYは存在しない）、局所的に破壊されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client sends an OFFLOAD_CANCEL to the source server to rescind the destination server&#39;s synchronous copy privilege, it uses the privileged copy_from_auth RPCSEC_GSSv3 handle, and the cra_destination_server in the OFFLOAD_CANCEL MUST be the same as the name of the destination server specified in copy_from_auth_priv. The source server will then delete the &lt;copy_from_auth, user id, destination&gt; privilege and fail any subsequent copy requests sent under the auspices of this privilege from the destination server. The client MUST destroy both the copy_from_auth and the copy_to_auth RPCSEC_GSSv3 handles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが接続先サーバーの同期コピー権限を取り消すために、ソースサーバにOFFLOAD_CANCELを送信した場合、それは特権copy_from_authのRPCSEC_GSSv3ハンドルを使用し、OFFLOAD_CANCELでcra_destination_serverはcopy_from_auth_privで指定された宛先サーバの名前と同じでなければなりません。ソースサーバは、&lt;copy_from_auth、ユーザID、先&gt;権限を削除し、先サーバーからこの権限の後援の下で送信され、その後のコピー要求を失敗します。クライアントはcopy_from_authとcopy_to_authのRPCSEC_GSSv3ハンドルの両方を破棄しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client sends an OFFLOAD_STATUS to the destination server to check on the status of an asynchronous copy, it uses the privileged copy_to_auth RPCSEC_GSSv3 handle, and the osa_stateid in the OFFLOAD_STATUS MUST be the same as the wr_callback_id specified in the copy_to_auth privilege stored on the destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、非同期コピーの状態をチェックし、宛先サーバにOFFLOAD_STATUSを送信した場合、それは特権copy_to_authのRPCSEC_GSSv3ハンドルを使用し、OFFLOAD_STATUSでosa_stateidは、先に保存されているcopy_to_auth権限で指定wr_callback_idと同じでなければなりませんサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client sends an OFFLOAD_CANCEL to the destination server to cancel an asynchronous copy, it uses the privileged copy_to_auth RPCSEC_GSSv3 handle, and the oaa_stateid in the OFFLOAD_CANCEL MUST be the same as the wr_callback_id specified in the copy_to_auth privilege stored on the destination server. The destination server will then delete the &lt;copy_to_auth, user id, source list&gt; privilege and the associated copy_confirm_auth RPCSEC_GSSv3 handle. The client MUST destroy both the copy_to_auth and copy_from_auth RPCSEC_GSSv3 handles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが非同期コピーをキャンセルする先サーバーにOFFLOAD_CANCELを送信した場合、それは特権copy_to_authのRPCSEC_GSSv3ハンドルを使用し、OFFLOAD_CANCELでoaa_stateidは先サーバーに保存されているcopy_to_auth権限で指定wr_callback_idと同じでなければなりません。宛先サーバーは、&lt;copy_to_auth、ユーザID、ソースリスト&gt;特権と関連するcopy_confirm_authのRPCSEC_GSSv3ハンドルを削除します。クライアントはcopy_to_authとcopy_from_auth RPCSEC_GSSv3ハンドルの両方を破棄しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.2. Inter-Server Copy via ONC RPC without RPCSEC_GSS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1.2。 RPCSEC_GSSなしONC RPC経由でサーバ間のコピー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ONC RPC security flavors other than RPCSEC_GSS MAY be used with the server-side copy offload operations described in this section. In particular, host-based ONC RPC security flavors such as AUTH_NONE and AUTH_SYS MAY be used. If a host-based security flavor is used, a minimal level of protection for the server-to-server copy protocol is possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RPCSEC_GSS以外のONC RPCセキュリティ風味は、このセクションで説明する操作は、サーバー側のコピーとオフロード使用されるかもしれません。特に、そのようなAUTH_NONEおよびAUTH_SYSなどのホストベースのONC RPCセキュリティ風味を使用することができます。ホストベースのセキュリティ風味を使用する場合は、サーバ間のコピープロトコルの保護の最低限のレベルが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The biggest issue is that there is a lack of a strong security method to allow the source server and destination server to identify themselves to each other. A further complication is that in a multihomed environment the destination server might not contact the source server from the same network address specified by the client in the COPY_NOTIFY. The cnr_stateid returned from the COPY_NOTIFY can be used to uniquely identify the destination server to the source server. The use of the cnr_stateid provides initial authentication of the destination server but cannot defend against man-in-the-middle attacks after authentication or against an eavesdropper that observes the opaque stateid on the wire. Other secure communication techniques (e.g., IPsec) are necessary to block these attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最大の問題は、ソースサーバーと送信先サーバーが相互に自分自身を特定できるようにする強力なセキュリティ方法が不足しているということです。さらに合併症は、マルチホーム環境での宛先サーバーがCOPY_NOTIFYで、クライアントによって指定された同じネットワークアドレスからソースサーバーに接続できないかもしれないということです。 COPY_NOTIFYから返さcnr_stateid一意ソースサーバに送信先サーバを識別するために使用することができます。 cnr_stateidの使用は、先サーバの初期認証を提供しますが、認証後またはワイヤ上の不透明たstateidを観察盗聴者に対するman-in-the-middle攻撃を防御することはできません。他の安全な通信技術（例えば、IPsec）は、これらの攻撃をブロックするために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers SHOULD reject COPY_NOTIFY requests that do not use RPCSEC_GSS with privacy, thus ensuring that the cnr_stateid in the COPY_NOTIFY reply is encrypted. For the same reason, clients SHOULD send COPY requests to the destination using RPCSEC_GSS with privacy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、このようにCOPY_NOTIFY応答でcnr_stateidが暗号化されていることを確認して、プライバシーをRPCSEC_GSSを使用していないCOPY_NOTIFY要求を拒否すべきです。同じ理由で、クライアントがプライバシーをRPCSEC_GSSを使用して宛先にCOPY要求を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Support for Application I/O Hints
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
アプリケーションのI / Oのヒント5.サポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Applications can issue client I/O hints via posix_fadvise() [posix_fadvise] to the NFS client. While this can help the NFS client optimize I/O and caching for a file, it does not allow the NFS server and its exported file system to do likewise. The IO_ADVISE procedure (Section 15.5) is used to communicate the client file access patterns to the NFS server. The NFS server, upon receiving an IO_ADVISE operation, MAY choose to alter its I/O and caching behavior but is under no obligation to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは、NFSクライアントに[posix_fadvise]）（posix_fadviseを介してクライアントI / Oヒントを発行することができます。これはファイルのNFSクライアントの最適化I / Oとキャッシュを助けることができるが、それはNFSサーバと同様に行うには、そのエクスポートされたファイルシステムを使用できません。 IO_ADVISE手順（15.5節）は、NFSサーバへのクライアント・ファイル・アクセス・パターンを通信するために使用されます。 NFSサーバは、IO_ADVISE操作を受信すると、そのI / Oおよびキャッシュ動作を変更することを選択するかもしれませんが、そうする義務はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Application-specific NFS clients such as those used by hypervisors and databases can also leverage application hints to communicate their specialized requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのようなハイパーバイザやデータベースによって使用されているようなアプリケーション固有のNFSクライアントは、彼らの専門的な要件を伝えるために、アプリケーションのヒントを活用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Sparse Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.スパースファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A sparse file is a common way of representing a large file without having to utilize all of the disk space for it. Consequently, a sparse file uses less physical space than its size indicates. This means the file contains &#34;holes&#34;, byte ranges within the file that contain no data. Most modern file systems support sparse files, including most UNIX file systems and Microsoft&#39;s New Technology File System (NTFS); however, it should be noted that Apple&#39;s Hierarchical File System Plus (HFS+) does not. Common examples of sparse files include Virtual Machine (VM) OS/disk images, database files, log files, and even checkpoint recovery files most commonly used by the High-Performance Computing (HPC) community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スパースファイルは、それのためにすべてのディスク領域を利用することなく、大きなファイルを表現する一般的な方法です。そのため、スパースファイルは、そのサイズが示すよりも少ない物理的なスペースを使用しています。これは、ファイルにはデータを含まないファイル内の「穴」、バイト範囲が含まれていることを意味します。最近のほとんどのファイルシステムは、ほとんどのUNIXファイルシステムとMicrosoftの新技術ファイルシステム（NTFS）を含むスパースファイルを、サポートしています。しかし、Appleの階層ファイルシステムプラス（HFS +）がないことに留意すべきです。スパースファイルの一般的な例としては、仮想マシン（VM）OS /ディスクイメージ、データベースファイル、ログファイル、および最も一般的に高性能コンピューティング（HPC）コミュニティで使用しても、チェックポイントリカバリファイルが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, many modern file systems support the concept of &#34;unwritten&#34; or &#34;uninitialized&#34; blocks, which have uninitialized space allocated to them on disk but will return zeros until data is written to them. Such functionality is already present in the data model of the pNFS block/volume layout (see [RFC5663]). Uninitialized blocks can be thought of as holes inside a space reservation window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、多くの近代的なファイルシステムは、ディスク上のそれらに割り当てられて初期化されていないスペースを持っていますが、データが書き込まれるまでゼロを返します「不文律」または「初期化されていない」ブロックの概念をサポートしています。そのような機能は、（[RFC5663]を参照）pNFSのブロック/ボリュームレイアウトのデータ・モデルに既に存在しています。初期化されていないブロックは、スペース予約ウィンドウ内の穴と考えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an application reads a hole in a sparse file, the file system must return all zeros to the application. For local data access there is little penalty, but with NFS these zeros must be transferred back to the client. If an application uses the NFS client to read data into memory, this wastes time and bandwidth as the application waits for the zeros to be transferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは、スパースファイルに穴を読み込む場合は、ファイルシステムは、アプリケーションにすべてゼロを返す必要があります。ローカル・データ・アクセスのために少しペナルティがありますが、NFSでこれらのゼロは、クライアントに転送する必要があります。アプリケーションがメモリにデータを読み出すためにNFSクライアントを使用している場合、これは転送されるゼロのアプリケーションを待つように時間と帯域幅を浪費します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A sparse file is typically created by initializing the file to be all zeros. Nothing is written to the data in the file; instead, the hole is recorded in the metadata for the file. So, an 8G disk image might be represented initially by a few hundred bits in the metadata (on UNIX file systems, the inode) and nothing on the disk. If the VM then writes 100M to a file in the middle of the image, there would now be two holes represented in the metadata and 100M in the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スパースファイルは通常、すべてゼロであることを、ファイルを初期化することによって作成されます。何も、ファイル内のデータに書き込まれません。代わりに、穴は、ファイルのメタデータに記録されています。だから、8Gのディスクイメージは（UNIXのファイルシステムで、iノード）メタデータとディスク上の何もないでは数百ビットで最初に表現されることがあります。 VMは、その後、画像の中央にあるファイルへの100Mを書き込んだ場合、今のデータ内のメタデータと100Mで表される2つの穴があることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
No new operation is needed to allow the creation of a sparsely populated file; when a file is created and a write occurs past the current size of the file, the non-allocated region will either be a hole or be filled with zeros. The choice of behavior is dictated by the underlying file system and is transparent to the application. However, the abilities to read sparse files and to punch holes to reinitialize the contents of a file are needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい操作は、人口密度の低いファイルの作成を可能にするために必要はありません。ファイルが作成され、書き込みがファイルの現在のサイズを越えて発生したとき、未割当領域は、いずれかの穴になり、またはゼロで充填すること。行動の選択は、基本的なファイルシステムによって決定し、アプリケーションに対して透過的です。ただし、スパースファイルを読み込むと、ファイルの内容を再初期化するために穴をパンチする能力が必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Two new operations -- DEALLOCATE (Section 15.4) and READ_PLUS (Section 15.10) -- are introduced. DEALLOCATE allows for the hole punching, where an application might want to reset the allocation and reservation status of a range of the file. READ_PLUS supports all the features of READ but includes an extension to support sparse files. READ_PLUS is guaranteed to perform no worse than READ and can dramatically improve performance with sparse files. READ_PLUS does not depend on pNFS protocol features but can be used by pNFS to support sparse files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
二つの新しい操作 -  DEALLOCATE（15.4項）とREAD_PLUS（セクション15.10）を - 導入されています。 DEALLOCATEは、アプリケーションがファイルの範囲の割り当てと予約ステータスをリセットしたい場合があります穴パンチ、することができます。 READ_PLUSは、READのすべての機能をサポートしていますが、スパースファイルをサポートするための拡張機能が含まれています。 READ_PLUSはREADよりも悪いことを行わないことが保証されており、飛躍的にスパースファイルのパフォーマンスを向上させることができます。 READ_PLUSはpNFSのプロトコルの機能に依存しませんが、スパースファイルをサポートするためのpNFSで使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Regular file: An object of file type NF4REG or NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
通常のファイル：ファイルタイプNF4REGまたはNF4NAMEDATTRのオブジェクト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sparse file: A regular file that contains one or more holes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スパースファイル：1つ以上の穴が含まれている通常のファイル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hole: A byte range within a sparse file that contains all zeros. A hole might or might not have space allocated or reserved to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホール：すべてゼロが含まれているスパースファイル内のバイト範囲。穴はスペースが割り当てられたか、それを予約していないこともありますか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. New Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。新事業
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. READ_PLUS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1。 READ_PLUS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ_PLUS is a new variant of the NFSv4.1 READ operation [RFC5661]. Besides being able to support all of the data semantics of the READ operation, it can also be used by the client and server to efficiently transfer holes. Because the client does not know in advance whether a hole is present or not, if the client supports READ_PLUS and so does the server, then it should always use the READ_PLUS operation in preference to the READ operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ_PLUSはNFSv4.1 READ動作[RFC5661]の新しい変種です。 READ操作のデータセマンティクスの全てをサポートすることができることに加え、また、効率的に穴を転送するために、クライアントとサーバーで使用することができます。クライアントは、クライアントがREAD_PLUSをサポートしていますので、サーバがない場合、それは常にREAD操作に優先してREAD_PLUS操作を使用する必要があり、穴が存在するかどうかを事前に把握していないので。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ_PLUS extends the response with a new arm representing holes to avoid returning data for portions of the file that are initialized to zero and may or may not contain a backing store. Returning actual data blocks corresponding to holes wastes computational and network resources, thus reducing performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ_PLUSはゼロに初期化され、またはバッキングストアを含んでも含まなくてもよいファイルの部分にデータを返す回避するために穴を表す新しいアームで応答を延びています。従って性能を低下させる、孔浪費計算およびネットワークリソースに対応する実際のデータ・ブロックを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client sends a READ operation, it is not prepared to accept a READ_PLUS-style response providing a compact encoding of the scope of holes. If a READ occurs on a sparse file, then the server must expand such data to be raw bytes. If a READ occurs in the middle of a hole, the server can only send back bytes starting from that offset. By contrast, if a READ_PLUS occurs in the middle of a hole, the server can send back a range that starts before the offset and extends past the requested length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはREAD操作を送信すると、穴の範囲のコンパクトなエンコーディングを提供READ_PLUSスタイルの応答を受け入れる用意はありません。 READがスパースファイルで発生した場合、サーバは、生のバイトに、このようなデータを展開する必要があります。 READは、穴の途中で発生した場合、サーバはそのオフセットから始まるバイトを送り返すことができます。 READ_PLUS穴の途中で発生した場合のコントラストによって、サーバは、オフセットの前に開始し、要求された長さを越えて延びる範囲を送り返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. DEALLOCATE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2。 DEALLOCATE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client can use the DEALLOCATE operation on a range of a file as a hole punch, which allows the client to avoid the transfer of a repetitive pattern of zeros across the network. This hole punch is a result of the unreserved space returning all zeros until overwritten.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、クライアントがネットワークを介してゼロの繰り返しパターンの転写を回避することを可能にする穴パンチなどのファイルの範囲にDEALLOCATE操作を使用することができます。この穴パンチが上書きされるまで、すべてゼロを返す予約されていないスペースの結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Space Reservation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.スペース予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Applications want to be able to reserve space for a file, report the amount of actual disk space a file occupies, and free up the backing space of a file when it is not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは、ファイルのためのスペースを確保したファイルが占有している実際のディスク・スペースの量を報告し、それを必要としない場合、ファイルの裏のスペースを空けることができるようにしたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One example is the posix_fallocate() operation [posix_fallocate], which allows applications to ask for space reservations from the operating system, usually to provide a better file layout and reduce overhead for random or slow-growing file-appending workloads.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一例では、アプリケーションは、より良好なファイルレイアウトを提供し、ランダムまたは成長の遅いファイル追加のワークロードのためのオーバーヘッドを低減するために、通常、オペレーティングシステムからの空間の予約を要求することを可能にするposix_fallocate（）操作[posix_fallocate]、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another example is space reservation for virtual disks in a hypervisor. In virtualized environments, virtual disk files are often stored on NFS-mounted volumes. When a hypervisor creates a virtual disk file, it often tries to preallocate the space for the file so that there are no future allocation-related errors during the operation of the VM. Such errors prevent a VM from continuing execution and result in downtime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の例では、ハイパーバイザ内の仮想ディスクのためのスペースを予約です。仮想化環境では、仮想ディスクファイルは、多くの場合、NFSマウントされたボリュームに保存されます。ハイパーバイザーは、仮想ディスクファイルを作成するとき、それは多くの場合、VMの動作中に何の将来の割り当てに関連するエラーがないように、ファイルのためのスペースを事前に割り当てるしようとします。このようなエラーは、ダウンタイムの継続的な実行と結果からVMを防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Currently, in order to achieve such a guarantee, applications zero the entire file. The initial zeroing allocates the backing blocks, and all subsequent writes are overwrites of already-allocated blocks. This approach is not only inefficient in terms of the amount of I/O done; it is also not guaranteed to work on file systems that are log-structured or deduplicated. An efficient way of guaranteeing space reservation would be beneficial to such applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在、そのような保証を達成するために、アプリケーションはファイル全体をゼロ。最初のゼロ化は、バッキングブロックを割り当て、後続のすべての書き込みが既に割り当てられているブロックの上書きです。このアプローチは、I / O行わ量の観点からだけでなく、非効率的です。また、ログ構造や重複排除されているファイル・システム上での動作が保証されていません。スペースの予約を保証する効率的な方法は、そのような用途に有益であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The new ALLOCATE operation (see Section 15.1) allows a client to request a guarantee that space will be available. The ALLOCATE operation guarantees that any future writes to the region it was successfully called for will not fail with NFS4ERR_NOSPC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいALLOCATE操作（項15.1を参照）、クライアントはスペースが利用できるようになります保証を要求することができます。 ALLOCATE操作将来はNFS4ERR_NOSPCで失敗しないであろうために、それが正常に呼び出された領域に書き込みを行うことが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another useful feature is the ability to report the number of blocks that would be freed when a file is deleted. Currently, NFS reports two size attributes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もう1つの便利な機能は、ファイルが削除されたときに解放されるだろうブロックの数を報告する機能です。現在、NFSは、2つのサイズの属性を報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
size The logical file size of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サイズファイルの論理ファイルサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
space_used The size in bytes that the file occupies on disk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルがディスク上で占有サイズをバイト単位でspace_used。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While these attributes are sufficient for space accounting in traditional file systems, they prove to be inadequate in modern file systems that support block-sharing. In such file systems, multiple inodes (the metadata portion of the file system object) can point to a single block with a block reference count to guard against premature freeing. Having a way to tell the number of blocks that would be freed if the file was deleted would be useful to applications that wish to migrate files when a volume is low on space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの属性は、従来のファイル・システム内のスペース会計のために十分であるが、それらはブロックの共有をサポートする最新のファイルシステムでは不十分であることを証明します。このようなファイルシステムでは、複数のiノード（ファイル・システム・オブジェクトのメタデータ部）が早期解放を防ぐためにブロックの参照カウントを有する単一のブロックを指すことができます。ファイルが削除された場合に解放されるだろうブロックの数を指示する方法を持つことは、ボリュームがスペースに低いときにファイルを移行したいアプリケーションに有用であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since virtual disks represent a hard drive in a VM, a virtual disk can be viewed as a file system within a file. Since not all blocks within a file system are in use, there is an opportunity to reclaim blocks that are no longer in use. A call to deallocate blocks could result in better space efficiency; less space might be consumed for backups after block deallocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
仮想ディスクがVMにハードドライブを表しているため、仮想ディスクは、ファイル内のファイルシステムとして表示することができます。ファイルシステム内のないすべてのブロックが使用されているので、使用されなくなったブロックを再利用する機会があります。ブロックの割り当てを解除するための呼び出しは、優れたスペース効率につながる可能性。少ないスペースには、ブロック割り当て解除後のバックアップのために消費される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following attribute and operation can be used to resolve these issues:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の属性と操作は、これらの問題を解決するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
space_freed This attribute reports the space that would be freed when a file is deleted, taking block-sharing into consideration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
space_freedこの属性を考慮にブロックが共有取って、ファイルが削除されたときに解放されるだろうスペースを報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DEALLOCATE This operation deallocates the blocks backing a region of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DEALLOCATEは、この操作では、ファイルの領域にバックアップブロックの割り当てを解除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If space_used of a file is interpreted to mean the size in bytes of all disk blocks pointed to by the inode of the file, then shared blocks get double-counted, over-reporting the space utilization. This also has the adverse effect that the deletion of a file with shared blocks frees up less than space_used bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルのspace_used場合は、すべてのディスクブロックのサイズをバイト単位で意味に解釈されたファイルのiノードによって指さ、その後、共有ブロックは過報告スペースの使用率を、ダブルカウントされています。これは、共有ブロックとファイルの削除がspace_usedバイト未満解放悪影響を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On the other hand, if space_used is interpreted to mean the size in bytes of those disk blocks unique to the inode of the file, then shared blocks are not counted in any file, resulting in under-reporting of the space utilization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方、解釈さspace_used場合、ファイルのiノードに固有のこれらのディスクブロックのサイズ（バイト単位）を意味すると、その後、共有ブロックが空間利用の過少報告をもたらす、任意のファイルにカウントされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, two files, A and B, have 10 blocks each. Let six of these blocks be shared between them. Thus, the combined space utilized by the two files is 14 * BLOCK_SIZE bytes. In the former case, the combined space utilization of the two files would be reported as 20 * BLOCK_SIZE. However, deleting either would only result in 4 * BLOCK_SIZE being freed. Conversely, the latter interpretation would report that the space utilization is only 8 * BLOCK_SIZE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、二つのファイル、A及びBは、10個のブロックそれぞれを持っています。これらのブロックの6は、それらの間で共有されてみましょう。このように、二つのファイルが利用する組み合わせた空間は、14 * BLOCK_SIZEバイトです。前者の場合には、二つのファイルの合計容量使用率が20 *のBLOCK_SIZEとして報告されるだろう。しかし、どちらかを削除するだけで4 * BLOCK_SIZEが解放されていることになります。逆に、後者の解釈は、スペースの使用率がわずか8 *のBLOCK_SIZEであることを報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using the space_freed attribute (see Section 12.2.2) is helpful in solving this problem. space_freed is the number of blocks that are allocated to the given file that would be freed on its deletion. In the example, both A and B would report space_freed as 4 * BLOCK_SIZE and space_used as 10 * BLOCK_SIZE. If A is deleted, B will report space_freed as 10 * BLOCK_SIZE, as the deletion of B would result in the deallocation of all 10 blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（12.2.2を参照）space_freed属性を使用することで、この問題を解決するのに役立ちます。 space_freedは、その削除に解放されるだろう与えられたファイルに割り当てられたブロックの数です。一例では、AとBの両方が4 * BLOCK_SIZEとしてspace_freed 10 * BLOCK_SIZEとしてspace_used報告します。 Aが削除された場合、BはBの削除は、すべての10個のブロックの解放につながるとして、10 * BLOCK_SIZEとしてspace_freedを報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using the space_freed attribute does not solve the problem of space being over-reported. However, over-reporting is better than under-reporting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
space_freed属性を使用すると、上に報告された空間の問題を解決していません。しかし、過報告過少報告よりも優れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Application Data Block Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.アプリケーションのデータ・ブロックのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At the OS level, files are contained on disk blocks. Applications are also free to impose structure on the data contained in a file and thus can define an Application Data Block (ADB) to be such a structure. From the application&#39;s viewpoint, it only wants to handle ADBs and not raw bytes (see [Strohm11]). An ADB is typically
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OSレベルでは、ファイルがディスクブロックに含まれています。アプリケーションは、ファイルに含まれるデータに構造を課すことは自由であり、したがって、アプリケーションデータブロック（ADB）は、このような構造であると定義することができます。アプリケーションの観点からは、それだけで（[Strohm11]参照）のADBはなく生のバイトを処理したいと考えています。 ADBは、一般的です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
comprised of two sections: header and data. The header describes the characteristics of the block and can provide a means to detect corruption in the data payload. The data section is typically initialized to all zeros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヘッダとデータの2つのセクションからなります。ヘッダは、ブロックの特性を説明し、データペイロードの破損を検出するための手段を提供することができます。データセクションは、一般的にすべてゼロに初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The format of the header is application specific, but there are two main components typically encountered:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヘッダのフォーマットは、アプリケーション固有であるが、一般的に遭遇する2つの主要なコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. An Application Data Block Number (ADBN), which allows the application to determine which data block is being referenced. This is useful when the client is not storing the blocks in contiguous memory, i.e., a logical block number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは、ブロックが参照されているデータを決定することを可能にする1】アプリケーションデータブロック番号（ADBN）。クライアントは、すなわち、論理ブロック番号を連続したメモリ内のブロックを格納していない場合に便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Fields to describe the state of the ADB and a means to detect block corruption. For both pieces of data, a useful property would be that the allowed values are specially selected so that, if passed across the network, corruption due to translation between big-endian and little-endian architectures is detectable. For example, 0xf0dedef0 has the same (32 wide) bit pattern in both architectures, making it inappropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ADBの状態とブロックの破損を検出するための手段を説明する2フィールド。データの両方の部分については、有用な特性は、ネットワーク、汚職全体に渡された場合、許可された値は、特別に検出可能であるため、ビッグエンディアンとリトルエンディアンアーキテクチャ間の翻訳に、なるように選択されていることだろう。例えば、それは不適切なって、両方のアーキテクチャにおいて同じ（32幅）ビットパターンを0xf0dedef0有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Applications already impose structures on files [Strohm11] and detect corruption in data blocks [Ashdown08]. What they are not able to do is efficiently transfer and store ADBs. To initialize a file with ADBs, the client must send each full ADB to the server, and that must be stored on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは、既に[Strohm11]ファイル上の構造を課し、データブロック[Ashdown08]の破損を検出します。彼らは何を行うことができないことは、効率的のADBを転送して保存しています。 ADBでファイルを初期化するには、クライアントがサーバーに各完全ADBを送信する必要があり、それは、サーバー上に保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section defines a framework for transferring the ADB from client to server and presents one approach to detecting corruption in a given ADB implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、クライアントからサーバにADBを転送するためのフレームワークを定義し、所与ADB実装で破損を検出するための一つのアプローチを提示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Generic Framework
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。一般的なフレームワーク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The representation of the ADB needs to be flexible enough to support many different applications. The most basic approach is no imposition of a block at all, which entails working with the raw bytes. Such an approach would be useful for storing holes, punching holes, etc. In more complex deployments, a server might be supporting multiple applications, each with their own definition of the ADB. One might store the ADBN at the start of the block and then have a guard pattern to detect corruption [Section 11.4.3: Detecting Memory Corruption&#34;&#34;&gt;McDougall07]. The next might store the ADBN at an offset of 100 bytes within the block and have no guard pattern at all, i.e., existing applications might already have well-defined formats for their data blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ADBの表現は、多くの異なるアプリケーションをサポートするのに十分柔軟である必要があります。最も基本的なアプローチは、生のバイトで作業を伴い、すべてのブロック、のない賦課されません。そのようなアプローチは、より複雑な展開では、サーバは複数のアプリケーション、ADBの独自の定義とそれぞれを支持するかもしれないなど、穴をパンチング孔を格納するために有用であろう。一つは、ブロックの開始時にADBNを格納し、腐敗[11.4.3項：メモリー破壊の検出「」&gt; McDougall07]を検出するガードパターンを持っているかもしれません。次の、すなわち、既存のアプリケーションは、既にデータブロックのフォーマットを明確に定義されている可能性があり、ブロック内の100バイトのオフセットでADBNを格納し、全くガードパターンを有していないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The guard pattern can be used to represent the state of the block, to protect against corruption, or both. Again, it needs to be able to be placed anywhere within the ADB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ガードパターンが破損、またはその両方から保護するために、ブロックの状態を表すために使用することができます。ここでも、ADB内のどこにでも置くことができるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Both the starting offset of the block and the size of the block need to be represented. Note that nothing prevents the application from defining different-sized blocks in a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
両方のブロックのオフセットとブロックの大きさが表現される必要が開始されます。何もファイルに異なるサイズのブロックを定義からアプリケーションを妨げないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. Data Block Representation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1。データブロック表現
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct app_data_block4 {
           offset4         adb_offset;
           length4         adb_block_size;
           length4         adb_block_count;
           length4         adb_reloff_blocknum;
           count4          adb_block_num;
           length4         adb_reloff_pattern;
           opaque          adb_pattern&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The app_data_block4 structure captures the abstraction presented for the ADB. The additional fields present are to allow the transmission of adb_block_count ADBs at one time. The adb_block_num is used to convey the ADBN of the first block in the sequence. Each ADB will contain the same adb_pattern string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
app_data_block4構造は、ADBのために提示抽象化をキャプチャします。存在する追加のフィールドが一度にadb_block_countののADBの伝送を可能にしています。 adb_block_numは、シーケンス内の最初のブロックのADBNを伝えるために使用されます。各ADBは同じadb_pattern文字列が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As both adb_block_num and adb_pattern are optional, if either adb_reloff_pattern or adb_reloff_blocknum is set to NFS4_UINT64_MAX, then the corresponding field is not set in any of the ADBs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
adb_block_numとadb_pattern両方がオプションであるのいずれかadb_reloff_pattern又はadb_reloff_blocknumがNFS4_UINT64_MAXに設定されている場合、次いで、対応するフィールドは、のADBのいずれかに設定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. An Example of Detecting Corruption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。検出汚職の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this section, an example ADB format is defined in which corruption can be detected. Note that this is just one possible format and means to detect corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、例えばADBフォーマットを検出することができる破損に定義されています。これはただ一つの可能​​な形式で、破損を検出することを意味することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider a very basic implementation of an operating system&#39;s disk blocks. A block is either data or an indirect block that allows for files that are larger than one block. It is desired to be able to initialize a block. Lastly, to quickly unlink a file, a block can be marked invalid. The contents remain intact; this would enable the OS application in question to undelete a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレーティングシステムのディスクブロックの非常に基本的な実装を考えてみましょう。ブロックは、データや1つのブロックよりも大きいファイルを可能にし、間接ブロックのいずれかです。ブロックを初期化することができることが望ましいです。最後に、すぐにファイルのリンクを解除するために、ブロックを無効とマークすることができます。内容はそのまま残ります。これは、ファイルの削除を取り消すには、問題になっているOSのアプリケーションを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The application defines 4K-sized data blocks, with an 8-byte block counter occurring at offset 0 in the block, and with the guard pattern occurring at offset 8 inside the block. Furthermore, the guard pattern can take one of four states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
で発生する8バイトのブロックカウンタがブロック内、及びガードパターンがブロック内のオフセット8に発生すると0をオフセットして、アプリケーションは、4Kサイズのデータ​​ブロックを定義します。さらに、ガードパターンは、の4つの状態のいずれかを取ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
0xfeedface - This is the FREE state and indicates that the ADB format has been applied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0xfeedface  - これはFREE状態で、ADBのフォーマットが適用されていることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
0xcafedead - This is the DATA state and indicates that real data has been written to this block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0xcafedead  - これは、データの状態で、実際のデータは、このブロックに書き込まれていることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
0xe4e5c001 - This is the INDIRECT state and indicates that the block contains block counter numbers that are chained off of this block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0xe4e5c001  - これは間接的な状態で、ブロックは、このブロックのオフに連鎖されているブロックカウンタ番号が含まれていることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
0xba1ed4a3 - This is the INVALID state and indicates that the block contains data whose contents are garbage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0xba1ed4a3  - これは無効な状態であり、ブロックがその内容ごみデータが含まれていることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finally, it also defines an 8-byte checksum starting at byte 16 that applies to the remaining contents of the block (see [Baira08] for an example of using checksums to detect data corruption). If the state is FREE, then that checksum is trivially zero. As such, the application has no need to transfer the checksum implicitly inside the ADB -- it need not make the transfer layer aware of the fact that there is a checksum (see [Ashdown08] for an example of checksums used to detect corruption in application data blocks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後に、それはまた、ブロックの残りの内容に適用されるバイト16で始まる8バイトのチェックサムを（[Baira08]データの破損を検出するためにチェックサムを使用する例を参照）を定義します。状態が空いている場合は、そのチェックサムは自明ゼロです。このように、アプリケーションは、ADB内部暗黙的にチェックサムを転送する必要がない - それはチェックサムが存在するという事実の認識転写層を作る必要はない（アプリケーションの破損を検出するために使用されるチェックサムの例えば[Ashdown08]参照データ・ブロック）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Corruption in each ADB can thus be detected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ADBの破損は、このように検出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the guard pattern is anything other than one of the allowed values, including all zeros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oガードパターンは、すべてゼロを含む許可された値の1以外の場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the guard pattern is FREE and any other byte in the remainder of the ADB is anything other than zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oガードパターンは無料で、ADBの残りの部分で他のバイトがゼロ以外である場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the guard pattern is anything other than FREE, then if the stored checksum does not match the computed checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ガードパターンがFREE以外の場合は、O、その後、保存されたチェックサムが計算されたチェックサムと一致しない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the guard pattern is INDIRECT and one of the stored indirect block numbers has a value greater than the number of ADBs in the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oガードパターンは間接的であると記憶されている間接ブロック番号のいずれかは、ファイル内のADBの数よりも大きい値を有する場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the guard pattern is INDIRECT and one of the stored indirect block numbers is a duplicate of another stored indirect block number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oガードパターンは間接的であると記憶されている間接ブロック番号のいずれかは、他の記憶された間接ブロック番号の重複している場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As can be seen, the application can detect errors based on the combination of the guard pattern state and the checksum but also can detect corruption based on the state and the contents of the ADB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図から分かるように、アプリケーションは、ガードパターン状態およびチェックサムの組み合わせに基づいてエラーを検出することができるだけでなく、状態及びADBの内容に基づいて破損を検出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This last point is important in validating the minimum amount of data incorporated into the generic framework. That is, the guard pattern is sufficient in allowing applications to design their own corruption detection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この最後の点は、一般的なフレームワークに組み込まれたデータの最小量を検証する上で重要です。つまり、ガードパターンは、アプリケーションが独自の腐敗検出を設計することが可能で十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finally, it is important to note that none of these corruption checks occur in the transport layer. The server and client components are totally unaware of the file format and might report everything as being transferred correctly, even in cases where the application detects corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後に、これらの破損チェックのどれもが、トランスポート層で発生していないことに注意することが重要です。サーバーとクライアントのコンポーネントは、ファイルフォーマットの全く気付いていないと正しく転送されるようにアプリケーションが破損を検出した場合であっても、すべてを報告することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. An Example of READ_PLUS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3。 READ_PLUSの例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The hypothetical application presented in Section 8.2 can be used to illustrate how READ_PLUS would return an array of results. A file is created and initialized with 100 4K ADBs in the FREE state with the WRITE_SAME operation (see Section 15.12):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
8.2節で提示架空のアプリケーションがREAD_PLUSは、結果の配列を返す方法を説明するために使用することができます。ファイルが作成され、WRITE_SAME動作とFREE状態で100の4KのADBで初期化されます（項15.12を参照してください）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME {0, 4K, 100, 0, 0, 8, 0xfeedface}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME {0、4K、100、0、0、8、0xfeedface}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Further, assume that the application writes a single ADB at 16K, changing the guard pattern to 0xcafedead; then there would be in memory:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、アプリケーションは0xcafedeadするガードパターンを変更する、16Kで単一ADBを書き込むと仮定する。その後、メモリ内に存在することになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 0K -&gt; (4K - 1) : 00 00 00 00 ... fe ed fa ce 00 00 ... 00 4K -&gt; (8K - 1) : 00 00 00 01 ... fe ed fa ce 00 00 ... 00 8K -&gt; (12K - 1) : 00 00 00 02 ... fe ed fa ce 00 00 ... 00 12K -&gt; (16K - 1) : 00 00 00 03 ... fe ed fa ce 00 00 ... 00 16K -&gt; (20K - 1) : 00 00 00 04 ... ca fe de ad 00 00 ... 00 20K -&gt; (24K - 1) : 00 00 00 05 ... fe ed fa ce 00 00 ... 00 24K -&gt; (28K - 1) : 00 00 00 06 ... fe ed fa ce 00 00 ... 00 ... 396K -&gt; (400K - 1) : 00 00 00 63 ... fe ed fa ce 00 00 ... 00
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0K  - &gt;（4K  -  1）：00 00 00 00 ... Feとがある... 00 00 00 4K  - &gt;（8K  -  1）：00 00 00 01 ... Feおよび00がある.. 00 。00 8K  - &gt;（12K  -  1）：00 00 00 02 ... FEとがあり... 00 00 00 12K  - &gt;（16K  -  1）：00 00 00 03 ... FEと00 00があります... 16K 00  - &gt;（20K  -  1）：00 00 00 04 ... CA FEド00 00 ... 00 20K  - &gt;（24K  -  1）：00 00 00 05 ... Feとがあります00 00 ... 00 24K  - &gt;（28K  -  1）：00 00 00 06 ... Feとがある... 00 00 00 ... 396K  - &gt;（400K  -  1）：00 00 00 63 .. 。Feとがあり... 00 00 00
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
And when the client did a READ_PLUS of 64K at the start of the file, it could get back a result of data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、ファイルの先頭に64KのREAD_PLUSをしたとき、それはデータの結果を取り戻すことができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 0K -&gt; (4K - 1) : 00 00 00 00 ... fe ed fa ce 00 00 ... 00 4K -&gt; (8K - 1) : 00 00 00 01 ... fe ed fa ce 00 00 ... 00 8K -&gt; (12K - 1) : 00 00 00 02 ... fe ed fa ce 00 00 ... 00 12K -&gt; (16K - 1) : 00 00 00 03 ... fe ed fa ce 00 00 ... 00 16K -&gt; (20K - 1) : 00 00 00 04 ... ca fe de ad 00 00 ... 00 20K -&gt; (24K - 1) : 00 00 00 05 ... fe ed fa ce 00 00 ... 00 24K -&gt; (28K - 1) : 00 00 00 06 ... fe ed fa ce 00 00 ... 00 ... 62K -&gt; (64K - 1) : 00 00 00 15 ... fe ed fa ce 00 00 ... 00
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0K  - &gt;（4K  -  1）：00 00 00 00 ... Feとがある... 00 00 00 4K  - &gt;（8K  -  1）：00 00 00 01 ... Feおよび00がある.. 00 。00 8K  - &gt;（12K  -  1）：00 00 00 02 ... FEとがあり... 00 00 00 12K  - &gt;（16K  -  1）：00 00 00 03 ... FEと00 00があります... 16K 00  - &gt;（20K  -  1）：00 00 00 04 ... CA FEド00 00 ... 00 20K  - &gt;（24K  -  1）：00 00 00 05 ... Feとがあります00 00 ... 00 24K  - &gt;（28K  -  1）：00 00 00 06 ... Feとがある... 00 00 00 ... 62K  - &gt;（64K  -  1）：00 00 00 15 .. 。Feとがあり... 00 00 00
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. An Example of Zeroing Space
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4。ゼロ化空間の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A simpler use case for WRITE_SAME is applications that want to efficiently zero out a file, but do not want to modify space reservations. This can easily be achieved by a call to WRITE_SAME without an ADB block numbers and pattern, e.g.:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAMEのためのシンプルなユースケースは、効率的にファイルをゼロにするアプリケーションですが、スペースの予約を変更する必要はありません。これは簡単に例えばADBブロック番号及びパターンなしWRITE_SAMEにコールすることによって達成することができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME {0, 1K, 10000, 0, 0, 0, 0}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME {0、1K、10000、0、0、0、0}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Labeled NFS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.標識NFS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Access control models such as UNIX permissions or Access Control Lists (ACLs) are commonly referred to as Discretionary Access Control (DAC) models. These systems base their access decisions on user identity and resource ownership. In contrast, Mandatory Access Control (MAC) models base their access control decisions on the label on the subject (usually a process) and the object it wishes to access [RFC4949]. These labels may contain user identity information but usually contain additional information. In DAC systems, users are free to specify the access rules for resources that they own. MAC models base their security decisions on a system-wide policy -- established by an administrator or organization -- that the users do not have the ability to override. In this section, a MAC model is added to NFSv4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのようなUNIX許可またはアクセス制御リスト（ACL）などのアクセス制御モデルは、一般的に随意アクセス制御（DAC）モデルと呼ばれます。これらのシステムは、ユーザーIDおよびリソースの所有権上のアクセスの決定をベースにします。対照的に、強制アクセス制御（MAC）モデルは、対象（通常処理）、それは[RFC4949]をアクセスしたいオブジェクトのラベルにそのアクセス制御決定の基礎。これらのラベルは、ユーザーID情報が含まれていますが、通常は、追加情報が含まれていてもよいです。 DACシステムでは、ユーザーが所有するリソースに対するアクセスルールを指定するのは自由です。 MACモデルは、システム全体のポリシーに、セキュリティ上の決定を基づか - 管理者または組織によって確立 - ユーザーがオーバーライドする機能を持っていないこと。このセクションでは、MACモデルはNFSv4.2に添加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First, a method is provided for transporting and storing security label data on NFSv4 file objects. Security labels have several semantics that are met by NFSv4 recommended attributes such as the ability to set the label value upon object creation. Access control on these attributes is done through a combination of two mechanisms. As with other recommended attributes on file objects, the usual DAC checks, based on the ACLs and permission bits, will be performed to ensure that proper file ownership is enforced. In addition, a MAC system MAY be employed on the client, server, or both to enforce additional policy on what subjects may modify security label information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、この方法は、NFSv4のファイルオブジェクトにセキュリティラベルデータを転送し、記憶するために設けられています。セキュリティラベルは、NFSv4ので満たされているいくつかのセマンティクスは、このようなオブジェクトの作成時にラベル値を設定する機能などの属性を推奨しています。これらの属性のアクセス制御は、二つのメカニズムの組み合わせを介して行われます。ファイルオブジェクトの他の推奨属性と同様に、ACLおよびパーミッションビットに基づいて、通常のDACチェックは、適切なファイルの所有権が適用されることを保証するために行われます。また、MACシステムは、セキュリティラベル情報を変更することができるものを対象に追加のポリシーを適用するために、クライアント、サーバー、またはその両方に使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Second, a method is described for the client to determine if an NFSv4 file object security label has changed. A client that needs to know if a label on a file or set of files is going to change SHOULD request a delegation on each labeled file. In order to change such a security label, the server will have to recall delegations on any file affected by the label change, so informing clients of the label change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第二に、この方法は、NFSv4のファイルオブジェクトのセキュリティ・ラベルが変更されているかどうかを判断するために、クライアントのために記述されています。ファイルまたはファイルの集合のラベルを変更しようとしているかどうかを知る必要があるクライアントは、ラベル付けされた各ファイルに対して委任を要求する必要があります。このようなセキュリティラベルを変更するためには、サーバーは、そのラベルの変更をクライアントに通知する、ラベル変更によって影響を受けるすべてのファイルに対して委任をリコールする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An additional useful feature would be modification to the RPC layer used by NFSv4 to allow RPCs to assert client process subject security labels and enable the enforcement of Full Mode as described in Section 9.5.1. Such modifications are outside the scope of this document (see [RFC7861]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
追加の便利な機能は、RPCは、クライアント・プロセスのサブジェクトのセキュリティラベルを主張し、9.5.1項で説明したようにフルモードの施行を可能にできるようにするためにはNFSv4で使用されるRPC層への修正されるだろう。そのような修飾は、（[RFC7861]を参照）は、この文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Label Format Specifier (LFS): an identifier used by the client to establish the syntactic format of the security label and the semantic meaning of its components. LFSs exist in a registry associated with documents describing the format and semantics of the label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ラベルフォーマット指定子（LFS）：セキュリティラベルの構文形式とそのコンポーネントのセマンティックな意味を確立するためにクライアントが使用する識別子。 LFSsは、ラベルの形式と意味論を記述した文書に関連付けられているレジストリ内に存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Security Label Format Selection Registry: the IANA registry (see [RFC7569]) containing all registered LFSs, along with references to the documents that describe the syntactic format and semantics of the security label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティラベルフォーマット選択レジストリ：IANAレジストリ（[RFC7569]を参照）、すべての登録LFSsを含む、セキュリティラベルの構文形式と意味論を記述したドキュメントへの参照と一緒に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Policy Identifier (PI): an optional part of the definition of an LFS. The PI allows clients and servers to identify specific security policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポリシー識別子（PI）：LFSの定義のオプション部分。 PIは、クライアントとサーバは、特定のセキュリティポリシーを識別することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Object: a passive resource within the system that is to be protected. Objects can be entities such as files, directories, pipes, sockets, and many other system resources relevant to the protection of the system state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オブジェクト：保護されているシステム内の受動的な資源。オブジェクトは、ファイル、ディレクトリ、パイプ、ソケット、およびシステム状態の保護に関連する他の多くのシステムリソースなどのエンティティすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Subject: an active entity, usually a process that is requesting access to an object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
被験者：アクティブエンティティ、オブジェクトへのアクセスを要求している通常のプロセス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAC-Aware: a server that can transmit and store object labels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAC-Awareの：送信することができ、サーバとストアオブジェクトのラベル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAC-Functional: a client or server that is Labeled NFS enabled. Such a system can interpret labels and apply policies based on the security system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAC-機能：NFSを有効に標識されたクライアントまたはサーバ。このようなシステムは、ラベルを解釈し、セキュリティシステムに基づいてポリシーを適用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multi-Level Security (MLS): a traditional model where objects are given a sensitivity level (Unclassified, Secret, Top Secret, etc.) and a category set (see [LB96], [RFC1108], [RFC2401], and [RFC4949]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチレベルセキュリティ（MLS）：オブジェクトは感度レベルを与えられている伝統的なモデル（、シークレット、トップシークレット、その他未分類）およびカテゴリセットは、（[LB96]、[RFC1108]、[RFC2401]、および[RFC4949を参照してください]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(Note: RFC 2401 has been obsoleted by RFC 4301, but we list RFC 2401 here because RFC 4301 does not discuss MLS.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（注：RFC 2401はRFC 4301で廃止されましたが、RFC 4301がMLSを議論していないため、我々はここにRFC 2401をリストします。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. MAC Security Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。 MACセキュリティ属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAC models base access decisions on security attributes bound to subjects (usually processes) and objects (for NFS, file objects). This information can range from a user identity for an identity-based MAC model, sensitivity levels for MLS, or a type for type enforcement. These models base their decisions on different criteria, but the semantics of the security attribute remain the same. The semantics required by the security attribute are listed below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MACモデルベースアクセス被験者にバインドされたセキュリティ属性の決定（通常処理）とオブジェクト（NFSのため、ファイルオブジェクト）。この情報は、IDベースのMACモデル、MLSの感度レベル、またはタイプの施行のためのタイプのユーザーIDの範囲とすることができます。これらのモデルは、さまざまな基準にその判断を下すことになるが、セキュリティ属性の意味は同じまま。セキュリティ属性によって必要な意味は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o MUST provide flexibility with respect to the MAC model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
oはMACモデルに対する柔軟性を提供しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o MUST provide the ability to atomically set security information upon object creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
oはアトミックオブジェクトの作成時にセキュリティ情報を設定する機能を提供しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o MUST provide the ability to enforce access control decisions on both the client and the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
oは、クライアントとサーバーの両方でアクセス制御の決定を執行する能力を提供しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o MUST NOT expose an object to either the client or server namespace before its security information has been bound to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのセキュリティ情報は、それにバインドされている前に、oは、クライアントまたはサーバの名前空間のいずれかにオブジェクトを公開してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4 implements the MAC security attribute as a recommended attribute. This attribute has a fixed format and semantics, which conflicts with the flexible nature of security attributes in general. To resolve this, the MAC security attribute consists of two components. The first component is an LFS, as defined in [RFC7569], to allow for interoperability between MAC mechanisms. The second component is an opaque field, which is the actual security attribute data. To allow for various MAC models, NFSv4 should be used solely as a transport mechanism for the security attribute. It is the responsibility of the endpoints to consume the security attribute and make access decisions based on their respective models. In addition, creation of objects through OPEN and CREATE allows the security attribute to be specified upon creation. By providing an atomic create and set operation for the security attribute, it is possible to enforce the second and fourth requirements listed above. The recommended attribute FATTR4_SEC_LABEL (see Section 12.2.4) will be used to satisfy this requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のは、推奨属性としてMACセキュリティ属性を実装しています。この属性は、一般的にはセキュリティ属性の柔軟な性質と矛盾固定フォーマットと意味を持っています。これを解決するには、MACのセキュリティ属性は、2つのコンポーネントで構成されています。 MAC機構間の相互運用性を可能にするために、[RFC7569]で定義されるように、第1の成分は、LFSです。第二の成分は、実際のセキュリティ属性データである不透明なフィールドです。様々なMACモデルを可能にするため、NFSv4のは、セキュリティ属性のための転送メカニズムとしてのみ使用されるべきです。セキュリティ属性を消費し、それぞれのモデルに基づいてアクセス決定を行うために、エンドポイントの責任です。また、OPENを通じてオブジェクトの作成とCREATEは、セキュリティ属性は、作成時に指定することができます。セキュリティ属性の作成原子と設定された動作を提供することによって、上記第二及び第四の要件を適用することが可能です。推奨属性FATTR4_SEC_LABEL（項12.2.4を参照）、この要件を満たすために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1. Delegations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1。代表団
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the event that a security attribute is changed on the server while a client holds a delegation on the file, both the server and the client MUST follow the NFSv4.1 protocol (see Section 10 of [RFC5661]) with respect to attribute changes. It SHOULD flush all changes back to the server and relinquish the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、ファイルの委任を保持して、サーバーとクライアントの両方の属性の変更をすることに関しては（[RFC5661]のセクション10を参照）NFSv4.1プロトコルに従わなければならない。一方、セキュリティ属性がサーバー上で変更された場合にはこれは、サーバーへのすべての変更をバックフラッシュし、委任を放棄すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.2. Permission Checking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.2。アクセス権のチェック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is not feasible to enumerate all possible MAC models and even levels of protection within a subset of these models. This means that the NFSv4 client and servers cannot be expected to directly make access control decisions based on the security attribute. Instead, NFSv4 should defer permission checking on this attribute to the host system. These checks are performed in addition to existing DAC and ACL checks outlined in the NFSv4 protocol. Section 9.5 gives a specific example of how the security attribute is handled under a particular MAC model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのモデルのサブセット内のすべての可能なMACモデルと保護のさえレベルを列挙することは不可能です。これは、NFSv4クライアントとサーバーが直接セキュリティ属性に基づいてアクセス制御の決定を行うことが期待できないことを意味します。代わりに、NFSv4のは、ホストシステムにこの属性に許可のチェックを延期すべきです。これらのチェックは、NFSv4のプロトコルで概説既存のDACとACLチェックに加えて実行されます。 9.5節は、セキュリティ属性が特定のMACモデルの下でどのように扱われるかの具体的な例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.3. Object Creation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.3。オブジェクトの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When creating files in NFSv4, the OPEN and CREATE operations are used. One of the parameters for these operations is an fattr4 structure containing the attributes the file is to be created with. This allows NFSv4 to atomically set the security attribute of files upon creation. When a client is MAC-Functional, it must always provide the initial security attribute upon file creation. In the event that the server is MAC-Functional as well, it should determine by policy whether it will accept the attribute from the client or instead make the determination itself. If the client is not MAC-Functional, then the MAC-Functional server must decide on a default label. A more in-depth explanation can be found in Section 9.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4では、OPENのファイルを作成し、CREATE操作が使用されています。これらの操作のためのパラメータの1つは、ファイルを使用して作成される属性を含むfattr4構造です。これは、NFSv4のがアトミック作成時にファイルのセキュリティ属性を設定することができます。クライアントがMAC-機能しているとき、それは常に、ファイル作成時の初期セキュリティ属性を提供しなければなりません。サーバーは同様にMAC-機能である場合には、それがクライアントから属性を受け入れるか、代わりに決定自体を行うかどうかのポリシーによって決定すべきです。クライアントがMAC-機能していない場合は、MAC-機能サーバーはデフォルトのラベルに決定する必要があります。より詳細な説明は、9.5項に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.4. Existing Objects
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.4。既存のオブジェクト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that under the MAC model, all objects must have labels. Therefore, if an existing server is upgraded to include Labeled NFS support, then it is the responsibility of the security system to define the behavior for existing objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MACモデルで、すべてのオブジェクトがラベルを持たなければならないことに注意してください。既存のサーバーが標識NFSサポートを含めるようにアップグレードされている場合ので、それは、既存のオブジェクトの動作を定義するためのセキュリティシステムの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.5. Label Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.5。ラベルの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider a Guest Mode system (Section 9.5.3) in which the clients enforce MAC checks and the server has only a DAC security system that stores the labels along with the file data. In this type of system, a user with the appropriate DAC credentials on a client with poorly configured or disabled MAC labeling enforcement is allowed access to the file label (and data) on the server and can change the label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがMACチェックを実施し、サーバがファイルデータと一緒にラベルを保存するだけDACのセキュリティシステムを持っているゲストモードシステム（9.5.3項）を考えてみましょう。このタイプのシステムでは、構成された不完全または無効MACラベリング施行に伴い、クライアント上の適切なDACの資格情報を持つユーザーは、サーバー上のファイル・ラベル（およびデータ）へのアクセスを許可され、ラベルを変更することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients that need to know if a label on a file or set of files has changed SHOULD request a delegation on each labeled file so that a label change by another client will be known via the process described in Section 9.2.1, which must be followed: the delegation will be recalled, which effectively notifies the client of the change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従わなければならない別のクライアントによるラベルの変更は9.2.1項で説明した工程を経て知られるように変更されたファイルまたはファイルのセットのラベルがラベル付けされた各ファイルに対して委任を要求すべきかどうかを知る必要があるクライアント、 ：代表団は、効果的に変更をクライアントに通知され、リコールされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the MAC security policies on a client can be such that the client does not have access to the file unless it has a delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは委任を持っていない限り、クライアントのMACのセキュリティポリシーは、クライアントがファイルにアクセスできないようにすることができることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. pNFS Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3。 pNFSの上の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The new FATTR4_SEC_LABEL attribute is metadata information, and as such the storage device is not aware of the value contained on the metadata server. Fortunately, the NFSv4.1 protocol [RFC5661] already has provisions for doing access-level checks from the storage device to the metadata server. In order for the storage device to validate the subject label presented by the client, it SHOULD utilize this mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいFATTR4_SEC_LABEL属性は、メタデータの情報であり、そのようなストレージデバイスとしてのメタデータ・サーバに含まれている値を認識しません。幸いなことに、NFSv4.1プロトコル[RFC5661]は既にメタデータサーバに記憶装置からアクセスレベル検査を行うための設備を有しています。クライアントによって提示された主題のラベルを検証するためのストレージデバイスのためには、このメカニズムを利用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. Discovery of Server Labeled NFS Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4。サーバーの発見標識NFSサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server can easily determine that a client supports Labeled NFS when it queries for the FATTR4_SEC_LABEL label for an object. Further, it can then determine which LFS the client understands. The client might want to discover whether the server supports Labeled NFS and which LFS the server supports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは簡単にそれがオブジェクトのFATTR4_SEC_LABELラベルを照会する場合、クライアントはNFSをサポートして標識することを決定することができます。さらに、それは、クライアントが理解LFSを決定することができます。クライアントは、サーバーがNFSを標識しているサーバーがサポートをLFSをサポートしているかどうかを発見することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following COMPOUND MUST NOT be denied by any MAC label check:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の化合物は、任意のMACラベルのチェックによって拒否されてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTROOTFH, GETATTR {FATTR4_SEC_LABEL}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PUTROOTFH、GETATTR {FATTR4_SEC_LABEL}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the server might have imposed a security flavor on the root that precludes such access. That is, if the server requires Kerberized access and the client presents a COMPOUND with AUTH_SYS, then the server is allowed to return NFS4ERR_WRONGSEC in this case. But if the client presents a correct security flavor, then the server MUST return the FATTR4_SEC_LABEL attribute with the supported LFS filled in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがそのようなアクセスを排除するルート上のセキュリティ風味を課している場合があります。サーバーは、Kerberos対応のアクセスを必要とし、クライアントがAUTH_SYSを有する化合物を提供する場合には、その後、サーバは、この場合にNFS4ERR_WRONGSECを返すことが許されています。クライアントは、正しいセキュリティ風味を提示した場合でも、サーバはサポートに充填LFSでFATTR4_SEC_LABEL属性を返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. MAC Security NFS Modes of Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5。操作のMACセキュリティNFSモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A system using Labeled NFS may operate in three modes (see Section 4 of [RFC7204]). The first mode provides the most protection and is called &#34;Full Mode&#34;. In this mode, both the client and server implement a MAC model allowing each end to make an access control decision. The second mode is a subset of the Full Mode and is called &#34;Limited Server Mode&#34;. In this mode, the server cannot enforce the labels, but it can store and transmit them. The remaining mode is called the &#34;Guest Mode&#34;; in this mode, one end of the connection is not implementing a MAC model and thus offers less protection than Full Mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
標識されたNFSを使用するシステムは、（[RFC7204]のセクション4を参照）は、3つのモードで動作することができます。第1のモードは、ほとんどの保護を提供し、「フルモード」と呼ばれています。このモードでは、クライアントとサーバの両方は、アクセス制御決定を行うために、各エンドを可能MACモデルを実装しています。第2のモードはフルモードのサブセットであり、「リミテッドサーバーモード」と呼ばれています。このモードでは、サーバーは、ラベルを強制することはできませんが、それはそれらを格納して送信することができます。残りのモードは、「ゲストモード」と呼ばれています。このモードでは、接続の一端は、MACモデルを実装するため、フルモードよりも少ない保護を提供されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1. Full Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1。フルモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Full Mode environments consist of MAC-Functional NFSv4 servers and clients and may be composed of mixed MAC models and policies. The system requires that both the client and server have an opportunity to perform an access control check based on all relevant information within the network. The file object security attribute is provided using the mechanism described in Section 9.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フルモード環境はMAC-機能のNFSv4サーバとクライアントで構成され、混合MACモデルとポリシーで構成することができます。システムは、クライアントとサーバの両方がネットワーク内のすべての関連情報に基づいてアクセス制御チェックを実行する機会を持つことが必要です。ファイルオブジェクトのセキュリティ属性は、9.2節で説明したメカニズムを使用して提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fully MAC-Functional NFSv4 servers are not possible in the absence of RPCSEC_GSSv3 [RFC7861] support for client process subject label assertion. However, servers may make decisions based on the RPC credential information available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全MAC-機能のNFSv4サーバはクライアントプロセス対象ラベル表明のためのRPCSEC_GSSv3 [RFC7861]のサポートが存在しない場合に可能ではありません。しかし、サーバが利用できるRPC資格情報に基づいて意思決定を行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1.1. Initial Labeling and Translation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1.1。初期のラベルと翻訳
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ability to create a file is an action that a MAC model may wish to mediate. The client is given the responsibility to determine the initial security attribute to be placed on a file. This allows the client to make a decision as to the acceptable security attribute to create a file with before sending the request to the server. Once the server receives the creation request from the client, it may choose to evaluate if the security attribute is acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルを作成する機能は、MACモデルが仲介することを望むかもしれないアクションです。クライアントは、ファイルの上に配置する最初のセキュリティ属性を決定する責任を与えられています。これは、クライアントがサーバに要求を送信する前にファイルを作成するための許容可能なセキュリティ属性に関する決定を行うことができます。サーバがクライアントからの作成要求を受信すると、セキュリティ属性が許容されるかどうかを評価することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Security attributes on the client and server may vary based on MAC model and policy. To handle this, the security attribute field has an LFS component. This component is a mechanism for the host to identify the format and meaning of the opaque portion of the security attribute. A Full Mode environment may contain hosts operating in several different LFSs. In this case, a mechanism for translating the opaque portion of the security attribute is needed. The actual translation function will vary based on MAC model and policy and is outside the scope of this document. If a translation is unavailable for a given LFS, then the request MUST be denied. Another recourse is to allow the host to provide a fallback mapping for unknown security attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバー上のセキュリティ属性は、MACモデルとポリシーに基づいて変化させることができます。これに対処するには、セキュリティ属性フィールドは、LFSの成分を有しています。このコンポーネントは、セキュリティ属性の不透明部分の形式と意味を識別するためにホストするためのメカニズムです。フルモード環境は、いくつかの異なるLFSsで動作するホストが含まれていてもよいです。この場合は、セキュリティ属性の不透明な部分を翻訳するためのメカニズムが必要とされています。実際の翻訳機能は、MACモデルとポリシーに基づいて、このドキュメントの範囲外で異なります。翻訳が与えられたLFSのために利用できない場合、その要求は拒否されなければなりません。もう一つの頼みの綱は、ホストが未知のセキュリティ属性のフォールバックマッピングを提供できるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1.2. Policy Enforcement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1.2。ポリシー施行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In Full Mode, access control decisions are made by both the clients and servers. When a client makes a request, it takes the security attribute from the requesting process and makes an access control decision based on that attribute and the security attribute of the object it is trying to access. If the client denies that access, an RPC to the server is never made. If, however, the access is allowed, the client will make a call to the NFS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フルモードでは、アクセス制御の決定は、クライアントとサーバの両方で作られています。クライアントが要求を行うと、それは要求プロセスのセキュリティ属性を取り、その属性とそれがアクセスしようとしているオブジェクトのセキュリティ属性に基づいたアクセス制御決定を行います。クライアントがアクセスを拒否した場合は、サーバへのRPCが行われることはありません。しかし、アクセスが許可されている場合、クライアントは、NFSサーバーへの呼び出しを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server receives the request from the client, it uses any credential information conveyed in the RPC request and the attributes of the object the client is trying to access to make an access control decision. If the server&#39;s policy allows this access, it will fulfill the client&#39;s request; otherwise, it will return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはクライアントからの要求を受信すると、RPC要求し、クライアントがアクセス制御決定を行うためにアクセスしようとしているオブジェクトの属性に搬送任意の資格情報を使用しています。サーバのポリシーがこのアクセスを許可している場合、それはクライアントの要求を満たすだろう。それ以外の場合は、NFS4ERR_ACCESSを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Future protocol extensions may also allow the server to factor into the decision a security label extracted from the RPC request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
将来のプロトコル拡張は、サーバーは、セキュリティラベルは、RPC要求から抽出された意思決定に考慮することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations MAY validate security attributes supplied over the network to ensure that they are within a set of attributes permitted from a specific peer and, if not, reject them. Note that a system may permit a different set of attributes to be accepted from each peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、彼らが特定のピアからの許可属性のセット内にあることを確実にするために、ネットワークを介して供給セキュリティ属性を検証し、そうでない場合は、それらを拒否することがあります。システムは、各ピアから受け入れられるように、属性の異なるセットを可能にすることができることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.2. Limited Server Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.2。リミテッドサーバモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Limited Server mode (see Section 4.2 of [RFC7204]) consists of a server that is label aware but does not enforce policies. Such a server will store and retrieve all object labels presented by clients and will utilize the methods described in Section 9.2.5 to allow the clients to detect changing labels, but may not factor the label into access decisions. Instead, it will expect the clients to enforce all such access locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リミテッドサーバーモードは、（[RFC7204]のセクション4.2を参照）を認識してラベルが、ポリシーを適用しないで、サーバーで構成されています。このようなサーバに格納され、クライアントによって提示されたすべてのオブジェクトのラベルを取得し、クライアントはラベルを変更するに検出できるようにするために、セクション9.2.5で説明した方法を利用しますが、アクセス決定に標識を考慮しないことがあります。その代わりに、クライアントはローカルでそのようなすべてのアクセスを強化することを期待します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.3. Guest Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.3。ゲストモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Guest Mode implies that either the client or the server does not handle labels. If the client is not Labeled NFS aware, then it will not offer subject labels to the server. The server is the only entity enforcing policy and may selectively provide standard NFS services to clients based on their authentication credentials and/or associated network attributes (e.g., IP address, network interface). The level of trust and access extended to a client in this mode is configuration specific. If the server is not Labeled NFS aware, then it will not return object labels to the client. Clients in this environment may consist of groups implementing different MAC model policies. The system requires that all clients in the environment be responsible for access control checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゲストモードは、クライアントまたはサーバのどちらかが、ラベルを処理しないことを意味します。クライアントが認識してNFSを標識されていない場合、それは、サーバーの対象とラベルを提供することはありません。サーバは、ポリシーを適用する唯一のエンティティであり、選択的に認証資格情報および/または関連するネットワーク属性（例えば、IPアドレス、ネットワークインターフェース）に基づいて、クライアントに、標準的なNFSサービスを提供してもよいです。このモードでは、クライアントに拡張信頼とアクセスのレベルは、コンフィギュレーション固有のものです。サーバが認識してNFSを標識されていない場合は、それがクライアントにオブジェクトのラベルを返しません。この環境でのクライアントは、異なるMACモデルの政策を実施グループから構成することができます。システムは、環境内のすべてのクライアントがアクセス制御チェックを担当することが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. Security Considerations for Labeled NFS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6。標識NFSのセキュリティに関する注意点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Depending on the level of protection the MAC system offers, there may be a requirement to tightly bind the security attribute to the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しっかりとデータへのセキュリティ属性をバインドするにはMACシステムが提供する保護のレベルに応じて、要件があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When only one of the client or server enforces labels, it is important to realize that the other side is not enforcing MAC protections. Alternate methods might be in use to handle the lack of MAC support, and care should be taken to identify and mitigate threats from possible tampering outside of these methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントまたはサーバの一方のみがラベルを強制するとき、他の側はMAC保護を強制されていないことを認識することが重要です。別の方法は、MACのサポートの欠如、及びケアは、これらの方法の可能性改ざん外部からの脅威を識別し、緩和するために取られるべきで処理するために使用されている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example of this is that a server that modifies READDIR or LOOKUP results based on the client&#39;s subject label might want to always construct the same subject label for a client that does not present one. This will prevent a non-Labeled NFS client from mixing entries in the directory cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この例では、クライアントの対象ラベルに基づいてREADDIRまたはLOOKUP結果を修正し、サーバが常に存在していない1を行い、クライアントのための同じ主題のラベルを作成したい場合がありますということです。これは、ディレクトリキャッシュ内のエントリを混合から非標識NFSクライアントを防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
10. Sharing Change Attribute Implementation Characteristics with NFSv4 Clients
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
10.共有の変更は、NFSv4クライアントを実装特性属性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although both the NFSv4 [RFC7530] and NFSv4.1 [RFC5661] protocols define the change attribute as being mandatory to implement, there is little in the way of guidance as to its construction. The only mandated constraint is that the value must change whenever the file data or metadata changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4の[RFC7530]とNFSv4.1 [RFC5661]の両方のプロトコルを実装するために必須であるとして変化属性を定義しますが、その構造についての指導の方法ではほとんどがあります。唯一の義務の制約は、いつでも、ファイルデータやメタデータの変更値を変更しなければならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While this allows for a wide range of implementations, it also leaves the client with no way to determine which is the most recent value for the change attribute in a case where several RPCs have been issued in parallel. In other words, if two COMPOUNDs, both containing WRITE and GETATTR requests for the same file, have been issued in parallel, how does the client determine which of the two change attribute values returned in the replies to the GETATTR requests corresponds to the most recent state of the file? In some cases, the only recourse may be to send another COMPOUND containing a third GETATTR that is fully serialized with the first two.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは実装の広い範囲を可能にしますが、それはまた、いくつかのRPCは、並列に発行された場合の変化属性の最新の値であるかを決定する方法はありませんし、クライアントを残します。言い換えれば、二つの化合物、同じファイルの両方含むWRITEとGETATTR要求は、クライアントがGETATTR要求に応答で返された値を属性は、最新のに対応して2つの変更のかを判断んどのように、並列に発行されている場合ファイルの状態？いくつかのケースでは、唯一の手段は、最初の2つに完全にシリアル化され第三のGETATTRを含む他の化合物を送信することであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2 avoids this kind of inefficiency by allowing the server to share details about how the change attribute is expected to evolve, so that the client may immediately determine which, out of the several change attribute values returned by the server, is the most recent. change_attr_type is defined as a new recommended attribute (see Section 12.2.3) and is a per-file system attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、すぐにサーバーから返されたいくつかの変化属性値のうち、最も最近である、決定することができるようにNFSv4.2は、サーバが変更属性が進化すると予想される方法の詳細を共有できるようにすることで、非効率のこの種のを回避します。 change_attr_typeは、新たな推奨属性として定義される（第12.2.3項を参照）、ファイルシステムごとの属性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Error Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.エラー値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS error numbers are assigned to failed operations within a COMPOUND (COMPOUND or CB_COMPOUND) request. A COMPOUND request contains a number of NFS operations that have their results encoded in sequence in a COMPOUND reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply and the COMPOUND request will be terminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSエラー番号は、化合物（化合物またはCB_COMPOUND）要求内で失敗した操作に割り当てられています。複合要求は、それらの結果は、化合物の応答のシーケンスでエンコード有するNFS操作の数を含んでいます。成功した操作の結果は、動作の符号化された結果に続いNFS4_OK状態で構成されます。 NFS操作が失敗した場合、エラー状態は、返信に入力されますとCOMPOUND要求は終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Error Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1。エラーの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          +-------------------------+--------+------------------+
          | Error                   | Number | Description      |
          +-------------------------+--------+------------------+
          | NFS4ERR_BADLABEL        | 10093  | Section 11.1.3.1 |
          | NFS4ERR_OFFLOAD_DENIED  | 10091  | Section 11.1.2.1 |
          | NFS4ERR_OFFLOAD_NO_REQS | 10094  | Section 11.1.2.2 |
          | NFS4ERR_PARTNER_NO_AUTH | 10089  | Section 11.1.2.3 |
          | NFS4ERR_PARTNER_NOTSUPP | 10088  | Section 11.1.2.4 |
          | NFS4ERR_UNION_NOTSUPP   | 10090  | Section 11.1.1.1 |
          | NFS4ERR_WRONG_LFS       | 10092  | Section 11.1.3.2 |
          +-------------------------+--------+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 1: Protocol Error Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表1：プロトコルエラーの定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. General Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1。一般的なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section deals with errors that are applicable to a broad set of different purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、異なる目的の広範なセットに適用されるエラーを扱っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1.1. NFS4ERR_UNION_NOTSUPP (Error Code 10090)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1.1。 NFS4ERR_UNION_NOTSUPP（エラーコード10090）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One of the arguments to the operation is a discriminated union, and while the server supports the given operation, it does not support the selected arm of the discriminated union.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作への引数の1つが判別組合であり、サーバが特定の操作をサポートしていながら、それを判別共用体の選択された腕をサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2. Server-to-Server Copy Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2。サーバ間のコピーエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These errors deal with the interaction between server-to-server copies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのエラーは、サーバー間のコピー間の相互作用を扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.1. NFS4ERR_OFFLOAD_DENIED (Error Code 10091)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.1。 NFS4ERR_OFFLOAD_DENIED（エラーコード10091）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The COPY offload operation is supported by both the source and the destination, but the destination is not allowing it for this file. If the client sees this error, it should fall back to the normal copy semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPYオフロード操作は、送信元と宛先の両方でサポートされていますが、先は、このファイルのためにそれを許可していません。クライアントはこのエラーを見ている場合は、それが戻って通常のコピーのセマンティクスに落ちる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.2. NFS4ERR_OFFLOAD_NO_REQS (Error Code 10094)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.2。 NFS4ERR_OFFLOAD_NO_REQS（エラーコード10094）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The COPY offload operation is supported by both the source and the destination, but the destination cannot meet the client requirements for either consecutive byte copy or synchronous copy. If the client sees this error, it should either relax the requirements (if any) or fall back to the normal copy semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPYオフロード操作は、送信元と宛先の両方でサポートされていますが、先が連続したバイトのコピーまたは同期コピーのいずれかのクライアントの要件を満たすことができません。クライアントはこのエラーを見れば、それは要件を緩和（もしあれば）または通常のコピー・セマンティクスにフォールバックする必要がありどちらか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.3. NFS4ERR_PARTNER_NO_AUTH (Error Code 10089)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.3。 NFS4ERR_PARTNER_NO_AUTH（エラーコード10089）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The source server does not authorize a server-to-server COPY offload operation. This may be due to the client&#39;s failure to send the COPY_NOTIFY operation to the source server, the source server receiving a server-to-server copy offload request after the copy lease time expired, or some other permission problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースサーバは、サーバ間COPYオフロード操作を許可していません。これは、クライアントのコピーリース時間の期限が切れた後、元のサーバーにサーバー間コピーオフロード要求を受信したソースサーバをCOPY_NOTIFY操作を送信するために失敗、または他のいくつかの権限の問題であってよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The destination server does not authorize a server-to-server COPY offload operation. This may be due to an inter-server COPY request where the destination server requires RPCSEC_GSSv3 and it is not used, or some other permissions problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信先サーバーは、サーバー間COPYオフロード操作を許可していません。これは、宛先サーバーがRPCSEC_GSSv3を必要とし、それが使用されていないサーバ間のコピー要求、または他のいくつかの権限の問題であってよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.4. NFS4ERR_PARTNER_NOTSUPP (Error Code 10088)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2.4。 NFS4ERR_PARTNER_NOTSUPP（エラーコード10088）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The remote server does not support the server-to-server COPY offload protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リモートサーバは、サーバからサーバへのCOPYのオフロードプロトコルをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3. Labeled NFS Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3。標識NFSエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These errors are used in Labeled NFS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのエラーは、ラベル付きNFSで使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3.1. NFS4ERR_BADLABEL (Error Code 10093)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3.1。 NFS4ERR_BADLABEL（エラーコード10093）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The label specified is invalid in some manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定されたラベルは、いくつかの方法で無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3.2. NFS4ERR_WRONG_LFS (Error Code 10092)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3.2。 NFS4ERR_WRONG_LFS（エラーコード10092）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The LFS specified in the subject label is not compatible with the LFS in the object label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
対象ラベルに指定されたLFSは、オブジェクト・ラベルのLFSと互換性がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. New Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2。新規事業とその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section contains a table that gives the valid error returns for each new NFSv4.2 protocol operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all new operations. The error values for all other operations are defined in Section 15.2 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、それぞれの新しいNFSv4.2プロトコルの動作のための有効なエラーリターンを与えるテーブルが含まれています。 （エラーがないことを示す）エラーコードNFS4_OKが表示されていないが、すべての新しい操作によって返却であると理解されるべきです。他のすべての操作のエラー値は[RFC5661]のセクション15.2で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------+--------------------------------------------------+
   | Operation      | Errors                                           |
   +----------------+--------------------------------------------------+
   | ALLOCATE       | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_MOVED,        |
   |                | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
   | CLONE          | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_MOVED,        |
   |                | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE,        |
   |                | NFS4ERR_XDEV                                     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------+--------------------------------------------------+
   | COPY           | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOSPC, NFS4ERR_OFFLOAD_DENIED,           |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,           |
   |                | NFS4ERR_OP_NOT_IN_SESSION,                       |
   |                | NFS4ERR_PARTNER_NO_AUTH,                         |
   |                | NFS4ERR_PARTNER_NOTSUPP, NFS4ERR_PNFS_IO_HOLE,   |
   |                | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
   | COPY_NOTIFY    | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,           |
   |                | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE, |
   |                | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
   |                | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,           |
   |                | NFS4ERR_WRONG_TYPE                               |
   +----------------+--------------------------------------------------+
   | DEALLOCATE     | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,  |
   |                | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,        |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
   | GETDEVICELIST  | NFS4ERR_NOTSUPP                                  |
   +----------------+--------------------------------------------------+
   | IO_ADVISE      | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,  |
   |                | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,        |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OP_NOT_IN_SESSION,                       |
   |                | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_SERVERFAULT, |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
   | LAYOUTERROR    | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |
   |                | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,        |
   |                | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,              |
   |                | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_ISDIR,     |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_NO_GRACE,               |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
   |                | NFS4ERR_TOO_MANY_OPS,                            |
   |                | NFS4ERR_UNKNOWN_LAYOUTTYPE, NFS4ERR_WRONG_CRED,  |
   |                | NFS4ERR_WRONG_TYPE                               |
   +----------------+--------------------------------------------------+
   | LAYOUTSTATS    | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |
   |                | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,        |
   |                | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,              |
   |                | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_ISDIR,     |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_NO_GRACE,               |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                | NFS4ERR_TOO_MANY_OPS,                            |
   |                | NFS4ERR_UNKNOWN_LAYOUTTYPE, NFS4ERR_WRONG_CRED,  |
   |                | NFS4ERR_WRONG_TYPE                               |
   +----------------+--------------------------------------------------+
   | OFFLOAD_CANCEL | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |
   |                | NFS4ERR_BAD_STATEID, NFS4ERR_COMPLETE_ALREADY,   |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_EXPIRED, NFS4ERR_GRACE, NFS4ERR_NOTSUPP, |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS        |
   +----------------+--------------------------------------------------+
   | OFFLOAD_STATUS | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,           |
   |                | NFS4ERR_BAD_STATEID, NFS4ERR_COMPLETE_ALREADY,   |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_EXPIRED, NFS4ERR_GRACE, NFS4ERR_NOTSUPP, |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OP_NOT_IN_SESSION,  |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS        |
   +----------------+--------------------------------------------------+
   | READ_PLUS      | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_PARTNER_NO_AUTH, NFS4ERR_PNFS_IO_HOLE,   |
   |                | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
   |                | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,           |
   |                | NFS4ERR_WRONG_TYPE                               |
   +----------------+--------------------------------------------------+
   | SEEK           | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED,          |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,            |
   |                | NFS4ERR_OPENMODE, NFS4ERR_OP_NOT_IN_SESSION,     |
   |                | NFS4ERR_PNFS_IO_HOLE, NFS4ERR_PNFS_NO_LAYOUT,    |
   |                | NFS4ERR_REP_TOO_BIG,                             |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   |                | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,              |
   |                | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,           |
   |                | NFS4ERR_UNION_NOTSUPP, NFS4ERR_WRONG_TYPE        |
   +----------------+--------------------------------------------------+
   | WRITE_SAME     | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,           |
   |                | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,             |
   |                | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,              |
   |                | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,            |
   |                | NFS4ERR_EXPIRED, NFS4ERR_FBIG,                   |
   |                | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, |
   |                | NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,       |
   |                | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,             |
   |                | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,                  |
   |                | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,           |
   |                | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE, |
   |                | NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,     |
   |                | NFS4ERR_REP_TOO_BIG_TO_CACHE,                    |
   |                | NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP, |
   |                | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,               |
   |                | NFS4ERR_STALE, NFS4ERR_SYMLINK,                  |
   |                | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE         |
   +----------------+--------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 2: Valid Error Returns for Each New Protocol Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表2：それぞれの新しいプロトコル動作のための有効なエラーを返します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. New Callback Operations and Their Valid Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3。新しいコールバックオペレーションとその有効なエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section contains a table that gives the valid error returns for each new NFSv4.2 callback operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all new callback operations. The error values for all other callback operations are defined in Section 15.3 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、それぞれの新しいNFSv4.2コールバック操作のための有効なエラーリターンを与えるテーブルが含まれています。 （エラーがないことを示す）エラーコードNFS4_OKが表示されていないが、すべての新しいコールバックオペレーションによって返却であると理解されるべきです。他のすべてのコールバック操作のためのエラー値は[RFC5661]のセクション15.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------+------------------------------------------------------+
   | Callback   | Errors                                               |
   | Operation  |                                                      |
   +------------+------------------------------------------------------+
   | CB_OFFLOAD | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,                   |
   |            | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY,                  |
   |            | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_REP_TOO_BIG,      |
   |            | NFS4ERR_REP_TOO_BIG_TO_CACHE, NFS4ERR_REQ_TOO_BIG,   |
   |            | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_SERVERFAULT,     |
   |            | NFS4ERR_TOO_MANY_OPS                                 |
   +------------+------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 3: Valid Error Returns for Each New Protocol Callback Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表3：それぞれの新しいプロトコルのコールバック操作のための有効なエラーを返します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. New File Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.新しいファイル属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. New RECOMMENDED Attributes - List and Definition References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1。新しい推奨属性 - リストと定義参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The list of new RECOMMENDED attributes appears in Table 4. The meanings of the columns of the table are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しい推奨属性のリストを表4に表示されるテーブルの列の意味は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Name: The name of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前：属性の名前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Id: The number assigned to the attribute. In the event of conflicts between the assigned number and [RFC7863], the latter is authoritative, but in such an event, it should be resolved with errata to this document and/or [RFC7863]. See [IESG08] for the errata process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ID：属性に割り当てられた番号。割り当てられた番号と[RFC7863]の間で競合が発生した場合、後者は信頼できますが、そのような場合には、この文書および/または[RFC7863]にエラッタで解決すべきです。正誤表・プロセスのために[IESG08]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Data Type: The XDR data type of the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データタイプ：属性のXDRデータ型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acc: Access allowed to the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ACC]属性に許可されるアクセス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
R means read-only (GETATTR may retrieve, SETATTR may not set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rは読み取り専用（GETATTRが検索してもよい、SETATTRが設定されていない場合があります）を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
W means write-only (SETATTR may set, GETATTR may not retrieve).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Wは、書き込み専用（SETATTRは、設定することがGETATTRが取得できない場合があります）を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
R W means read/write (GETATTR may retrieve, SETATTR may set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
R Wは、読み取り/書き込みを意味（GETATTRが検索してもよい、SETATTRは設定可能）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Defined in: The section of this specification that describes the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性を記述し、この仕様のセクション：で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------+----+-------------------+-----+----------------+
   | Name             | Id | Data Type         | Acc | Defined in     |
   +------------------+----+-------------------+-----+----------------+
   | clone_blksize    | 77 | uint32_t          | R   | Section 12.2.1 |
   | space_freed      | 78 | length4           | R   | Section 12.2.2 |
   | change_attr_type | 79 | change_attr_type4 | R   | Section 12.2.3 |
   | sec_label        | 80 | sec_label4        | R W | Section 12.2.4 |
   +------------------+----+-------------------+-----+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 4: New RECOMMENDED Attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表4：新たな推奨属性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. Attribute Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2。属性定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.1. Attribute 77: clone_blksize
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.1。属性77：clone_blksize
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The clone_blksize attribute indicates the granularity of a CLONE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
clone_blksize属性は、クローン操作の細分性を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.2. Attribute 78: space_freed
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.2。属性78：space_freed
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
space_freed gives the number of bytes freed if the file is deleted. This attribute is read-only and is of type length4. It is a per-file attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
space_freedは、ファイルが削除された場合に解放されたバイト数を示します。この属性は読み取り専用とタイプLENGTH4のです。これは、ファイルごとの属性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.3. Attribute 79: change_attr_type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.3。属性79：change_attr_type
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum change_attr_type4 { NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR = 0, NFS4_CHANGE_TYPE_IS_VERSION_COUNTER = 1, NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2, NFS4_CHANGE_TYPE_IS_TIME_METADATA = 3, NFS4_CHANGE_TYPE_IS_UNDEFINED = 4 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙change_attr_type4 {NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR = 0、NFS4_CHANGE_TYPE_IS_VERSION_COUNTER = 1、NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2、NFS4_CHANGE_TYPE_IS_TIME_METADATA = 3、NFS4_CHANGE_TYPE_IS_UNDEFINED = 4}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
change_attr_type is a per-file system attribute that enables the NFSv4.2 server to provide additional information about how it expects the change attribute value to evolve after the file data or metadata has changed. While Section 5.4 of [RFC5661] discusses per-file system attributes, it is expected that the value of change_attr_type will not depend on the value of &#34;homogeneous&#34; and will only change in the event of a migration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
change_attr_typeは、ファイルデータやメタデータが変更された後に変化属性値が進化することを期待方法に関する追加情報を提供するために、NFSv4.2サーバーを可能ごとのファイルシステム属性です。 [RFC5661]の5.4節ごとのファイルシステム属性を説明しますが、change_attr_typeの値は「均質」の値に依存せず、唯一の移行の際に変更されることが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR: The change attribute value MUST monotonically increase for every atomic change to the file attributes, data, or directory contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR：変更属性値が単調にファイル属性、データ、またはディレクトリの内容にすべての原子の変更のために増加しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_VERSION_COUNTER: The change attribute value MUST be incremented by one unit for every atomic change to the file attributes, data, or directory contents. This property is preserved when writing to pNFS data servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_VERSION_COUNTER：変更属性値は、ファイル属性、データ、またはディレクトリの内容にすべての原子の変更のための1個の単位で増加しなければなりません。 pNFSのデータ・サーバへの書き込み時に、このプロパティは保持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS: The change attribute value MUST be incremented by one unit for every atomic change to the file attributes, data, or directory contents. In the case where the client is writing to pNFS data servers, the number of increments is not guaranteed to exactly match the number of WRITEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS：変更属性値は、ファイル属性、データ、またはディレクトリの内容にすべての原子の変更のための1個の単位で増加しなければなりません。クライアントはpNFSのデータ・サーバへの書き込みをされた場合には、増分の数は正確に書き込みの数と一致するように保証するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_TIME_METADATA: The change attribute is implemented as suggested in [RFC7530] in terms of the time_metadata attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_TIME_METADATA：time_metadata属性の面で、[RFC7530]で提案されているように変化属性が実装されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_UNDEFINED: The change attribute does not take values that fit into any of these categories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_UNDEFINED：変更属性は、これらのカテゴリのいずれかに適合した値を取ることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If either NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR, NFS4_CHANGE_TYPE_IS_VERSION_COUNTER, or NFS4_CHANGE_TYPE_IS_TIME_METADATA is set, then the client knows at the very least that the change attribute is monotonically increasing, which is sufficient to resolve the question of which value is the most recent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR、NFS4_CHANGE_TYPE_IS_VERSION_COUNTER、またはNFS4_CHANGE_TYPE_IS_TIME_METADATAのいずれかが設定されている場合、クライアントは、変化属性が単調に値が最新となっている問題を解決するのに十分である、増加していることが非常に少なくとも、知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client sees the value NFS4_CHANGE_TYPE_IS_TIME_METADATA, then by inspecting the value of the &#34;time_delta&#34; attribute it additionally has the option of detecting rogue server implementations that use time_metadata in violation of the specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが値NFS4_CHANGE_TYPE_IS_TIME_METADATAを見ている場合は、「TIME_DELTA」の値を調べることによって、それがさらに仕様に違反してtime_metadataを使用し、不正なサーバーの実装を検出するオプションを持っている属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client sees NFS4_CHANGE_TYPE_IS_VERSION_COUNTER, it has the ability to predict what the resulting change attribute value should be after a COMPOUND containing a SETATTR, WRITE, or CREATE. This again allows it to detect changes made in parallel by another client. The value NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS permits the same, but only if the client is not doing pNFS WRITEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがNFS4_CHANGE_TYPE_IS_VERSION_COUNTERを見れば、それは、結果の変化属性値がSETATTRを含む化合物の後にどうあるべきかを予測WRITE、または作成する能力を持っています。これは、再び、それが別のクライアントによって並列に行われた変更を検出することができます。値NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS同じことを許可するが、クライアントはpNFSのへの書き込みをしていないされている場合のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finally, if the server does not support change_attr_type or if NFS4_CHANGE_TYPE_IS_UNDEFINED is set, then the server SHOULD make an effort to implement the change attribute in terms of the time_metadata attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後に、場合、サーバはchange_attr_typeをサポートしていないか、NFS4_CHANGE_TYPE_IS_UNDEFINEDが設定されている場合、サーバはtime_metadata属性の面で変化属性を実装するための努力をすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.4. Attribute 80: sec_label
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.4。属性80：sec_l​​abel
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedef uint32_t policy4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
typedefでのuint32_t policy4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct labelformat_spec4 {
           policy4 lfs_lfs;
           policy4 lfs_pi;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct sec_label4 {
           labelformat_spec4       slai_lfs;
           opaque                  slai_data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The FATTR4_SEC_LABEL contains an array of two components, with the first component being an LFS. It serves to provide the receiving end with the information necessary to translate the security attribute into a form that is usable by the endpoint. Label Formats assigned an LFS may optionally choose to include a Policy Identifier field to allow for complex policy deployments. The LFS and the Security Label Format Selection Registry are described in detail in [RFC7569]. The translation used to interpret the security attribute is not specified as part of the protocol, as it may depend on various factors. The second component is an opaque section that contains the data of the attribute. This component is dependent on the MAC model to interpret and enforce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FATTR4_SEC_LABELは、第一成分がLFSされた状態で、二つの成分の配列を含んでいます。これは、エンドポイントによって使用可能な形式にセキュリティ属性を変換するために必要な情報を受信側に提供するのに役立ちます。 LFS割り当てられたラベルフォーマットは、必要に応じて、複雑な政策の展開を可能にする方針識別子フィールドを含めるように選択することができます。 LFSとセキュリティラベルフォーマットの選択レジストリは、[RFC7569]に詳細に記載されています。それは様々な要因に依存し得るようなセキュリティ属性を解釈するために使用される変換は、プロトコルの一部として指定されていません。第二成分は、属性のデータを含む不透明な部分です。このコンポーネントは、解釈し、施行するMACモデルに依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In particular, it is the responsibility of the LFS specification to define a maximum size for the opaque section, slai_data&lt;&gt;. When creating or modifying a label for an object, the client needs to be guaranteed that the server will accept a label that is sized correctly. By both client and server being part of a specific MAC model, the client will be aware of the size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特に、不透明なセクションの最大サイズ、slai_data &lt;&gt;を定義するLFS仕様の責任です。オブジェクトのラベルを作成または変更する場合、クライアントは、サーバーが正しく大きさでラベルを受け入れることを保証する必要があります。クライアントとサーバーの両方が、特定のMACモデルの一部であることによって、クライアントは、サイズに気付くであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Operations: REQUIRED, RECOMMENDED, or OPTIONAL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.操作：推奨REQUIRED、またはオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tables 5 and 6 summarize the operations of the NFSv4.2 protocol and the corresponding designations of REQUIRED, RECOMMENDED, and OPTIONAL to implement or MUST NOT implement. The &#34;MUST NOT implement&#34; designation is reserved for those operations that were defined in either NFSv4.0 or NFSv4.1 and MUST NOT be implemented in NFSv4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表5および表6は、実施したり実装してはいけません推奨、NFSv4.2プロトコルと必要な対応する指定の動作を要約し、そしてOPTIONAL。 「実装してはいけません」指定はNFSv4.0又はNFSv4.1のいずれかで定義され、NFSv4.2に実装してはいけませんこれらの操作のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the most part, the REQUIRED, RECOMMENDED, or OPTIONAL designation for operations sent by the client is for the server implementation. The client is generally required to implement the operations needed for the operating environment that it serves. For example, a read-only NFSv4.2 client would have no need to implement the WRITE operation and is not required to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ほとんどの部分については、REQUIREDは、推奨、またはクライアントから送信された操作のためのオプションの指定は、サーバの実装のためです。クライアントは一般的に、それが機能動作環境のために必要な操作を実現するために必要とされます。例えば、読み取り専用NFSv4.2のクライアントは、書き込み動作を実装する必要がないだろうし、そうする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The REQUIRED or OPTIONAL designation for callback operations sent by the server is for both the client and server. Generally, the client has the option of creating the backchannel and sending the operations on the forechannel that will be a catalyst for the server sending callback operations. A partial exception is CB_RECALL_SLOT; the only way the client can avoid supporting this operation is by not creating a backchannel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーから送信されたコールバック操作のための必須またはオプションの指定は、クライアントとサーバーの両方のためです。一般的に、クライアントはバックチャネルを作成し、コールバックオペレーションを送信するサーバのための触媒となりますforechannel上で操作を送信するオプションがあります。部分的な例外はCB_RECALL_SLOTです。クライアントがこの操作をサポートして避けることができる唯一の方法は、バックチャネルを作成しないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since this is a summary of the operations and their designation, there are subtleties that are not presented here. Therefore, if there is a question regarding implementation requirements, the operation descriptions themselves must be consulted, along with other relevant explanatory text within either this specification or the NFSv4.1 specification [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは事業の概要とその名称であるので、ここで提示されていない微妙な点があります。実装要件に関する質問がある場合はそのため、操作の説明自体は、この仕様またはNFSv4.1仕様[RFC5661]のいずれかの内の他の関連する説明文とともに、相談する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The abbreviations used in the second and third columns of Tables 5 and 6 are defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように表5及び6の第2列と第3列で使用された略語が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
REQ: REQUIRED to implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
REQ：実装するために必要な
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
REC: RECOMMENDED to implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
REC：実装する推奨
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPT: OPTIONAL to implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPT：オプションを実装します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MNI: MUST NOT implement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MNI：実装してはなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the NFSv4.2 features that are OPTIONAL, the operations that support those features are OPTIONAL, and the server MUST return NFS4ERR_NOTSUPP in response to the client&#39;s use of those operations when those operations are not implemented by the server. If an OPTIONAL feature is supported, it is possible that a set of operations related to the feature become REQUIRED to implement. The third column of the tables designates the feature(s) and if the operation is REQUIRED or OPTIONAL in the presence of support for the feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションであるNFSv4.2機能については、これらの機能をサポートする操作はオプションであり、そしてそれらの操作は、サーバーで実装されていない場合、サーバーは、これらの操作のクライアントの使用に応じてNFS4ERR_NOTSUPPを返さなければなりません。オプション機能がサポートされている場合は、機能に関連する一連の操作が必須実装になっている可能性があります。テーブルの第3列は、機能（複数可）を指定して操作が必要または機能に対するサポートの存在下でのオプションの場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OPTIONAL features identified and their abbreviations are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプション機能を識別し、次のように彼らの略語は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFS: Parallel NFS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSの：パラレルNFS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
FDELG: File Delegations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FDELG：ファイルの代表団
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DDELG: Directory Delegations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DDELG：ディレクトリ代表団
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPYra: Intra-server Server-Side Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPYra：イントラサーバーのサーバー側のコピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPYer: Inter-server Server-Side Copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コピア：サーバ間のサーバー側のコピー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ADB: Application Data Blocks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ADB：アプリケーションのデータ・ブロック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------------+--------------------+-----------------------+
   | Operation            | REQ, REC, OPT, or  | Feature (REQ, REC, or |
   |                      | MNI                | OPT)                  |
   +----------------------+--------------------+-----------------------+
   | ACCESS               | REQ                |                       |
   | ALLOCATE             | OPT                |                       |
   | BACKCHANNEL_CTL      | REQ                |                       |
   | BIND_CONN_TO_SESSION | REQ                |                       |
   | CLONE                | OPT                |                       |
   | CLOSE                | REQ                |                       |
   | COMMIT               | REQ                |                       |
   | COPY                 | OPT                | COPYer (REQ), COPYra  |
   |                      |                    | (REQ)                 |
   | COPY_NOTIFY          | OPT                | COPYer (REQ)          |
   | CREATE               | REQ                |                       |
   | CREATE_SESSION       | REQ                |                       |
   | DEALLOCATE           | OPT                |                       |
   | DELEGPURGE           | OPT                | FDELG (REQ)           |
   | DELEGRETURN          | OPT                | FDELG, DDELG, pNFS    |
   |                      |                    | (REQ)                 |
   | DESTROY_CLIENTID     | REQ                |                       |
   | DESTROY_SESSION      | REQ                |                       |
   | EXCHANGE_ID          | REQ                |                       |
   | FREE_STATEID         | REQ                |                       |
   | GETATTR              | REQ                |                       |
   | GETDEVICEINFO        | OPT                | pNFS (REQ)            |
   | GETDEVICELIST        | MNI                | pNFS (MNI)            |
   | GETFH                | REQ                |                       |
   | GET_DIR_DELEGATION   | OPT                | DDELG (REQ)           |
   | ILLEGAL              | REQ                |                       |
   | IO_ADVISE            | OPT                |                       |
   | LAYOUTCOMMIT         | OPT                | pNFS (REQ)            |
   | LAYOUTERROR          | OPT                | pNFS (OPT)            |
   | LAYOUTGET            | OPT                | pNFS (REQ)            |
   | LAYOUTRETURN         | OPT                | pNFS (REQ)            |
   | LAYOUTSTATS          | OPT                | pNFS (OPT)            |
   | LINK                 | OPT                |                       |
   | LOCK                 | REQ                |                       |
   | LOCKT                | REQ                |                       |
   | LOCKU                | REQ                |                       |
   | LOOKUP               | REQ                |                       |
   | LOOKUPP              | REQ                |                       |
   | NVERIFY              | REQ                |                       |
   | OFFLOAD_CANCEL       | OPT                | COPYer (OPT), COPYra  |
   |                      |                    | (OPT)                 |
   | OFFLOAD_STATUS       | OPT                | COPYer (OPT), COPYra  |
   |                      |                    | (OPT)                 |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | OPEN                 | REQ                |                       |
   | OPENATTR             | OPT                |                       |
   | OPEN_CONFIRM         | MNI                |                       |
   | OPEN_DOWNGRADE       | REQ                |                       |
   | PUTFH                | REQ                |                       |
   | PUTPUBFH             | REQ                |                       |
   | PUTROOTFH            | REQ                |                       |
   | READ                 | REQ                |                       |
   | READDIR              | REQ                |                       |
   | READLINK             | OPT                |                       |
   | READ_PLUS            | OPT                |                       |
   | RECLAIM_COMPLETE     | REQ                |                       |
   | RELEASE_LOCKOWNER    | MNI                |                       |
   | REMOVE               | REQ                |                       |
   | RENAME               | REQ                |                       |
   | RENEW                | MNI                |                       |
   | RESTOREFH            | REQ                |                       |
   | SAVEFH               | REQ                |                       |
   | SECINFO              | REQ                |                       |
   | SECINFO_NO_NAME      | REC                | pNFS file layout      |
   |                      |                    | (REQ)                 |
   | SEEK                 | OPT                |                       |
   | SEQUENCE             | REQ                |                       |
   | SETATTR              | REQ                |                       |
   | SETCLIENTID          | MNI                |                       |
   | SETCLIENTID_CONFIRM  | MNI                |                       |
   | SET_SSV              | REQ                |                       |
   | TEST_STATEID         | REQ                |                       |
   | VERIFY               | REQ                |                       |
   | WANT_DELEGATION      | OPT                | FDELG (OPT)           |
   | WRITE                | REQ                |                       |
   | WRITE_SAME           | OPT                | ADB (REQ)             |
   +----------------------+--------------------+-----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 5: Operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表5：事業
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------+------------------+----------------------+
   | Operation               | REQ, REC, OPT,   | Feature (REQ, REC,   |
   |                         | or MNI           | or OPT)              |
   +-------------------------+------------------+----------------------+
   | CB_GETATTR              | OPT              | FDELG (REQ)          |
   | CB_ILLEGAL              | REQ              |                      |
   | CB_LAYOUTRECALL         | OPT              | pNFS (REQ)           |
   | CB_NOTIFY               | OPT              | DDELG (REQ)          |
   | CB_NOTIFY_DEVICEID      | OPT              | pNFS (OPT)           |
   | CB_NOTIFY_LOCK          | OPT              |                      |
   | CB_OFFLOAD              | OPT              | COPYer (REQ), COPYra |
   |                         |                  | (REQ)                |
   | CB_PUSH_DELEG           | OPT              | FDELG (OPT)          |
   | CB_RECALL               | OPT              | FDELG, DDELG, pNFS   |
   |                         |                  | (REQ)                |
   | CB_RECALL_ANY           | OPT              | FDELG, DDELG, pNFS   |
   |                         |                  | (REQ)                |
   | CB_RECALL_SLOT          | REQ              |                      |
   | CB_RECALLABLE_OBJ_AVAIL | OPT              | DDELG, pNFS (REQ)    |
   | CB_SEQUENCE             | OPT              | FDELG, DDELG, pNFS   |
   |                         |                  | (REQ)                |
   | CB_WANTS_CANCELLED      | OPT              | FDELG, DDELG, pNFS   |
   |                         |                  | (REQ)                |
   +-------------------------+------------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 6: Callback Operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表6：コールバックオペレーション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Modifications to NFSv4.1 Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
NFSv4.1事業への14の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. Operation 42: EXCHANGE_ID - Instantiate the client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1。操作42：EXCHANGE_ID  - クライアントのIDをインスタンス化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* new */
      const EXCHGID4_FLAG_SUPP_FENCE_OPS      = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unchanged
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変更なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.3. MOTIVATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.3。動機
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Enterprise applications require guarantees that an operation has either aborted or completed. NFSv4.1 provides this guarantee as long as the session is alive: simply send a SEQUENCE operation on the same slot with a new sequence number, and the successful return of SEQUENCE indicates that the previous operation has completed. However, if the session is lost, there is no way to know when any operations in progress have aborted or completed. In hindsight, the NFSv4.1 specification should have mandated that DESTROY_SESSION either abort or complete all outstanding operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンタープライズアプリケーションは、操作が中断または完了しているいずれかのことを保証する必要があります。 NFSv4.1は限りセッションが生きているように、この保証を提供しています。単に新しいシーケンス番号と同じスロットにシーケンス動作を送信し、SEQUENCEの成功リターンは前の操作が完了したことを示しています。セッションが失われた場合は、進行中の操作が中断または完了したときに知る方法はありません。後知恵では、NFSv4.1仕様はDESTROY_SESSIONは、すべての未処理の操作を中止または完了のいずれかのことを義務付けている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client SHOULD request the EXCHGID4_FLAG_SUPP_FENCE_OPS capability when it sends an EXCHANGE_ID operation. The server SHOULD set this capability in the EXCHANGE_ID reply whether the client requests it or not. It is the server&#39;s return that determines whether this capability is in effect. When it is in effect, the following will occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはEXCHANGE_ID操作を送信すると、クライアントはEXCHGID4_FLAG_SUPP_FENCE_OPS機能を要求する必要があります。サーバーは、クライアントがそれを要求しているか否か返信EXCHANGE_IDでこの機能を設定する必要があります。これは、この機能が有効になっているかどうかを判断し、サーバのリターンです。それが有効である場合には、以下が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server will not reply to any DESTROY_SESSION invoked with the client ID until all operations in progress are completed or aborted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oサーバーは、進行中のすべての操作が完了または中止されるまで、クライアントのIDで呼び出さ任意のDESTROY_SESSIONに返信しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The server will not reply to subsequent EXCHANGE_ID operations invoked on the same client owner with a new verifier until all operations in progress on the client ID&#39;s session are completed or aborted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントIDのセッション上で進行中のすべての操作が完了または中止されるまで、Oサーバは、新しい検証と同じクライアント所有者に呼び出され、その後のEXCHANGE_ID操作に応答しなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In implementations where the NFS server is deployed as a cluster, it does support client ID trunking, and the EXCHGID4_FLAG_SUPP_FENCE_OPS capability is enabled, then a session ID created on one node of the storage cluster MUST be destroyable via DESTROY_SESSION. In addition, DESTROY_CLIENTID and an EXCHANGE_ID with a new verifier affect all sessions, regardless of what node the sessions were created on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O NFSサーバがクラスタとして配置されている実装では、クライアントIDトランキングをサポートし、そしてEXCHGID4_FLAG_SUPP_FENCE_OPS機能が有効化され、その後、ストレージクラスタの1つのノード上に生成したセッションIDはDESTROY_SESSION介し分解性でなければなりません。また、新しい検証とDESTROY_CLIENTIDとEXCHANGE_IDは関係なく、セッションが作成されたノードものの、すべてのセッションに影響を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
14.2. Operation 48: GETDEVICELIST - Get all device mappings for a file system
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
14.2。操作48：GETDEVICELIST  - ファイルシステムのすべてのデバイスのマッピングを取得します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETDEVICELIST4args {
           /* CURRENT_FH: object belonging to the file system */
           layouttype4     gdla_layout_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* number of device IDs to return */
           count4          gdla_maxdevices;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           nfs_cookie4     gdla_cookie;
           verifier4       gdla_cookieverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETDEVICELIST4resok {
           nfs_cookie4             gdlr_cookie;
           verifier4               gdlr_cookieverf;
           deviceid4               gdlr_deviceid_list&lt;&gt;;
           bool                    gdlr_eof;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETDEVICELIST4res switch (nfsstat4 gdlr_status) {
   case NFS4_OK:
           GETDEVICELIST4resok     gdlr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.3. MOTIVATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.3。動機
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The GETDEVICELIST operation was introduced in [RFC5661] specifically to request a list of devices at file system mount time from block layout type servers. However, the use of the GETDEVICELIST operation introduces a race condition versus notification about changes to pNFS device IDs as provided by CB_NOTIFY_DEVICEID. Implementation experience with block layout servers has shown that there is no need for GETDEVICELIST. Clients have to be able to request new devices using GETDEVICEINFO at any time in response to either a new deviceid in LAYOUTGET results or the CB_NOTIFY_DEVICEID callback operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETDEVICELIST動作は、具体的には、ブロックレイアウト型サーバから時刻をマウントファイルシステムでデバイスのリストを要求するために、[RFC5661]に導入しました。しかし、GETDEVICELIST操作の使用はCB_NOTIFY_DEVICEIDによって提供されるpNFSのデバイスIDの変更に関する通知対競合状態を紹介します。ブロックレイアウトサーバと実装の経験はGETDEVICELISTの必要がないことを示しています。クライアントはLAYOUTGET結果で新しいデバイスIDやCB_NOTIFY_DEVICEIDコールバック操作のいずれかに応じて、任意の時点でGETDEVICEINFOを使用して新しいデバイスを要求できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.4. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.4。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients and servers MUST NOT implement the GETDEVICELIST operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバーはGETDEVICELIST操作を実装してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFSv4.2 Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFSv4.2操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. Operation 59: ALLOCATE - Reserve space in a region of a file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1。操作59： - ファイルの領域内に予約領域を割り当てます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ALLOCATE4args {
           /* CURRENT_FH: file */
           stateid4        aa_stateid;
           offset4         aa_offset;
           length4         aa_length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ALLOCATE4res {
           nfsstat4        ar_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever a client wishes to reserve space for a region in a file, it calls the ALLOCATE operation with the current filehandle set to the filehandle of the file in question, and with the start offset and length in bytes of the region set in aa_offset and aa_length, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがファイルに地域のためのスペースを確保したいときはいつでも、それは問題のファイルのファイルハンドルに設定された現在のファイルハンドルでALLOCATE操作を呼び出し、aa_offsetとaa_lengthに設定された領域のバイト単位の開始オフセットと長さを持ちます、それぞれ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CURRENT_FH must be a regular file. If CURRENT_FH is not a regular file, the operation MUST fail and return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CURRENT_FHは、通常のファイルでなければなりません。 CURRENT_FHが通常のファイルでない場合、操作は失敗し、NFS4ERR_WRONG_TYPEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The aa_stateid MUST refer to a stateid that is valid for a WRITE operation and follows the rules for stateids in Sections 8.2.5 and 18.32.3 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
aa_stateidは、書き込み動作のために有効であり、セクション8.2.5でのstateidsの規則に従い、[RFC5661]の18.32.3のstateidを参照しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server will ensure that backing blocks are reserved to the region specified by aa_offset and aa_length, and that no future writes into this region will return NFS4ERR_NOSPC. If the region lies partially or fully outside the current file size, the file size will be set to aa_offset + aa_length implicitly. If the server cannot guarantee this, it must return NFS4ERR_NOSPC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、バックアップのブロックがaa_offsetとaa_lengthで指定された領域に予約されていることを保証します、そして何の未来がこの領域に書き込むないことNFS4ERR_NOSPCを返します。領域は、現在のファイルサイズの外に部分的または完全にある場合、ファイルサイズは、暗黙的に+ aa_lengthをaa_offsetに設定されます。サーバはこれを保証できない場合は、NFS4ERR_NOSPCを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ALLOCATE operation can also be used to extend the size of a file if the region specified by aa_offset and aa_length extends beyond the current file size. In that case, any data outside of the previous file size will return zeros when read before data is written to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ALLOCATE動作もaa_offsetとaa_lengthによって指定された領域は、現在のファイルサイズを越えて延在する場合に、ファイルのサイズを拡張するために使用することができます。読んだときにデータが書き込まれる前に、その場合には、前のファイルサイズの外のデータはゼロを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is not required that the server allocate the space to the file before returning success. The allocation can be deferred; however, it must be guaranteed that it will not fail for lack of space. The deferral does not result in an asynchronous reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが成功を返す前に、ファイルに領域を割り当てることを必要とされていません。割り当てが延期することができます。しかし、スペースの不足のために失敗しないことを保証しなければなりません。延期は、非同期応答にはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ALLOCATE operation will result in the space_used and space_freed attributes being increased by the number of bytes reserved, unless they were previously reserved or written and not shared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ALLOCATE動作space_usedとspace_freed属性は、それらが以前に予約または書き込まれ、共有されなかった場合を除き、予約されたバイト数だけ増加されることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. Operation 60: COPY - Initiate a server-side copy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2。操作60：COPY  - サーバー側のコピーを開始
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COPY4args {
           /* SAVED_FH: source file */
           /* CURRENT_FH: destination file */
           stateid4        ca_src_stateid;
           stateid4        ca_dst_stateid;
           offset4         ca_src_offset;
           offset4         ca_dst_offset;
           length4         ca_count;
           bool            ca_consecutive;
           bool            ca_synchronous;
           netloc4         ca_source_server&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct write_response4 {
           stateid4        wr_callback_id&lt;1&gt;;
           length4         wr_count;
           stable_how4     wr_committed;
           verifier4       wr_writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct copy_requirements4 {
           bool            cr_consecutive;
           bool            cr_synchronous;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COPY4resok {
           write_response4         cr_response;
           copy_requirements4      cr_requirements;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union COPY4res switch (nfsstat4 cr_status) {
   case NFS4_OK:
           COPY4resok              cr_resok4;
   case NFS4ERR_OFFLOAD_NO_REQS:
           copy_requirements4      cr_requirements;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The COPY operation is used for both intra-server and inter-server copies. In both cases, the COPY is always sent from the client to the destination server of the file copy. The COPY operation requests that a range in the file specified by SAVED_FH be copied to a range in the file specified by CURRENT_FH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コピー操作は、イントラサーバとサーバ間の両方のコピーに使用されます。どちらの場合も、COPYは、常にファイルコピーの宛先クライアントからサーバに送信されます。コピー操作はSAVED_FHで指定されたファイル内の範囲がCURRENT_FHで指定されたファイル内の範囲にコピーすることを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Both SAVED_FH and CURRENT_FH must be regular files. If either SAVED_FH or CURRENT_FH is not a regular file, the operation MUST fail and return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SAVED_FHとCURRENT_FHの両方が通常のファイルでなければなりません。 SAVED_FHまたはCURRENT_FHのいずれかが通常のファイルでない場合、操作は失敗し、NFS4ERR_WRONG_TYPEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SAVED_FH and CURRENT_FH must be different files. If SAVED_FH and CURRENT_FH refer to the same file, the operation MUST fail with NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SAVED_FHとCURRENT_FHは異なるファイルでなければなりません。 SAVED_FHとCURRENT_FHが同じファイルを参照する場合は、操作はNFS4ERR_INVALで失敗しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the request is for an inter-server copy, the source-fh is a filehandle from the source server and the COMPOUND procedure is being executed on the destination server. In this case, the source-fh is a foreign filehandle on the server receiving the COPY request. If either PUTFH or SAVEFH checked the validity of the filehandle, the operation would likely fail and return NFS4ERR_STALE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求がサーバ間コピーのためのものである場合、ソース-FHは、ソースサーバからのファイルハンドルであり、COMPOUND手順は、宛先サーバ上で実行されています。この場合、ソース-FHは、コピー要求を受信したサーバ上の外部ファイルハンドルです。 PUTFHまたはSAVEFHどちらかがファイルハンドルの妥当性をチェックした場合、操作はおそらく失敗し、NFS4ERR_STALEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a server supports the inter-server copy feature, a PUTFH followed by a SAVEFH MUST NOT return NFS4ERR_STALE for either operation. These restrictions do not pose substantial difficulties for servers. CURRENT_FH and SAVED_FH may be validated in the context of the operation referencing them and an NFS4ERR_STALE error returned for an invalid filehandle at that point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、サーバ間コピー機能をサポートしている場合は、SAVEFH続いPUTFHは、いずれかの操作のためNFS4ERR_STALEを返してはなりません。これらの制限は、サーバのための実質的な困難をもたらすことはありません。 CURRENT_FHとSAVED_FHは、それらを参照する操作のコンテキストで検証し、NFS4ERR_STALEエラーは、その時点で無効なファイルハンドルのために返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ca_dst_stateid MUST refer to a stateid that is valid for a WRITE operation and follows the rules for stateids in Sections 8.2.5 and 18.32.3 of [RFC5661]. For an inter-server copy, the ca_src_stateid MUST be the cnr_stateid returned from the earlier COPY_NOTIFY operation, while for an intra-server copy ca_src_stateid MUST refer to a stateid that is valid for a READ operation and follows the rules for stateids in Sections 8.2.5 and 18.22.3 of [RFC5661]. If either stateid is invalid, then the operation MUST fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ca_dst_stateidは、書き込み動作のために有効であり、セクション8.2.5でのstateidsの規則に従い、[RFC5661]の18.32.3のstateidを参照しなければなりません。サーバ間のコピーについては、ca_src_stateidは、イントラサーバーコピーのca_src_stateidに対する読み出し動作のために有効であり、セクション8.2でのstateidsのための規則に従ったstateidを参照する必要がありながらcnr_stateidは、以前COPY_NOTIFY操作から返される必要があります。 5及び[RFC5661]の18.22.3。いずれかのstateidが無効である場合、操作は失敗しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ca_src_offset is the offset within the source file from which the data will be read, the ca_dst_offset is the offset within the destination file to which the data will be written, and the ca_count is the number of bytes that will be copied. An offset of 0 (zero) specifies the start of the file. A count of 0 (zero) requests that all bytes from ca_src_offset through EOF be copied to the destination. If concurrent modifications to the source file overlap with the source file region being copied, the data copied may include all, some, or none of the modifications. The client can use standard NFS operations (e.g., OPEN with OPEN4_SHARE_DENY_WRITE or mandatory byte-range locks) to protect against concurrent modifications if the client is concerned about this. If the source file&#39;s EOF is being modified in parallel with a COPY that specifies a count of 0 (zero) bytes, the amount of data copied is implementation dependent (clients may guard against this case by specifying a non-zero count value or preventing modification of the source file as mentioned above).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ca_src_offsetはca_dst_offsetデータが書き込まれる先のファイル内のオフセットであり、データが読み出される元のソースファイル内のオフセットされ、そしてca_countがコピーされるバイト数です。 0（ゼロ）のオフセットをファイルの先頭を指定します。 0（ゼロ）の数は、EOFを介しca_src_offsetからのすべてのバイトが先にコピーすることを要求します。ソースファイル領域とソース・ファイルの重複の同時変更がコピーされる場合、コピーされたデータは全て、いくつか、または改変のいずれを含んでもよいです。クライアントがこの懸念している場合、クライアントは、同時変更から保護するために、標準的なNFS操作（OPEN4_SHARE_DENY_WRITEまたは必須のバイト範囲ロックと、例えば、OPEN）を使用することができます。ソース・ファイルのEOFが0（ゼロ）バイトの数を指定するCOPYと並列に変更されている場合は、コピーされたデータの量は、実装依存である（クライアントが非ゼロカウント値を指定または変更を防止することによって、このような場合を防ぐことができます）上述したようにソースファイル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the source offset or the source offset plus count is greater than the size of the source file, the operation MUST fail with NFS4ERR_INVAL. The destination offset or destination offset plus count may be greater than the size of the destination file. This allows the client to issue parallel copies to implement operations such as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースはオフセットやソースがプラスオフセットカウントは、ソースファイルのサイズよりも大きい場合、操作はNFS4ERR_INVALで失敗しなければなりません。オフセットまたは宛先オフセットプラスカウント先は先のファイルのサイズよりも大きくすることができます。これは、クライアントのような操作を実装するために、並列コピーを発行することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
% cat file1 file2 file3 file4 &gt; dest
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
％の猫ファイル1ファイル2ファイル3 FILE4&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the ca_source_server list is specified, then this is an inter-server COPY operation and the source file is on a remote server. The client is expected to have previously issued a successful COPY_NOTIFY request to the remote source server. The ca_source_server list MUST be the same as the COPY_NOTIFY response&#39;s cnr_source_server list. If the client includes the entries from the COPY_NOTIFY response&#39;s cnr_source_server list in the ca_source_server list, the source server can indicate a specific copy protocol for the destination server to use by returning a URL that specifies both a protocol service and server name. Server-to-server copy protocol considerations are described in Sections 4.6 and 4.9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ca_source_serverリストが指定されている場合、これはサーバ間のコピー操作で、ソースファイルは、リモートサーバー上にあります。クライアントが以前にリモートソースサーバに成功したCOPY_NOTIFY要求を発行していると予想されます。 ca_source_serverリストはCOPY_NOTIFY応答のcnr_source_serverリストと同じでなければなりません。クライアントがca_source_serverリストでCOPY_NOTIFY応答のcnr_source_serverリストからエントリが含まれている場合、宛先サーバは、プロトコルサービスとサーバー名の両方を指定するURLを返すことによって使用するために、ソース・サーバーは、特定のコピープロトコルを示すことができます。サーバー間のコピープロトコルの考慮事項については、セクション4.6と4.9.1で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If ca_consecutive is set, then the client has specified that the copy protocol selected MUST copy bytes in consecutive order from ca_src_offset to ca_count. If the destination server cannot meet this requirement, then it MUST return an error of NFS4ERR_OFFLOAD_NO_REQS and set cr_consecutive to be FALSE. Likewise, if ca_synchronous is set, then the client has required that the copy protocol selected MUST perform a synchronous copy. If the destination server cannot meet this requirement, then it MUST return an error of NFS4ERR_OFFLOAD_NO_REQS and set cr_synchronous to be FALSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ca_consecutiveが設定されている場合、クライアントは、選択したコピープロトコルがca_src_offsetからca_countに連続した順序でバイトをコピーしなければならないことを指定しています。宛先サーバーがこの要件を満たすことができないなら、それはNFS4ERR_OFFLOAD_NO_REQSのエラーを返し、FALSEであることがcr_consecutive設定しなければなりません。 ca_synchronousが設定されている場合は同様に、クライアントは、選択したコピープロトコルが同期コピーを実行しなければなりませんことを必要としています。宛先サーバーがこの要件を満たすことができないなら、それはNFS4ERR_OFFLOAD_NO_REQSのエラーを返し、FALSEであることがcr_synchronous設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If both are set by the client, then the destination SHOULD try to determine if it can respond to both requirements at the same time. If it cannot make that determination, it must set to TRUE the one it can and set to FALSE the other. The client, upon getting an NFS4ERR_OFFLOAD_NO_REQS error, has to examine both cr_consecutive and cr_synchronous against the respective values of ca_consecutive and ca_synchronous to determine the possible requirement not met. It MUST be prepared for the destination server not being able to determine both requirements at the same time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
両方がクライアントによって設定されている場合、その先には、それは同時に両方の要件に対応できるかどうかを判断するようにしてください。それはその決定を行うことができない場合は、TRUEにそれはとFALSE他に設定することができるものを設定する必要があります。クライアントは、NFS4ERR_OFFLOAD_NO_REQSのエラーを取得すると、満たされていない可能性の要件を決定するためにca_consecutiveとca_synchronousのそれぞれの値に対してcr_consecutiveとcr_synchronousの両方を検討する必要があります。これは、先のサーバが同時に両方の要件を決定することができないために準備しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon receiving the NFS4ERR_OFFLOAD_NO_REQS error, the client has to determine whether it wants to re-request the copy with a relaxed set of requirements or revert to manually copying the data. If it decides to manually copy the data and this is a remote copy, then the client is responsible for informing the source that the earlier COPY_NOTIFY is no longer valid by sending it an OFFLOAD_CANCEL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_OFFLOAD_NO_REQSエラーを受信すると、クライアントは、それが要件の緩和されたセットでコピーを再要求するか、手動でデータをコピーするために復帰したいかどうかを決定しなければなりません。それは手動でデータをコピーすることを決定し、これは、リモートコピーである場合、クライアントは以前COPY_NOTIFYはそれをOFFLOAD_CANCELを送信することにより、もはや有効であることをソースに通知する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the operation does not result in an immediate failure, the server will return NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作はすぐに故障が生じない場合は、サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the wr_callback_id is returned, this indicates that an asynchronous COPY operation was initiated and a CB_OFFLOAD callback will deliver the final results of the operation. The wr_callback_id stateid is termed a &#34;copy stateid&#34; in this context. The server is given the option of returning the results in a callback because the data may require a relatively long period of time to copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
wr_callback_idが返された場合、これは、非同期コピー操作が開始されたことを示し、CB_OFFLOADコールバックは、操作の最終結果をお届けします。 wr_callback_idののstateidは、この文脈での「コピーのstateid」と呼ばれています。データをコピーするために、比較的長い時間を必要とする場合があるため、サーバーは、コールバックで結果を返すのオプションが与えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If no wr_callback_id is returned, the operation completed synchronously and no callback will be issued by the server. The completion status of the operation is indicated by cr_status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何wr_callback_idが返されない場合、操作は同期的に完了し、コールバックは、サーバーによって発行されません。操作の完了ステータスはcr_statusで示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the copy completes successfully, either synchronously or asynchronously, the data copied from the source file to the destination file MUST appear identical to the NFS client. However, the NFS server&#39;s on-disk representation of the data in the source file and destination file MAY differ. For example, the NFS server might encrypt, compress, deduplicate, or otherwise represent the on-disk data in the source and destination files differently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コピーが正常に完了した場合、同期または非同期、ソースファイルから目的ファイルにコピーされたデータは、NFSクライアントと同じで現れなければなりません。ただし、ソースファイルと宛先ファイル内のデータのNFSサーバのディスク上の表現が異なる場合があります。たとえば、NFSサーバは、暗号化、圧縮、重複排除、またはそれ以外の場合は、異なる送信元と送信先のファイルで、ディスク上のデータを表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a failure does occur for a synchronous copy, wr_count will be set to the number of bytes copied to the destination file before the error occurred. If cr_consecutive is TRUE, then the bytes were copied in order. If the failure occurred for an asynchronous copy, then the client will have gotten the notification of the consecutive copy order when it got the copy stateid. It will be able to determine the bytes copied from the coa_bytes_copied in the CB_OFFLOAD argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
障害が同期コピーのために発生した場合は、エラーが発生する前に、wr_countは先のファイルにコピーされたバイト数に設定されます。 cr_consecutiveがTRUEの場合、バイトは順番にコピーされました。障害が非同期コピーのために発生した場合、クライアントは、それがコピーのstateidを得た連続したコピー順の通知を得ているでしょう。 CB_OFFLOAD引数にcoa_bytes_copiedからコピーされたバイトを決定することができるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In either case, if cr_consecutive was not TRUE, there is no assurance as to exactly which bytes in the range were copied. The client MUST assume that there exists a mixture of the original contents of the range and the new bytes. If the COPY wrote past the end of the file on the destination, then the last byte written to will determine the new file size. The contents of any block not written to and past the original size of the file will be as if a normal WRITE extended the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cr_consecutiveがTRUEでなかった場合はいずれの場合においても、正確範囲でどのバイトがコピーしたするように保証はありません。クライアントは、範囲の元の内容と新しいバイトの混合物が存在すると仮定しなければなりません。 COPYは、先にファイルの終わりを過ぎて書いた場合は、に書き込まれた最後のバイトは、新しいファイルサイズを決定します。通常のWRITEは、ファイルを拡張しているかのように、ファイルの元のサイズを超えて書き込まれていない任意のブロックの内容になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
15.3. Operation 61: COPY_NOTIFY - Notify a source server of a future copy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
15.3。操作61：COPY_NOTIFY  - 未来コピーのソースサーバーに通知
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COPY_NOTIFY4args {
           /* CURRENT_FH: source file */
           stateid4        cna_src_stateid;
           netloc4         cna_destination_server;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COPY_NOTIFY4resok {
           nfstime4        cnr_lease_time;
           stateid4        cnr_stateid;
           netloc4         cnr_source_server&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union COPY_NOTIFY4res switch (nfsstat4 cnr_status) {
   case NFS4_OK:
           COPY_NOTIFY4resok       resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is used for an inter-server copy. A client sends this operation in a COMPOUND request to the source server to authorize a destination server identified by cna_destination_server to read the file specified by CURRENT_FH on behalf of the given user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作は、サーバー間コピーに使用されます。クライアントは、特定のユーザーに代わってCURRENT_FHで指定されたファイルを読み込むためにcna_destination_serverによって識別される宛先サーバーを承認するためにソースサーバにCOMPOUND要求に、この操作を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cna_src_stateid MUST refer to either open or locking states provided earlier by the server. If it is invalid, then the operation MUST fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cna_src_stateidは、サーバによって以前提供されるオープンまたはロック状態のいずれかを参照する必要があります。それが無効である場合、操作は失敗しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cna_destination_server MUST be specified using the netloc4 network location format. The server is not required to resolve the cna_destination_server address before completing this operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cna_destination_serverはnetloc4ネットワーク・ロケーション・フォーマットを使用して指定されなければなりません。サーバーは、この操作を完了する前にcna_destination_serverアドレスを解決するために必要とされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If this operation succeeds, the source server will allow the cna_destination_server to copy the specified file on behalf of the given user as long as both of the following conditions are met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作が成功した場合は、ソースサーバはcna_destination_serverがいる限り、次の両方の条件が満たされているとして、特定のユーザーに代わって指定されたファイルをコピーすることができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The destination server begins reading the source file before the cnr_lease_time expires. If the cnr_lease_time expires while the destination server is still reading the source file, the destination server is allowed to finish reading the file. If the cnr_lease_time expires before the destination server uses READ or READ_PLUS to begin the transfer, the source server can use NFS4ERR_PARTNER_NO_AUTH to inform the destination server that the cnr_lease_time has expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O先サーバーはcnr_lease_timeの有効期限が切れる前に、ソースファイルの読み込みを開始します。先サーバーは、まだソースファイルを読んでいる間、cnr_lease_timeの有効期限が切れた場合は、宛先サーバーは、ファイルを読み終えるために許可されています。宛先サーバーが転送を開始するREADまたはREAD_PLUSを使用する前にcnr_lease_timeの有効期限が切れた場合は、ソースサーバはcnr_lease_timeの期限が切れている先サーバーに通知するNFS4ERR_PARTNER_NO_AUTHを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The client has not issued an OFFLOAD_CANCEL for the same combination of user, filehandle, and destination server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクライアントは、ユーザ、ファイルハンドル、および先サーバの同じ組み合わせのためOFFLOAD_CANCELを発行しておりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cnr_lease_time is chosen by the source server. A cnr_lease_time of 0 (zero) indicates an infinite lease. To avoid the need for synchronized clocks, copy lease times are granted by the server as a time delta. To renew the copy lease time, the client should resend the same copy notification request to the source server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cnr_lease_timeは、ソースサーバによって選択されます。 0（ゼロ）のcnr_lease_timeは、無限リースを示しています。同期クロックの必要性を回避するには、コピーのリース時間は、時間デルタとしてサーバによって付与されます。コピーリース期間を更新するには、クライアントは、ソースサーバーに同じコピー通知要求を再送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cnr_stateid is a copy stateid that uniquely describes the state needed on the source server to track the proposed COPY. As defined in Section 8.2 of [RFC5661], a stateid is tied to the current filehandle, and if the same stateid is presented by two different clients, it may refer to different states. As the source does not know which netloc4 network location the destination might use to establish the COPY operation, it can use the cnr_stateid to identify that the destination is operating on behalf of the client. Thus, the source server MUST construct copy stateids such that they are distinct from all other stateids handed out to clients. These copy stateids MUST denote the same set of locks as each of the earlier delegation, locking, and open states for the client on the given file (see Section 4.3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cnr_stateidは一意に提案COPYを追跡するために、ソースサーバ上で必要な状態を記述するコピーのstateidです。 [RFC5661]のセクション8.2で定義されるように、のstateidは、現在のファイルハンドルに接続され、そして同じのstateidが2つの異なるクライアントによって提示された場合、それは別の状態を参照することができます。ソースは宛先がコピー操作を確立するために使用する可能性があるnetloc4ネットワーク上の場所を知らないので、それは先がクライアントの代わりに動作していることを識別するためにcnr_stateidを使用することができます。このように、ソースサーバは、彼らが顧客に配った他のすべてのstateids区別されるようなコピーのstateidsを構築しなければなりません。これらのコピーのstateidsが与えられたファイル上のクライアントのために以前の委任、ロック、オープン状態のそれぞれのようにロックの同じセットを表す必要があります（4.3.1項を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A successful response will also contain a list of netloc4 network location formats called cnr_source_server, on which the source is willing to accept connections from the destination. These might not be reachable from the client and might be located on networks to which the client has no connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功した応答は、ソース、宛先からの接続を受け入れる意志があるれるcnr_source_server呼ばnetloc4ネットワーク・ロケーション・フォーマットのリストを含むであろう。これらは、クライアントから到達可能ではないかもしれないと、クライアントが接続されていない先のネットワークに設置されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This operation is unnecessary for an intra-server copy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作は、イントラサーバーコピーには不要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4. Operation 62: DEALLOCATE - Unreserve space in a region of a file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4。操作62：DEALLOCATE  - ファイルの領域に予約解除スペース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DEALLOCATE4args {
           /* CURRENT_FH: file */
           stateid4        da_stateid;
           offset4         da_offset;
           length4         da_length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DEALLOCATE4res {
           nfsstat4        dr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever a client wishes to unreserve space for a region in a file, it calls the DEALLOCATE operation with the current filehandle set to the filehandle of the file in question, and with the start offset and length in bytes of the region set in da_offset and da_length, respectively. If no space was allocated or reserved for all or parts of the region, the DEALLOCATE operation will have no effect for the region that already is in unreserved state. All further READs from the region passed to DEALLOCATE MUST return zeros until overwritten.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがファイルに地域のためのスペースを予約解除したいときはいつでも、それは問題のファイルのファイルハンドルに設定された現在のファイルハンドルとDEALLOCATE操作を呼び出し、da_offsetとda_lengthに設定された領域のバイト単位の開始オフセットと長さを持ちます、それぞれ。スペースが割り当てられていないか、全てまたは地域の一部のために予約された場合は、DEALLOCATE操作は、既に予約されていない状態になっている地域のためには効果がありません。すべてのさらに上書きされるまでゼロを返さなければならないDEALLOCATEに渡された領域から読み込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CURRENT_FH must be a regular file. If CURRENT_FH is not a regular file, the operation MUST fail and return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CURRENT_FHは、通常のファイルでなければなりません。 CURRENT_FHが通常のファイルでない場合、操作は失敗し、NFS4ERR_WRONG_TYPEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The da_stateid MUST refer to a stateid that is valid for a WRITE operation and follows the rules for stateids in Sections 8.2.5 and 18.32.3 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
da_stateidは、書き込み動作のために有効であり、セクション8.2.5でのstateidsの規則に従い、[RFC5661]の18.32.3のstateidを参照しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Situations may arise where da_offset and/or da_offset + da_length will not be aligned to a boundary for which the server does allocations or deallocations. For most file systems, this is the block size of the file system. In such a case, the server can deallocate as many bytes as it can in the region. The blocks that cannot be deallocated MUST be zeroed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
da_offset及び/又はda_offset + da_lengthサーバが割り当てまたは割り当て解除を行う対象の境界に位置合わせされない場合の状況が生じ得ます。ほとんどのファイルシステムでは、これはファイルシステムのブロックサイズです。このような場合、サーバは、多くのバイトが領域内にできる限りの割り当てを解除することができます。割り当てを解除することができないブロックがゼロにされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DEALLOCATE will result in the space_used attribute being decreased by the number of bytes that were deallocated. The space_freed attribute may or may not decrease, depending on the support and whether the blocks backing the specified range were shared or not. The size attribute will remain unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DEALLOCATEはspace_used属性が割り当て解除されたバイトの数だけ減少されることになります。 space_freed属性がまたはサポートに応じ、減少しない場合があり、指定した範囲をバックアップブロックは共有されたのかどうか。サイズ属性は変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
15.5. Operation 63: IO_ADVISE - Send client I/O access pattern hints to the server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
15.5。操作63：IO_ADVISE  - クライアントの送信I / Oアクセスパターンサーバーへのヒント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum IO_ADVISE_type4 { IO_ADVISE4_NORMAL = 0, IO_ADVISE4_SEQUENTIAL = 1, IO_ADVISE4_SEQUENTIAL_BACKWARDS = 2, IO_ADVISE4_RANDOM = 3, IO_ADVISE4_WILLNEED = 4, IO_ADVISE4_WILLNEED_OPPORTUNISTIC = 5, IO_ADVISE4_DONTNEED = 6, IO_ADVISE4_NOREUSE = 7, IO_ADVISE4_READ = 8, IO_ADVISE4_WRITE = 9, IO_ADVISE4_INIT_PROXIMITY = 10 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙IO_ADVISE_type4 {IO_ADVISE4_NORMAL = 0、IO_ADVISE4_SEQUENTIAL = 1、IO_ADVISE4_SEQUENTIAL_BACKWARDS = 2、IO_ADVISE4_RANDOM = 3、IO_ADVISE4_WILLNEED = 4、IO_ADVISE4_WILLNEED_OPPORTUNISTIC = 5、IO_ADVISE4_DONTNEED = 6、IO_ADVISE4_NOREUSE = 7、IO_ADVISE4_READ = 8、IO_ADVISE4_WRITE = 9、IO_ADVISE4_INIT_PROXIMITY = 10}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct IO_ADVISE4args {
           /* CURRENT_FH: file */
           stateid4        iaa_stateid;
           offset4         iaa_offset;
           length4         iaa_count;
           bitmap4         iaa_hints;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct IO_ADVISE4resok {
           bitmap4 ior_hints;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union IO_ADVISE4res switch (nfsstat4 ior_status) {
   case NFS4_OK:
           IO_ADVISE4resok resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IO_ADVISE operation sends an I/O access pattern hint to the server for the owner of the stateid for a given byte range specified by iar_offset and iar_count. The byte range specified by iaa_offset and iaa_count need not currently exist in the file, but the iaa_hints will apply to the byte range when it does exist. If iaa_count is 0, all data following iaa_offset is specified. The server MAY ignore the advice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE動作はiar_offsetとiar_countによって指定された指定されたバイト範囲のためのstateidの所有者のためにサーバにI / Oアクセスパターンヒントを送信します。 iaa_offsetとiaa_countで指定されたバイト範囲は、現在ファイルに存在する必要はないが、それが存在しない場合iaa_hintsはバイト範囲に適用されます。 iaa_countが0の場合、iaa_offset以下のすべてのデータが指定されています。サーバは、アドバイスを無視してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following are the allowed hints for a stateid holder:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
stateidホルダーのための許可のヒントは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_NORMAL There is no advice to give. This is the default behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_NORMAL与えるために何のアドバイスはありません。これがデフォルトの動作です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_SEQUENTIAL Expects to access the specified data sequentially from lower offsets to higher offsets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_SEQUENTIALは、より高いオフセットに低オフセットから指定されたデータを順次アクセスすることを期待しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_SEQUENTIAL_BACKWARDS Expects to access the specified data sequentially from higher offsets to lower offsets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_SEQUENTIAL_BACKWARDSはオフセットを下げるために高いオフセットから指定されたデータを順次アクセスすることを期待しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_RANDOM Expects to access the specified data in a random order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_RANDOMはランダムな順序で指定されたデータにアクセスすることを期待しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_WILLNEED Expects to access the specified data in the near future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_WILLNEEDは、近い将来に指定されたデータにアクセスすることを期待しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_WILLNEED_OPPORTUNISTIC Expects to possibly access the data in the near future. This is a speculative hint, and therefore the server should prefetch data or indirect blocks only if it can be done at a marginal cost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_WILLNEED_OPPORTUNISTICは、おそらく近い将来にデータにアクセスすることを期待しています。これは、投機的なヒントであるため、サーバはそれが限界費用で行うことができる場合にのみ、データまたは間接ブロックをプリフェッチする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE_DONTNEED Expects that it will not access the specified data in the near future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE_DONTNEEDは、それが近い将来に指定されたデータにアクセスしないであろうことを期待しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE_NOREUSE Expects to access the specified data once and then not reuse it thereafter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE_NOREUSEは一度指定されたデータにアクセスすることを期待して、その後、それを再利用しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_READ Expects to read the specified data in the near future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_READは、近い将来に指定されたデータを読み出すために期待しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_WRITE Expects to write the specified data in the near future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_WRITEは、近い将来に指定されたデータを書き込むために期待しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_INIT_PROXIMITY Informs the server that the data in the byte range remains important to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_INIT_PROXIMITYはバイト範囲内のデータがクライアントに重要なままサーバーに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since IO_ADVISE is a hint, a server SHOULD NOT return an error and invalidate an entire COMPOUND request if one of the sent hints in iar_hints is not supported by the server. Also, the server MUST NOT return an error if the client sends contradictory hints to the server, e.g., IO_ADVISE4_SEQUENTIAL and IO_ADVISE4_RANDOM in a single IO_ADVISE operation. In these cases, the server MUST return success and an ior_hints value that indicates the hint it intends to implement. This may mean simply returning IO_ADVISE4_NORMAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISEがヒントですのでiar_hintsで送信されたヒントの一つがサーバによってサポートされていない場合、サーバーはエラーを返し、化合物全体の要求を無効にすべきではありません。クライアントは、単一のIO_ADVISE操作で、例えば、IO_ADVISE4_SEQUENTIALとIO_ADVISE4_RANDOM、サーバに矛盾するヒントを送信した場合も、サーバーはエラーを返してはなりません。これらのケースでは、サーバは成功し、それを実装する予定のヒントを示しior_hints値を返さなければなりません。これはIO_ADVISE4_NORMALを返す単に意味するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ior_hints returned by the server is primarily for debugging purposes, since the server is under no obligation to carry out the hints that it describes in the ior_hints result. In addition, while the server may have intended to implement the hints returned in ior_hints, the server may need to change its handling of a given file -- for example, because of memory pressure, additional IO_ADVISE hints sent by other clients, or heuristically detected file access patterns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはそれがior_hints結果で説明するヒントを実行する義務を負いませんので、サーバから返さior_hintsは、デバッグ目的のために主にあります。サーバはヒントがior_hintsで返さ実装することを意図しているかもしれないがまた、サーバーは、指定したファイルの取り扱いを変更する必要があるかもしれません - 例えば、なぜならメモリ圧力のため、追加のIO_ADVISEヒントは、他のクライアントによって送信される、またはヒューリスティック検出しますファイル・アクセス・パターン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MAY return different advice than what the client requested. Some examples include another client advising of a different I/O access pattern, another client employing a different I/O access pattern, or inability of the server to support the requested I/O access pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、クライアントが要求したものとは異なるアドバイスを返す場合があります。いくつかの例は、さまざまなI / Oアクセスパターン、異なるI / Oアクセスパターン、または要求されたI / Oアクセスパターンをサポートするサーバーのできないことを利用し、別のクライアントの助言別のクライアントが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each issuance of the IO_ADVISE operation overrides all previous issuances of IO_ADVISE for a given byte range. This effectively follows a strategy of &#34;last hint wins&#34; for a given stateid and byte range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE動作の各発行は、指定されたバイト範囲のIO_ADVISEの以前のすべての発行を上書き。これは、効果的に与えられたstateidとバイト範囲のための「最後のヒント勝利」の戦略に従っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients should assume that hints included in an IO_ADVISE operation will be forgotten once the file is closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、ファイルが閉じられるとIO_ADVISE操作に含まヒントが忘れ去られることを前提とすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.4。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFS client may choose to issue an IO_ADVISE operation to the server in several different instances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSクライアントは、いくつかの異なるインスタンス内のサーバーにIO_ADVISE操作を発行することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The most obvious is in direct response to an application&#39;s execution of posix_fadvise(). In this case, IO_ADVISE4_WRITE and IO_ADVISE4_READ may be set, based upon the type of file access specified when the file was opened.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最も明白なはposix_fadviseのアプリケーションの実行（）に直接対応しています。この場合、IO_ADVISE4_WRITEとIO_ADVISE4_READは、ファイルを開いたときに指定したファイルアクセスのタイプに基づいて、設定されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.5. IO_ADVISE4_INIT_PROXIMITY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.5。 IO_ADVISE4_INIT_PROXIMITY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IO_ADVISE4_INIT_PROXIMITY hint is non-POSIX in origin and can be used to convey that the client has recently accessed the byte range in its own cache. That is, it has not accessed it on the server but has accessed it locally. When the server reaches resource exhaustion, knowing which data is more important allows the server to make better choices about which data to, for example, purge from a cache or move to secondary storage. It also informs the server as to which delegations are more important, because if delegations are working correctly, once delegated to a client and the client has read the content for that byte range, a server might never receive another READ request for that byte range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_INIT_PROXIMITYヒントは、起源が非POSIXであり、クライアントが自身のキャッシュにバイト範囲を最近アクセスしたことを伝えるために使用することができます。つまり、それは、サーバー上でアクセスしていないが、それをローカルにアクセスしてきました。サーバーはリソースの枯渇に達すると、より重要となるデータを知ること、例えば、サーバはへデータに関するよりよい選択をするために、二次ストレージにキャッシュまたは移動からパージすることができます。クライアントに委譲し、クライアントがそのバイト範囲のコンテンツを読んでいたら代表団は、正しく動作している場合、サーバはそのバイト範囲のための別のREAD要求を受けたことがないかもしれないので、その代表団は、より重要であるためにように、それはまた、サーバーに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IO_ADVISE4_INIT_PROXIMITY hint can also be used in a pNFS setting to let the client inform the metadata server as to the I/O statistics between the client and the storage devices. The metadata server is then free to use this information about client I/O to optimize the data storage location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IO_ADVISE4_INIT_PROXIMITYヒントは、クライアントは、クライアントとストレージデバイス間のI / O統計になどのメタデータサーバに通知できるように設定するのpNFSで使用することができます。メタデータサーバは、データの保存場所を最適化するために、クライアントI / Oについては、この情報を使用して自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This hint is also useful in the case of NFS clients that are network-booting from a server. If the first client to be booted sends this hint, then it keeps the cache warm for the remaining clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このヒントは、サーバからネットワーク・ブートしているNFSクライアントの場合にも便利です。ブートするための最初のクライアントは、このヒントを送信した場合、それは残りのクライアントのキャッシュを暖かく保ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.6. pNFS File Layout Data Type Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.6。 pNFSのレイアウトデータ型に関する注意事項ファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IO_ADVISE considerations for pNFS are very similar to the COMMIT considerations for pNFS (see Section 13.7 of [RFC5661]). That is, as with COMMIT, some NFS server implementations prefer that IO_ADVISE be done on the storage device, and some prefer that it be done on the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSのためIO_ADVISEの考慮事項は、（[RFC5661]のセクション13.7を参照）pNFSのためのCOMMIT考慮に非常に類似しています。つまり、COMMITと同様に、いくつかのNFSサーバの実装はIO_ADVISEは、記憶装置上で行われることを好む、そしていくつかは、それがメタデータサーバ上で行うことを好むです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the file&#39;s layout type, NFSv4.2 includes an additional hint, NFL42_CARE_IO_ADVISE_THRU_MDS, which is valid only on metadata servers running NFSv4.2 or higher. (&#34;NFL&#34; stands for &#34;NFS File Layout&#34;.) Any file&#39;s layout obtained from an NFSv4.1 metadata server MUST NOT have NFL42_UFLG_IO_ADVISE_THRU_MDS set. Any file&#39;s layout obtained with an NFSv4.2 metadata server MAY have NFL42_UFLG_IO_ADVISE_THRU_MDS set. However, if the layout utilizes NFSv4.1 storage devices, the IO_ADVISE operation cannot be sent to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルのレイアウトタイプの場合は、NFSv4.2はNFSv4.2以上を実行して、メタデータサーバー上で有効である追加のヒント、NFL42_CARE_IO_ADVISE_THRU_MDSを、含まれています。 （「NFL」「NFSは、ファイルレイアウト」の略です。）NFSv4.1メタデータサーバから取得したすべてのファイルのレイアウトはNFL42_UFLG_IO_ADVISE_THRU_MDSセットを持ってはいけません。 NFSv4.2のメタデータ・サーバで得られたすべてのファイルのレイアウトはNFL42_UFLG_IO_ADVISE_THRU_MDSセットを持っているかもしれません。レイアウトはNFSv4.1ストレージデバイスを利用している場合しかし、IO_ADVISE操作は、それらに送信することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If NFL42_UFLG_IO_ADVISE_THRU_MDS is set, the client MUST send the IO_ADVISE operation to the metadata server in order for it to be honored by the storage device. Once the metadata server receives the IO_ADVISE operation, it will communicate the advice to each storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFL42_UFLG_IO_ADVISE_THRU_MDSが設定されている場合、クライアントは、それが記憶装置によって表彰されるためには、メタデータサーバにIO_ADVISE操作を送らなければなりません。メタデータサーバはIO_ADVISE操作を受信すると、それは、各ストレージ・デバイスへのアドバイスを伝えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If NFL42_UFLG_IO_ADVISE_THRU_MDS is not set, then the client SHOULD send an IO_ADVISE operation to the appropriate storage device for the specified byte range. While the client MAY always send IO_ADVISE to the metadata server, if the server has not set NFL42_UFLG_IO_ADVISE_THRU_MDS, the client should expect that such an IO_ADVISE is futile. Note that a client SHOULD use the same set of arguments on each IO_ADVISE sent to a storage device for the same open file reference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFL42_UFLG_IO_ADVISE_THRU_MDSが設定されていない場合、クライアントは指定されたバイト範囲のための適切なストレージデバイスにIO_ADVISE操作を送るべきです。クライアントは常にメタデータサーバにIO_ADVISEを送るかもしれないが、サーバーがNFL42_UFLG_IO_ADVISE_THRU_MDSを設定していない場合、クライアントは、このようなIO_ADVISEが無益であることを期待してください。クライアントが同じオープンファイルリファレンスのストレージ・デバイスに送信された各IO_ADVISE上の引数の同じセットを使用する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server is not required to support different advice for different storage devices with the same open file reference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは同じオープンファイルを参照して異なるストレージ・デバイスごとに異なるアドバイスをサポートする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.6.1. Dense and Sparse Packing Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.5.6.1。緻密でスパースパッキングの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IO_ADVISE operation MUST use the iar_offset and byte range as dictated by the presence or absence of NFL4_UFLG_DENSE (see Section 13.4.4 of [RFC5661]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFL4_UFLG_DENSEの存在または不在によって決定されるようIO_ADVISE動作は（[RFC5661]のセクション13.4.4を参照）iar_offsetおよびバイト範囲を使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if NFL4_UFLG_DENSE is present, then (1) a READ or WRITE to the storage device for iaa_offset 0 really means iaa_offset 10000 in the logical file and (2) an IO_ADVISE for iaa_offset 0 means iaa_offset 10000 in the logical file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFL4_UFLG_DENSEが存在する場合、例えば、次に（1）READまたはiaa_offset 0ために記憶装置への書き込みは、実際の論理ファイルにiaa_offset 10000を意味し、（2）iaa_offset 0手段がIO_ADVISE論理ファイル10000をiaa_offset。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if NFL4_UFLG_DENSE is absent, then (1) a READ or WRITE to the storage device for iaa_offset 0 really means iaa_offset 0 in the logical file and (2) an IO_ADVISE for iaa_offset 0 means iaa_offset 0 in the logical file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFL4_UFLG_DENSEが存在しない場合、例えば、次に（1）READまたはiaa_offset 0ために記憶装置への書き込みは、実際の論理ファイルにiaa_offset 0を意味し、（2）iaa_offset 0手段がIO_ADVISEは、論理ファイルに0をiaa_offset。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if NFL4_UFLG_DENSE is present, the stripe unit is 1000 bytes and the stripe count is 10, and the dense storage device file is serving iar_offset 0. A READ or WRITE to the storage device for iaa_offsets 0, 1000, 2000, and 3000 really means iaa_offsets 10000, 20000, 30000, and 40000 (implying a stripe count of 10 and a stripe unit of 1000), and then an IO_ADVISE sent to the same storage device with an iaa_offset of 500 and an iaa_count of 3000 means that the IO_ADVISE applies to these byte ranges of the dense storage device file:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えばNFL4_UFLG_DENSEが存在する場合、ストライプユニットが1000バイトであり、ストライプの数は10であり、緻密なストレージデバイスファイルはiar_offset 0 A READサービングまたはiaa_offsets 0、1000,2000、および3000のための記憶装置への書き込みされます実際iaa_offsets 10000、20000、30000、および40000（10のストライプ数1000のストライプ部を意味する）を意味し、そして次いでIO_ADVISE 500のiaa_offset 3000のiaa_countと同一のストレージ装置に送信することを意味IO_ADVISE高密度のストレージ・デバイス・ファイルのこれらのバイト範囲に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 500 to 999 - 1000 to 1999 - 2000 to 2999 - 3000 to 3499
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3499から3000  -  2999年から2000年 -  1999年から1000年 -   -  999から500
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
That is, the contiguous range 500 to 3499, as specified in IO_ADVISE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すなわち、IO_ADVISEで指定されるように3499の連続した範囲500です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It also applies to these byte ranges of the logical file:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、論理ファイルのこれらのバイト範囲に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 10500 to 10999 (500 bytes) - 20000 to 20999 (1000 bytes) - 30000 to 30999 (1000 bytes) - 40000 to 40499 (500 bytes) (total 3000 bytes)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  10500 10999に（500バイト） -  20000 20999に（1000バイト） -  30000 30999に（1000バイト） -  40000 40499に（500バイト）（合計3000バイト）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if NFL4_UFLG_DENSE is absent, the stripe unit is 250 bytes, the stripe count is 4, and the sparse storage device file is serving iaa_offset 0. Then, a READ or WRITE to the storage device for iaa_offsets 0, 1000, 2000, and 3000 really means iaa_offsets 0, 1000, 2000, and 3000 in the logical file, keeping in mind that in the storage device file byte ranges 250 to 999, 1250 to 1999, 2250 to 2999, and 3250 to 3999 are not accessible. Then, an IO_ADVISE sent to the same storage device with an iaa_offset of 500 and an iaa_count of 3000 means that the IO_ADVISE applies to these byte ranges of the logical file and the sparse storage device file:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えばNFL4_UFLG_DENSEが存在しない場合、ストライプ単位は250バイトであり、ストライプ・カウントは4であり、そしてスパースストレージデバイスファイルは、次にiaa_offset 0にサービスを提供している、READまたはiaa_offsets 0 1000、2000用の記憶装置への書き込みそして3000は本当に記憶装置ファイルのバイトで2999年に1999年、2250年に999から250まで、1250年の範囲ということを念頭に置いて、論理ファイルにiaa_offsets 0、1000年、2000年、および3000を意味し、3999から3250にはアクセスできません。次いで、IO_ADVISE 500のiaa_offsetと同じ記憶装置に送られ、3000のiaa_countはIO_ADVISE論理ファイル及びスパース記憶装置ファイルのこれらのバイト範囲に適用されることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- 500 to 999 (500 bytes) - no effect - 1000 to 1249 (250 bytes) - effective - 1250 to 1999 (750 bytes) - no effect - 2000 to 2249 (250 bytes) - effective - 2250 to 2999 (750 bytes) - no effect - 3000 to 3249 (250 bytes) - effective - 3250 to 3499 (250 bytes) - no effect (subtotal 2250 bytes) - no effect (subtotal 750 bytes) - effective (grand total 3000 bytes) - no effect + effective
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  500から999（500バイト） - 全く効果 -  1249（250バイト）1000  - 有効 -  1999から1250（750バイト） - 全く効果 -  2249（250バイト）2000  - 有効 -  2999から2250（750バイト） 3249（250バイト）3000  -   -   - 何ら影響しない効果的な -  3250 3499（250バイト） - 効果なし（小計2250バイト） - 効果なし（小計750バイト） - 有効（総計3000バイト） - 効果なし+実効
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If neither the NFL42_UFLG_IO_ADVISE_THRU_MDS flag nor the NFL4_UFLG_DENSE flag is set in the layout, then any IO_ADVISE request sent to the data server with a byte range that overlaps stripe units that the data server does not serve MUST NOT result in the status NFS4ERR_PNFS_IO_HOLE. Instead, the response SHOULD be successful, and if the server applies IO_ADVISE hints on any stripe units that overlap with the specified range, those hints SHOULD be indicated in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFL42_UFLG_IO_ADVISE_THRU_MDSフラグもNFL4_UFLG_DENSEフラグでもないが、レイアウトに設定されている場合、データ・サーバが機能していないストライプユニットと重なるバイト範囲をデータ・サーバに送信されたIO_ADVISE要求がステータスNFS4ERR_PNFS_IO_HOLEにつながるなりません。その代わりに、応答が成功する必要があり、サーバが指定された範囲と重複任意のストライプユニットにIO_ADVISEヒントを適用する場合は、それらのヒントは、応答して表示すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6. Operation 64: LAYOUTERROR - Provide errors for the layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6。操作64：LAYOUTERROR  - レイアウトのエラーを提供します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct device_error4 {
           deviceid4       de_deviceid;
           nfsstat4        de_status;
           nfs_opnum4      de_opnum;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTERROR4args {
           /* CURRENT_FH: file */
           offset4                 lea_offset;
           length4                 lea_length;
           stateid4                lea_stateid;
           device_error4           lea_errors&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTERROR4res {
           nfsstat4        ler_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client can use LAYOUTERROR to inform the metadata server about errors in its interaction with the layout (see Section 12 of [RFC5661]) represented by the current filehandle, client ID (derived from the session ID in the preceding SEQUENCE operation), byte range (lea_offset + lea_length), and lea_stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、現在のファイルハンドルによって表されるレイアウトとのその相互作用におけるエラーに関するメタデータサーバ（[RFC5661]のセクション12を参照）、（前回のシーケンス動作のセッションIDに由来する）は、クライアントID、バイト範囲を通知するLAYOUTERRORを使用することができ（lea_offset + lea_length）、及びlea_stateid。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each individual device_error4 describes a single error associated with a storage device, which is identified via de_deviceid. If the layout type (see Section 12.2.7 of [RFC5661]) supports NFSv4 operations, then the operation that returned the error is identified via de_opnum. If the layout type does not support NFSv4 operations, then either (1) it MAY choose to map the operation onto one of the allowed operations that can be sent to a storage device with the file layout type (see Section 3.3) or (2) it can signal no support for operations by marking de_opnum with the ILLEGAL operation. Finally, the NFS error value (nfsstat4) encountered is provided via de_status and may consist of the following error codes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各個々device_error4はde_deviceidを介して識別されたストレージデバイスに関連付けられた単一のエラーを説明します。レイアウトタイプは、（[RFC5661]のセクション12.2.7を参照）のNFSv4操作をサポートしている場合、エラーが返される操作がde_opnumを介して識別されます。レイアウトタイプのNFSv4操作をサポートしていない場合、その後、（1）それがファイルのレイアウトタイプのストレージデバイスに送信することができる許可された操作のいずれかに操作をマッピングするために選ぶかもしれません（セクション3.3を参照）または（2）それは不正な処理をde_opnumをマーキングすることにより、操作のためのサポートを知らせることはできません。最後に、遭遇したNFSエラー値（nfsstat4）はde_statusを介して提供され、次のエラーコードから成ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_NXIO: The client was unable to establish any communication with the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_NXIO：クライアントは、ストレージ・デバイスとの通信を確立することができませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_*: The client was able to establish communication with the storage device and is returning one of the allowed error codes for the operation denoted by de_opnum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_ *：クライアントは、ストレージ・デバイスとの通信を確立することができたとde_opnumで示される操作のための許可のエラーコードのいずれかを返しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that while the metadata server may return an error associated with the layout stateid or the open file, it MUST NOT return an error in the processing of the errors. If LAYOUTERROR is in a COMPOUND before LAYOUTRETURN, it MUST NOT introduce an error other than what LAYOUTRETURN would already encounter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メタデータサーバは、レイアウトのstateidまたは開いているファイルに関連付けられたエラーを返すかもしれないが、それがエラーの処理にエラーを返してはならないことに留意されたいです。 LAYOUTERRORはLAYOUTRETURN前COMPOUNDであれば、それはLAYOUTRETURNがすでに遭遇するもの以外のエラーを導入してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.6.4。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two broad classes of errors: transient and persistent. The client SHOULD strive to only use this new mechanism to report persistent errors. It MUST be able to deal with transient issues by itself. Also, while the client might consider an issue to be persistent, it MUST be prepared for the metadata server to consider such issues to be transient. A prime example of this is if the metadata server fences off a client from either a stateid or a filehandle. The client will get an error from the storage device and might relay either NFS4ERR_ACCESS or NFS4ERR_BAD_STATEID back to the metadata server, with the belief that this is a hard error. If the metadata server is informed by the client that there is an error, it can safely ignore that. For the metadata server, the mission is accomplished in that the client has returned a layout that the metadata server had most likely recalled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一過性と永続：エラーの二つの広いクラスがあります。クライアントは、永続的なエラーを報告するために、この新しいメカニズムを使用するように努力すべきです。それ自体で一過性の問題に対処できなければなりません。クライアントは問題が永続的であると考えるかもしれないが、また、一過性であることを、このような問題を検討するために、メタデータ・サーバ用に準備しなければなりません。メタデータサーバはのstateidまたはファイルハンドルのいずれかからクライアントをオフにフェンス場合は、このの典型的な例です。クライアントは、ストレージデバイスからエラーになりますと、これはハードエラーであることを確信して、戻ってメタデータサーバへNFS4ERR_ACCESSまたはNFS4ERR_BAD_STATEIDのいずれかを中継することがあります。メタデータサーバはエラーがあることをクライアントに通知された場合は、安全にそれを無視することができます。メタデータ・サーバの場合は、ミッションは、クライアントがメタデータサーバは、最も可能性の高いリコールしたレイアウトが戻ってきたことで達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client might also need to inform the metadata server that it cannot reach one or more of the storage devices. While the metadata server can detect the connectivity of both of these paths:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはまた、ストレージデバイスの一つ以上に達することができないメタデータサーバに通知する必要があるかもしれません。メタデータサーバは、これらのパスの両方の接続を検出することができますが。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o metadata server to storage device
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ストレージデバイスへのOメタデータ・サーバ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o metadata server to client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントへのOメタデータサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
it cannot determine if the client and storage device path is working. As with the case of the storage device passing errors to the client, it must be prepared for the metadata server to consider such outages as being transitory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとストレージデバイスのパスが機能しているかどうかは判断できません。クライアントにエラーを渡して、ストレージ装置の場合と同様に、一時的なものとして、このような停止を検討するメタデータサーバのために準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients are expected to tolerate transient storage device errors, and hence clients SHOULD NOT use the LAYOUTERROR error handling for device access problems that may be transient. The methods by which a client decides whether a device access problem is transient or persistent are implementation specific but may include retrying I/Os to a data server under appropriate conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、一過性記憶デバイスのエラーを許容することが期待され、したがって、クライアントは一過性であり、デバイスへのアクセスの問題を扱うLAYOUTERRORエラーを使用しないでください。クライアントは、デバイスアクセスの問題は一時的または永続的であるか否かを判断することにより、どの方法が特定の実装ですが、適切な条件下でのデータ・サーバへの再試行のI / Oを含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an I/O to a storage device fails, the client SHOULD retry the failed I/O via the metadata server. In this situation, before retrying the I/O, the client SHOULD return the layout, or the affected portion thereof, and SHOULD indicate which storage device or devices was problematic. The client needs to do this when the storage device is being unresponsive in order to fence off any failed write attempts and ensure that they do not end up overwriting any later data being written through the metadata server. If the client does not do this, the metadata server MAY issue a layout recall callback in order to perform the retried I/O.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ストレージデバイスへのI / Oが失敗すると、クライアントは、メタデータ・サーバを経由して失敗したI / Oを再試行する必要があります。この状況では、再試行I / Oの前に、クライアントは、レイアウト、またはその影響を受けた部分を返す必要があり、記憶装置またはデバイスが問題であったかを示すべきです。フェンスのためにオフいずれかが書き込みの試みを失敗し、彼らは、メタデータサーバを経由して書き込まれて、それ以降の任意のデータを上書きしてしまうことがないようにストレージデバイスが応答しないされているとき、クライアントはこれを実行する必要があります。クライアントはこれを実行しない場合は、メタデータサーバは、再試行I / Oを実行するために、レイアウトリコールコールバックを発行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client needs to be cognizant that since this error handling is optional in the metadata server, the metadata server may silently ignore this functionality. Also, as the metadata server may consider some issues the client reports to be expected, the client might find it difficult to detect a metadata server that has not implemented error handling via LAYOUTERROR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、このエラー処理は、メタデータサーバにオプションであることから、メタデータサーバは黙ってこの機能を無視してもよいことを認識している必要があります。メタデータサーバは、クライアントレポートが予想されるいくつかの問題を考慮することができるようまた、クライアントは、それが困難LAYOUTERROR経由でエラー処理を実装していないメタデータサーバーを検出するために見つけるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a metadata server is aware that a storage device is proving problematic to a client, the metadata server SHOULD NOT include that storage device in any pNFS layouts sent to that client. If the metadata server is aware that a storage device is affecting many clients, then the metadata server SHOULD NOT include that storage device in any pNFS layouts sent out. If a client asks for a new layout for the file from the metadata server, it MUST be prepared for the metadata server to return that storage device in the layout. The metadata server might not have any choice in using the storage device, i.e., there might only be one possible layout for the system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メタデータサーバはストレージデバイスがクライアントに問題が証明されていることを認識している場合は、メタデータサーバは、そのクライアントに送信されたのpNFSレイアウトでそのストレージデバイスを含めるべきではありません。メタデータサーバはストレージデバイスは、多くのクライアントに影響を及ぼしていることを認識している場合には、メタデータサーバは、送り出された任意のpNFSのレイアウトでそのストレージデバイスを含めるべきではありません。クライアントは、メタデータサーバからのファイルの新しいレイアウトを要求する場合は、レイアウトにそのストレージデバイスを返すために、メタデータ・サーバ用に準備しなければなりません。メタデータサーバはストレージデバイスを使用してのいずれかの選択肢を持っていない可能性があり、すなわち、唯一のシステムのための1つの可能なレイアウトがあるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Also, in the case of existing files, the metadata server might have no choice regarding which storage devices to hand out to clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、既存のファイルの場合には、メタデータサーバは、クライアントに配るためにどのストレージ・デバイスに関する選択肢がないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The metadata server is not required to indefinitely retain per-client storage device error information. The metadata server is also not required to automatically reinstate the use of a previously problematic storage device; administrative intervention may be required instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メタデータサーバは、無期限にクライアントごとのストレージデバイスエラー情報を保持するために必要とされていません。メタデータサーバは、自動的に以前に問題のストレージデバイスの使用を回復するために必要とされません。管理者の介入ではなく、必要な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7. Operation 65: LAYOUTSTATS - Provide statistics for the layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7。操作65：LAYOUTSTATSは - レイアウトの統計を提供します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct layoutupdate4 {
           layouttype4             lou_type;
           opaque                  lou_body&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct io_info4 {
           uint64_t        ii_count;
           uint64_t        ii_bytes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTSTATS4args {
           /* CURRENT_FH: file */
           offset4                 lsa_offset;
           length4                 lsa_length;
           stateid4                lsa_stateid;
           io_info4                lsa_read;
           io_info4                lsa_write;
           deviceid4               lsa_deviceid;
           layoutupdate4           lsa_layoutupdate;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTSTATS4res {
           nfsstat4        lsr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.7.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client can use LAYOUTSTATS to inform the metadata server about its interaction with the layout (see Section 12 of [RFC5661]) represented by the current filehandle, client ID (derived from the session ID in the preceding SEQUENCE operation), byte range (lsa_offset and lsa_length), and lsa_stateid. lsa_read and lsa_write allow non-layout-type-specific statistics to be reported. lsa_deviceid allows the client to specify to which storage device the statistics apply. The remaining information the client is presenting is specific to the layout type and presented in the lsa_layoutupdate field. Each layout type MUST define the contents of lsa_layoutupdate in their respective specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、（前のシーケンス動作のセッションIDに由来する）現在のファイルハンドル、クライアントIDで示される（[RFC5661]のセクション12を参照）のレイアウトとの相互作用に関するメタデータサーバに通知するLAYOUTSTATSを使用バイト範囲（lsa_offsetできそしてlsa_length）、およびlsa_stateid。 lsa_readとlsa_writeは非レイアウト型固有の統計情報を報告することができます。 lsa_deviceidは、クライアントが、統計が適用されるストレージデバイスに指定することができます。クライアントが提示され、残りの情報は、レイアウトタイプに固有とlsa_layoutupdateフィールドに示されています。それぞれのレイアウトタイプは、それぞれの仕様にlsa_layoutupdateの内容を定義しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LAYOUTSTATS can be combined with IO_ADVISE (see Section 15.5) to augment the decision-making process of how the metadata server handles a file. That is, IO_ADVISE lets the server know that a byte range has a certain characteristic, but not necessarily the intensity of that characteristic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LAYOUTSTATSは、メタデータサーバがファイルをどのように扱うかの意思決定プロセスを強化するために（項15.5を参照してください）IO_ADVISEと組み合わせることができます。それはIO_ADVISEは、その特性の強さを、サーバがバイト範囲が特定の特性を持っていることを知ることができますが、必ずしもそうではない、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The statistics are cumulative, i.e., multiple LAYOUTSTATS updates can be in flight at the same time. The metadata server can examine the packet&#39;s timestamp to order the different calls. The first LAYOUTSTATS sent by the client SHOULD be from the opening of the file. The choice of how often to update the metadata server is made by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
統計は、すなわち、複数のLAYOUTSTATSの更新を同時に飛行にすることができ、累積されます。メタデータサーバは、別の呼び出しを注文するパケットのタイムスタンプを調べることができます。クライアントから送信された最初のLAYOUTSTATSは、ファイルのオープンからであるべきです。メタデータサーバーを更新する頻度の選択は、クライアントによって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that while the metadata server may return an error associated with the layout stateid or the open file, it MUST NOT return an error in the processing of the statistics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メタデータサーバは、レイアウトのstateidまたは開いているファイルに関連付けられたエラーを返すかもしれないが、それは統計の処理中にエラーを返してはならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8. Operation 66: OFFLOAD_CANCEL - Stop an offloaded operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8。操作66：OFFLOAD_CANCEL  - オフロード運転を停止します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OFFLOAD_CANCEL4args {
           /* CURRENT_FH: file to cancel */
           stateid4        oca_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OFFLOAD_CANCEL4res {
           nfsstat4        ocr_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.8.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_CANCEL is used by the client to terminate an asynchronous operation, which is identified by both CURRENT_FH and the oca_stateid. That is, there can be multiple OFFLOAD_CANCEL operations acting on the file, and the stateid will identify to the server exactly which one is to be stopped. Currently, there are only two operations that can decide to be asynchronous: COPY and WRITE_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_CANCELはCURRENT_FHとoca_stateid両方によって識別される非同期操作を終了するためにクライアントによって使用されます。これは、ファイルに作用する複数のOFFLOAD_CANCEL操作が可能であり、かつのstateidは1つが停止する正確サーバに識別します。 COPYとWRITE_SAME：現在、非同期に決めることができる唯一の2つの操作があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the context of server-to-server copy, the client can send OFFLOAD_CANCEL to either the source or destination server, albeit with a different stateid. The client uses OFFLOAD_CANCEL to inform the destination to stop the active transfer and uses the stateid it got back from the COPY operation. The client uses OFFLOAD_CANCEL and the stateid it used in the COPY_NOTIFY to inform the source to not allow any more copying from the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー間のコピーのコンテキストでは、クライアントが異なるのstateidはあるものの、いずれかの送信元または送信先サーバにOFFLOAD_CANCELを送ることができます。クライアントは、アクティブな転送を停止するには、宛先を知らせるためにOFFLOAD_CANCELを使用し、それが戻っCOPY操作から得たstateidを使用しています。クライアントはOFFLOAD_CANCEL、それが先から任意のより多くのコピーを許可しないようにソースを知らせるためにCOPY_NOTIFYで使用したstateidを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_CANCEL is also useful in situations in which the source server granted a very long or infinite lease on the destination server&#39;s ability to read the source file and all COPY operations on the source file have been completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_CANCELは、ソースサーバーがソースファイルを読み込むための送信先サーバーの能力に非常に長いまたは無限のリースを付与し、ソースファイルのすべてのコピー操作が完了された状況でも有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
15.9. Operation 67: OFFLOAD_STATUS - Poll for the status of an asynchronous operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
15.9。操作67：OFFLOAD_STATUS  - 非同期操作のステータスをポーリング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.9.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.9.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OFFLOAD_STATUS4args {
           /* CURRENT_FH: destination file */
           stateid4        osa_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.9.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.9.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OFFLOAD_STATUS4resok {
           length4         osr_count;
           nfsstat4        osr_complete&lt;1&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OFFLOAD_STATUS4res switch (nfsstat4 osr_status) {
   case NFS4_OK:
           OFFLOAD_STATUS4resok            osr_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.9.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.9.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_STATUS can be used by the client to query the progress of an asynchronous operation, which is identified by both CURRENT_FH and the osa_stateid. If this operation is successful, the number of bytes processed is returned to the client in the osr_count field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OFFLOAD_STATUSはCURRENT_FHとosa_stateidの両方で識別される非同期操作の進捗状況を照会するために、クライアントで使用することができます。この操作が成功した場合は、処理されたバイト数がosr_countフィールドでクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the optional osr_complete field is present, the asynchronous operation has completed. In this case, the status value indicates the result of the asynchronous operation. In all cases, the server will also deliver the final results of the asynchronous operation in a CB_OFFLOAD operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションのosr_completeフィールドが存在する場合は、非同期操作が完了しました。この場合、ステータス値は、非同期操作の結果を示しています。すべての場合において、サーバはまたCB_OFFLOAD操作で非同期操作の最終結果をお届けします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The failure of this operation does not indicate the result of the asynchronous operation in any way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作の失敗は、どのような方法で、非同期操作の結果を示すものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10. Operation 68: READ_PLUS - READ data or holes from a file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10。操作68：READ_PLUS  - ファイルからのデータや穴をREAD
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ_PLUS4args {
           /* CURRENT_FH: file */
           stateid4        rpa_stateid;
           offset4         rpa_offset;
           count4          rpa_count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum data_content4 { NFS4_CONTENT_DATA = 0, NFS4_CONTENT_HOLE = 1 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙data_content4 {NFS4_CONTENT_DATA = 0、NFS4_CONTENT_HOLE = 1}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct data_info4 {
           offset4         di_offset;
           length4         di_length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct data4 {
           offset4         d_offset;
           opaque          d_data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union read_plus_content switch (data_content4 rpc_content) {
   case NFS4_CONTENT_DATA:
           data4           rpc_data;
   case NFS4_CONTENT_HOLE:
           data_info4      rpc_hole;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Allow a return of an array of contents.
    */
   struct read_plus_res4 {
           bool                    rpr_eof;
           read_plus_content       rpr_contents&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READ_PLUS4res switch (nfsstat4 rp_status) {
   case NFS4_OK:
           read_plus_res4  rp_resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The READ_PLUS operation is based upon the NFSv4.1 READ operation (see Section 18.22 of [RFC5661]) and similarly reads data from the regular file identified by the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ_PLUS動作はNFSv4.1 READ動作に基づいている（[RFC5661]のセクション18.22参照）と同様に、現在のファイルハンドルによって識別される通常のファイルからデータを読み出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client provides an rpa_offset of where the READ_PLUS is to start and an rpa_count of how many bytes are to be read. An rpa_offset of zero means that data will be read starting at the beginning of the file. If rpa_offset is greater than or equal to the size of the file, the status NFS4_OK is returned with di_length (the data length) set to zero and eof set to TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはREAD_PLUSを開始する場所のrpa_offsetと読み取られるバイト数のrpa_countを提供します。ゼロのrpa_offsetは、データをファイルの先頭から読まれることを意味します。 rpa_offsetより大きい又はファイルのサイズに等しい場合、ステータスNFS4_OKはdi_length（データ長）をゼロに設定し、TRUEに設定eofがで返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The READ_PLUS result is comprised of an array of rpr_contents, each of which describes a data_content4 type of data. For NFSv4.2, the allowed values are data and hole. A server MUST support both the data type and the hole if it uses READ_PLUS. If it does not want to support a hole, it MUST use READ. The array contents MUST be contiguous in the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
READ_PLUS結果は、データのdata_content4タイプを記述する各々がrpr_contentsのアレイから構成されています。 NFSv4.2ため、許容値は、データ及び穴です。それはREAD_PLUSを使用している場合、サーバーは、データ型と穴の両方をサポートしなければなりません。それは穴をサポートしたくない場合は、READを使用しなければなりません。配列の内容は、ファイル内の連続していなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Holes SHOULD be returned in their entirety -- clients must be prepared to get more information than they requested. Both the start and the end of the hole may exceed what was requested. If data to be returned is comprised entirely of zeros, then the server SHOULD return that data as a hole instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
穴は、その全体が返されるべきである（SHOULD） - クライアントが要求したよりも多くの情報を得るために準備する必要があります。開始と穴の両端には、要求されたものを超えてもよいです。返されるデータは、完全にゼロで構成されている場合、サーバは、代わりに孔としてそのデータを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server may elect to return adjacent elements of the same type. For example, if the server has a range of data comprised entirely of zeros and then a hole, it might want to return two adjacent holes to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、同じタイプの隣接する要素を返すように選択することができます。サーバーが完全にゼロで構成されるデータ、その後、穴の範囲を持っている場合、それはクライアントに隣接する二つの穴を返すようにしたいかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client specifies an rpa_count value of zero, the READ_PLUS succeeds and returns zero bytes of data. In all situations, the server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがゼロのrpa_count値を指定した場合、READ_PLUSは成功し、0バイトのデータを返します。すべての状況では、サーバーは、クライアントによって指定されたよりも少ないバイト数を返すように選択することができます。クライアントは、この状態を確認し、適切な条件を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client specifies data that is entirely contained within a hole of the file (i.e., both rpa_offset and rpa_offset + rpa_count are within the hole), then the di_offset and di_length returned MAY be for the entire hole. If the owner has a locked byte range covering rpa_offset and rpa_count entirely, the di_offset and di_length MUST NOT be extended outside the locked byte range. This result is considered valid until the file is changed (detected via the change attribute). The server MUST provide the same semantics for the hole as if the client read the region and received zeros; the implied hole&#39;s contents lifetime MUST be exactly the same as any other read data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、完全ファイル（穴内にある、すなわち、rpa_offsetとrpa_offset + rpa_count両方）の穴内に含まれるデータを指定した場合、返さdi_offsetとdi_length全体ホールためのものであってもよいです。所有者が完全rpa_offsetとrpa_countをカバーロックバイト範囲を有する場合、di_offsetとdi_lengthは、ロックされたバイト範囲外に拡張してはいけません。ファイルが変更されるまで、この結果は有効であると考えられる（変化属性を介して検出）。クライアント領域を読み取り、ゼロを受信したかのようにサーバが穴に対して同じセマンティクスを提供しなければなりません。暗黙の穴の内容の寿命は、他の読み出しデータとまったく同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client specifies data by an rpa_offset that begins in a non-hole of the file but extends into a hole (the rpa_offset + rpa_count is in the hole), the server should return an array comprised of both data and a hole. The client MUST be prepared for the server to return a short read describing just the data. The client will then issue another READ_PLUS for the remaining bytes, to which the server will respond with information about the hole in the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、ファイルの非穴に始まるが、穴の中に延びrpa_offsetによってデータを指定した場合（rpa_offset + rpa_countが穴の中にある）、サーバは、データと穴の両方で構成される配列を返す必要があります。クライアントは、データだけを説明する短い読み取りを返すために、サーバーのために準備しなければなりません。その後、クライアントは、サーバがファイルの穴についての情報で応答する先の残りのバイト、のために別のREAD_PLUSを発行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Except when special stateids are used, the stateid value for a READ_PLUS request represents a value returned from a previous byte-range lock or share reservation request or the stateid associated with a delegation. The stateid identifies the associated owners, if any, and is used by the server to verify that the associated locks are still valid (e.g., have not been revoked).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別のstateidsが使用される場合を除き、READ_PLUS要求用のstateid値は、以前のバイト範囲ロックまたは共有の予約要求又は委任に関連付けられたstateidから返された値を表します。 stateidは、もしあれば、関連する所有者を識別し、関連するロックが依然として（例えば、失効していない）が有効であることを確認するためにサーバによって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the read ended at the end of the file (formally, in a correctly formed READ_PLUS operation, if rpa_offset + rpa_count is equal to the size of the file) or the READ_PLUS operation extends beyond the size of the file (if rpa_offset + rpa_count is greater than the size of the file), eof is returned as TRUE; otherwise, it is FALSE. A successful READ_PLUS of an empty file will always return eof as TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
rpa_offset + rpa_countがある場合やREAD_PLUS操作（rpa_offset + rpa_countは、ファイルのサイズと等しい場合、正しく形成されREAD_PLUS操作で、正式に）ファイルの最後に終了し、読み取りは、（ファイルのサイズを超えて拡張する場合）ファイルのサイズよりも大きい、EOFはTRUEとして返されます。それ以外の場合はFALSEです。空のファイルの成功READ_PLUSは常にEOFとしてTRUEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のファイルハンドルが通常のファイルでない場合、エラーがクライアントに返されます。現在のファイルハンドルが型NF4DIRのオブジェクトを表す場合には、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定した場合、NFS4ERR_SYMLINKが返されます。他のすべてのケースでは、NFS4ERR_WRONG_TYPEが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a READ_PLUS with a stateid value of all bits equal to zero, the server MAY allow the READ_PLUS to be serviced subject to mandatory byte-range locks or the current share deny modes for the file. For a READ_PLUS with a stateid value of all bits equal to one, the server MAY allow READ_PLUS operations to bypass locking checks at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゼロに等しいすべてのビットのstateid値でREAD_PLUSため、サーバはREAD_PLUSは必須バイト範囲ロックまたは現在の共有ファイルのためのモードを拒否する対象サービスを受けることを可能にすることができます。 1に等しいすべてのビットのstateid値でREAD_PLUSため、サーバはREAD_PLUS操作がサーバでロックチェックをバイパスすることを可能にし得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.3.1. Note on Client Support of Arms of the Union
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.3.1。連合の腕のクライアントサポートに注意してください
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It was decided not to add a means for the client to inform the server as to which arms of READ_PLUS it would support. In a later minor version, it may become necessary for the introduction of a new operation that would allow the client to inform the server as to whether it supported the new arms of the union of data types available in READ_PLUS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、クライアントがサポートするREAD_PLUSのどの武器に、サーバに通知する手段を追加しないことに決めました。以降のマイナーバージョンでは、クライアントはそれがREAD_PLUSで使用可能なデータ型の労働組合の新しい武器をサポートするかどうかがサーバーに通知することを可能にする新しい操作を導入するために必要になることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.4. IMPLEMENTATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.4。実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, the IMPLEMENTATION notes for READ in Section 18.22.4 of [RFC5661] also apply to READ_PLUS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的には、[RFC5661]のセクション18.22.4でREADの実装ノートもREAD_PLUSに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.4.1. Additional pNFS Implementation Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.4.1。追加pNFSの実施情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With pNFS, the semantics of using READ_PLUS remains the same. Any data server MAY return a hole result for a READ_PLUS request that it receives. When a data server chooses to return such a result, it has the option of returning information for the data stored on that data server (as defined by the data layout), but it MUST NOT return results for a byte range that includes data managed by another data server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSのでは、READ_PLUSを使用しての意味は同じまま。任意のデータ・サーバは、受信しREAD_PLUS要求のための穴の結果を返すことがあります。データ・サーバは、そのような結果を返すことを選択する場合は、（データレイアウトによって定義されるように）そのデータサーバーに格納されたデータのための情報を返すオプションがあり、それが管理するデータを含むバイト範囲の結果を返してはいけません別のデータ・サーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If mandatory locking is enforced, then the data server must also ensure that only information that is within the owner&#39;s locked byte range is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
強制ロックが適用されている場合、データ・サーバはまた、所有者のロックされたバイトの範囲内にある情報のみが返されることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.10.5. READ_PLUS with Sparse Files: Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.10.5。スパースファイルとREAD_PLUS：例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following table describes a sparse file. For each byte range, the file contains either non-zero data or a hole. In addition, the server in this example will only create a hole if it is greater than 32K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の表は、スパースファイルについて説明します。各バイト範囲のため、ファイルが非ゼロデータまたは正孔のいずれかを含みます。それは32Kよりも大きい場合はさらに、この例では、サーバが唯一の穴を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        +-------------+----------+
                        | Byte Range  | Contents |
                        +-------------+----------+
                        | 0-15999     | Hole     |
                        | 16K-31999   | Non-Zero |
                        | 32K-255999  | Hole     |
                        | 256K-287999 | Non-Zero |
                        | 288K-353999 | Hole     |
                        | 354K-417999 | Non-Zero |
                        +-------------+----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table 7: Sparse File
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表7：スパースファイル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Under the given circumstances, if a client was to read from the file with a maximum read size of 64K, the following will be the results for the given READ_PLUS calls. This assumes that the client has already opened the file, acquired a valid stateid (&#34;s&#34; in the example), and just needs to issue READ_PLUS requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、64Kの最大読み取りサイズを持つファイルからの読み込みをした場合には与えられた状況下では、次のように与えられたREAD_PLUSコールの結果になります。これは、クライアントが既にファイルを開いていることを前提として有効なstateid（例では「S」）を取得し、ちょうどREAD_PLUS要求を発行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. READ_PLUS(s, 0, 64K) --&gt; NFS_OK, eof = FALSE, &lt;data[0,32K], hole[32K,224K]&gt;. Since the first hole is less than the server&#39;s minimum hole size, the first 32K of the file is returned as data and the remaining 32K is returned as a hole that actually extends to 256K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. READ_PLUS（S、0、64K） - &gt; NFS_OK、EOF = FALSE、&lt;データ[0,32K]、ホール[32K、224K]&gt;。最初の穴は、サーバーの最小の孔サイズよりも小さいので、ファイルの最初の32Kは、データとして戻され、残りの32Kは、実際には256Kまで延びる穴として返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. READ_PLUS(s, 32K, 64K) --&gt; NFS_OK, eof = FALSE, &lt;hole[32K,224K]&gt;. The requested range was all zeros, and the current hole begins at offset 32K and is 224K in length. Note that the client should not have followed up the previous READ_PLUS request with this one, as the hole information from the previous call extended past what the client was requesting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. READ_PLUS（S、32K、64K） - &gt; NFS_OK、EOF = FALSE、&lt;正孔[32K、224K]&gt;。要求された範囲は、全てゼロであり、現在の穴がオフセット32Kで始まり、長さが224Kです。前の呼び出しからのホールの情報は、クライアントが要求したものを超えて延長としてクライアントは、このいずれかで、前のREAD_PLUS要求をフォローしているべきではないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. READ_PLUS(s, 256K, 64K) --&gt; NFS_OK, eof = FALSE, &lt;data[256K, 288K], hole[288K, 354K]&gt;. Returns an array of the 32K data and the hole, which extends to 354K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. READ_PLUS（S、256K、64K） - &gt; NFS_OK、EOF = FALSE、&lt;データ[256K、288K]、穴〔288K、354K]&gt;。 32Kデータ及び354Kまで延びる穴の配列を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. READ_PLUS(s, 354K, 64K) --&gt; NFS_OK, eof = TRUE, &lt;data[354K, 418K]&gt;. Returns the final 64K of data and informs the client that there is no more data in the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. READ_PLUS（S、354K、64K） - &gt; NFS_OK、EOF = TRUE、&lt;データ[354K、418K]&gt;。データの最終64Kを返し、ファイル内のデータがないことをクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11. Operation 69: SEEK - Find the next data or hole
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11。操作69：SEEK  - 次のデータや穴を探します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum data_content4 { NFS4_CONTENT_DATA = 0, NFS4_CONTENT_HOLE = 1 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙data_content4 {NFS4_CONTENT_DATA = 0、NFS4_CONTENT_HOLE = 1}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SEEK4args {
           /* CURRENT_FH: file */
           stateid4        sa_stateid;
           offset4         sa_offset;
           data_content4   sa_what;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct seek_res4 {
           bool            sr_eof;
           offset4         sr_offset;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SEEK4res switch (nfsstat4 sa_status) {
   case NFS4_OK:
           seek_res4       resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.11.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEEK is an operation that allows a client to determine the location of the next data_content4 in a file. It allows an implementation of the emerging extension to the lseek(2) function to allow clients to determine the next hole whilst in data or the next data whilst in a hole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEEKクライアントは、ファイル内の次data_content4の位置を決定することを可能にする操作です。それのlseek（2）関数の出現拡張の実装では、クライアントがデータまたは孔内ながら次のデータにしながら次の穴を決定することを可能にすることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
From the given sa_offset, find the next data_content4 of type sa_what in the file. If the server cannot find a corresponding sa_what, then the status will still be NFS4_OK, but sr_eof would be TRUE. If the server can find the sa_what, then the sr_offset is the start of that content. If the sa_offset is beyond the end of the file, then SEEK MUST return NFS4ERR_NXIO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
与えられたsa_offsetからは、ファイル内のタイプsa_whatの次data_content4を見つけます。サーバが対応するsa_whatを見つけることができない場合は、ステータスがまだNFS4_OKになりますが、sr_eofはTRUEになります。サーバがsa_whatを見つけることができれば、その後sr_offsetは、そのコンテンツの始まりです。 sa_offsetは、ファイルの終わりを超えている場合は、SEEKはNFS4ERR_NXIOを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All files MUST have a virtual hole at the end of the file. That is, if a file system does not support sparse files, then a COMPOUND with {SEEK 0 NFS4_CONTENT_HOLE;} would return a result of {SEEK 1 X;}, where &#34;X&#34; was the size of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのファイルは、ファイルの末尾に仮想の穴を持たなければなりません。 「X」は、ファイルのサイズであった場合、{1 Xシーク}の結果を返す、ファイルシステムは、スパース・ファイルをサポートしていない場合には、{0 NFS4_CONTENT_HOLEをSEEK}とその後の化合物です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEEK must follow the same rules for stateids as READ_PLUS (Section 15.10.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEEK READ_PLUS（セクション15.10.3）などのstateidsための同じ規則に従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12. Operation 70: WRITE_SAME - WRITE an ADB multiple times to a file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12。操作70：WRITE_SAME  - ファイルにADB複数回WRITE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum stable_how4 { UNSTABLE4 = 0, DATA_SYNC4 = 1, FILE_SYNC4 = 2 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙stable_how4 {UNSTABLE4 = 0、DATA_SYNC4 = 1、FILE_SYNC4 = 2}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct app_data_block4 {
           offset4         adb_offset;
           length4         adb_block_size;
           length4         adb_block_count;
           length4         adb_reloff_blocknum;
           count4          adb_block_num;
           length4         adb_reloff_pattern;
           opaque          adb_pattern&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE_SAME4args {
           /* CURRENT_FH: file */
           stateid4        wsa_stateid;
           stable_how4     wsa_stable;
           app_data_block4 wsa_adb;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct write_response4 {
           stateid4        wr_callback_id&lt;1&gt;;
           length4         wr_count;
           stable_how4     wr_committed;
           verifier4       wr_writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union WRITE_SAME4res switch (nfsstat4 wsr_status) {
   case NFS4_OK:
           write_response4         resok4;
   default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The WRITE_SAME operation writes an application data block to the regular file identified by the current filehandle (see WRITE SAME (10) in [T10-SBC2]). The target file is specified by the current filehandle. The data to be written is specified by an app_data_block4 structure (Section 8.1.1). The client specifies with the wsa_stable parameter the method of how the data is to be processed by the server. It is treated like the stable parameter in the NFSv4.1 WRITE operation (see Section 18.32.3 of [RFC5661]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME操作は現在のファイルハンドルによって識別される通常のファイルへのアプリケーションデータブロックを書き込む（WRITE参照SAME（10）における[T10-SBC2]）。対象のファイルは、現在のファイルハンドルで指定されています。書き込まれるデータはapp_data_block4構造（セクション8.1.1）によって指定されます。クライアントはwsa_stableパラメータを使用してデータがサーバによって処理されるかの方法を指定します。これは、（[RFC5661]のセクション18.32.3を参照）NFSv4.1書き込み操作で安定したパラメータと同様に扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A successful WRITE_SAME will construct a reply for wr_count, wr_committed, and wr_writeverf as per the NFSv4.1 WRITE operation results. If wr_callback_id is set, it indicates an asynchronous reply (see Section 15.12.3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功WRITE_SAMEはNFSv4.1 WRITE操作結果に従ってwr_committed wr_countに対する応答、およびwr_writeverfを構築します。 wr_callback_idが設定されている場合、それは非同期応答（セクション15.12.3.1を参照）を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As it is an OPTIONAL operation, WRITE_SAME has to support NFS4ERR_NOTSUPP. As it is an extension of WRITE, it has to support all of the errors returned by WRITE. If the client supports WRITE_SAME, it MUST support CB_OFFLOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが任意のオペレーションであるため、WRITE_SAMEはNFS4ERR_NOTSUPPをサポートする必要があります。それはWRITEの拡張であるとして、それはWRITEによって返されたエラーのすべてをサポートする必要があります。クライアントがWRITE_SAMEをサポートしている場合、それはCB_OFFLOADをサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server supports ADBs, then it MUST support the WRITE_SAME operation. The server has no concept of the structure imposed by the application. It is only when the application writes to a section of the file does order get imposed. In order to detect corruption even before the application utilizes the file, the application will want to initialize a range of ADBs using WRITE_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがのADBをサポートしている場合、それはWRITE_SAME操作をサポートしなければなりません。サーバは、アプリケーションによって課さ構造の概念がありません。アプリケーションは順序が課せられますないファイルのセクションに書き込み場合のみです。アプリケーションがファイルを利用する前であっても破損を検出するためには、アプリケーションがWRITE_SAMEを使用してのADBの範囲を初期化することになるでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client invokes the WRITE_SAME operation, it wants to record the block structure described by the app_data_block4 into the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがWRITE_SAME操作を呼び出すと、それがファイルにapp_data_block4で記述ブロック構造を記録したいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server receives the WRITE_SAME operation, it MUST populate adb_block_count ADBs in the file, starting at adb_offset. The block size will be given by adb_block_size. The ADBN (if provided) will start at adb_reloff_blocknum, and each block will be monotonically numbered, starting from adb_block_num in the first block. The pattern (if provided) will be at adb_reloff_pattern of each block and will be provided in adb_pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがWRITE_SAME操作を受信すると、それはadb_offsetから始まる、ファイルにadb_block_countののADBを移入する必要があります。ブロックサイズはadb_block_sizeによって与えられます。 ADBN（提供される場合）はadb_reloff_blocknumで開始され、各ブロックは単調最初のブロックでadb_block_numから出発して、番号付けされます。パターン（提供される場合）は、各ブロックのadb_reloff_patternであろうとadb_patternで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server SHOULD return an asynchronous result if it can determine that the operation will be long-running (see Section 15.12.3.1). Once either the WRITE_SAME finishes synchronously or the server uses CB_OFFLOAD to inform the client of the asynchronous completion of the WRITE_SAME, the server MUST return the ADBs to clients as data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは（セクション15.12.3.1を参照）の操作が長時間実行されることを判断できる場合、サーバは、非同期の結果を返すべきです。一度WRITE_SAMEが同期終了またはサーバーがWRITE_SAMEの非同期完了をクライアントに通知するCB_OFFLOADを使用してのいずれか、サーバがデータとしてクライアントにのADBを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.3.1. Asynchronous Transactions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.3.1。非同期取引
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ADB initialization may cause a server to decide to service the operation asynchronously. If it decides to do so, it sets the stateid in wr_callback_id to be that of the wsa_stateid. If it does not set the wr_callback_id, then the result is synchronous.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ADBの初期化は、サーバーが非同期操作にサービスを提供することを決定する可能性があります。それがそうすることを決定した場合、それはwsa_stateidのものであることをwr_callback_idでのstateidを設定します。それはwr_callback_idを設定しない場合、結果は同期です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client determines that the reply will be given asynchronously, it should not assume anything about the contents of what it wrote until it is informed by the server that the operation is complete. It can use OFFLOAD_STATUS (Section 15.9) to monitor the operation and OFFLOAD_CANCEL (Section 15.8) to cancel the operation. An example of an asynchronous WRITE_SAME is shown in Figure 6. Note that, as with the COPY operation, WRITE_SAME must provide a stateid for tracking the asynchronous operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは応答が非同期的に与えられることになると判断した場合は、操作が完了したことを、サーバーによって通知されるまで、それが書いたものの内容について何も仮定するべきではありません。これは、操作をキャンセルする操作とOFFLOAD_CANCEL（セクション15.8）を監視するためにOFFLOAD_STATUS（セクション15.9）を使用することができます。非同期WRITE_SAMEの例がCOPY動作と同様に、WRITE_SAMEが非同期動作を追跡するためのstateidを提供しなければならない、ことを図6注記に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     Client                                  Server
        +                                      +
        |                                      |
        |--- OPEN ----------------------------&gt;| Client opens
        |&lt;------------------------------------/| the file
        |                                      |
        |--- WRITE_SAME ----------------------&gt;| Client initializes
        |&lt;------------------------------------/| an ADB
        |                                      |
        |                                      |
        |--- OFFLOAD_STATUS ------------------&gt;| Client may poll
        |&lt;------------------------------------/| for status
        |                                      |
        |                  .                   | Multiple OFFLOAD_STATUS
        |                  .                   | operations may be sent.
        |                  .                   |
        |                                      |
        |&lt;-- CB_OFFLOAD -----------------------| Server reports results
        |\------------------------------------&gt;|
        |                                      |
        |--- CLOSE ---------------------------&gt;| Client closes
        |&lt;------------------------------------/| the file
        |                                      |
        |                                      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 6: An Asynchronous WRITE_SAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図6：非同期WRITE_SAME
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When CB_OFFLOAD informs the client of the successful WRITE_SAME, the write_response4 embedded in the operation will provide the necessary information that a synchronous WRITE_SAME would have provided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_OFFLOADが成功WRITE_SAMEのクライアントに通知した場合、運転中に埋め込まれたwrite_response4同期WRITE_SAMEが提供しているだろう、必要な情報を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Regardless of whether the operation is asynchronous or synchronous, it MUST still support the COMMIT operation semantics as outlined in Section 18.3 of [RFC5661]. That is, COMMIT works on one or more WRITE operations, and the WRITE_SAME operation can appear as several WRITE operations to the server. The client can use locking operations to control the behavior on the server with respect to long-running asynchronous WRITE_SAME operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5661]のセクション18.3に概説されているようにかかわらず、動作は非同期または同期であるかどうか、それはまだコミット操作セマンティクスをサポートしなければなりません。それは、一つ以上のWRITE操作に作品をCOMMITされ、かつWRITE_SAME操作がサーバーになど、いくつかの書き込み操作を表示することができます。クライアントは、実行時間の長い非同期WRITE_SAME操作に関してサーバー上の動作を制御するためのロック操作を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.3.2. Error Handling of a Partially Complete WRITE_SAME
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.12.3.2。部分的に完成しWRITE_SAMEのエラー処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME will clone adb_block_count copies of the given ADB in consecutive order in the file, starting at adb_offset. An error can occur after writing the Nth ADB to the file. WRITE_SAME MUST appear to populate the range of the file as if the client used WRITE to transfer the instantiated ADBs. That is, the contents of the range will be easy for the client to determine in the case of a partially complete WRITE_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAMEはadb_offsetから始まる、ファイルに連続した順序で与えられたADBのadb_block_countコピーのクローンを作成します。エラーは、ファイルにN番目のADBを書き込んだ後に発生する可能性があります。クライアントは、インスタンス化のADBを転送するためにWRITEを使用しているかのようWRITE_SAMEは、ファイルの範囲を取り込むために現れなければなりません。クライアントは、部分的に完全なWRITE_SAMEの場合に決定するということです、範囲の内容が簡単になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13. Operation 71: CLONE - Clone a range of a file into another file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13。操作71：CLONE  - 別のファイルにファイルの範囲を複製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CLONE4args {
           /* SAVED_FH: source file */
           /* CURRENT_FH: destination file */
           stateid4        cl_src_stateid;
           stateid4        cl_dst_stateid;
           offset4         cl_src_offset;
           offset4         cl_dst_offset;
           length4         cl_count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CLONE4res {
           nfsstat4        cl_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.13.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CLONE operation is used to clone file content from a source file specified by the SAVED_FH value into a destination file specified by CURRENT_FH without actually copying the data, e.g., by using a copy-on-write mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クローン操作は、コピーオンライト機構を使用することにより、例えば、実際にデータをコピーせずCURRENT_FHによって指定された宛先ファイルにSAVED_FH値によって指定されたソースファイルからファイルコンテンツをクローニングするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Both SAVED_FH and CURRENT_FH must be regular files. If either SAVED_FH or CURRENT_FH is not a regular file, the operation MUST fail and return NFS4ERR_WRONG_TYPE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SAVED_FHとCURRENT_FHの両方が通常のファイルでなければなりません。 SAVED_FHまたはCURRENT_FHのいずれかが通常のファイルでない場合、操作は失敗し、NFS4ERR_WRONG_TYPEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ca_dst_stateid MUST refer to a stateid that is valid for a WRITE operation and follows the rules for stateids in Sections 8.2.5 and 18.32.3 of [RFC5661]. The ca_src_stateid MUST refer to a stateid that is valid for a READ operation and follows the rules for stateids in Sections 8.2.5 and 18.22.3 of [RFC5661]. If either stateid is invalid, then the operation MUST fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ca_dst_stateidは、書き込み動作のために有効であり、セクション8.2.5でのstateidsの規則に従い、[RFC5661]の18.32.3のstateidを参照しなければなりません。 ca_src_stateidは、読み出し動作のために有効であり、セクション8.2.5でのstateidsの規則に従い、[RFC5661]の18.22.3のstateidを参照しなければなりません。いずれかのstateidが無効である場合、操作は失敗しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cl_src_offset is the starting offset within the source file from which the data to be cloned will be obtained, and the cl_dst_offset is the starting offset of the target region into which the cloned data will be placed. An offset of 0 (zero) indicates the start of the respective file. The number of bytes to be cloned is obtained from cl_count, except that a cl_count of 0 (zero) indicates that the number of bytes to be cloned is the count of bytes between cl_src_offset and the EOF of the source file. Both cl_src_offset and cl_dst_offset must be aligned to the clone block size (Section 12.2.1). The number of bytes to be cloned must be a multiple of the clone block size, except in the case in which cl_src_offset plus the number of bytes to be cloned is equal to the source file size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cl_src_offsetをクローニングするためのデータを取得する元のソースファイル内のオフセット、及びcl_dst_offsetは、クローニングされたデータが配置されるに対象領域の開始オフセットで開始しています。 0（ゼロ）のオフセットを各ファイルの開始を示します。クローン化されるべきバイトの数が0（ゼロ）のcl_countがクローニングされるべきバイトの数がcl_src_offset、ソースファイルのEOFの間のバイトのカウントであることを示していることを除いて、cl_countから得られます。 cl_src_offsetとcl_dst_offset両方は、クローン・ブロック・サイズ（セクション12.2.1）に位置合わせされなければなりません。クローン化されるべきバイトの数はcl_src_offsetにおける場合を除いて、クローン・ブロック・サイズの倍数でなければならないプラスクローン化されるべきバイトの数は、ソース・ファイル・サイズに等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the source offset or the source offset plus count is greater than the size of the source file, the operation MUST fail with NFS4ERR_INVAL. The destination offset or destination offset plus count may be greater than the size of the destination file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースはオフセットやソースがプラスオフセットカウントは、ソースファイルのサイズよりも大きい場合、操作はNFS4ERR_INVALで失敗しなければなりません。オフセットまたは宛先オフセットプラスカウント先は先のファイルのサイズよりも大きくすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If SAVED_FH and CURRENT_FH refer to the same file and the source and target ranges overlap, the operation MUST fail with NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SAVED_FHとCURRENT_FHが同じファイルを参照し、ソースとターゲット範囲が重複する場合、操作はNFS4ERR_INVALで失敗しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the target area of the CLONE operation ends beyond the end of the destination file, the offset at the end of the target area will determine the new size of the destination file. The contents of any block not part of the target area will be the same as if the file size were extended by a WRITE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クローン操作の対象領域が先ファイルの終わりを超えて終了した場合は、対象領域の終わりにオフセット先のファイルの新しいサイズを決定します。ファイルサイズがWRITEによって拡張されたかのような任意のブロック対象領域のない部分の内容が同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the area to be cloned is not a multiple of the clone block size and the size of the destination file is past the end of the target area, the area between the end of the target area and the next multiple of the clone block size will be zeroed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クローン化されるべき領域は、クローン・ブロック・サイズの倍数と宛先ファイルのサイズではない場合、ターゲット領域の端を過ぎて、ターゲット領域の端部とクローンブロック・サイズの倍数の間の領域は、意志ゼロにすること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CLONE operation is atomic in that other operations may not see any intermediate states between the state of the two files before the operation and after the operation. READs of the destination file will never see some blocks of the target area cloned without all of them being cloned. WRITEs of the source area will either have no effect on the data of the target file or be fully reflected in the target area of the destination file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クローン操作は、操作前と操作後の二つのファイルの状態の間の任意の中間状態が表示されないかもしれない他の動作中の原子です。それらのすべてがクローン化されずにクローン化された対象領域のいくつかのブロックを参照することはありません先のファイルを読み込みます。ターゲット・ファイルのデータに影響を与えないであろういずれかまたは完全に宛先ファイルのターゲット領域に反映されたソース領域の書き込みを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The completion status of the operation is indicated by cr_status.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
操作の完了ステータスはcr_statusで示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. NFSv4.2 Callback Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. NFSv4.2コールバックオペレーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
16.1. Operation 15: CB_OFFLOAD - Report the results of an asynchronous operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
16.1。操作15：CB_OFFLOADは - 非同期操作の結果を報告します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.1. ARGUMENT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.1。引数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct write_response4 {
           stateid4        wr_callback_id&lt;1&gt;;
           length4         wr_count;
           stable_how4     wr_committed;
           verifier4       wr_writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union offload_info4 switch (nfsstat4 coa_status) {
   case NFS4_OK:
           write_response4 coa_resok4;
   default:
           length4         coa_bytes_copied;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_OFFLOAD4args {
           nfs_fh4         coa_fh;
           stateid4        coa_stateid;
           offload_info4   coa_offload_info;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.2. RESULT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.2。結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_OFFLOAD4res {
           nfsstat4        cor_status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.3. DESCRIPTION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1.3。 DESCRIPTION
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_OFFLOAD is used to report to the client the results of an asynchronous operation, e.g., server-side COPY or WRITE_SAME. The coa_fh and coa_stateid identify the transaction, and the coa_status indicates success or failure. The coa_resok4.wr_callback_id MUST NOT be set. If the transaction failed, then the coa_bytes_copied contains the number of bytes copied before the failure occurred. The coa_bytes_copied value indicates the number of bytes copied but not which specific bytes have been copied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CB_OFFLOADクライアントに非同期動作、例えば、サーバ側のコピーまたはWRITE_SAMEの結果を報告するために使用されます。 coa_fhとcoa_stateidトランザクションを識別し、そしてcoa_statusは、成功または失敗を示します。 coa_resok4.wr_callback_idを設定してはいけません。トランザクションが失敗した場合は、coa_bytes_copiedは、障害が発生する前にコピーされたバイト数が含まれています。 coa_bytes_copied値は、特定バイトがコピーされたコピーされたバイトではなく数を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client supports any of the following operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、以下のいずれかの操作をサポートしている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPY: for both intra-server and inter-server asynchronous copies
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPY：サーバ内とサーバ間の非同期コピーの両方のために
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME: for ADB initialization
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME：ADB初期化
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
then the client is REQUIRED to support the CB_OFFLOAD operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その後、クライアントはCB_OFFLOAD操作をサポートするために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is a potential race between the reply to the original transaction on the forechannel and the CB_OFFLOAD callback on the backchannel. Section 2.10.6.3 of [RFC5661] describes how to handle this type of issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
forechannel上の元のトランザクションへの返信やバックチャネル上CB_OFFLOADコールバックの間の潜在的なレースがあります。 [RFC5661]のセクション2.10.6.3は、この種の問題を処理する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon success, the coa_resok4.wr_count presents for each operation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功した場合、coa_resok4.wr_countは、各操作のために提示します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPY: the total number of bytes copied
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COPY：コピーされたバイトの総数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME: the same information that a synchronous WRITE_SAME would provide
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WRITE_SAME：同期WRITE_SAMEが提供するのと同じ情報
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2 has all of the security concerns present in NFSv4.1 (see Section 21 of [RFC5661]), as well as those present in the server-side copy (see Section 4.9) and in Labeled NFS (see Section 9.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.2セキュリティNFSv4.1に存在する問題（[RFC5661]のセクション21を参照）、ならびにサーバ側のコピーに存在するものの全てを有している（セクション4.9を参照）及び標識NFS（セクション9.6を参照）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IANA considerations for Labeled NFS are addressed in [RFC7569].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
標識NFSのためのIANA問題は[RFC7569]で扱われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[posix_fadvise] The Open Group, &#34;Section &#39;posix_fadvise()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2016 Edition (HTML Version), ISBN 1937218812, September 2016, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[posix_fadvise] &#34;Open Groupの基本仕様問題7のシステムインターフェースのセクション &#39;posix_fadvise（）&#39;&#34; Open Groupの、IEEE STD 1003.1、2016年版（HTML版）、ISBN 1937218812、2016年9月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[posix_fallocate] The Open Group, &#34;Section &#39;posix_fallocate()&#39; of System Interfaces of The Open Group Base Specifications Issue 7&#34;, IEEE Std 1003.1, 2016 Edition (HTML Version), ISBN 1937218812, September 2016, &lt;http://www.opengroup.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[posix_fallocate] &#34;Open Groupの基本仕様問題7のシステムインターフェースのセクション &#39;posix_fallocate（）&#39;&#34; Open Groupの、IEEE STD 1003.1、2016年版（HTML版）、ISBN 1937218812、2016年9月、&lt;のhttp：// WWW .opengroup.org /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, &lt;http://www.rfc-editor.org/info/rfc3986&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 &#34;ユニフォームリソース識別子（URI）：汎用構文&#34;、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月&lt;HTTP：/ /www.rfc-editor.org/info/rfc3986&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 Protocol&#34;, RFC 5661, DOI 10.17487/RFC5661, January 2010, &lt;http://www.rfc-editor.org/info/rfc5661&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5661] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル&#34;、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、&lt;http://www.rfc-editor.org/info/rfc5661&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5662] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description&#34;, RFC 5662, DOI 10.17487/RFC5662, January 2010, &lt;http://www.rfc-editor.org/info/rfc5662&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5662] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1外部データ表現標準（XDR）の説明&#34;、RFC 5662、DOI 10.17487 / RFC5662、2010年1月、&lt;http://www.rfc-editor.org/info/rfc5662&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7569] Quigley, D., Lu, J., and T. Haynes, &#34;Registry Specification for Mandatory Access Control (MAC) Security Label Formats&#34;, RFC 7569, DOI 10.17487/RFC7569, July 2015, &lt;http://www.rfc-editor.org/info/rfc7569&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7569]クイグリー、D.、呂、J.、およびT.ヘインズ、 &#34;強制アクセス制御（MAC）セキュリティラベルフォーマットのレジストリ仕様&#34;、RFC 7569、DOI 10.17487は/ RFC7569、2015年7月、&lt;のhttp：// WWW .rfc-editor.org /情報/ rfc7569&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7861] Adamson, A. and N. Williams, &#34;Remote Procedure Call (RPC) Security Version 3&#34;, RFC 7861, DOI 10.17487/RFC7861, November 2016, &lt;http://www.rfc-editor.org/info/rfc7861&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7861]アダムソン、A.およびN.ウィリアムズ、 &#34;リモートプロシージャコール（RPC）Securityバージョン3&#34;、RFC 7861、DOI 10.17487 / RFC7861、2016年11月、&lt;http://www.rfc-editor.org/info/ rfc7861&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7863] Haynes, T., &#34;Network File System (NFS) Version 4 Minor Version 2 External Data Representation Standard (XDR) Description&#34;, RFC 7863, DOI 10.17487/RFC7863, November 2016, &lt;http://www.rfc-editor.org/info/rfc7863&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7863]ヘインズ、T.、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン2外部データ表現標準（XDR）の説明&#34;、RFC 7863、DOI 10.17487 / RFC7863、2016年11月、&lt;のhttp：//www.rfc- editor.org/info/rfc7863&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ashdown08] Ashdown, L., &#34;Chapter 15: Validating Database Files and Backups&#34;, Oracle Database Backup and Recovery User&#39;s Guide 11g Release 1 (11.1), August 2008, &lt;http://download.oracle.com/docs/cd/B28359_01/backup.111/ b28270/rcmvalid.htm&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ashdown08]アッシュダウン、L.、 &#34;第15章：データベース・ファイルおよびバックアップの検証&#34;、Oracle Databaseバックアップおよびリカバリ・ユーザーズ・ガイド11gリリース1（11.1）、2008年8月に、&lt;http://download.oracle.com/docs/cd /B28359_01/backup.111/ b28270 / rcmvalid.htm&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Baira08] Bairavasundaram, L., Goodson, G., Schroeder, B., Arpaci-Dusseau, A., and R. Arpaci-Dusseau, &#34;An Analysis of Data Corruption in the Storage Stack&#34;, Proceedings of the 6th USENIX Symposium on File and Storage Technologies (FAST &#39;08), 2008, &lt;http://www.usenix.org/events/fast08/tech/full_papers/ bairavasundaram/bairavasundaram.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【Baira08] Bairavasundaram、L.、グッドソン、G.、シュローダー、B.、Arpaci-Dusseau、A.、およびR. Arpaci-Dusseau、 &#34;ストレージスタック内のデータ破損のアン分析&#34;、第6回USENIXシンポジウムファイルとストレージテクノロジーズ（FAST &#39;08）、2008年、&lt;http://www.usenix.org/events/fast08/tech/full_papers/ bairavasundaram / bairavasundaram.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IESG08] IESG, &#34;IESG Processing of RFC Errata for the IETF Stream&#34;, July 2008, &lt;https://www.ietf.org/iesg/statement/ errata-processing.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IESG08] IESG、 &#34;IETF RFCストリームのための正誤表のIESG処理&#34;、2008年7月、&lt;https://www.ietf.org/iesg/statement/エラッタ-processing.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[LB96] LaPadula, L. and D. Bell, &#34;MITRE Technical Report 2547, Volume II&#34;, Journal of Computer Security, Volume 4, Issue 2-3, 239-263, IOS Press, Amsterdam, The Netherlands, January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[LB96] LaPadula、L.とD.ベル、 &#34;MITERテクニカルレポート2547（第2巻）&#34;、コンピュータセキュリティ、4巻、号2-3、239から263、IOSを押し、アムステルダム、オランダ、1996年1月のジャーナル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[McDougall07] McDougall, R. and J. Mauro, &#34;Section 11.4.3: Detecting Memory Corruption&#34;, Solaris Internals: Solaris 10 and OpenSolaris Kernel Architecture, 2nd Edition, 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[McDougall07]マクドゥーガル、R.とJ.マウロ、 &#34;11.4.3項：メモリー破壊の検出&#34;、Solarisの内部構造：Solaris 10およびOpenSolarisのカーネルアーキテクチャ、第2版、2007。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[NFSv4-Versioning] Noveck, D., &#34;Rules for NFSv4 Extensions and Minor Versions&#34;, Work in Progress, draft-ietf-nfsv4-versioning-07, October 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[NFSv4の-バージョニング] Noveck、D.、進行中で働いて、ドラフト-IETF-NFSv4のバージョン管理-07、2016年10月 &#34;NFSv4の拡張とマイナーバージョンの規則&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC959] Postel, J. and J. Reynolds, &#34;File Transfer Protocol&#34;, STD 9, RFC 959, DOI 10.17487/RFC0959, October 1985, &lt;http://www.rfc-editor.org/info/rfc959&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC959]ポステル、J.、およびJ.レイノルズ、 &#34;ファイル転送プロトコル&#34;、STD 9、RFC 959、DOI 10.17487 / RFC0959、1985年10月、&lt;http://www.rfc-editor.org/info/rfc959&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1108] Kent, S., &#34;U.S. Department of Defense Security Options for the Internet Protocol&#34;, RFC 1108, DOI 10.17487/RFC1108, November 1991, &lt;http://www.rfc-editor.org/info/rfc1108&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1108] DOI 10.17487 / RFC1108、1991年11月、&lt;http://www.rfc-editor.org/info/rfc1108&gt;ケント、S.、 &#34;インターネットプロトコルのための米国国防総省のセキュリティオプション&#34;、RFC 1108、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2401] Kent, S. and R. Atkinson, &#34;Security Architecture for the Internet Protocol&#34;, RFC 2401, DOI 10.17487/RFC2401, November 1998, &lt;http://www.rfc-editor.org/info/rfc2401&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2401]ケント、S.とR.アトキンソン、 &#34;インターネットプロトコルのためのセキュリティー体系&#34;、RFC 2401、DOI 10.17487 / RFC2401、1998年11月、&lt;http://www.rfc-editor.org/info/rfc2401&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4506] Eisler, M., Ed., &#34;XDR: External Data Representation Standard&#34;, STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, &lt;http://www.rfc-editor.org/info/rfc4506&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4506]アイスラー、M.、エド、 &#34;XDR：外部データ表現標準&#34;。、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、&lt;http://www.rfc-editor.org/info/rfc4506 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4949] Shirey, R., &#34;Internet Security Glossary, Version 2&#34;, FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, &lt;http://www.rfc-editor.org/info/rfc4949&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4949] Shirey、R.、 &#34;インターネットセキュリティ用語集、バージョン2&#34;、FYI 36、RFC 4949、DOI 10.17487 / RFC4949、2007年8月、&lt;http://www.rfc-editor.org/info/rfc4949&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5663] Black, D., Fridella, S., and J. Glasgow, &#34;Parallel NFS (pNFS) Block/Volume Layout&#34;, RFC 5663, DOI 10.17487/RFC5663, January 2010, &lt;http://www.rfc-editor.org/info/rfc5663&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5663]黒、D.、Fridella、S.、およびJ.グラスゴー、 &#34;パラレルNFS（pNFSの）ブロック/ボリュームレイアウト&#34;、RFC 5663、DOI 10.17487 / RFC5663、2010年1月、&lt;HTTP：//www.rfc- editor.org/info/rfc5663&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7204] Haynes, T., &#34;Requirements for Labeled NFS&#34;, RFC 7204, DOI 10.17487/RFC7204, April 2014, &lt;http://www.rfc-editor.org/info/rfc7204&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7204]ヘインズ、T.、 &#34;標識されたNFSのための要件&#34;、RFC 7204、DOI 10.17487 / RFC7204、2014年4月、&lt;http://www.rfc-editor.org/info/rfc7204&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7230] Fielding, R., Ed., and J. Reschke, Ed., &#34;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&#34;, RFC 7230, DOI 10.17487/RFC7230, June 2014, &lt;http://www.rfc-editor.org/info/rfc7230&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7230]フィールディング、R.、エド、及びJ. Reschke、編、 &#34;ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング&#34;。。、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、&lt;HTTP：/ /www.rfc-editor.org/info/rfc7230&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7530] Haynes, T., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Protocol&#34;, RFC 7530, DOI 10.17487/RFC7530, March 2015, &lt;http://www.rfc-editor.org/info/rfc7530&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7530]ヘインズ、T.、エド、およびD. Noveck、エド、 &#34;ネットワークファイルシステム（NFS）バージョン4プロトコル&#34;、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、&lt;のhttp：。。//www.rfc -editor.org/info/rfc7530&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Strohm11] Strohm, R., &#34;Chapter 2: Data Blocks, Extents, and Segments&#34;, Oracle Database Concepts 11g Release 1 (11.1), January 2011, &lt;http://download.oracle.com/docs/cd/B28359_01/server.111/ b28318/logical.htm&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Strohm11] Strohm、R.、 &#34;第2章：データ・ブロック、エクステントおよびセグメント&#34; は、Oracle Database概要1（11.1）、2011年1月、&lt;http://download.oracle.com/docs/cd/B28359_01 11gリリース/server.111/ b28318 / logical.htm&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[T10-SBC2] Elliott, R., Ed., &#34;ANSI INCITS 405-2005, Information Technology - SCSI Block Commands - 2 (SBC-2)&#34;, November 2004, &lt;ftp://www.t10.org/t10/document.05/05-344r0.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[T10-SBC2]エリオット、R.、エド、 &#34;ANSI INCITS 405から2005、情報技術 -  SCSIブロックコマンド -  2（SBC2）&#34;。2004年11月、&lt;ftp://www.t10.org/t10 /document.05/05-344r0.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tom Haynes would like to thank NetApp, Inc. for its funding of his time on this project.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トム・ヘインズは、このプロジェクトの自分の時間の資金調達のためのNetApp、Inc.に感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the topic &#34;sharing change attribute implementation characteristics with NFSv4 clients&#34;, the original document was by Trond Myklebust.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トピック「NFSv4のクライアントと共有する変化属性の実装特性」については、元の文書は、トロンMyklebustでいました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the NFS server-side copy, the original document was by James Lentini, Mike Eisler, Deepak Kenchammana, Anshul Madan, and Rahul Iyer. Tom Talpey co-authored an unpublished version of that document. It was also reviewed by a number of individuals: Pranoop Erasani, Tom Haynes, Arthur Lent, Trond Myklebust, Dave Noveck, Theresa Lingutla-Raj, Manjunath Shankararao, Satyam Vaghani, and Nico Williams. Anna Schumaker&#39;s early prototyping experience helped us avoid some traps. Also, both Olga Kornievskaia and Andy Adamson brought implementation experience to the use of copy stateids in the inter-server copy. Jorge Mora was able to optimize the handling of errors for the result of COPY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSサーバー側のコピーの場合は、元の文書は、ジェームズ・レンティーニ、マイク・アイスラー、ディーパックKenchammana、Anshulマダン、およびラーフルアイヤルででした。トムTalpeyは、そのドキュメントの未発表バージョンを共同執筆しました。四旬節Pranoop Erasani、トム・ヘインズ、アーサー、トロンMyklebust、デイブNoveck、テレサLingutla-ラジ、Manjunath Shankararao、サティヤムVaghani、そしてニコ・ウィリアムズ：それはまた個人の数によって見直されました。アンナSchumakerの初期のプロトタイピングの経験は、私たちはいくつかの罠を避ける助けました。また、オルガKornievskaiaとアンディ・アダムソンの両方がサーバ間コピーのコピーのstateidsの使用に実装経験をもたらしました。ホルヘ・モラはCOPYの結果のためにエラーの処理を最適化することができました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the NFS space reservation operations, the original document was by Mike Eisler, James Lentini, Manjunath Shankararao, and Rahul Iyer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSスペース予約操作については、元の文書には、マイク・アイスラー、ジェームズ・レンティーニ、Manjunath Shankararao、およびラーフルアイヤルででした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the sparse file support, the original document was by Dean Hildebrand and Marc Eshel. Valuable input and advice was received from Sorin Faibish, Bruce Fields, Benny Halevy, Trond Myklebust, and Richard Scheffenegger.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スパースファイルのサポートについては、元の文書には、ディーン・ヒルデブラントとマルク・Eshelでいました。貴重な入力とアドバイスがソリンFaibish、ブルース・フィールズ、ベニー・アレヴィ、トロンMyklebust、そしてリチャードScheffeneggerから受信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the application I/O hints, the original document was by Dean Hildebrand, Mike Eisler, Trond Myklebust, and Sam Falkner. Some early reviewers included Benny Halevy and Pranoop Erasani.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションI / Oのヒントについては、元の文書には、ディーン・ヒルデブラント、マイク・アイスラー、トロンMyklebust、そしてサム・フォークナーによってでした。いくつかの初期のレビューアはベニー・アレヴィとPranoop Erasaniが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For Labeled NFS, the original document was by David Quigley, James Morris, Jarrett Lu, and Tom Haynes. Peter Staubach, Trond Myklebust, Stephen Smalley, Sorin Faibish, Nico Williams, and David Black also contributed in the final push to get this accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
標識NFSの場合は、元の文書はデビッド・クイグリー、ジェームズ・モリス、ジャレット呂、そしてトム・ヘインズでいました。ピーター・ストーバック、トロンMyklebust、スティーブン・スモーリー、ソリンFaibish、ニコ・ウィリアムズ、そしてデヴィッド・ブラックもこれが受け入れを取得するために最後の一押しに貢献しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Christoph Hellwig was very helpful in getting the WRITE_SAME semantics to model more of what T10 was doing for WRITE SAME (10) [T10-SBC2]. And he led the push to get space reservations to more closely model the posix_fallocate() operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クリストフHellwigさんは、T10は、同じWRITE（10）[T10-SBC2]のために何をやっていたのより多くをモデル化するためにWRITE_SAMEセマンティクスを得ることにとても役に立ちました。そして、彼はより密接posix_fallocate（）の動作をモデル化するためのスペースの予約を取得するためにプッシュを導きました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Andy Adamson picked up the RPCSEC_GSSv3 work, which enabled both Labeled NFS and server-side copy to provide more secure options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アンディ・アダムソンは、より安全な選択肢を提供するために、標識NFSとサーバー側のコピーの両方を有効にRPCSEC_GSSv3の仕事を、拾いました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Christoph Hellwig provided the update to GETDEVICELIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クリストフHellwigさんはGETDEVICELISTにアップデートを提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jorge Mora provided a very detailed review and caught some important issues with the tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホルヘ・モラは、非常に詳細なレビューを提供し、テーブルといくつかの重要な問題を捉えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
During the review process, Talia Reyes-Ortiz helped the sessions run smoothly. While many people contributed here and there, the core reviewers were Andy Adamson, Pranoop Erasani, Bruce Fields, Chuck Lever, Trond Myklebust, David Noveck, Peter Staubach, and Mike Kupfer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レビュープロセスの間に、タリア・レイエス・オルティスは、セッションがスムーズに実行助けました。多くの人々があちこちで貢献している間、コアのレビューはアンディ・アダムソン、Pranoop Erasani、ブルース・フィールズ、チャックレバー、トロンMyklebust、デビッドNoveck、ピーター・ストーバック、そしてマイク・クッパーました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Elwyn Davies was the General Area Reviewer for this document, and his insights as to the relationship of this document and both [RFC5661] and [RFC7530] were very much appreciated!
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エルウィン・デイヴィスは、一般的なエリア、この文書のレビュー、および本文書との両方[RFC5661]と[RFC7530]の関係についての彼の洞察力は非常に高く評価されたのでした！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thomas Haynes Primary Data, Inc. 4300 El Camino Real Ste 100 Los Altos, CA 94022 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トーマス・ヘインズプライマリ・データ、株式会社アメリカの4300エル・カミノレアルサント100ロスアルトス、CA 94022米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 408 215 1519 Email: thomas.haynes@primarydata.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 408 215 1519 Eメール：thomas.haynes@primarydata.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
