<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8435 - Parallel NFS (pNFS) Flexible File Layout 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8435</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8435 - Parallel NFS (pNFS) Flexible File Layout 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8435">
              https://tools.ietf.org/html/rfc8435
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8435 - パラレルNFS（pNFSの）柔軟なファイルレイアウト</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         B. Halevy
Request for Comments: 8435
Category: Standards Track                                      T. Haynes
ISSN: 2070-1721                                              Hammerspace
                                                             August 2018
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                Parallel NFS (pNFS) Flexible File Layout
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parallel NFS (pNFS) allows a separation between the metadata (onto a metadata server) and data (onto a storage device) for a file. The flexible file layout type is defined in this document as an extension to pNFS that allows the use of storage devices that require only a limited degree of interaction with the metadata server and use already-existing protocols. Client-side mirroring is also added to provide replication of files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラレルNFS（pNFSの）ファイルの（メタデータサーバに）メタデータおよびデータ（記憶装置への）との間の分離を可能にします。柔軟なファイルレイアウトタイプは、メタデータサーバとの相互作用の限られた程度を必要とし、既存のプロトコルを使用するストレージデバイスの使用を可能にするpNFSの拡張として、この文書で定義されています。クライアント側のミラーリングも、ファイルの複製を提供するために添加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8435.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8435で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................3
      1.1. Definitions ................................................4
      1.2. Requirements Language ......................................6
   2. Coupling of Storage Devices .....................................6
      2.1. LAYOUTCOMMIT ...............................................7
      2.2. Fencing Clients from the Storage Device ....................7
           2.2.1. Implementation Notes for Synthetic uids/gids ........8
           2.2.2. Example of Using Synthetic uids/gids ................9
      2.3. State and Locking Models ..................................10
           2.3.1. Loosely Coupled Locking Model ......................11
           2.3.2. Tightly Coupled Locking Model ......................12
   3. XDR Description of the Flexible File Layout Type ...............13
      3.1. Code Components Licensing Notice ..........................14
   4. Device Addressing and Discovery ................................16
      4.1. ff_device_addr4 ...........................................16
      4.2. Storage Device Multipathing ...............................17
   5. Flexible File Layout Type ......................................18
      5.1. ff_layout4 ................................................19
           5.1.1. Error Codes from LAYOUTGET .........................23
           5.1.2. Client Interactions with FF_FLAGS_NO_IO_THRU_MDS ...23
      5.2. LAYOUTCOMMIT ..............................................24
      5.3. Interactions between Devices and Layouts ..................24
      5.4. Handling Version Errors ...................................24
   6. Striping via Sparse Mapping ....................................25
   7. Recovering from Client I/O Errors ..............................25
   8. Mirroring ......................................................26
      8.1. Selecting a Mirror ........................................26
      8.2. Writing to Mirrors ........................................27
           8.2.1. Single Storage Device Updates Mirrors ..............27
           8.2.2. Client Updates All Mirrors .........................27
           8.2.3. Handling Write Errors ..............................28
           8.2.4. Handling Write COMMITs .............................28
      8.3. Metadata Server Resilvering of the File ...................29
   9. Flexible File Layout Type Return ...............................29
      9.1. I/O Error Reporting .......................................30
           9.1.1. ff_ioerr4 ..........................................30
      9.2. Layout Usage Statistics ...................................31
           9.2.1. ff_io_latency4 .....................................31
           9.2.2. ff_layoutupdate4 ...................................32
           9.2.3. ff_iostats4 ........................................33
      9.3. ff_layoutreturn4 ..........................................34
   10. Flexible File Layout Type LAYOUTERROR .........................35
   11. Flexible File Layout Type LAYOUTSTATS .........................35
   12. Flexible File Layout Type Creation Hint .......................35
      12.1. ff_layouthint4 ...........................................35
   13. Recalling a Layout ............................................36
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      13.1. CB_RECALL_ANY ............................................36
   14. Client Fencing ................................................37
   15. Security Considerations .......................................37
      15.1. RPCSEC_GSS and Security Services .........................39
           15.1.1. Loosely Coupled ...................................39
           15.1.2. Tightly Coupled ...................................39
   16. IANA Considerations ...........................................39
   17. References ....................................................40
      17.1. Normative References .....................................40
      17.2. Informative References ...................................41
   Acknowledgments ...................................................42
   Authors&#39; Addresses ................................................42
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Parallel NFS (pNFS), the metadata server returns layout type structures that describe where file data is located. There are different layout types for different storage systems and methods of arranging data on storage devices. This document defines the flexible file layout type used with file-based data servers that are accessed using the NFS protocols: NFSv3 [RFC1813], NFSv4.0 [RFC7530], NFSv4.1 [RFC5661], and NFSv4.2 [RFC7862].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラレルNFS（pNFSの）においては、メタデータサーバは、ファイルデータがどこにあるかについて説明レイアウト型構造を返します。異なるストレージシステムおよびストレージ・デバイス上のデータを配置する方法のための別のレイアウトタイプがあります。 NFSv3の[RFC1813]、NFSv4.0 [RFC7530]、NFSv4.1 [RFC5661]、およびNFSv4.2 [RFC7862]：この文書では、NFSプロトコルを使用してアクセスされるファイルベースのデータ・サーバで使用される柔軟なファイルレイアウトタイプを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide a global state model equivalent to that of the files layout type, a back-end control protocol might be implemented between the metadata server and NFSv4.1+ storage devices. An implementation can either define its own proprietary mechanism or it could define a control protocol in a Standards Track document. The requirements for a control protocol are specified in [RFC5661] and clarified in [RFC8434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルのレイアウトタイプのものとグローバルな状態モデルと同等を実現するために、バックエンドの制御プロトコルは、メタデータサーバとNFSv4.1 +ストレージデバイス間で実装される可能性があります。実装は独自のメカニズムを定義するか、またはそれが標準化過程文書で制御プロトコルを定義することができます。制御プロトコルのための要件は[RFC5661]で指定し、[RFC8434]で明らかにされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The control protocol described in this document is based on NFS. It does not provide for knowledge of stateids to be passed between the metadata server and the storage devices. Instead, the storage devices are configured such that the metadata server has full access rights to the data file system and then the metadata server uses synthetic ids to control client access to individual files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書に記載された制御プロトコルは、NFSに基づいています。これは、メタデータサーバとストレージデバイス間で渡されるのstateidsの知識を提供していません。その代わり、ストレージデバイスは、メタデータサーバは、データ・ファイル・システムへの完全なアクセス権を持っているように構成され、その後、メタデータサーバは、個々のファイルへのクライアントアクセスを制御するために、合成のIDを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In traditional mirroring of data, the server is responsible for replicating, validating, and repairing copies of the data file. With client-side mirroring, the metadata server provides a layout that presents the available mirrors to the client. The client then picks a mirror to read from and ensures that all writes go to all mirrors. The client only considers the write transaction to have succeeded if all mirrors are successfully updated. In case of error, the client can use the LAYOUTERROR operation to inform the metadata server, which is then responsible for the repairing of the mirrored copies of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データの伝統的なミラーリングでは、サーバは、複製、検証、およびデータファイルのコピーを修復するための責任があります。クライアント側のミラーリングでは、メタデータサーバは、クライアントが利用可能なミラーを提示したレイアウトを提供します。次に、クライアントはからの読み取りにミラーをピックアップし、すべての書き込みがすべてのミラーに行くことを保証します。クライアントは、すべてのミラーが正常に更新された場合、書き込みトランザクションが成功したとみなします。エラーの場合、クライアントは、ファイルのミラーリングされたコピーの修理を担当してメタデータサーバを、知らせるためLAYOUTERROR操作を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
control communication requirements: the specification for information on layouts, stateids, file metadata, and file data that must be communicated between the metadata server and the storage devices. There is a separate set of requirements for each layout type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御通信要件：メタデータサーバとストレージデバイス間で通信されなければならないレイアウト、のstateids、ファイル・メタデータ、およびファイルデータに関する情報の仕様。各レイアウトタイプの要件の別々のセットがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
control protocol: the particular mechanism that an implementation of a layout type would use to meet the control communication requirement for that layout type. This need not be a protocol as normally understood. In some cases, the same protocol may be used as a control protocol and storage protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御プロトコル：レイアウトタイプの実装は、そのレイアウトタイプの制御通信の要件を満たすために使用する特定の機構。通常理解されるようにこれはプロトコルである必要はありません。いくつかのケースでは、同じプロトコル制御プロトコルとストレージプロトコルとして使用されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client-side mirroring: a feature in which the client, not the server, is responsible for updating all of the mirrored copies of a layout segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント側のミラーリング：クライアントではなくサーバー機能は、レイアウトのセグメントのミラーリングされたコピーのすべてを更新する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(file) data: that part of the file system object that contains the data to be read or written. It is the contents of the object rather than the attributes of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ファイル）データ：読み書きされるデータを含むファイル・システム・オブジェクトのその部分。これは、オブジェクトの内容ではなく、オブジェクトの属性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
data server (DS): a pNFS server that provides the file&#39;s data when the file system object is accessed over a file-based protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データサーバ（DS）：ファイル・システム・オブジェクトがファイルベースのプロトコルを介してアクセスされたときにファイルのデータを提供するのpNFSサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fencing: the process by which the metadata server prevents the storage devices from processing I/O from a specific client to a specific file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フェンシング：メタデータサーバは特定のファイルに特定のクライアントからのI / Oを処理してからストレージデバイスを防止するプロセス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
file layout type: a layout type in which the storage devices are accessed via the NFS protocol (see Section 13 of [RFC5661]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルレイアウトタイプ：ストレージデバイスはNFSプロトコルを介してアクセスされるレイアウトタイプ（[RFC5661]のセクション13を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
gid: the group id, a numeric value that identifies to which group a file belongs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GID：グループID、ファイルが属するグループを識別する数値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layout: the information a client uses to access file data on a storage device. This information includes specification of the protocol (layout type) and the identity of the storage devices to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウト：クライアントは、ストレージ・デバイス上のファイルデータにアクセスするために使用する情報。この情報は、プロトコル（レイアウトタイプ）、使用される記憶装置の同一の仕様を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layout iomode: a grant of either read-only or read/write I/O to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトIOModeに：クライアントへの読み取り専用または読み取り/書き込みI / Oのいずれかの助成金。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layout segment: a sub-division of a layout. That sub-division might be by the layout iomode (see Sections 3.3.20 and 12.2.9 of [RFC5661]), a striping pattern (see Section 13.3 of [RFC5661]), or requested byte range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトのセグメント：レイアウトのサブ分割。そのサブ分割レイアウトIOModeに（セクション3.3.20と[RFC5661]の12.2.9を参照されたい）、ストライピングパターン（[RFC5661]のセクション13.3を参照）、または要求されたバイト範囲によってかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layout stateid: a 128-bit quantity returned by a server that uniquely defines the layout state provided by the server for a specific layout that describes a layout type and file (see Section 12.5.2 of [RFC5661]). Further, Section 12.5.3 of [RFC5661] describes differences in handling between layout stateids and other stateid types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトのstateid一意レイアウトタイプとファイルを記述する特定のレイアウトのためにサーバによって提供されるレイアウトの状態を定義するサーバによって返された128ビットの量（[RFC5661]のセクション12.5.2を参照のこと）。さらに、[RFC5661]のセクション12.5.3は、レイアウトのstateidsおよび他のstateidタイプの間の取り扱いの違いを説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layout type: a specification of both the storage protocol used to access the data and the aggregation scheme used to lay out the file data on the underlying storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトタイプ：データにアクセスするために使用されるストレージプロトコルと、基礎となるストレージデバイス上のファイルのデータをレイアウトするために使用される集計方式の両方の仕様。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loose coupling: when the control protocol is a storage protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疎結合：制御プロトコルは、ストレージプロトコルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(file) metadata: the part of the file system object that contains various descriptive data relevant to the file object, as opposed to the file data itself. This could include the time of last modification, access time, EOF position, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ファイル）メタデータ：ファイルデータ自体とは対照的に、ファイル・オブジェクトに関連する様々な記述データを含むファイル・システム・オブジェクトの一部。これが最後の変更、アクセス時刻、EOFの位置などの時間を含めることができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
metadata server (MDS): the pNFS server that provides metadata information for a file system object. It is also responsible for generating, recalling, and revoking layouts for file system objects, for performing directory operations, and for performing I/O operations to regular files when the clients direct these to the metadata server itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバ（MDS）：ファイル・システム・オブジェクトのメタデータ情報を提供するのpNFSサーバ。また、生成リコール、およびディレクトリ操作を実行するため、およびクライアントは、メタデータサーバ自体にこれらを指示したときに通常のファイルへのI / O操作を実行するため、ファイル・システム・オブジェクトのためのレイアウトを取り消すための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mirror: a copy of a layout segment. Note that if one copy of the mirror is updated, then all copies must be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミラー：レイアウトセグメントのコピー。鏡の一つのコピーが更新された場合は、すべてのコピーを更新しなければならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
recalling a layout: a graceful recall, via a callback, of a specific layout by the metadata server to the client. Graceful here means that the client would have the opportunity to flush any WRITEs, etc., before returning the layout to the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントへのメタデータサーバによって特定のレイアウトで、コールバックを経由して、優雅なリコール：レイアウトをリコール。ここでの優雅は、クライアントがメタデータサーバへのレイアウトを返す前に、任意の書き込み、などをフラッシュする機会を持つことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
revoking a layout: an invalidation of a specific layout by the metadata server. Once revocation occurs, the metadata server will not accept as valid any reference to the revoked layout, and a storage device will not accept any client access based on the layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバによって特定のレイアウトの無効化：レイアウトを取り消します。失効が発生すると、メタデータサーバは取り消され、レイアウトに有効な任意の参照を受け入れないだろう、とストレージデバイスは、レイアウトに基づいて、任意のクライアントアクセスを受け付けません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resilvering: the act of rebuilding a mirrored copy of a layout segment from a known good copy of the layout segment. Note that this can also be done to create a new mirrored copy of the layout segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再同期化：レイアウト・セグメントの既知の正常なコピーからレイアウトセグメントのミラーコピーを再構築する行為。これはまた、レイアウトセグメントの新しいミラーコピーを作成するために行うことができることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rsize: the data transfer buffer size used for READs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リサイズ：に使用されるデータ転送バッファサイズが読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid: a 128-bit quantity returned by a server that uniquely defines the set of locking-related state provided by the server. Stateids may designate state related to open files, byte-range locks, delegations, or layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid一意サーバによって提供されるロック関連状態のセットを定義し、サーバによって返された128ビットの量。 stateidsは、ファイル、バイト範囲ロック、代表団、またはレイアウトを開くには、関連する状態を指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
storage device: the target to which clients may direct I/O requests when they hold an appropriate layout. See Section 2.1 of [RFC8434] for further discussion of the difference between a data server and a storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイス：彼らは適切なレイアウトを保持したときに、クライアントがI / O要求を指示することができる先のターゲット。データサーバとストレージ装置との間の差の更なる議論については[RFC8434]のセクション2.1を参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
storage protocol: the protocol used by clients to do I/O operations to the storage device. Each layout type specifies the set of storage protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージプロトコル：ストレージ・デバイスへのI / O操作を行うためにクライアントが使用するプロトコル。それぞれのレイアウトタイプは、ストレージプロトコルのセットを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tight coupling: an arrangement in which the control protocol is one designed specifically for control communication. It may be either a proprietary protocol adapted specifically to a particular metadata server or a protocol based on a Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密結合：制御プロトコルは、制御通信のために特別に設計された1つである構成。これは、特定のメタデータサーバに特異的に適合独自のプロトコルまたは標準化過程文書に基づいてプロトコルのいずれであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uid: the user id, a numeric value that identifies which user owns a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UID：ユーザID、ファイルを所有しているユーザーを識別する数値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wsize: the data transfer buffer size used for WRITEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
wsizeの値：書き込みに使用されるデータ転送バッファサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Coupling of Storage Devices
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ストレージデバイスの2カップリング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server implementation may choose either a loosely coupled model or a tightly coupled model between the metadata server and the storage devices. [RFC8434] describes the general problems facing pNFS implementations. This document details how the new flexible file layout type addresses these issues. To implement the tightly coupled model, a control protocol has to be defined. As the flexible file layout imposes no special requirements on the client, the control protocol will need to provide:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバの実装は、疎結合モデルまたはメタデータサーバとストレージデバイス間の密結合モデルのいずれかを選択することができます。 [RFC8434]はpNFSの実装に対向一般的な問題を記載しています。この文書は、新しい柔軟なファイルレイアウトの種類は、これらの問題を解決する方法について説明します。密結合モデルを実装するために、制御プロトコルが定義されなければなりません。柔軟なファイルレイアウトがクライアントに特別な要件が課されないように、制御プロトコルが提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) management of both security and LAYOUTCOMMITs and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ及びLAYOUTCOMMITsとの両方の（1）管理
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a global stateid model and management of these stateids.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2）これらのstateidsのグローバルのstateidモデルと管理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When implementing the loosely coupled model, the only control protocol will be a version of NFS, with no ability to provide a global stateid model or to prevent clients from using layouts inappropriately. To enable client use in that environment, this document will specify how security, state, and locking are to be managed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疎結合モデルを実装する場合、唯一の制御プロトコルは、グローバルのstateidモデルを提供するか、不適切なレイアウトを使用することからクライアントを防止する能力と、NFSのバージョンであろう。その環境でのクライアントの使用を有効にするには、この文書では、セキュリティ、状態、およびロックを管理する方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. LAYOUTCOMMIT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.  LAYOUTCOMMIT
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the coupling model, the metadata server has the responsibility, upon receiving a LAYOUTCOMMIT (see Section 18.42 of [RFC5661]) to ensure that the semantics of pNFS are respected (see Section 3.1 of [RFC8434]). These do include a requirement that data written to a data storage device be stable before the occurrence of the LAYOUTCOMMIT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
かかわらず、結合モデルの、メタデータサーバは、pNFSののセマンティクスが尊重されることを保証するLAYOUTCOMMITを受信する責任を、（[RFC5661]のセクション18.42を参照）（[RFC8434]のセクション3.1を参照）を有しています。これらは、データ記憶装置に書き込まれたデータがLAYOUTCOMMITが発生する前に安定しなければならないという要件が含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is the responsibility of the client to make sure the data file is stable before the metadata server begins to query the storage devices about the changes to the file. If any WRITE to a storage device did not result with stable_how equal to FILE_SYNC, a LAYOUTCOMMIT to the metadata server MUST be preceded by a COMMIT to the storage devices written to. Note that if the client has not done a COMMIT to the storage device, then the LAYOUTCOMMIT might not be synchronized to the last WRITE operation to the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバがファイルへの変更についてのストレージデバイスを照会するために開始する前に、データファイルが安定していることを確認するために、クライアントの責任です。記憶装置への書き込みがFILE_SYNCに等しいstable_howと生じなかった場合、メタデータサーバへLAYOUTCOMMITが書き込まストレージデバイスにCOMMITが先行されなければなりません。クライアントは、ストレージデバイスにCOMMITを行っていない場合には、LAYOUTCOMMITは、ストレージデバイスへの最後の書き込み動作に同期されない可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Fencing Clients from the Storage Device
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 記憶装置からクライアントフェンシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With loosely coupled storage devices, the metadata server uses synthetic uids (user ids) and gids (group ids) for the data file, where the uid owner of the data file is allowed read/write access and the gid owner is allowed read-only access. As part of the layout (see ffds_user and ffds_group in Section 5.1), the client is provided with the user and group to be used in the Remote Procedure Call (RPC) [RFC5531] credentials needed to access the data file. Fencing off of clients is achieved by the metadata server changing the synthetic uid and/or gid owners of the data file on the storage device to implicitly revoke the outstanding RPC credentials. A client presenting the wrong credential for the desired access will get an NFS4ERR_ACCESS error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
緩く結合された記憶装置と、メタデータサーバは、データファイルのUID所有者は読み取りのみ許可されている読み取り/書き込みアクセスとgid所有者が許可されているデータファイルのための合成のUID（ユーザID）とGID（グループID）を使用しアクセス。レイアウト（5.1節でffds_userとffds_groupを参照）の一環として、クライアントは、リモートプロシージャコール（RPC）のデータファイルにアクセスするために必要な[RFC5531]の資格情報で使用するユーザーとグループを備えています。クライアントのオフフェンシングは、暗黙的に優れたRPC資格証明書を失効させる合成のuidおよび/またはストレージデバイス上のデータファイルのGID所有者を変更するメタデータサーバによって達成されます。所望のアクセスのために、間違った資格情報を提示するクライアントはNFS4ERR_ACCESSエラーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With this loosely coupled model, the metadata server is not able to fence off a single client; it is forced to fence off all clients. However, as the other clients react to the fencing, returning their layouts and trying to get new ones, the metadata server can hand out a new uid and gid to allow access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この疎結合のモデルでは、メタデータサーバは、フェンスオフ単一のクライアントをすることができません。それは、すべてのクライアントオフフェンスに強制されます。他のクライアントが自分のレイアウトを返し、フェンシングに反応し、新しいものを取得しようとしてしかし、メタデータサーバは、アクセスを許可する新しいuidとgidを配ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED to implement common access control methods at the storage device file system to allow only the metadata server root (super user) access to the storage device and to set the owner of all directories holding data files to the root user. This approach provides a practical model to enforce access control and fence off cooperative clients, but it cannot protect against malicious clients; hence, it provides a level of security equivalent to AUTH_SYS. It is RECOMMENDED that the communication between the metadata server and storage device be secure from eavesdroppers and man-in-the-middle protocol tampering. The security measure could be physical security (e.g., the servers are co-located in a physically secure area), encrypted communications, or some other technique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスへの唯一のメタデータ・サーバのルート（スーパーユーザー）アクセスを許可するようにし、rootユーザーにデータファイルを保持しているすべてのディレクトリの所有者を設定するには、ストレージデバイスのファイルシステムで共通のアクセス制御メソッドを実装することをお勧めします。このアプローチは、アクセス制御やフェンスオフ協力のクライアントを強制するための実用的なモデルを提供していますが、それは悪意のあるクライアントから保護することはできません。したがって、AUTH_SYSのセキュリティと同等のレベルを提供します。メタデータサーバとストレージデバイス間の通信が盗聴者とのman-in-the-middleプロトコル改ざんから保護することが推奨されます。セキュリティ対策は、物理的なセキュリティ（例えば、サーバが物理的に安全な領域に同じ場所に配置されている）、暗号化通信、またはいくつかの他の技術であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With tightly coupled storage devices, the metadata server sets the user and group owners, mode bits, and Access Control List (ACL) of the data file to be the same as the metadata file. And the client must authenticate with the storage device and go through the same authorization process it would go through via the metadata server. In the case of tight coupling, fencing is the responsibility of the control protocol and is not described in detail in this document. However, implementations of the tightly coupled locking model (see Section 2.3) will need a way to prevent access by certain clients to specific files by invalidating the corresponding stateids on the storage device. In such a scenario, the client will be given an error of NFS4ERR_BAD_STATEID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密結合された記憶装置と、メタデータサーバは、メタデータファイルと同じになるように、データファイルのユーザおよびグループ所有者、モードビット、およびアクセス制御リスト（ACL）を設定します。そして、クライアントは、ストレージ・デバイスを使用して認証し、それがメタデータ・サーバを経由して通過するのと同じ承認プロセスを経なければなりません。密結合の場合には、フェンシングは、制御プロトコルの責任であり、この文書に詳細に記載されていません。しかしながら、密結合ロックモデル（セクション2.3を参照）の実装は、記憶装置上の対応のstateidsを無効にすることによって、特定のファイルに特定のクライアントによるアクセスを防止するための方法が必要になります。このようなシナリオでは、クライアントはNFS4ERR_BAD_STATEIDの誤差が与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client need not know the model used between the metadata server and the storage device. It need only react consistently to any errors in interacting with the storage device. It should both return the layout and error to the metadata server and ask for a new layout. At that point, the metadata server can either hand out a new layout, hand out no layout (forcing the I/O through it), or deny the client further access to the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、メタデータサーバとストレージデバイス間で使用されるモデルを知っている必要はありません。それだけで、ストレージデバイスとの相互作用に何らかのエラーに一貫して反応する必要があります。これは、両方のメタデータサーバにレイアウトし、エラーを返し、新しいレイアウトを求める必要があります。その時点で、メタデータサーバは、新しいレイアウトを配る一切レイアウト（それを介してI / Oを強制）を配るない、またはファイルへのクライアントのさらなるアクセスを拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. Implementation Notes for Synthetic uids/gids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. 合成のUID / GIDのための実装の注意事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The selection method for the synthetic uids and gids to be used for fencing in loosely coupled storage devices is strictly an implementation issue. That is, an administrator might restrict a range of such ids available to the Lightweight Directory Access Protocol (LDAP) &#39;uid&#39; field [RFC4519]. The administrator might also be able to choose an id that would never be used to grant access. Then, when the metadata server had a request to access a file, a SETATTR would be sent to the storage device to set the owner and group of the data file. The user and group might be selected in a round-robin fashion from the range of available ids.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
緩く結合された記憶装置にフェンシングのために使用される合成UIDおよびGIDの選択方法は、厳密な実装の問題です。これは、管理者がLDAP（Lightweight Directory Access Protocol）の「UID」フィールド[RFC4519]に利用可能なIDの範囲を制限する可能性が、あります。管理者は、アクセス権を付与するために使用されることはありませんでしょうIDを選択することができるかもしれません。メタデータサーバがファイルにアクセスするための要求があったときに、SETATTRは、データファイルの所有者とグループを設定するには、ストレージ・デバイスに送信されます。ユーザおよびグループは、利用可能なIDの範囲からラウンドロビン方式で選択することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Those ids would be sent back as ffds_user and ffds_group to the client, who would present them as the RPC credentials to the storage device. When the client is done accessing the file and the metadata server knows that no other client is accessing the file, it can reset the owner and group to restrict access to the data file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのIDは、ストレージデバイスへのRPC資格としてそれらを提示するクライアントにffds_userとffds_groupとして送り返されます。クライアントがファイルにアクセスして行われ、メタデータサーバは、他のクライアントがファイルにアクセスしていないことを知っている場合は、データファイルへのアクセスを制限するために、所有者とグループをリセットすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the metadata server wants to fence off a client, it changes the synthetic uid and/or gid to the restricted ids. Note that using a restricted id ensures that there is a change of owner and at least one id available that never gets allowed access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバは、クライアントオフフェンスしようとする場合、それが制限されたIDへの合成uidと/またはGIDを変更します。制限されたIDを使用すると、所有者の変更とアクセスが許可されることは決してありませんが利用可能少なくとも1つのIDが存在することを保証することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Under an AUTH_SYS security model, synthetic uids and gids of 0 SHOULD be avoided. These typically either grant super access to files on a storage device or are mapped to an anonymous id. In the first case, even if the data file is fenced, the client might still be able to access the file. In the second case, multiple ids might be mapped to the anonymous ids.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_SYSセキュリティモデルでは、0の合成UIDとGIDは避けるべきです。これらは、典型的には、いずれかのストレージデバイス上のファイルへの極度のアクセスを許可または匿名IDにマッピングされます。最初のケースでは、データファイルがフェンスで囲まれていても、クライアントは、ファイルにアクセスすることができるかもしれません。後者の場合には、複数のIDは匿名IDにマッピングされている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. Example of Using Synthetic uids/gids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. 合成のUID / GIDの使用例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user loghyr creates a file &#34;ompha.c&#34; on the metadata server, which then creates a corresponding data file on the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザloghyrは、ストレージデバイス上の対応するデータ・ファイルを作成し、メタデータサーバ上のファイル「ompha.c」を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server entry may look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータ・サーバのエントリは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
-rw-r--r-- 1 loghyr staff 1697 Dec 4 11:31 ompha.c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
-rw-R  -  r--の1 loghyrスタッフ1697年12月4日11時31 ompha.c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the storage device, the file may be assigned some unpredictable synthetic uid/gid to deny access:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスには、ファイルがアクセスを拒否するために、いくつかの予測できない合成UID / GIDを割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   -rw-r-----    1 19452   28418    1697 Dec  4 11:31 data_ompha.c
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the file is opened on a client and accessed, the user will try to get a layout for the data file. Since the layout knows nothing about the user (and does not care), it does not matter whether the user loghyr or garbo opens the file. The client has to present an uid of 19452 to get write permission. If it presents any other value for the uid, then it must give a gid of 28418 to get read access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがクライアント上で開かれ、アクセスされた場合、ユーザーは、データファイルのレイアウトを取得しようとします。レイアウトは、ユーザー（と気にしない）について何も知らないので、ユーザーloghyrやガルボがファイルを開くかどうかは関係ありません。クライアントは、書き込み権限を取得するために19452のUIDを提示する必要があります。それはUIDのために他の値を提示した場合、それは読み取りアクセスを得るために28418のGIDを与えなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Further, if the metadata server decides to fence the file, it should change the uid and/or gid such that these values neither match earlier values for that file nor match a predictable change based on an earlier fencing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバは、フェンスのファイルをすることを決定した場合また、それは、そのファイルのように、これらの値のいずれも一致し、以前の値のuidおよび/またはGIDを変更するも、以前のフェンシングに基づいて予測可能な変更と一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   -rw-r-----    1 19453   28419    1697 Dec  4 11:31 data_ompha.c
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of synthetic gids on the storage device should be selected such that there is no mapping in any of the name services used by the storage device, i.e., each group should have no members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
記憶装置上の合成のGIDのセットは、ストレージデバイスによって使用されるネームサービスのいずれにもマッピングが存在しないように選択されるべきである、すなわち、各グループにはメンバーを持たないはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the layout segment has an iomode of LAYOUTIOMODE4_READ, then the metadata server should return a synthetic uid that is not set on the storage device. Only the synthetic gid would be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトセグメントはLAYOUTIOMODE4_READのIOModeにがある場合、メタデータサーバは、記憶装置上に設定されていない合成UIDを返すべきです。唯一の合成gidが有効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client is thus solely responsible for enforcing file permissions in a loosely coupled model. To allow loghyr write access, it will send an RPC to the storage device with a credential of 1066:1067. To allow garbo read access, it will send an RPC to the storage device with a credential of 1067:1067. The value of the uid does not matter as long as it is not the synthetic uid granted when getting the layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、このように疎結合モデルでのファイルのアクセス権を執行する責任があります。 1067：loghyr書き込みアクセスを許可するには、それは1066年の資格を持つストレージデバイスにRPCを送信します。 1067：ガルボは、読み取りアクセスを許可するには、それは1067年の資格を持つストレージデバイスにRPCを送信します。 UIDの値は、それがレイアウトを取得するときに付与された合成UIDでないとして重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While pushing the enforcement of permission checking onto the client may seem to weaken security, the client may already be responsible for enforcing permissions before modifications are sent to a server. With cached writes, the client is always responsible for tracking who is modifying a file and making sure to not coalesce requests from multiple users into one request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティを弱めるように見えるかもしれませんが、クライアントに許可のチェックの施行を押しながら、クライアントがすでに変更がサーバーに送信される前に、権限を執行する責任があります。キャッシュされた書き込みでは、クライアントは常に、誰がファイルを修正している追跡し、一つのリクエストに複数のユーザーからの要求を合体しないようにしてください作るための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. State and Locking Models
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. 国家とロックモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation can always be deployed as a loosely coupled model. There is, however, no way for a storage device to indicate over an NFS protocol that it can definitively participate in a tightly coupled model:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は常に疎結合モデルとして展開することができます。ストレージデバイスは、それが決定的に密結合モデルに参加することができ、NFSプロトコルを介して指示するための方法は、しかし、ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Storage devices implementing the NFSv3 and NFSv4.0 protocols are always treated as loosely coupled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのNFSv3とNFSv4.0プロトコルを実装するストレージデバイスは常に疎結合として扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1+ storage devices that do not return the EXCHGID4_FLAG_USE_PNFS_DS flag set to EXCHANGE_ID are indicating that they are to be treated as loosely coupled. From the locking viewpoint, they are treated in the same way as NFSv4.0 storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O EXCHANGE_IDに設定EXCHGID4_FLAG_USE_PNFS_DSフラグを返さないNFSv4.1 +記憶装置は、それらが疎結合として扱われるべきであることを示しています。ロック観点から、それらはNFSv4.0ストレージデバイスと同様に扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NFSv4.1+ storage devices that do identify themselves with the EXCHGID4_FLAG_USE_PNFS_DS flag set to EXCHANGE_ID can potentially be tightly coupled. They would use a back-end control protocol to implement the global stateid model as described in [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCHANGE_IDに設定EXCHGID4_FLAG_USE_PNFS_DSフラグで自身を識別しないO NFSv4.1 +記憶装置は、潜在的に密に結合することができます。彼らは[RFC5661]に記載されているように、グローバルのstateidモデルを実装するために、バックエンド制御プロトコルを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A storage device would have to be either discovered or advertised over the control protocol to enable a tightly coupled model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
記憶装置は、密結合モデルを有効にする制御プロトコルを介して発見またはアドバタイズするのいずれかであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. Loosely Coupled Locking Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. 疎結合ロック・モデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When locking-related operations are requested, they are primarily dealt with by the metadata server, which generates the appropriate stateids. When an NFSv4 version is used as the data access protocol, the metadata server may make stateid-related requests of the storage devices. However, it is not required to do so, and the resulting stateids are known only to the metadata server and the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック関連の操作が要求される場合、それらは、主に適切なのstateidsを生成するメタデータサーバによって扱われます。 NFSv4のバージョンがデータ・アクセス・プロトコルとして使用する場合、メタデータサーバは、ストレージデバイスののstateid関連の要求を行うことができます。しかし、そうする必要はありません、そして得られたのstateidsは、メタデータのみサーバとストレージ・デバイスに知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given this basic structure, locking-related operations are handled as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように、この基本的な構造が与えられると、ロックに関連する操作は、処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPENs are dealt with by the metadata server. Stateids are selected by the metadata server and associated with the client ID describing the client&#39;s connection to the metadata server. The metadata server may need to interact with the storage device to locate the file to be opened, but no locking-related functionality need be used on the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのOPENsは、メタデータサーバによって対処されています。 stateidsは、メタデータサーバによって選択され、メタデータサーバへのクライアントの接続を記述したクライアントIDに関連付けられています。メタデータサーバは、ファイルをオープンする検索するストレージデバイスと対話する必要があるかもしれませんが、ないロック関連の機能は、ストレージ・デバイス上で使用する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
OPEN_DOWNGRADE and CLOSE only require local execution on the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
OPEN_DOWNGRADEとCLOSEは、メタデータのみのサーバー上のローカル実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Advisory byte-range locks can be implemented locally on the metadata server. As in the case of OPENs, the stateids associated with byte-range locks are assigned by the metadata server and only used on the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O諮問バイト範囲ロックは、メタデータサーバー上でローカルに実装することができます。 OPENsの場合のように、バイト範囲ロックに関連付けられているのstateidsは、メタデータサーバによって割り当てられ、メタデータのみをサーバ上で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Delegations are assigned by the metadata server that initiates recalls when conflicting OPENs are processed. No storage device involvement is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの代表団は、矛盾のOPENsが処理される際にリコールを開始し、メタデータ・サーバによって割り当てられます。いいえ、ストレージデバイスの関与は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TEST_STATEID and FREE_STATEID are processed locally on the metadata server, without storage device involvement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TEST_STATEIDとFREE_STATEIDは、記憶装置の関与なしに、メタデータサーバ上でローカルに処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All I/O operations to the storage device are done using the anonymous stateid. Thus, the storage device has no information about the openowner and lockowner responsible for issuing a particular I/O operation. As a result:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスへのすべてのI / O操作は、匿名たstateidを使用して行われます。従って、記憶装置はopenownerと特定のI / O操作を発行する責任lockownerに関する情報がありません。結果として：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Mandatory byte-range locking cannot be supported because the storage device has no way of distinguishing I/O done on behalf of the lock owner from those done by others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージ装置のI / O他人によって行われたものからロック所有者に代わって行わ区別する方法がないので、O必須バイト範囲ロッキングをサポートすることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Enforcement of share reservations is the responsibility of the client. Even though I/O is done using the anonymous stateid, the client must ensure that it has a valid stateid associated with the openowner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oシェアの予約の施行は、クライアントの責任です。 I / Oが匿名たstateidを使用して行われていても、クライアントは、それがopenownerに関連する有効なstateidを持っていることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that a stateid is revoked, the metadata server is responsible for preventing client access, since it has no way of being sure that the client is aware that the stateid in question has been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、クライアントが問題になっているのstateidが取り消されたことを認識していることを確認している方法がないことからのstateidが取り消された場合には、メタデータサーバは、クライアントアクセスを防止する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the client never receives a stateid generated by a storage device, there is no client lease on the storage device and no prospect of lease expiration, even when access is via NFSv4 protocols. Clients will have leases on the metadata server. In dealing with lease expiration, the metadata server may need to use fencing to prevent revoked stateids from being relied upon by a client unaware of the fact that they have been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ストレージデバイスによって生成されたstateidを受けたことがないように、ストレージデバイスには、クライアントのリースとリース満了の見込みはアクセスがNFSv4のプロトコル経由であっても、ありません。クライアントは、メタデータサーバ上のリースを持っています。リース満了に対処するには、メタデータサーバは、彼らが失効しているという事実を知らないクライアントが依存しているから、失効のstateidsを防ぐためにフェンシングを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2. Tightly Coupled Locking Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2. 密結合ロック・モデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When locking-related operations are requested, they are primarily dealt with by the metadata server, which generates the appropriate stateids. These stateids must be made known to the storage device using control protocol facilities, the details of which are not discussed in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック関連の操作が要求される場合、それらは、主に適切なのstateidsを生成するメタデータサーバによって扱われます。これらのstateidsは、このドキュメントで説明されていない詳細は制御プロトコル機能を用いて記憶装置に知らせなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given this basic structure, locking-related operations are handled as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように、この基本的な構造が与えられると、ロックに関連する操作は、処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OPENs are dealt with primarily on the metadata server. Stateids are selected by the metadata server and associated with the client ID describing the client&#39;s connection to the metadata server. The metadata server needs to interact with the storage device to locate the file to be opened and to make the storage device aware of the association between the metadata-server-chosen stateid and the client and openowner that it represents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのOPENsは、メタデータサーバ上で主に扱っています。 stateidsは、メタデータサーバによって選択され、メタデータサーバへのクライアントの接続を記述したクライアントIDに関連付けられています。メタデータサーバがオープンするファイルを検索し、それが表すメタデータ・サーバーに選ばれたのstateidとクライアントとの間の関連openownerのストレージデバイスを認識させるためにストレージデバイスと対話する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
OPEN_DOWNGRADE and CLOSE are executed initially on the metadata server, but the state change made must be propagated to the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
OPEN_DOWNGRADEとCLOSEは、メタデータ・サーバ上で最初に実行されますが、作られた状態変化は、記憶装置に伝播する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Advisory byte-range locks can be implemented locally on the metadata server. As in the case of OPENs, the stateids associated with byte-range locks are assigned by the metadata server and are available for use on the metadata server. Because I/O operations are allowed to present lock stateids, the metadata server needs the ability to make the storage device aware of the association between the metadata-server-chosen stateid and the corresponding open stateid it is associated with.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O諮問バイト範囲ロックは、メタデータサーバー上でローカルに実装することができます。 OPENsの場合のように、バイト範囲ロックに関連付けられているのstateidsは、メタデータサーバによって割り当てられ、メタデータサーバ上で使用するために入手可能です。 I / O操作がロックのstateidsを提示するために許可されているので、メタデータサーバは、メタデータサーバ選択のstateid、それが関連付けられている対応するオープンのstateidとの間の関連付けの記憶装置に認識させる能力を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Mandatory byte-range locks can be supported when both the metadata server and the storage devices have the appropriate support. As in the case of advisory byte-range locks, these are assigned by the metadata server and are available for use on the metadata server. To enable mandatory lock enforcement on the storage device, the metadata server needs the ability to make the storage device aware of the association between the metadata-server-chosen stateid and the client, openowner, and lock (i.e., lockowner, byte-range, and lock-type) that it represents. Because I/O operations are allowed to present lock stateids, this information needs to be propagated to all storage devices to which I/O might be directed rather than only to storage device that contain the locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータ・サーバとストレージ・デバイスの両方が適切なサポートを持っているとき、O必須バイト範囲ロックをサポートすることができます。諮問バイト範囲ロックの場合のように、これらは、メタデータサーバによって割り当てられ、メタデータサーバ上で使用するために利用できます。ストレージデバイス上の強制ロックの強制を有効にするには、メタデータサーバは、メタデータ・サーバーに選ばれたのstateidとクライアント、openowner、およびロック（すなわち、lockowner、バイト範囲との間の関連性のストレージデバイスに認識させる能力を必要とし、ロック型）は、それが表しています。 I / O操作がロックのstateidsを提示することが許可されているので、この情報は、I / Oだけでロックされた領域が含まれているストレージデバイスにではなく、向けられる可能性があるために、すべてのストレージデバイスに伝播する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Delegations are assigned by the metadata server that initiates recalls when conflicting OPENs are processed. Because I/O operations are allowed to present delegation stateids, the metadata server requires the ability (1) to make the storage device aware of the association between the metadata-server-chosen stateid and the filehandle and delegation type it represents and (2) to break such an association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの代表団は、矛盾のOPENsが処理される際にリコールを開始し、メタデータ・サーバによって割り当てられます。 I / O操作を委任のstateidsを提示するために許可されているので、メタデータサーバは、（1）メタデータサーバ選択のstateidとファイルハンドルと委任の間の関連を認識し、記憶装置は、それが表す入力する能力を必要とし、（2）そのような関連付けを解除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TEST_STATEID is processed locally on the metadata server, without storage device involvement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TEST_STATEIDは、記憶装置の関与なしに、メタデータサーバ上でローカルに処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FREE_STATEID is processed on the metadata server, but the metadata server requires the ability to propagate the request to the corresponding storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O FREE_STATEIDは、メタデータサーバ上で処理が、メタデータサーバは、対応するストレージデバイスへの要求を伝播する能力が必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the client will possess and use stateids valid on the storage device, there will be a client lease on the storage device, and the possibility of lease expiration does exist. The best approach for the storage device is to retain these locks as a courtesy. However, if it does not do so, control protocol facilities need to provide the means to synchronize lock state between the metadata server and storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ストレージ・デバイス上で有効なのstateidsを所有して使用しますので、そこストレージデバイス上のクライアントのリースとなり、リース満了の可能性は存在しません。ストレージデバイスのための最善のアプローチは、礼儀として、これらのロックを保持することです。それはそうしない場合は、制御プロトコル機能は、メタデータサーバとストレージデバイス間のロック状態を同期させるための手段を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients will also have leases on the metadata server that are subject to expiration. In dealing with lease expiration, the metadata server would be expected to use control protocol facilities enabling it to invalidate revoked stateids on the storage device. In the event the client is not responsive, the metadata server may need to use fencing to prevent revoked stateids from being acted upon by the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、クライアントは、有効期限の対象となるメタデータ・サーバ上のリースを持っています。リース満了に対処するには、メタデータサーバは、ストレージ・デバイス上で取り消されたのstateidsを無効にすることを可能にする制御プロトコル機能を使用することが予想されます。クライアントが応答しない場合には、メタデータサーバは、記憶装置によって作用されることから、失効のstateidsを防ぐためにフェンシングを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. XDR Description of the Flexible File Layout Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
柔軟なファイルレイアウトタイプの3 XDR説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document contains the External Data Representation (XDR) [RFC4506] description of the flexible file layout type. The XDR description is embedded in this document in a way that makes it simple for the reader to extract into a ready-to-compile form. The reader can feed this document into the following shell script to produce the machine-readable XDR description of the flexible file layout type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、柔軟なファイルレイアウトタイプの外部データ表現（XDR）[RFC4506]の記述を含んでいます。 XDRの説明は、それが単純な読者がすぐにコンパイル形式に抽出することを可能にするように、この文書に埋め込まれています。読者は、柔軟なファイルレイアウトタイプの機械可読XDR記述を生成するために、次のシェル・スクリプトにこの文書を供給することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#!/bin/sh grep &#39;^ *///&#39; $* | sed &#39;s?^ */// ??&#39; | sed &#39;s?^ *///$??&#39;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ます。＃！/ bin / shのはgrep &#39;^ * ///&#39; $ * | SEDの？^ * /// ?? &#39; | SEDの？^ * /// $ ?? &#39;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That is, if the above script is stored in a file called &#34;extract.sh&#34; and this document is in a file called &#34;spec.txt&#34;, then the reader can do:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、上記のスクリプトは、「extract.sh」と呼ばれるファイルに格納されており、この文書は「spec.txt」と呼ばれるファイルである、そして読者が行うことができます場合は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sh extract.sh &lt; spec.txt &gt; flex_files_prot.x
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SH extract.sh &lt;spec.txt&gt; flex_files_prot.x
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The effect of the script is to remove leading white space from each line, plus a sentinel sequence of &#34;///&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スクリプトの効果は、主要な白の各ラインからのスペース、プラス「///」のセンチネル配列を除去することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The embedded XDR file header follows. Subsequent XDR descriptions with the sentinel sequence are embedded throughout the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
埋め込みXDRファイルヘッダは以下の通りです。センチネル配列とそれに続くXDRの説明は文書全体に埋め込まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the XDR code contained in this document depends on types from the NFSv4.1 nfs4_prot.x file [RFC5662]. This includes both nfs types that end with a 4, such as offset4, length4, etc., as well as more generic types such as uint32_t and uint64_t.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書に含まれるXDRコードは[RFC5662]ファイルnfs4_prot.x NFSv4.1の種類に依存することに留意されたいです。これは、等OFFSET4、LENGTH4、並びにのuint32_tとuint64_tを、より一般的なタイプとして4で終わるNFSタイプ、の両方を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Code Components Licensing Notice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. コードコンポーネントのライセンスに関するお知らせ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the XDR description and the scripts used for extracting the XDR description are Code Components as described in Section 4 of &#34;Trust Legal Provisions (TLP)&#34; [LEGAL]. These Code Components are licensed according to the terms of that document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「トラスト法規定（TLP）」[法的]のセクション4で説明したようにXDR記述とXDR記述を抽出するために使用されるスクリプトの両方は、コードコンポーネントです。これらのコードコンポーネントは、その文書の条項に従ってライセンスされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// /*
   ///  * Copyright (c) 2018 IETF Trust and the persons identified
   ///  * as authors of the code.  All rights reserved.
   ///  *
   ///  * Redistribution and use in source and binary forms, with
   ///  * or without modification, are permitted provided that the
   ///  * following conditions are met:
   ///  *
   ///  * - Redistributions of source code must retain the above
   ///  *   copyright notice, this list of conditions and the
   ///  *   following disclaimer.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ///  *
   ///  * - Redistributions in binary form must reproduce the above
   ///  *   copyright notice, this list of conditions and the
   ///  *   following disclaimer in the documentation and/or other
   ///  *   materials provided with the distribution.
   ///  *
   ///  * - Neither the name of Internet Society, IETF or IETF
   ///  *   Trust, nor the names of specific contributors, may be
   ///  *   used to endorse or promote products derived from this
   ///  *   software without specific prior written permission.
   ///  *
   ///  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
   ///  *   AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED
   ///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   ///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
   ///  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
   ///  *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   ///  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   ///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   ///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   ///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   ///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   ///  *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   ///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
   ///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   ///  *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   ///  *
   ///  * This code was derived from RFC 8435.
   ///  * Please reproduce this note if possible.
   ///  */
   ///
   /// /*
   ///  * flex_files_prot.x
   ///  */
   ///
   /// /*
   ///  * The following include statements are for example only.
   ///  * The actual XDR definition files are generated separately
   ///  * and independently and are likely to have a different name.
   ///  * %#include &lt;nfsv42.x&gt;
   ///  * %#include &lt;rpc_prot.x&gt;
   ///  */
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Device Addressing and Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.デバイスアドレッシングとディスカバリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data operations to a storage device require the client to know the network address of the storage device. The NFSv4.1+ GETDEVICEINFO operation (Section 18.40 of [RFC5661]) is used by the client to retrieve that information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスへのデータ操作は、ストレージ・デバイスのネットワークアドレスを知っているクライアントが必要です。 NFSv4.1 + GETDEVICEINFO操作（[RFC5661]のセクション18.40）は、その情報を取得するためにクライアントによって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. ff_device_addr4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.  ff_device_addr4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ff_device_addr4 data structure is returned by the server as the layout-type-specific opaque field da_addr_body in the device_addr4 structure by a successful GETDEVICEINFO operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ff_device_addr4データ構造は成功GETDEVICEINFO操作によってdevice_addr4構造におけるレイアウトタイプ固有の不透明なフィールドda_addr_bodyとしてサーバによって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_device_versions4 {
   ///         uint32_t        ffdv_version;
   ///         uint32_t        ffdv_minorversion;
   ///         uint32_t        ffdv_rsize;
   ///         uint32_t        ffdv_wsize;
   ///         bool            ffdv_tightly_coupled;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_device_addr4 {
   ///         multipath_list4     ffda_netaddrs;
   ///         ff_device_versions4 ffda_versions&lt;&gt;;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ffda_netaddrs field is used to locate the storage device. It MUST be set by the server to a list holding one or more of the device network addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffda_netaddrsフィールドは記憶装置の位置を特定するために使用されます。これは、デバイスのネットワークアドレスの一つ以上を保持しているリストにサーバによって設定されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ffda_versions array allows the metadata server to present choices as to NFS version, minor version, and coupling strength to the client. The ffdv_version and ffdv_minorversion represent the NFS protocol to be used to access the storage device. This layout specification defines the semantics for ffdv_versions 3 and 4. If ffdv_version equals 3, then the server MUST set ffdv_minorversion to 0 and ffdv_tightly_coupled to false. The client MUST then access the storage device using the NFSv3 protocol [RFC1813]. If ffdv_version equals 4, then the server MUST set ffdv_minorversion to one of the NFSv4 minor version numbers, and the client MUST access the storage device using NFSv4 with the specified minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffda_versions配列は、メタデータサーバがクライアントにNFSバージョンのような選択肢、マイナーバージョン、および結合強度を提示することができます。 ffdv_versionとffdv_minorversionは、ストレージデバイスにアクセスするために使用されるNFSプロトコルを表します。このレイアウト仕様はffdv_versions 3と4 ffdv_versionが3に等しい場合、サーバーが0にffdv_minorversionを設定し、falseにffdv_tightly_coupledしなければならないためのセマンティクスを定義します。次に、クライアントはNFSv3のプロトコル[RFC1813]を使用してストレージデバイスにアクセスしなければなりません。 ffdv_versionが4に等しい場合、サーバはNFSv4のマイナーバージョン番号の1つにffdv_minorversionを設定しなければなりませんし、クライアントは指定されたマイナーバージョンでのNFSv4を使用してストレージデバイスにアクセスする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that while the client might determine that it cannot use any of the configured combinations of ffdv_version, ffdv_minorversion, and ffdv_tightly_coupled, when it gets the device list from the metadata server, there is no way to indicate to the metadata server as to which device it is version incompatible. However, if the client waits until it retrieves the layout from the metadata server, it can at that time clearly identify the storage device in question (see Section 5.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、それがffdv_versionの構成された組み合わせのいずれかを使用できないことを判断するかもしれないがあることに注意してください、ffdv_minorversion、およびffdv_tightly_coupled、それがメタデータサーバからデバイスのリストを取得するときに、どのデバイスにそれをするなどのメタデータ・サーバに指示する方法はありませんバージョン互換性がありません。それは、メタデータサーバからレイアウトを取得するまで、クライアントが待機している場合しかし、それはその時点で明らかに問題のストレージデバイスを識別することができます（5.4節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ffdv_rsize and ffdv_wsize are used to communicate the maximum rsize and wsize supported by the storage device. As the storage device can have a different rsize or wsize than the metadata server, the ffdv_rsize and ffdv_wsize allow the metadata server to communicate that information on behalf of the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffdv_rsizeとffdv_wsizeは、記憶装置がサポートする最大rsizeやwsizeの値を通信するために使用されます。記憶装置は、メタデータサーバ、ffdv_rsize異なるRSIZE又はwsizeの値を有し、ffdv_wsizeことができるように、メタデータサーバは、記憶装置に代わって、その情報を通信することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffdv_tightly_coupled informs the client as to whether or not the metadata server is tightly coupled with the storage devices. Note that even if the data protocol is at least NFSv4.1, it may still be the case that there is loose coupling in effect. If ffdv_tightly_coupled is not set, then the client MUST commit writes to the storage devices for the file before sending a LAYOUTCOMMIT to the metadata server. That is, the writes MUST be committed by the client to stable storage via issuing WRITEs with stable_how == FILE_SYNC or by issuing a COMMIT after WRITEs with stable_how != FILE_SYNC (see Section 3.3.7 of [RFC1813]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffdv_tightly_coupledは、メタデータサーバがしっかりとストレージ・デバイスに結合されているか否かをクライアントに通知します。データプロトコルは、少なくともNFSv4.1であっても、まだ有効で疎結合がある場合であってもよいことに留意されたいです。 ffdv_tightly_coupledが設定されていない場合、クライアントは、メタデータサーバにLAYOUTCOMMITを送信する前に、ファイルのためのストレージ・デバイスへの書き込みをコミットする必要があります。これは== stable_howと書き込みを発行経由で書き込みが安定したストレージにクライアントによってコミットされる必要があり、FILE_SYNCですかstable_howとのWRITE後にCOMMITを発行することによって！= FILE_SYNCは（[RFC1813]のセクション3.3.7を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Storage Device Multipathing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. ストレージデバイスのマルチパス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flexible file layout type supports multipathing to multiple storage device addresses. Storage-device-level multipathing is used for bandwidth scaling via trunking and for higher availability of use in the event of a storage device failure. Multipathing allows the client to switch to another storage device address that may be that of another storage device that is exporting the same data stripe unit, without having to contact the metadata server for a new layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
柔軟なファイルレイアウトの種類は、複数のストレージデバイスのアドレスにマルチパスをサポートしています。ストレージデバイスレベルのマルチパスは、トランクを介して帯域幅のスケーリングのための記憶装置が故障した場合における使用のより高い可用性のために使用されます。マルチパスは、クライアントが新しいレイアウトのメタデータサーバに連絡することなく、同じデータ・ストライプ・ユニットをエクスポートしている他の記憶装置とすることができる他の記憶装置のアドレスに切り替えることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support storage device multipathing, ffda_netaddrs contains an array of one or more storage device network addresses. This array (data type multipath_list4) represents a list of storage devices (each identified by a network address), with the possibility that some storage device will appear in the list multiple times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスのマルチパスをサポートするために、ffda_netaddrsは、1つまたは複数の記憶デバイスのネットワークアドレスのアレイを含んでいます。この配列（データ型multipath_list4）は、いくつかの記憶装置がリストに複数回現れる可能性のあるストレージデバイスのリスト（各ネットワークアドレスによって識別される）を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client is free to use any of the network addresses as a destination to send storage device requests. If some network addresses are less desirable paths to the data than others, then the metadata server SHOULD NOT include those network addresses in ffda_netaddrs. If less desirable network addresses exist to provide failover, the RECOMMENDED method to offer the addresses is to provide them in a replacement device-ID-to-device-address mapping or a replacement device ID. When a client finds no response from the storage device using all addresses available in ffda_netaddrs, it SHOULD send a GETDEVICEINFO to attempt to replace the existing device-ID-to-device-address mappings. If the metadata server detects that all network paths represented by ffda_netaddrs are unavailable, the metadata server SHOULD send a CB_NOTIFY_DEVICEID (if the client has indicated it wants device ID notifications for changed device IDs) to change the device-ID-to-device-address mappings to the available addresses. If the device ID itself will be replaced, the metadata server SHOULD recall all layouts with the device ID and thus force the client to get new layouts and device ID mappings via LAYOUTGET and GETDEVICEINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ストレージデバイスの要求を送信する宛先としてネットワークアドレスのいずれかを使用して自由です。いくつかのネットワークアドレスが他よりもデータにより望ましくない経路である場合には、メタデータサーバはffda_netaddrsでそれらのネットワークアドレスを含めるべきではありません。あまり望ましくないネットワークアドレスフェールオーバーを提供するために存在する場合、アドレスを提供するために推奨される方法は、交換用のデバイスIDとデバイスアドレスマッピングまたは交換装置IDでそれらを提供することです。クライアントはffda_netaddrsで利用可能なすべてのアドレスを使用してストレージデバイスからの応答が見つからない場合は、既存のデバイスIDとデバイスアドレスのマッピングを交換しようとするGETDEVICEINFOを送るべきです。メタデータサーバはffda_netaddrsに代表される、すべてのネットワーク・パスが使用できないことが検出された場合、メタデータサーバは、デバイスIDとデバイス・アドレスを変更する（クライアントが変更されたデバイスIDのデバイスIDの通知を望んで示した場合）CB_NOTIFY_DEVICEIDを送るべき利用可能なアドレスへのマッピング。デバイスID自体を交換する場合は、メタデータサーバは、デバイスIDを持つすべてのレイアウトを思い出すので、LAYOUTGETとGETDEVICEINFOを経由して新しいレイアウトとデバイスIDのマッピングを取得するようにクライアントを強制すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generally, if two network addresses appear in ffda_netaddrs, they will designate the same storage device. When the storage device is accessed over NFSv4.1 or a higher minor version, the two storage device addresses will support the implementation of client ID or session trunking (the latter is RECOMMENDED) as defined in [RFC5661]. The two storage device addresses will share the same server owner or major ID of the server owner. It is not always necessary for the two storage device addresses to designate the same storage device with trunking being used. For example, the data could be read-only, and the data consist of exact replicas.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのネットワークアドレスがffda_netaddrsに表示された場合、一般的に、彼らは同じストレージデバイスを指定します。記憶装置はNFSv4.1以上マイナーバージョンを介してアクセスされる場合、2つの記憶装置アドレスは[RFC5661]で定義されるように（後者が推奨される）は、クライアントIDまたはセッション・トランキングの実装を支援します。 2つのストレージデバイスのアドレスは、同じサーバーの所有者またはサーバーの所有者の主要なIDを共有します。二つの記憶装置のアドレスが使用されているトランキングと同一の記憶装置を指定することは必ずしも必要ではありません。例えば、データは、読み取り専用ことができ、データは、正確な複製から成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Flexible File Layout Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.柔軟なファイルレイアウトタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The original layouttype4 introduced in [RFC5662] is modified to be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5662]で導入され、元のlayouttype4になるように修正されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum layouttype4 {
           LAYOUT4_NFSV4_1_FILES   = 1,
           LAYOUT4_OSD2_OBJECTS    = 2,
           LAYOUT4_BLOCK_VOLUME    = 3,
           LAYOUT4_FLEX_FILES      = 4
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct layout_content4 {
           layouttype4             loc_type;
           opaque                  loc_body&lt;&gt;;
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct layout4 {
           offset4                 lo_offset;
           length4                 lo_length;
           layoutiomode4           lo_iomode;
           layout_content4         lo_content;
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines structures associated with the layouttype4 value LAYOUT4_FLEX_FILES. [RFC5661] specifies the loc_body structure as an XDR type &#34;opaque&#34;. The opaque layout is uninterpreted by the generic pNFS client layers but is interpreted by the flexible file layout type implementation. This section defines the structure of this otherwise opaque value, ff_layout4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、layouttype4値LAYOUT4_FLEX_FILESに関連付けられている構造を定義します。 [RFC5661]は「不透明」XDRタイプとしてloc_body構造を指定します。不透明なレイアウトは、汎用のpNFSクライアント層に解釈されることなくされているが、柔軟なファイルレイアウトタイプの実装によって解釈されます。このセクションでは、そうでなければ不透明値、ff_layout4の構造を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. ff_layout4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.  ff_layout4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// const FF_FLAGS_NO_LAYOUTCOMMIT   = 0x00000001;
   /// const FF_FLAGS_NO_IO_THRU_MDS    = 0x00000002;
   /// const FF_FLAGS_NO_READ_IO        = 0x00000004;
   /// const FF_FLAGS_WRITE_ONE_MIRROR  = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/// typedef uint32_t ff_flags4; ///
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
///のtypedefのuint32_t ff_flags4。 ///
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_data_server4 {
   ///     deviceid4               ffds_deviceid;
   ///     uint32_t                ffds_efficiency;
   ///     stateid4                ffds_stateid;
   ///     nfs_fh4                 ffds_fh_vers&lt;&gt;;
   ///     fattr4_owner            ffds_user;
   ///     fattr4_owner_group      ffds_group;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_mirror4 {
   ///     ff_data_server4         ffm_data_servers&lt;&gt;;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_layout4 {
   ///     length4                 ffl_stripe_unit;
   ///     ff_mirror4              ffl_mirrors&lt;&gt;;
   ///     ff_flags4               ffl_flags;
   ///     uint32_t                ffl_stats_collect_hint;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/// }; ///
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
／／／ ｝； ／／／
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ff_layout4 structure specifies a layout in that portion of the data file described in the current layout segment. It is either a single instance or a set of mirrored copies of that portion of the data file. When mirroring is in effect, it protects against loss of data in layout segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ff_layout4構造は、現在のレイアウトのセグメントに記載されたデータファイルのその部分のレイアウトを指定します。これは、単一のインスタンスまたはデータファイルのその部分のミラーリングされたコピーのセットのいずれかです。ミラーリングが有効である場合には、レイアウト・セグメント内のデータの損失を防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While not explicitly shown in the above XDR, each layout4 element returned in the logr_layout array of LAYOUTGET4res (see Section 18.43.2 of [RFC5661]) describes a layout segment. Hence, each ff_layout4 also describes a layout segment. It is possible that the file is concatenated from more than one layout segment. Each layout segment MAY represent different striping parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明示上記XDRには示されていないが、各layout4要素（[RFC5661]のセクション18.43.2を参照）LAYOUTGET4resのlogr_layout配列に返さレイアウト・セグメントを記述する。したがって、各ff_layout4はまた、レイアウト・セグメントを記述する。ファイルが複数のレイアウト・セグメントから連結されることが可能です。各レイアウトのセグメントは、異なるストライピングパラメータを表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ffl_stripe_unit field is the stripe unit size in use for the current layout segment. The number of stripes is given inside each mirror by the number of elements in ffm_data_servers. If the number of stripes is one, then the value for ffl_stripe_unit MUST default to zero. The only supported mapping scheme is sparse and is detailed in Section 6. Note that there is an assumption here that both the stripe unit size and the number of stripes are the same across all mirrors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffl_stripe_unitフィールドは、現在のレイアウトのセグメントの使用におけるストライプユニットサイズです。ストライプの数はffm_data_servers内の要素の数で各ミラーの内部に与えられます。ストライプの数が1であれば、ffl_stripe_unitの値がゼロにデフォルト設定しなければなりません。のみサポートされているマッピング方式が希薄であると仮定がストライプユニットサイズとストライプの数の両方がすべてのミラー間で同じであることがここに存在することを第6注詳細です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ffl_mirrors field is the array of mirrored storage devices that provide the storage for the current stripe; see Figure 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffl_mirrorsフィールドは、現在のストライプのためのストレージを提供するミラーリングストレージデバイスのアレイです。図1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ffl_stats_collect_hint field provides a hint to the client on how often the server wants it to report LAYOUTSTATS for a file. The time is in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffl_stats_collect_hintフィールドは、サーバーがファイルのLAYOUTSTATSを報告することを望んでいるどのくらいの頻度でクライアントへのヒントを提供します。時間は秒単位です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      +-----------+
                      |           |
                      |           |
                      |   File    |
                      |           |
                      |           |
                      +-----+-----+
                            |
               +------------+------------+
               |                         |
          +----+-----+             +-----+----+
          | Mirror 1 |             | Mirror 2 |
          +----+-----+             +-----+----+
               |                         |
          +-----------+            +-----------+
          |+-----------+           |+-----------+
          ||+-----------+          ||+-----------+
          +||  Storage  |          +||  Storage  |
           +|  Devices  |           +|  Devices  |
            +-----------+            +-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
Figure 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
図1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ffs_mirrors field represents an array of state information for each mirrored copy of the current layout segment. Each element is described by a ff_mirror4 type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffs_mirrorsフィールドは、現在のレイアウトのセグメントの各ミラーコピーの状態情報の配列を表します。各要素はff_mirror4タイプによって記述されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffds_deviceid provides the deviceid of the storage device holding the data file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffds_deviceidは、データファイルを保持するストレージデバイスのデバイスIDを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffds_fh_vers is an array of filehandles of the data file matching the available NFS versions on the given storage device. There MUST be exactly as many elements in ffds_fh_vers as there are in ffda_versions. Each element of the array corresponds to a particular combination of ffdv_version, ffdv_minorversion, and ffdv_tightly_coupled provided for the device. The array allows for server implementations that have different filehandles for different combinations of version, minor version, and coupling strength. See Section 5.4 for how to handle versioning issues between the client and storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffds_fh_versは、与えられたストレージデバイス上で利用可能なNFSバージョンと一致するデータファイルのファイルハンドルの配列です。 ffda_versionsにあるようffds_fh_versで正確に同じ数の要素があるに違いありません。配列の各要素はffdv_version、ffdv_minorversionの特定の組み合わせに対応し、デバイスのために提供さffdv_tightly_coupled。アレイは、バージョンの異なる組み合わせ、マイナーバージョン、及び結合強度のための異なるファイルハンドルを有するサーバーの実装を可能にします。クライアントとストレージデバイス間のバージョン管理の問題を処理する方法については、セクション5.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For tight coupling, ffds_stateid provides the stateid to be used by the client to access the file. For loose coupling and an NFSv4 storage device, the client will have to use an anonymous stateid to perform I/O on the storage device. With no control protocol, the metadata server stateid cannot be used to provide a global stateid model. Thus, the server MUST set the ffds_stateid to be the anonymous stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密結合のために、ffds_stateidは、ファイルにアクセスするためにクライアントが使用するのstateidを提供します。疎結合とNFSv4のストレージデバイスのために、クライアントは、ストレージ・デバイス上のI / Oを実行するために、匿名のstateidを使用する必要があります。無制御プロトコルでは、メタデータサーバのstateidは、グローバルたstateidモデルを提供するために使用することはできません。このように、サーバは匿名のstateidするffds_stateidを設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification of the ffds_stateid restricts both models for NFSv4.x storage protocols:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffds_stateidのこの仕様はNFSv4.xストレージプロトコルのための両方のモデルを制限します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loosely coupled model: the stateid has to be an anonymous stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疎結合モデル：のstateidは匿名のstateidなければなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tightly coupled model: the stateid has to be a global stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密結合モデル：のstateidは、グローバルなstateidなければなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of issues stem from a mismatch between the fact that ffds_stateid is defined as a single item while ffds_fh_vers is defined as an array. It is possible for each open file on the storage device to require its own open stateid. Because there are established loosely coupled implementations of the version of the protocol described in this document, such potential issues have not been addressed here. It is possible for future layout types to be defined that address these issues, should it become important to provide multiple stateids for the same underlying file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの問題はffds_fh_versが配列として定義されている間ffds_stateidが単一のアイテムとして定義されているという事実との間のミスマッチから生じます。ストレージ・デバイス上の各オープンファイルは、独自のオープンなstateidを必要とすることが可能です。この文書に記載されているプロトコルのバージョンの疎結合の実装が確立されているので、そのような潜在的な問題は、ここで扱われていません。これは、これらの問題を解決するに定義される将来のレイアウトタイプのために可能であり、それは同じ基本的なファイルのために複数のstateidsを提供することが重要になるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For loosely coupled storage devices, ffds_user and ffds_group provide the synthetic user and group to be used in the RPC credentials that the client presents to the storage device to access the data files. For tightly coupled storage devices, the user and group on the storage device will be the same as on the metadata server; that is, if ffdv_tightly_coupled (see Section 4.1) is set, then the client MUST ignore both ffds_user and ffds_group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疎結合ストレージ・デバイスの場合、ffds_userとffds_groupは、クライアントがデータファイルにアクセスするストレージデバイスに提示するRPCの資格情報で使用される合成ユーザとグループを提供しています。密結合された記憶装置のために、ストレージデバイス上のユーザおよびグループは、メタデータサーバ上と同じになります。 ffdv_tightly_coupled場合には設定されている場合、クライアントはffds_userとffds_groupの両方を無視しなければなりません（セクション4.1を参照）、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The allowed values for both ffds_user and ffds_group are specified as owner and owner_group, respectively, in Section 5.9 of [RFC5661]. For NFSv3 compatibility, user and group strings that consist of decimal numeric values with no leading zeros can be given a special interpretation by clients and servers that choose to provide such support. The receiver may treat such a user or group string as representing the same user as would be represented by an NFSv3 uid or gid having the corresponding numeric value. Note that if using Kerberos for security, the expectation is that these values will be a name@domain string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffds_userとffds_group両方の許容値は、[RFC5661]のセクション5.9に、それぞれ、所有者及びowner_groupとして指定されています。 NFSv3の互換性のため、無先行ゼロの10進数値で構成され、ユーザーとグループの文字列は、このようなサポートを提供することを選択したクライアントとサーバで特別な解釈を与えることができます。受信機は、NFSv3のUIDのまたは対応する数値を有するGIDによって表されるであろうと同じユーザを表すようなユーザまたはグループ列を扱うことができます。セキュリティのためにKerberosを使用した場合、期待はこれらの値は名前@ドメイン文字列になることであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffds_efficiency describes the metadata server&#39;s evaluation as to the effectiveness of each mirror. Note that this is per layout and not per device as the metric may change due to perceived load, availability to the metadata server, etc. Higher values denote higher perceived utility. The way the client can select the best mirror to access is discussed in Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffds_efficiencyは、各ミラーの有効性などのメタデータ・サーバの評価について述べます。メトリックは、より高い値がより高い知覚有用性を示す等、メタデータサーバ、に知覚される負荷、利用可能に変更されることがあり、これはデバイスごとにレイアウトごとではないことに留意されたいです。クライアントがアクセスに最もミラーを選択することができる方法は8.1節で議論されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffl_flags is a bitmap that allows the metadata server to inform the client of particular conditions that may result from more or less tight coupling of the storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffl_flagsは、メタデータサーバはストレージデバイスの多かれ少なかれ密結合に起因する特定の条件をクライアントに通知することを可能にするビットマップです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FF_FLAGS_NO_LAYOUTCOMMIT: can be set to indicate that the client is not required to send LAYOUTCOMMIT to the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FF_FLAGS_NO_LAYOUTCOMMIT：クライアントは、メタデータサーバにLAYOUTCOMMITを送信するために必要とされていないことを示すように設定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FF_FLAGS_NO_IO_THRU_MDS: can be set to indicate that the client should not send I/O operations to the metadata server. That is, even if the client could determine that there was a network disconnect to a storage device, the client should not try to proxy the I/O through the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FF_FLAGS_NO_IO_THRU_MDS：クライアントは、メタデータサーバへのI / O操作を送るべきではないことを示すように設定することができます。これは、クライアントがストレージデバイスへのネットワークの切断があったと判断できた場合でも、クライアントはメタデータサーバを介してプロキシへのI / Oを試みるべきではありません、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FF_FLAGS_NO_READ_IO: can be set to indicate that the client should not send READ requests with the layouts of iomode LAYOUTIOMODE4_RW. Instead, it should request a layout of iomode LAYOUTIOMODE4_READ from the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FF_FLAGS_NO_READ_IO：クライアントがIOModeにLAYOUTIOMODE4_RWのレイアウトとREAD要求を送信してはならないことを示すように設定することができます。その代わりに、メタデータサーバからIOModeにLAYOUTIOMODE4_READのレイアウトを要求しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FF_FLAGS_WRITE_ONE_MIRROR: can be set to indicate that the client only needs to update one of the mirrors (see Section 8.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FF_FLAGS_WRITE_ONE_MIRROR：クライアントのみ（8.2節を参照してください）ミラーの一つを更新する必要があることを示すように設定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. Error Codes from LAYOUTGET
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1.  LAYOUTGETからのエラーコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] provides little guidance as to how the client is to proceed with a LAYOUTGET that returns an error of either NFS4ERR_LAYOUTTRYLATER, NFS4ERR_LAYOUTUNAVAILABLE, and NFS4ERR_DELAY. Within the context of this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661]は、クライアントがNFS4ERR_LAYOUTTRYLATER、NFS4ERR_LAYOUTUNAVAILABLE、およびNFS4ERR_DELAYのいずれかのエラーを返しますLAYOUTGETを進めることである方法についての少しのガイダンスを提供します。この文書の文脈の中で：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LAYOUTUNAVAILABLE: there is no layout available and the I/O is to go to the metadata server. Note that it is possible to have had a layout before a recall and not after.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LAYOUTUNAVAILABLE：そこにはレイアウトが利用できないとI / Oは、メタデータサーバに移動することです。リコール前ではなく後のレイアウトを持っていたことが可能であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LAYOUTTRYLATER: there is some issue preventing the layout from being granted. If the client already has an appropriate layout, it should continue with I/O to the storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LAYOUTTRYLATER：付与されることから、レイアウトを阻止するいくつかの問題があります。クライアントがすでに適切なレイアウトを持っている場合、それは、ストレージデバイスへのI / Oを継続する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DELAY: there is some issue preventing the layout from being granted. If the client already has an appropriate layout, it should not continue with I/O to the storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DELAY：付与されることから、レイアウトを阻止するいくつかの問題があります。クライアントがすでに適切なレイアウトを持っている場合、それは、ストレージデバイスへのI / Oを続けるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. Client Interactions with FF_FLAGS_NO_IO_THRU_MDS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2.  FF_FLAGS_NO_IO_THRU_MDSとクライアントの相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even if the metadata server provides the FF_FLAGS_NO_IO_THRU_MDS flag, the client can still perform I/O to the metadata server. The flag functions as a hint. The flag indicates to the client that the metadata server prefers to separate the metadata I/O from the data I/ O, most likely for performance reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバはFF_FLAGS_NO_IO_THRU_MDSフラグを提供している場合でも、クライアントは、メタデータサーバへのI / Oを実行することができます。ヒントとしてフラグ機能します。フラグは、メタデータサーバは、パフォーマンス上の理由から、I / Oは、最も可能性の高いデータからメタデータI / Oを分離することを好むクライアントに示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. LAYOUTCOMMIT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.  LAYOUTCOMMIT
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flexible file layout does not use lou_body inside the loca_layoutupdate argument to LAYOUTCOMMIT. If lou_type is LAYOUT4_FLEX_FILES, the lou_body field MUST have a zero length (see Section 18.42.1 of [RFC5661]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
柔軟なファイルのレイアウトはLAYOUTCOMMITにloca_layoutupdate引数内lou_body使用していません。 lou_typeがLAYOUT4_FLEX_FILESである場合、lou_bodyフィールドは、（[RFC5661]のセクション18.42.1を参照）はゼロ長さでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Interactions between Devices and Layouts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. デバイスとレイアウト間の相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In [RFC5661], the file layout type is defined such that the relationship between multipathing and filehandles can result in either 0, 1, or N filehandles (see Section 13.3). Some rationales for this are clustered servers that share the same filehandle or allow for multiple read-only copies of the file on the same storage device. In the flexible file layout type, while there is an array of filehandles, they are independent of the multipathing being used. If the metadata server wants to provide multiple read-only copies of the same file on the same storage device, then it should provide multiple mirrored instances, each with a different ff_device_addr4. The client can then determine that, since the each of the ffds_fh_vers are different, there are multiple copies of the file for the current layout segment available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661]に、ファイルのレイアウトタイプは、マルチパスとファイルハンドルとの間の関係は、0、1、又はNのファイルハンドル（13.3節を参照）のいずれかをもたらすことができるように定義されています。このためのいくつかの理論的根拠は、同じファイルハンドルを共有したり、同じストレージデバイス上のファイルの複数の読み取り専用のコピーを可能にサーバをクラスタ化されています。ファイルハンドルの配列があるが柔軟なファイルレイアウトタイプでは、それらは、使用されているマルチパスとは無関係です。メタデータサーバが同じストレージデバイス上の同じファイルの複数の読み取り専用のコピーを提供したい場合、それは、複数のインスタンスをミラーリング異なるff_device_addr4とそれぞれを提供しなければなりません。次に、クライアントはffds_fh_versザ各々が異なるため、利用可能な現在のレイアウトのセグメントのファイルの複数のコピーが存在する、と判断することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Handling Version Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. バージョンエラーの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the metadata server provides the ffda_versions array in the ff_device_addr4 (see Section 4.1), the client is able to determine whether or not it can access a storage device with any of the supplied combinations of ffdv_version, ffdv_minorversion, and ffdv_tightly_coupled. However, due to the limitations of reporting errors in GETDEVICEINFO (see Section 18.40 in [RFC5661]), the client is not able to specify which specific device it cannot communicate with over one of the provided ffdv_version and ffdv_minorversion combinations. Using ff_ioerr4 (see Section 9.1.1) inside either the LAYOUTRETURN (see Section 18.44 of [RFC5661]) or the LAYOUTERROR (see Section 15.6 of [RFC7862] and Section 10 of this document), the client can isolate the problematic storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバはff_device_addr4（セクション4.1を参照）ffda_versionsアレイを提供する場合、クライアントはffdv_version、ffdv_minorversion、及びffdv_tightly_coupledの供給組み合わせのいずれかのストレージデバイスにアクセスできるかどうかを決定することができます。しかしながら、（[RFC5661]セクション18.40を参照）GETDEVICEINFOのエラーを報告の制限のために、クライアントは、それが提供ffdv_versionとffdv_minorversion組み合わせの1つの上で通信することができない特定のデバイスを指定することができません。 LAYOUTRETURN（[RFC5661]のセクション18.44を参照）またはLAYOUTERRORいずれかの内部ff_ioerr4（セクション9.1.1を参照）（[RFC7862]のセクション15.6およびこのドキュメントのセクション10を参照）を使用して、クライアントは、問題のストレージデバイスを単離することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The error code to return for LAYOUTRETURN and/or LAYOUTERROR is NFS4ERR_MINOR_VERS_MISMATCH. It does not matter whether the mismatch is a major version (e.g., client can use NFSv3 but not NFSv4) or minor version (e.g., client can use NFSv4.1 but not NFSv4.2), the error indicates that for all the supplied combinations for ffdv_version and ffdv_minorversion, the client cannot communicate with the storage device. The client can retry the GETDEVICEINFO to see if the metadata server can provide a different combination, or it can fall back to doing the I/O through the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTRETURNおよび/またはLAYOUTERRORのために返すようにエラーコードがNFS4ERR_MINOR_VERS_MISMATCHです。それは、ミスマッチがメジャーバージョンであるかどうかは関係ありませんか、マイナーバージョン（例えば、クライアントがNFSv4.1ではなく、NFSv4.2を使用することができます）（例えば、クライアントがNFSv3のではなく、NFSv4のを使用することができます）、エラーを示している全ての供給組み合わせについてffdv_versionとffdv_minorversionのために、クライアントは、ストレージ・デバイスと通信することはできません。クライアントは、メタデータサーバが異なる組み合わせを提供できるかどうかを確認するためにGETDEVICEINFOを再試行することができ、またはそれは、メタデータサーバを介してI / Oを行うことにフォールバックすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Striping via Sparse Mapping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
スパースマッピング経由6.ストライピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While other layout types support both dense and sparse mapping of logical offsets to physical offsets within a file (see, for example, Section 13.4 of [RFC5661]), the flexible file layout type only supports a sparse mapping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のレイアウトタイプは、ファイル内の物理オフセットに論理オフセットの両方稠密と疎なマッピングをサポートする（例えば、[RFC5661]のセクション13.4を参照）しながら、柔軟なファイルレイアウトタイプは、疎なマッピングをサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With sparse mappings, the logical offset within a file (L) is also the physical offset on the storage device. As detailed in Section 13.4.4 of [RFC5661], this results in holes across each storage device that does not contain the current stripe index.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疎なマッピングと、ファイル（L）内のオフセットの論理は、ストレージデバイス上の物理オフセットです。 [RFC5661]のセクション13.4.4に詳述するように、これは現在の縞視標が含まれていない各記憶デバイスの両端の穴になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
L: logical offset within the file
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
L：論理ファイル内のオフセット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W: stripe width W = number of elements in ffm_data_servers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W：ffm_data_serversの要素のストライプ幅W =数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S: number of bytes in a stripe S = W * ffl_stripe_unit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S：ストライプS = Wの*のffl_stripe_unitのバイト数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N: stripe number N = L / S
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N：ストライプ数N = L / S
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Recovering from Client I/O Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
クライアントI / Oエラーからの回復7.
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pNFS client may encounter errors when directly accessing the storage devices. However, it is the responsibility of the metadata server to recover from the I/O errors. When the LAYOUT4_FLEX_FILES layout type is used, the client MUST report the I/O errors to the server at LAYOUTRETURN time using the ff_ioerr4 structure (see Section 9.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
直接ストレージデバイスにアクセスする際のpNFSクライアントは、エラーが発生することがあります。しかし、I / Oエラーから回復するためのメタデータ・サーバの責任です。 LAYOUT4_FLEX_FILESのレイアウトタイプを使用する場合、クライアントは、（9.1.1項を参照）ff_ioerr4構造を使用してLAYOUTRETURN時にサーバーにI / Oエラーを報告しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server analyzes the error and determines the required recovery operations such as recovering media failures or reconstructing missing data files.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバがエラーを分析し、そのようなメディア障害の回復または欠落したデータファイルを再構築するなど、必要なリカバリ操作を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server MUST recall any outstanding layouts to allow it exclusive write access to the stripes being recovered and to prevent other clients from hitting the same error condition. In these cases, the server MUST complete recovery before handing out any new layouts to the affected byte ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバが回収されていると、同じエラー条件を打つから、他のクライアントを防ぐために、それをストライプへの排他的書き込みアクセスを許可するように、未処理のレイアウトをリコールしなければなりません。これらのケースでは、サーバーは、影響を受けたバイト範囲に新しいレイアウトを配る前に復旧を完了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the client implementation has the option to propagate a corresponding error to the application that initiated the I/O operation and drop any unwritten data, the client should attempt to retry the original I/O operation by either requesting a new layout or sending the I/O via regular NFSv4.1+ READ or WRITE operations to the metadata server. The client SHOULD attempt to retrieve a new layout and retry the I/O operation using the storage device first and only retry the I/O operation via the metadata server if the error persists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの実装では、I / O操作を開始したアプリケーションに対応するエラーを伝播し、任意の書き込まれていないデータをドロップするためのオプションがありますが、クライアントは、どちらかが新しいレイアウトを要求またはIを送信することにより、元のI / O操作を再試行しなければなりません/ O定期NFSv4.1を経て+メタデータサーバに業務を読み書き。クライアントは、新しいレイアウトを取得しようと再試行I / O操作を第一の記憶装置を使用して、エラーが解決しない場合にのみ、メタデータ・サーバを経由してI / O操作を再試行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Mirroring
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.ミラーリング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flexible file layout type has a simple model in place for the mirroring of the file data constrained by a layout segment. There is no assumption that each copy of the mirror is stored identically on the storage devices. For example, one device might employ compression or deduplication on the data. However, the over-the-wire transfer of the file contents MUST appear identical. Note, this is a constraint of the selected XDR representation in which each mirrored copy of the layout segment has the same striping pattern (see Figure 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
柔軟なファイルレイアウトタイプは、レイアウト・セグメントによって制約ファイルデータのミラーリングのための場所に単純なモデルを有しています。ミラーの各コピーは、ストレージ・デバイス上で同じように格納されていることを全く想定はありません。例えば、1つのデバイスがデータの圧縮や重複排除機能を利用するかもしれません。ただし、ファイルの内容のオーバーザワイヤ転送は、同一現れなければなりません。メモ、このレイアウト・セグメントの各ミラーコピーが（図1参照）は、同じストライプパターンを有する、選択されたXDR表現の制約です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server is responsible for determining the number of mirrored copies and the location of each mirror. While the client may provide a hint to how many copies it wants (see Section 12), the metadata server can ignore that hint; in any event, the client has no means to dictate either the storage device (which also means the coupling and/or protocol levels to access the layout segments) or the location of said storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバは、ミラーリングされたコピーの数と、各ミラーの位置を決定する責任があります。クライアントが（セクション12を参照）、それは望んでいるどのように多くのコピーにヒントを提供することができるが、メタデータサーバは、そのヒントを無視することができます。いずれにしても、クライアントは、又は前記ストレージ装置の位置（また、カップリング及び/又はプロトコルレベルレイアウト・セグメントにアクセスすることを意味する）、記憶装置のいずれかを決定する手段を持ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The updating of mirrored layout segments is done via client-side mirroring. With this approach, the client is responsible for making sure modifications are made on all copies of the layout segments it is informed of via the layout. If a layout segment is being resilvered to a storage device, that mirrored copy will not be in the layout. Thus, the metadata server MUST update that copy until the client is presented it in a layout. If the FF_FLAGS_WRITE_ONE_MIRROR is set in ffl_flags, the client need only update one of the mirrors (see Section 8.2). If the client is writing to the layout segments via the metadata server, then the metadata server MUST update all copies of the mirror. As seen in Section 8.3, during the resilvering, the layout is recalled, and the client has to make modifications via the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミラーリングされたレイアウト・セグメントの更新は、クライアント側のミラーリングを介して行われます。このアプローチでは、クライアントは、レイアウトを経由して通知されたレイアウト・セグメントのすべてのコピーに行われていることを確認修正を作るための責任があります。レイアウト・セグメントを記憶装置に再同期化されている場合、そのミラーリングされたコピーは、レイアウトになりません。クライアントは、レイアウトでそれを提示されるまでこのように、メタデータサーバは、そのコピーを更新する必要があります。 FF_FLAGS_WRITE_ONE_MIRRORがffl_flagsに設定されている場合は、クライアントのみのミラー（8.2節を参照）のいずれかをアップデートする必要が。クライアントは、メタデータ・サーバを経由してレイアウトセグメントに書き込みされている場合は、メタデータサーバは、ミラーのすべてのコピーを更新する必要があります。 8.3節で見られるように、再同期化の際に、レイアウトがリコールされ、クライアントは、メタデータサーバを経由して変更を加えることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Selecting a Mirror
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. ミラーを選択します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the metadata server grants a layout to a client, it MAY let the client know how fast it expects each mirror to be once the request arrives at the storage devices via the ffds_efficiency member. While the algorithms to calculate that value are left to the metadata server implementations, factors that could contribute to that calculation include speed of the storage device, physical memory available to the device, operating system version, current load, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバがクライアントにレイアウトを許可する場合は、クライアントは、要求がffds_efficiency部材を介してストレージ・デバイスに到着すると、各ミラーがあることを期待いかに早く知らせてもよい（MAY）。その値を計算するアルゴリズムは、メタデータサーバの実装に任されているが、その計算に寄与し得る要因は、記憶装置の速度等のデバイス、オペレーティングシステムのバージョン、現在の負荷、使用可能な物理メモリを含みます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, what should not be involved in that calculation is a perceived network distance between the client and the storage device. The client is better situated for making that determination based on past interaction with the storage device over the different available network interfaces between the two; that is, the metadata server might not know about a transient outage between the client and storage device because it has no presence on the given subnet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、どのようなその計算に関与すべきでないことは、クライアントとストレージデバイス間の知覚ネットワーク距離です。クライアントは、両者の異なる利用可能なネットワーク・インタフェースを介してストレージ装置との過去の対話に基づいてその決定を行うためのより良い位置しています。それは与えられたサブネットに存在感を持っていないので、つまり、メタデータサーバは、クライアントとストレージデバイス間の過渡的な停電を知っていない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As such, it is the client that decides which mirror to access for reading the file. The requirements for writing to mirrored layout segments are presented below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このように、それはファイルを読み取るためにアクセスするためにどのミラーを決定するクライアントです。ミラーリングされたレイアウト・セグメントに書き込むための要件は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Writing to Mirrors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. ミラーへの書き込み
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1. Single Storage Device Updates Mirrors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1. 単一ストレージデバイスのアップデートミラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the FF_FLAGS_WRITE_ONE_MIRROR flag in ffl_flags is set, the client only needs to update one of the copies of the layout segment. For this case, the storage device MUST ensure that all copies of the mirror are updated when any one of the mirrors is updated. If the storage device gets an error when updating one of the mirrors, then it MUST inform the client that the original WRITE had an error. The client then MUST inform the metadata server (see Section 8.2.3). The client&#39;s responsibility with respect to COMMIT is explained in Section 8.2.4. The client may choose any one of the mirrors and may use ffds_efficiency as described in Section 8.1 when making this choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffl_flagsでFF_FLAGS_WRITE_ONE_MIRRORフラグが設定されている場合、クライアントは、レイアウトのセグメントのコピーの1つを更新する必要があります。この場合、ストレージデバイスは、ミラーのいずれかが更新されたときに、ミラーのすべてのコピーが更新されていることを確認しなければなりません。ミラーの一つを更新する際、ストレージデバイスがエラーを取得する場合、それは、元のWRITEがエラーを持っていたことをクライアントに通知しなければなりません。その後、クライアントは、（8.2.3項を参照）メタデータサーバに通知しなければなりません。 COMMITに関しては、クライアントの責任は、8.2.4項で説明されています。クライアントは、ミラーのいずれかを選ぶことができ、この選択を行うとき、8.1節で説明したようにffds_efficiency使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2. Client Updates All Mirrors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2. クライアントは、すべてのミラーを更新します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the FF_FLAGS_WRITE_ONE_MIRROR flag in ffl_flags is not set, the client is responsible for updating all mirrored copies of the layout segments that it is given in the layout. A single failed update is sufficient to fail the entire operation. If all but one copy is updated successfully and the last one provides an error, then the client needs to inform the metadata server about the error. The client can use either LAYOUTRETURN or LAYOUTERROR to inform the metadata server that the update failed to that storage device. If the client is updating the mirrors serially, then it SHOULD stop at the first error encountered and report that to the metadata server. If the client is updating the mirrors in parallel, then it SHOULD wait until all storage devices respond so that it can report all errors encountered during the update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffl_flagsでFF_FLAGS_WRITE_ONE_MIRRORフラグが設定されていない場合、クライアントは、それがレイアウトで指定されたレイアウト・セグメントのすべてのミラーリングされたコピーを更新する責任があります。シングル失敗した更新は、全体の動作を失敗するのに十分です。すべてが、1つのコピーが正常に更新され、最後の1がエラーを提供する場合、クライアントはエラーに関するメタデータサーバに通知する必要があります。クライアントは、アップデートがそのストレージデバイスに障害が発生したメタデータサーバに通知するLAYOUTRETURNまたはLAYOUTERRORのいずれかを使用することができます。クライアントは、シリアルミラーを更新している場合は、それが発生した最初のエラーで停止し、メタデータサーバにそれを報告しなければなりません。クライアントが並列にミラーを更新している場合は、すべてのストレージデバイスが応答するまでは、更新中に発生したすべてのエラーを報告できるように、それは待つべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.3. Handling Write Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.3. 書き込みエラーの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client reports a write error to the metadata server, the metadata server is responsible for determining if it wants to remove the errant mirror from the layout, if the mirror has recovered from some transient error, etc. When the client tries to get a new layout, the metadata server informs it of the decision by the contents of the layout. The client MUST NOT assume that the contents of the previous layout will match those of the new one. If it has updates that were not committed to all mirrors, then it MUST resend those updates to all mirrors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、メタデータサーバへの書き込みエラーを報告すると、メタデータサーバ等、それはミラーは、いくつかの一時的なエラーから回復した場合、レイアウトから誤ったミラーを削除したいかどうかを判断する責任があるクライアントが取得しようとすると新しいレイアウトは、メタデータサーバは、レイアウトの内容の決定のそれを知らせます。クライアントは、以前のレイアウトの内容は新しいもののものと一致すると仮定してはいけません。それはすべてのミラーにコミットされていない最新情報を持っている場合、それはすべてのミラーにそれらの更新を再送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no provision in the protocol for the metadata server to directly determine that the client has or has not recovered from an error. For example, if a storage device was network partitioned from the client and the client reported the error to the metadata server, then the network partition would be repaired, and all of the copies would be successfully updated. There is no mechanism for the client to report that fact, and the metadata server is forced to repair the file across the mirror.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
直接クライアントが持っているか、エラーから回復していないことを決定するために、メタデータサーバのプロトコルには規定はありません。例えば、場合ストレージデバイスがクライアントから仕切られたネットワークだったとクライアントがメタデータサーバにエラーを報告し、その後、ネットワークパーティションを修復するだろう、とコピーのすべてが正常に更新されます。そこクライアントがその事実を報告するためのメカニズムがなく、メタデータサーバは、ミラー間でファイルを修復することを余儀なくされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client supports NFSv4.2, it can use LAYOUTERROR and LAYOUTRETURN to provide hints to the metadata server about the recovery efforts. A LAYOUTERROR on a file is for a non-fatal error. A subsequent LAYOUTRETURN without a ff_ioerr4 indicates that the client successfully replayed the I/O to all mirrors. Any LAYOUTRETURN with a ff_ioerr4 is an error that the metadata server needs to repair. The client MUST be prepared for the LAYOUTERROR to trigger a CB_LAYOUTRECALL if the metadata server determines it needs to start repairing the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFSv4.2をサポートしている場合は、復旧作業に関するメタデータサーバへのヒントを提供するために、LAYOUTERRORとLAYOUTRETURNを使用することができます。ファイルのLAYOUTERRORは致命的でないエラーのためです。 ff_ioerr4することなく次のLAYOUTRETURNは、クライアントが正常にすべてのミラーにI / Oを再生していることを示しています。 ff_ioerr4を持つ任意のLAYOUTRETURNは、メタデータサーバを修復する必要がありますエラーです。メタデータサーバは、それがファイルの修復を開始する必要が決定した場合、クライアントはCB_LAYOUTRECALLをトリガするLAYOUTERRORのために準備しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.4. Handling Write COMMITs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.4. 書き込みCOMMITを取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When stable writes are done to the metadata server or to a single replica (if allowed by the use of FF_FLAGS_WRITE_ONE_MIRROR), it is the responsibility of the receiving node to propagate the written data stably, before replying to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定した書き込みがメタデータサーバーまたは単一のレプリカ（FF_FLAGS_WRITE_ONE_MIRRORの使用によって許可されている場合）に行われた場合、それはクライアントに応答する前に、安定的に書き込まれたデータを伝播する受信ノードの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the corresponding cases in which unstable writes are done, the receiving node does not have any such obligation, although it may choose to asynchronously propagate the updates. However, once a COMMIT is replied to, all replicas must reflect the writes that have been done, and this data must have been committed to stable storage on all replicas.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは非同期に更新を伝播することを選択するかもしれないが、不安定な書き込みが行われている対応するケースでは、受信ノードは、そのような義務はありません。しかし、一度、すべてのレプリカが行われている書き込みを反映しなければならないために応答するCOMMIT、そしてこのデータは、すべてのレプリカで安定したストレージにコミットされている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid situations in which stale data is read from replicas to which writes have not been propagated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
古いデータを書き込むにレプリカから読み出される事態を避けるために伝播されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A client that has outstanding unstable writes made to single node (metadata server or storage device) MUST do all reads from that same node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oすべてを行う必要があります単一ノード（メタデータ・サーバやストレージ・デバイス）に作られた優れた不安定な書き込みを持つクライアントは、同じノードから読み込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When writes are flushed to the server (for example, to implement close-to-open semantics), a COMMIT must be done by the client to ensure that up-to-date written data will be available irrespective of the particular replica read.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込みがサーバーにフラッシュされた場合、O COMMIT最新書き込まれたデータは関係なく、読み特定のレプリカの利用可能になることを保証するために、クライアントによって行われなければならない、（例えば、クローズ・ツー・オープンのセマンティクスを実装します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Metadata Server Resilvering of the File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. ファイルのメタデータサーバーのリシルバリング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server may elect to create a new mirror of the layout segments at any time. This might be to resilver a copy on a storage device that was down for servicing, to provide a copy of the layout segments on storage with different storage performance characteristics, etc. As the client will not be aware of the new mirror and the metadata server will not be aware of updates that the client is making to the layout segments, the metadata server MUST recall the writable layout segment(s) that it is resilvering. If the client issues a LAYOUTGET for a writable layout segment that is in the process of being resilvered, then the metadata server can deny that request with an NFS4ERR_LAYOUTUNAVAILABLE. The client would then have to perform the I/O through the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバは、いつでもレイアウトセグメントの新しいミラーを作成することを選択してもよいです。クライアントが新しいミラーとメタデータ・サーバを認識しません、これはなど、さまざまなストレージのパフォーマンス特性を持つストレージ上のレイアウト・セグメントのコピーを提供するために、保守のためにダウンしたストレージデバイス上のコピーを再同期化するかもしれませんクライアントは、レイアウトのセグメントになっているアップデートを認識しません、メタデータサーバは、それがミラー復元されていることを書き込み可能なレイアウトセグメント（複数可）をリコールしなければなりません。クライアントが再同期化中である書き込み可能なレイアウトセグメントのLAYOUTGETを発行した場合、メタデータサーバはNFS4ERR_LAYOUTUNAVAILABLEでその要求を拒否することができます。次に、クライアントは、メタデータサーバを介してI / Oを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Flexible File Layout Type Return
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.柔軟なファイルレイアウトタイプに戻ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layoutreturn_file4 is used in the LAYOUTRETURN operation to convey layout-type-specific information to the server. It is defined in Section 18.44.1 of [RFC5661] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layoutreturn_file4は、サーバへのレイアウト・タイプ固有の情報を伝えるためLAYOUTRETURN操作で使用されています。それは次のように[RFC5661]のセクション18.44.1に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Constants used for LAYOUTRETURN and CB_LAYOUTRECALL */
      const LAYOUT4_RET_REC_FILE      = 1;
      const LAYOUT4_RET_REC_FSID      = 2;
      const LAYOUT4_RET_REC_ALL       = 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
enum layoutreturn_type4 { LAYOUTRETURN4_FILE = LAYOUT4_RET_REC_FILE, LAYOUTRETURN4_FSID = LAYOUT4_RET_REC_FSID, LAYOUTRETURN4_ALL = LAYOUT4_RET_REC_ALL };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
列挙layoutreturn_type4 {LAYOUTRETURN4_FILE = LAYOUT4_RET_REC_FILE、LAYOUTRETURN4_FSID = LAYOUT4_RET_REC_FSID、LAYOUTRETURN4_ALL = LAYOUT4_RET_REC_ALL}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
struct layoutreturn_file4 { offset4 lrf_offset;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体layoutreturn_file4 {OFFSET4 lrf_offset。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           length4         lrf_length;
           stateid4        lrf_stateid;
           /* layouttype4 specific data */
           opaque          lrf_body&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {
           case LAYOUTRETURN4_FILE:
                   layoutreturn_file4      lr_layout;
           default:
                   void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LAYOUTRETURN4args {
           /* CURRENT_FH: file */
           bool                    lora_reclaim;
           layouttype4             lora_layout_type;
           layoutiomode4           lora_iomode;
           layoutreturn4           lora_layoutreturn;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the lora_layout_type layout type is LAYOUT4_FLEX_FILES and the lr_returntype is LAYOUTRETURN4_FILE, then the lrf_body opaque value is defined by ff_layoutreturn4 (see Section 9.3). This allows the client to report I/O error information or layout usage statistics back to the metadata server as defined below. Note that while the data structures are built on concepts introduced in NFSv4.2, the effective discriminated union (lora_layout_type combined with ff_layoutreturn4) allows for an NFSv4.1 metadata server to utilize the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lora_layout_typeレイアウトタイプはLAYOUT4_FLEX_FILESとlr_returntype次いでlrf_body不透明値をff_layoutreturn4によって定義さLAYOUTRETURN4_FILE、ある場合には（セクション9.3を参照）。これは、以下に定義するクライアントは、メタデータサーバに戻ってI / Oエラー情報やレイアウトの使用状況の統計情報を報告することができます。データ構造はNFSv4.2で導入された概念に基づいて構築されている間、有効な識別連合（ff_layoutreturn4組み合わせるlora_layout_type）がデータを利用するNFSv4.1メタデータサーバーを可能にすることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. I/O Error Reporting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.  I / Oエラー報告
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1. ff_ioerr4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1.1.  ff_ioerr4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_ioerr4 {
   ///         offset4        ffie_offset;
   ///         length4        ffie_length;
   ///         stateid4       ffie_stateid;
   ///         device_error4  ffie_errors&lt;&gt;;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recall that [RFC7862] defines device_error4 as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7862]はとしてdevice_error4定義されていることを思い出してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct device_error4 {
           deviceid4       de_deviceid;
           nfsstat4        de_status;
           nfs_opnum4      de_opnum;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ff_ioerr4 structure is used to return error indications for data files that generated errors during data transfers. These are hints to the metadata server that there are problems with that file. For each error, ffie_errors.de_deviceid, ffie_offset, and ffie_length represent the storage device and byte range within the file in which the error occurred; ffie_errors represents the operation and type of error. The use of device_error4 is described in Section 15.6 of [RFC7862].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ff_ioerr4構造は、データ転送中にエラーが発生したデータファイルのエラー表示を返すために使用されます。これらは、そのファイルに問題があるメタデータサーバへのヒントです。各エラーのために、ffie_errors.de_deviceid、ffie_offset、及びffie_lengthは、記憶装置とエラーが発生したファイル内のバイト範囲を表します。 ffie_errors動作とエラーの種類を表します。 device_error4の使用は、[RFC7862]のセクション15.6に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though the storage device might be accessed via NFSv3 and reports back NFSv3 errors to the client, the client is responsible for mapping these to appropriate NFSv4 status codes as de_status. Likewise, the NFSv3 operations need to be mapped to equivalent NFSv4 operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージデバイスは、NFSv3のとレポートを介してアクセスされる可能性がありますにもかかわらず、クライアントにNFSv3のエラーをバックに、クライアントはde_statusとしてNFSv4のステータスコードを適切に、これらをマッピングする責任があります。同様に、NFSv3の操作が同等のNFSv4操作にマッピングする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Layout Usage Statistics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. レイアウト使用統計情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1. ff_io_latency4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1.  ff_io_latency4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_io_latency4 {
   ///         uint64_t       ffil_ops_requested;
   ///         uint64_t       ffil_bytes_requested;
   ///         uint64_t       ffil_ops_completed;
   ///         uint64_t       ffil_bytes_completed;
   ///         uint64_t       ffil_bytes_not_delivered;
   ///         nfstime4       ffil_total_busy_time;
   ///         nfstime4       ffil_aggregate_completion_time;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both operation counts and bytes transferred are kept in the ff_io_latency4. As seen in ff_layoutupdate4 (see Section 9.2.2), READ and WRITE operations are aggregated separately. READ operations are used for the ff_io_latency4 ffl_read. Both WRITE and COMMIT operations are used for the ff_io_latency4 ffl_write. &#34;Requested&#34; counters track what the client is attempting to do, and &#34;completed&#34; counters track what was done. There is no requirement that the client only report completed results that have matching requested results from the reported period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送の両方の操作数とバイトはff_io_latency4に保管されています。 ff_layoutupdate4（セクション9.2.2を参照）に見られるように、READおよびWRITE動作は別々に集約されます。 READ操作はff_io_latency4のffl_readのために使用されています。両方とも書き、COMMIT操作がff_io_latency4のffl_writeのために使用されています。 「要求」カウンタは、クライアントが何しようとしているものを追跡し、「完了」カウンタが行われていたものを追跡します。クライアントが唯一の報告期間から要求された結果に一致している完成した結果を報告要件はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffil_bytes_not_delivered is used to track the aggregate number of bytes requested but not fulfilled due to error conditions. ffil_total_busy_time is the aggregate time spent with outstanding RPC calls. ffil_aggregate_completion_time is the sum of all round-trip times for completed RPC calls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffil_bytes_not_deliveredは、要求されたバイトの合計数を追跡するために使用されるが、エラー条件のために満たされていません。 ffil_total_busy_timeは、優れたRPCコールで過ごした総時間です。 ffil_aggregate_completion_timeが完了RPC呼び出しのためのすべての往復時間の合計です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Section 3.3.1 of [RFC5661], the nfstime4 is defined as the number of seconds and nanoseconds since midnight or zero hour January 1, 1970 Coordinated Universal Time (UTC). The use of nfstime4 in ff_io_latency4 is to store time since the start of the first I/O from the client after receiving the layout. In other words, these are to be decoded as duration and not as a date and time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661]のセクション3.3.1において、nfstime4は、協定世界時（UTC）深夜またはゼロ時間1970年1月1日からの秒とナノ秒の数として定義されます。 ff_io_latency4でnfstime4の使用は、レイアウトを受け取った後、クライアントからの最初のI / Oを開始してからの時間を格納することです。言い換えれば、これらは期間としてではなく、日付と時刻としてデコードされることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that LAYOUTSTATS are cumulative, i.e., not reset each time the operation is sent. If two LAYOUTSTATS operations for the same file and layout stateid originate from the same NFS client and are processed at the same time by the metadata server, then the one containing the larger values contains the most recent time series data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAYOUTSTATSは累積的であることに留意されたい、すなわち、操作が送信されるたびにリセットされません。同じファイルとレイアウト用の2つのLAYOUTSTATS操作が同じNFSクライアントから発信STATEIDとメタデータ・サーバで同時に処理されている場合は、より大きな値を含む1は、最新の時系列データが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.2. ff_layoutupdate4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.2.  ff_layoutupdate4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_layoutupdate4 {
   ///         netaddr4       ffl_addr;
   ///         nfs_fh4        ffl_fhandle;
   ///         ff_io_latency4 ffl_read;
   ///         ff_io_latency4 ffl_write;
   ///         nfstime4       ffl_duration;
   ///         bool           ffl_local;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt; ffl_addr differentiates which network address the client is connected to on the storage device. In the case of multipathing, ffl_fhandle indicates which read-only copy was selected. ffl_read and ffl_write convey the latencies for both READ and WRITE operations, respectively. ffl_duration is used to indicate the time period over which the statistics were collected. If true, ffl_local indicates that the I/O was serviced by the client&#39;s cache. This flag allows the client to inform the metadata server about &#34;hot&#34; access to a file it would not normally be allowed to report on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがストレージデバイス上に接続されたネットワークアドレスffl_addr微分&lt;CODEは終了します&gt;。マルチパスの場合は、ffl_fhandleは、読み取り専用のものが選択されたコピーを示しています。 ffl_readそれぞれ、READおよびWRITE操作の両方のための待ち時間を伝えるffl_write。 ffl_durationは、統計が収集された時間帯を示すために使用されます。 trueの場合、ffl_localは、I / Oは、クライアントのキャッシュによってサービスされたことを示しています。このフラグは、クライアントが、正常に報告することを許可されませんファイルへの「ホット」のアクセスに関するメタデータ・サーバに通知することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.3. ff_iostats4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.3.  ff_iostats4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_iostats4 {
   ///         offset4           ffis_offset;
   ///         length4           ffis_length;
   ///         stateid4          ffis_stateid;
   ///         io_info4          ffis_read;
   ///         io_info4          ffis_write;
   ///         deviceid4         ffis_deviceid;
   ///         ff_layoutupdate4  ffis_layoutupdate;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7862] defines io_info4 as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7862]はio_info4のように定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct io_info4 {
           uint64_t        ii_count;
           uint64_t        ii_bytes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With pNFS, data transfers are performed directly between the pNFS client and the storage devices. Therefore, the metadata server has no direct knowledge of the I/O operations being done and thus cannot create on its own statistical information about client I/O to optimize the data storage location. ff_iostats4 MAY be used by the client to report I/O statistics back to the metadata server upon returning the layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSのと、データ転送はpNFSのクライアントとストレージデバイス間で直接行われます。したがって、メタデータサーバが行われているので、データの格納場所を最適化するためにクライアントに関する独自の統計情報I / Oで作成することができないI / O動作の直接的な知識を有していません。 ff_iostats4は、レイアウトを返す時に戻ってメタデータサーバへのI / O統計を報告するために、クライアントによって使用されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since it is not feasible for the client to report every I/O that used the layout, the client MAY identify &#34;hot&#34; byte ranges for which to report I/O statistics. The definition and/or configuration mechanism of what is considered &#34;hot&#34; and the size of the reported byte range are out of the scope of this document. For client implementation, providing reasonable default values and an optional run-time management interface to control these parameters is suggested. For example, a client can define the default byte-range resolution to be 1 MB in size and the thresholds for reporting to be 1 MB/second or 10 I/O operations per second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、クライアントがレイアウトを使用し、すべてのI / Oを報告するのは現実的ではありませんので、クライアントは、I / Oの統計情報を報告するための「ホット」バイト範囲を識別することができます。定義および/または「熱い」と考えられるものの設定メカニズムと報告されたバイト範囲の大きさは、この文書の範囲外です。クライアントの実装については、合理的なデフォルト値を提供し、これらのパラメータを制御するための任意の実行時の管理インタフェースが提案されています。例えば、クライアントは、第1 MB /又は毎秒10のI / O操作であることを報告するための1のサイズでMBとしきい値ことが既定バイトレンジ分解能を定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each byte range, ffis_offset and ffis_length represent the starting offset of the range and the range length in bytes. ffis_read.ii_count, ffis_read.ii_bytes, ffis_write.ii_count, and ffis_write.ii_bytes represent the number of contiguous READ and WRITE I/Os and the respective aggregate number of bytes transferred within the reported byte range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各バイト範囲に対して、ffis_offsetとffis_length範囲の開始オフセットおよびバイト単位の範囲の長さを表します。 ffis_read.ii_count、ffis_read.ii_bytes、ffis_write.ii_count、及びffis_write.ii_bytesは連続読み取りおよび書き込みI / Oと報告バイトの範囲内で転送されたバイトのそれぞれの総数の数を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The combination of ffis_deviceid and ffl_addr uniquely identifies both the storage path and the network route to it. Finally, ffl_fhandle allows the metadata server to differentiate between multiple read-only copies of the file on the same storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ffis_deviceidとffl_addrの組み合わせが一意にストレージ・パスと、それへのネットワーク経路の両方を識別する。最後に、ffl_fhandleは、メタデータサーバが同じストレージデバイス上のファイルの複数の読み取り専用コピーを区別することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. ff_layoutreturn4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.  ff_layoutreturn4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_layoutreturn4 {
   ///         ff_ioerr4     fflr_ioerr_report&lt;&gt;;
   ///         ff_iostats4   fflr_iostats_report&lt;&gt;;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When data file I/O operations fail, fflr_ioerr_report&lt;&gt; is used to report these errors to the metadata server as an array of elements of type ff_ioerr4. Each element in the array represents an error that occurred on the data file identified by ffie_errors.de_deviceid. If no errors are to be reported, the size of the fflr_ioerr_report&lt;&gt; array is set to zero. The client MAY also use fflr_iostats_report&lt;&gt; to report a list of I/O statistics as an array of elements of type ff_iostats4. Each element in the array represents statistics for a particular byte range. Byte ranges are not guaranteed to be disjoint and MAY repeat or intersect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データファイルI / O操作が失敗すると、fflr_ioerr_reportは&lt;&gt;型ff_ioerr4の要素の配列として、メタデータサーバにこれらのエラーを報告するために使用されます。アレイ内の各要素はffie_errors.de_deviceidによって識別されたデータファイルで発生したエラーを表しています。エラーが報告されていない場合、fflr_ioerr_report &lt;&gt;配列のサイズはゼロに設定されます。また、クライアントは、タイプff_iostats4の要素の配列として、I / O統計のリストを報告するfflr_iostats_report &lt;&gt;を使用するかもしれません。アレイ内の各要素は、特定のバイト範囲の統計を表します。バイト範囲は互いに素であることが保証されていないと繰り返したり交差することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Flexible File Layout Type LAYOUTERROR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.柔軟なファイルレイアウトタイプLAYOUTERROR
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client is using NFSv4.2 to communicate with the metadata server, then instead of waiting for a LAYOUTRETURN to send error information to the metadata server (see Section 9.1), it MAY use LAYOUTERROR (see Section 15.6 of [RFC7862]) to communicate that information. For the flexible file layout type, this means that LAYOUTERROR4args is treated the same as ff_ioerr4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが（9.1節を参照）、その後、メタデータサーバとの通信にNFSv4.2を使用して代わりにLAYOUTRETURNは、メタデータサーバにエラー情報を送信するのを待っている場合、それはLAYOUTERRORを使用するかもしれ（[RFC7862]のセクション15.6を参照）その情報を伝えます。柔軟なファイルレイアウトタイプの場合、これはLAYOUTERROR4argsがff_ioerr4と同様に扱われることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Flexible File Layout Type LAYOUTSTATS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.柔軟なファイルレイアウトタイプLAYOUTSTATS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client is using NFSv4.2 to communicate with the metadata server, then instead of waiting for a LAYOUTRETURN to send I/O statistics to the metadata server (see Section 9.2), it MAY use LAYOUTSTATS (see Section 15.7 of [RFC7862]) to communicate that information. For the flexible file layout type, this means that LAYOUTSTATS4args.lsa_layoutupdate is overloaded with the same contents as in ffis_layoutupdate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが（9.2節を参照）の代わりにメタデータ・サーバへのI / O統計を送信するためにLAYOUTRETURNを待つので、その後、メタデータサーバとの通信にNFSv4.2を使用している場合は、[RFC7862]のセクション15.7を参照してください（LAYOUTSTATSを使用するかもしれ）その情報を通信します。柔軟なファイルレイアウトタイプの場合、これはLAYOUTSTATS4args.lsa_layoutupdateがffis_layoutupdateと同じ内容でオーバーロードされることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Flexible File Layout Type Creation Hint
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.柔軟なファイルレイアウトタイプ作成のヒント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layouthint4 type is defined in the [RFC5661] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにlayouthint4タイプは[RFC5661]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct layouthint4 {
       layouttype4        loh_type;
       opaque             loh_body&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layouthint4 structure is used by the client to pass a hint about the type of layout it would like created for a particular file. If the loh_type layout type is LAYOUT4_FLEX_FILES, then the loh_body opaque value is defined by the ff_layouthint4 type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
layouthint4構造は、それが特定のファイルのために作成された希望のレイアウトのタイプについてのヒントを渡すために、クライアントによって使用されます。 loh_typeレイアウトタイプがLAYOUT4_FLEX_FILESある場合、loh_body不透明値はff_layouthint4タイプによって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. ff_layouthint4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.  ff_layouthint4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// union ff_mirrors_hint switch (bool ffmc_valid) {
   ///     case TRUE:
   ///         uint32_t    ffmc_mirrors;
   ///     case FALSE:
   ///         void;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct ff_layouthint4 {
   ///     ff_mirrors_hint    fflh_mirrors_hint;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This type conveys hints for the desired data map. All parameters are optional so the client can give values for only the parameter it cares about.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このタイプは、所望のデータマップのためのヒントを伝えます。すべてのパラメータはオプションですので、クライアントは、それが気に唯一のパラメータの値を与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Recalling a Layout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.レイアウトを想起
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While Section 12.5.5 of [RFC5661] discusses reasons independent of layout type for recalling a layout, the flexible file layout type metadata server should recall outstanding layouts in the following cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661]のセクション12.5.5レイアウトをリコールためのレイアウトタイプの独立した理由について説明しながら、柔軟なファイルレイアウト・タイプ・メタデータ・サーバーは、次のような場合には、優れたレイアウトを思い出す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the file&#39;s security policy changes, i.e., ACLs or permission mode bits are set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oファイルのセキュリティポリシーの変更、つまり、ACLまたは許可モードのビットが設定されている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the file&#39;s layout changes, rendering outstanding layouts invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oファイルのレイアウトの変更は、無効な優れたレイアウトをレンダリングする場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When existing layouts are inconsistent with the need to enforce locking constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O既存のレイアウトは固定制約を施行する必要性と矛盾しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When existing layouts are inconsistent with the requirements regarding resilvering as described in Section 8.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8.3節で説明したように、O既存のレイアウトは、再同期化に関する要件と矛盾しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. CB_RECALL_ANY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1.  CB_RECALL_ANY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server can use the CB_RECALL_ANY callback operation to notify the client to return some or all of its layouts. Section 22.3 of [RFC5661] defines the allowed types of the &#34;NFSv4 Recallable Object Types Registry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバは、そのレイアウトの一部またはすべてを返すようにクライアントに通知するためにCB_RECALL_ANYコールバック操作を使用することができます。 [RFC5661]のセクション22.3には、「NFSv4のリコールオブジェクト・タイプレジストリ」の許可されたタイプを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// const RCA4_TYPE_MASK_FF_LAYOUT_MIN     = 16;
   /// const RCA4_TYPE_MASK_FF_LAYOUT_MAX     = 17;
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct  CB_RECALL_ANY4args      {
       uint32_t        craa_layouts_to_keep;
       bitmap4         craa_type_mask;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typically, CB_RECALL_ANY will be used to recall client state when the server needs to reclaim resources. The craa_type_mask bitmap specifies the type of resources that are recalled, and the craa_layouts_to_keep value specifies how many of the recalled flexible file layouts the client is allowed to keep. The mask flags for the flexible file layout type are defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的に、CB_RECALL_ANYは、サーバーがリソースを再利用する必要がある場合に、クライアントの状態をリコールするために使用されます。 craa_type_maskビットマップがリコールされているリソースの種類を指定し、craa_layouts_to_keep値は、クライアントが続けることができる方法を思い出した柔軟なファイルの多くレイアウトする指定します。次のように柔軟なファイルレイアウトタイプのマスクフラグが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが開始されます&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/// enum ff_cb_recall_any_mask { /// PNFS_FF_RCA4_TYPE_MASK_READ = 16, /// PNFS_FF_RCA4_TYPE_MASK_RW = 17 /// }; ///
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
///列挙ff_cb_recall_any_mask {/// PNFS_FF_RCA4_TYPE_MASK_READ = 16、/// PNFS_FF_RCA4_TYPE_MASK_RW = 17 ///}。 ///
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flags represent the iomode of the recalled layouts. In response, the client SHOULD return layouts of the recalled iomode that it needs the least, keeping at most craa_layouts_to_keep flexible file layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグは、リコールのレイアウトのIOModeにを表しています。応答では、クライアントは、それが最もcraa_layouts_to_keep柔軟なファイルのレイアウトに保ち、少なくともを必要としていることをIOModeにリコールのレイアウトを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PNFS_FF_RCA4_TYPE_MASK_READ flag notifies the client to return layouts of iomode LAYOUTIOMODE4_READ. Similarly, the PNFS_FF_RCA4_TYPE_MASK_RW flag notifies the client to return layouts of iomode LAYOUTIOMODE4_RW. When both mask flags are set, the client is notified to return layouts of either iomode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PNFS_FF_RCA4_TYPE_MASK_READフラグはIOModeにLAYOUTIOMODE4_READのレイアウトを返すようにクライアントに通知します。同様に、PNFS_FF_RCA4_TYPE_MASK_RWフラグがIOModeにLAYOUTIOMODE4_RWのレイアウトを返すようにクライアントに通知します。両方のマスクのフラグが設定されている場合は、クライアントは、どちらかIOModeにのレイアウトを返すように通知されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Client Fencing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.クライアントフェンシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases where clients are uncommunicative and their lease has expired or when clients fail to return recalled layouts within a lease period, the server MAY revoke client layouts and reassign these resources to other clients (see Section 12.5.5 of [RFC5661]). To avoid data corruption, the metadata server MUST fence off the revoked clients from the respective data files as described in Section 2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが通信不能であり、（[RFC5661]のセクション12.5.5を参照）、そのリースの有効期限が切れているか、クライアントがリース期間内にリコールのレイアウトを返すために失敗した場合、サーバはクライアントのレイアウトを取り消して他のクライアントにこれらのリソースを再割り当てすることのケースでは。データの破損を避けるために、それぞれのデータファイルから失効したクライアントオフメタデータサーバMUSTフェンスは、2.2節で説明したように。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The combination of components in a pNFS system is required to preserve the security properties of NFSv4.1+ with respect to an entity accessing data via a client. The pNFS feature partitions the NFSv4.1+ file system protocol into two parts: the control protocol and the data protocol. As the control protocol in this document is NFS, the security properties are equivalent to the version of NFS being used. The flexible file layout further divides the data protocol into metadata and data paths. The security properties of the metadata path are equivalent to those of NFSv4.1x (see Sections 1.7.1 and 2.2.1 of [RFC5661]). And the security properties of the data path are equivalent to those of the version of NFS used to access the storage device, with the provision that the metadata server is responsible for authenticating client access to the data file. The metadata server provides appropriate credentials to the client to access data files on the storage device. It is also responsible for revoking access for a client to the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pNFSのシステム内の構成要素の組み合わせは、クライアントを介してデータにアクセスするエンティティに対してNFSv4.1 +のセキュリティ特性を維持するために必要とされます。制御プロトコルとデータプロトコル：pNFSのパーティション2つの部分にNFSv4.1 +ファイルシステムプロトコルを備えています。この文書に記載されている制御プロトコルはNFSのように、セキュリティプロパティは、使用されているNFSのバージョンと等価です。柔軟なファイルレイアウトは、さらに、メタデータとデータパスにデータプロトコルを分割します。メタデータ・パスのセキュリティ特性がNFSv4.1xのものと同等である（セクション1.7.1および2.2.1を参照[RFC5661]）。そして、データパスのセキュリティプロパティは、NFSのバージョンと同等のメタデータサーバは、データファイルへのクライアントアクセスを認証するための責任があることを規定して、ストレージデバイスにアクセスするために使用されています。メタデータサーバは、ストレージ・デバイス上のデータファイルにアクセスするには、クライアントに適切な資格情報を提供します。また、ストレージデバイスにクライアントのアクセスを取り消すための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server enforces the file access control policy at LAYOUTGET time. The client should use RPC authorization credentials for getting the layout for the requested iomode ((LAYOUTIOMODE4_READ or LAYOUTIOMODE4_RW), and the server verifies the permissions and ACL for these credentials, possibly returning NFS4ERR_ACCESS if the client is not allowed the requested iomode. If the LAYOUTGET operation succeeds, the client receives, as part of the layout, a set of credentials allowing it I/O access to the specified data files corresponding to the requested iomode. When the client acts on I/O operations on behalf of its local users, it MUST authenticate and authorize the user by issuing respective OPEN and ACCESS calls to the metadata server, similar to having NFSv4 data delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバは、LAYOUTGET時にファイルのアクセス制御ポリシーを適用します。クライアントは、要求されたIOModeに（（LAYOUTIOMODE4_READまたはLAYOUTIOMODE4_RW）のレイアウトを取得するためのRPC認証の資格情報を使用する必要があり、およびサーバは、クライアントが要求IOModeには許可されていない場合は、おそらくNFS4ERR_ACCESSを返し、これらの資格情報の権限とACLを検証します。LAYOUTGET場合操作は、レイアウトの一部として、クライアントが受け取る、成功し、要求されたIOModeに対応する指定されたデータファイルへのI / Oアクセスを許可する資格情報のセット。クライアントは、ローカルユーザーの代わりにI / O操作に作用すると、それが認証し、NFSv4のデータ代表団を持つに似たメタデータサーバにそれぞれのOPENとアクセスのコールを、発行してユーザーを認証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The combination of filehandle, synthetic uid, and gid in the layout is the way that the metadata server enforces access control to the data server. The client only has access to filehandles of file objects and not directory objects. Thus, given a filehandle in a layout, it is not possible to guess the parent directory filehandle. Further, as the data file permissions only allow the given synthetic uid read/write permission and the given synthetic gid read permission, knowing the synthetic ids of one file does not necessarily allow access to any other data file on the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイアウトのファイルハンドル、合成UID、およびGIDの組み合わせは、メタデータサーバは、データ・サーバへのアクセス制御を実施する方法です。クライアントは、ファイルオブジェクトではなくディレクトリオブジェクトのファイルハンドルへのアクセスを持っています。このように、レイアウトのファイルハンドルを考えると、親ディレクトリのファイルハンドルを推測することはできません。さらに、データファイルのアクセス権のみ与えられ、合成UID読み取り/書き込み許可と所定の合成GIDを可能としては、一つのファイルの合成IDは必ず、ストレージデバイス上の他のデータファイルへのアクセスを許可しない知って、許可を読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metadata server can also deny access at any time by fencing the data file, which means changing the synthetic ids. In turn, that forces the client to return its current layout and get a new layout if it wants to continue I/O to the data file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メタデータサーバは、合成IDの変更を意味し、データファイルをフェンシングすることで、いつでもアクセスを拒否することができます。ターンでは、それは、その現在のレイアウトを返し、それがデータファイルにI / Oを継続したい場合は、新しいレイアウトを取得するためにクライアントを強制します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If access is allowed, the client uses the corresponding (read-only or read/write) credentials to perform the I/O operations at the data file&#39;s storage devices. When the metadata server receives a request to change a file&#39;s permissions or ACL, it SHOULD recall all layouts for that file and then MUST fence off any clients still holding outstanding layouts for the respective files by implicitly invalidating the previously distributed credential on all data file comprising the file in question. It is REQUIRED that this be done before committing to the new permissions and/or ACL. By requesting new layouts, the clients will reauthorize access against the modified access control metadata. Recalling the layouts in this case is intended to prevent clients from getting an error on I/Os done after the client was fenced off.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスが許可されている場合、クライアントは、対応する（読み取り専用または読み取り/書き込み）の資格情報は、データファイルのストレージ・デバイスでI / O操作を実行するために使用しています。メタデータサーバは、ファイルのアクセス権またはACLを変更する要求を受信すると、そのファイルのすべてのレイアウトを思い出すべきで、その後はフェンスオフまだ暗黙のうちにあって、すべてのデータファイルに以前に配布さ証明書を無効化することにより、それぞれのファイルのための優れたレイアウトを保持しているすべてのクライアントをMUST問題のファイル。新たな権限および/またはACLにコミットする前に行われることが必要です。新しいレイアウトを要求することにより、クライアントが変更されたアクセス制御メタデータに対するアクセスを再承認します。この場合、レイアウトを想起することは、クライアントが仕切られた後に行われたI / Oのエラーを取得してからクライアントを防止するためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. RPCSEC_GSS and Security Services
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.  RPCSEC_GSSとセキュリティサービス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because of the special use of principals within the loosely coupled model, the issues are different depending on the coupling model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
なぜなら疎結合モデル内のプリンシパルの特別な使用のため、問題が結合モデルに応じて異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1. Loosely Coupled
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.1. 疎結合
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSS version 3 (RPCSEC_GSSv3) [RFC7861] contains facilities that would allow it to be used to authorize the client to the storage device on behalf of the metadata server. Doing so would require that each of the metadata server, storage device, and client would need to implement RPCSEC_GSSv3 using an RPC-application-defined structured privilege assertion in a manner described in Section 4.9.1 of [RFC7862]. The specifics necessary to do so are not described in this document. This is principally because any such specification would require extensive implementation work on a wide range of storage devices, which would be unlikely to result in a widely usable specification for a considerable time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSのバージョン3（RPCSEC_GSSv3）[RFC7861]は、メタデータサーバの代わりにストレージデバイスにクライアントを許可するために使用することができるようになる機能が含まれています。そうすることで、メタデータサーバ、記憶装置、及びクライアントのそれぞれは[RFC7862]のセクション4.9.1に記載したようにRPCアプリケーション定義構造特権アサーションを使用RPCSEC_GSSv3を実装する必要があることを必要とするであろう。そうするために必要な詳細は、このドキュメントに記載されていません。そのような仕様はかなりの時間のために広く使用可能な仕様につながる可能性が低いであろうストレージ・デバイスの広範囲に大規模な実装作業を必要とするので、これは主にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result, the layout type described in this document will not provide support for use of RPCSEC_GSS together with the loosely coupled model. However, future layout types could be specified, which would allow such support, either through the use of RPCSEC_GSSv3 or in other ways.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果として、この文書に記載されたレイアウトの種類は疎結合モデルと共にRPCSEC_GSSを使用するためのサポートを提供しないであろう。しかし、将来のレイアウトタイプはRPCSEC_GSSv3の使用により、または他の方法のいずれかで、そのようなサポートを可能にされ、指定することができました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2. Tightly Coupled
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1.2. 固く結ばれた
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With tight coupling, the principal used to access the metadata file is exactly the same as used to access the data file. The storage device can use the control protocol to validate any RPC credentials. As a result, there are no security issues related to using RPCSEC_GSS with a tightly coupled system. For example, if Kerberos V5 Generic Security Service Application Program Interface (GSS-API) [RFC4121] is used as the security mechanism, then the storage device could use a control protocol to validate the RPC credentials to the metadata server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密結合では、メタデータファイルにアクセスするために使用される主要なデータファイルにアクセスするために使用されるとまったく同じです。記憶装置は、任意のRPC認証情報を検証するために制御プロトコルを使用することができます。その結果、密結合システムでRPCSEC_GSSを使用してに関連したセキュリティ上の問題はありません。ケルベロスV5汎用セキュリティサービスアプリケーションプログラムインタフェース（GSS-API）[RFC4121]は、セキュリティ・メカニズムとして使用される場合、例えば、その後、記憶装置は、メタデータサーバにRPC認証情報を検証するために制御プロトコルを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] introduced the &#34;pNFS Layout Types Registry&#34;; new layout type numbers in this registry need to be assigned by IANA. This document defines the protocol associated with an existing layout type number: LAYOUT4_FLEX_FILES. See Table 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661]は、「pNFSのレイアウトタイプレジストリ」を導入しました。このレジストリ内の新しいレイアウトタイプ番号は、IANAによって割り当てする必要があります。この文書では、既存のレイアウトタイプ番号に関連付けられたプロトコルを定義：LAYOUT4_FLEX_FILES。表1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------------------+------------+----------+-----+----------------+
   | Layout Type Name   | Value      | RFC      | How | Minor Versions |
   +--------------------+------------+----------+-----+----------------+
   | LAYOUT4_FLEX_FILES | 0x00000004 | RFC 8435 | L   | 1              |
   +--------------------+------------+----------+-----+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Table 1: Layout Type Assignments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
表1：レイアウトタイプの割り当て
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] also introduced the &#34;NFSv4 Recallable Object Types Registry&#34;. This document defines new recallable objects for RCA4_TYPE_MASK_FF_LAYOUT_MIN and RCA4_TYPE_MASK_FF_LAYOUT_MAX (see Table 2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661]も「NFSv4のリコールオブジェクトの種類レジストリ」を導入しました。この文書では、RCA4_TYPE_MASK_FF_LAYOUT_MINとRCA4_TYPE_MASK_FF_LAYOUT_MAX（表2を参照）のための新たなリコールオブジェクトを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------------+-------+--------+-----+-------------+
   | Recallable Object Type Name  | Value | RFC    | How | Minor       |
   |                              |       |        |     | Versions    |
   +------------------------------+-------+--------+-----+-------------+
   | RCA4_TYPE_MASK_FF_LAYOUT_MIN | 16    | RFC    | L   | 1           |
   |                              |       | 8435   |     |             |
   | RCA4_TYPE_MASK_FF_LAYOUT_MAX | 17    | RFC    | L   | 1           |
   |                              |       | 8435   |     |             |
   +------------------------------+-------+--------+-----+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Table 2: Recallable Object Type Assignments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
表2：リコールオブジェクトタイプの割り当て
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LEGAL] IETF Trust, &#34;Trust Legal Provisions (TLP)&#34;, &lt;https://trustee.ietf.org/trust-legal-provisions.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[法的] IETFトラスト、 &#34;信頼法律の規定（TLP）&#34;、&lt;https://trustee.ietf.org/trust-legal-provisions.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813] Callaghan, B., Pawlowski, B., and P. Staubach, &#34;NFS Version 3 Protocol Specification&#34;, RFC 1813, DOI 10.17487/RFC1813, June 1995, &lt;https://www.rfc-editor.org/info/rfc1813&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813]キャラハン、B.、ポロウスキー、B.、およびP.ストーバック、 &#34;NFSバージョン3プロトコル仕様&#34;、RFC 1813、DOI 10.17487 / RFC1813、1995年6月、&lt;https://www.rfc-editor.org/情報/ RFC1813&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, &#34;The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2&#34;, RFC 4121, DOI 10.17487/RFC4121, July 2005, &lt;https://www.rfc-editor.org/info/rfc4121&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4121]朱、L.、Jaganathan、K.、およびS.ハートマン、 &#34;Kerberosバージョン5の汎用セキュリティサービスアプリケーションプログラムインタフェース（GSS-API）メカニズム：バージョン2&#34;、RFC 4121、DOI 10.17487 / RFC4121、2005年7月、&lt;https://www.rfc-editor.org/info/rfc4121&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4506] Eisler, M., Ed., &#34;XDR: External Data Representation Standard&#34;, STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, &lt;https://www.rfc-editor.org/info/rfc4506&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4506]アイスラー、M.、エド、 &#34;XDR：外部データ表現標準&#34;。、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、&lt;https://www.rfc-editor.org/info/rfc4506 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5531] Thurlow, R., &#34;RPC: Remote Procedure Call Protocol Specification Version 2&#34;, RFC 5531, DOI 10.17487/RFC5531, May 2009, &lt;https://www.rfc-editor.org/info/rfc5531&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5531] Thurlow、R.、 &#34;RPC：リモートプロシージャコールプロトコル仕様バージョン2&#34;、RFC 5531、DOI 10.17487 / RFC5531、2009年5月、&lt;https://www.rfc-editor.org/info/rfc5531&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 Protocol&#34;, RFC 5661, DOI 10.17487/RFC5661, January 2010, &lt;https://www.rfc-editor.org/info/rfc5661&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5661] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル&#34;、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、&lt;https://www.rfc-editor.org/info/rfc5661&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5662] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description&#34;, RFC 5662, DOI 10.17487/RFC5662, January 2010, &lt;https://www.rfc-editor.org/info/rfc5662&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5662] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1外部データ表現標準（XDR）の説明&#34;、RFC 5662、DOI 10.17487 / RFC5662、2010年1月、&lt;https://www.rfc-editor.org/info/rfc5662&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7530] Haynes, T., Ed. and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Protocol&#34;, RFC 7530, DOI 10.17487/RFC7530, March 2015, &lt;https://www.rfc-editor.org/info/rfc7530&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7530]ヘインズ、T.、エド。そして、D. Noveck、エド。、 &#34;ネットワークファイルシステム（NFS）バージョン4プロトコル&#34;、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、&lt;https://www.rfc-editor.org/info/rfc7530&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7861] Adamson, A. and N. Williams, &#34;Remote Procedure Call (RPC) Security Version 3&#34;, RFC 7861, DOI 10.17487/RFC7861, November 2016, &lt;https://www.rfc-editor.org/info/rfc7861&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7861]アダムソン、A.およびN.ウィリアムズ、 &#34;リモートプロシージャコール（RPC）Securityバージョン3&#34;、RFC 7861、DOI 10.17487 / RFC7861、2016年11月、&lt;https://www.rfc-editor.org/info/ rfc7861&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7862] Haynes, T., &#34;Network File System (NFS) Version 4 Minor Version 2 Protocol&#34;, RFC 7862, DOI 10.17487/RFC7862, November 2016, &lt;https://www.rfc-editor.org/info/rfc7862&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7862]ヘインズ、T.、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン2プロトコル&#34;、RFC 7862、DOI 10.17487 / RFC7862、2016年11月、&lt;https://www.rfc-editor.org/info/rfc7862 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B.、 &#34;RFC 2119個のキーワードに小文字VS大文字の曖昧さ&#34;、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https://www.rfc-editor.org/info/ rfc8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8434] Haynes, T., &#34;Requirements for Parallel NFS (pNFS) Layout Types&#34;, RFC 8434, DOI 10.17487/RFC8434, August 2018, &lt;https://www.rfc-editor.org/info/rfc8434&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8434]ヘインズ、T.、 &#34;パラレルNFS（pNFSの）レイアウトタイプのための要件&#34;、RFC 8434、DOI 10.17487 / RFC8434、2018年8月、&lt;https://www.rfc-editor.org/info/rfc8434&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4519] Sciberras, A., Ed., &#34;Lightweight Directory Access Protocol (LDAP): Schema for User Applications&#34;, RFC 4519, DOI 10.17487/RFC4519, June 2006, &lt;https://www.rfc-editor.org/info/rfc4519&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4519] Sciberras、A.、エド、 &#34;ライトウェイトディレクトリアクセスプロトコル（LDAP）：ユーザー・アプリケーションのためのスキーマ&#34;。、RFC 4519、DOI 10.17487 / RFC4519、2006年6月、&lt;https://www.rfc-editor.org/情報/ rfc4519&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following individuals provided miscellaneous comments to early draft versions of this document: Matt W. Benjamin, Adam Emerson, J. Bruce Fields, and Lev Solomonov.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マット・W.ベンジャミン、アダム・エマーソン、J.ブルース・フィールド、およびレフSolomonov：以下の個人はこのドキュメントの初期のドラフトバージョンに雑多なコメントを提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following individuals provided miscellaneous comments to the final draft versions of this document: Anand Ganesh, Robert Wipfel, Gobikrishnan Sundharraj, Trond Myklebust, Rick Macklem, and Jim Sermersheim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アナンガネーシュ、ロバートWipfel、Gobikrishnan Sundharraj、トロンMyklebust、リックMacklem、そしてジム・Sermersheim：以下の個人は、この文書の最終草案バージョンに雑多なコメントを提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Idan Kedar caught a nasty bug in the interaction of client-side mirroring and the minor versioning of devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IDANケダールは、クライアント側のミラーリングおよびデバイスのマイナーバージョンとの相互作用に厄介なバグをキャッチ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dave Noveck provided comprehensive reviews of the document during the working group last calls. He also rewrote Section 2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デイブNoveckは、ワーキンググループの最後の通話中に文書の包括的なレビューを提供します。彼はまた、2.3節を書き直しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Olga Kornievskaia made a convincing case against the use of a credential versus a principal in the fencing approach. Andy Adamson and Benjamin Kaduk helped to sharpen the focus.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オルガKornievskaiaはフェンシングアプローチにおける主要対資格の使用に対する説得力のケースを作りました。アンディ・アダムソンとベンジャミンKadukはフォーカスをシャープにするのに役立ちました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Benjamin Kaduk and Olga Kornievskaia also helped provide concrete scenarios for loosely coupled security mechanisms. In the end, Olga proved that as defined, the loosely coupled model would not work with RPCSEC_GSS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベンジャミンKadukとオルガKornievskaiaも疎結合のセキュリティメカニズムのための具体的なシナリオを提供助けました。最後に、オルガは定義されているように、疎結合モデルはRPCSEC_GSSでは動作しないだろうことを証明しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tigran Mkrtchyan provided the use case for not allowing the client to proxy the I/O through the data server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tigran Mkrtchyanは、データサーバーを介してI / Oプロキシにクライアントを許可しないためのユースケースを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rick Macklem provided the use case for only writing to a single mirror.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リックMacklemは、単一のミラーに書き込むためのユースケースを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Benny Halevy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベニー・アレヴィ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: bhalevy@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：bhalevy@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thomas Haynes Hammerspace 4300 El Camino Real Ste 105 Los Altos, CA 94022 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トーマス・ヘインズHammerspace 4300エル・カミノレアルサントアメリカの105ロスアルトス、CA 94022米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: loghyr@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：loghyr@gmail.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
