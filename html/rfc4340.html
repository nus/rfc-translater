<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 4340 - Datagram Congestion Control Protocol (DCCP) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4340</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc4340">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 4340 - Datagram Congestion Control Protocol (DCCP) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc4340">
              https://tools.ietf.org/html/rfc4340
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 4340 - データグラム輻輳制御プロトコル（DCCP）</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                          E. Kohler
Request for Comments: 4340                                          UCLA
Category: Standards Track                                     M. Handley
                                                                     UCL
                                                                S. Floyd
                                                                    ICIR
                                                              March 2006
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Datagram Congestion Control Protocol (DCCP)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2006）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Datagram Congestion Control Protocol (DCCP) is a transport protocol that provides bidirectional unicast connections of congestion-controlled unreliable datagrams. DCCP is suitable for applications that transfer fairly large amounts of data and that can benefit from control over the tradeoff between timeliness and reliability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データグラム輻輳制御プロトコル（DCCP）が輻輳制御信頼性のないデータグラムの双方向のユニキャスト接続を提供するトランスポート・プロトコルです。 DCCPはデータのかなり大きな金額を転送し、それがタイムリーかつ信頼性の間のトレードオフを制御の恩恵を受けることができるアプリケーションに適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................5
   2. Design Rationale ................................................6
   3. Conventions and Terminology .....................................7
      3.1. Numbers and Fields .........................................7
      3.2. Parts of a Connection ......................................8
      3.3. Features ...................................................9
      3.4. Round-Trip Times ...........................................9
      3.5. Security Limitation ........................................9
      3.6. Robustness Principle ......................................10
   4. Overview .......................................................10
      4.1. Packet Types ..............................................10
      4.2. Packet Sequencing .........................................11
      4.3. States ....................................................12
      4.4. Congestion Control Mechanisms .............................14
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      4.5. Feature Negotiation Options ...............................15
      4.6. Differences from TCP ......................................16
      4.7. Example Connection ........................................17
   5. Packet Formats .................................................18
      5.1. Generic Header ............................................19
      5.2. DCCP-Request Packets ......................................22
      5.3. DCCP-Response Packets .....................................23
      5.4. DCCP-Data, DCCP-Ack, and DCCP-DataAck Packets .............23
      5.5. DCCP-CloseReq and DCCP-Close Packets ......................25
      5.6. DCCP-Reset Packets ........................................25
      5.7. DCCP-Sync and DCCP-SyncAck Packets ........................28
      5.8. Options ...................................................29
           5.8.1. Padding Option .....................................31
           5.8.2. Mandatory Option ...................................31
   6. Feature Negotiation ............................................32
      6.1. Change Options ............................................32
      6.2. Confirm Options ...........................................33
      6.3. Reconciliation Rules ......................................33
           6.3.1. Server-Priority ....................................34
           6.3.2. Non-Negotiable .....................................34
      6.4. Feature Numbers ...........................................35
      6.5. Feature Negotiation Examples ..............................36
      6.6. Option Exchange ...........................................37
           6.6.1. Normal Exchange ....................................38
           6.6.2. Processing Received Options ........................38
           6.6.3. Loss and Retransmission ............................40
           6.6.4. Reordering .........................................41
           6.6.5. Preference Changes .................................42
           6.6.6. Simultaneous Negotiation ...........................42
           6.6.7. Unknown Features ...................................43
           6.6.8. Invalid Options ....................................43
           6.6.9. Mandatory Feature Negotiation ......................44
   7. Sequence Numbers ...............................................44
      7.1. Variables .................................................45
      7.2. Initial Sequence Numbers ..................................45
      7.3. Quiet Time ................................................46
      7.4. Acknowledgement Numbers ...................................47
      7.5. Validity and Synchronization ..............................47
           7.5.1. Sequence and Acknowledgement Number Windows ........48
           7.5.2. Sequence Window Feature ............................49
           7.5.3. Sequence-Validity Rules ............................49
           7.5.4. Handling Sequence-Invalid Packets ..................51
           7.5.5. Sequence Number Attacks ............................52
           7.5.6. Sequence Number Handling Examples ..................54
      7.6. Short Sequence Numbers ....................................55
           7.6.1. Allow Short Sequence Numbers Feature ...............55
           7.6.2. When to Avoid Short Sequence Numbers ...............56
      7.7. NDP Count and Detecting Application Loss ..................56
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           7.7.1. NDP Count Usage Notes ..............................57
           7.7.2. Send NDP Count Feature .............................57
   8. Event Processing ...............................................58
      8.1. Connection Establishment ..................................58
           8.1.1. Client Request .....................................58
           8.1.2. Service Codes ......................................59
           8.1.3. Server Response ....................................61
           8.1.4. Init Cookie Option .................................62
           8.1.5. Handshake Completion ...............................63
      8.2. Data Transfer .............................................63
      8.3. Termination ...............................................64
           8.3.1. Abnormal Termination ...............................66
      8.4. DCCP State Diagram ........................................66
      8.5. Pseudocode ................................................67
   9. Checksums ......................................................72
      9.1. Header Checksum Field .....................................73
      9.2. Header Checksum Coverage Field ............................73
           9.2.1. Minimum Checksum Coverage Feature ..................74
      9.3. Data Checksum Option ......................................75
           9.3.1. Check Data Checksum Feature ........................76
           9.3.2. Checksum Usage Notes ...............................76
   10. Congestion Control ............................................76
      10.1. TCP-like Congestion Control ..............................77
      10.2. TFRC Congestion Control ..................................78
      10.3. CCID-Specific Options, Features, and Reset Codes .........78
      10.4. CCID Profile Requirements ................................80
      10.5. Congestion State .........................................81
   11. Acknowledgements ..............................................81
      11.1. Acks of Acks and Unidirectional Connections ..............82
      11.2. Ack Piggybacking .........................................83
      11.3. Ack Ratio Feature ........................................84
      11.4. Ack Vector Options .......................................85
           11.4.1. Ack Vector Consistency ............................88
           11.4.2. Ack Vector Coverage ...............................89
      11.5. Send Ack Vector Feature ..................................90
      11.6. Slow Receiver Option .....................................90
      11.7. Data Dropped Option ......................................91
           11.7.1. Data Dropped and Normal Congestion Response .......94
           11.7.2. Particular Drop Codes .............................95
   12. Explicit Congestion Notification ..............................96
      12.1. ECN Incapable Feature ....................................96
      12.2. ECN Nonces ...............................................97
      12.3. Aggression Penalties .....................................98
   13. Timing Options ................................................99
      13.1. Timestamp Option .........................................99
      13.2. Elapsed Time Option ......................................99
      13.3. Timestamp Echo Option ...................................100
   14. Maximum Packet Size ..........................................101
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      14.1. Measuring PMTU ..........................................102
      14.2. Sender Behavior .........................................103
   15. Forward Compatibility ........................................104
   16. Middlebox Considerations .....................................105
   17. Relations to Other Specifications ............................106
      17.1. RTP .....................................................106
      17.2. Congestion Manager and Multiplexing .....................108
   18. Security Considerations ......................................108
      18.1. Security Considerations for Partial Checksums ...........109
   19. IANA Considerations ..........................................110
      19.1. Packet Types Registry ...................................110
      19.2. Reset Codes Registry ....................................110
      19.3. Option Types Registry ...................................110
      19.4. Feature Numbers Registry ................................111
      19.5. Congestion Control Identifiers Registry .................111
      19.6. Ack Vector States Registry ..............................111
      19.7. Drop Codes Registry .....................................112
      19.8. Service Codes Registry ..................................112
      19.9. Port Numbers Registry ...................................112
   20. Thanks .......................................................114
   A.  Appendix: Ack Vector Implementation Notes ....................116
       A.1. Packet Arrival ..........................................118
            A.1.1. New Packets ......................................118
            A.1.2. Old Packets ......................................119
       A.2. Sending Acknowledgements ................................120
       A.3. Clearing State ..........................................120
       A.4. Processing Acknowledgements .............................122
   B.  Appendix: Partial Checksumming Design Motivation .............123
   Normative References .............................................124
   Informative References ...........................................125
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
List of Tables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
テーブルのリスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Table 1: DCCP Packet Types .......................................21
   Table 2: DCCP Reset Codes ........................................28
   Table 3: DCCP Options ............................................30
   Table 4: DCCP Feature Numbers.....................................35
   Table 5: DCCP Congestion Control Identifiers .....................77
   Table 6: DCCP Ack Vector States ..................................86
   Table 7: DCCP Drop Codes .........................................92
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Datagram Congestion Control Protocol (DCCP) is a transport protocol that implements bidirectional, unicast connections of congestion-controlled, unreliable datagrams. Specifically, DCCP provides the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データグラム輻輳制御プロトコル（DCCP）は、輻輳制御、信頼性のないデータグラムの双方向のユニキャスト接続を実装するトランスポート・プロトコルです。具体的には、DCCPは、以下の機能を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Unreliable flows of datagrams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データグラムの信頼性の低いフローO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Reliable handshakes for connection setup and teardown.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続セットアップとティアダウンのための信頼性の高い握手O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Reliable negotiation of options, including negotiation of a suitable congestion control mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適した輻輳制御機構の交渉など、オプションのO信頼性交渉、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Mechanisms allowing servers to avoid holding state for unacknowledged connection attempts and already-finished connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メカニズムoをサーバが未確認の接続試行と、すでに完成の接続の状態を保持しないようすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Congestion control incorporating Explicit Congestion Notification (ECN) [RFC3168] and the ECN Nonce [RFC3540].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明示的輻輳通知（ECN）[RFC3168]及びECNノンス[RFC3540]を組み込むO輻輳制御。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Acknowledgement mechanisms communicating packet loss and ECN information. Acks are transmitted as reliably as the relevant congestion control mechanism requires, possibly completely reliably.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O肯定応答メカニズムは、パケットロス及びECN情報を通信します。 ACKは、関連する輻輳制御機構は、おそらく完全に確実に、必要な限り確実に伝達されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Optional mechanisms that tell the sending application, with high reliability, which data packets reached the receiver, and whether those packets were ECN marked, corrupted, or dropped in the receive buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データパケットが受信機に到達し、それらのパケットがECNマークされたかどうか、破損し、または受信バッファに滴下高い信頼性と、送信アプリケーションを伝える任意のメカニズムを、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Path Maximum Transmission Unit (PMTU) discovery [RFC1191].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oパス最大伝送単位（PMTU）の発見[RFC1191]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A choice of modular congestion control mechanisms. Two mechanisms are currently specified: TCP-like Congestion Control [RFC4341] and TCP-Friendly Rate Control (TFRC) [RFC4342]. DCCP is easily extensible to further forms of unicast congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oモジュール式の輻輳制御機構の選択。 TCPのような輻輳制御を[RFC4341]とTCPフレンドリーレート制御（TFRC）[RFC4342]：二つのメカニズムは、現在指定されています。 DCCPは、ユニキャスト輻輳制御の更なる形態に容易に拡張可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP is intended for applications such as streaming media that can benefit from control over the tradeoffs between delay and reliable in-order delivery. TCP is not well suited for these applications, since reliable in-order delivery and congestion control can cause arbitrarily long delays. UDP avoids long delays, but UDP applications that implement congestion control must do so on their own. DCCP provides built-in congestion control, including ECN support, for unreliable datagram flows, avoiding the arbitrary delays associated with TCP. It also implements reliable connection setup, teardown, and feature negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは、遅延および信頼性における順序配信の間のトレードオフに対する制御から利益を得ることができるようなストリーミングメディアなどのアプリケーションのために意図されています。信頼性の高い順序どおりの配信と輻輳制御が任意に長い遅延が発生する可能性がありますので、TCPは、これらのアプリケーションには適していません。 UDPは、長い遅延を回避できますが、輻輳制御を実装するUDPアプリケーションは自分で行う必要があります。 DCCPはTCPに関連付けられている任意の遅延を回避信頼性のないデータグラムフローのECNのサポート、を含む、内蔵の輻輳制御を提供します。また、信頼性の高い接続のセットアップ、ティアダウン、および機能のネゴシエーションを実装しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Design Rationale
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.デザイン理論的根拠
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One DCCP design goal was to give most streaming UDP applications little reason not to switch to DCCP, once it is deployed. To facilitate this, DCCP was designed to have as little overhead as possible, both in terms of the packet header size and in terms of the state and CPU overhead required at end hosts. Only the minimal necessary functionality was included in DCCP, leaving other functionality, such as forward error correction (FEC), semi-reliability, and multiple streams, to be layered on top of DCCP as desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つDCCPの設計目標は、それが展開されると、DCCPに切り替えていないほとんどのストリーミングUDPアプリケーション少し理由を与えることでした。これを容易にするために、DCCPは、パケットヘッダサイズの観点とエンドホストに必要な状態とCPUオーバーヘッドの点で両方の、可能な限り少ないオーバーヘッドを有するように設計しました。最小限の必要な機能は、所望のようにDCCPの上部に積層される、このような順方向誤り訂正（FEC）、半信頼性、および複数のストリームとして、他の機能を残し、DCCPに含まれていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Different forms of conformant congestion control are appropriate for different applications. For example, on-line games might want to make quick use of any available bandwidth, while streaming media might trade off this responsiveness for a steadier, less bursty rate. (Sudden rate changes can cause unacceptable UI glitches such as audible pauses or clicks in the playout stream.) DCCP thus allows applications to choose from a set of congestion control mechanisms. One alternative, TCP-like Congestion Control, halves the congestion window in response to a packet drop or mark, as in TCP. Applications using this congestion control mechanism will respond quickly to changes in available bandwidth, but must tolerate the abrupt changes in congestion window typical of TCP. A second alternative, TCP-Friendly Rate Control (TFRC) [RFC3448], a form of equation-based congestion control, minimizes abrupt changes in the sending rate while maintaining longer-term fairness with TCP. Other alternatives can be added as future congestion control mechanisms are standardized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
準拠輻輳制御の異なる形式は、さまざまなアプリケーションに適しています。例えば、オンラインゲームは、ストリーミングメディアがより安定し、より少ないバースト性率のために、この応答性のトレードオフかもしれないが、任意の利用可能な帯域幅を迅速に活用したい場合があります。 （突然の速度変化は、再生ストリーム内の可聴休止またはクリックなどの容認できないUIの不具合を引き起こす可能性がある。）DCCP従ってアプリケーションが輻輳制御機構のセットから選択することができます。一つの代替、TCPのような輻輳制御は、TCPのように、パケットのドロップまたはマークに対応して混雑ウィンドウを半分にします。この輻輳制御機構を使用するアプリケーションは、利用可能な帯域幅の変化に迅速に対応しますが、TCPの典型的な輻輳ウィンドウの急激な変化に耐えなければなりません。 TCPと長期的公平性を維持しながら、第二の代替、TCPフレンドリーレート制御（TFRC）[RFC3448]は、方程式ベースの輻輳制御の形態は、送信レートの急激な変化を最小限に抑えます。将来の輻輳制御機構が標準化されているように、他の選択肢を追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP also lets unreliable traffic safely use ECN. A UDP kernel Application Programming Interface (API) might not allow applications to set UDP packets as ECN capable, since the API could not guarantee that the application would properly detect or respond to congestion. DCCP kernel APIs will have no such issues, since DCCP implements congestion control itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPはまた、信頼できないトラフィックが安全にECNを使用することができます。 UDPカーネルアプリケーションプログラミングインターフェイス（API）は、APIは、アプリケーションが適切に検出または混雑に応答することを保証することができませんでしたので、アプリケーションは、可能ECNとしてUDPパケットを設定することができない場合があります。 DCCPは輻輳制御自体を実装しているのでDCCPカーネルAPIは、そのような問題を持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We chose not to require the use of the Congestion Manager [RFC3124], which allows multiple concurrent streams between the same sender and receiver to share congestion control. The current Congestion Manager can only be used by applications that have their own end-to-end feedback about packet losses, but this is not the case for many of the applications currently using UDP. In addition, the current Congestion Manager does not easily support multiple congestion control mechanisms or mechanisms where the state about past packet drops or marks is maintained at the receiver rather than the sender. DCCP should be able to make use of CM where desired by the application, but we do not see any benefit in making the deployment of DCCP contingent on the deployment of CM itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、同じ送信者と受信者の間で複数の同時ストリームが輻輳制御を共有することができます輻輳マネージャ[RFC3124]の使用を必要としないことを選びました。現在の輻輳Managerは、パケットロスについて、独自のエンドツーエンドのフィードバックを持っているアプリケーションで使用することができますが、これは現在、UDPを使用したアプリケーションの多くの場合はそうではありません。加えて、現在の輻輳管理を容易に過去のパケットドロップまたはマークに関する状態が受信機ではなく送信側で維持される複数の輻輳制御機構または機構をサポートしていません。 DCCPは、アプリケーションが希望するCMを利用することができるはずですが、私たちはCM自体の展開にDCCPの偶発の展開を行う際にどんな利益が表示されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We intend for DCCP&#39;s protocol mechanisms, which are described in this document, to suit any application desiring unicast congestion-controlled streams of unreliable datagrams. However, the congestion control mechanisms currently approved for use with DCCP, which are described in separate Congestion Control ID Profiles [RFC4341, RFC4342], may cause problems for some applications, including high-bandwidth interactive video. These applications should be able to use DCCP once suitable Congestion Control ID Profiles are standardized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、信頼性のないデータグラムのユニキャスト輻輳制御の流れを望む任意のアプリケーションに合うように、このドキュメントで説明されているDCCPのプロトコルメカニズム、のために意図しています。しかし、現在、別輻輳制御IDプロファイルに記載されているDCCP、[RFC4341、RFC4342]で使用するために承認された輻輳制御メカニズムは、高帯域幅のインタラクティブビデオを含むいくつかの用途のために問題を引き起こす可能性があります。これらのアプリケーションは、一度、適切な輻輳制御IDプロファイルが標準化されているDCCPを使用することができるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Conventions and Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.表記と用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります[RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Numbers and Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 数字とフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All multi-byte numerical quantities in DCCP, such as port numbers, Sequence Numbers, and arguments to options, are transmitted in network byte order (most significant byte first).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなポート番号、シーケンス番号、およびオプションの引数としてDCCPのすべてのマルチバイト数量は、ネットワークバイト順（最上位バイト）で送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We occasionally refer to the &#34;left&#34; and &#34;right&#34; sides of a bit field. &#34;Left&#34; means towards the most significant bit, and &#34;right&#34; means towards the least significant bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、時折ビットフィールドの「左」と「右」の側面を参照してください。 「左」、最上位ビットの方を意味し、「右」は最下位ビットの方を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Random numbers in DCCP are used for their security properties and SHOULD be chosen according to the guidelines in [RFC4086].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPにおける乱数は、それらのセキュリティ特性のために使用され、[RFC4086]のガイドラインに従って選択されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All operations on DCCP sequence numbers use circular arithmetic modulo 2^48, as do comparisons such as &#34;greater&#34; and &#34;greatest&#34;. This form of arithmetic preserves the relationships between sequence numbers as they roll over from 2^48 - 1 to 0. Implementation strategies for DCCP sequence numbers will resemble those for other circular arithmetic spaces, including TCP&#39;s sequence numbers [RFC793] and DNS&#39;s serial numbers [RFC1982]. It may make sense to store DCCP sequence numbers in the most significant 48 bits of 64-bit integers and set the least significant 16 bits to zero, since this supports a common technique that implements circular comparison A &lt; B by testing whether (A - B) &lt; 0 using conventional two&#39;s-complement arithmetic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような「大きい」と「最大」などの比較がそうであるようにDCCPのシーケンス番号に対するすべての操作は、円形算術法2 ^ 48を使用しています。 TCPのシーケンス番号[RFC793]とDNSのシリアル番号[含む他の円形の演算空間のものに似ているであろうDCCP配列番号1 0に実装戦略 - これらは2 ^ 48からロールオーバー等の演算のこの形態は、シーケンス番号との間の関係を維持しますRFC1982]。 B  - これは（Aかどうかをテストすることにより円形の比較A &lt;Bを実装する一般的な技術をサポートするので、それは、64ビット整数の最上位48ビットにDCCPシーケンス番号を格納し、ゼロに最下位16ビットを設定しても意味ができます）&lt;0従来の2の補数演算を使用して。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved bitfields in DCCP packet headers MUST be set to zero by senders and MUST be ignored by receivers, unless otherwise specified. This allows for future protocol extensions. In particular, DCCP processors MUST NOT reset a DCCP connection simply because a Reserved field has non-zero value [RFC3360].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPパケットヘッダ内の予約ビットフィールドは送信者によってゼロに設定しなければならなくて、特に断らない限り、受信機によって無視されなければなりません。これは、将来のプロトコル拡張が可能になります。 Reservedフィールドが非ゼロ値[RFC3360]を有しているという理由だけで、特に、DCCPプロセッサはDCCP接続をリセットしてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Parts of a Connection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 接続のパーツ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each DCCP connection runs between two hosts, which we often name DCCP A and DCCP B. Each connection is actively initiated by one of the hosts, which we call the client; the other, initially passive host is called the server. The term &#34;DCCP endpoint&#34; is used to refer to either of the two hosts explicitly named by the connection (the client and the server). The term &#34;DCCP processor&#34; refers more generally to any host that might need to process a DCCP header; this includes the endpoints and any middleboxes on the path, such as firewalls and network address translators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各DCCP接続は、我々は多くの場合、積極的に私たちは、クライアントを呼び出すホスト、のいずれかによって開始され、それぞれの接続DCCP AとDCCP B.に名前を付ける2つのホスト間で実行されます。その他、最初にパッシブホストがサーバーと呼ばれています。用語「DCCP終点は、」明示的な接続（クライアントとサーバ）によってという名前の2つのホストのいずれかを参照するために使用されます。用語「DCCPプロセッサ」はDCCPヘッダを処理する必要がある可能性があるホストに、より一般的にいいます。これは、ファイアウォールやネットワークアドレス変換などのエンドポイントと経路上の任意の中間装置を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP connections are bidirectional: data may pass from either endpoint to the other. This means that data and acknowledgements may flow in both directions simultaneously. Logically, however, a DCCP connection consists of two separate unidirectional connections, called half-connections. Each half-connection consists of the application data sent by one endpoint and the corresponding acknowledgements sent by the other endpoint. We can illustrate this as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP接続が双方向である：データは、他のエンドポイントのいずれかから渡してもよいです。これは、データおよび肯定応答は、同時に両方向に流れることができることを意味します。論理的には、しかし、DCCPコネクションはハーフ接続と呼ばれる2つの別々の単方向接続、構成されています。各半接続は、一方のエンドポイントによって送信されたアプリケーションデータ及び他のエンドポイントによって送信され、対応する肯定応答から成ります。次のように私たちは、これを説明することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +--------+  A-to-B half-connection:         +--------+
      |        |    --&gt;  application data  --&gt;    |        |
      |        |    &lt;--  acknowledgements  &lt;--    |        |
      | DCCP A |                                  | DCCP B |
      |        |  B-to-A half-connection:         |        |
      |        |    &lt;--  application data  &lt;--    |        |
      +--------+    --&gt;  acknowledgements  --&gt;    +--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although they are logically distinct, in practice the half-connections overlap; a DCCP-DataAck packet, for example, contains application data relevant to one half-connection and acknowledgement information relevant to the other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らは実際には、論理的に別個のものであるが、半接続が重なって。 DCCP-DataAckパケットは、例えば、1つの半接続および他の関連する送達確認情報に関連するアプリケーションデータを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the context of a single half-connection, the terms &#34;HC-Sender&#34; and &#34;HC-Receiver&#34; denote the endpoints sending application data and acknowledgements, respectively. For example, DCCP A is the HC-Sender and DCCP B is the HC-Receiver in the A-to-B half-connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一半接続の文脈において、用語「HC-送信者」及び「HC-受信機」は、それぞれ、アプリケーションデータおよび肯定応答を送信するエンドポイントを示します。例えば、DCCP Aは、HC-送信元であるとDCCP BはA対B半接続におけるHC-受信機です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 特徴
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP feature is a connection attribute on whose value the two endpoints agree. Many properties of a DCCP connection are controlled by features, including the congestion control mechanisms in use on the two half-connections. The endpoints achieve agreement through the exchange of feature negotiation options in DCCP headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPの機能は、その値が2つのエンドポイントが同意の接続属性です。 DCCP接続の多くの特性は、二つの半接続に使用されている輻輳制御機構を含む、機能によって制御されます。エンドポイントはDCCPヘッダーに特徴交渉オプションの交換を通じて合意を達成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP features are identified by a feature number and an endpoint. The notation &#34;F/X&#34; represents the feature with feature number F located at DCCP endpoint X. Each valid feature number thus corresponds to two features, which are negotiated separately and need not have the same value. The two endpoints know, and agree on, the value of every valid feature. DCCP A is the &#34;feature location&#34; for all features F/A, and the &#34;feature remote&#34; for all features F/B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPの特徴は、機能の数とエンドポイントによって識別されます。記号「F / X」DCCP終点Xの位置フィーチャー番号Fと機能を表す各有効な特徴数は、このように別々にネゴシエートと同じ値を有する必要はないされた2つの機能に対応します。 2つのエンドポイントは、すべての有効な機能の価値を知っている、と同意します。 DCCP Aは、すべてのための「特徴位置」とは、F / Aを備え、そしてすべての特徴F / Bは、「Remote機能」されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Round-Trip Times
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 往復時間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP round-trip time measurements are performed by congestion control mechanisms; different mechanisms may measure round-trip time in different ways, or not measure it at all. However, the main DCCP protocol does use round-trip times occasionally, such as in the initial values for certain timers. Each DCCP implementation thus defines a default round-trip time for use when no estimate is available. This parameter should default to not less than 0.2 seconds, a reasonably conservative round-trip time for Internet TCP connections. Protocol behavior specified in terms of &#34;round-trip time&#34; values actually refers to &#34;a current round-trip time estimate taken by some CCID, or, if no estimate is available, the default round-trip time parameter&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP往復時間測定は、輻輳制御機構によって実行されます。異なるメカニズムは異なる方法で往復時間を測定する、またはまったくそれを測定することができません。しかし、主DCCPプロトコルは、特定のタイマーの初期値と同様に、時折往復時間を使用しません。何の推定値が利用できない場合、各DCCPの実装は、このように使用するためのデフォルトのラウンドトリップ時間を定義します。このパラメータは、以下0.2秒以上、インターネットのTCP接続のための合理的に保守的な往復時間をデフォルトとすべきです。 「何の推定値は、デフォルトのラウンドトリップ時間パラメータ利用できない場合、いくつかのCCIDで撮影した現在の往復時間の見積もり、または」「往復時間」の値の観点から指定されたプロトコルの動作は、実際にを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The maximum segment lifetime, or MSL, is the maximum length of time a packet can survive in the network. The DCCP MSL should equal that of TCP, which is normally two minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大のセグメント生涯、またはMSL、パケットがネットワークの中で生き残ることができる時間の最大の長さです。 DCCP MSLは、通常は2分であるTCPのそれに等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Security Limitation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. セキュリティの制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP provides no protection against attackers who can snoop on a connection in progress, or who can guess valid sequence numbers in other ways. Applications desiring stronger security should use IPsec [RFC2401]; depending on the level of security required, application-level cryptography may also suffice. These issues are discussed further in Sections 7.5.5 and 18.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは、進行中の接続をスヌーピングすることができ、あるいは他の方法で有効なシーケンス番号を推測できる人攻撃に対する保護を提供していません。強力なセキュリティを希望するアプリケーションは、IPsec [RFC2401]を使用する必要があります。必要とされるセキュリティのレベルに応じて、アプリケーション・レベルの暗号化も十分です。これらの問題は、セクション7.5.5および18でさらに議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Robustness Principle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 堅牢性の原則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   DCCP implementations will follow TCP&#39;s &#34;general principle of
   robustness&#34;: &#34;be conservative in what you do, be liberal in what you
   accept from others&#34; [RFC793].
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP&#39;s high-level connection dynamics echo those of TCP. Connections progress through three phases: initiation, including a three-way handshake; data transfer; and termination. Data can flow both ways over the connection. An acknowledgement framework lets senders discover how much data has been lost and thus avoid unfairly congesting the network. Of course, DCCP provides unreliable datagram semantics, not TCP&#39;s reliable bytestream semantics. The application must package its data into explicit frames and must retransmit its own data as necessary. It may be useful to think of DCCP as TCP minus bytestream semantics and reliability, or as UDP plus congestion control, handshakes, and acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPの高レベルの接続力学はTCPのそれらをエコー。接続は3つの段階を経て進行する：開始、3ウェイハンドシェイクを含みます。データ転送;そして終了。データが接続を介して、両方の方法を流れることができます。承認フレームワークでは、送信者が失われたため、不当にネットワークを輻輳回避してきたどのくらいのデータを発見することができます。もちろん、DCCPは信頼性のないデータグラム意味論ではなく、TCPの信頼性の高いバイトストリームのセマンティクスを提供します。アプリケーションが明示的なフレームにそのデータをパッケージ化する必要があり、必要に応じて、独自のデータを再送信しなければなりません。 TCPマイナスバイトストリームセマンティクスと信頼性、またはUDPプラス輻輳制御、握手、および確認応答としてDCCPを考えることが有用であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Packet Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. パケットタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ten packet types implement DCCP&#39;s protocol functions. For example, every new connection attempt begins with a DCCP-Request packet sent by the client. In this way a DCCP-Request packet resembles a TCP SYN, but since DCCP-Request is a packet type there is no way to send an unexpected flag combination, such as TCP&#39;s SYN+FIN+ACK+RST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テンのパケットタイプは、DCCPのプロトコル機能を実装します。たとえば、すべての新しい接続試行は、クライアントから送信されたDCCP-Requestパケットで始まります。このように、DCCP-RequestパケットはTCP SYNに似ているが、DCCP-要求は、パケットの種類があるので、このようなTCPのSYN + FIN + ACK + RSTなどの予期しないフラグの組み合わせを、送信する方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eight packet types occur during the progress of a typical connection, shown here. Note the three-way handshakes during initiation and termination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
八のパケットタイプは、ここに示されている一般的な接続の進行中に発生します。開始と終了時の3ウェイハンドシェイクを注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Client                                      Server
      ------                                      ------
                       (1) Initiation
      DCCP-Request --&gt;
                                       &lt;-- DCCP-Response
      DCCP-Ack --&gt;
                       (2) Data transfer
      DCCP-Data, DCCP-Ack, DCCP-DataAck --&gt;
                   &lt;-- DCCP-Data, DCCP-Ack, DCCP-DataAck
                       (3) Termination
                                       &lt;-- DCCP-CloseReq
      DCCP-Close --&gt;
                                          &lt;-- DCCP-Reset
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two remaining packet types are used to resynchronize after bursts of loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りの2つのパケットタイプは、損失のバースト後に再同期するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every DCCP packet starts with a fixed-size generic header. Particular packet types include additional fixed-size header data; for example, DCCP-Acks include an Acknowledgement Number. DCCP options and any application data follow the fixed-size header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのDCCPパケットは、固定サイズの一般的なヘッダーで始まります。特定のパケットタイプは、追加の固定サイズ・ヘッダ・データを含みます。例えば、DCCP-ACKは確認応答番号が含まれます。 DCCPオプションと任意のアプリケーションデータは、固定サイズのヘッダに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet types are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにパケットの種類は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Request Sent by the client to initiate a connection (the first part of the three-way initiation handshake).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPリクエスト接続（三元開始ハンドシェークの最初の部分）を開始するためにクライアントによって送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Response Sent by the server in response to a DCCP-Request (the second part of the three-way initiation handshake).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-要求に応答してサーバによって送信されたDCCP  - 応答（三元開始ハンドシェークの第二部分）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Data Used to transmit application data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-データは、アプリケーション・データを送信するために使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Ack Used to transmit pure acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Ackのは、純粋な確認応答を送信するために使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-DataAck Used to transmit application data with piggybacked acknowledgement information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-DataAckは便乗送達確認情報とアプリケーションデータを送信するために使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-CloseReq Sent by the server to request that the client close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが接続を閉じることを要求するためにサーバーによって送信されDCCP-CloseReq。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Close Used by the client or the server to close the connection; elicits a DCCP-Reset in response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続を閉じるには、クライアントまたはサーバが使用するDCCP-閉じます。応答におけるDCCP-リセットを誘発します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Reset Used to terminate the connection, either normally or abnormally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-リセットはどちらか通常または異常、接続を終了するために使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Sync, DCCP-SyncAck Used to resynchronize sequence numbers after large bursts of loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-同期、DCCP-SyncAckは、損失の大バースト後のシーケンス番号を再同期するために使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Packet Sequencing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. パケットシーケンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each DCCP packet carries a sequence number so that losses can be detected and reported. Unlike TCP sequence numbers, which are byte-based, DCCP sequence numbers increment by one per packet. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
損失が検出されたと報告できるように、それぞれのDCCPパケットは、シーケンス番号を運びます。バイトベースでTCPシーケンス番号とは異なり、DCCPのシーケンス番号は、パケットごとに1ずつ増加。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      DCCP A                                      DCCP B
      ------                                      ------
      DCCP-Data(seqno 1) --&gt;
      DCCP-Data(seqno 2) --&gt;
                         &lt;-- DCCP-Ack(seqno 10, ackno 2)
      DCCP-DataAck(seqno 3, ackno 10) --&gt;
                                 &lt;-- DCCP-Data(seqno 11)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every DCCP packet increments the sequence number, whether or not it contains application data. DCCP-Ack pure acknowledgements increment the sequence number; for instance, DCCP B&#39;s second packet above uses sequence number 11, since sequence number 10 was used for an acknowledgement. This lets endpoints detect all packet loss, including acknowledgement loss. It also means that endpoints can get out of sync after long bursts of loss. The DCCP-Sync and DCCP-SyncAck packet types are used to recover (Section 7.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのDCCPパケットは、アプリケーションデータが含まれているかどうかにかかわらず、シーケンス番号をインクリメントします。 DCCP-Ackの純粋な肯定応答シーケンス番号をインクリメントします。配列番号10は、確認応答のために使用したので、例えば、DCCP Bの第2のパケットは、上記、配列番号11を使用します。これは、エンドポイントが確認応答損失を含む全てのパケットロスを検出することができます。また、エンドポイントが損失の長いバースト後の同期から抜け出すことができることを意味します。 DCCP-SyncとDCCP-SyncAckパケットタイプは（セクション7.5）を回収するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since DCCP provides unreliable semantics, there are no retransmissions, and having a TCP-style cumulative acknowledgement field doesn&#39;t make sense. DCCP&#39;s Acknowledgement Number field equals the greatest sequence number received, rather than the smallest sequence number not received. Separate options indicate any intermediate sequence numbers that weren&#39;t received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは信頼できないセマンティクスを提供しているので、そこには再送信されない、とTCP-スタイル累積確認応答フィールドを持つことは意味がありません。 DCCPの承認番号フィールドは、受信最大シーケンス番号ではなく、ない受け取った最小のシーケンス番号に等しいです。個別のオプションが受信されなかった任意の中間シーケンス番号を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. States
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. アメリカ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints progress through different states during the course of a connection, corresponding roughly to the three phases of initiation, data transfer, and termination. The figure below shows the typical progress through these states for a client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点は、開始、データ転送、および終了の三相にほぼ対応し、接続の過程の間の異なる状態を経て進行します。下の図は、クライアントとサーバのためにこれらの状態を経て、典型的な進行状況が表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Client                                             Server
      ------                                             ------
                        (0) No connection
      CLOSED                                             LISTEN
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 (1) Initiation REQUEST DCCP-Request --&gt; &lt;-- DCCP-Response RESPOND PARTOPEN DCCP-Ack or DCCP-DataAck --&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（1）開始要求DCCPリクエスト - &gt; &lt; -  DCCP-応答が応答PARTOPEN DCCP-ACKまたはDCCP-DataAck  - &gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 (2) Data transfer OPEN &lt;-- DCCP-Data, Ack, DataAck --&gt; OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt; -  DCCP-DATA、ACK、DataAck  - &gt; OPEN（2）データは、OPENを転送します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 (3) Termination &lt;-- DCCP-CloseReq CLOSEREQ CLOSING DCCP-Close --&gt; &lt;-- DCCP-Reset CLOSED TIMEWAIT CLOSED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（3）終了&lt; -  DCCP-CloseReqのCLOSEREQがDCCP-閉じるCLOSING  - &gt; &lt; -  DCCPリセットCLOSED TIMEWAITが閉じ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nine possible states are as follows. They are listed in increasing order, so that &#34;state &gt;= CLOSEREQ&#34; means the same as &#34;state = CLOSEREQ or state = CLOSING or state = TIMEWAIT&#34;. Section 8 describes the states in more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように9つの可能な状態です。 「&gt; = CLOSEREQ状態」が「状態= CLOSEREQまたは状態= CLOSINGまたは状態= TIMEWAIT」と同じことを意味するように、それらは、昇順にリストされています。第8章は、より詳細に状態を説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSED Represents nonexistent connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEDは存在しない接続を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LISTEN Represents server sockets in the passive listening state. LISTEN and CLOSED are not associated with any particular DCCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LISTENはパッシブリスニングステートのサーバソケットを表します。 LISTENとCLOSEDは、任意の特定のDCCP接続に関連付けられていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUEST A client socket enters this state, from CLOSED, after sending a DCCP-Request packet to try to initiate a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUESTは、クライアントソケットは、接続を開始しようとするDCCP-Requestパケットを送信した後、CLOSEDから、この状態に入ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESPOND A server socket enters this state, from LISTEN, after receiving a DCCP-Request from a client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバソケットは、クライアントからのDCCP-Requestを受け取った後、LISTENから、この状態に入り、応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PARTOPEN A client socket enters this state, from REQUEST, after receiving a DCCP-Response from the server. This state represents the third phase of the three-way handshake. The client may send application data in this state, but it MUST include an Acknowledgement Number on all of its packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PARTOPEN Aクライアントソケットは、サーバからDCCP-応答を受け取った後、REQUESTから、この状態に入ります。この状態は、スリーウェイハンドシェイクの第三相を表しています。クライアントは、この状態でアプリケーションデータを送ることができますが、それはそのパケットのすべての承認番号を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN The central data transfer portion of a DCCP connection. Client and server sockets enter this state from PARTOPEN and RESPOND, respectively. Sometimes we speak of SERVER-OPEN and CLIENT-OPEN states, corresponding to the server&#39;s OPEN state and the client&#39;s OPEN state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP接続の中央のデータ転送部を開きます。クライアントとサーバーのソケットはPARTOPENからこの状態に入り、それぞれ、対応しています。時々、私たちは、サーバのOPEN状態とクライアントのOPEN状態に対応し、SERVER-OPENおよびCLIENT-OPEN状態の話します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEREQ A server socket enters this state, from SERVER-OPEN, to order the client to close the connection and to hold TIMEWAIT state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEREQサーバソケットは、接続を閉じるには、クライアントを注文するとTIMEWAIT状態を保持するために、SERVER-OPENから、この状態に入ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSING Server and client sockets can both enter this state to close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSINGサーバーとクライアントのソケットは、接続を閉じるには、この状態に入ることができるの両方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TIMEWAIT A server or client socket remains in this state for 2MSL (4 minutes) after the connection has been torn down, to prevent mistakes due to the delivery of old packets. Only one of the endpoints has to enter TIMEWAIT state (the other can enter CLOSED state immediately), and a server can request its client to hold TIMEWAIT state using the DCCP-CloseReq packet type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TIMEWAITは、サーバーまたはクライアントソケットは、接続は切断された後2MSL（4分）については、この状態のまま、古いパケットの配信に起因するミスを防ぐために。唯一のエンドポイントの1つは、（他はすぐにCLOSED状態に入ることができる）TIMEWAIT状態に入る必要があり、サーバがDCCP-CloseReqパケットタイプを使用してTIMEWAIT状態を保持するために、そのクライアントを要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Congestion Control Mechanisms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 輻輳制御機構
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP connections are congestion controlled, but unlike in TCP, DCCP applications have a choice of congestion control mechanism. In fact, the two half-connections can be governed by different mechanisms. Mechanisms are denoted by one-byte congestion control identifiers, or CCIDs. The endpoints negotiate their CCIDs during connection initiation. Each CCID describes how the HC-Sender limits data packet rates, how the HC-Receiver sends congestion feedback via acknowledgements, and so forth. CCIDs 2 and 3 are currently defined; CCIDs 0, 1, and 4-255 are reserved. Other CCIDs may be defined in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPコネクションは、輻輳制御ですが、TCPとは異なり、DCCPアプリケーションは、輻輳制御機構の選択肢があります。実際には、二つの半接続は異なるメカニズムによって支配することができます。メカニズムは、1バイトの輻輳制御識別子、またはのCCIDsで示されています。エンドポイントは、接続開始時に自分のCCIDsを交渉します。各CCIDは、HC-Receiverのなどの承認を経て、輻輳フィードバックを送信し、どのように、どのようにHC-送信者の制限、データパケットのレートを記述する。 CCIDs 2及び3は、現在定義されています。 CCIDs 0,1、及び4から255は予約されています。その他のCCIDsは、将来的に定義されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 2 provides TCP-like Congestion Control, which is similar to that of TCP. The sender maintains a congestion window and sends packets until that window is full. Packets are acknowledged by the receiver. Dropped packets and ECN [RFC3168] indicate congestion; the response to congestion is to halve the congestion window. Acknowledgements in CCID 2 contain the sequence numbers of all received packets within some window, similar to a selective acknowledgement (SACK) [RFC2018].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 2は、TCPと同様であるTCPのような輻輳制御を提供します。送信者は輻輳ウィンドウを維持し、そのウィンドウがいっぱいになるまでパケットを送信します。パケットは、受信機によって確認されます。ドロップされたパケットとECNは、[RFC3168]の輻輳を示します。混雑への応答は、輻輳ウィンドウを半分にすることです。 CCID 2の肯定応答は、選択的確認応答（SACK）[RFC2018]と同様、いくつかのウィンドウ内のすべての受信パケットのシーケンス番号を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 3 provides TCP-Friendly Rate Control (TFRC), an equation-based form of congestion control intended to respond to congestion more smoothly than CCID 2. The sender maintains a transmit rate, which it updates using the receiver&#39;s estimate of the packet loss and mark rate. CCID 3 behaves somewhat differently than TCP in the short term, but is designed to operate fairly with TCP over the long term.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 3は、TCPフレンドリーレート制御（TFRC）、送信側は、パケットロスの受信機の推定値とを用いて更新する送信レートを維持CCID 2よりもより円滑輻輳に応答するように意図され、輻輳制御の方程式ベースのフォームを提供しますマーク率。 CCID 3は、短期的には多少異なるTCPよりも動作しますが、長期的にTCPと公平に動作するように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 10 describes DCCP&#39;s CCIDs in more detail. The behaviors of CCIDs 2 and 3 are fully defined in separate profile documents [RFC4341, RFC4342].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション10は、より詳細にDCCPののCCIDsを説明しています。 CCIDs 2及び3の動作は完全に別々のプロファイルドキュメント[RFC4341、RFC4342]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Feature Negotiation Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. 特徴交渉オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints use Change and Confirm options to negotiate and agree on feature values. Feature negotiation will almost always happen on the connection initiation handshake, but it can begin at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点は、変更を使用し、交渉し、特徴値に同意するオプションを確認してください。機能の交渉は、ほとんどの場合、接続開始握手に発生しますが、それはいつでも始めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are four feature negotiation options in all: Change L, Confirm L, Change R, and Confirm R. The &#34;L&#34; options are sent by the feature location and the &#34;R&#34; options are sent by the feature remote. A Change R option says to the feature location, &#34;change this feature value as follows&#34;. The feature location responds with Confirm L, meaning, &#34;I&#39;ve changed it&#34;. Some features allow Change R options to contain multiple values sorted in preference order. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更L、L、変更Rを確認し、「L」オプションが機能リモートによって送信された特徴位置と「R」のオプションによって送信されたR.確認：4つの全部で特徴交渉オプションがあります。変更Rオプションは、「この機能は、次のように値を変更する」、特徴位置に言います。特徴位置は、「私はそれを変更した」、という意味、確認Lで応答します。一部の機能は変更Rオプションは、優先順にソートされた複数の値を含めることができます。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Client                                        Server
      ------                                        ------
      Change R(CCID, 2) --&gt;
                                    &lt;-- Confirm L(CCID, 2)
                 * agreement that CCID/Server = 2 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Change R(CCID, 3 4) --&gt; &lt;-- Confirm L(CCID, 4, 4 2) * agreement that CCID/Server = 4 *
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
変更R（CCID、3 4） - &gt; &lt; -  Lを確認し（CCID、4,4 2）*契約CCID /サーバ= 4 *
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both exchanges negotiate the CCID/Server feature&#39;s value, which is the CCID in use on the server-to-client half-connection. In the second exchange, the client requests that the server use either CCID 3 or CCID 4, with 3 preferred; the server chooses 4 and supplies its preference list, &#34;4 2&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらの交換は、サーバからクライアントへの半分の接続に使用してCCIDあるCCID /サーバ機能の値を、交渉します。第二の交換、サーバー使用CCID 3又は好適3とCCID 4、いずれかのクライアント要求に、サーバーは、「4 2」、4を選択し、その優先リストを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Change L and Confirm R options are used for feature negotiations initiated by the feature location. In the following example, the server requests that CCID/Server be set to 3 or 2, with 3 preferred, and the client agrees.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更Lとは、Rオプションは特徴位置によって開始された特徴交渉のために使用されていることを確認します。次の例では、CCID /サーバが3または2に設定するサーバー要求は、3が好ましく、そしてクライアントが同意します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Client                                       Server
      ------                                       ------
                                  &lt;-- Change L(CCID, 3 2)
      Confirm R(CCID, 3, 3 2)  --&gt;
                 * agreement that CCID/Server = 3 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 6 describes the feature negotiation options further, including the retransmission strategies that make negotiation reliable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第6節は、交渉が信頼できるように再送戦略を含めた更なる特徴交渉オプションについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Differences from TCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.  TCPとの違い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP&#39;s differences from TCP apart from those discussed so far include the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPからのDCCPの違いは別に議論したから、これまでに次のものがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Copious space for options (up to 1008 bytes or the PMTU).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oオプション（最大1008バイトまたはPMTU）のために多量のスペース。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Different acknowledgement formats. The CCID for a connection determines how much acknowledgement information needs to be transmitted. For example, in CCID 2 (TCP-like), this is about one ack per 2 packets, and each ack must declare exactly which packets were received. In CCID 3 (TFRC), it is about one ack per round-trip time, and acks must declare at minimum just the lengths of recent loss intervals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の確認応答形式O。接続用のCCIDは、多くの送達確認情報を送信する必要がある方法を決定します。例えば、CCID 2（TCPのような）で、これは2つのパケット当たり約ACKあり、各ACKは、パケットが受信された正確に宣言しなければなりません。 CCID 3（TFRC）では、往復時間あたり約1 ACKで、ACKは最低でも最近の損失間隔のちょうど長さを宣言する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Denial of Service (DoS) protection. Several mechanisms help limit the amount of state that possibly-misbehaving clients can force DCCP servers to maintain. An Init Cookie option analogous to TCP&#39;s SYN Cookies [SYNCOOKIES] avoids SYN-flood-like attacks. Only one connection endpoint has to hold TIMEWAIT state; the DCCP-CloseReq packet, which may only be sent by the server, passes that state to the client. Various rate limits let servers avoid attacks that might force extensive computation or packet generation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサービス拒否（DoS）の保護。いくつかのメカニズムは、おそらく、ふらちなクライアントが維持するために、DCCPサーバを強制することができる状態の量を制限するのに役立ちます。 [syncookies機能] TCPのSYNクッキーに類似のInit Cookieのオプションは、SYNフラッドのような攻撃を回避します。一つだけ接続エンドポイントはTIMEWAIT状態を保持する必要があります。唯一のサーバーによって送信されることがDCCP-CloseReqパケットは、クライアントにその状態を渡します。様々なレート制限は、サーバが大規模な計算やパケットの生成を強制するかもしれない攻撃を避けるましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Distinguishing different kinds of loss. A Data Dropped option (Section 11.7) lets an endpoint declare that a packet was dropped because of corruption, because of receive buffer overflow, and so on. This facilitates research into more appropriate rate-control responses for these non-network-congestion losses (although currently such losses will cause a congestion response).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O損失の異なる種類を区別。データは、オプション（11.7節）エンドポイントがそうであるため、バッファオーバーフローを受けるのは、パケットが原因で破損のドロップされたことを宣言し、することができますを落としました。 （現在、このような損失が輻輳応答を引き起こしますが）これは、これらの非ネットワークの混雑の損失のためのより適切な速度制御応答の研究を促進します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Acknowledgeability. In TCP, a packet may be acknowledged only once the data is reliably queued for application delivery. This does not make sense in DCCP, where an application might, for example, request a drop-from-front receive buffer. A DCCP packet may be acknowledged as soon as its header has been successfully processed. Concretely, a packet becomes acknowledgeable at Step 8 of Section 8.5&#39;s packet processing pseudocode. Acknowledgeability does not guarantee data delivery, however: the Data Dropped option may later report that the packet&#39;s application data was discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Acknowledgeability O。 TCPでは、パケットは、データを確実にアプリケーション配信のためにキューイングされて一度だけ認めていてもよいです。これは、アプリケーションが、例えば、ドロップからフロントを要求バッファを受け取ることがありますDCCPに意味がありません。 DCCPパケットは、すぐにそのヘッダが正常に処理されたと認定することができます。具体的には、パケットは、セクション8.5のパケット処理の擬似コードのステップ8で受け付け可能となります。 Acknowledgeabilityしかし、データの配信を保証するものではありません：データドロップオプションは、後に、パケットのアプリケーションデータが破棄されたことを報告することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o No receive window. DCCP is a congestion control protocol, not a flow control protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oノーウィンドウを受け取ります。 DCCP輻輳制御プロトコルではなく、フロー制御プロトコルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o No simultaneous open. Every connection has one client and one server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノー同時オープンO。すべての接続は、1つのクライアントと一つのサーバを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o No half-closed states. DCCP has no states corresponding to TCP&#39;s FINWAIT and CLOSEWAIT, where one half-connection is explicitly closed while the other is still active. The Data Dropped option&#39;s Drop Code 1, Application Not Listening (Section 11.7), can achieve a similar effect, however.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノー半分閉じた状態O。 DCCPは他がまだアクティブである間、1つの半接続を明示的にクローズされるTCPのFINWAITとCLOSEWAIT、に対応する状態を持っていません。データは、オプションのドロップコード1、（セクション11.7を）聞いていないアプリケーションを落とし、しかし、同様の効果を得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. Example Connection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. 接続例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The progress of a typical DCCP connection is as follows. (This description is informative, not normative.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように一般的なDCCP接続の進行があります。 （この記述は規範的、有益ではありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          Client                                  Server
          ------                                  ------
      0.  [CLOSED]                              [LISTEN]
      1.  DCCP-Request --&gt;
      2.                               &lt;-- DCCP-Response
      3.  DCCP-Ack --&gt;
      4.  DCCP-Data, DCCP-Ack, DCCP-DataAck --&gt;
                   &lt;-- DCCP-Data, DCCP-Ack, DCCP-DataAck
      5.                               &lt;-- DCCP-CloseReq
      6.  DCCP-Close --&gt;
      7.                                  &lt;-- DCCP-Reset
      8.  [TIMEWAIT]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The client sends the server a DCCP-Request packet specifying the client and server ports, the service being requested, and any features being negotiated, including the CCID that the client would like the server to use. The client may optionally piggyback an application request on the DCCP-Request packet. The server may ignore this application request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.クライアントは、サーバがクライアントとサーバのポートを指定するDCCP-Requestパケット送信し、サービスが要求されている、とすべての機能は、クライアントがサーバーを使用したいCCIDを含め、交渉中。クライアントは、必要に応じてDCCP-Requestパケット上のアプリケーション要求を背負うことがあります。サーバーは、このアプリケーションの要求を無視することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The server sends the client a DCCP-Response packet indicating that it is willing to communicate with the client. This response indicates any features and options that the server agrees to, begins other feature negotiations as desired, and optionally includes Init Cookies that wrap up all this information and that must be returned by the client for the connection to complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.サーバーはクライアントに、クライアントと通信する意志があることを示すDCCP-Responseパケットを送信します。この応答は、サーバがすることに同意する任意の機能とオプションを示し、必要に応じて他の機能の交渉を開始し、必要に応じて、このすべての情報をラップし、それが完了するの接続のために、クライアントによって返されなければならない初期のクッキーが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The client sends the server a DCCP-Ack packet that acknowledges the DCCP-Response packet. This acknowledges the server&#39;s initial sequence number and returns any Init Cookies in the DCCP-Response. It may also continue feature negotiation. The client may piggyback an application-level request on this ack, producing a DCCP-DataAck packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.クライアントは、サーバにDCCP-Responseパケットを承認DCCP-Ackパケットを送信します。これは、サーバの初期シーケンス番号を認識し、DCCP-応答で任意の初期クッキーを返します。また、機能の交渉を継続してもよいです。クライアントは、DCCP-DataAckパケットを生成し、このACK上のアプリケーションレベルの要求を背負うことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The server and client then exchange DCCP-Data packets, DCCP-Ack packets acknowledging that data, and, optionally, DCCP-DataAck packets containing data with piggybacked acknowledgements. If the client has no data to send, then the server will send DCCP-Data and DCCP-DataAck packets, while the client will send DCCP-Acks exclusively. (However, the client may not send DCCP-Data packets before receiving at least one non-DCCP-Response packet from the server.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.サーバとクライアントは、次に、DCCP-ACKパケットは、必要に応じて、DCCP-DataAckパケットがピギーバック肯定応答とデータを含む、そのデータを認め、そして、DCCP  - データパケットを交換します。クライアントが送信するデータがない場合は、クライアントが独占的にDCCP-ACKを送信する一方、サーバは、DCCP-データとDCCP-DataAckパケットを送信します。 （ただし、クライアントは、サーバから少なくとも1つの非DCCP-Responseパケットを受信する前にDCCP  - データパケットを送信しない場合があります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. The server sends a DCCP-CloseReq packet requesting a close.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.サーバーがクローズを要求DCCP-CloseReqパケットを送信します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. The client sends a DCCP-Close packet acknowledging the close.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.クライアントが近くを認めDCCP-閉じるパケットを送信します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The server sends a DCCP-Reset packet with Reset Code 1, &#34;Closed&#34;, and clears its connection state. DCCP-Resets are part of normal connection termination; see Section 5.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7.サーバは、「クローズ」、リセットコード1とDCCP-リセットパケットを送信し、その接続状態をクリアします。 DCCP-リセットは、通常の接続終端の一部です。セクション5.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. The client receives the DCCP-Reset packet and holds state for two maximum segment lifetimes, or 2MSL, to allow any remaining packets to clear the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8.クライアントはDCCP  - リセットパケットを受信し、残りのパケットがネットワークをクリアできるようにするために、2つの最大セグメント寿命、または2MSLの状態を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative connection closedown sequence is initiated by the client:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代替接続閉止シーケンスは、クライアントによって開始されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5b. The client sends a DCCP-Close packet closing the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図5b。クライアントが接続を閉じるDCCP-閉じるパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6b. The server sends a DCCP-Reset packet with Reset Code 1, &#34;Closed&#34;, and clears its connection state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図6b。サーバは、「クローズ」リセットコード1とDCCP-リセットパケットを送信し、その接続状態をクリアします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7b. The client receives the DCCP-Reset packet and holds state for 2MSL to allow any remaining packets to clear the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図7b。クライアントは、DCCP-リセットパケットを受信して​​、残りのパケットがネットワークをクリアできるようにするために2MSLの状態を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Packet Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.パケットフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DCCP header can be from 12 to 1020 bytes long. The initial part of the header has the same semantics for all currently defined packet types. Following this comes any additional fixed-length fields required by the packet type, and then a variable-length list of options. The application data area follows the header. In some packet types, this area contains data for the application; in other packet types, its contents are ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPヘッダーは12 1020バイトより長くすることができます。ヘッダの最初の部分は、現在定義されているすべてのパケットタイプについて同じ意味を有します。続いて、これはその後、追加の固定長パケットの種類によって必要なフィールド、およびオプションの可変長リストを付属しています。アプリケーションデータ領域は、ヘッダの後に続きます。いくつかのパケットタイプでは、このエリアには、アプリケーションのためのデータが含まれています。他のパケットタイプで、その内容は無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +---------------------------------------+  -.
      |            Generic Header             |   |
      +---------------------------------------+   |
      | Additional Fields (depending on type) |   +- DCCP Header
      +---------------------------------------+   |
      |          Options (optional)           |   |
      +=======================================+  -&#39;
      |         Application Data Area         |
      +---------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Generic Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 一般ヘッダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DCCP generic header takes different forms depending on the value of X, the Extended Sequence Numbers bit. If X is one, the Sequence Number field is 48 bits long, and the generic header takes 16 bytes, as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPジェネリックヘッダはX、拡張シーケンス番号のビットの値に応じて異なる形式をとります。 Xが1である場合、シーケンス番号フィールドは48ビット長であり、以下のようにジェネリックヘッダは、16のバイトを要します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Source Port          |           Dest Port           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Data Offset  | CCVal | CsCov |           Checksum            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     |       |X|               |                               .
      | Res | Type  |=|   Reserved    |  Sequence Number (high bits)  .
      |     |       |1|               |                               .
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      .                  Sequence Number (low bits)                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If X is zero, only the low 24 bits of the Sequence Number are transmitted, and the generic header is 12 bytes long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Xがゼロである場合、シーケンス番号だけ低い24ビットが送信され、ジェネリックヘッダは12バイト長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Source Port          |           Dest Port           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Data Offset  | CCVal | CsCov |           Checksum            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     |       |X|                                               |
      | Res | Type  |=|          Sequence Number (low bits)           |
      |     |       |0|                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The generic header fields are defined as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにジェネリックヘッダフィールドが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source and Destination Ports: 16 bits each These fields identify the connection, similar to the corresponding fields in TCP and UDP. The Source Port represents the relevant port on the endpoint that sent this packet, and the Destination Port represents the relevant port on the other endpoint. When initiating a connection, the client SHOULD choose its Source Port randomly to reduce the likelihood of attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信元ポートと宛先ポート：16ビットの各これらのフィールドは、TCPとUDPの対応するフィールドと同様の接続を、識別します。送信元ポートは、このパケットを送信したエンドポイントに関連するポートを表し、および宛先ポートは、他のエンドポイント上の関連するポートを表します。接続を開始すると、クライアントは、攻撃の可能性を低減するために、ランダムにその送信元ポートを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DCCP APIs should treat port numbers similarly to TCP and UDP port numbers. For example, machines that distinguish between &#34;privileged&#34; and &#34;unprivileged&#34; ports for TCP and UDP should do the same for DCCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DCCP APIは、TCPとUDPのポート番号と同様にポート番号を扱う必要があります。たとえば、TCPとUDPのための「特権」と「非特権」ポートを区別マシンはDCCPのために同じことを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Offset: 8 bits The offset from the start of the packet&#39;s DCCP header to the start of its application data area, in 32-bit words. The receiver MUST ignore packets whose Data Offset is smaller than the minimum-sized header for the given Type or larger than the DCCP packet itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データオフセット：8ビット、32ビット・ワードで、そのアプリケーションデータ領域の先頭にパケットのDCCPヘッダの先頭からのオフセット。受信機は、そのデータオフセットDCCPパケット自体よりも所与のタイプ以上の最小サイズのヘッダより小さいパケットを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCVal: 4 bits Used by the HC-Sender CCID. For example, the A-to-B CCID&#39;s sender, which is active at DCCP A, MAY send 4 bits of information per packet to its receiver by encoding that information in CCVal. The sender MUST set CCVal to zero unless its HC-Sender CCID specifies otherwise, and the receiver MUST ignore the CCVal field unless its HC-Receiver CCID specifies otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCVal：HC-送信者CCIDによって使用される4ビット。例えば、DCCP Aで活性であるA対B CCIDの送信者は、CCValにその情報を符号化することにより、その受信機にパケット当たり4ビットの情報を送信することができます。そのHC-SenderのCCIDは、別段の指定がない限り、送信者はゼロにCCValを設定しなければなりません、そのHCレシーバCCIDが別途指定しない限り、受信機はCCValフィールドを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Checksum Coverage (CsCov): 4 bits Checksum Coverage determines the parts of the packet that are covered by the Checksum field. This always includes the DCCP header and options, but some or all of the application data may be excluded. This can improve performance on noisy links for applications that can tolerate corruption. See Section 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チェックサム・カバレッジ（CsCov）：4ビットのチェックサム・カバレッジは、チェックサムフィールドによって覆われているパケットの部分を決定します。これは、常にDCCPヘッダーとオプションを含むが、アプリケーションデータの一部またはすべてが除外されてもよいです。これは、破損を許容できるアプリケーションのための騒がしいリンク上のパフォーマンスを向上させることができます。第9章を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Checksum: 16 bits The Internet checksum of the packet&#39;s DCCP header (including options), a network-layer pseudoheader, and, depending on Checksum Coverage, all, some, or none of the application data. See Section 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チェックサム：16ビット（オプションを含む）パケットのDCCPヘッダーのインターネットチェックサム、ネットワーク層擬似ヘッダ、及び、チェックサム・カバレッジ、すべて、一部、またはアプリケーション・データのどれに応じ。第9章を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved (Res): 3 bits Senders MUST set this field to all zeroes on generated packets, and receivers MUST ignore its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予約（RES）：3ビットの送信者は、生成されたパケットのすべてゼロにこのフィールドを設定しなければなりません、そして受信機は、その値を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type: 4 bits The Type field specifies the type of the packet. The following values are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ：4ビットのTypeフィールドは、パケットの種類を指定します。次の値が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                         Type   Meaning
                         ----   -------
                           0    DCCP-Request
                           1    DCCP-Response
                           2    DCCP-Data
                           3    DCCP-Ack
                           4    DCCP-DataAck
                           5    DCCP-CloseReq
                           6    DCCP-Close
                           7    DCCP-Reset
                           8    DCCP-Sync
                           9    DCCP-SyncAck
                         10-15  Reserved
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Table 1: DCCP Packet Types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
表1：DCCPパケットタイプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Receivers MUST ignore any packets with reserved type. That is, packets with reserved type MUST NOT be processed, and they MUST NOT be acknowledged as received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
レシーバは、予約タイプを持つパケットを無視しなければなりません。これは、予約型のパケットを処理してはならない、と受け取ったとして、彼らは認めてはならない、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extended Sequence Numbers (X): 1 bit Set to one to indicate the use of an extended generic header with 48-bit Sequence and Acknowledgement Numbers. DCCP-Data, DCCP-DataAck, and DCCP-Ack packets MAY set X to zero or one. All DCCP-Request, DCCP-Response, DCCP-CloseReq, DCCP-Close, DCCP-Reset, DCCP-Sync, and DCCP-SyncAck packets MUST set X to one; endpoints MUST ignore any such packets with X set to zero. High-rate connections SHOULD set X to one on all packets to gain increased protection against wrapped sequence numbers and attacks. See Section 7.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張シーケンス番号（X）：1ビットは、48ビットのシーケンスおよび確認応答番号の拡張ジェネリックヘッダの使用を示すために1に設定します。 DCCP-データ、DCCP-DataAck、およびDCCP-ACKパケットは、0または1にXを設定してもよいです。すべてのDCCP-要求、DCCP-応答、DCCP-CloseReq、DCCP-クローズ、DCCP-リセット、DCCP-同期、およびDCCP-SyncAckパケットは1つにXを設定しなければなりません。エンドポイントはゼロにXが設定された任意のそのようなパケットを無視しなければなりません。高レート接続は、ラップシーケンス番号と攻撃に対する保護を強化を得るために、すべてのパケット上のものにXを設定する必要があります。 7.6節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sequence Number: 48 or 24 bits Identifies the packet uniquely in the sequence of all packets the source sent on this connection. Sequence Number increases by one with every packet sent, including packets such as DCCP-Ack that carry no application data. See Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配列番号：48個のまたは24ビットがすべてのパケットのシーケンスに一意この接続上で送信されたソースパケットを識別する。シーケンス番号には、アプリケーションデータを運ぶないようDCCP-ACKとパケットを含むすべてのパケット送信とのいずれかによって増加します。セクション7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All currently defined packet types except DCCP-Request and DCCP-Data carry an Acknowledgement Number Subheader in the four or eight bytes immediately following the generic header. When X=1, its format is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-要求とDCCP-データを除くすべての現在定義されたパケットタイプは、一般的なヘッダの直後に4つのまたは8バイトに確認応答番号サブヘッダを運びます。場合X = 1、そのフォーマットは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Reserved            |    Acknowledgement Number     .
      |                               |          (high bits)          .
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      .               Acknowledgement Number (low bits)               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When X=0, only the low 24 bits of the Acknowledgement Number are transmitted, giving the Acknowledgement Number Subheader this format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X = 0、のみ確認応答番号の下位24ビットが送信されると、確認応答番号サブヘッダにこのフォーマットを与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Reserved    |       Acknowledgement Number (low bits)       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved: 16 or 8 bits Senders MUST set this field to all zeroes on generated packets, and receivers MUST ignore its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予約：16または8ビットの送信者が生成されたパケットのすべてゼロにこのフィールドを設定しなければなりません、そして受信機がその値を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Acknowledgement Number: 48 or 24 bits Generally contains GSR, the Greatest Sequence Number Received on any acknowledgeable packet so far. A packet is acknowledgeable if and only if its header was successfully processed by the receiver; Section 7.4 describes this further. Options such as Ack Vector (Section 11.4) combine with the Acknowledgement Number to provide precise information about which packets have arrived.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
謝辞番号：48または24ビットが一般的GSR、これまでの任意の承認可能パケットで最もすばらしいSequence Number Receivedが含まれています。そのヘッダが正常に受信機によって処理された場合だけパケットが承認可能です。 7.4節ではこれをさらに説明します。このようAckをベクトル（11.4節）などのオプションは、パケットが到着したかについての正確な情報を提供するために、承認番号と組み合わせます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Acknowledgement Numbers on DCCP-Sync and DCCP-SyncAck packets need not equal GSR. See Section 5.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DCCP-SyncとDCCP-SyncAckパケットの確認応答番号は、GSRを等しくする必要はありません。 5.7節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. DCCP-Request Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.  DCCP-Requestパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client initiates a DCCP connection by sending a DCCP-Request packet. These packets MAY contain application data and MUST use 48-bit sequence numbers (X=1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、DCCP-Requestパケットを送信することにより、DCCP接続を開始します。これらのパケットは、アプリケーションデータを含んでいてもよく、48ビットのシーケンス番号（X = 1）を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /                   with Type=0 (DCCP-Request)                  /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Service Code                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                       Application Data                        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Service Code: 32 bits Describes the application-level service to which the client application wants to connect. Service Codes are intended to provide information about which application protocol a connection intends to use, thus aiding middleboxes and reducing reliance on globally well-known ports. See Section 8.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サービスコード：32ビットのクライアント・アプリケーションは、接続したいとアプリケーションレベルのサービスを記述します。サービスコードは、このようにミドルボックスを支援し、世界的に有名なポートへの依存を減らし、接続が使用することを意図しているアプリケーションプロトコルに関する情報を提供することを意図しています。 8.1.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. DCCP-Response Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.  DCCP-応答パケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server responds to valid DCCP-Request packets with DCCP-Response packets. This is the second phase of the three-way handshake. DCCP-Response packets MAY contain application data and MUST use 48-bit sequence numbers (X=1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはDCCP-応答パケットで有効なDCCP-Requestパケットに応答します。これは、3ウェイハンドシェイクの第二段階です。 DCCP  - 応答パケットは、アプリケーション・データを含んでいてもよく、48ビットのシーケンス番号（X = 1）を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /                  with Type=1 (DCCP-Response)                  /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /          Acknowledgement Number Subheader (8 bytes)           /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Service Code                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                       Application Data                        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Acknowledgement Number: 48 bits Contains GSR. Since DCCP-Responses are only sent during connection initiation, this will always equal the Sequence Number on a received DCCP-Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
謝辞数：48ビットは、GSRが含まれています。 DCCP-応答のみ接続開始時に送信されますので、これは常に受信DCCP-要求のシーケンス番号に等しくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Service Code: 32 bits MUST equal the Service Code on the corresponding DCCP-Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サービスコード：32ビットは、対応するDCCP-要求にサービスコードを等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. DCCP-Data, DCCP-Ack, and DCCP-DataAck Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.  DCCP-データ、DCCP-ACK、およびDCCP-DataAckパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The central data transfer portion of every DCCP connection uses DCCP-Data, DCCP-Ack, and DCCP-DataAck packets. These packets MAY use 24-bit sequence numbers, depending on the value of the Allow Short Sequence Numbers feature (Section 7.6.1). DCCP-Data packets carry application data without acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのDCCP接続の中央のデータ転送部は、DCCP-データ、DCCP-ACK、およびDCCP-DataAckパケットを使用します。これらのパケットは許可ショートシーケンス番号機能（7.6.1項）の値に応じて、24ビットのシーケンス番号を使用するかもしれません。 DCCP  - データパケットは、確認応答なしにアプリケーションデータを運びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /              Generic DCCP Header (16 or 12 bytes)             /
      /                    with Type=2 (DCCP-Data)                    /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                       Application Data                        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Ack packets dispense with the data but contain an Acknowledgement Number. They are used for pure acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-ACKパケットはデータを省くが、確認応答番号が含まれています。彼らは純粋な受信確認のために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /              Generic DCCP Header (16 or 12 bytes)             /
      /                    with Type=3 (DCCP-Ack)                     /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /        Acknowledgement Number Subheader (8 or 4 bytes)        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                Application Data Area (Ignored)                /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-DataAck packets carry both application data and an Acknowledgement Number. This piggybacks acknowledgement information on a data packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-DataAckパケットは、アプリケーションデータと確認応答番号の両方を運びます。これは、データパケットの送達確認情報をピギーバックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /              Generic DCCP Header (16 or 12 bytes)             /
      /                  with Type=4 (DCCP-DataAck)                   /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /        Acknowledgement Number Subheader (8 or 4 bytes)        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                       Application Data                        /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP-Data or DCCP-DataAck packet may have a zero-length application data area, which indicates that the application sent a zero-length datagram. This differs from DCCP-Request and DCCP-Response packets, where an empty application data area indicates the absence of application data (not the presence of zero-length application data). The API SHOULD report any received zero-length datagrams to the receiving application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-データまたはDCCP-DataAckパケットは、アプリケーションが長さゼロのデータグラムを送信したことを示し、ゼロレングスアプリケーションデータ領域を有していてもよいです。これは、空のアプリケーションデータ領域は、アプリケーションデータがない（ゼロでない長さのアプリケーションデータの有無）を示すDCCP  - 要求とDCCP  - 応答パケットとは異なります。 APIは、受信側アプリケーションへの受信長さがゼロのデータグラムを報告する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP-Ack packet MAY have a non-zero-length application data area, which essentially pads the DCCP-Ack to a desired length. Receivers MUST ignore the content of the application data area in DCCP-Ack packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Ackパケットは、本質的に所望の長さにDCCP-ACKをパッド非ゼロレングスアプリケーションデータ領域を有していてもよいです。受信機はDCCP-ACKパケットにおけるアプリケーションデータ領域の内容を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Ack and DCCP-DataAck packets often include additional acknowledgement options, such as Ack Vector, as required by the congestion control mechanism in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-ACKおよびDCCP-DataAckパケットは、多くの場合、使用中の輻輳制御機構によって要求されるように、そのような肯定応答ベクトルなどの追加の肯定応答オプションを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. DCCP-CloseReq and DCCP-Close Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.  DCCP-CloseReqとDCCP-閉じるパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-CloseReq and DCCP-Close packets begin the handshake that normally terminates a connection. Either client or server may send a DCCP-Close packet, which will elicit a DCCP-Reset packet. Only the server can send a DCCP-CloseReq packet, which indicates that the server wants to close the connection but does not want to hold its TIMEWAIT state. Both packet types MUST use 48-bit sequence numbers (X=1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-CloseReqとDCCP-閉じるパケットが正常に接続を終了ハンドシェイクを開始します。クライアントまたはサーバのどちらかがDCCP-リセットパケットを誘発するDCCP-閉じるパケットを送信することができます。唯一のサーバは、サーバが接続を閉じるように望んでいることを示しているが、そのTIMEWAIT状態を保持したくないDCCP-CloseReqパケットを、送信することができます。両方のパケットタイプは、48ビットのシーケンス番号（X = 1）を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /         with Type=5 (DCCP-CloseReq) or 6 (DCCP-Close)         /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /          Acknowledgement Number Subheader (8 bytes)           /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                Application Data Area (Ignored)                /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with DCCP-Ack packets, DCCP-CloseReq and DCCP-Close packets MAY have non-zero-length application data areas, whose contents receivers MUST ignore.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-ACKパケット、DCCP-CloseReqとDCCP-閉じるパケットと同様にその内容が受信機は無視しなければならない非ゼロ長アプリケーションデータ領域を有していてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. DCCP-Reset Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6.  DCCP-リセットパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Reset packets unconditionally shut down a connection. Connections normally terminate with a DCCP-Reset, but resets may be sent for other reasons, including bad port numbers, bad option behavior, incorrect ECN Nonce Echoes, and so forth. DCCP-Resets MUST use 48-bit sequence numbers (X=1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-リセットパケットは無条件に接続をシャットダウンします。接続が正常にDCCP-リセットで終了しますが、リセットが悪いなどのポート番号、悪いオプションの振舞い、間違ったECNのNonceエコーズ、およびを含むその他の理由で送信されることがあります。 DCCP-リセットは、48ビットのシーケンス番号（X = 1）を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /                   with Type=7 (DCCP-Reset)                    /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /          Acknowledgement Number Subheader (8 bytes)           /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Reset Code   |    Data 1     |    Data 2     |    Data 3     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /              Application Data Area (Error Text)               /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reset Code: 8 bits Represents the reason that the sender reset the DCCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードをリセット：8ビットは送信者がDCCP接続をリセットした理由を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data 1, Data 2, and Data 3: 8 bits each The Data fields provide additional information about why the sender reset the DCCP connection. The meanings of these fields depend on the value of Reset Code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ1、データ2、データ3：8ビットの各データフィールドは、送信者がDCCP接続をリセットする理由に関する追加情報を提供します。これらのフィールドの意味はリセットコードの値に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application Data Area: Error Text If present, Error Text is a human-readable text string encoded in Unicode UTF-8, and preferably in English, that describes the error in more detail. For example, a DCCP-Reset with Reset Code 11, &#34;Aggression Penalty&#34;, might contain Error Text such as &#34;Aggression Penalty: Received 3 bad ECN Nonce Echoes, assuming misbehavior&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションデータ領域：存在する場合はエラーテキストは、エラーテキストは、エラーをより詳細に説明し、好ましくは英語でのUnicode UTF-8でエンコードされた、人間が読み取り可能なテキスト文字列です。 「侵略ペナルティ：不正行為を想定し、3つの悪いECNのNonceエコーズを受信した」たとえば、リセットコード11、「侵略ペナルティ」とDCCP-リセットは、のようなエラーテキストが含まれる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following Reset Codes are currently defined. Unless otherwise specified, the Data 1, 2, and 3 fields MUST be set to 0 by the sender of the DCCP-Reset and ignored by its receiver. Section references describe concrete situations that will cause each Reset Code to be generated; they are not meant to be exhaustive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のリセットコードは、現在定義されています。特に断らない限り、データ1、2、及び3つのフィールドは、DCCP  - リセットの送信者によって0に設定され、その受信機で無視しなければなりません。セクション参照は、各リセットコードが生成されます、具体的な状況について説明します。それらは、網羅的であることを意味するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0, &#34;Unspecified&#34; Indicates the absence of a meaningful Reset Code. Use of Reset Code 0 is NOT RECOMMENDED: the sender should choose a Reset Code that more clearly defines why the connection is being reset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0は、「指定なし」意味のリセットコードがないことを示します。リセットコード0の使用は推奨されません：送信者は、接続がリセットされている理由をより明確に定義するリセットコードを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1, &#34;Closed&#34; Normal connection close. See Section 8.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1、「クローズ」通常の接続があります。 8.3節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2, &#34;Aborted&#34; The sending endpoint gave up on the connection because of lack of progress. See Sections 8.1.1 and 8.1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2は、「中止」の送信エンドポイントがあるため進捗の欠如の接続をあきらめました。セクション8.1.1と8.1.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3, &#34;No Connection&#34; No connection exists. See Section 8.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3、「接続なし」の接続は存在しません。 8.3.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4, &#34;Packet Error&#34; A valid packet arrived with unexpected type. For example, a DCCP-Data packet with valid header checksum and sequence numbers arrived at a connection in the REQUEST state. See Section 8.3.1. The Data 1 field equals the offending packet type as an eight-bit number; thus, an offending packet with Type 2 will result in a Data 1 value of 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4、「パケットエラー」の有効なパケットが予期しない形で到着しました。例えば、有効なヘッダチェックサムとシーケンス番号とのDCCP  - データパケットはREQUEST状態で接続に到着しました。 8.3.1項を参照してください。データ1フィールドは、8ビット数として問題のあるパケットタイプに等しいです。従って、タイプ2との違反パケットは、2のデータ1つの値をもたらすであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5, &#34;Option Error&#34; An option was erroneous, and the error was serious enough to warrant resetting the connection. See Sections 6.6.7, 6.6.8, and 11.4. The Data 1 field equals the offending option type; Data 2 and Data 3 equal the first two bytes of option data (or zero if the option had less than two bytes of data).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5、「オプション誤り」オプションが誤っていた、とエラーが接続をリセット値するほど深刻でした。セクション6.6.7、6.6.8、および11.4を参照してください。データ1つのフィールドは、問題のオプションタイプに等しいです。データ2及びデータ3は、オプションデータの最初の2バイトに等しく（またはゼロオプションは、データの2未満のバイトを有する場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6, &#34;Mandatory Error&#34; The sending endpoint could not process an option O that was immediately preceded by Mandatory. The Data fields report the option type and data of option O, using the format of Reset Code 5, &#34;Option Error&#34;. See Section 5.8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図6は、「必須のエラーは、」送信エンドポイントはすぐに必須で先行されたオプションのOを処理できませんでした。データフィールドは、リセットコード5、「オプション誤り」の形式を使用して、オプションタイプとオプションOのデータを報告しています。 5.8.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7, &#34;Connection Refused&#34; The Destination Port didn&#39;t correspond to a port open for listening. Sent only in response to DCCP-Requests. See Section 8.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7は、宛先ポートがリスニングのために開いているポートに対応していませんでした「接続が拒否されました」。 DCCP-要求に応じてのみ送信されます。 8.1.3項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8, &#34;Bad Service Code&#34; The Service Code didn&#39;t equal the service code attached to the Destination Port. Sent only in response to DCCP-Requests. See Section 8.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8、「悪いサービスコード」サービスコードは、宛先ポートに付加されたサービスコードを等しくありませんでした。 DCCP-要求に応じてのみ送信されます。 8.1.3項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9, &#34;Too Busy&#34; The server is too busy to accept new connections. Sent only in response to DCCP-Requests. See Section 8.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9、「ビジー状態」サーバーは、新しい接続を受け入れることができないくらい忙しいです。 DCCP-要求に応じてのみ送信されます。 8.1.3項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10, &#34;Bad Init Cookie&#34; The Init Cookie echoed by the client was incorrect or missing. See Section 8.1.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10は、クライアントによって反響「悪い初期クッキー」のInitクッキーが正しくないか、行方不明でした。セクション8.1.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11, &#34;Aggression Penalty&#34; This endpoint has detected congestion control-related misbehavior on the part of the other endpoint. See Section 12.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11、「攻撃ペナルティ」は、このエンドポイントは他のエンドポイントの一部に輻輳制御に関連する不正行為を検出しました。 12.3節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12-127, Reserved Receivers should treat these codes as they do Reset Code 0, &#34;Unspecified&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らは、「指定なし」のコード0をリセットしそうであるように12から127、予約レシーバは、これらのコードを扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
128-255, CCID-specific codes Semantics depend on the connection&#39;s CCIDs. See Section 10.3. Receivers should treat unknown CCID-specific Reset Codes as they do Reset Code 0, &#34;Unspecified&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
128-255、CCID固有のコードの意味は、接続ののCCIDsに依存します。 10.3節を参照してください。彼らは、「指定なし」のコード0をリセットしそうであるように受信機は、未知のCCID特有のリセットコードを扱う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following table summarizes this information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の表は、この情報をまとめたもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          Reset
          Code   Name                    Data 1     Data 2 &amp; 3
          -----  ----                    ------     ----------
            0    Unspecified               0            0
            1    Closed                    0            0
            2    Aborted                   0            0
            3    No Connection             0            0
            4    Packet Error           pkt type        0
            5    Option Error           option #   option data
            6    Mandatory Error        option #   option data
            7    Connection Refused        0            0
            8    Bad Service Code          0            0
            9    Too Busy                  0            0
           10    Bad Init Cookie           0            0
           11    Aggression Penalty        0            0
          12-127 Reserved
         128-255 CCID-specific codes
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Table 2: DCCP Reset Codes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
表2：DCCPは、コードをリセット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Options on DCCP-Reset packets are processed before the connection is shut down. This means that certain combinations of options, particularly involving Mandatory, may cause an endpoint to respond to a valid DCCP-Reset with another DCCP-Reset. This cannot lead to a reset storm; since the first endpoint has already reset the connection, the second DCCP-Reset will be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続がシャットダウンされる前に、DCCP-リセットパケットのオプションが処理されます。これは特に必須に関わるオプションの組み合わせによっては、エンドポイントが別のDCCP-リセットで有効なDCCP-リセットに応答させることを意味します。これは、リセット嵐につながることはできません。最初のエンドポイントが既に接続をリセットしているので、第二のDCCP-リセットは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. DCCP-Sync and DCCP-SyncAck Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7.  DCCP-SyncとDCCP-SyncAckパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Sync packets help DCCP endpoints recover synchronization after bursts of loss and recover from half-open connections. Each valid received DCCP-Sync immediately elicits a DCCP-SyncAck. Both packet types MUST use 48-bit sequence numbers (X=1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Syncのパケットは、DCCP終点は損失のバースト後に同期を回復し、ハーフオープン接続からの回復を助けます。それぞれの有効な受信DCCP-Syncは、すぐにDCCP-SyncAckを誘発します。両方のパケットタイプは、48ビットのシーケンス番号（X = 1）を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /            Generic DCCP Header with X=1 (16 bytes)            /
      /          with Type=8 (DCCP-Sync) or 9 (DCCP-SyncAck)          /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /          Acknowledgement Number Subheader (8 bytes)           /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      /                      Options and Padding                      /
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
      /                Application Data Area (Ignored)                /
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Acknowledgement Number field has special semantics for DCCP-Sync and DCCP-SyncAck packets. First, the packet corresponding to a DCCP-Sync&#39;s Acknowledgement Number need not have been acknowledgeable. Thus, receivers MUST NOT assume that a packet was processed simply because it appears in the Acknowledgement Number field of a DCCP-Sync packet. This differs from all other packet types, where the Acknowledgement Number by definition corresponds to an acknowledgeable packet. Second, the Acknowledgement Number on any DCCP-SyncAck packet MUST correspond to the Sequence Number on an acknowledgeable DCCP-Sync packet. In the presence of reordering, this might not equal GSR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認応答番号フィールドは、DCCP-SyncとDCCP-SyncAckパケットのための特別な意味を持っています。まず、DCCP同期の確認応答番号に対応するパケットは承認可能となっている必要はありません。このように、受信機は、それがDCCP-同期パケットの確認応答番号フィールドに表示されますので、パケットは単純に処理されたと仮定してはいけません。これは、定義により、確認応答番号が承認可能パケットに対応して他のすべてのパケットタイプとは異なります。第二に、任意のDCCP-SyncAckパケットに確認応答番号が承認可能DCCP同期パケットにシーケンス番号に対応しなければなりません。並べ替えの存在下で、これはGSRと等しくない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with DCCP-Ack packets, DCCP-Sync and DCCP-SyncAck packets MAY have non-zero-length application data areas, whose contents receivers MUST ignore. Padded DCCP-Sync packets may be useful when performing Path MTU discovery; see Section 14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-ACKパケットのように、DCCP-SyncとDCCP-SyncAckパケットは、そのコンテンツ受信機は無視しなければならない非ゼロレングスアプリケーションデータ領域を有していてもよいです。パスMTUディスカバリを実行するときにパッド入りDCCP-Syncのパケットが有用である可能性があります。第14章を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any DCCP packet may contain options, which occupy space at the end of the DCCP header. Each option is a multiple of 8 bits in length. Individual options are not padded to multiples of 32 bits, and any option may begin on any byte boundary. However, the combination of all options MUST add up to a multiple of 32 bits; Padding options MUST be added as necessary to fill out option space to a word boundary. Any options present are included in the header checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意のDCCPパケットはDCCPヘッダーの最後にスペースを占有するオプションを含んでいてもよいです。各オプションは、長さが8ビットの倍数です。個々のオプションは、32ビットの倍数に水増しされていない、と任意のオプションは、任意のバイト境界で開始してもよいです。しかし、すべてのオプションの組合せは、32ビットの倍数にならなければなりません。パディングオプションは、ワード境界にオプションスペースを記入し、必要に応じて加えなければなりません。存在する任意のオプションは、ヘッダチェックサムに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first byte of an option is the option type. Options with types 0 through 31 are single-byte options. Other options are followed by a byte indicating the option&#39;s length. This length value includes the two bytes of option-type and option-length as well as any option-data bytes; it must therefore be greater than or equal to two.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションの最初のバイトはオプションタイプです。タイプ0〜31でのオプションは、シングルバイトのオプションです。その他のオプションは、オプションの長さを示すバイトが続いています。この長さの値は、オプションタイプとオプション長ならびに任意のオプションデータバイトの2つのバイトを含みます。従って、2以上でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Options MUST be processed sequentially, starting with the first option in the packet header. Options with unknown types MUST be ignored. Also, options with nonsensical lengths (length byte less than two or more than the remaining space in the options portion of the header) MUST be ignored, and any option space following an option with nonsensical length MUST likewise be ignored. Unless otherwise specified, multiple occurrences of the same option MUST be processed independently; for some options, this will mean in practice that the last valid occurrence of an option takes precedence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションは、パケットヘッダ内の最初のオプションで開始し、順次処理されなければなりません。不明な種類のオプションを無視しなければなりません。また、無意味な長さ（長さバイト2未満またはヘッダのオプション部分の残りの空間より）を持つオプションは無視しなければなりません、そして無意味な長さのオプションを以下のいずれかのオプションのスペースは、同様に無視しなければなりません。特に指定しない限り、同じオプションの複数の出現は、独立して処理しなければなりません。オプションの最後の有効な発生が優先されることにいくつかのオプションのために、これは実際には意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following options are currently defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のオプションは、現在定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               Option                           DCCP-  Section
       Type    Length     Meaning               Data?  Reference
       ----    ------     -------               -----  ---------
         0        1       Padding                 Y      5.8.1
         1        1       Mandatory               N      5.8.2
         2        1       Slow Receiver           Y      11.6
       3-31       1       Reserved
        32     variable   Change L                N      6.1
        33     variable   Confirm L               N      6.2
        34     variable   Change R                N      6.1
        35     variable   Confirm R               N      6.2
        36     variable   Init Cookie             N      8.1.4
        37       3-8      NDP Count               Y      7.7
        38     variable   Ack Vector [Nonce 0]    N      11.4
        39     variable   Ack Vector [Nonce 1]    N      11.4
        40     variable   Data Dropped            N      11.7
        41        6       Timestamp               Y      13.1
        42      6/8/10    Timestamp Echo          Y      13.3
        43       4/6      Elapsed Time            N      13.2
        44        6       Data Checksum           Y      9.3
       45-127  variable   Reserved
      128-255  variable   CCID-specific options   -      10.3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Table 3: DCCP Options
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
表3：DCCPオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Not all options are suitable for all packet types. For example, since the Ack Vector option is interpreted relative to the Acknowledgement Number, it isn&#39;t suitable on DCCP-Request and DCCP-Data packets, which have no Acknowledgement Number. If an option occurs on an unexpected packet type, it MUST generally be ignored; any such restrictions are mentioned in each option&#39;s description. The table summarizes the most common restriction: when the DCCP-Data? column value is N, the corresponding option MUST be ignored when received on a DCCP-Data packet. (Section 7.5.5 describes why such options are ignored as opposed to, say, causing a reset.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いないすべてのオプションは、すべてのパケットタイプに適しています。 Ackベクトルオプションは確認応答番号に関連して解釈されるので、例えば、それは肯定応答番号を持たないDCCP  - 要求とDCCP  - データパケットには適していません。オプションは、予期しないパケットタイプで発生した場合、それは一般的に無視しなければなりません。そのような制限は、各オプションの説明に記載されています。 DCCP-データ：表は、最も一般的な制限を要約したもの？カラムの値がDCCP  - データパケットで受信したときにN、対応するオプションを無視しなければなりませんです。 （セクション7.5.5は、リセットを引き起こし、たとえば、とは対照的に、このようなオプションは無視されている理由を説明しています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Options with invalid values MUST be ignored unless otherwise specified. For example, any Data Checksum option with option length
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に指定がない限り、無効な値を持つオプションを無視しなければなりません。オプションの長さを持つ例えば、任意のデータのチェックサムオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4 MUST be ignored, since all valid Data Checksum options have option length 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての有効なデータのチェックサム・オプションは、オプションの長さ6を持っているので、4は、無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes two generic options, Padding and Mandatory. Other options are described later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、2つの一般的なオプション、パディングと必須を説明しています。その他のオプションについては後述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1. Padding Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.1. パディングオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+
   |00000000|
   +--------+
     Type=0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Padding is a single-byte &#34;no-operation&#34; option used to pad between or after options. If the length of a packet&#39;s other options is not a multiple of 32 bits, then Padding options are REQUIRED to pad out the options area to the length implied by Data Offset. Padding may also be used between options; for example, to align the beginning of a subsequent option on a 32-bit boundary. There is no guarantee that senders will use this option, so receivers must be prepared to process options even if they do not begin on a word boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディングはオプションの間または後のパッドに使用されるシングルバイトの「ノーオペレーション」のオプションです。パケットの他のオプションの長さが32ビットの倍数でない場合、パディングオプションは、オフセットデータによって暗黙の長さにオプションエリアアウトパッドが要求されます。パディングはまた、オプションの間で使用されてもよいです。例えば、32ビット境界上の次のオプションの開始を整列させます。受信機は、彼らがワード境界で始まらない場合でも、オプションを処理するために準備しなければならないので、送信者は、このオプションを使用するという保証はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2. Mandatory Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8.2. 必須オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+
   |00000001|
   +--------+
     Type=1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mandatory is a single-byte option that marks the immediately following option as mandatory. Say that the immediately following option is O. Then the Mandatory option has no effect if the receiving DCCP endpoint understands and processes O. If the endpoint does not understand or process O, however, then it MUST reset the connection using Reset Code 6, &#34;Mandatory Failure&#34;. For instance, the endpoint would reset the connection if it did not understand O&#39;s type; if it understood O&#39;s type, but not O&#39;s data; if O&#39;s data was invalid for O&#39;s type; if O was a feature negotiation option, and the endpoint did not understand the enclosed feature number; or if the endpoint understood O, but chose not to perform the action O implies. This list is not exhaustive and, in particular, individual option specifications may describe additional situations in which the endpoint should reset the connection and situations in which it should not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須は必須として、すぐに次のオプションをマークシングルバイトオプションです。 「すぐに次のオプションは、受信DCCP終点が理解し、エンドポイントが理解していないか、プロセス・Oは、しかし、それはリセットコード6を使用して接続をリセットしなければならない場合はOを処理する場合O.が続い必須オプションは効果がありませんと言います必須の失敗」。それはOのタイプを理解していない場合たとえば、エンドポイントは、接続をリセットします。それはOのタイプではなく、Oのデータを理解している場合。 Oのデータは、Oのタイプには無効だった場合。 Oは特徴交渉オプションで、エンドポイントは、同封の機能番号を理解していなかった場合。場合、またはエンドポイントがOを理解したが、Oが示すアクションを実行しないことを選択しました。このリストは網羅的なものではないと、特に、個々のオプション仕様は、それがないべきエンドポイントは、接続や状況をリセットするべき追加的な状況を記述することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mandatory options MUST NOT be sent on DCCP-Data packets, and any Mandatory options received on DCCP-Data packets MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須オプションはDCCP  - データパケットに送ってはいけません、とDCCP  - データパケットで受信したすべての必須オプションは無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The connection is in error and should be reset with Reset Code 5, &#34;Option Error&#34;, if option O is absent (Mandatory was the last byte of the option list), or if option O equals Mandatory. However, the combination &#34;Mandatory Padding&#34; is valid, and MUST behave like two bytes of Padding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションのOは（必須オプションリストの最後のバイトだった）存在しない場合、またはオプションOが必須等しい場合の接続は、エラーであるとリセットコード5、「オプション誤り」でリセットする必要があります。しかし、組み合わせ「必須パディングは、」有効であり、パディングの2バイトのように動作しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 6.6.9 describes the behavior of Mandatory feature negotiation options in more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6.6.9項では、より詳細に必須の特徴交渉オプションの動作について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Feature Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.機能のネゴシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Four DCCP options, Change L, Confirm L, Change R, and Confirm R, are used to negotiate feature values. Change options initiate a negotiation; Confirm options complete that negotiation. The &#34;L&#34; options are sent by the feature location, and the &#34;R&#34; options are sent by the feature remote. Change options are retransmitted to ensure reliability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
四のDCCPオプション、変更Lは、L、Rの変更を確認し、Rを確認して、特徴値を交渉するために使用されています。変更オプションは、交渉を開始します。オプションは、その交渉を完了を確認してください。 「L」オプションは特徴位置によって送信され、そして「R」オプションは、特徴遠隔によって送信されます。変更オプションは、信頼性を確保するために再送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All these options have the same format. The first byte of option data is the feature number, and the second and subsequent data bytes hold one or more feature values. The exact format of the feature value area depends on the feature type; see Section 6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのオプションはすべて同じフォーマットを持っています。オプションデータの最初のバイトは、特徴数であり、2番目以降のデータバイトは、一つ以上の特徴値を保持します。特徴量領域の正確なフォーマットは、特徴の種類に依存します。 6.3節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+--------
   |  Type  | Length |Feature#| Value(s) ...
   +--------+--------+--------+--------+--------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Together, the feature number and the option type (&#34;L&#34; or &#34;R&#34;) uniquely identify the feature to which an option applies. The exact format of the Value(s) area depends on the feature number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一緒に、機能番号及びオプションの種類（「L」または「R」）は、一意のオプションが適用される機能を特定します。値（S）領域の正確なフォーマットは、特徴数に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Feature negotiation options MUST NOT be sent on DCCP-Data packets, and any feature negotiation options received on DCCP-Data packets MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特徴交渉オプションはDCCP  - データパケットに送ってはいけません、とDCCP  - データパケットで受信された任意の特徴交渉オプションは無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Change Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 変更オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change L and Change R options initiate feature negotiation. The option to use depends on the relevant feature&#39;s location: To start a negotiation for feature F/A, DCCP A will send a Change L option; to start a negotiation for F/B, it will send a Change R option. Change options are retransmitted until some response is received. They contain at least one Value, and thus have a length of at least 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更LとRの変更オプションが機能ネゴシエーションを開始します。使用するオプションは、関連する機能の位置によって異なります。機能F / Aのための交渉を開始するには、DCCP Aは変更Lオプションを送信します。 F / Bのための交渉を開始するために、それは変更Rオプションを送信します。いくつかの応答が受信されるまで、変更オプションが再送されています。彼らは、少なくとも1つの値を含み、従って少なくとも4の長さを有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +--------+--------+--------+--------+--------
   Change L:  |00100000| Length |Feature#| Value(s) ...
              +--------+--------+--------+--------+--------
               Type=32
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +--------+--------+--------+--------+--------
   Change R:  |00100010| Length |Feature#| Value(s) ...
              +--------+--------+--------+--------+--------
               Type=34
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Confirm Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. オプションを確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Confirm L and Confirm R options complete feature negotiation and are sent in response to Change R and Change L options, respectively. Confirm options MUST NOT be generated except in response to Change options. Confirm options need not be retransmitted, since Change options are retransmitted as necessary. The first byte of the Confirm option contains the feature number from the corresponding Change. Following this is the selected Value, and then possibly the sender&#39;s preference list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lを確認し、Rオプションに完全な機能ネゴシエーションを確認し、それぞれ、RとLの変更オプションを変更するために応答して送信されます。オプションを確認してオプションを変更するには、応答以外で生成してはなりません。変更オプションは、必要に応じて再送信されるためのオプションは、再送信する必要はないことを確認します。 Confirmオプションの最初のバイトは、対応する変更から機能番号が含まれています。これは、選択した値、そしておそらく送信者の優先リストを以下に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +--------+--------+--------+--------+--------
   Confirm L: |00100001| Length |Feature#| Value(s) ...
              +--------+--------+--------+--------+--------
               Type=33
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +--------+--------+--------+--------+--------
   Confirm R: |00100011| Length |Feature#| Value(s) ...
              +--------+--------+--------+--------+--------
               Type=35
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an endpoint receives an invalid Change option -- with an unknown feature number, or an invalid value -- it will respond with an empty Confirm option containing the problematic feature number, but no value. Such options have length 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未知の機能の数、または無効な値を持つ -   - エンドポイントが無効の変更オプションを受信した場合には、問題のある機能番号を含む空のConfirmオプション、ない値で応答します。このようなオプションは、長さ3を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Reconciliation Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 調整ルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reconciliation rules determine how the two sets of preferences for a given feature are resolved into a unique result. The reconciliation rule depends only on the feature number. Each reconciliation rule must have the property that the result is uniquely determined given the contents of Change options sent by the two endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
調整ルールは、所定の機能に対する好みの二組がユニークな結果に解決される方法を決定します。和解ルールは唯一の機能の数によって異なります。各調整ルールは結果が一意に2つのエンドポイントによって送信された変更オプションの内容を与えて決定された性質を持っている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All current DCCP features use one of two reconciliation rules: server-priority (&#34;SP&#34;) and non-negotiable (&#34;NN&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバの優先度（「SP」）と非交渉（「NN」）：現在のすべてのDCCPの特徴は、二つのリコンシリエーション・ルールのいずれかを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. Server-Priority
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. サーバーの優先
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The feature value is a fixed-length byte string (length determined by the feature number). Each Change option contains a list of values ordered by preference, with the most preferred value coming first. Each Confirm option contains the confirmed value, followed by the confirmer&#39;s preference list. Thus, the feature&#39;s current value will generally appear twice in Confirm options&#39; data, once as the current value and once in the confirmer&#39;s preference list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特徴量は、固定長バイト文字列（特徴数によって決定される長さ）です。各変更オプションは、最も好ましい値は、最初に来て、好みによって順序付けされた値のリストが含まれています。各Confirmオプションは、確認者の嗜好リストに続いて確認した値を、含まれています。このように、機能の現在の値は、一般的に確認者の優先リストに一度、現在の値として、一度、確認オプションのデータに2回表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To reconcile the preference lists, select the first entry in the server&#39;s list that also occurs in the client&#39;s list. If there is no shared entry, the feature&#39;s value MUST NOT change, and the Confirm option will confirm the feature&#39;s previous value (unless the Change option was Mandatory; see Section 6.6.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
好みのリストを調整するために、また、クライアントのリストに発生し、サーバーのリストの最初のエントリを選択します。何の共有エントリが存在しない場合は、機能の値が変化してはならない、とConfirmオプションは、機能の以前の値を確認します（変更オプションが必須でない限り、6.6.9項を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. Non-Negotiable
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. 不流通
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The feature value is a byte string. Each option contains exactly one feature value. The feature location signals a new value by sending a Change L option. The feature remote MUST accept any valid value, responding with a Confirm R option containing the new value, and it MUST send empty Confirm R options in response to invalid values (unless the Change L option was Mandatory; see Section 6.6.9). Change R and Confirm L options MUST NOT be sent for non-negotiable features; see Section 6.6.8. Non-negotiable features use the feature negotiation mechanism to achieve reliability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特徴値はバイト文字列です。各オプションは、1つの特徴値が含まれています。特徴位置は変更Lオプションを送ることによって、新たな価値を知らせます。機能リモコンは、新しい値を含む確認Rオプションで対応し、任意の有効な値を受け入れなければならない、と（変更Lオプションが必須でない限り、6.6.9項を参照）には、無効な値に応じて、空の確認Rオプションを送らなければなりません。 Rを変更し、非交渉機能のために送ってはいけませんLオプションを確認します。 6.6.8項を参照してください。非交渉機能は、信頼性を達成するための特徴交渉メカニズムを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Feature Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. フィーチャー番号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines the following feature numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、次の機能番号を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                          Rec&#39;n Initial        Section
   Number   Meaning                       Rule   Value  Req&#39;d Reference
   ------   -------                       -----  -----  ----- ---------
      0     Reserved
      1     Congestion Control ID (CCID)   SP      2      Y     10
      2     Allow Short Seqnos             SP      0      Y     7.6.1
      3     Sequence Window                NN     100     Y     7.5.2
      4     ECN Incapable                  SP      0      N     12.1
      5     Ack Ratio                      NN      2      N     11.3
      6     Send Ack Vector                SP      0      N     11.5
      7     Send NDP Count                 SP      0      N     7.7.2
      8     Minimum Checksum Coverage      SP      0      N     9.2.1
      9     Check Data Checksum            SP      0      N     9.3.1
    10-127  Reserved
   128-255  CCID-specific features                              10.3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Table 4: DCCP Feature Numbers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
表4：DCCPフィーチャー番号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rec&#39;n Rule The reconciliation rule used for the feature. SP means server-priority, NN means non-negotiable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機能のために使用さ和解のルールをルールRec&#39;n。 SPは、サーバーの優先順位を意味し、NNは、譲渡禁止を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initial Value The initial value for the feature. Every feature has a known initial value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期値機能の初期値。すべての機能は、既知の初期値を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Req&#39;d This column is &#34;Y&#34; if and only if every DCCP implementation MUST understand the feature. If it is &#34;N&#34;, then the feature behaves like an extension (see Section 15), and it is safe to respond to Change options for the feature with empty Confirm options. Of course, a CCID might require the feature; a DCCP that implements CCID 2 MUST support Ack Ratio and Send Ack Vector, for example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このコラムReq&#39;dすべてのDCCP実装が機能を理解しなければならない場合に限り、「Y」です。それは「N」であれば、機能が拡張（セクション15を参照）のように振る舞い、空の確認オプションを使用して、機能のオプションを変更するに応答しても安全です。もちろん、CCIDは、機能が必要になることがあります。 CCID 2を実装DCCPは、ACK比率をサポートし、例えば、のAckベクトルを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. Feature Negotiation Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. 特徴交渉の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here are three example feature negotiations for features located at the server, the first two for the Congestion Control ID feature, the last for the Ack Ratio.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは3例機能サーバにある機能の交渉、輻輳制御ID機能のための最初の二つは、ACK比率の最後のです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                 Client                     Server
                 ------                     ------
      1. Change R(CCID, 2 3 1)  --&gt;
         (&#34;2 3 1&#34; is client&#39;s preference list)
      2.                        &lt;--  Confirm L(CCID, 3, 3 2 1)
                               (3 is the negotiated value;
                               &#34;3 2 1&#34; is server&#39;s pref list)
                  * agreement that CCID/Server = 3 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. XXX &lt;-- Change L(CCID, 3 2 1) 2. Retransmission: &lt;-- Change L(CCID, 3 2 1) 3. Confirm R(CCID, 3, 2 3 1) --&gt; * agreement that CCID/Server = 3 *
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. XXX &lt; - 変更L（CCID、3 2 1）2再送&lt; - 変更L（CCID、3 2 1）3.確認R（CCID、3、2 3 1） - &gt; *合意CCID /サーバ= 3 *
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. &lt;-- Change L(Ack Ratio, 3) 2. Confirm R(Ack Ratio, 3) --&gt; * agreement that Ack Ratio/Server = 3 *
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. &lt; - 変更L（肯定応答率、3）2.確認R（肯定応答率、3） - &gt; *契約のAck比/サーバ= 3 *
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This example shows a simultaneous negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例では、同時交渉を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  Client                     Server
                  ------                     ------
      1a. Change R(CCID, 2 3 1)  --&gt;
       b.                        &lt;--  Change L(CCID, 3 2 1)
      2a.                        &lt;--  Confirm L(CCID, 3, 3 2 1)
       b. Confirm R(CCID, 3, 2 3 1)  --&gt;
                   * agreement that CCID/Server = 3 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here are the byte encodings of several Change and Confirm options. Each option is sent by DCCP A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここではいくつかの変更のバイトエンコーディングがあり、オプションを確認してください。各オプションは、DCCP Aによって送られます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change L(CCID, 2 3) = 32,5,1,2,3 DCCP B should change CCID/A&#39;s value (feature number 1, a server-priority feature); DCCP A&#39;s preferred values are 2 and 3, in that preference order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変化L（CCID、2 3）= 32,5,1,2,3 DCCP Bは、（フィーチャー番号1、サーバ優先機能）CCID / Aの値を変更すべきです。 DCCP Aの好ましい値は、優先順に、2及び3です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change L(Sequence Window, 1024) = 32,9,3,0,0,0,0,4,0 DCCP B should change Sequence Window/A&#39;s value (feature number 3, a non-negotiable feature) to the 6-byte string 0,0,0,0,4,0 (the value 1024).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変化L（シーケンスウィンドウ、1024）= 32,9,3,0,0,0,0,4,0 DCCP Bは、シーケンスウィンドウ/ Aの値を変更する必要があり（フィーチャー番号3、非交渉機能）6〜バイト文字列0,0,0,0,4,0（値1024）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Confirm L(CCID, 2, 2 3) = 33,6,1,2,2,3 DCCP A has changed CCID/A&#39;s value to 2; its preferred values are 2 and 3, in that preference order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（CCID、2、2 3）Lを確認= 33,6,1,2,2,3 DCCP A 2にCCID / Aの値を変更しました。その好ましい値は、優先順に、2及び3です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Empty Confirm L(126) = 33,3,126 DCCP A doesn&#39;t implement feature number 126, or DCCP B&#39;s proposed value for feature 126/A was invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空の確認L（126）= 33,3,126 DCCP Aは、特徴番号126を実装していない、または機能126 / AのためのDCCP Bの提案された値が無効でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change R(CCID, 3 2) = 34,5,1,3,2 DCCP B should change CCID/B&#39;s value; DCCP A&#39;s preferred values are 3 and 2, in that preference order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更R（CCID、3 2）= 34,5,1,3,2 DCCP Bは、CCID / Bの値を変更すべきです。 DCCP Aの好ましい値は、優先順に、3及び2です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Confirm R(CCID, 2, 3 2) = 35,6,1,2,3,2 DCCP A has changed CCID/B&#39;s value to 2; its preferred values were 3 and 2, in that preference order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R（CCID、2、3 2）を確認= 35,6,1,2,3,2 DCCP Aは2にCCID / Bの値を変更しました。その好ましい値は、優先順に、3及び2でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Confirm R(Sequence Window, 1024) = 35,9,3,0,0,0,0,4,0 DCCP A has changed Sequence Window/B&#39;s value to the 6-byte string 0,0,0,0,4,0 (the value 1024).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R（シーケンスウィンドウ、1024）を確認= 35,9,3,0,0,0,0,4,0 DCCP Aは、6バイトの文字列0,0,0,0,4にシーケンスウィンドウ/ Bの値を変更しました、0（値1024）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Empty Confirm R(126) = 35,3,126 DCCP A doesn&#39;t implement feature number 126, or DCCP B&#39;s proposed value for feature 126/B was invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空の確認R（126）= 35,3,126 DCCP Aは、特徴番号126を実装していない、または機能126 / BのためのDCCP Bの提案された値が無効でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. Option Exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. オプション取引
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A few basic rules govern feature negotiation option exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの基本的なルールは特徴交渉オプションの交換を支配します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Every non-reordered Change option gets a Confirm option in response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.すべての非並べ替えを変更するオプションは、応答におけるConfirmオプションを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Change options are retransmitted until a response for the latest Change is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最新の変更のための応答が受信されるまで2.変更オプションが再送されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Feature negotiation options are processed in strictly-increasing order by Sequence Number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.特徴交渉オプションは、シーケンス番号によって厳密に増加順に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of this section describes the consequences of these rules in more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの残りの部分は、より詳細にこれらのルールの結果を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1. Normal Exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1. 通常取引
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change options are generated when a DCCP endpoint wants to change the value of some feature. Generally, this will happen at the beginning of a connection, although it may happen at any time. We say the endpoint &#34;generates&#34; or &#34;sends&#34; a Change L or Change R option, but of course the option must be attached to a packet. The endpoint may attach the option to a packet it would have generated anyway (such as a DCCP-Request), or it may create a &#34;feature negotiation packet&#34;, often a DCCP-Ack or DCCP-Sync, just to carry the option. Feature negotiation packets are controlled by the relevant congestion control mechanism. For example, DCCP A may send a DCCP-Ack or DCCP-Sync for feature negotiation only if the B-to-A CCID would allow sending a DCCP-Ack. In addition, an endpoint SHOULD generate at most one feature negotiation packet per round-trip time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更オプションは、DCCP終点は、いくつかの機能の値を変更したいときに生成されます。それはいつでも起こるかもしれませんが、一般的に、これは、接続の開始時に発生します。私たちは、エンドポイントが、「生成」または変更Lまたは変更Rオプションを「送信」が、もちろんオプションは、パケットに付加されなければならないと言います。エンドポイントは、それが（例えばDCCP-要求として）とにかく生成しているだろうか、それだけでオプションを運ぶために、「特徴交渉パケット」、しばしばDCCP-ACKまたはDCCP-Syncを作成することができ、パケットにオプションをつけてもよいです。機能ネゴシエーションパケットは、関連する輻輳制御機構によって制御されています。例えば、DCCP AはB対A CCIDがDCCP-ACKを送信できるようになる場合にのみ機能ネゴシエーションのためにDCCP-ACKまたはDCCP-Syncを送信することができます。また、エンドポイントは、ラウンドトリップ時間あたり最大1つの特徴交渉パケットを生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving a Change L or Change R option, a DCCP endpoint examines the included preference list, reconciles that with its own preference list, calculates the new value, and sends back a Confirm R or Confirm L option, respectively, informing its peer of the new value or that the feature was not understood. Every non-reordered Change option MUST result in a corresponding Confirm option, and any packet including a Confirm option MUST carry an Acknowledgement Number. (Section 6.6.4 describes how Change reordering is detected and handled.) Generated Confirm options may be attached to packets that would have been sent anyway (such as DCCP-Response or DCCP-SyncAck) or to new feature negotiation packets, as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更Lまたは変更Rオプションを受信するのピアに知らせる、それぞれ、DCCP終点は、含まれる優先リストを調べ、自身の好みのリストと、新しい値を計算することを両立し、確認Rを返信またはLオプションを確認します新しい価値や機能を理解していなかったこと。すべての非並べ替えの変更オプションは、対応するConfirmオプションをもたらさなければなりません、とConfirmオプションを含むすべてのパケットが確認応答番号を運ばなければなりません。 （セクション6.6.4は、変更の並べ替えが検出され、処理される方法を説明します。）（例えばDCCP-応答またはDCCP-SyncAckとして）、または新しい機能ネゴシエーションパケットにとにかく送られていたであろうパケットに取り付けることができるオプションを確認して生成され、上記のように。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Change-sending endpoint MUST wait to receive a corresponding Confirm option before changing its stored feature value. The Confirm-sending endpoint changes its stored feature value as soon as it sends the Confirm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更-送信エンドポイントは、その保存された特徴値を変更する前に、対応するConfirmオプションを受け取るのを待たなければなりません。確認-送信エンドポイントは、すぐにそれが確認を送るように、その記憶された特徴値を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A packet MAY contain more than one feature negotiation option, possibly including two options that refer to the same feature; as usual, the options are processed sequentially.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットは、おそらく同じ機能を参照する2つの選択肢を含む複数の特徴交渉オプションを含んでいてもよいです。いつものように、オプションが順番に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.2. Processing Received Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.2. 処理の受信オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints exist in one of three states relative to each feature. STABLE is the normal state, where the endpoint knows the feature&#39;s value and thinks the other endpoint agrees. An endpoint enters the CHANGING state when it first sends a Change for the feature and returns to STABLE once it receives a corresponding Confirm. The final state, UNSTABLE, indicates that an endpoint in CHANGING state changed its preference list but has not yet transmitted a Change option with the new preference list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点は、各機能に対する3つの状態が存在します。 STABLEは、エンドポイントが機能の価値を知っているし、他のエンドポイントが同意考えて通常の状態、です。それが第一の特徴のために変更を送信し、それが対応することを確認を受けた後、STABLEに戻ったときにエンドポイントは、CHANGING状態になります。 UNSTABLE最終状態は、状態を変更におけるエンドポイントがその優先リストを変更したが、まだ新しい優先リストでの変更のオプションを送信していないことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Feature state transitions at a feature location are implemented according to this diagram. The diagram ignores sequence number and option validity issues; these are handled explicitly in the pseudocode that follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特徴位置における特徴の状態遷移は、この図に従って実装されます。図は、シーケンス番号とオプションの妥当性の問題を無視します。これらは、以下の擬似コードで明示的に処理されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                                          timeout/
 rcv Confirm R      app/protocol evt : snd Change L       rcv non-ack
 : ignore      +---------------------------------------+  : snd Change L
      +----+   |                                       |  +----+
      |    v   |                   rcv Change R        v  |    v
   +------------+  rcv Confirm R   : calc new value, +------------+
   |            |  : accept value    snd Confirm L   |            |
   |   STABLE   |&lt;-----------------------------------|  CHANGING  |
   |            |        rcv empty Confirm R         |            |
   +------------+        : revert to old value       +------------+
       |    ^                                            |    ^
       +----+                                  pref list |    | snd
 rcv Change R                                  changes   |    | Change L
 : calc new value, snd Confirm L                         v    |
                                                     +------------+
                                                 +---|            |
                            rcv Confirm/Change R |   |  UNSTABLE  |
                            : ignore             +--&gt;|            |
                                                     +------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Feature locations SHOULD use the following pseudocode, which corresponds to the state diagram, to react to each feature negotiation option on each valid non-Data packet received. The pseudocode refers to &#34;P.seqno&#34; and &#34;P.ackno&#34;, which are properties of the packet; &#34;O.type&#34; and &#34;O.len&#34;, which are properties of the option; &#34;FGSR&#34; and &#34;FGSS&#34;, which are properties of the connection and handle reordering as described in Section 6.6.4; &#34;F.state&#34;, which is the feature&#39;s state (STABLE, CHANGING, or UNSTABLE); and &#34;F.value&#34;, which is the feature&#39;s value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特徴位置は、受け取ったそれぞれの有効な非データパケットの各特徴交渉オプションに反応するように、状態図に対応し、以下の擬似コードを使用する必要があります。擬似コードは、パケットの特性である「P.seqno」および「P.ackno」を指します。オプションのプロパティである「O.type」と「O.len」、。接続のプロパティであり、セクション6.6.4に記載のように並べ替え処理「FGSR」および「FGSS」;機能の状態（安定、変化、または不安定）である「F.state」;機能の値であり、「F.value」、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   First, check for unknown features (Section 6.6.7);
      If F is unknown,
         If the option was Mandatory,   /* Section 6.6.9 */
            Reset connection and return
         Otherwise, if O.type == Change R,
            Send Empty Confirm L on a future packet
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Return
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リターン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Second, check for reordering (Section 6.6.4); If F.state == UNSTABLE or P.seqno &lt;= FGSR or (O.type == Confirm R and P.ackno &lt; FGSS), Ignore option and return
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二に、（セクション6.6.4）を並べ替えるかどうかを確認。 F.stateは==不安定になったりP.seqno &lt;= FGSR又は（O.type ==確認R及びP.ackno &lt;FGSS）、オプションとリターンを無視した場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Third, process Change R options;
      If O.type == Change R,
         If the option&#39;s value is valid,   /* Section 6.6.8 */
            Calculate new value
            Send Confirm L on a future packet
            Set F.state := STABLE
         Otherwise, if the option was Mandatory,
            Reset connection and return
         Otherwise,
            Send Empty Confirm L on a future packet
            /* Remain in existing state.  If that&#39;s CHANGING, this
               endpoint will retransmit its Change L option later. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Fourth, process Confirm R options (but only in CHANGING state).
      If F.state == CHANGING and O.type == Confirm R,
         If O.len &gt; 3,   /* nonempty */
            If the option&#39;s value is valid,
               Set F.value := new value
            Otherwise,
               Reset connection and return
         Set F.state := STABLE
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Versions of this diagram and pseudocode are also used by feature remotes; simply switch the &#34;L&#34;s and &#34;R&#34;s, so that the relevant options are Change R and Confirm L.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この図と擬似コードのバージョンも機能のリモコンで使用されています。単純に関連するオプションが変更Rになるように、「L」sおよび「R」Sを切り替えるとL.を確認
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3. Loss and Retransmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3. 損失および再送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packets containing Change and Confirm options might be lost or delayed by the network. Therefore, Change options are repeatedly transmitted to achieve reliability. We refer to this as &#34;retransmission&#34;, although of course there are no packet-level retransmissions in DCCP: a Change option that is sent again will be sent on a new packet with a new sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更を含むパケットとオプションを確認するには、ネットワークによって失われたり、遅れる場合がございます。そのため、変更オプションを繰り返し、信頼性を達成するために送信されます。もちろんDCCPにはパケットレベルの再送信されないが、私たちは、「再送信」としてこれを参照してください：再送信される変更オプションは、新しいシーケンス番号の新しいパケットに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CHANGING endpoint transmits another Change option once it realizes that it has not heard back from the other endpoint. The new Change option need not contain the same payload as the original; reordering protection will ensure that agreement is reached based on the most recently transmitted option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが戻って、他のエンドポイントから聞いていないことを理解したら、CHANGING終点は、他の変更オプションを送信します。新しい変更オプションは、オリジナルと同じペイロードを含む必要はありません。その合意を確保する並べ替え保護は、最も最近に送信オプションをもとに達しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CHANGING endpoint MUST continue retransmitting Change options until it gets some response or the connection terminates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CHANGING終点は、それはいくつかの応答を取得または接続が終了するまで変更オプションを再送継続する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints SHOULD use an exponential-backoff timer to decide when to retransmit Change options. (Packets generated specifically for feature negotiation MUST use such a timer.) The timer interval is initially set to not less than one round-trip time, and should back off to not less than 64 seconds. The backoff protects against delayed agreement due to the reordering protection algorithms described in the next section. Again, endpoints may piggyback Change options on packets they would have sent anyway or create new packets to carry the options. Any new packets are controlled by the relevant congestion-control mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、変更オプションを再送するタイミングを決定するために、指数バックオフタイマーを使用すべきです。 （パケットは、そのようなタイマーを使用しなければならない機能の交渉のために特別に生成される。）タイマー間隔は最初はない1未満のラウンドトリップ時間に設定され、64秒以上にバックオフする必要があります。バックオフが原因次のセクションで説明並び替え保護アルゴリズムに遅延合意を防ぎます。ここでも、エンドポイントは、彼らがオプションを運ぶために、とにかく送信または新しいパケットを作成していたパケットの変更オプションを背負うことがあります。すべての新しいパケットは、関連する輻輳制御機構によって制御されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Confirm options are never retransmitted, but the Confirm-sending endpoint MUST generate a Confirm option after every non-reordered Change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認したオプションは、再送信されることはありませんが、確認-送信するエンドポイントは、すべての非並べ替えの変更後のConfirmオプションを発生させなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.4. Reordering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.4. 並べ替え
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reordering might cause packets containing Change and Confirm options to arrive in an unexpected order. Endpoints MUST ignore feature negotiation options that do not arrive in strictly-increasing order by Sequence Number. The rest of this section presents two algorithms that fulfill this requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
並べ替えは、変更を含むパケットを引き起こし、予想外の順序で到着するオプションを確認することがあります。エンドポイントは、シーケンス番号によって厳密に昇順に到着しない特徴交渉オプションを無視しなければなりません。この節の残りの部分では、この要件を満たす2つのアルゴリズムを提示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first algorithm introduces two sequence number variables that each endpoint maintains for the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のアルゴリズムは、各エンドポイントが接続のために維持するに、2つのシーケンス番号変数を導入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FGSR Feature Greatest Sequence Number Received: The greatest sequence number received, considering only valid packets that contained one or more feature negotiation options (Change and/or Confirm). This value is initialized to ISR - 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信FGSRフィーチャー最大のシーケンス番号は：最大のシーケンス番号は、一つ以上の特徴交渉オプション（変更および/または確認）が含まれていた唯一の有効なパケットを考慮すると、受け取りました。 1  - この値は、ISRに初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FGSS Feature Greatest Sequence Number Sent: The greatest sequence number sent, considering only packets that contained one or more new Change options. A Change option is new if and only if it was generated during a transition from the STABLE or UNSTABLE state to the CHANGING state; Change options generated within the CHANGING state are retransmissions and MUST have exactly the same contents as previously transmitted options, allowing tolerance for reordering. FGSS is initialized to ISS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つ以上の新しい変更オプションが含まれているパケットのみを考慮すると、送信された最大の配列番号：FGSSは、送信最大のシーケンス番号を備えています。変更オプションがあれば、新規であり、それは、CHANGING状態に安定または不安定状態からの遷移中に生成された場合にのみ。 CHANGING状態内で発生する変更のオプションは再送信され、並べ替えのための許容範囲をできるように、以前に送信オプションとまったく同じ内容を持たなければなりません。 FGSSは、ISSに初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each endpoint checks two conditions on sequence numbers to decide whether to process received feature negotiation options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各エンドポイントは受け取った特徴交渉オプションを処理するかどうかを決定するために、シーケンス番号に2つの条件をチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If a packet&#39;s Sequence Number is less than or equal to FGSR, then its Change options MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットのシーケンス番号が以下FGSRに等しい場合は1、その変更オプションは無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If a packet&#39;s Sequence Number is less than or equal to FGSR, if it has no Acknowledgement Number, OR if its Acknowledgement Number is less than FGSS, then its Confirm options MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.それは確認応答番号を持っていない、またはその承認番号がFGSS未満である場合には、その確認のオプションは無視されなければならない場合は、パケットのシーケンス番号は、以下FGSRに等しい場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternatively, an endpoint MAY maintain separate FGSR and FGSS values for every feature. FGSR(F/X) would equal the greatest sequence number received, considering only packets that contained Change or Confirm options applying to feature F/X; FGSS(F/X) would be defined similarly. This algorithm requires more state, but is slightly more forgiving to multiple overlapped feature negotiations. Either algorithm MAY be used; the first algorithm, with connection-wide FGSR and FGSS variables, is RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、エンドポイントは、すべての機能のための独立したFGSRとFGSS値を維持することができます。 FGSR（F / X）が変更を含んでいたパケットのみを考慮し、最大シーケンス番号が受信等しいか又はF / Xを特色する適用オプションを確認することになります。 FGSS（F / X）が同様に定義されます。このアルゴリズムは、より多くの状態を必要としますが、複数の重複した特徴交渉にもう少し寛容です。どちらのアルゴリズムが使用されてもよいです。接続全体FGSRとFGSS変数との最初のアルゴリズムは、推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One consequence of these rules is that a CHANGING endpoint will ignore any Confirm option that does not acknowledge the latest Change option sent. This ensures that agreement, once achieved, used the most recent available information about the endpoints&#39; preferences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのルールの1つの結果は、CHANGING終点が送られた最新の変更オプションを認めていない任意のConfirmオプションを無視するということです。これは、一度達成合意は、エンドポイントの好みについての最新の入手可能な情報を使用することを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.5. Preference Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.5. プリファレンスの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints are allowed to change their preference lists at any time. However, an endpoint that changes its preference list while in the CHANGING state MUST transition to the UNSTABLE state. It will transition back to CHANGING once it has transmitted a Change option with the new preference list. This ensures that agreement is based on active preference lists. Without the UNSTABLE state, simultaneous negotiation -- where the endpoints began independent negotiations for the same feature at the same time -- might lead to the negotiation&#39;s terminating with the endpoints thinking the feature had different values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、いつでも自分の好みのリストを変更することが許可されています。しかし、変更状態にある間、その優先リストを変更するエンドポイントが不安定な状態に移行しなければなりません。それは新しい優先リストでの変更のオプションを送信した後に変更することに戻って移行します。これは、契約は、アクティブ優先リストに基づいていることを保証します。不安定な状態がなければ、同時交渉 - エンドポイントが同時に同じ機能のための独立した交渉を開始しました - 機能を考えて、エンドポイントが異なる値を持っていたとの交渉の終結につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.6. Simultaneous Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.6. 同時交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two endpoints might simultaneously open negotiation for the same feature, after which an endpoint in the CHANGING state will receive a Change option for the same feature. Such received Change options can act as responses to the original Change options. The CHANGING endpoint MUST examine the received Change&#39;s preference list, reconcile that with its own preference list (as expressed in its generated Change options), and generate the corresponding Confirm option. It can then transition to the STABLE state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのエンドポイントは、CHANGING状態の終点は同じ機能の変更オプションを受け取るた後、同じ機能、同時にオープン交渉をすることがあります。このような受信した変更オプションは、元の変更オプションへの応答としての役割を果たすことができます。変更エンドポイントは、受信した変更の好みのリストを調べる（その生成された変更オプションで表現されるように）それ自身の好みのリストとそれを照合し、対応する確認オプションを生成しなければなりません。それは安定した状態に遷移することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.7. Unknown Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.7. 不明な特長
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints may receive Change options referring to feature numbers they do not understand -- for instance, when an extended DCCP converses with a non-extended DCCP. Endpoints MUST respond to unknown Change options with Empty Confirm options (that is, Confirm options containing no data), which inform the CHANGING endpoint that the feature was not understood. However, if the Change option was Mandatory, the connection MUST be reset; see Section 6.6.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、拡張DCCPが非拡張DCCPと対話するとき - エンドポイントは、彼らが理解していない数字を特徴とする参照の変更オプションを受け取ることができます。エンドポイントは、機能が理解されなかったCHANGING終点を知らせる空の確認オプション（つまり、何もデータを含まないオプションを確認してください）、未知の変更オプションに反応しなければなりません。変更オプションが必須だった場合は、接続をリセットする必要があります。 6.6.9項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving an empty Confirm option for some feature, the CHANGING endpoint MUST transition back to the STABLE state, leaving the feature&#39;s value unchanged. Section 15 suggests that the default value for any extension feature correspond to &#34;extension not available&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの機能のための空のConfirmオプションを受け取ると、CHANGING終点は、機能の値が変わらないままに、安定した状態に戻って遷移する必要があります。セクション15は、任意の拡張機能のデフォルト値は「利用できない拡張子」に対応することを示唆しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some features are required to be understood by all DCCPs (see Section 6.4). The CHANGING endpoint SHOULD reset the connection (with Reset Code 5, &#34;Option Error&#34;) if it receives an empty Confirm option for such a feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部の機能は、すべてのDCCPsが理解される必要がある（6.4節を参照してください）。それは、このような機能のための空のConfirmオプションを受信した場合CHANGING終点は、（リセットコード5、「オプション誤り」との）接続をリセットする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since Confirm options are generated only in response to Change options, an endpoint should never receive a Confirm option referring to a feature number it does not understand. Nevertheless, endpoints MUST ignore any such options they receive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認オプションは、オプションを変更するためにのみ応答して生成されるので、エンドポイントは、それが理解していない機能番号を参照Confirmオプションを受け取ることはありません。それにもかかわらず、エンドポイントは、彼らが受け取るどのようなオプションを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.8. Invalid Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.8. 無効なオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP endpoint might receive a Change or Confirm option for a known feature that lists one or more values that it does not understand. Some, but not all, such options are invalid, depending on the relevant reconciliation rule (Section 6.3). For instance:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点は変更を受けるか、それは理解していない1つ以上の値を示しています知られている機能のオプションを確認することがあります。いくつかは、すべてではないが、そのようなオプションは、関連する和解規則（6.3節）に応じて、無効です。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All features have length limitations, and options with invalid lengths are invalid. For example, the Ack Ratio feature takes 16-bit values, so valid &#34;Confirm R(Ack Ratio)&#34; options have option length 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oすべての機能は、長さの制限があり、不正な長さのオプションは無効です。例えば、肯定応答比フィーチャは、16ビットの値を取るので、有効な「R（のAck比）を確認」オプションは、オプションの長さ5を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Some non-negotiable features have value limitations. The Ack Ratio feature takes two-byte, non-zero integer values, so a &#34;Change L(Ack Ratio, 0)&#34; option is never valid. Note that server-priority features do not have value limitations, since unknown values are handled as a matter of course.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oいくつかの非交渉機能は、値の制限があります。 Ack比フィーチャは、2バイト、ゼロ以外の整数値をとるので、「変更L（Ackを比、0）」オプションが有効になることはありません。未知の値は、当然のこととして扱われるため、サーバーの優先度の機能は、値の制限を持たないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any Confirm option that selects the wrong value, based on the two preference lists and the relevant reconciliation rule, is invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 2つの好みのリストと関連する和解のルールに基づいて、間違った値を選択し、任意のConfirmオプションは、無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, unexpected Confirm options -- that refer to unknown feature numbers, or that don&#39;t appear to be part of a current negotiation -- are not invalid, although they are ignored by the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、予想外の確認オプション - 未知の機能番号を参照、またはそれは、現在の交渉の一部であることが表示されません - 彼らは受信機で無視しているが、無効ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint receiving an invalid Change option MUST respond with the corresponding empty Confirm option. An endpoint receiving an invalid Confirm option MUST reset the connection, with Reset Code 5, &#34;Option Error&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不正な変更オプションを受信エンドポイントは、対応する空のConfirmオプションで応じなければなりません。無効Confirmオプションを受け取るエンドポイントはリセットコード5、「オプション誤り」との接続を、リセットする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.9. Mandatory Feature Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.9. 必須機能のネゴシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change options may be preceded by Mandatory options (Section 5.8.2). Mandatory Change options are processed like normal Change options except that the following failure cases will cause the receiver to reset the connection with Reset Code 6, &#34;Mandatory Failure&#34;, rather than send a Confirm option. The connection MUST be reset if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更オプションは必須オプション（セクション5.8.2）が先行することができます。必須の変更オプションには、次の障害の場合は、受信機がリセットコード6、「必須失敗」との接続をリセットするのではなく、Confirmオプションを送信するようになりますことを除いて、通常の変更オプションのように処理されます。場合は、接続をリセットする必要があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the Change option&#39;s feature number was not understood;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの変更オプションの機能番号が理解されていませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the Change option&#39;s value was invalid, and the receiver would normally have sent an empty Confirm option in response; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの変更オプションの値が無効であり、受信機は、通常、応答における空のConfirmオプションを送っているだろう。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o for server-priority features, there was no shared entry in the two endpoints&#39; preference lists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの優先度の機能のoは、2つのエンドポイントの好みのリストには、共有エントリはありませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other failure cases do not cause connection reset; in particular, reordering protection may cause a Mandatory Change option to be ignored without resetting the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その他の障害の場合は、接続リセットは発生しません。具体的には、並べ替えの保護は、接続をリセットせずに無視することが必須の変更オプションを引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Confirm options behave identically and have the same reset conditions whether or not they are Mandatory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションは同じように動作し、それらが必須かどうか、同じリセット条件を持っていることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Sequence Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.シーケンス番号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP uses sequence numbers to arrange packets into sequence, to detect losses and network duplicates, and to protect against attackers, half-open connections, and the delivery of very old packets. Every packet carries a Sequence Number; most packet types carry an Acknowledgement Number as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは、シーケンスにパケットを配置する損失やネットワークの重複を検出すると、攻撃者は、ハーフオープン接続、および非常に古いパケットの配信から保護するためにシーケンス番号を使用しています。すべてのパケットは、シーケンス番号を運びます。ほとんどのパケットタイプは、同様に確認応答番号を運びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP sequence numbers are packet based. That is, Sequence Numbers generated by each endpoint increase by one, modulo 2^48, per packet. Even DCCP-Ack and DCCP-Sync packets, and other packets that don&#39;t carry user data, increment the Sequence Number. Since DCCP is an unreliable protocol, there are no true retransmissions, but effective retransmissions, such as retransmissions of DCCP-Request packets, also increment the Sequence Number. This lets DCCP implementations detect network duplication, retransmissions, and acknowledgement loss; it is a significant departure from TCP practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPのシーケンス番号は、パケットベースです。すなわち、パケットごとに一つ、各エンドポイントの増加、モジュロ2 ^ 48によって生成されたシーケンス番号です。でも、DCCP-AckのとDCCP-同期パケット、およびユーザデータを運ばない他のパケットは、シーケンス番号をインクリメントします。 DCCPは信頼できないプロトコルであるので、そこには真の再送はありませんが、このようなDCCP-Requestパケットの再送信などの効果的な再送信は、また、シーケンス番号をインクリメントします。これはDCCP実装がネットワーク複製、再送信、および承認損失を検出することができます。それはTCPの練習から大幅に逸脱しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Variables
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 変数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints maintain a set of sequence number variables for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点は、各接続のシーケンス番号変数のセットを維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ISS The Initial Sequence Number Sent by this endpoint. This equals the Sequence Number of the first DCCP-Request or DCCP-Response sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ISSこのエンドポイントによって送信された初期シーケンス番号。これは最初のDCCP-要求または送信されたDCCP  - 応答のシーケンス番号に等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ISR The Initial Sequence Number Received from the other endpoint. This equals the Sequence Number of the first DCCP-Request or DCCP-Response received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のエンドポイントから受信した初期シーケンス番号ISR。これは、受信した最初DCCP-要求またはDCCP-応答のシーケンス番号に等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GSS The Greatest Sequence Number Sent by this endpoint. Here, and elsewhere, &#34;greatest&#34; is measured in circular sequence space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GSSこのエンドポイントによって送信された最大のシーケンス番号。ここでは、他の場所、「最大」は、円形の系列スペースで測定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GSR The Greatest Sequence Number Received from the other endpoint on an acknowledgeable packet. (Section 7.4 defines this term.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GSR承認可能パケット上の他のエンドポイントから受信した最大のシーケンス番号。 （7.4節は、この用語を定義します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GAR The Greatest Acknowledgement Number Received from the other endpoint on an acknowledgeable packet that was not a DCCP-Sync.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GAR DCCP-Syncのではなかった承認可能パケット上の他のエンドポイントから受信した最大の確認番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some other variables are derived from these primitives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの他の変数は、これらのプリミティブに由来しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SWL and SWH (Sequence Number Window Low and High) The extremes of the validity window for received packets&#39; Sequence Numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SWLとSWH（シーケンス番号ウィンドウLowとHigh）受信パケットのシーケンス番号の有効ウィンドウの両極端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AWL and AWH (Acknowledgement Number Window Low and High) The extremes of the validity window for received packets&#39; Acknowledgement Numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AWLとAWH（承認番号ウィンドウLowとHigh）受信パケットの確認応答番号の有効ウィンドウの両極端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Initial Sequence Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 初期シーケンス番号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The endpoints&#39; initial sequence numbers are set by the first DCCP-Request and DCCP-Response packets sent. Initial sequence numbers MUST be chosen to avoid two problems:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントの初期シーケンス番号が送信された最初のDCCP-要求とDCCP-応答パケットによって設定されています。初期シーケンス番号は、二つの問題を回避するために選ばなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o delivery of old packets, where packets lingering in the network from an old connection are delivered to a new connection with the same addresses and port numbers; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
古い接続からネットワークに長引くパケットが同じアドレスとポート番号との新しい接続に配信されている古いパケットのO配信。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sequence number attacks, where an attacker can guess the sequence numbers that a future connection would use [M85].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、将来の接続は、[M85]を使用することをシーケンス番号を推測することができ、シーケンス番号攻撃、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These problems are the same as those faced by TCP, and DCCP implementations SHOULD use TCP&#39;s strategies to avoid them [RFC793, RFC1948]. The rest of this section explains these strategies in more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793、RFC1948]これらの問題は、TCPが直面しているものと同じであり、DCCP実装は、それらを避けるために、TCPの戦略を使用すべきです。このセクションの残りの部分は、より詳細にこれらの戦略を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To address the first problem, an implementation MUST ensure that the initial sequence number for a given &lt;source address, source port, destination address, destination port&gt; 4-tuple doesn&#39;t overlap with recent sequence numbers on previous connections with the same 4-tuple. (&#34;Recent&#34; means sent within 2 maximum segment lifetimes, or 4 minutes.) The implementation MUST additionally ensure that the lower 24 bits of the initial sequence number don&#39;t overlap with the lower 24 bits of recent sequence numbers (unless the implementation plans to avoid short sequence numbers; see Section 7.6). An implementation that has state for a recent connection with the same 4-tuple can pick a good initial sequence number explicitly. Otherwise, it could tie initial sequence number selection to some clock, such as the 4-microsecond clock used by TCP [RFC793]. Two separate clocks may be required, one for the upper 24 bits and one for the lower 24 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の問題に対処するために、実装は確保しなければならないことを指定された&lt;ソースアドレス、ソースポート、宛先アドレス、宛先ポート&gt; 4タプルは、同じ4-以前の接続における最近のシーケンス番号と重複しないための初期シーケンス番号タプル。 （2つの最大セグメント寿命、または4分以内に送信された「最近の」を意味する。）の実装は、さらに初期シーケンス番号の下位24ビットは、実施計画しない限り、（最近のシーケンス番号の下位24ビットと重複しないようにする必要があり短いシーケンス番号を避けるために、7.6節を参照してください）。同じ4組との最近の接続の状態を持っている実装は、明示的に良好な初期シーケンス番号を選ぶことができます。それ以外の場合は、TCP [RFC793]で使用される4マイクロ秒のクロックとして、いくつかのクロックに初期シーケンス番号の選択を結ぶことができました。二つの別個のクロックは、上位24ビット用と下位24ビットのための1つを必要とすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To address the second problem, an implementation MUST provide each 4-tuple with an independent initial sequence number space. Then, opening a connection doesn&#39;t provide any information about initial sequence numbers on other connections to the same host. [RFC1948] achieves this by adding a cryptographic hash of the 4-tuple and a secret to each initial sequence number. For the secret, [RFC1948] recommends a combination of some truly random data [RFC4086], an administratively installed passphrase, the endpoint&#39;s IP address, and the endpoint&#39;s boot time, but truly random data is sufficient. Care should be taken when the secret is changed; such a change alters all initial sequence number spaces, which might make an initial sequence number for some 4-tuple equal a recently sent sequence number for the same 4-tuple. To avoid this problem, the endpoint might remember dead connection state for each 4-tuple or stay quiet for 2 maximum segment lifetimes around such a change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二の問題に対処するために、実装は、独立した初期シーケンス番号スペースで各4タプルを提供しなければなりません。その後、接続を開くと、同じホストに他の接続の初期シーケンス番号に関する情報を提供していません。 [RFC1948]は、各初期シーケンス番号に4タプルと秘密の暗号ハッシュを追加することによって、これを達成します。秘密の場合は、[RFC1948]はいくつかの本当にランダムデータ[RFC4086]、行政インストールパスフレーズ、エンドポイントのIPアドレス、およびエンドポイントのブート時間の組み合わせを推奨していますが、真にランダムなデータが十分です。秘密が変更されたときには注意が必要です。そのような変化は、同一の4タプルのためのいくつかの4-タプル等しい最近送信されたシーケンス番号の初期シーケンス番号を作る可能性のあるすべての初期シーケンス番号空間を変化させます。この問題を回避するために、エンドポイントは各4タプルのために死んだの接続状態を覚えているか、そのような変化を約2つの最大セグメント寿命のために静かにとどまる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Quiet Time
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 静かな時間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints, like TCP endpoints, must take care before initiating connections when they boot. In particular, they MUST NOT send packets whose sequence numbers are close to the sequence numbers of packets lingering in the network from before the boot. The simplest way to enforce this rule is for DCCP endpoints to avoid sending any packets until one maximum segment lifetime (2 minutes) after boot.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPエンドポイントのようなDCCPエンドポイントは、それらが起動時に接続を開始する前に注意しなければなりません。特に、それらは、その配列番号ブート前からネットワークに長引くパケットのシーケンス番号に近いパケットを送ってはいけません。 DCCPエンドポイントが起動次々最大セグメント寿命（2分）までの任意のパケットを送信することを避けるために、このルールを適用する最も簡単な方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other enforcement mechanisms include remembering recent sequence numbers across boots and reserving the upper 8 or so bits of initial sequence numbers for a persistent counter that decrements by two each boot. (The latter mechanism would require disallowing packets with short sequence numbers; see Section 7.6.1.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その他の実施メカニズムは、ブーツ全体で、最近のシーケンス番号を記憶し、2各ブートでデクリメント永続的なカウンタの初期シーケンス番号の上位8かそこらビットを確保含まれています。 （後者のメカニズムは、短いシーケンス番号を持つパケットを拒否必要とする;セクション7.6.1を参照します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Acknowledgement Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 謝辞番号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cumulative acknowledgements are meaningless in an unreliable protocol. Therefore, DCCP&#39;s Acknowledgement Number field has a different meaning from TCP&#39;s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
累積確認応答は、信頼できないプロトコルでは無意味です。したがって、DCCPの承認番号フィールドには、TCPの異なる意味を持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A received packet is classified as acknowledgeable if and only if its header was successfully processed by the receiving DCCP. In terms of the pseudocode in Section 8.5, a received packet becomes acknowledgeable when the receiving endpoint reaches Step 8. This means, for example, that all acknowledgeable packets have valid header checksums and sequence numbers. A sent packet&#39;s Acknowledgement Number MUST equal the sending endpoint&#39;s GSR, the Greatest Sequence Number Received on an acknowledgeable packet, for all packet types except DCCP-Sync and DCCP-SyncAck.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信されたパケットは、IF承認可能として分類され、そのヘッダが正常に受信DCCPによって処理された場合にのみ。セクション8.5の擬似コードの点で、受信したパケットは、受信エンドポイントが、すべての承認可能パケットが有効なヘッダチェックサムとシーケンス番号を持っていること、例えば、これは、ステップ8に到達したときに承認可能となります。送信されたパケットの確認応答番号は、送信エンドポイントのGSR、DCCP-SyncとDCCP-SyncAck以外のすべてのパケットタイプのため、承認可能パケットで最もすばらしいSequence Number Receivedと等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Acknowledgeable&#34; does not refer to data processing. Even acknowledgeable packets may have their application data dropped, due to receive buffer overflow or corruption, for instance. Data Dropped options report these data losses when necessary, letting congestion control mechanisms distinguish between network losses and endpoint losses. This issue is discussed further in Sections 11.4 and 11.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「承認可能」は、データ処理を参照していません。承認可能パケットは、それらのアプリケーションデータは、例えば、バッファオーバーフローや破損を受けることにより、低下していることができます。データが必要なときのオプションが輻輳制御メカニズムは、ネットワークの損失とエンドポイントの損失を区別せ、これらのデータの損失を報告して落としました。この問題は、セクション11.4と11.7でさらに議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Sync and DCCP-SyncAck packets&#39; Acknowledgement Numbers differ as follows: The Acknowledgement Number on a DCCP-Sync packet corresponds to a received packet, but not necessarily to an acknowledgeable packet; in particular, it might correspond to an out-of-sync packet whose options were not processed. The Acknowledgement Number on a DCCP-SyncAck packet always corresponds to an acknowledgeable DCCP-Sync packet; it might be less than GSR in the presence of reordering.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにDCCP-SyncとDCCP-SyncAckパケットの確認応答番号が異なる：DCCP同期パケットに確認応答番号は必ずしも必要ではないが承認可能パケットに、受信したパケットに対応します。特に、それは、そのオプションが処理されなかった外の同期パケットに対応することがあります。 DCCP-SyncAckパケットの確認応答番号は、常に受け付け可能DCCP-Syncのパケットに対応します。それは、並べ替えの存在下でのGSR未満であるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. Validity and Synchronization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. 有効性と同期
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any DCCP endpoint might receive packets that are not actually part of the current connection. For instance, the network might deliver an old packet, an attacker might attempt to hijack a connection, or the other endpoint might crash, causing a half-open connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意のDCCP終点は、実際には現在の接続の一部ではないパケットを受け取ることがあります。例えば、ハーフオープン接続を引き起こして、古いパケットを配信する可能性があるネットワークでは、攻撃者が接続をハイジャックしようとしたり、他のエンドポイントがクラッシュする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP, like TCP, uses sequence number checks to detect these cases. Packets whose Sequence and/or Acknowledgement Numbers are out of range are called sequence-invalid and are not processed normally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは、TCPのように、これらのケースを検出するためのシーケンス番号のチェックを使用しています。その配列および/または承認番号が範囲外の系列無効と呼ばれ、正常に処理されていないパケット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike TCP, DCCP requires a synchronization mechanism to recover from large bursts of loss. One endpoint might send so many packets during a burst of loss that when one of its packets finally got through, the other endpoint would label its Sequence Number as invalid. A handshake of DCCP-Sync and DCCP-SyncAck packets recovers from this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPとは異なり、DCCPは、損失の大バーストから回復するために同期メカニズムが必要です。一方のエンドポイントは、そのパケットの1つが最終的に通じ得たとき、他のエンドポイントは無効とそのシーケンス番号にラベルを付けるだろうと損失のバースト中に非常に多くのパケットを送信することがあります。 DCCP-SyncとDCCP-SyncAckパケットのハンドシェークは、この場合から回復します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.1. Sequence and Acknowledgement Number Windows
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.1. シーケンスおよび確認応答番号のWindows
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each DCCP endpoint defines sequence validity windows that are subsets of the Sequence and Acknowledgement Number spaces. These windows correspond to packets the endpoint expects to receive in the next few round-trip times. The Sequence and Acknowledgement Number windows always contain GSR and GSS, respectively. The window widths are controlled by Sequence Window features for the two half-connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各DCCP終点は、シーケンスおよび確認応答番号スペースのサブセットである一連の妥当性の窓を定義します。これらのウィンドウは、エンドポイントは、次のいくつかのラウンドトリップ時間に受信することを期待パケットに対応しています。シーケンスおよび確認応答番号のウィンドウは、常に、それぞれ、GSRとGSSが含まれています。ウィンドウの幅は、二つの半接続のためのシーケンスウィンドウ機能によって制御されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Sequence Number validity window for packets from DCCP B is [SWL, SWH]. This window always contains GSR, the Greatest Sequence Number Received on a sequence-valid packet from DCCP B. It is W packets wide, where W is the value of the Sequence Window/B feature. One-fourth of the sequence window, rounded down, is less than or equal to GSR, and three-fourths is greater than GSR. (This asymmetric placement assumes that bursts of loss are more common in the network than significant reorderings.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP Bからのパケットのシーケンス番号の有効性ウィンドウは[SWL、SWH]です。このウィンドウには、常にGSR、Wはシーケンスウィンドウ/ Bの機能の値であり、Wパケット広いですDCCP B.それから配列の有効なパケットで最もすばらしいSequence Number Receivedが含まれています。切り捨てシーケンスウィンドウの4分の1は、以下GSRに等しく、四分の三は、GSRよりも大きいです。 （この非対称配置は、損失のバーストが重要reorderingsよりもネットワークでより一般的であることを前提としています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     invalid  |       valid Sequence Numbers        |  invalid
   &lt;---------*|*===========*=======================*|*---------&gt;
         GSR -|GSR + 1 -   GSR                 GSR +|GSR + 1 +
    floor(W/4)|floor(W/4)                 ceil(3W/4)|ceil(3W/4)
               = SWL                           = SWH
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Acknowledgement Number validity window for packets from DCCP B is [AWL, AWH]. The high end of the window, AWH, equals GSS, the Greatest Sequence Number Sent by DCCP A; the window is W&#39; packets wide, where W&#39; is the value of the Sequence Window/A feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP Bからのパケットの確認応答番号の有効性ウィンドウは[AWL、AWH]です。ウィンドウのハイエンド、AWH、GSS、DCCP Aによって送信された最大のシーケンス番号が等しいです。ウィンドウシーケンスウィンドウ/特徴の値はW「Wは、ここで、パケット広い」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     invalid  |    valid Acknowledgement Numbers    |  invalid
   &lt;---------*|*===================================*|*---------&gt;
      GSS - W&#39;|GSS + 1 - W&#39;                      GSS|GSS + 1
               = AWL                           = AWH
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SWL and AWL are initially adjusted so that they are not less than the initial Sequence Numbers received and sent, respectively:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらはそれぞれ、受信及び送信された初期シーケンス番号以上であるようにSWLとAWLは、最初に調整されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         SWL := max(GSR + 1 - floor(W/4), ISR),
         AWL := max(GSS + 1 - W&#39;, ISS).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These adjustments MUST be applied only at the beginning of the connection. (Long-lived connections may wrap sequence numbers so that they appear to be less than ISR or ISS; the adjustments MUST NOT be applied in that case.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの調整は、接続の開始時にのみ適用されなければなりません。 （彼らはISRかISSより少ないように見えるように、長命の接続は、シーケンス番号をラップすることがあり、調整は、その場合に適用してはなりません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.2. Sequence Window Feature
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.2. シーケンスウィンドウ機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Sequence Window/A feature determines the width of the Sequence Number validity window used by DCCP B and the width of the Acknowledgement Number validity window used by DCCP A. DCCP A sends a &#34;Change L(Sequence Window, W)&#34; option to notify DCCP B that the Sequence Window/A value is W.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスウィンドウ/特徴はDCCP Bによって使用されるシーケンス番号の有効性ウィンドウの幅を決定し、DCCP A. DCCP Aによって使用される確認応答番号の有効性ウィンドウの幅を通知するための「変更L（シーケンスウィンドウ、W）」オプションを送りますDCCP Bシーケンスウィンドウ/ Aの値が、Wであること
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sequence Window has feature number 3 and is non-negotiable. It takes 48-bit (6-byte) integer values, like DCCP sequence numbers. Change and Confirm options for Sequence Window are therefore 9 bytes long. New connections start with Sequence Window 100 for both endpoints. The minimum valid Sequence Window value is Wmin = 32. The maximum valid Sequence Window value is Wmax = 2^46 - 1 = 70368744177663. Change options suggesting Sequence Window values out of this range are invalid and MUST be handled accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスウィンドウは、機能番号3を持っており、非交渉です。これはDCCPシーケンス番号と同様に、48ビット（6バイト）の整数値をとります。変更およびシーケンスウィンドウのオプションを確認するには、したがって、9バイトの長さです。新しい接続は、両方のエンドポイントのシーケンスウィンドウ100で始まります。最小の有効なシーケンスウィンドウ値は最大有効シーケンスウィンドウ値Wminと= 32である値Wmax = 2 ^ 46  - でこの範囲外のシーケンスウィンドウ値を示唆1 = 70368744177663.変更オプションは無効であり、それに応じて取り扱わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proper Sequence Window/A value must reflect the number of packets DCCP A expects to be in flight. Only DCCP A can anticipate this number. Values that are too small increase the risk of the endpoints getting out sync after bursts of loss, and values that are much too small can prevent productive communication whether or not there is loss. On the other hand, too-large values increase the risk of connection hijacking; Section 7.5.5 quantifies this risk. One good guideline is for each endpoint to set Sequence Window to about five times the maximum number of packets it expects to send in a round-trip time. Endpoints SHOULD send Change L(Sequence Window) options, as necessary, as the connection progresses. Also, an endpoint MUST NOT persistently send more than its Sequence Window number of packets per round-trip time; that is, DCCP A MUST NOT persistently send more than Sequence Window/A packets per RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適切なシーケンスウィンドウ/値がDCCP Aが飛行中であることを期待するパケットの数を反映しなければなりません。唯一のDCCP Aは、この数を予測することができます。あまりにも小さくて損失のバースト後に同期を抜け出すエンドポイントのリスクは小さすぎる増加された値、および値は損失があるかどうかを生産通信を防ぐことができます。一方、大きすぎる値は、接続ハイジャックのリスクを高めます。 7.5.5項では、このリスクを定量化します。一つの良いガイドラインは約5倍に、それは往復時間に送信することを期待するパケットの最大数をシーケンスウィンドウを設定するために、各エンドポイントのためです。接続が進むにつれてエンドポイントは、必要に応じて変更L（シーケンスウィンドウ）のオプションを、送信すべきです。また、エンドポイントは、持続的に往復時間当たりのパケットのシーケンスウィンドウの数よりも多くを送ってはいけません。つまり、DCCP Aは、永続的にRTTごとのシーケンスウィンドウ/ Aパケット以上のものを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.3. Sequence-Validity Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.3. シーケンス・妥当性ルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sequence-validity depends on the received packet&#39;s type. This table shows the sequence and acknowledgement number checks applied to each packet; a packet is sequence-valid if it passes both tests, and sequence-invalid if it does not. Many of the checks refer to the sequence and acknowledgement number validity windows [SWL, SWH] and [AWL, AWH] defined in Section 7.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス・妥当性は、受信したパケットの種類によって異なります。このテーブルは、シーケンスと、各パケットに適用される確認応答番号の確認を示す図です。そうでない場合には、テスト、および系列無効の両方に合格した場合、パケットは配列有効です。チェックの多くは、7.5.1項で定義された順序と確認応答番号の妥当性の窓[SWL、SWH]と[AWL、AWH]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                             Acknowledgement Number
   Packet Type      Sequence Number Check    Check
   -----------      ---------------------    ----------------------
   DCCP-Request     SWL &lt;= seqno &lt;= SWH (*)  N/A
   DCCP-Response    SWL &lt;= seqno &lt;= SWH (*)  AWL &lt;= ackno &lt;= AWH
   DCCP-Data        SWL &lt;= seqno &lt;= SWH      N/A
   DCCP-Ack         SWL &lt;= seqno &lt;= SWH      AWL &lt;= ackno &lt;= AWH
   DCCP-DataAck     SWL &lt;= seqno &lt;= SWH      AWL &lt;= ackno &lt;= AWH
   DCCP-CloseReq    GSR &lt;  seqno &lt;= SWH      GAR &lt;= ackno &lt;= AWH
   DCCP-Close       GSR &lt;  seqno &lt;= SWH      GAR &lt;= ackno &lt;= AWH
   DCCP-Reset       GSR &lt;  seqno &lt;= SWH      GAR &lt;= ackno &lt;= AWH
   DCCP-Sync        SWL &lt;= seqno             AWL &lt;= ackno &lt;= AWH
   DCCP-SyncAck     SWL &lt;= seqno             AWL &lt;= ackno &lt;= AWH
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*) Check not applied if connection is in LISTEN or REQUEST state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*）接続がLISTENやREQUEST状態にある場合には適用されません確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, packets are sequence-valid if their Sequence and Acknowledgement Numbers lie within the corresponding valid windows, [SWL, SWH] and [AWL, AWH]. The exceptions to this rule are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それらの配列確認応答番号が対応する有効ウィンドウ内に存在する場合、一般的に、パケットがシーケンス有効である、[SWL、SWH]と[AWL、AWH]。次のようにこのルールの例外は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Since DCCP-CloseReq, DCCP-Close, and DCCP-Reset packets end a connection, they cannot have Sequence Numbers less than or equal to GSR, or Acknowledgement Numbers less than GAR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DCCPクローズDCCP-CloseReq、以来、およびDCCP  - リセットパケットが接続を終了し、それらは以下GAR未満GSR、または確認応答番号に等しいシーケンス番号を持つことができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DCCP-Sync and DCCP-SyncAck Sequence Numbers are not strongly checked. These packet types exist specifically to get the endpoints back into sync; checking their Sequence Numbers would eliminate their usefulness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DCCP-SyncとDCCP-SyncAckシーケンス番号が強くチェックされません。これらのパケットタイプは、バック同期にエンドポイントを取得するために、具体的に存在します。そのシーケンス番号をチェックしてその有用性を排除するであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The lenient checks on DCCP-Sync and DCCP-SyncAck packets allow continued operation after unusual events, such as endpoint crashes and large bursts of loss, but there&#39;s no need for leniency in the absence of unusual events -- that is, during ongoing successful communication. Therefore, DCCP implementations SHOULD use the following, more stringent checks for active connections, where a connection is considered active if it has received valid packets from the other endpoint within the last three round-trip times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-SyncとDCCP-SyncAckパケットの寛大なチェックは、このようなエンドポイントのクラッシュや損失の大バーストなど、異常なイベント、後に運転を続けてできますが、異常なイベントが存在しない場合に寛大のための必要はありません - つまり、継続的な成功を収め通信中。したがって、DCCP実装は、それが最後の三つのラウンドトリップ時間内に他のエンドポイントから有効なパケットを受信した場合、接続がアクティブであると考えられるアクティブな接続は、次の、より厳しいチェックを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                             Acknowledgement Number
   Packet Type      Sequence Number Check    Check
   -----------      ---------------------    ----------------------
   DCCP-Sync        SWL &lt;= seqno &lt;= SWH      AWL &lt;= ackno &lt;= AWH
   DCCP-SyncAck     SWL &lt;= seqno &lt;= SWH      AWL &lt;= ackno &lt;= AWH
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, an endpoint MAY apply the following more stringent checks to DCCP-CloseReq, DCCP-Close, and DCCP-Reset packets, further lowering the probability of successful blind attacks using those packet types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、エンドポイントは、さらに、それらのパケットタイプを使用して成功したブラインド攻撃の確率を下げ、DCCP-CloseReq、DCCP-閉じる、およびDCCP  - リセットパケットを次のように、より厳格なチェックを適用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since these checks can cause extra synchronization overhead and delay connection closing when packets are lost, they should be considered experimental.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのチェックは、余分な同期のオーバーヘッドが発生し、パケットが失われたときに、接続閉鎖を遅らせることができるので、彼らは実験的と考えるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                             Acknowledgement Number
   Packet Type      Sequence Number Check    Check
   -----------      ---------------------    ----------------------
   DCCP-CloseReq    seqno == GSR + 1         GAR &lt;= ackno &lt;= AWH
   DCCP-Close       seqno == GSR + 1         GAR &lt;= ackno &lt;= AWH
   DCCP-Reset       seqno == GSR + 1         GAR &lt;= ackno &lt;= AWH
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that sequence-validity is only one of the validity checks applied to received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その配列妥当性のみ受信パケットに適用される妥当性チェックのいずれかであることに注意。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.4. Handling Sequence-Invalid Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.4. 系列無効パケットの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints respond to received sequence-invalid packets as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにエンドポイントは、受信系列無効のパケットに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any sequence-invalid DCCP-Sync or DCCP-SyncAck packet MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O任意の系列無効DCCP同期またはDCCP-SyncAckパケットを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sequence-invalid DCCP-Reset packet MUST elicit a DCCP-Sync packet in response (subject to a possible rate limit). This response packet MUST use a new Sequence Number, and thus will increase GSS; GSR will not change, however, since the received packet was sequence-invalid. The response packet&#39;s Acknowledgement Number MUST equal GSR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oシーケンス無効DCCP  - リセットパケットは、（可能なレート制限を受ける）DCCP同期応答のパケットを誘発しなければなりません。この応答パケットは、新しいシーケンス番号を使用しなければならないので、GSSが増加します。受信したパケットが系列無効だったのでGSRは、しかし、変更されません。応答パケットの確認応答番号はGSRと等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any other sequence-invalid packet MUST elicit a similar DCCP-Sync packet, except that the response packet&#39;s Acknowledgement Number MUST equal the sequence-invalid packet&#39;s Sequence Number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O任意の他の配列、無効なパケットは、応答パケットの確認応答番号は配列の無効なパケットのシーケンス番号に等しくなければならないことを除いて、同様のDCCP同期パケットを誘発しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving a sequence-valid DCCP-Sync packet, the peer endpoint (say, DCCP B) MUST update its GSR variable and reply with a DCCP-SyncAck packet. The DCCP-SyncAck packet&#39;s Acknowledgement Number will equal the DCCP-Sync&#39;s Sequence Number, which is not necessarily GSR. Upon receiving this DCCP-SyncAck, which will be sequence-valid since it acknowledges the DCCP-Sync, DCCP A will update its GSR variable, and the endpoints will be back in sync. As an exception, if the peer endpoint is in the REQUEST state, it MUST respond with a DCCP-Reset instead of a DCCP-SyncAck. This serves to clean up DCCP A&#39;s half-open connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス有効DCCP同期パケットを受信すると、ピアエンドポイント（例えば、DCCP B）はそのGSR変数を更新しなければならなくて、DCCP-SyncAckパケットで返信。 DCCP-SyncAckパケットの確認応答番号は必ずしもGSRないDCCP同期のシーケンス番号を、等しくなります。それはDCCP同期を承認するのでシーケンス有効であろう本DCCP-SyncAckを受信すると、DCCP Aは、GSR変数を更新し、エンドポイントは、同期に戻ってきます。ピアエンドポイントが要求状態にある場合は例外として、それは代わりにDCCP-SyncAckのDCCP-リセットで応答しなければなりません。これはDCCP Aのハーフオープン接続をクリーンアップするのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To protect against denial-of-service attacks, DCCP implementations SHOULD impose a rate limit on DCCP-Syncs sent in response to sequence-invalid packets, such as not more than eight DCCP-Syncs per second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サービス拒否攻撃から保護するために、DCCP実装は、このような毎秒8 DCCP-同期よりもないよう系列無効のパケットに応答して送られたDCCP-同期のレート制限を課すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints MUST NOT process sequence-invalid packets except, perhaps, by generating a DCCP-Sync. For instance, options MUST NOT be processed. An endpoint MAY temporarily preserve sequence-invalid packets in case they become valid later, however; this can reduce the impact of bursts of loss by delivering more packets to the application. In particular, an endpoint MAY preserve sequence-invalid packets for up to 2 round-trip times. If, within that time, the relevant sequence windows change so that the packets become sequence-valid, the endpoint MAY process them again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点は、DCCP-Syncを発生させることにより、おそらく、を除い系列無効のパケットを処理してはいけません。例えば、オプションが処理されてはなりません。エンドポイントは、一時的に、彼らはしかし、後から有効となる場合のシーケンス、無効なパケットを保存することができます。これは、アプリケーションにより多くのパケットを提供することにより、損失のバーストの影響を低減することができます。具体的には、エンドポイントは、最大で2往復時間のための系列無効のパケットを保存することができます。場合は、その時間内に、パケットが配列有効になるように、関連する一連のウィンドウの変更は、エンドポイントが再びそれらを処理することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that sequence-invalid DCCP-Reset packets cause DCCP-Syncs to be generated. This is because endpoints in an unsynchronized state (CLOSED, REQUEST, and LISTEN) might not have enough information to generate a proper DCCP-Reset on the first try. For example, if a peer endpoint is in CLOSED state and receives a DCCP-Data packet, it cannot guess the right Sequence Number to use on the DCCP-Reset it generates (since the DCCP-Data packet has no Acknowledgement Number). The DCCP-Sync generated in response to this bad reset serves as a challenge, and contains enough information for the peer to generate a proper DCCP-Reset. However, the new DCCP-Reset may carry a different Reset Code than the original DCCP-Reset; probably the new Reset Code will be 3, &#34;No Connection&#34;. The endpoint SHOULD use information from the original DCCP-Reset when possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その系列無効DCCP-リセットパケットはDCCP-同期を発生させるに注意してください。同期化されていない状態でのエンドポイントは（CLOSED、REQUEST、およびLISTEN）最初の試みで適切なDCCP-リセットを生成するのに十分な情報を持っていない可能性があるためです。ピアエンドポイントが閉状態にあり、DCCP  - データパケットを受信した場合、例えば、それは（DCCP  - データパケットが確認応答番号を持っていないので）それが生成DCCPリセットに使用する権利シーケンス番号を推測することができません。この悪いリセットに応答して生成DCCP-Syncは、チャレンジとなり、適切なDCCP・リセットを生成するために、ピアのための十分な情報を含んでいます。しかし、新しいDCCP  - リセットは、元のDCCP、リセットとは異なるリセットコードを運ぶことができます。おそらく、新しいリセットコードは3、「接続なし」となります。エンドポイントは、オリジナルのDCCP-リセット可能性からの情報を使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.5. Sequence Number Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.5. シーケンス番号攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sequence and Acknowledgement Numbers form DCCP&#39;s main line of defense against attackers. An attacker that cannot guess sequence numbers cannot easily manipulate or hijack a DCCP connection, and requirements like careful initial sequence number choice eliminate the most serious attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスおよび確認応答番号は、攻撃者に対する防御のDCCPのメインラインを形成します。シーケンス番号を推測することができない攻撃者が簡単に操作またはDCCPコネクションをハイジャックし、慎重な初期シーケンス番号の選択のような要件が最も深刻な攻撃を排除することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker might still send many packets with randomly chosen Sequence and Acknowledgement Numbers, however. If one of those probes ends up sequence-valid, it may shut down the connection or otherwise cause problems. The easiest such attacks to execute are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者はまだしかし、ランダムに選択された配列と謝辞番号を持つ多くのパケットを送信することがあります。これらのプローブの1つが配列有効終わる場合、それは接続をシャットダウンまたはそれ以外の問題が発生することがあります。次のように実行するための最も簡単な、このような攻撃は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Send DCCP-Data packets with random Sequence Numbers. If one of these packets hits the valid sequence number window, the attack packet&#39;s application data may be inserted into the data stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oランダムシーケンス番号とDCCP  - データパケットを送信します。これらのパケットの1つは、有効なシーケンス番号のウィンドウをヒットした場合、攻撃パケットのアプリケーションデータは、データストリームに挿入することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Send DCCP-Sync packets with random Sequence and Acknowledgement Numbers. If one of these packets hits the valid acknowledgement number window, the receiver will shift its sequence number window accordingly, getting out of sync with the correct endpoint -- perhaps permanently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oランダムシーケンスおよび確認応答番号とDCCP-Syncのパケットを送信します。これらのパケットの1つが有効な確認応答番号のウィンドウをヒットした場合、受信機は、正しいエンドポイントと同期しなくなって、それに応じてシーケンス番号のウィンドウをシフトします - おそらく永久に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attacker has to guess both Source and Destination Ports for any of these attacks to succeed. Additionally, the connection would have to be inactive for the DCCP-Sync attack to succeed, assuming the victim implemented the more stringent checks for active connections recommended in Section 7.5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、成功するために、これらの攻撃のいずれかの送信元ポートと宛先ポートの両方を推測しています。 DCCP-Syncの攻撃が成功するためにはさらに、接続は、被害者は、セクション7.5.3で推奨アクティブな接続のためのより厳格なチェックを実装想定し、非アクティブでなければならないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To quantify the probability of success, let N be the number of attack packets the attacker is willing to send, W be the relevant sequence window width, and L be the length of sequence numbers (24 or 48). The attacker&#39;s best strategy is to space the attack packets evenly over sequence space. Then the probability of hitting one sequence number window is P = WN/2^L.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功の確率を定量化するために、N攻撃の数は、攻撃者が送信しても構わないと思っているパケットする、Wは、関連配列のウィンドウ幅であり、そしてLは、シーケンス番号（24または48）の長さとします。攻撃者の最善の戦略は、均等に配列スペース上の空間に攻撃パケットです。次いで、一つのシーケンス番号のウィンドウを打つ確率はP = WN / 2 ^ Lです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The success probability for a DCCP-Data attack using short sequence numbers thus equals P = WN/2^24. For W = 100, then, the attacker must send more than 83,000 packets to achieve a 50% chance of success. For reference, the easiest TCP attack -- sending a SYN with a random sequence number, which will cause a connection reset if it falls within the window -- with W = 8760 (a common default) and L = 32 requires more than 245,000 packets to achieve a 50% chance of success.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
短いシーケンス番号を使用して、DCCP  - データ攻撃の成功確率は、このようにP = WN / 2 ^ 24に等しいです。 W = 100の場合は、その後、攻撃者は、成功の50％の確率を達成するために以上83,000パケットを送信する必要があります。参考のために、最も簡単なTCP攻撃 - それは、ウィンドウ内にある場合、接続のリセットが発生しますランダムシーケンス番号、とSYNを送信する -  W = 8760と（一般的なデフォルト）とL = 32以上245,000パケットを必要とし成功の50％の確率で実現しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A fast connection&#39;s W will generally be high, increasing the attack success probability for fixed N. If this probability gets uncomfortably high with L = 24, the endpoint SHOULD prevent the use of short sequence numbers by manipulating the Allow Short Sequence Numbers feature (see Section 7.6.1). The probability limit depends on the application, however. Some applications, such as those already designed to handle corruption, are quite resilient to data injection attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速接続のWは、一般的に、この確率は、L = 24と不快に高くなった場合は、固定N.ため、攻撃の成功確率を高め、ハイになり、エンドポイントは許可ショートシーケンス番号の機能を操作することにより、短いシーケンス番号の使用を防止すべきである（セクションを参照してください7.6.1）。確率の上限は、しかし、アプリケーションに依存します。こうしたすでに腐敗を扱うように設計されたものなどの一部のアプリケーションでは、データインジェクション攻撃に対して非常に弾力性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DCCP-Sync attack has L = 48, since DCCP-Sync packets use long sequence numbers exclusively; in addition, the success probability is halved, since only half the Sequence Number space is valid. Attacks have a correspondingly smaller probability of success. For a large W of 2000 packets, then, the attacker must send more than 10^11 packets to achieve a 50% chance of success.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Syncのパケットが排他的に長いシーケンス番号を使用するので、DCCP-Syncの攻撃は、L = 48を持っています。加えて、成功確率は半分しかシーケンス番号空間が有効であることから、半分になります。攻撃が成功するのに対応して小さい確率を持っています。 2000のパケットの大Wに関しては、その後、攻撃者は、成功の50％の確率を達成するために10個の以上の^ 11パケットを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attacks involving DCCP-Ack, DCCP-DataAck, DCCP-CloseReq, DCCP-Close, and DCCP-Reset packets are more difficult, since Sequence and Acknowledgement Numbers must both be guessed. The probability of attack success for these packet types equals P = WXN/2^(2L), where W is the Sequence Number window, X is the Acknowledgement Number window, and N and L are as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスおよび確認応答番号の両方が推測されなければならないので、DCCP-Ackを、DCCP-DataAck、DCCP-CloseReq、DCCP-閉じる、およびDCCP-リセットパケットを伴う攻撃は、より困難です。これらのパケットタイプの攻撃成功の確率がWは、シーケンス番号のウィンドウであるP = WXN / 2 ^（2L）を、等しく、Xは、肯定応答番号ウィンドウであり、そしてNおよびLは、前のようにです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since DCCP-Data attacks with short sequence numbers are relatively easy for attackers to execute, DCCP has been engineered to prevent these attacks from escalating to connection resets or other serious consequences. In particular, any options whose processing might cause the connection to be reset are ignored when they appear on DCCP-Data packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
短いシーケンス番号とDCCP-データ攻撃は、攻撃者が実行するのは比較的容易であるので、DCCPは、接続のリセットやその他の重大な結果にエスカレートするから、これらの攻撃を防ぐように設計されています。彼らはDCCP  - データパケットに表示されたときに、特に、その処理の接続がリセットされることがあります任意のオプションは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.6. Sequence Number Handling Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5.6. 例の処理シーケンス番号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, DCCP A and DCCP B recover from a large burst of loss that runs DCCP A&#39;s sequence numbers out of DCCP B&#39;s appropriate sequence number window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例では、DCCP AとDCCP BはDCCP Bの適切なシーケンス番号のウィンドウの外DCCP Aのシーケンス番号を実行損失の大バーストから回復します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP A DCCP B (GSS=1,GSR=10) (GSS=10,GSR=1) --&gt; DCCP-Data(seq 2) XXX ... --&gt; DCCP-Data(seq 100) XXX --&gt; DCCP-Data(seq 101) --&gt; ??? seqno out of range; send Sync OK &lt;-- DCCP-Sync(seq 11, ack 101) &lt;-- (GSS=11,GSR=1) --&gt; DCCP-SyncAck(seq 102, ack 11) --&gt; OK (GSS=102,GSR=11) (GSS=11,GSR=102)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP A DCCP B（GSS = 1、GSR = 10）（GSS = 10、GSR = 1） - &gt; DCCP-データ（配列2）XXX ...  - &gt; DCCP-データ（配列番号100）XXX  - &gt; DCCP-データ（配列101） - &gt; ???範囲外のSEQNO。送信同期OK &lt; -  DCCP-SYNC（配列番号11、101 ACK）&lt; - （GSS = 11、GSR = 1） - &gt; DCCP-SyncAck（11 ACK配列番号102） - &gt; OK（GSS = 102、 = 11 GSR）（GSS = 11、GSR = 102）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the next example, a DCCP connection recovers from a simple blind attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例では、DCCP接続は、単純なブラインド攻撃から回復します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP A DCCP B (GSS=1,GSR=10) (GSS=10,GSR=1) *ATTACKER* --&gt; DCCP-Data(seq 10^6) --&gt; ??? seqno out of range; send Sync ??? &lt;-- DCCP-Sync(seq 11, ack 10^6) &lt;-- ackno out of range; ignore (GSS=1,GSR=10) (GSS=11,GSR=1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP A DCCP B（GSS = 1、GSR = 10）（GSS = 10、GSR = 1）* ATTACKER *  - &gt; DCCP-データ（配列番号10 ^ 6） - &gt; ???範囲外のSEQNO。 Syncを送ります？ &lt; -  DCCP-SYNC（配列番号11、10 ^ 6 ACK）&lt; -  ackno範囲外。無視（GSS = 1、GSR = 10）（GSS = 11、GSR = 1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final example demonstrates recovery from a half-open connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の例は、ハーフオープン接続からの回復を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP A DCCP B (GSS=1,GSR=10) (GSS=10,GSR=1) (Crash) CLOSED OPEN REQUEST --&gt; DCCP-Request(seq 400) --&gt; ??? !! &lt;-- DCCP-Sync(seq 11, ack 400) &lt;-- OPEN REQUEST --&gt; DCCP-Reset(seq 401, ack 11) --&gt; (Abort) REQUEST CLOSED REQUEST --&gt; DCCP-Request(seq 402) --&gt; ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP A DCCP B（GSS = 1、GSR = 10）（クラッシュ）が閉じオープン要求（GSSが、GSR = 1 = 10） - &gt; DCCP  - 要求（配列番号400） - &gt; ??? !! &lt; -  DCCP-SYNC（配列番号11、400をACK）&lt; -  OPEN REQUEST  - &gt; DCCP・リセット（配列番号401、ACK 11） - &gt;  - &gt; DCCP  - 要求（配列番号402）（中止）要求がREQUEST CLOSED - &gt; ...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. Short Sequence Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. ショートシーケンス番号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP sequence numbers are 48 bits long. This large sequence space protects DCCP connections against some blind attacks, such as the injection of DCCP-Resets into the connection. However, DCCP-Data, DCCP-Ack, and DCCP-DataAck packets, which make up the body of any DCCP connection, may reduce header space by transmitting only the lower 24 bits of the relevant Sequence and Acknowledgement Numbers. The receiving endpoint will extend these numbers to 48 bits using the following pseudocode:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPのシーケンス番号は48ビット長です。この大きな配列スペースは、このような接続にDCCP-リセットの注射などのいくつかの盲目の攻撃に対するDCCP接続を保護します。しかし、任意のDCCP接続の本体を構成するDCCP-データ、DCCP-ACK、およびDCCP-DataAckパケットは、関連配列確認応答番号の下位24ビットのみを送信することによりヘッダスペースを低減することができます。受信エンドポイントは、以下の疑似コードを使用して48ビットにこれらの番号を拡張します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   procedure Extend_Sequence_Number(S, REF)
      /* S is a 24-bit sequence number from the packet header.
         REF is the relevant 48-bit reference sequence number:
         GSS if S is an Acknowledgement Number, and GSR if S is a
         Sequence Number. */
      Set REF_low := low 24 bits of REF
      Set REF_hi := high 24 bits of REF
      If REF_low (&lt;) S           /* circular comparison mod 2^24 */
            and S |&lt;| REF_low,   /* conventional, non-circular
                                    comparison */
         Return (((REF_hi + 1) mod 2^24) &lt;&lt; 24) | S
      Otherwise, if S (&lt;) REF_low and REF_low |&lt;| S,
         Return (((REF_hi - 1) mod 2^24) &lt;&lt; 24) | S
      Otherwise,
         Return (REF_hi &lt;&lt; 24) | S
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two different kinds of comparison in the if statements detect when the low-order bits of the sequence space have wrapped. (The circular comparison &#34;REF_low (&lt;) S&#34; returns true if and only if (S - REF_low), calculated using two&#39;s-complement arithmetic and then represented as an unsigned number, is less than or equal to 2^23 (mod 2^24).) When this happens, the high-order bits are incremented or decremented, as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
比較の2種類のステートメントは、配列スペースの下位ビットをラップしている時に検出した場合。 、2の補数演算を用いて計算した後、符号なしの数として表される、^ 2（MOD未満または2 ^ 23に等しいREF_low） - のみ（Sもしあれば（円形の比較は「REF_low（&lt;）S」がtrueを返しますこれが発生すると24）。）、上位ビットは、インクリメントまたはデクリメント、適宜れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6.1. Allow Short Sequence Numbers Feature
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6.1. ショートシーケンス番号の機能を許可します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints can require that all packets use long sequence numbers by leaving the Allow Short Sequence Numbers feature value at its default of zero. This can reduce the risk that data will be inappropriately injected into the connection. DCCP A sends a &#34;Change L(Allow Short Seqnos, 1)&#34; option to indicate its desire to send packets with short sequence numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、すべてのパケットが許可ショートシーケンス番号がゼロのデフォルトの値を特徴と残して長いシーケンス番号を使用することを必要とすることができます。これは、データが不適切な接続に注入されるリスクを減らすことができます。 DCCP Aは、「変更L（ショートSeqnosを許可する、1）」短いシーケンス番号のパケットを送信するためにその要望を示すためのオプションを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allow Short Sequence Numbers has feature number 2 and is server-priority. It takes one-byte Boolean values. When Allow Short Seqnos/B is zero, DCCP B MUST NOT send packets with short sequence numbers and DCCP A MUST ignore any packets with short sequence numbers that are received. Values of two or more are reserved. New connections start with Allow Short Sequence Numbers 0 for both endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
許可ショートシーケンス番号は、機能番号2を持っていると、サーバーの優先順位です。これは、1バイトのブール値をとります。許可ショートSeqnos / Bがゼロである場合、DCCP Bは、短いシーケンス番号を持つパケットを送ってはいけませんとDCCP Aが受信される短いシーケンス番号を持つパケットを無視しなければなりません。二つ以上の値が予約されています。両方のエンドポイントのショートシーケンス番号0を許可すると新しい接続が開始されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6.2. When to Avoid Short Sequence Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6.2. ショートシーケンス番号を避けるためにする場合
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Short sequence numbers reduce the rate DCCP connections can safely achieve and increase the risks of certain kinds of attacks, including blind data injection. Very-high-rate DCCP connections, and connections with large sequence windows (Section 7.5.2), SHOULD NOT use short sequence numbers on their data packets. The attack risk issues have been discussed in Section 7.5.5; we discuss the rate limitation issue here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
短いシーケンス番号は、DCCP接続が安全に達成し、ブラインドデータの注入を含む攻撃の特定の種類のリスクを増やすことができます率を低下させます。超高レートDCCP接続、大きなシーケンス窓（7.5.2項）との接続は、そのデータパケットに短いシーケンス番号を使用しないでください。攻撃のリスク問題は、第7.5.5項で説明されています。ここでは、レート制限の問題を議論します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequence-validity mechanism assumes that the network does not deliver extremely old data. In particular, it assumes that the network must have dropped any packet by the time the connection wraps around and uses its sequence number again. This constraint limits the maximum connection rate that can be safely achieved. Let MSL equal the maximum segment lifetime, P equal the average DCCP packet size in bits, and L equal the length of sequence numbers (24 or 48 bits). Then the maximum safe rate, in bits per second, is R = P*(2^L)/2MSL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス・妥当性のメカニズムは、ネットワークが非常に古いデータを提供しないことを前提としています。特に、ネットワーク接続がラップアラウンドして、再びそのシーケンス番号を使用する時間によって、任意のパケットを落としていなければならないことを前提としています。この制約は、安全に実現することができる最大接続速度を制限します。 MSLは、最大セグメント寿命を等しくしてみましょう、Pは、ビットの平均DCCPパケットのサイズに等しく、そしてLは、シーケンス番号（24または48ビット）の長さに等しいです。次いで、最大安全速度は、秒当たりのビットで、R = P *（2 ^ L）/ 2MSLあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the default MSL of 2 minutes, 1500-byte DCCP packets, and short sequence numbers, the safe rate is therefore approximately 800 Mb/s. Although 2 minutes is a very large MSL for any networks that could sustain that rate with such small packets, long sequence numbers allow much higher rates under the same constraints: up to 14 petabits a second for 1500-byte packets and the default MSL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2分、1500バイトのDCCPパケット、および短いシーケンス番号のデフォルトMSLのために、安全率は、したがって、約800メガビット/秒です。 1500バイトのパケットとデフォルトMSLのための14 petabits秒まで：2分は、このような小さなパケットをそのレートを維持する可能性のあるネットワークのための非常に大きいMSLですが、長いシーケンス番号が同じ制約の下ではるかに高いレートを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7. NDP Count and Detecting Application Loss
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7.  NDPカウントと検出アプリケーションの損失
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP&#39;s sequence numbers increment by one on every packet, including non-data packets (packets that don&#39;t carry application data). This makes DCCP sequence numbers suitable for detecting any network loss, but not for detecting the loss of application data. The NDP Count option reports the length of each burst of non-data packets. This lets the receiving DCCP reliably determine when a burst of loss included application data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPのシーケンス番号は、非データ・パケット（アプリケーションデータを運ばないパケット）を含め、すべてのパケットに1ずつ増加します。これは、アプリケーションデータの消失を検出するための任意のネットワークの損失を検出するのに適してではなく、DCCPシーケンス番号になります。 NDPカウントオプションは非データパケットの各バーストの長さを報告します。これは、損失のバーストは、アプリケーションデータが含まれた場合に受信DCCPを確実に判断することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+-------- ... --------+
   |00100101| Length |      NDP Count      |
   +--------+--------+-------- ... --------+
    Type=37  Len=3-8       (1-6 bytes)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a DCCP endpoint&#39;s Send NDP Count feature is one (see below), then that endpoint MUST send an NDP Count option on every packet whose immediate predecessor was a non-data packet. Non-data packets consist of DCCP packet types DCCP-Ack, DCCP-Close, DCCP-CloseReq, DCCP-Reset, DCCP-Sync, and DCCP-SyncAck. The other packet types, namely DCCP-Request, DCCP-Response, DCCP-Data, and DCCP-DataAck, are considered data packets, although not all DCCP-Request and DCCP-Response packets will actually carry application data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点のカウントNDPを送る機能が（下記参照）1である場合、そのエンドポイントは即時の前任者以外のデータパケットたすべてのパケット上のNDPカウントオプションを送らなければなりません。非データパケットはDCCPパケットタイプDCCP-ACK、DCCP-閉じる、DCCP-CloseReq、DCCP  - リセット、DCCP同期、およびDCCP-SyncAckから成ります。すべてのDCCP-要求とDCCP-応答パケットが実際にアプリケーションデータを運ぶされていないが、他のパケットタイプ、すなわち、DCCP-要求、DCCP-応答、DCCP-データ、およびDCCP-DataAckは、データパケットを考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value stored in NDP Count equals the number of consecutive non-data packets in the run immediately previous to the current packet. Packets with no NDP Count option are considered to have NDP Count zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NDPカウントに格納されている値は、現在のパケットの直前、実行中の連続した非データパケットの数に等しいです。無NDPカウントオプション付きパケットはNDPがゼロカウント有すると考えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NDP Count option can carry one to six bytes of data. The smallest option format that can hold the NDP Count SHOULD be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NDPカウントオプションは、データの1〜6個のバイトを運ぶことができます。 NDPカウントを保持できる最小のオプションの形式を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With NDP Count, the receiver can reliably tell only whether a burst of loss contained at least one data packet. For example, the receiver cannot always tell whether a burst of loss contained a non-data packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NDPはカウントして、受信機は確実に損失のバーストは、少なくとも1つのデータ・パケットが含まれているかどうかだけで伝えることができます。例えば、受信機は常に損失のバーストが非データパケットが含まれているかどうかわかりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7.1. NDP Count Usage Notes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7.1.  NDPカウント使用上の注意
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Say that K consecutive sequence numbers are missing in some burst of loss, and that the Send NDP Count feature is on. Then some application data was lost within those sequence numbers unless the packet following the hole contains an NDP Count option whose value is greater than or equal to K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
K連続したシーケンス番号が損失のいくつかのバーストに欠けていること、およびカウントNDPを送る機能がオンになっていることを言います。穴次のパケットがその値K.以上であるNDPカウントオプションが含まれない限り、いくつかのアプリケーションデータは、これらのシーケンス番号の中に失われました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, say that an endpoint sent the following sequence of non-data packets (Nx) and data packets (Dx).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、エンドポイントが非データ・パケット（Nxの）データパケット（Dxと）、次のシーケンスを送信することを言います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
N0 N1 D2 N3 D4 D5 N6 D7 D8 D9 D10 N11 N12 D13
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
N0 N1 D2 N3 D4 D5 N6 D7 D8 D9 D10 N11 N12 D13
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Those packets would have NDP Counts as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのパケットは、次のようにNDPカウントのだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
N0 N1 D2 N3 D4 D5 N6 D7 D8 D9 D10 N11 N12 D13 - 1 2 - 1 - - 1 - - - - 1 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
N0 N1 D2 N3 D4 D5 N6 D7 D8 D9 D10 N11 N12のD13  -  1 2  -  1  -   -  1  -   -   -   -  1 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NDP Count is not useful for applications that include their own sequence numbers with their packet headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NDP Countは、そのパケットのヘッダに、独自のシーケンス番号を含むアプリケーションのために有用ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7.2. Send NDP Count Feature
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7.2.  NDPカウント機能を送ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Send NDP Count feature lets DCCP endpoints negotiate whether they should send NDP Count options on their packets. DCCP A sends a &#34;Change R(Send NDP Count, 1)&#34; option to ask DCCP B to send NDP Count options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NDPカウント機能は、DCCP終点は、彼らが自分のパケットのNDPカウントオプションを送信するかどうかを交渉することができます送信します。 DCCP Aは &#34;変化R（、カウント1 NDPを送る）&#34; NDPカウントオプションを送信するためにDCCP Bを依頼するオプションを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Send NDP Count has feature number 7 and is server-priority. It takes one-byte Boolean values. DCCP B MUST send NDP Count options as described above when Send NDP Count/B is one, although it MAY send NDP Count options even when Send NDP Count/B is zero. Values of two or more are reserved. New connections start with Send NDP Count 0 for both endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NDP Countが機能番号7を持っていると、サーバーの優先順位で送信します。これは、1バイトのブール値をとります。 DCCP Bは、NDPカウント/ B送信すると上記のようなオプションをカウントNDPを送信しなければならないことがNDPを送る場合でも、Bがゼロ/カウントオプションカウントNDPを送ることができるが、一つです。二つ以上の値が予約されています。新しい接続は、両方のエンドポイントのNDPカウント0を送信し始めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Event Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.イベント処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes how DCCP connections move between states and which packets are sent when. Note that feature negotiation takes place in parallel with the connection-wide state transitions described here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、DCCP接続はパケットが送信される状態との間を移動する方法について説明します。交渉がここで説明した接続全体の状態遷移と並行して行われ、その機能に注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Connection Establishment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 接続の確立
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP connections&#39; initiation phase consists of a three-way handshake: an initial DCCP-Request packet sent by the client, a DCCP-Response sent by the server in reply, and finally an acknowledgement from the client, usually via a DCCP-Ack or DCCP-DataAck packet. The client moves from the REQUEST state to PARTOPEN, and finally to OPEN; the server moves from LISTEN to RESPOND, and finally to OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP接続の初期段階は3ウェイハンドシェイクで構成されています。通常、DCCP-Ackを経由して、クライアントから送信された初期のDCCP-Requestパケット、応答でサーバーから送信されたDCCP-応答、およびクライアントから最終的に承認またはDCCP-DataAckパケット。クライアントはPARTOPENにREQUEST状態から移動し、最終的にOPENに。サーバーが応答し、そして最終的にOPENにLISTENから移動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Client State Server State CLOSED LISTEN 1. REQUEST --&gt; Request --&gt; 2. &lt;-- Response &lt;-- RESPOND 3. PARTOPEN --&gt; Ack, DataAck --&gt; 4. &lt;-- Data, Ack, DataAck &lt;-- OPEN 5. OPEN &lt;-&gt; Data, Ack, DataAck &lt;-&gt; OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント状態サーバーの状態は、1 REQUESTをLISTEN CLOSED  - &gt;リクエスト - &gt; 2. &lt; - レスポンス&lt; -  RESPOND 3. PARTOPEN  - &gt; ACK、DataAck  - &gt; 4. &lt; - データ、ACK、DataAck &lt; -  -  OPEN 5. OPEN &lt; - &gt;データ、ACK、DataAck &lt; - &gt; OPEN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. Client Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. クライアント要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client decides to initiate a connection, it enters the REQUEST state, chooses an initial sequence number (Section 7.2), and sends a DCCP-Request packet using that sequence number to the intended server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが接続を開始することを決定するとき、それは、要求状態に入る初期シーケンス番号（セクション7.2）を選択し、目的のサーバーにそのシーケンス番号を使用して、DCCP-Requestパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Request packets will commonly carry feature negotiation options that open negotiations for various connection parameters, such as preferred congestion control IDs for each half-connection. They may also carry application data, but the client should be aware that the server may not accept such data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Requestパケットは、一般的に、このような各半分接続の優先輻輳制御IDなど、さまざまな接続パラメータのためのオープン交渉、特徴交渉オプションを運ぶでしょう。彼らはまた、アプリケーションデータを運ぶかもしれませんが、クライアントは、サーバがそのようなデータを受け入れないことに注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client in the REQUEST state SHOULD use an exponential-backoff timer to send new DCCP-Request packets if no response is received. The first retransmission should occur after approximately one second, backing off to not less than one packet every 64 seconds; or the endpoint can use whatever retransmission strategy is followed for retransmitting TCP SYNs. Each new DCCP-Request MUST increment the Sequence Number by one and MUST contain the same Service Code and application data as the original DCCP-Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQUEST状態のクライアントは、応答が受信されない場合は、新しいDCCP-Requestパケットを送信するために、指数バックオフタイマーを使用すべきです。最初の再送信は、1つのパケットごとに64秒未満ではないにバックオフ、約1秒後に発生しなければなりません。またはエンドポイントは、TCPのSYNを再送するために続いているものは何でも、再送信戦略を使用することができます。それぞれの新しいDCCP-要求が一つのシーケンス番号をインクリメントしなければならなくて、オリジナルのDCCP-要求と同じサービスコードとアプリケーションデータを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MAY give up on its DCCP-Requests after some time (3 minutes, for example). When it does, it SHOULD send a DCCP-Reset packet to the server with Reset Code 2, &#34;Aborted&#34;, to clean up state in case one or more of the Requests actually arrived. A client in REQUEST state has never received an initial sequence number from its peer, so the DCCP-Reset&#39;s Acknowledgement Number MUST be set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、いくつかの時間後にそのDCCP-要求（例えば3分）にあきらめるかもしれません。それがないと、それは場合、実際に到着した要求の一つ以上の状態をクリーンアップするために、リセットコード2、「中止」を使用してサーバーにDCCP-リセットパケットを送るべきです。 REQUEST状態のクライアントがピアからの初期シーケンス番号を受けたことがないので、DCCP-リセットの確認応答番号をゼロに設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client leaves the REQUEST state for PARTOPEN when it receives a DCCP-Response from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、サーバからDCCP-応答を受信したときにクライアントがPARTOPENの要求の状態を残します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. Service Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. サービスコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each DCCP-Request contains a 32-bit Service Code, which identifies the application-level service to which the client application is trying to connect. Service Codes should correspond to application services and protocols. For example, there might be a Service Code for SIP control connections and one for RTP audio connections. Middleboxes, such as firewalls, can use the Service Code to identify the application running on a nonstandard port (assuming the DCCP header has not been encrypted).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各DCCP-要求は、クライアントアプリケーションが接続しようとされているアプリケーションレベルのサービスを識別する32ビットのサービスコードが含まれています。サービスコードは、アプリケーションサービスとプロトコルに対応している必要があります。例えば、SIP制御接続およびRTPオーディオ接続のいずれかのサービスコードがあるかもしれません。ファイアウォールなどの中間装置は、（DCCPヘッダが暗号化されていないと仮定して）非標準ポート上で動作するアプリケーションを識別するためのサービスコードを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints MUST associate a Service Code with every DCCP socket, both actively and passively opened. The application will generally supply this Service Code. Each active socket MUST have exactly one Service Code. Passive sockets MAY, at the implementation&#39;s discretion, be associated with more than one Service Code; this might let multiple applications, or multiple versions of the same application, listen on the same port, differentiated by Service Code. If the DCCP-Request&#39;s Service Code doesn&#39;t equal any of the server&#39;s Service Codes for the given port, the server MUST reject the request by sending a DCCP-Reset packet with Reset Code 8, &#34;Bad Service Code&#34;. A middlebox MAY also send such a DCCP-Reset in response to packets whose Service Code is considered unsuitable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、あらゆるDCCPソケットの両方積極的かつ受動的に開かれたサービスコードを関連付ける必要があります。アプリケーションは、一般的に、このサービスコードを供給します。各アクティブソケットは、1つのサービスコードを持たなければなりません。パッシブソケットは、実装者の裁量で、複数のサービスコードを関連付けることができます。これは、複数のアプリケーション、または同じアプリケーションの複数のバージョンは、サービスコードによって区別同じポート上で聞くせて頂く場合がございます。 DCCPリクエストのサービスコードは、特定のポートのサーバーのサービスコードのいずれかと等しくない場合、サーバーはリセットコード8、「悪い接客規範」とDCCP-リセットパケットを送信することにより、要求を拒絶しなければなりません。ミドルはまた、サービスコードは不向きと考えられているパケットに応じて、このようなDCCP-リセットを送るかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Service Codes are not intended to be DCCP-specific and are allocated by IANA. Following the policies outlined in [RFC2434], most Service Codes are allocated First Come First Served, subject to the following guidelines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サービスコードはDCCP特有であることを意図していないと、IANAによって割り当てられています。 [RFC2434]に概説された方針に続いて、ほとんどのサービスコードは、次のガイドラインに従う、まず第一に役立っ来割り当てられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Service Codes are allocated one at a time, or in small blocks. A short English description of the intended service is REQUIRED to obtain a Service Code assignment, but no specification, standards track or otherwise, is necessary. IANA maintains an association of Service Codes to the corresponding phrases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサービスコードは、一度に1つを割り当てられた、または小さなブロックでされています。意図したサービスの短い英語の説明がサービスコードの割り当てを取得する必要がありますが、指定なし、規格がそうでなければ追跡したり、必要です。 IANAは、対応する語句にサービスコードの関連付けを維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Users request specific Service Code values. We suggest that users request Service Codes that can be represented using the &#34;SC:&#34; formatting convention described below. Thus, the &#34;Frobodyne Plotz Protocol&#34; might correspond to Service Code 17178548426 or, equivalently, &#34;SC:fdpz&#34;. The canonical interpretation of a Service Code field is numeric.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oユーザーが特定のサービスコード値を要求します。下記の書式設定規則：私たちは、ユーザーが「SC」を用いて表すことができるサービスコードを要求することを示唆しています。 「：fdpz SC」したがって、「Frobodyne Plotz議定書は、」サービスコード17178548426または、同等に対応することがあります。サービスコードフィールドの標準的な解釈が数値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Service Codes whose bytes each have values in the set {32, 45-57, 65-90} use a Specification Required allocation policy. That is, these Service Codes are used for international standard or standards-track specifications, IETF or otherwise. (This set consists of the ASCII digits, uppercase letters, and characters space, &#39;-&#39;, &#39;.&#39;, and &#39;/&#39;.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのバイトをそれぞれが集合{32、45-57、65-90}の値を持っている仕様が必要で割り当てポリシーを使用するサービスコードO。それは、これらのサービスコードは、国際規格や標準化過程仕様、IETFまたはそれ以外のために使用されています。 （ - 、および 『/』「」「」このセットには、ASCII数字、大文字、および文字のスペースで構成されています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Service Codes whose high-order byte equals 63 (ASCII &#39;?&#39;) are reserved for Private Use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その上位バイト63等しい（ASCIIの「？」）Oサービスコードは、私的使用のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Service Code 0 represents the absence of a meaningful Service Code and MUST NOT be allocated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサービスコード0は、意味のあるサービスコードが存在しないことを表しており、割り当てられてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value 4294967295 is an invalid Service Code. Servers MUST reject any DCCP-Request with this Service Code value by sending a DCCP-Reset packet with Reset Code 8, &#34;Bad Service Code&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O値4294967295が無効なサービスコードがあります。サーバーはリセットコード8、「悪い接客規範」とDCCP-リセットパケットを送信することにより、このサービスコード値で任意のDCCP-Requestを拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This design for Service Code allocation is based on the allocation of 4-byte identifiers for Macintosh resources, PNG chunks, and TrueType and OpenType tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サービスコードの割り当てのためのこの設計は、Macintoshのリソース、PNGチャンク、およびTrueTypeおよびOpenTypeのテーブルの4バイトの識別子の割り当てに基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In text settings, we recommend that Service Codes be written in one of three forms, prefixed by the ASCII letters SC and either a colon &#34;:&#34; or equals sign &#34;=&#34;. These forms are interpreted as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「：」または記号「=」に等しいテキスト設定では、我々はサービスコードはASCII文字のSCとコロンのいずれかで始まる3つの形で書かれることをお勧めします。これらのフォームは、次のように解釈されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SC: Indicates a Service Code representable using a subset of the ASCII characters. The colon is followed by one to four characters taken from the following set: letters, digits, and the characters in &#34;-_+.*/?@&#34; (not including quotes). Numerically, these characters have values in {42-43, 45-57, 63-90, 95, 97-122}. The Service Code is calculated by padding the string on the right with spaces (value 32) and intepreting the four-character result as a 32-bit big-endian number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SC：ASCII文字のサブセットを使用してサービスコードの表現を示します。コロンは、以下のセットから取られた1〜4つの文字が続いている：「？-_ + * / @」文字、数字、およびの文字（引用符は含みません）。数値的に、これらの文字は{42-43、45-57、63から90、95、97から122}の値を有します。サービスコードは、スペース（値32）と右側の文字列をパディングし、32ビットのビッグエンディアン番号として4文字の結果をintepretingして算出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SC= Indicates a decimal Service Code. The equals sign is followed by any number of decimal digits, which specify the Service Code. Values above 4294967294 are illegal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SC =小数サービスコードを示します。等号は、サービスコードを指定小数点以下の桁の任意の数、続いています。 4294967294上記の値は違法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SC=x or SC=X Indicates a hexadecimal Service Code. The &#34;x&#34; or &#34;X&#34; is followed by any number of hexadecimal digits (upper or lower case), which specify the Service Code. Values above 4294967294 are illegal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SC = xまたはSC = Xは、16進のサービスコードを示します。 「X」または「X」は、サービスコードを指定する16進数字（大文字または小文字）、任意の数が続きます。 4294967294上記の値は違法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the Service Code 1717858426 might be represented in text as either SC:fdpz, SC=1717858426, or SC=x6664707A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このように、サービスコード1717858426のいずれかSCとしてテキストで表現されることがありますfdpz、SC = 1717858426、またはSC = x6664707A。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.3. Server Response
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.3. サーバーの応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the second phase of the three-way handshake, the server moves from the LISTEN state to RESPOND and sends a DCCP-Response message to the client. In this phase, a server will often specify the features it would like to use, either from among those the client requested or in addition to those. Among these options is the congestion control mechanism the server expects to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3ウェイハンドシェイクの第二段階では、LISTEN状態からサーバーに移動するには、応答すると、クライアントにDCCP-Responseメッセージを送信します。このフェーズでは、サーバーは、多くの場合、クライアントが要求したものの中から、またはそれらに加えてのいずれかで、それが使用したい機能を指定します。これらのオプションの中にサーバが使用することを期待する輻輳制御機構です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY respond to a DCCP-Request packet with a DCCP-Reset packet to refuse the connection. Relevant Reset Codes for refusing a connection include 7, &#34;Connection Refused&#34;, when the DCCP-Request&#39;s Destination Port did not correspond to a DCCP port open for listening; 8, &#34;Bad Service Code&#34;, when the DCCP-Request&#39;s Service Code did not correspond to the service code registered with the Destination Port; and 9, &#34;Too Busy&#34;, when the server is currently too busy to respond to requests. The server SHOULD limit the rate at which it generates these resets; for example, to not more than 1024 per second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは接続を拒否するためにDCCP-リセットパケットでDCCP-Requestパケットに応答することができます。接続を拒否ための関連リセットコードは、DCCP-要求の宛先ポートは、リスニングのためのオープンDCCPポートに対応していませんでした「接続拒否」を、7類; 8、「悪い接客規範」、DCCPリクエストのサービスコードは、宛先ポートに登録されたサービスコードに対応していませんでした。そして9、サーバーが現在の要求に応答するには余りにも忙しいときに、「ビジー状態」。サーバは、これらのリセットを生成する速度を制限する必要があります。例えば、毎秒1024以上にしないように。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server SHOULD NOT retransmit DCCP-Response packets; the client will retransmit the DCCP-Request if necessary. (Note that the &#34;retransmitted&#34; DCCP-Request will have, at least, a different sequence number from the &#34;original&#34; DCCP-Request. The server can thus distinguish true retransmissions from network duplicates.) The server will detect that the retransmitted DCCP-Request applies to an existing connection because of its Source and Destination Ports. Every valid DCCP-Request received while the server is in the RESPOND state MUST elicit a new DCCP-Response. Each new DCCP-Response MUST increment the server&#39;s Sequence Number by one and MUST include the same application data, if any, as the original DCCP-Response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはDCCP-応答パケットを再送すべきではありません。必要であれば、クライアントはDCCP-Requestを再送します。サーバは、再送ことを検出する（「再送」DCCP-要求は、少なくとも、「オリジナル」DCCP  - 要求とは異なるシーケンス番号を有すること。サーバは、このようにネットワーク複製から真の再送を区別することができる。注）DCCP-要求は、その送信元ポートおよび宛先ポートの既存の接続に適用されます。すべての有効なDCCP-要求は、サーバーが応答状態にある間に新しいDCCP-応答を惹起しなければならない受け取りました。いずれかの場合にはそれぞれの新しいDCCP-応答は、オリジナルのDCCP-応答として、1により、サーバーのシーケンス番号をインクリメントしなければならなくて、同じアプリケーションデータを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST NOT accept more than one piece of DCCP-Request application data per connection. In particular, the DCCP-Response sent in reply to a retransmitted DCCP-Request with application data SHOULD contain a Data Dropped option, in which the retransmitted DCCP-Request data is reported with Drop Code 0, Protocol Constraints. The original DCCP-Request SHOULD also be reported in the Data Dropped option, either in a Normal Block (if the server accepted the data or there was no data) or in a Drop Code 0 Drop Block (if the server refused the data the first time as well).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは接続ごとにDCCP  - 要求アプリケーションデータの複数部分を受け入れてはいけません。具体的には、データを含むべきアプリケーションデータを再送さDCCP-要求に応答して送信されDCCP-応答は、再送さDCCP要求データがドロップコード0、プロトコルの制約で報告されているオプションは、ドロップされました。サーバーは、最初のデータを拒否した場合（またはドロップコード0ドロップブロック内（サーバーがデータを受け入れられるかはデータがなかった場合）、元DCCP-Requestは、データで報告されるべきでは通常、ブロックのいずれかで、オプションをドロップ時間も）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Data Dropped and Init Cookie options are particularly useful for DCCP-Response packets (Sections 11.7 and 8.1.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データはドロップとinitクッキーオプションはDCCP  - レスポンスパケット（セクション11.7および8.1.4）のために特に有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server leaves the RESPOND state for OPEN when it receives a valid DCCP-Ack from the client, completing the three-way handshake. It MAY also leave the RESPOND state for CLOSED after a timeout of not less than 4MSL (8 minutes); when doing so, it SHOULD send a DCCP-Reset with Reset Code 2, &#34;Aborted&#34;, to clean up state at the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは3ウェイハンドシェイクが完了し、クライアントから有効なDCCP-ACKを受信したときに、サーバーがOPENのためにRESPOND状態を離れます。また、4MSL（8分）以上のタイムアウト後にCLOSEDのためにRESPOND状態を残すことができます。そうするとき、それは、クライアントの状態をクリーンアップするために、リセットコード2、「中止」とDCCP-リセットを送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.4. Init Cookie Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.4. 初期クッキーオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+--------+--------
   |00100100| Length |         Init Cookie Value   ...
   +--------+--------+--------+--------+--------+--------
    Type=36
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Init Cookie option lets a DCCP server avoid having to hold any state until the three-way connection setup handshake has completed, in a similar fashion as for TCP SYN cookies [SYNCOOKIES]. The server wraps up the Service Code, server port, and any options it cares about from both the DCCP-Request and DCCP-Response in an opaque cookie. Typically the cookie will be encrypted using a secret known only to the server and will include a cryptographic checksum or magic value so that correct decryption can be verified. When the server receives the cookie back in the response, it can decrypt the cookie and instantiate all the state it avoided keeping. In the meantime, it need not move from the LISTEN state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期クッキーオプションは、3ウェイ接続設定ハンドシェイクが完了するまで、TCP SYNクッキー[syncookies機能]の場合と同様の方法で、任意の状態を保持する必要がDCCPサーバーの回避をすることができます。サーバーは、サービスコード、サーバポート、およびそれがDCCP-要求と不透明なクッキーでDCCP-応答の両方から気に任意のオプションをラップします。通常、クッキーはサーバだけに知られている秘密を使用して暗号化され、正しい復号化を検証できるように、暗号化チェックサムや魔法値が含まれます。サーバが応答して戻ってクッキーを受信すると、クッキーを解読し、それが維持避け、すべての状態をインスタンス化することができます。一方で、それはLISTEN状態から移動する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Init Cookie option MUST NOT be sent on DCCP-Request or DCCP-Data packets. Any Init Cookie options received on DCCP-Request or DCCP-Data packets, or after the connection has been established (when the connection&#39;s state is &gt;= OPEN), MUST be ignored. The server MAY include Init Cookie options in its DCCP-Response. If so, then the client MUST echo the same Init Cookie options, in the same order, in each succeeding DCCP packet until one of those packets is acknowledged (showing that the three-way handshake has completed) or the connection is reset. As a result, the client MUST NOT use DCCP-Data packets until the three-way handshake completes or the connection is reset. The Init Cookie options on a client packet MUST equal those received on the DCCP-Request indicated by the client packet&#39;s Acknowledgement Number. The server SHOULD design its Init Cookie format so that Init Cookies can be checked for tampering; it SHOULD respond to a tampered Init Cookie option by resetting the connection with Reset Code 10, &#34;Bad Init Cookie&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期クッキーオプションは、DCCP-要求またはDCCP  - データパケットに送ってはいけません。任意のInit CookieのオプションはDCCP-要求またはDCCP  - データパケットで受信し、または（接続の状態が&gt; = OPENのとき）、接続が確立された後、無視しなければなりません。サーバーは、そのDCCP-応答でのInit Cookieのオプションを含むかもしれません。もしそうであれば、クライアントは、これらのパケットの1つまで、各後続DCCPパケットに、同じ順序で、同じ初期クッキーオプションをエコーし​​なければならない肯定応答（スリーウェイハンドシェイクが完了したことを示す）、または接続がリセットされます。 3ウェイハンドシェイクが完了したか、接続がリセットされるまでその結果、クライアントはDCCP  - データパケットを使用してはなりません。クライアントパケット上のInit Cookieのオプションは、クライアントパケットの確認応答番号で示さDCCP-要求で受信したものと等しくなければなりません。初期のクッキーが改ざんをチェックすることができるように、サーバーは、その初期Cookie形式を設計する必要があります。それはリセットコード10、「悪い初期クッキー」との接続をリセットすることにより、改ざんのInit Cookieのオプションに応じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Init Cookie&#39;s precise implementation need not be specified here; since Init Cookies are opaque to the client, there are no interoperability concerns. An example cookie format might encrypt (using a secret key) the connection&#39;s initial sequence and acknowledgement numbers, ports, Service Code, any options included on the DCCP-Request packet and the corresponding DCCP-Response, a random salt, and a magic number. On receiving a reflected Init Cookie, the server would decrypt the cookie, validate it by checking its magic number, sequence numbers, and ports, and, if valid, create a corresponding socket using the options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期クッキーの正確な実装では、ここで指定する必要はありません。初期クッキーがクライアントに不透明であることから、何の相互運用性の問題はありません。例えば、クッキーのフォーマットは、接続の初期シーケンスおよび確認応答番号、ポート、サービスコード、任意のオプションはDCCP-Requestパケットに含まれており、対応するDCCP-応答、ランダム塩、およびマジックナンバー（秘密鍵を使用して）暗号化するかもしれません。有効な場合は、オプションを使用して対応するソケットを作成し、反映のInitクッキーを受信すると、サーバは、クッキーを解読するでしょうそのマジックナンバー、シーケンス番号、およびポートをチェックして、それを検証し、そして。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each individual Init Cookie option can hold at most 253 bytes of data, but a server can send multiple Init Cookie options to gain more space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個々のInit Cookieのオプションは、データの最大で253のバイトを保持することができますが、サーバーはより多くのスペースを得るために、複数のInit Cookieのオプションを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.5. Handshake Completion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.5. ハンドシェイク完了
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client receives a DCCP-Response from the server, it moves from the REQUEST state to PARTOPEN and completes the three-way handshake by sending a DCCP-Ack packet to the server. The client remains in PARTOPEN until it can be sure that the server has received some packet the client sent from PARTOPEN (either the initial DCCP-Ack or a later packet). Clients in the PARTOPEN state that want to send data MUST do so using DCCP-DataAck packets, not DCCP-Data packets. This is because DCCP-Data packets lack Acknowledgement Numbers, so the server can&#39;t tell from a DCCP-Data packet whether the client saw its DCCP-Response. Furthermore, if the DCCP-Response included an Init Cookie, that Init Cookie MUST be included on every packet sent in PARTOPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバからDCCP-応答を受信した場合、それはPARTOPENにREQUEST状態から移動し、サーバにDCCP-Ackパケットを送信することにより、3ウェイハンドシェイクを完了します。サーバがいくつかのパケットPARTOPEN（どちらかの初期のDCCP-Ackの以降のパケット）から送信されたクライアントを受け取ったことを確認することができるようになるまで、クライアントはPARTOPENに残っています。データを送信したいPARTOPEN状態にあるクライアントは、DCCP  - データパケットはDCCP-DataAckパケットを使用して、ないそうしなければなりません。 DCCP  - データパケットは確認応答番号が不足しているので、クライアントはそのDCCP-応答を見たかどうかをサーバがDCCP  - データパケットから言うことができないためです。さらに、場合DCCP-応答は、initクッキーがPARTOPENに送信されるすべてのパケットに含まれなければならないことを、初期クッキーが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The single DCCP-Ack sent when entering the PARTOPEN state might, of course, be dropped by the network. The client SHOULD ensure that some packet gets through eventually. The preferred mechanism would be a roughly 200-millisecond timer, set every time a packet is transmitted in PARTOPEN. If this timer goes off and the client is still in PARTOPEN, the client generates another DCCP-Ack and backs off the timer. If the client remains in PARTOPEN for more than 4MSL (8 minutes), it SHOULD reset the connection with Reset Code 2, &#34;Aborted&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PARTOPEN状態に入るときに送信される単一のDCCP-Ackのは、当然のことながら、ネットワークによって廃棄される可能性があります。クライアントは、いくつかのパケットが最終的を通じて取得することを確認する必要があります。好ましい機構は、パケットがPARTOPENで送信されるたびに設定おおよそ200ミリ秒タイマであろう。このタイマーがオフになると、クライアントはPARTOPENに残っている場合、クライアントは別のDCCP-ACKを生成し、タイマーをオフにバックアップします。クライアントが4MSL以上（8分）のためにPARTOPENに残っている場合、それは、「中止」リセットコード2との接続をリセットする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client leaves the PARTOPEN state for OPEN when it receives a valid packet other than DCCP-Response, DCCP-Reset, or DCCP-Sync from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、サーバからDCCP-応答、DCCP-リセット、またはDCCP同期以外の有効なパケットを受信した場合、クライアントは、OPENのためPARTOPEN状態を離れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Data Transfer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. データ転送
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the central data transfer phase of the connection, both server and client are in the OPEN state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続の中央のデータ転送フェーズでは、サーバーとクライアントの両方がOPEN状態になっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP A sends DCCP-Data and DCCP-DataAck packets to DCCP B due to application events on host A. These packets are congestion-controlled by the CCID for the A-to-B half-connection. In contrast, DCCP-Ack packets sent by DCCP A are controlled by the CCID for the B-to-A half-connection. Generally, DCCP A will piggyback acknowledgement information on DCCP-Data packets when acceptable, creating DCCP-DataAck packets. DCCP-Ack packets are used when there is no data to send from DCCP A to DCCP B, or when the congestion state of the A-to-B CCID will not allow data to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP Aは、これらのパケットが輻輳制御のA対B半接続のためにCCIDによるものによるホストA上のアプリケーションイベントにDCCP BにDCCP-データとDCCP-DataAckパケットを送信します。対照的に、DCCP Aによって送られたDCCP-ACKパケットは、B-に半接続のためにCCIDによって制御されます。 DCCP-DataAckパケットを作成する際に許容される、一般的に、DCCP AはDCCP  - データパケットに対して送達確認情報をピギーバックします。そこDCCP BへのDCCP Aから送信するデータがない、またはA対B CCIDの輻輳状態は、データが送信されることを許可しないとき場合DCCP-ACKパケットが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Sync and DCCP-SyncAck packets may also occur in the data transfer phase. Some cases causing DCCP-Sync generation are discussed in Section 7.5. One important distinction between DCCP-Sync packets and other packet types is that DCCP-Sync elicits an immediate acknowledgement. On receiving a valid DCCP-Sync packet, a DCCP endpoint MUST immediately generate and send a DCCP-SyncAck response (subject to any implementation rate limits); the Acknowledgement Number on that DCCP-SyncAck MUST equal the Sequence Number of the DCCP-Sync.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-SyncとDCCP-SyncAckパケットはまた、データ転送フェーズで行うことができます。 DCCP同期発生の原因となるいくつかの場合には、セクション7.5に記載されています。 DCCP-Syncのパケットと他のパケットタイプの間の1つの重要な違いはDCCP-Syncが即時確認応答を誘発することです。有効なDCCP同期パケットを受信すると、DCCP終点は直ちにDCCP-SyncAck応答（どんな実装レート制限を受ける）を生成して送信しなければなりません。そのDCCP-SyncAckに確認応答番号DCCP同期のシーケンス番号に等しくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A particular DCCP implementation might decide to initiate feature negotiation only once the OPEN state was reached, in which case it might not allow data transfer until some time later. Data received during that time SHOULD be rejected and reported using a Data Dropped Drop Block with Drop Code 0, Protocol Constraints (see Section 11.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のDCCP実装は、OPEN状態は、それはいくつかの時間後になるまでのデータ転送を許可しない場合があります。その場合には、達成された一度だけの機能の交渉を開始することを決めるかもしれません。その時に受信したデータは、拒否され、データがドロップコード0で落下ブロックをドロップ使用して報告されるべきである（SHOULD）プロトコルの制約（11.7節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Termination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. 終了
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP connection termination uses a handshake consisting of an optional DCCP-CloseReq packet, a DCCP-Close packet, and a DCCP-Reset packet. The server moves from the OPEN state, possibly through the CLOSEREQ state, to CLOSED; the client moves from OPEN through CLOSING to TIMEWAIT, and after 2MSL wait time (4 minutes) to CLOSED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP接続終了は、オプションDCCP-CloseReqパケット、DCCPクローズパケット、およびDCCP  - リセットパケットからなるハンドシェイクを使用しています。サーバはCLOSEDに、おそらくはCLOSEREQ状態を介して、開状態から移動します。クライアントはTIMEWAITにCLOSINGを通じてOPENから移動し、2MSL後CLOSEDまでの時間（4分）を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequence DCCP-CloseReq, DCCP-Close, DCCP-Reset is used when the server decides to close the connection but doesn&#39;t want to hold TIMEWAIT state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスDCCP-CloseReq、DCCP-閉じるが、DCCP  - リセットは、サーバーが接続を終了することを決定したが、TIMEWAIT状態を保持したくないときに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Client State Server State OPEN OPEN 1. &lt;-- CloseReq &lt;-- CLOSEREQ 2. CLOSING --&gt; Close --&gt; 3. &lt;-- Reset &lt;-- CLOSED (LISTEN) 4. TIMEWAIT 5. CLOSED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント状態サーバーの状態OPEN OPEN 1. &lt; -  CloseReq &lt; -  CLOSEREQ 2. CLOSING  - &gt;閉じる - &gt; 3 &lt; -  &lt;リセット -  CLOSED（LISTEN）4. TIMEWAIT 5. CLOSED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A shorter sequence occurs when the client decides to close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが接続を閉じることを決定したときより短い配列が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Client State Server State OPEN OPEN 1. CLOSING --&gt; Close --&gt; 2. &lt;-- Reset &lt;-- CLOSED (LISTEN) 3. TIMEWAIT 4. CLOSED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント状態サーバーの状態OPEN OPEN 1. CLOSING  - &gt;閉じる - &gt; 2. &lt; -  &lt;リセット -  CLOSED（LISTEN）3. TIME_WAIT 4. CLOSED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the server can decide to hold TIMEWAIT state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、サーバはTIMEWAIT状態を保持することを決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Client State Server State OPEN OPEN 1. &lt;-- Close &lt;-- CLOSING 2. CLOSED --&gt; Reset --&gt; 3. TIMEWAIT 4. CLOSED (LISTEN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント状態サーバーの状態OPEN OPEN 1. &lt; - クローズ&lt; -  2が閉じ閉会 - &gt;リセット - &gt; 3. TIMEWAIT 4. CLOSED（LISTEN）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In all cases, the receiver of the DCCP-Reset packet holds TIMEWAIT state for the connection. As in TCP, TIMEWAIT state, where an endpoint quietly preserves a socket for 2MSL (4 minutes) after its connection has closed, ensures that no connection duplicating the current connection&#39;s source and destination addresses and ports can start up while old packets might remain in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全ての場合において、DCCP  - リセットパケットの受信機は、接続用TIMEWAIT状態を保持します。 TCPのように、その接続が閉じられた後に、エンドポイントが静かに2MSL（4分）のためのソケットを保持するTIMEWAIT状態は、古いパケットが中に残っているかもしれないが、現在の接続の送信元と送信先アドレスとポートを複製するには接続が起動しないことが保証さ通信網。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The termination handshake proceeds as follows. The receiver of a valid DCCP-CloseReq packet MUST respond with a DCCP-Close packet. The receiver of a valid DCCP-Close packet MUST respond with a DCCP-Reset packet with Reset Code 1, &#34;Closed&#34;. The receiver of a valid DCCP-Reset packet -- which is also the sender of the DCCP-Close packet (and possibly the receiver of the DCCP-CloseReq packet) -- will hold TIMEWAIT state for the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように終了ハンドシェイクが進行します。有効なDCCP-CloseReqパケットの受信機はDCCP-閉じるパケットで応じなければなりません。有効なDCCP-閉じるパケットの受信機は、「クローズ」、リセットコード1とDCCP-リセットパケットで応じなければなりません。また、DCCPクローズパケット（およびおそらくDCCP-CloseReqパケットの受信機）の送信元である -   - 有効なDCCP  - リセットパケットの受信機は、接続用TIMEWAIT状態を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP-Reset packet completes every DCCP connection, whether the termination is clean (due to application close; Reset Code 1, &#34;Closed&#34;) or unclean. Unlike TCP, which has two distinct termination mechanisms (FIN and RST), DCCP ends all connections in a uniform manner. This is justified because some aspects of connection termination are the same independent of whether termination was clean. For instance, the endpoint that receives a valid DCCP-Reset SHOULD hold TIMEWAIT state for the connection. Processors that must distinguish between clean and unclean termination can examine the Reset Code. DCCP implementations generally transition to the CLOSED state after sending a DCCP-Reset packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
または汚れ; DCCP-リセットパケットが終了（リセットコード1、「クローズ」により近いアプリケーションに）きれいであるかどうか、すべてのDCCP接続を完了します。二つの別個の終結機構（FIN及びRST）を有するTCPとは異なり、DCCPは均一にすべての接続を終了します。接続終了のいくつかの側面を終了がきれいだったかどうか、同じ独立しているので、これは正当化されます。例えば、有効なDCCP-リセットを受信エンドポイントは、接続のためのTIMEWAIT状態を保持する必要があります。清潔で汚れ終了とを区別しなければならないプロセッサは、リセットコードを調べることができます。 DCCP実装は、一般的にDCCP  - リセットパケットを送信した後CLOSED状態に遷移します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints in the CLOSEREQ and CLOSING states MUST retransmit DCCP-CloseReq and DCCP-Close packets, respectively, until leaving those states. The retransmission timer should initially be set to go off in two round-trip times and should back off to not less than once every 64 seconds if no relevant response is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEREQとCLOSING状態でのエンドポイントは、それらの状態を残してまで、それぞれ、DCCP-CloseReqとDCCP-閉じるパケットを再送しなければなりません。再送タイマは、最初に2往復時間でオフに行くように設定されるべきであると該当する応答が受信されない場合は一回64秒未満ではないにバックオフする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Only the server can send a DCCP-CloseReq packet or enter the CLOSEREQ state. A server receiving a sequence-valid DCCP-CloseReq packet MUST respond with a DCCP-Sync packet and otherwise ignore the DCCP-CloseReq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバだけがDCCP-CloseReqパケットを送信したり、CLOSEREQ状態に入ることができます。シーケンスの有効なDCCP-CloseReqパケットを受信したサーバはDCCP同期パケットで応答し、そうでない場合はDCCP-CloseReqを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Data, DCCP-DataAck, and DCCP-Ack packets received in CLOSEREQ or CLOSING states MAY be either processed or ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEREQまたはCLOSING状態で受信DCCP-データ、DCCP-DataAck、およびDCCP-Ackのパケットが処理されるか、または無視のいずれかであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.1. Abnormal Termination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3.1. 異常終了
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints generate DCCP-Reset packets to terminate connections abnormally; a DCCP-Reset packet may be generated from any state. Resets sent in the CLOSED, LISTEN, and TIMEWAIT states use Reset Code 3, &#34;No Connection&#34;, unless otherwise specified. Resets sent in the REQUEST or RESPOND states use Reset Code 4, &#34;Packet Error&#34;, unless otherwise specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点は、異常な接続を終了するDCCP  - リセットパケットを生成します。 DCCP  - リセットパケットは、任意の状態から生成することができます。 CLOSEDに送られたリセットは、LISTEN、特に断らない限りTIMEWAIT状態は、リセットコード3、「接続なし」を使用します。リセットは、リクエストで送信されたか、特に指定のない限り状態は、リセットコード4、「パケットエラー」を使用して応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints in CLOSED, LISTEN, or TIMEWAIT state may need to generate a DCCP-Reset packet in response to a packet received from a peer. Since these states have no associated sequence number variables, the Sequence and Acknowledgement Numbers on the DCCP-Reset packet R are taken from the received packet P, as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEDにおけるDCCPエンドポイントは、LISTEN、またはTIMEWAIT状態は、ピアから受信したパケットに応答して、DCCP  - リセットパケットを生成する必要があるかもしれません。これらの状態は、DCCP  - リセットパケットRには関連付けられたシーケンス番号変数、シーケンスおよび確認応答番号を持っていないので、次のように、受信したパケットPから取られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If P.ackno exists, then set R.seqno := P.ackno + 1. Otherwise, set R.seqno := 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. P.acknoが存在する場合、R.seqno設定します、それ以外の場合= P.ackno + 1. R.seqnoを設定：= 0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Set R.ackno := P.seqno.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.設定しR.ackno：= P.seqno。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the packet used short sequence numbers (P.X == 0), then set the upper 24 bits of R.seqno and R.ackno to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.パケットが短い一連番号（P.X == 0）を使用した場合、0にR.seqnoとR.acknoの上位24ビットを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. DCCP State Diagram
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4.  DCCP状態図
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most common state transitions discussed above can be summarized in the following state diagram. The diagram is illustrative; the text in Section 8.5 and elsewhere should be considered definitive. For example, there are arcs (not shown) from every state except CLOSED to TIMEWAIT, contingent on the receipt of a valid DCCP-Reset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述の最も一般的な状態遷移は、以下の状態図に要約することができます。図は例示です。セクション8.5および他の場所でのテキストが決定的と考えるべきです。例えば、TIMEWAIT、有効なDCCP  - リセットを受けて偶発的にCLOSED以外のすべての状態からアーク（図示せず）があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------------------+    +---------------------------+
   |                           v    v                           |
   |                        +----------+                        |
   |          +-------------+  CLOSED  +------------+           |
   |          | passive     +----------+  active    |           |
   |          |  open                      open     |           |
   |          |                         snd Request |           |
   |          v                                     v           |
   |     +----------+                          +----------+     |
   |     |  LISTEN  |                          | REQUEST  |     |
   |     +----+-----+                          +----+-----+     |
   |          | rcv Request            rcv Response |           |
   |          | snd Response             snd Ack    |           |
   |          v                                     v           |
   |     +----------+                          +----------+     |
   |     | RESPOND  |                          | PARTOPEN |     |
   |     +----+-----+                          +----+-----+     |
   |          | rcv Ack/DataAck         rcv packet  |           |
   |          |                                     |           |
   |          |             +----------+            |           |
   |          +------------&gt;|   OPEN   |&lt;-----------+           |
   |                        +--+-+--+--+                        |
   |       server active close | |  |   active close            |
   |           snd CloseReq    | |  | or rcv CloseReq           |
   |                           | |  |    snd Close              |
   |                           | |  |                           |
   |     +----------+          | |  |          +----------+     |
   |     | CLOSEREQ |&lt;---------+ |  +---------&gt;| CLOSING  |     |
   |     +----+-----+            |             +----+-----+     |
   |          | rcv Close        |        rcv Reset |           |
   |          | snd Reset        |                  |           |
   |&lt;---------+                  |                  v           |
   |                             |             +----+-----+     |
   |                   rcv Close |             | TIMEWAIT |     |
   |                   snd Reset |             +----+-----+     |
   +-----------------------------+                  |           |
                                                    +-----------+
                                                 2MSL timer expires
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. Pseudocode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. 擬似コード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section presents an algorithm describing the processing steps a DCCP endpoint must go through when it receives a packet. A DCCP implementation need not implement the algorithm as it is described here, but any implementation MUST generate observable effects exactly as indicated by this pseudocode, except where allowed otherwise by another part of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、処理は、それがパケットを受信したときDCCP終点が通過しなければならない手順を記述したアルゴリズムを示します。それがここで説明されるようDCCP実装は、アルゴリズムを実装する必要はなく、任意の実装は、この文書の別の部分でそれ以外の場合は許可した場合を除いて、この擬似コードで示されているとおりに観察可能な効果を発生させなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The received packet is written as P, the socket as S. Socket variables are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したパケットをPとして書き込まれ、S.ソケット変数としてソケットは、次のとおり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S.SWL - sequence number window low S.SWH - sequence number window high S.AWL - acknowledgement number window low S.AWH - acknowledgement number window high S.ISS - initial sequence number sent S.ISR - initial sequence number received S.OSR - first OPEN sequence number received S.GSS - greatest sequence number sent S.GSR - greatest valid sequence number received S.GAR - greatest valid acknowledgement number received on a non-Sync; initialized to S.ISS &#34;Send packet&#34; actions always use, and increment, S.GSS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S.SWL  - シーケンス番号のウィンドウ低いS.SWH  - シーケンス番号のウィンドウ高S.AWL  - 確認応答番号のウィンドウ低いS.AWH  - 確認応答番号のウィンドウ高S.ISS  - 初期シーケンス番号はS.ISRを送った - 初期シーケンス番号は、Sを受信OSR  - 最初のOPENシーケンス番号がS.GSSを受けた - 最大のシーケンス番号がS.GSRを送った - 最大の有効なシーケンス番号がS.GAR受信 - 非同期で受信した最大の有効な承認番号を、 、S.GSSをS.ISSアクション常に使用「パケットが送信」、および増分に初期化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 1: Check header basics
      /* This step checks for malformed packets.  Packets that fail
         these checks are ignored -- they do not receive Resets in
         response */
      If the packet is shorter than 12 bytes, drop packet and return
      If P.type is not understood, drop packet and return
      If P.Data Offset is smaller than the given packet type&#39;s
            fixed header length or larger than the packet&#39;s length,
            drop packet and return
      If P.type is not Data, Ack, or DataAck and P.X == 0 (the packet
            has short sequence numbers), drop packet and return
      If the header checksum is incorrect, drop packet and return
      If P.CsCov is too large for the packet size, drop packet and
            return
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 2: Check ports and process TIMEWAIT state
      /* Flow ID is &lt;src addr, src port, dst addr, dst port&gt; 4-tuple */
      Look up flow ID in table and get corresponding socket
      If no socket, or S.state == TIMEWAIT,
         /* The following Reset&#39;s Sequence and Acknowledgement Numbers
            are taken from the input packet; see Section 8.3.1. */
         Generate Reset(No Connection) unless P.type == Reset
         Drop packet and return
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 3: Process LISTEN state
      If S.state == LISTEN,
         If P.type == Request or P contains a valid Init Cookie option,
            /* Must scan the packet&#39;s options to check for Init
               Cookies.  Only Init Cookies are processed here,
               however; other options are processed in Step 8.  This
               scan need only be performed if the endpoint uses Init
               Cookies */
            /* Generate a new socket and switch to that socket */
            Set S := new socket for this port pair
            S.state = RESPOND
            Choose S.ISS (initial seqno) or set from Init Cookies
            Initialize S.GAR := S.ISS
            Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookies
            Continue with S.state == RESPOND
            /* A Response packet will be generated in Step 11 */
         Otherwise,
            Generate Reset(No Connection) unless P.type == Reset
            Drop packet and return
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 4: Prepare sequence numbers in REQUEST
      If S.state == REQUEST,
         If (P.type == Response or P.type == Reset)
               and S.AWL &lt;= P.ackno &lt;= S.AWH,
            /* Set sequence number variables corresponding to the
               other endpoint, so P will pass the tests in Step 6 */
            Set S.GSR, S.ISR, S.SWL, S.SWH
            /* Response processing continues in Step 10; Reset
               processing continues in Step 9 */
         Otherwise,
            /* Only Response and Reset are valid in REQUEST state */
            Generate Reset(Packet Error)
            Drop packet and return
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 5: Prepare sequence numbers for Sync
      If P.type == Sync or P.type == SyncAck,
         If S.AWL &lt;= P.ackno &lt;= S.AWH and P.seqno &gt;= S.SWL,
            /* P is valid, so update sequence number variables
               accordingly.  After this update, P will pass the tests
               in Step 6.  A SyncAck is generated if necessary in
               Step 15 */
            Update S.GSR, S.SWL, S.SWH
         Otherwise,
            Drop packet and return
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 6: Check sequence numbers
      If P.X == 0 and the relevant Allow Short Seqnos feature is 0,
         /* Packet has short seqnos, but short seqnos not allowed */
         Drop packet and return
      Otherwise, if P.X == 0,
         Extend P.seqno and P.ackno to 48 bits using the procedure
         in Section 7.6
      Let LSWL = S.SWL and LAWL = S.AWL
      If P.type == CloseReq or P.type == Close or P.type == Reset,
         LSWL := S.GSR + 1, LAWL := S.GAR
      If LSWL &lt;= P.seqno &lt;= S.SWH
            and (P.ackno does not exist or LAWL &lt;= P.ackno &lt;= S.AWH),
         Update S.GSR, S.SWL, S.SWH
         If P.type != Sync,
            Update S.GAR
      Otherwise,
         If P.type == Reset,
            Send Sync packet acknowledging S.GSR
         Otherwise,
            Send Sync packet acknowledging P.seqno
         Drop packet and return
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 7: Check for unexpected packet types If (S.is_server and P.type == CloseReq) or (S.is_server and P.type == Response) or (S.is_client and P.type == Request) or (S.state &gt;= OPEN and P.type == Request and P.seqno &gt;= S.OSR) or (S.state &gt;= OPEN and P.type == Response and P.seqno &gt;= S.OSR) or (S.state == RESPOND and P.type == Data), Send Sync packet acknowledging P.seqno Drop packet and return
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステップ7：（リクエスト== S.is_clientとP.type）場合（S.is_serverとP.type CloseReq ==）予想外のパケットの種類を確認するか（S.is_serverとP.type ==応答）またはまたは（S .state&gt; = OPENとP.type ==リクエストとP.seqno&gt; = S.OSR）または（S.state&gt; = OPENとP.type ==応答とP.seqno&gt; = S.OSR）または（S .state ==対応し、P.type ==データ）、P.seqnoドロップパケットとリターンを認め同期パケットを送信します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 8: Process options and mark acknowledgeable
      /* Option processing is not specifically described here.
         Certain options, such as Mandatory, may cause the connection
         to be reset, in which case Steps 9 and on are not executed */
      Mark packet as acknowledgeable (in Ack Vector terms, Received
           or Received ECN Marked)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 9: Process Reset If P.type == Reset, Tear down connection S.state := TIMEWAIT Set TIMEWAIT timer Drop packet and return
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
手順9：プロセスがP.typeが==リセットした場合、リセット接続S.stateを取り壊す：= TIMEWAIT設定TIMEWAITタイマードロップパケットとリターン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 10: Process REQUEST state (second part)
      If S.state == REQUEST,
         /* If we get here, P is a valid Response from the server (see
            Step 4), and we should move to PARTOPEN state.  PARTOPEN
            means send an Ack, don&#39;t send Data packets, retransmit
            Acks periodically, and always include any Init Cookie from
            the Response */
         S.state := PARTOPEN
         Set PARTOPEN timer
         Continue with S.state == PARTOPEN
         /* Step 12 will send the Ack completing the three-way
            handshake */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 11: Process RESPOND state
      If S.state == RESPOND,
         If P.type == Request,
            Send Response, possibly containing Init Cookie
            If Init Cookie was sent,
               Destroy S and return
               /* Step 3 will create another socket when the client
                  completes the three-way handshake */
         Otherwise,
            S.OSR := P.seqno
            S.state := OPEN
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 12: Process PARTOPEN state If S.state == PARTOPEN, If P.type == Response, Send Ack Otherwise, if P.type != Sync, S.OSR := P.seqno S.state := OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステップ12：、P.type ==応答した場合、P.typeあれば、そうでない場合はACKを送るプロセスPARTOPEN状態S.state == PARTOPEN場合=同期、S.OSR：！= P.seqno S.state：= OPEN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 13: Process CloseReq If P.type == CloseReq and S.state &lt; CLOSEREQ, Generate Close S.state := CLOSING Set CLOSING timer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステップ13：= CLOSINGセットCLOSINGタイマー：プロセスCloseReq P.type == CloseReqとS.state &lt;CLOSEREQは、閉じるS.stateを生成する場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 14: Process Close If P.type == Close, Generate Reset(Closed) Tear down connection Drop packet and return
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステップ14：プロセス閉じるP.type ==閉じる場合は、リセット（クローズ）を生成し、接続ドロップパケットとリターンを取り壊します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 15: Process Sync If P.type == Sync, Generate SyncAck
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステップ15：プロセス同期する場合P.type ==同期、SyncAckを生成します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Step 16: Process data
      /* At this point any application data on P can be passed to the
         application, except that the application MUST NOT receive
         data from more than one Request or Response */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Checksums
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.チェックサム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP uses a header checksum to protect its header against corruption. Generally, this checksum also covers any application data. DCCP applications can, however, request that the header checksum cover only part of the application data, or perhaps no application data at all. Link layers may then reduce their protection on unprotected parts of DCCP packets. For some noisy links, and for applications that can tolerate corruption, this can greatly improve delivery rates and perceived performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは、腐敗、そのヘッダを保護するために、ヘッダチェックサムを使用しています。一般的には、このチェックサムはまた、任意のアプリケーションデータをカバーしています。 DCCPアプリケーションは、しかし、アプリケーションデータ、またはまったく多分ないアプリケーションデータのヘッダチェックサムカバーは一部のみように要求することができます。リンク層は、DCCPパケットの保護されていない部分について、その保護を減らすことができます。いくつかの騒々しいリンクについては、汚職を許容できるアプリケーションのために、これは非常に配達率と体感的なパフォーマンスを向上させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Checksum coverage may eventually impact congestion control mechanisms as well. A packet with corrupt application data and complete checksum coverage is treated as lost. This incurs a heavy-duty loss response from the sender&#39;s congestion control mechanism, which can unfairly penalize connections on links with high background corruption. The combination of reduced checksum coverage and Data Checksum options may let endpoints report packets as corrupt rather than dropped, using Data Dropped options and Drop Code 3 (see Section 11.7). This may eventually benefit applications. However, further research is required to determine an appropriate response to corruption, which can sometimes correlate with congestion. Corrupt packets currently incur a loss response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チェックサム・カバレッジは、最終的にも輻輳制御メカニズムに影響を与えることができます。失われたとして、破損したアプリケーションデータと完全なチェックサム適用範囲を持つパケットが処理されます。これは不当に高いバックグラウンドの破損とのリンクで接続を罰することができ、送信者の輻輳制御機構、から大型損失応答が発生します。減少し、チェックサムのカバレッジとデータチェックサムオプションの組み合わせは、エンドポイントは、データはオプションとドロップコード3を（11.7節を参照してください）ドロップ使用して、破損しているとしてではなく、ドロップされたパケットを報告してみましょうことがあります。これは、最終的にアプリケーションを利益を得ることができます。しかしながら、さらなる研究が時々混雑と相関することができる破損への適切な応答を決定する必要があります。破損したパケットは、現在の損失応答を被ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Data Checksum option, which contains a strong CRC, lets endpoints detect application data corruption. An API can then be used to avoid delivering corrupt data to the application, even if links deliver corrupt data to the endpoint due to reduced checksum coverage. However, the use of reduced checksum coverage for applications that demand correct data is currently considered experimental. This is because the combined loss-plus-corruption rate for packets with reduced checksum coverage may be significantly higher than that for packets with full checksum coverage, although the loss rate will generally be lower. Actual behavior will depend on link design; further research and experience is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
強力なCRCが含まれているデータのチェックサムオプションは、エンドポイントは、アプリケーションデータの破損を検出することができます。 APIは、リンクが減少し、チェックサム・カバレッジのためにエンドポイントに破損したデータを提供する場合でも、アプリケーションに壊れたデータを配信避けるために使用することができます。しかし、正しいデータを必要とするアプリケーションのために減少したチェックサム適用範囲の使用は、現在、実験的なものと考えています。損失率は、一般的に低くなるが減少チェックサム適用範囲とパケットの複合損失プラス破損率は、完全なチェックサム・カバレッジを有するパケットの場合よりも有意に高くすることができるからです。実際の動作は、リンクの設計に依存します。さらなる研究と経験が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reduced checksum coverage introduces some security considerations; see Section 18.1. See Appendix B for further motivation and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
減少し、チェックサム適用範囲は、いくつかのセキュリティ上の考慮事項を紹介します。 18.1節を参照してください。さらに動機については、付録Bを参照してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
discussion. DCCP&#39;s implementation of reduced checksum coverage was inspired by UDP-Lite [RFC3828].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
討論。減少し、チェックサム・カバレッジのDCCPの実装はUDP-Liteは[RFC3828]に触発されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Header Checksum Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. ヘッダチェックサム・フィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP uses the TCP/IP checksum algorithm. The Checksum field in the DCCP generic header (see Section 5.1) equals the 16-bit one&#39;s complement of the one&#39;s complement sum of all 16-bit words in the DCCP header, DCCP options, a pseudoheader taken from the network-layer header, and, depending on the value of the Checksum Coverage field, some or all of the application data. When calculating the checksum, the Checksum field itself is treated as 0. If a packet contains an odd number of header and payload bytes to be checksummed, 8 zero bits are added on the right to form a 16-bit word for checksum purposes. The pad byte is not transmitted as part of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは、TCP / IPのチェックサムアルゴリズムを使用しています。 DCCPジェネリックヘッダ内のチェックサムフィールド（セクション5.1を参照）DCCPヘッダ、DCCPオプション、ネットワーク層ヘッダから取られた擬似ヘッダ内の全ての16ビットワードの1の補数和の16ビットの1の補数に等しく、そしてアプリケーションデータのチェックサム・カバレッジ・フィールドの値に応じて、一部またはすべて。チェックサムを計算するときに、パケットが8ゼロビットがチェックサムの目的のために、16ビット・ワードを形成するために右側に追加され、チェックサムするヘッダとペイロードバイトの奇数が含まれている場合、チェックサムフィールド自体は0として扱われます。パッドバイトは、パケットの一部として送信されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pseudoheader is calculated as for TCP. For IPv4, it is 96 bits long and consists of the IPv4 source and destination addresses, the IP protocol number for DCCP (padded on the left with 8 zero bits), and the DCCP length as a 16-bit quantity (the length of the DCCP header with options, plus the length of any data); see [RFC793], Section 3.1. For IPv6, it is 320 bits long, and consists of the IPv6 source and destination addresses, the DCCP length as a 32-bit quantity, and the IP protocol number for DCCP (padded on the left with 24 zero bits); see [RFC2460], Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
擬似ヘッダは、TCPのためのように計算されます。 IPv4の場合、それは96ビット長であり、IPv4ソースアドレスと宛先アドレスで構成され、（8ゼロビットで左に埋め）DCCPのためのIPプロトコル番号、および16ビット量としてDCCPの長さ（長さDCCPオプションとヘッダ、および任意のデータの長さ）。 [RFC793]、セクション3.1を参照してください。 IPv6の場合、それは長い320ビットであり、IPv6ソースアドレスと宛先アドレスで構成され、32ビットの量としてDCCPの長さ、および（24のゼロビットと左側のパディング）DCCPのためのIPプロトコル番号。 [RFC2460]、セクション8.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packets with invalid header checksums MUST be ignored. In particular, their options MUST NOT be processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無効なヘッダーチェックサムを持つパケットは無視しなければなりません。具体的には、そのオプションを処理してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Header Checksum Coverage Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. ヘッダチェックサム・カバレッジ・フィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Checksum Coverage field in the DCCP generic header (see Section 5.1) specifies what parts of the packet are covered by the Checksum field, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにDCCPジェネリックヘッダー内のチェックサムカバー範囲フィールドは、パケットの部分はチェックサムフィールドで覆われているものを指定します（セクション5.1を参照してください）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CsCov = 0 The Checksum field covers the DCCP header, DCCP options, network-layer pseudoheader, and all application data in the packet, possibly padded on the right with zeros to an even number of bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CsCov = 0チェックサムフィールドを偶数バイトにゼロが右側にパディングおそらく、DCCPヘッダ、DCCPオプション、ネットワーク層擬似ヘッダ、およびパケット内のすべてのアプリケーションデータをカバーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CsCov = 1-15 The Checksum field covers the DCCP header, DCCP options, network-layer pseudoheader, and the initial (CsCov-1)*4 bytes of the packet&#39;s application data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CsCov = 1-15チェックサムフィールドは、DCCPヘッダ、DCCPオプション、ネットワーク層擬似ヘッダ、及び初期（CsCov-1）*パケットのアプリケーションデータの4つのバイトをカバーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, if CsCov is 1, none of the application data is protected by the header checksum. The value (CsCov-1)*4 MUST be less than or equal to the length of the application data. Packets with invalid CsCov values MUST be ignored; in particular, their options MUST NOT be processed. The meanings of values other than 0 and 1 should be considered experimental.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CsCovが1である場合したがって、アプリケーションデータのいずれも、ヘッダチェックサムによって保護されていません。値（CsCov-1）* 4は、以下のアプリケーション・データの長さに等しくなければなりません。無効なCsCov値を持つパケットは無視しなければなりません。具体的には、そのオプションを処理してはなりません。 0と1以外の値の意味は実験的と見なされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Values other than 0 specify that corruption is acceptable in some or all of the DCCP packet&#39;s application data. In fact, DCCP cannot even detect corruption in areas not covered by the header checksum, unless the Data Checksum option is used. Applications should not make any assumptions about the correctness of received data not covered by the checksum and should, if necessary, introduce their own validity checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0以外の値が破損がDCCPパケットのアプリケーションデータの一部またはすべてでは許容可能であることを指定します。データチェックサムオプションを使用しない限り、実際には、DCCPも、ヘッダチェックサムによってカバーされていない領域の破損を検出することができません。アプリケーションは、チェックサムで覆われ、必要に応じて、自分自身の妥当性チェックを導入すべきではない、受信したデータの正確性についての仮定を行うべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP application interface should let sending applications suggest a value for CsCov for sent packets, defaulting to 0 (full coverage). The Minimum Checksum Coverage feature, described below, lets an endpoint refuse delivery of application data on packets with partial checksum coverage; by default, only fully covered application data is accepted. Lower layers that support partial error detection MAY use the Checksum Coverage field as a hint of where errors do not need to be detected. Lower layers MUST use a strong error detection mechanism to detect at least errors that occur in the sensitive part of the packet, and to discard damaged packets. The sensitive part consists of the bytes between the first byte of the IP header and the last byte identified by Checksum Coverage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPアプリケーションインターフェースは、アプリケーションが0（フルカバー）をデフォルト、送信されるパケットのCsCovの値を示唆して送信するようにする必要があります。以下に説明する最小サムカバレッジ機能は、エンドポイントが部分的チェックサム適用範囲とパケットのアプリケーションデータの配信を拒否することができます。デフォルトでは、唯一の完全にカバーされたアプリケーションデータが受け入れられています。部分的なエラー検出をサポートする下位層は、エラーが検出されている必要はありませんどこのヒントとしてチェックサム・カバレッジ・フィールドを使用するかもしれません。下位層は、パケットの敏感な部分で発生する少なくともエラーを検出するための強力なエラー検出メカニズムを使用しなければなりません、そして損傷したパケットを廃棄します。敏感な部分は、IPヘッダとチェックサム・カバレッジによって識別される最後のバイトの最初のバイトの間のバイトから成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For more details on application and lower-layer interface issues relating to partial checksumming, see [RFC3828].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
部分的なチェックサムに関連するアプリケーションと下層の界面の問題の詳細については、[RFC3828]を参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1. Minimum Checksum Coverage Feature
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1. 最低チェックサムカバレッジ機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Minimum Checksum Coverage feature lets a DCCP endpoint determine whether its peer is willing to accept packets with reduced Checksum Coverage. For example, DCCP A sends a &#34;Change R(Minimum Checksum Coverage, 1)&#34; option to DCCP B to check whether B is willing to accept packets with Checksum Coverage set to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小チェックサムカバレッジ機能は、DCCP終点は、そのピアが減少チェックサム・カバレッジを有するパケットを受け入れる意志があるかどうかを決定することができます。例えば、DCCP Aは、「変更R（最小チェックサム・カバレッジ、1）」Bチェックサムカバレッジを1に設定したパケットを受け入れるかどうかをチェックするDCCP Bにオプションを送ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Minimum Checksum Coverage has feature number 8 and is server-priority. It takes one-byte integer values between 0 and 15; values of 16 or more are reserved. Minimum Checksum Coverage/B reflects values of Checksum Coverage that DCCP B finds unacceptable. Say that the value of Minimum Checksum Coverage/B is MinCsCov. Then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最低チェックサムカバー範囲は、機能番号8を持っていると、サーバーの優先順位です。これは、0と15との間に1バイトの整数値をとります。 16以上の値が予約されています。最小のチェックサム・カバレッジ/ BはDCCP Bが容認できない見つけたチェックサム・カバレッジの値を反映しています。最小のチェックサム・カバレッジ/ Bの値がMinCsCovであると言います。その後：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If MinCsCov = 0, then DCCP B only finds packets with CsCov = 0 acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O MinCsCov = 0の場合、DCCP Bのみ許容されるCsCov = 0のパケットを発見します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If MinCsCov &gt; 0, then DCCP B additionally finds packets with CsCov &gt;= MinCsCov acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O MinCsCov&gt; 0の場合、DCCP BはさらにCsCov&gt; = MinCsCovで許容されるパケットを見つけます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP B MAY refuse to process application data from packets with unacceptable Checksum Coverage. Such packets SHOULD be reported using Data Dropped options (Section 11.7) with Drop Code 0, Protocol Constraints. New connections start with Minimum Checksum Coverage 0 for both endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP Bが容認できないチェックサムカバー範囲を持つパケットからアプリケーションデータを処理するために拒否することができます。このようなパケットは、データを使用して報告されるべきでドロップコード0、プロトコルの制約とオプション（11.7節）を落としました。新しい接続は両方の終点の最小チェックサムカバー範囲0から始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. Data Checksum Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. データチェックサム・オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Data Checksum option holds a 32-bit CRC-32c cyclic redundancy-check code of a DCCP packet&#39;s application data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データチェックサムオプションはDCCPパケットのアプリケーションデータの32ビットのCRC-32C巡回冗長検査符号を保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+--------+--------+
   |00101100|00000110|              CRC-32c              |
   +--------+--------+--------+--------+--------+--------+
    Type=44  Length=6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sending DCCP computes the CRC of the bytes comprising the application data area and stores it in the option data. The CRC-32c algorithm used for Data Checksum is the same as that used for SCTP [RFC3309]; note that the CRC-32c of zero bytes of data equals zero. The DCCP header checksum will cover the Data Checksum option, so the data checksum must be computed before the header checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信DCCPは、アプリケーションデータ領域及びオプションデータに格納それを含むバイトのCRCを計算します。データチェックサムに使用されるCRC-32CアルゴリズムはSCTP [RFC3309]のために用いたものと同じです。データのゼロバイトのCRC-32cはゼロに等しいことに注意してください。データチェックサムは、ヘッダチェックサムの前に計算されなければならないので、DCCPヘッダーチェックサムは、データチェックサムオプションをカバーします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP endpoint receiving a packet with a Data Checksum option either MUST or MAY check the Data Checksum; the choice depends on the value of the Check Data Checksum feature described below. If it checks the checksum, it computes the received application data&#39;s CRC-32c using the same algorithm as the sender and compares the result with the Data Checksum value. If the CRCs differ, the endpoint reacts in one of two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点データチェックサムのいずれかのオプションMUSTでパケットを受信したり、データのチェックサムを確認すること。選択は下記のチェックデータのチェックサム機能の値に依存します。それはチェックサムをチェックした場合は、送信者と同じアルゴリズムを使用して、受信したアプリケーションデータのCRC-32Cを計​​算し、データチェックサム値と結果を比較します。 CRCが異なる場合、エンドポイントは2つの方法のいずれかで反応します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The receiving application may have requested delivery of known-corrupt data via some optional API. In this case, the packet&#39;s data MUST be delivered to the application, with a note that it is known to be corrupt. Furthermore, the receiving endpoint MUST report the packet as delivered corrupt using a Data Dropped option (Drop Code 7, Delivered Corrupt).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O受信側アプリケーションは、いくつかのオプションのAPIを介して既知の破損データの配信を要求してもよいです。この場合、パケットのデータは、破損していることが知られていることに注意して、アプリケーションに配信されなければなりません。 （破損を配信ドロップコード7、）データドロップオプションを使用して破損している配信としてさらに、受信側のエンドポイントはパケットを報告しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, the receiving endpoint MUST drop the application data and report that data as dropped due to corruption using a Data Dropped option (Drop Code 3, Corrupt).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれ以外の場合は、受信エンドポイントは、アプリケーションデータを削除したデータを使用してによる破損まで低下などのデータは、（破損ドロップコード3）オプションをドロップすることを報告しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In either case, the packet is considered acknowledgeable (since its header was processed) and will therefore be acknowledged using the equivalent of Ack Vector&#39;s Received or Received ECN Marked states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれの場合も、パケットは（そのヘッダが処理されたため）承認可能であると考えられ、したがって、肯定応答ベクトルの受信または受信ECNマークされた状態と同等のものを使用して認識されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although Data Checksum is intended for packets containing application data, it may be included on other packets, such as DCCP-Ack, DCCP-
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データチェックサムは、アプリケーション・データを含むパケットのために意図されているが、そのようなDCCP-ACK、DCCP-のような他のパケットに含まれていてもよいです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sync, and DCCP-SyncAck. The receiver SHOULD calculate the application data area&#39;s CRC-32c on such packets, just as it does for DCCP-Data and similar packets. If the CRCs differ, the packets similarly MUST be reported using Data Dropped options (Drop Code 3), although their application data areas would not be delivered to the application in any case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同期、およびDCCP-SyncAck。受信機は、それがDCCP-データと類似したパケットの場合と同じように、そのようなパケットにアプリケーションデータ領域のCRC-32Cを計​​算する必要があります。 CRCが異なる場合、パケットは、同様のデータを使用して報告しなければならないそれらのアプリケーションデータ領域は、いずれの場合にもアプリケーションに配信されないが、オプション（ドロップコード3）を滴下しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.1. Check Data Checksum Feature
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.1. データチェックサム機能をチェック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Check Data Checksum feature lets a DCCP endpoint determine whether its peer will definitely check Data Checksum options. DCCP A sends a Mandatory &#34;Change R(Check Data Checksum, 1)&#34; option to DCCP B to require it to check Data Checksum options (the connection will be reset if it cannot).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チェックデータのチェックサム機能は、DCCP終点はそのピアは間違いなく、データチェックサムオプションをチェックするかどうかを判断することができます。 DCCP Aは必須「チェンジR（データチェックサム、1を確認してください）」データチェックサムオプションを確認することを要求するDCCP Bにオプションを（それができない場合は、接続がリセットされます）を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Check Data Checksum has feature number 9 and is server-priority. It takes one-byte Boolean values. DCCP B MUST check any received Data Checksum options when Check Data Checksum/B is one, although it MAY check them even when Check Data Checksum/B is zero. Values of two or more are reserved. New connections start with Check Data Checksum 0 for both endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チェックデータチェックサムは、機能番号9を持ち、サーバーの優先順位です。これは、1バイトのブール値をとります。 DCCP Bは、いずれかをチェックしなければならないデータのチェックサム/ Bをチェックしたときに、データチェックサムオプションを受け取ったことは、データチェックサム/ Bがゼロで確認しても、それらをチェックするかもしれないが、1です。二つ以上の値が予約されています。新しい接続は両方の終点のためのチェックデータのチェックサム0で始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.2. Checksum Usage Notes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.2. チェックサムの使用上の注意
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet links must normally apply strong integrity checks to the packets they transmit [RFC3828, RFC3819]. This is the default case when the DCCP header&#39;s Checksum Coverage value equals zero (full coverage). However, the DCCP Checksum Coverage value might not be zero. By setting partial Checksum Coverage, the application indicates that it can tolerate corruption in the unprotected part of the application data. Recognizing this, link layers may reduce error detection and/or correction strength when transmitting this unprotected part. This, in turn, can significantly increase the likelihood of the endpoint&#39;s receiving corrupt data; Data Checksum lets the receiver detect that corruption with very high probability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネットリンクは、通常、彼らは[RFC3828、RFC3819]送信パケットに強い整合性チェックを適用する必要があります。 DCCPヘッダーのチェックサム・カバレッジ値がゼロ（完全なカバレッジ）に等しいとき、これは、デフォルトのケースです。しかし、DCCPチェックサムカバー範囲の値がゼロではないかもしれません。部分的なチェックサム適用範囲を設定することにより、アプリケーションは、アプリケーションデータの保護されていない部分の破損に耐えることができることを示しています。この保護されていない部分を送信する場合、これを認識し、リンク層は、エラー検出及び/又は補正強度を低減することができます。これは、順番に、大幅にエンドポイントの受信データが破損する可能性を高めることができます。データチェックサムは、受信機が非常に高い確率でその破損を検出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each congestion control mechanism supported by DCCP is assigned a congestion control identifier, or CCID: a number from 0 to 255. During connection setup, and optionally thereafter, the endpoints negotiate their congestion control mechanisms by negotiating the values for their Congestion Control ID features. Congestion Control ID has feature number 1. The CCID/A value equals the CCID in use for the A-to-B half-connection. DCCP B sends a &#34;Change R(CCID, K)&#34; option to ask DCCP A to use CCID K for its data packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続のセットアップ時に0〜255の数、及び必要に応じてその後、エンドポイントは、その輻輳制御ID機能の値を交渉することによって、それらの輻輳制御機構をネゴシエート：DCCPによってサポートされる各輻輳制御機構は、輻輳制御識別子、またはCCIDが割り当てられます。輻輳制御IDは、機能番号1 CCID / Aの値はA対B半接続のための使用においてCCIDに等しいを有しています。 DCCP Bは、そのデータパケットのためにCCID Kを使用するようにDCCP Aを依頼する &#34;の変更R（CCID、K）&#34; オプションを送ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID is a server-priority feature, so CCID negotiation options can list multiple acceptable CCIDs, sorted in descending order of priority. For example, the option &#34;Change R(CCID, 2 3 4)&#34; asks the receiver to use CCID 2 for its packets, although CCIDs 3 and 4 are also acceptable. (This corresponds to the bytes &#34;35, 6, 1, 2, 3, 4&#34;: Change R option (35), option length (6), feature ID (1), CCIDs (2, 3, 4).) Similarly, &#34;Confirm L(CCID, 2, 2 3 4)&#34; tells the receiver that the sender is using CCID 2 for its packets, but that CCIDs 3 and 4 might also be acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID交渉オプションは、優先度の高い順にソート複数の許容のCCIDsを、一覧表示することができますので、CCIDは、サーバー優先順位の機能です。 CCIDs 3及び4も許容可能であるが、例えば、オプション「変更R（CCID、2 3 4）」は、そのパケットのためにCCID 2を使用する受信機に要求します。 （これは、バイトに対応する &#34;35、6、1、2、3、4&#34;：変更Rオプション（35）、オプションの長さ（6）、特徴ID（1）のCCIDs（2、3、4）。）同様、「L（CCID、2、2 3 4）を確認」送信者は、そのパケットのためCCID 2を使用していることを受信機に通知し、しかしのCCIDs 3及び4も許容されるかもしれないこと。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Currently allocated CCIDs are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように現在割り当てられているのCCIDsは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           CCID   Meaning                      Reference
           ----   -------                      ---------
            0-1   Reserved
             2    TCP-like Congestion Control  [RFC4341]
             3    TCP-Friendly Rate Control    [RFC4342]
           4-255  Reserved
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Table 5: DCCP Congestion Control Identifiers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
表5：DCCP輻輳制御識別子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New connections start with CCID 2 for both endpoints. If this is unacceptable for a DCCP endpoint, that endpoint MUST send Mandatory Change(CCID) options on its first packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい接続は両方の終点のためにCCID 2で始まります。これはDCCP終点のために許容できない場合、そのエンドポイントは、その最初のパケット上で必須の変更（CCID）オプションを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All CCIDs standardized for use with DCCP will correspond to congestion control mechanisms previously standardized by the IETF. We expect that for quite some time, all such mechanisms will be TCP friendly, but TCP-friendliness is not an explicit DCCP requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPで使用するために標準化され、すべてのCCIDsは、以前にIETFによって標準化された輻輳制御メカニズムに対応することになります。私たちは、かなりの時間のために、すべてのそのようなメカニズムは、TCPフレンドリーになることを期待していますが、TCPフレンドリーには、明示的なDCCP要件ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP implementation intended for general use, such as an implementation in a general-purpose operating system kernel, SHOULD implement at least CCID 2. The intent is to make CCID 2 broadly available for interoperability, although particular applications might disallow its use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような汎用オペレーティングシステムカーネルに実装として一般的な使用のために意図DCCP実装は、少なくともCCID 2を実装する必要が意図は、特定のアプリケーションがその使用を許可しないかもしれないが、相互運用性のためにCCID 2は、広く利用できるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. TCP-like Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1.  TCPのような輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 2, TCP-like Congestion Control, denotes Additive Increase, Multiplicative Decrease (AIMD) congestion control with behavior modelled directly on TCP, including congestion window, slow start, timeouts, and so forth [RFC2581]. CCID 2 achieves maximum bandwidth over the long term, consistent with the use of end-to-end congestion control, but halves its congestion window in response to each congestion event. This leads to the abrupt rate changes typical of TCP. Applications should use CCID 2 if they prefer maximum bandwidth utilization to steadiness of rate. This is often the case for applications that are not playing their data directly to the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 2、TCPのような輻輳制御は、輻輳ウィンドウ、スロースタート、タイムアウト、等[RFC2581]を含むTCPに直接モデル化挙動を有する添加増加、乗算減少（AIMD）輻輳制御を表します。 CCID 2は、エンドツーエンドの輻輳制御の使用と一致して、長期にわたって最大帯域幅を達成するが、各輻輳イベントに応答して輻輳ウィンドウを半分。これは、TCPの典型的な突然のレート変化をもたらします。彼らは率の堅実に最大帯域幅の利用を好む場合アプリケーションは、CCID 2を使用する必要があります。これは、多くの場合、ユーザーに直接自分のデータを再生していないアプリケーションの場合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, a hypothetical application that transferred files over DCCP, using application-level retransmissions for lost packets, would prefer CCID 2 to CCID 3. On-line games may also prefer CCID 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、失われたパケットのためのアプリケーションレベルの再送信を使用して、DCCPの上にファイルを転送する仮想的なアプリケーションは、オンラインゲームはまた、CCID 2を好むことがCCID 3にCCID 2を好むだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 2 is further described in [RFC4341].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 2は、さらに、[RFC4341]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. TFRC Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2.  TFRC輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 3 denotes TCP-Friendly Rate Control (TFRC), an equation-based rate-controlled congestion control mechanism. TFRC is designed to be reasonably fair when competing for bandwidth with TCP-like flows, where a flow is &#34;reasonably fair&#34; if its sending rate is generally within a factor of two of the sending rate of a TCP flow under the same conditions. However, TFRC has a much lower variation of throughput over time compared with TCP, which makes CCID 3 more suitable than CCID 2 for applications such as streaming media where a relatively smooth sending rate is important.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 3は、TCPフレンドリーレート制御（TFRC）、方程式ベースのレート制御輻輳制御機構です。 TFRCは、その送信レートが同じ条件の下でTCPフローの送信レートの2倍以内であれば、一般的にフローが「合理的公正」である場合には、TCPのようなフローに帯域幅を競合するとき、合理的に公平であるように設計されています。しかし、TFRCは、比較的滑らかな送信速度が重要であるストリーミングメディアなどのアプリケーションのためにCCID 2よりCCID 3がより適してTCPと比べ経時スループットのはるかに低い変動を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 3 is further described in [RFC4342]. The TFRC congestion control algorithms were initially described in [RFC3448].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 3は、[RFC4342]に記載されています。 TFRC輻輳制御アルゴリズムは、最初に[RFC3448]で説明しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. CCID-Specific Options, Features, and Reset Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3.  CCID特有のオプション、機能、およびコードをリセット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Half of the option types, feature numbers, and Reset Codes are reserved for CCID-specific use. CCIDs may often need new options, for communicating acknowledgement or rate information, for example; reserved option spaces let CCIDs create options at will without polluting the global option space. Option 128 might have different meanings on a half-connection using CCID 4 and a half-connection using CCID 8. CCID-specific options and features will never conflict with global options and features introduced by later versions of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションの種類の半分、機能番号、およびコードをリセットは、CCID特有の使用のために予約されています。 CCIDsは、多くの場合、例えば、承認またはレート情報を通信するための、新しいオプションが必要な場合があります。予約オプションスペースはのCCIDsがグローバルオプション空間を汚染することなく、意志のオプションを作成してみましょう。オプション128は、CCID 4使って半接続、この仕様の後のバージョンで導入された世界的なオプションと機能と競合することはありませんCCID 8 CCID特有のオプションおよび機能を使用して、半接続で異なる意味を持っているかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any packet may contain information meant for either half-connection, so CCID-specific option types, feature numbers, and Reset Codes explicitly signal the half-connection to which they apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID特有のオプションの種類、機能番号、およびコードをリセットを明示的に彼らが適用される半接続を知らせるように、任意のパケットは、半接続のいずれかのために意味の情報が含まれていてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Option numbers 128 through 191 are for options sent from the HC-Sender to the HC-Receiver; option numbers 192 through 255 are for options sent from the HC-Receiver to the HC-Sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプション番号128 O 191を介してHC-ReceiverにHC-送信者から送られたオプションのためのものです。オプション番号192〜255はHC-SenderへのHC-レシーバから送信されたオプションのためのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Reset Codes 128 through 191 indicate that the HC-Sender reset the connection (most likely because of some problem with acknowledgements sent by the HC-Receiver). Reset Codes 192 through 255 indicate that the HC-Receiver reset the connection (most likely because of some problem with data packets sent by the HC-Sender).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 191を通じてコード128をリセットHC-Senderが（理由はHC-Receiverが送られた確認応答といくつかの問題の最も可能性の高い）接続をリセットすることを示しています。リセットコードは255 192は、HC-レシーバが（理由はHC-送信者によって送信されたデータパケットを持ついくつかの問題の最も可能性が高い）接続をリセットすることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Finally, feature numbers 128 through 191 are used for features located at the HC-Sender; feature numbers 192 through 255 are for features located at the HC-Receiver. Since Change L and Confirm L options for a feature are sent by the feature location, we know that any Change L(128) option was sent by the HC-Sender, while any Change L(192) option was sent by the HC-Receiver. Similarly, Change R(128) options are sent by the HC-Receiver, while Change R(192) options are sent by the HC-Sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O最後に、機能番号128 191を介しては、HC-センダに位置する機能のために使用されます。 255 192機能番号は、HC-レシーバに位置機能のためのものです。機能の変更LおよびConfirm Lオプションは特徴位置によって送信されますので任意の変更Lは、（192）オプションはHC-Receiverが送られたが、我々は、任意の変更Lは、（128）オプションはHC-送信者によって送信されたことを知っています。変更R（192）オプションはHC-送信者によって送信されつつ同様に、変更R（128）オプションは、HC-受信機によって送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider a DCCP connection where the A-to-B half-connection uses CCID 4 and the B-to-A half-connection uses CCID 5. Here is how a sampling of CCID-specific options are assigned to half-connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A対B半接続CCID 4を使用し、B-に半接続ここCCID 5を使用するCCID特有のオプションのサンプリングは、半接続に割り当てる方法であり、例えば、DCCP接続を検討。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                   Relevant    Relevant
        Packet  Option             Half-conn.  CCID
        ------  ------             ----------  ----
        A &gt; B   128                  A-to-B     4
        A &gt; B   192                  B-to-A     5
        A &gt; B   Change L(128, ...)   A-to-B     4
        A &gt; B   Change R(192, ...)   A-to-B     4
        A &gt; B   Confirm L(128, ...)  A-to-B     4
        A &gt; B   Confirm R(192, ...)  A-to-B     4
        A &gt; B   Change R(128, ...)   B-to-A     5
        A &gt; B   Change L(192, ...)   B-to-A     5
        A &gt; B   Confirm R(128, ...)  B-to-A     5
        A &gt; B   Confirm L(192, ...)  B-to-A     5
        B &gt; A   128                  B-to-A     5
        B &gt; A   192                  A-to-B     4
        B &gt; A   Change L(128, ...)   B-to-A     5
        B &gt; A   Change R(192, ...)   B-to-A     5
        B &gt; A   Confirm L(128, ...)  B-to-A     5
        B &gt; A   Confirm R(192, ...)  B-to-A     5
        B &gt; A   Change R(128, ...)   A-to-B     4
        B &gt; A   Change L(192, ...)   A-to-B     4
        B &gt; A   Confirm R(128, ...)  A-to-B     4
        B &gt; A   Confirm L(192, ...)  A-to-B     4
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using CCID-specific options and feature options during a negotiation for the corresponding CCID feature is NOT RECOMMENDED, since it is difficult to predict which CCID will be in force when the option is processed. For example, if a DCCP-Request contains the option sequence &#34;Change L(CCID, 3), 128&#34;, the CCID-specific option &#34;128&#34; may be processed either by CCID 3 (if the server supports CCID 3) or by the default CCID 2 (if it does not). However, it is safe to include CCID-specific options following certain Mandatory Change(CCID) options. For example, if a DCCP-Request contains the option sequence &#34;Mandatory, Change L(CCID, 3), 128&#34;, then either the &#34;128&#34; option will be processed by CCID 3 or the connection will be reset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションが処理されるときCCIDが力になるかを予測することが困難であるため、対応するCCID機能のネゴシエーション中にCCID特有のオプションと機能オプションを使用すると、お勧めしません。 DCCP-要求はオプション配列が含まれている場合、例えば、「変更L（CCIDを、3）、128」、CCID固有のオプション「128」（サーバがCCID 3をサポートしている場合）またはCCID 3のいずれかによって処理されてもよいですデフォルトCCID 2（そうでない場合）。しかし、特定の必須の変更（CCID）オプションは以下のCCID特有のオプションが含まれるように安全です。例えば、DCCPリクエスト「は必須、変更L（CCID、3）、128は」オプション配列は、いずれかの「128」オプションはCCID 3によって処理されるか、または接続がリセットされますが含まれている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that do not implement the default CCID 2 might nevertheless receive CCID 2-specific options on a DCCP-Request packet. (Such a server MUST send Mandatory Change(CCID) options on its DCCP-Response, so CCID-specific options on any other packet won&#39;t refer to CCID 2.) The server MUST treat such options as non-understood. Thus, it will reset the connection on encountering a Mandatory CCID-specific option or feature negotiation request, send an empty Confirm for a non-Mandatory Change option for a CCID-specific feature, and ignore other CCID-specific options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCID 2デフォルトを実装していないサーバは、それにもかかわらず、DCCP-RequestパケットにCCID 2固有のオプションを受け取ることがあります。非分かるように、サーバーは、そのようなオプションを扱わなければなりません（他のパケットにCCID特有のオプションは、CCID 2を参照していますので、そのようなサーバは、そのDCCP-応答に必須の変更（CCID）オプションを送らなければなりません）。したがって、それは、必須CCID特有のオプションや機能交渉要求に遭遇した上で接続をリセットCCID特有の機能の非必須の変更オプションの空の確認を送信し、他のCCID特有のオプションを無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. CCID Profile Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4.  CCIDプロフィールの要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each CCID Profile document MUST address at least the following requirements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各CCIDプロフィール文書には、少なくとも以下の要件に対処しなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The profile MUST include the name and number of the CCID being described.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルoを記載されているCCIDの名前と番号を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The profile MUST describe the conditions in which it is likely to be useful. Often the best way to do this is by comparison to existing CCIDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oプロファイルは、有用である可能性が高いである状態を説明しなければなりません。多くの場合、これを行うための最善の方法は、既存のCCIDsとの比較です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The profile MUST list and describe any CCID-specific options, features, and Reset Codes and SHOULD list those general options and features described in this document that are especially relevant to the CCID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルMUSTリストoおよび任意CCID特有のオプション、機能について説明し、コードをリセットし、CCIDに特に関連するこの文書に記載されているものの一般的なオプションと機能をリストする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any newly defined acknowledgement mechanism MUST include a way to transmit ECN Nonce Echoes back to the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O新しく定義された確認応答機構は、送信者の電子証券取引ネットワークNonceのエコーを送信する方法を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The profile MUST describe the format of data packets, including any options that should be included and the setting of the CCval header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oプロファイルが含まれるべきである任意のオプションとCCvalヘッダフィールドの設定を含む、データパケットのフォーマットを記述しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The profile MUST describe the format of acknowledgement packets, including any options that should be included.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oプロファイルが含まれるべきである任意のオプションを含む肯定応答パケットのフォーマットを記述しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The profile MUST define how data packets are congestion controlled. This includes responses to congestion events, to idle and application-limited periods, and to the DCCP Data Dropped and Slow Receiver options. CCIDs that implement per-packet congestion control SHOULD discuss how packet size is factored in to congestion control decisions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oプロファイルは、データパケットが輻輳制御方法を定義しなければなりません。これは、渋滞のイベントへの応答、アイドル状態にすると、アプリケーションが制限された期間を含み、およびDCCPデータに低下し、スローレシーバーオプション。パケットごとの輻輳制御を実装するのCCIDsは、パケットサイズが輻輳制御の決定に加味される方法を議論する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The profile MUST specify when acknowledgement packets are generated and how they are congestion controlled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認応答パケットが生成されるとき、プロファイルは指定しなければならないOおよびそれらがどのように輻輳制御されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The profile MUST define when a sender using the CCID is considered quiescent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CCIDを使用して、送信者が静止考慮すると、Oプロファイルが定義しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The profile MUST say whether its CCID&#39;s acknowledgements ever need to be acknowledged and, if so, how often.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oプロファイルは、そのCCIDの謝辞が今までそうであれば、どのくらいの頻度、承認される必要があるかどうか言わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. Congestion State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. 輻輳状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most congestion control algorithms depend on past history to determine the current allowed sending rate. In CCID 2, this congestion state includes a congestion window and a measurement of the number of packets outstanding in the network; in CCID 3, it includes the lengths of recent loss intervals. Both CCIDs use an estimate of the round-trip time. Congestion state depends on the network path and is invalidated by path changes. Therefore, DCCP senders and receivers SHOULD reset their congestion state -- essentially restarting congestion control from &#34;slow start&#34; or equivalent -- on significant changes in the end-to-end path. For example, an endpoint that sends or receives a Mobile IPv6 Binding Update message [RFC3775] SHOULD reset its congestion state for any corresponding DCCP connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの輻輳制御アルゴリズムは、現在許可され、送信レートを決定するために過去の歴史に依存しています。 CCID 2において、この輻輳状態は、輻輳ウィンドウと、ネットワーク内の未処理パケットの数の測定を含みます。 CCID 3で、それは最近の損失間隔の長さを含んでいます。どちらのCCIDsは、ラウンドトリップ時間の推定値を使用します。輻輳状態は、ネットワーク経路に依存し、パスの変更によって無効化されます。したがって、DCCP送信側と受信側は、その輻輳状態をリセットする必要 - 本質的に「スロースタート」または同等の輻輳制御を再開 - エンドツーエンドパスの有意な変化に。例えば、モバイルIPv6バインディング更新メッセージ[RFC3775]を送信または受信したエンドポイントは、任意の対応するDCCP接続のために、その輻輳状態をリセットする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP implementation MAY also reset its congestion state when a CCID changes (that is, when a negotiation for the CCID feature completes successfully and the new feature value differs from the old value). Thus, a connection in a heavily congested environment might evade end-to-end congestion control by frequently renegotiating a CCID, just as it could evade end-to-end congestion control by opening new connections for the same session. This behavior is prohibited. To prevent it, DCCP implementations MAY limit the rate at which CCID can be changed -- for instance, by refusing to change a CCID feature value more than once per minute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPの実装はまた、その輻輳状態をリセットされる場合がありCCIDの変更（CCID機能のネゴシエーションが正常に完了し、新しい機能の値が古い値と異なるときには、あります）。このように、非常に輻輳環境での接続は、同じセッションのために新しい接続を開くことによって、エンドツーエンドの輻輳制御を回避することができ同じように、頻繁にCCIDを再交渉することにより、エンドツーエンドの輻輳制御を回避することがあります。この動作は禁止されています。それを防ぐために、DCCP実装は、CCIDを変えることができる速度を制限するかもしれない - 例えば、1分に1回以上CCIDの特徴量を変更することを拒否することによって。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion control requires that receivers transmit information about packet losses and ECN marks to senders. DCCP receivers MUST report all congestion they see, as defined by the relevant CCID profile. Each CCID says when acknowledgements should be sent, what options they must use, and so on. DCCP acknowledgements are congestion controlled, although it is not required that the acknowledgement stream be more than very roughly TCP friendly; each CCID defines how acknowledgements are congestion controlled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳制御は、受信機が送信者にパケットロスやECNマークに関する情報を送信することが必要です。関連CCIDプロファイルで定義されたDCCP受信機は、彼らが見るすべての混雑を報告しなければなりません。各CCIDは、確認応答を送信する必要がある場合、どのようなオプション彼らはように使用し、しなければならないと言います。承認の流れが非常に大まかTCPフレンドリー以上である必要はないが、DCCPの承認は、輻輳制御されています。各CCIDは、確認応答が輻輳を制御する方法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most acknowledgements use DCCP options. For example, on a half-connection with CCID 2 (TCP-like), the receiver reports acknowledgement information using the Ack Vector option. This section describes common acknowledgement options and shows how acks using those options will commonly work. Full descriptions of the ack mechanisms used for each CCID are laid out in the CCID profile specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの承認はDCCPオプションを使用しています。例えば、CCID 2（TCPのような）との半接続で、受信機は、ACKベクトルオプションを使用して送達確認情報をレポートします。このセクションでは、一般的な確認応答オプションについて説明し、それらのオプションを使用してACKが、一般的に動作する方法を示しています。各CCIDに使用されるACKメカニズムの完全な説明はCCIDプロフィール仕様に配置されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Acknowledgement options, such as Ack Vector, depend on the DCCP Acknowledgement Number and are thus only allowed on packet types that carry that number. Acknowledgement options received on other packet types, namely DCCP-Request and DCCP-Data, MUST be ignored. Detailed acknowledgement options are not necessarily required on every packet that carries an Acknowledgement Number, however.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような肯定応答ベクトルとして肯定応答オプションは、DCCP確認応答数に依存し、したがってのみその数を運ぶパケットタイプで許可されています。他のパケットタイプ、すなわち、DCCP-要求とDCCP-Dataを受信確認応答のオプションは、無視しなければなりません。詳細な確認応答オプションは、必ずしもしかし、確認応答番号を運ぶすべてのパケットには必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Acks of Acks and Unidirectional Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.  ACKおよび単方向接続のACKを
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP was designed to work well for both bidirectional and unidirectional flows of data, and for connections that transition between these states. However, acknowledgements required for a unidirectional connection are very different from those required for a bidirectional connection. In particular, unidirectional connections need to worry about acks of acks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPはデータの双方向と単方向フローの両方のための、および、これらの状態間の遷移の接続のために働くように設計されました。しかし、一方向の接続に必要な確認応答が双方向の接続に必要なものとは非常に異なっています。具体的には、一方向の接続は、ACKのACKを心配する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ack-of-acks problem arises because some acknowledgement mechanisms are reliable. For example, an HC-Receiver using CCID 2, TCP-like Congestion Control, sends Ack Vectors containing completely reliable acknowledgement information. The HC-Sender should occasionally inform the HC-Receiver that it has received an ack. If it did not, the HC-Receiver might resend complete Ack Vector information, going back to the start of the connection, with every DCCP-Ack packet! However, note that acks-of-acks need not be reliable themselves: when an ack-of-acks is lost, the HC-Receiver will simply maintain, and periodically retransmit, old acknowledgement-related state for a little longer. Therefore, there is no need for acks-of-acks-of-acks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの承認メカニズムが信頼性があるため、ACK-の-ACKの問題が発生します。例えば、CCID 2、TCPのような輻輳制御を使用して、HC-Receiverは、完全に信頼できる送達確認情報を含む肯定応答ベクトルを送信します。 HC-送信者は時折、それはACKを受信したことをHC-Receiverを通知する必要があります。それがなかった場合は、HC-レシーバは、すべてのDCCP-Ackパケットで、接続の開始に戻って、完全なのAckベクトル情報を再送するかもしれません！ ACK-の-のACKが失われたとき、HC-レシーバは、単に少し長く維持し、定期的に再送信し、古い承認関連の状態になります。しかし、それはACKを-の-ACKが自分自身の信頼性である必要はない注意してください。したがって、ACKを-の-のACK-の-ACKのための必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When communication is bidirectional, any required acks-of-acks are automatically contained in normal acknowledgements for data packets. On a unidirectional connection, however, the receiver DCCP sends no data, so the sender would not normally send acknowledgements. Therefore, the CCID in force on that half-connection must explicitly say whether, when, and how the HC-Sender should generate acks-of-acks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信が双方向である場合、必要なのACK-ACKのは、自動的にデータ・パケットの通常肯定応答に含まれています。一方向の接続では、しかし、受信機DCCPはデータを送信しないので、送信者は、通常、確認応答を送信しません。したがって、その半分接続で力のCCIDは、明示的にHC-SenderはACKの-の-ACKを生成するかどうか、いつ、どのように言わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider a bidirectional connection where both half-connections use the same CCID (either 2 or 3), and where DCCP B goes &#34;quiescent&#34;. This means that the connection becomes unidirectional:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、半接続の両方が同じCCID（2または3）を使用した双方向の接続を考慮し、ここで、DCCP Bは、「静止」になります。これは、接続が単方向になっていることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP B stops sending data and sends only DCCP-Ack packets to DCCP A. In CCID 2, TCP-like Congestion Control, DCCP B uses Ack Vector to reliably communicate which packets it has received. As described above, DCCP A must occasionally acknowledge a pure acknowledgement from DCCP B so that B can free old Ack Vector state. For instance, A might send a DCCP-DataAck packet instead of DCCP-Data every now and then. In CCID 3, however, acknowledgement state is generally bounded, so A does not need to acknowledge B&#39;s acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP Bはデータ送信を停止し、CCID 2でDCCP AにのみDCCP-ACKパケットを送信し、TCPのような輻輳制御は、DCCP Bは確実それが受信したパケットた通信にACKベクトルを使用します。前述したようにBが古いのAckベクトル状態を解放することができるように、DCCP Aは時折DCCP Bから純粋な承認を確認する必要があります。例えば、Aは、すべての今して代わりにDCCP-データのDCCP-DataAckパケットを送信することがあります。 CCID 3では、しかし、確認応答状態は、一般的に囲まれているので、AはBの確認応答を確認する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When communication is unidirectional, a single CCID -- in the example, the A-to-B CCID -- controls both DCCPs&#39; acknowledgements, in terms of their content, their frequency, and so forth. For bidirectional connections, the A-to-B CCID governs DCCP B&#39;s acknowledgements (including its acks of DCCP A&#39;s acks) and the B-to-A CCID governs DCCP A&#39;s acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信が一方向である、単一CCID  - 例では、A対B CCID  - などのコントロールの両方DCCPs&#39;肯定応答、それらの内容の点で、それらの周波数、および。双方向接続のために、A対B CCIDは（DCCP AのACKのそのACKを含む）DCCP Bの確認応答を支配し、BツーCCIDはDCCP Aの確認応答を支配します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP A switches its ack pattern from bidirectional to unidirectional when it notices that DCCP B has gone quiescent. It switches from unidirectional to bidirectional when it must acknowledge even a single DCCP-Data or DCCP-DataAck packet from DCCP B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP Aは、DCCP Bが休止になったことに気づくときに一方向で双方向からのACKパターンを切り替えます。それはDCCP Bから1つでもDCCP-データやDCCP-DataAckパケットを確認しなければならない場合には、単方向から双方向に切り替え
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each CCID defines how to detect quiescence on that CCID, and how that CCID handles acks-of-acks on unidirectional connections. The B-to-A CCID defines when DCCP B has gone quiescent. Usually, this happens when a period has passed without B sending any data packets; in CCID 2, for example, this period is the maximum of 0.2 seconds and two round-trip times. The A-to-B CCID defines how DCCP A handles acks-of-acks once DCCP B has gone quiescent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各CCIDは、CCIDに休止を検出する方法を定義し、そのCCIDは一方向の接続でのACK-の-ACKをどのように処理しますか。 DCCP Bが休止になったときにBツーCCIDを定義します。期間はBは、任意のデータ・パケットを送信せずに経過したとき通常、これは起こります。 CCID 2において、例えば、この期間は0.2秒と2往復時間の最大値です。 A・ツー・B CCIDはDCCP Bが静止行った後DCCP AはACKを-の-ACKをどのように処理するかを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Ack Piggybacking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.  Ackをピギーバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Acknowledgements of A-to-B data MAY be piggybacked on data sent by DCCP B, as long as that does not delay the acknowledgement longer than the A-to-B CCID would find acceptable. However, data acknowledgements often require more than 4 bytes to express. A large set of acknowledgements prepended to a large data packet might exceed the allowed maximum packet size. In this case, DCCP B SHOULD send separate DCCP-Data and DCCP-Ack packets, or wait, but not too long, for a smaller datagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A-に-Bデータの謝辞は限りそれは長いA-に-B CCIDが許容見つけることよりも、確認応答を遅らせることはありませんので、DCCP Bによって送信されたデータにピギーバックされるかもしれません。しかし、データの確認応答は、多くの場合、表現するために4バイト以上が必要です。大きなデータパケットの前に付加肯定応答の大規模なセットは、許容される最大パケットサイズを超える場合があります。この場合、DCCP Bは小さなデータグラムのために、長すぎる別のDCCP-データとDCCP-Ackのパケットを送信し、または待って、しかしべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Piggybacking is particularly common at DCCP A when the B-to-A half-connection is quiescent -- that is, when DCCP A is just acknowledging DCCP B&#39;s acknowledgements. There are three reasons to acknowledge DCCP B&#39;s acknowledgements: to allow DCCP B to free up information about previously acknowledged data packets from A; to shrink the size of future acknowledgements; and to manipulate the rate at which future acknowledgements are sent. Since these are secondary concerns, DCCP A can generally afford to wait indefinitely for a data packet to piggyback its acknowledgement onto; if DCCP B wants to elicit an acknowledgement, it can send a DCCP-Sync.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
つまり、DCCP AはちょうどDCCP Bの確認応答を認めているとき -  B-に半接続が静止しているとき、便乗はDCCP Aで特に一般的です。 DCCP Bの確認応答を確認するには、3つの理由があります：DCCP BはAからの応答済みのデータパケットに関する情報を解放できるようにするには、将来の確認応答のサイズを縮小します。そして将来の確認応答が送信されるレートを操作します。これらは、二次問題であるので、DCCP Aは、一般に、その確認応答をピギーバックするためのデータパケットを無期限に待機する余裕ができます。 DCCP Bは、確認応答を惹起したい場合、それはDCCP-Syncを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any restrictions on ack piggybacking are described in the relevant CCID&#39;s profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACKのピギーバック上の任意の制限は、関連CCIDのプロフィールに記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. Ack Ratio Feature
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.  Ack比フィーチャ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Ack Ratio feature lets HC-Senders influence the rate at which HC-Receivers generate DCCP-Ack packets, thus controlling reverse-path congestion. This differs from TCP, which presently has no congestion control for pure acknowledgement traffic. Ack Ratio reverse-path congestion control does not try to be TCP friendly. It just tries to avoid congestion collapse, and to be somewhat better than TCP in the presence of a high packet loss or mark rate on the reverse path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ack比フィーチャは、HC-送信者は、このようにリバースパス輻輳を制御する、HC-受信機がDCCP-ACKパケットを生成する速度に影響を与えることができます。これは現在、純粋な承認トラフィックの輻輳制御を持っていないTCPとは異なります。 Ack比リバースパス輻輳制御はTCPフレンドリーになろうとしません。それはちょうど混雑崩壊を避けるために、高いパケット損失の存在下でのTCPよりも幾分良好であるか、または逆の経路上の率をマークしようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ack Ratio applies to CCIDs whose HC-Receivers clock acknowledgements off the receipt of data packets. The value of Ack Ratio/A equals the rough ratio of data packets sent by DCCP A to DCCP-Ack packets sent by DCCP B. Higher Ack Ratios correspond to lower DCCP-Ack rates; the sender raises Ack Ratio when the reverse path is congested and lowers Ack Ratio when it is not. Each CCID profile defines how it controls congestion on the acknowledgement path, and, particularly, whether Ack Ratio is used. CCID 2, for example, uses Ack Ratio for acknowledgement congestion control, but CCID 3 does not. However, each Ack Ratio feature has a value whether or not that value is used by the relevant CCID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ack比は、そのHC-レシーバのクロックデータパケットの受信をオフに謝辞のCCIDsに適用されます。肯定応答率/ Aの値がDCCP-Ackの速度を低下させるために対応するDCCP B.高いのAck比によって送信されたDCCP-ACKパケットにDCCP Aによって送られたデータパケットの大まかな比に等しいです。送信者は、リバースパスが混雑しているときのAck比率を上昇させ、それがないときのAck比を低下させます。各CCIDプロフィールは、ACK比率が使用されているかどうか、特に、それは肯定応答経路上の輻輳を制御する方法を定義し、そして。 CCID 2は、例えば、確認応答輻輳制御のためのACK比を使用するが、CCID 3がありません。しかし、それぞれのAck比フィーチャは、その値が関連CCIDによって使用されているか否かの値を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ack Ratio has feature number 5 and is non-negotiable. It takes two-byte integer values. An Ack Ratio/A value of four means that DCCP B will send at least one acknowledgement packet for every four data packets sent by DCCP A. DCCP A sends a &#34;Change L(Ack Ratio)&#34; option to notify DCCP B of its ack ratio. An Ack Ratio value of zero indicates that the relevant half-connection does not use an Ack Ratio to control its acknowledgement rate. New connections start with Ack Ratio 2 for both endpoints; this Ack Ratio results in acknowledgement behavior analogous to TCP&#39;s delayed acks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ack比率は、フィーチャー番号5を持ち、非交渉です。これは、2バイトの整数値をとります。肯定応答率/ DCCP BはDCCP A. DCCP Aによって送られたすべての4つのデータ・パケットのための少なくとも一つの肯定応答パケットを送信する4つの手段の値は、そのACK比DCCP Bに通知するために「変更L（のAck比）」オプションを送ります。ゼロの肯定応答比の値は、関連する半接続は、その確認応答速度を制御するためのAck比を使用していないことを示しています。新しい接続は、両方のエンドポイント用のAck比2で始まります。このTCPの遅延ACKに似確認行動でのAck比結果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ack Ratio should be treated as a guideline rather than a strict requirement. We intend Ack Ratio-controlled acknowledgement behavior to resemble TCP&#39;s acknowledgement behavior when there is no reverse-path congestion, and to be somewhat more conservative when there is reverse-path congestion. Following this intent is more important than implementing Ack Ratio precisely. In particular: o Receivers MAY piggyback acknowledgement information on data packets, creating DCCP-DataAck packets. The Ack Ratio does not apply to piggybacked acknowledgements. However, if the data packets are too big to carry acknowledgement information, or if the data sending rate is lower than Ack Ratio would suggest, then DCCP B SHOULD send enough pure DCCP-Ack packets to maintain the rate of one acknowledgement per Ack Ratio received data packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACK比はガイドラインではなく、厳密な要件として扱われるべきです。私たちは何のリバースパス輻輳がない場合TCPの確認応答動作に似ているし、逆パスを輻輳があるときやや保守的にACK比制御の確認動作を意図しています。この意図を正確に続いてのAck比を実装するよりも重要です。特に：レシーバO DCCP-DataAckパケットを作成、データパケットに関する確認情報をピギーバックするかもしれません。 Ack比は、確認応答をピギーバックには適用されません。データパケットが送達確認情報を運ぶことが大きすぎる場合は、データ送信レートがACK比率が示唆しているよりも低い場合には、あるいは、その後、DCCP Bは、受信したACK比ごとに確認応答のレートを維持するために十分な純粋なDCCP-ACKパケットを送信すべきですデータパケット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Receivers MAY rate-pace their acknowledgements rather than send acknowledgements immediately upon the receipt of data packets. Receivers that rate-pace acknowledgements SHOULD pick a rate that approximates the effect of Ack Ratio and SHOULD include Elapsed Time options (Section 13.2) to help the sender calculate round-trip times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oレシーバは、その確認応答を評価ペースではなく、データパケットの受信時にすぐに確認応答を送信することができます。レートペースの確認応答がACK比の影響を近似し、送信者が往復時間を計算するのに役立つ経過時間オプション（13.2節）を含むべきである率を選ぶべきであることをレシーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Receivers SHOULD implement delayed acknowledgement timers like TCP&#39;s, whereby any packet&#39;s acknowledgement is delayed by at most T seconds. This delay lets the receiver collect additional packets to acknowledge and thus reduce the per-packet overhead of acknowledgements; but if T seconds have passed by and the ack is still around, it is sent out right away. The default value of T should be 0.2 seconds, as is common in TCP implementations. This may lead to sending more acknowledgement packets than Ack Ratio would suggest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OレシーバはTCPの、任意のパケットの確認応答が最もT秒で遅れで表示させるような遅延確認応答タイマを実装する必要があります。この遅延は、受信機が認めるので、確認応答のパケットごとのオーバーヘッドを減らすために、追加のパケットを収集することができます。 T秒がで合格したとACKがまだ残っている場合は、それがすぐに送信されます。 TCP実装で一般的であるようにTのデフォルト値は、0.2秒であるべきです。これは、ACK比率が示唆しているよりも多くの確認応答パケットを送信することにつながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Receivers SHOULD send acknowledgements immediately on receiving packets marked ECN Congestion Experienced or packets whose out-of-order sequence numbers potentially indicate loss. However, there is no need to send such immediate acknowledgements for marked packets more than once per round-trip time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oレシーバは、パケットを受信すると、すぐに確認応答を送信すべきであるECNの輻輳に遭遇したか、そのアウトオブオーダーシーケンス番号の潜在的損失を示すパケットをマーク。しかし、ラウンドトリップ時間ごとに複数回マークされたパケットのために、このような即時の確認応答を送信する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Receivers MAY ignore Ack Ratio if they perform their own congestion control on acknowledgements. For example, a receiver that knows the loss and mark rate for its DCCP-Ack packets might maintain a TCP-friendly acknowledgement rate on its own. Such a receiver MUST either ensure that it always obtains sufficient acknowledgement loss and mark information or fall back to Ack Ratio when sufficient information is not available, as might happen during periods when the receiver is quiescent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らは謝辞に、独自の輻輳制御を行う場合には、O受信機は、ACK比率を無視してもよいです。例えば、そのDCCP-ACKパケットのための損失とマーク率を知っている受信機は、独自のTCPフレンドリー承認率を維持することがあります。このような受信機は、それが必ずしも十分確認の損失やマーク情報を取得していることを確認したり、受信機が静止しているときの期間中に発生する可能性があるとして、十分な情報が、利用できない場合のAck比にフォールバックする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. Ack Vector Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4.  Ackベクトルオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Ack Vector gives a run-length encoded history of data packets received at the client. Each byte of the vector gives the state of that data packet in the loss history, and the number of preceding packets with the same state. The option&#39;s data looks like this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ack Vectorがクライアントで受信したデータパケットのランレングスエンコードされた歴史を与えます。ベクトルの各バイトは、損失の歴史の中で、そのデータパケットの状態と同じ状態を持つパケットの前の数を与えます。オプションのデータは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+--------+--------
   |0010011?| Length |SSLLLLLL|SSLLLLLL|SSLLLLLL|  ...
   +--------+--------+--------+--------+--------+--------
   Type=38/39         \___________ Vector ___________...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two Ack Vector options (option types 38 and 39) differ only in the values they imply for ECN Nonce Echo. Section 12.2 describes this further.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのAckベクトルオプション（オプションタイプ38及び39）のみ、彼らがECNノンスエコーを意味するものでは値が異なります。 12.2節は、これをさらに説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The vector itself consists of a series of bytes, each of whose encoding is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベクター自体が一連のバイトで構成され、その符号化の各々は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |Sta| Run Length|
   +-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sta[te] occupies the most significant two bits of each byte and can have one of four values, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにSTA [TE]は、各バイトの最上位の2ビットを占有し、4つの値のいずれかを有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    State  Meaning
                    -----  -------
                      0    Received
                      1    Received ECN Marked
                      2    Reserved
                      3    Not Yet Received
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Table 6: DCCP Ack Vector States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
表6：DCCPのAckベクトル州
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The term &#34;ECN marked&#34; refers to packets with ECN code point 11, CE (Congestion Experienced); packets received with this ECN code point MUST be reported using State 1, Received ECN Marked. Packets received with ECN code points 00, 01, or 10 (Non-ECT, ECT(0), or ECT(1), respectively) MUST be reported using State 0, Received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用語「ECNがマークされた」とは、ECNコードポイント11、CE（輻輳経験豊富な）を持つパケットを指します。このECNコードポイントで受信されたパケットは状態1を用いて報告されなければならない、ECNがマーク受付。 ECNコードで受信されたパケットは、00、01、または10ポイント（非ECT、ECT（0）、またはECT（1）、それぞれ）状態0、受信を使用して報告されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Run Length, the least significant six bits of each byte, specifies how many consecutive packets have the given State. Run Length zero says the corresponding State applies to one packet only; Run Length 63 says it applies to 64 consecutive packets. Run lengths of 65 or more must be encoded in multiple bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各バイトの最下位6ビット、長さを実行して、多くの連続したパケットが与えられた状態を持っているかを指定します。ランレングスゼロは、対応する状態は、一つのパケットのみに適用されると言います。ランレングス63は、64の連続したパケットに適用されると言います。 65以上のランレングスは、複数のバイトに符号化されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first byte in the first Ack Vector option refers to the packet indicated in the Acknowledgement Number; subsequent bytes refer to older packets. Ack Vector MUST NOT be sent on DCCP-Data and DCCP-Request packets, which lack an Acknowledgement Number, and any Ack Vector options encountered on such packets MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のAckベクトルオプションの最初のバイトは、肯定応答番号に示されたパケットを意味します。後続のバイトは、古いパケットを参照してください。 Ack VectorがDCCP-データに送信され、受信確認番号が不足しているDCCP-Requestパケット、及びそのようなパケットに発生したのAckベクトルオプションは無視されなければならないしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Ack Vector containing the decimal values 0,192,3,64,5 and for which the Acknowledgement Number is decimal 100 indicates that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
小数値0,192,3,64,5かつに対する肯定応答数が100小数であるを含むのAck Vectorがことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet 100 was received (Acknowledgement Number 100, State 0, Run Length 0);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット100は、（確認応答番号100、状態0、ランレングス0）を受けました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet 99 was lost (State 3, Run Length 0);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット99は、（状態3、ランレングス0）を失いました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packets 98, 97, 96 and 95 were received (State 0, Run Length 3);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット98、97、96及び95は、受信した（状態0、ランレングス3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet 94 was ECN marked (State 1, Run Length 0); and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット94は、ECNは、（状態1、ランレングス0）をマークしました。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packets 93, 92, 91, 90, 89, and 88 were received (State 0, Run Length 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット93、92、91、90、89、および88は、（状態0、ランレングス5）を受けました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single Ack Vector option can acknowledge up to 16192 data packets. Should more packets need to be acknowledged than can fit in 253 bytes of Ack Vector, then multiple Ack Vector options can be sent; the second Ack Vector begins where the first left off, and so forth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のAckベクトルオプションは、16192個のデータパケットまで認めることができます。より多くのパケットは、ACKベクトルの253バイトに収まることができるよりも、その後、複数のACKベクトルオプションを送信することができます承認される必要がある必要があります。最初等中断、及びここ第二のAckベクトルが始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ack Vector states are subject to two general constraints. (These principles SHOULD also be followed for other acknowledgement mechanisms; referring to Ack Vector states simplifies their explanation.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ackベクトル状態は、二つの一般的な制約を受けています。 （これらの原理は、他の肯定応答メカニズムについて追跡されるべきであるのAckベクトルを参照すると、その説明を簡略化状態。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Packets reported as State 0 or State 1 MUST be acknowledgeable: their options have been processed by the receiving DCCP stack. Any data on the packet need not have been delivered to the receiving application; in fact, the data may have been dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのオプションは受信DCCPスタックによって処理されています：1.パケットは承認可能でなければならない状態0または状態1と報告しました。パケット上のすべてのデータが受信アプリケーションに配信されている必要はありません。実際には、データが削除された可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Packets reported as State 3 MUST NOT be acknowledgeable. Feature negotiations and options on such packets MUST NOT have been processed, and the Acknowledgement Number MUST NOT correspond to such a packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態3は、受け付け可能にすることはできません2.パケットは報告しました。そのようなパケットの機能の交渉やオプションが処理されていてはならない、と謝辞数は、パケットに対応してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packets dropped in the application&#39;s receive buffer MUST be reported as Received or Received ECN Marked (States 0 and 1), depending on their ECN state; such packets&#39; ECN Nonces MUST be included in the Nonce Echo. The Data Dropped option informs the sender that some packets reported as received actually had their application data dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットは、彼らのECNの状態に応じて、のは、受信バッファをアプリケーションにドロップされた受信または受信ECNがマークとして報告されなければならない（米国0および1）。そのようなパケットのECNのナンスはノンスエコーに含まれなければなりません。データドロップオプションは、受け取ったと報告いくつかのパケットが実際にアプリケーションデータがドロップされていたことを送信者に通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One or more Ack Vector options that, together, report the status of a packet with a sequence number less than ISN, the initial sequence number, SHOULD be considered invalid. The receiving DCCP SHOULD either ignore the options or reset the connection with Reset Code 5, &#34;Option Error&#34;. No Ack Vector option can refer to a packet that has not yet been sent, as the Acknowledgement Number checks in Section
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、一緒に、ISN未満のシーケンス番号、初期シーケンス番号を持つパケットの状況を報告し、無効と見なされるべきである一の以上のAckベクトルオプション。受信DCCPは、いずれかのオプションを無視するか、リセットコード5、「オプション誤り」との接続をリセットする必要があります。何のAckベクトルオプションはまだ節で承認番号をチェックして、送信されていないパケットを参照することはできません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7.5.3 ensure, but because of attack, implementation bug, or misbehavior, an Ack Vector option can claim that a packet was received before it is actually delivered. Section 12.2 describes how this is detected and how senders should react. Packets that haven&#39;t been included in any Ack Vector option SHOULD be treated as &#34;not yet received&#34; (State 3) by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7.5.3は確実に、しかしなぜなら、攻撃、実装上のバグ、または誤動作のは、ACKベクトルオプションは、それが実際に配信される前に、パケットを受信したことを主張することができます。 12.2節では、これが検出された方法と送信者が反応する方法を説明します。どんなのAckベクトルオプションには含まれていないパケットは、送信者（状態3）「まだ受け取っていない」として扱われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix A provides a non-normative description of the details of DCCP acknowledgement handling in the context of an abstract Ack Vector implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Aは、抽象のAckベクトルの実装のコンテキストでDCCP確認処理の詳細の非規範的な説明を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4.1. Ack Vector Consistency
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4.1.  Ackベクトル一貫性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP sender will commonly receive multiple acknowledgements for some of its data packets. For instance, an HC-Sender might receive two DCCP-Acks with Ack Vectors, both of which contained information about sequence number 24. (Information about a sequence number is generally repeated in every ack until the HC-Sender acknowledges an ack. In this case, perhaps the HC-Receiver is sending acks faster than the HC-Sender is acknowledging them.) In a perfect world, the two Ack Vectors would always be consistent. However, there are many reasons why they might not be. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP送信者は、一般的にそのデータパケットのいくつかのために複数の承認を受け取ります。例えば、HC-SenderはHC-SenderはACKを確認するまで、シーケンス番号に関する情報は、一般的にすべてのACKで繰り返される（シーケンス番号24についての情報が含まれて両方とも肯定応答ベクトルを有する2つのDCCP-ACKを受け取る可能性がある。この中で場合は、おそらくHC-レシーバが速くHC-Senderはそれらを認めているよりも、ACKを送信しています。）完璧な世界では、2つのAckベクターは常に一致するであろう。しかし、彼らはないかもしれない多くの理由があります。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The HC-Receiver received packet 24 between sending its acks, so the first ack said 24 was not received (State 3) and the second said it was received or ECN marked (State 0 or 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O HC-ReceiverはそのACKを送信間のパケット24を受信し、第1のACKが24（状態3）に受信されなかった前記第二は、それが受信されたか、ECNがマークされた前記（状態0または1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The HC-Receiver received packet 24 between sending its acks, and the network reordered the acks. In this case, the packet will appear to transition from State 0 or 1 to State 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O HC-受信機は、そのACKを送信間のパケット24を受信し、そしてネットワークがACKを並べ替え。この場合、パケットは、状態0または1から状態3に遷移するように見えるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The network duplicated packet 24, and one of the duplicates was ECN marked. This might show up as a transition between States 0 and 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oネットワークは、パケット24を複製し、かつ重複の一つは、ECNがマークしました。これは、米国0と1の間の遷移として表示される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To cope with these situations, HC-Sender DCCP implementations SHOULD combine multiple received Ack Vector states according to this table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの状況に対処するため、複数を組み合わせるべきであるHC-送信者DCCP実装は、ACKベクトルはこのテーブルに従って述べ受けました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                               Received State
                                 0   1   3
                               +---+---+---+
                             0 | 0 |0/1| 0 |
                       Old     +---+---+---+
                             1 | 1 | 1 | 1 |
                      State    +---+---+---+
                             3 | 0 | 1 | 3 |
                               +---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To read the table, choose the row corresponding to the packet&#39;s old state and the column corresponding to the packet&#39;s state in the newly received Ack Vector; then read the packet&#39;s new state off the table. For an old state of 0 (received non-marked) and received state of 1 (received ECN marked), the packet&#39;s new state may be set to either 0 or 1. The HC-Sender implementation will be indifferent to ack reordering if it chooses new state 1 for that cell.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テーブルを読み取るには、パケットの古い状態に対応する行と、新たに受信したACKのベクトルで、パケットの状態に対応する列を選択してください。その後、テーブルから、パケットの新しい状態を読み出します。古い状態のために0（受信した非マーク）との状態を受け取っ1（受信ECNがマーク）、パケットの新しい状態が0または1のいずれかに設定することができるHC-送信者の実装は、それが選択した場合の並べ替えACKに無関心になりますそのセルの新しい状態1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HC-Receiver should collect information about received packets according to the following table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-Receiverは次の表に従って受信されたパケットについての情報を収集する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              Received Packet
                                 0   1   3
                               +---+---+---+
                             0 | 0 |0/1| 0 |
                     Stored    +---+---+---+
                             1 |0/1| 1 | 1 |
                      State    +---+---+---+
                             3 | 0 | 1 | 3 |
                               +---+---+---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This table equals the sender&#39;s table except that, when the stored state is 1 and the received state is 0, the receiver is allowed to switch its stored state to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保存された状態が1で受信された状態が0である場合、このテーブルは、受信機が0に、その格納された状態を切り替えることが許可されている、ことを除いて、送信者のテーブルに等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HC-Sender MAY choose to throw away old information gleaned from the HC-Receiver&#39;s Ack Vectors, in which case it MUST ignore newly received acknowledgements from the HC-Receiver for those old packets. It is often kinder to save recent Ack Vector information for a while so that the HC-Sender can undo its reaction to presumed congestion when a &#34;lost&#34; packet unexpectedly shows up (the transition from State 3 to State 0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-送信者は、これらの古いパケット用HC-Receiverから新たに受信した確認応答を無視しなければなりません。その場合にはHC-ReceiverのAckをベクトルから集められた古い情報を、捨てるのを選ぶかもしれ。 「失われた」パケットが予期せず（状態3から状態0への移行）現れたときにHC-Senderは推定混雑への反応を元に戻すことができるようにしばらくの間、最近のAckベクトル情報を保存することが多い親切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4.2. Ack Vector Coverage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4.2.  Ackベクトルカバレッジ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can divide the packets that have been sent from an HC-Sender to an HC-Receiver into four roughly contiguous groups. From oldest to youngest, these are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、4つの概ね連続したグループにHC-ReceiverにHC-送信機から送信されたパケットを分割することができます。最年少の古いものから、これらは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Packets already acknowledged by the HC-Receiver, where the HC-Receiver knows that the HC-Sender has definitely received the acknowledgements;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すでにHC-レシーバはHC-Senderが確実に確認応答を受信したことを知っているHC-レシーバによって認め1.パケット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Packets already acknowledged by the HC-Receiver, where the HC-Receiver cannot be sure that the HC-Sender has received the acknowledgements;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.パケットは、既にHC-レシーバはHC-Senderが確認応答を受信したことを確認することはできませんHC-レシーバー、によって確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Packets not yet acknowledged by the HC-Receiver; and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
まだHC-Receiverが認められていない3.パケット。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Packets not yet received by the HC-Receiver.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.パケットはまだHC-レシーバで受信されません。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The union of groups 2 and 3 is called the Acknowledgement Window. Generally, every Ack Vector generated by the HC-Receiver will cover the whole Acknowledgement Window: Ack Vector acknowledgements are cumulative. (This simplifies Ack Vector maintenance at the HC-Receiver; see Appendix A, below.) As packets are received, this window both grows on the right and shrinks on the left. It grows because there are more packets, and shrinks because the HC-Sender&#39;s Acknowledgement Numbers will acknowledge previous acknowledgements, moving packets from group 2 into group 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グループ2と3の労働組合は、確認応答ウィンドウと呼ばれています。一般に、HC-受信機によって生成されたすべてのAckベクトル全体肯定応答ウィンドウをカバーする：肯定応答ベクトル確認応答が累積的です。 （これは、HC-受信機でのAckベクトルメンテナンスを簡素化し、以下、付録Aを参照。）パケットが受信されると、このウィンドウの両方が右側に成長し、左側に収縮します。これは、より多くのパケットがあるので成長し、HC-送信者の承認番号がグループ1にグループ2からのパケットを移動し、以前の承認を承認しますので、縮小します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.5. Send Ack Vector Feature
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.5.  Ackベクトル機能を送ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Send Ack Vector feature lets DCCPs negotiate whether they should use Ack Vector options to report congestion. Ack Vector provides detailed loss information and lets senders report back to their applications whether particular packets were dropped. Send Ack Vector is mandatory for some CCIDs and optional for others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信のAckベクトル機能がDCCPsは、彼らが混雑を報告したAckベクトルオプションを使用する必要があるかどうかを交渉することができます。 Ack Vectorが、詳細な損失情報を提供し、特定のパケットが破棄されたかどうかを送信者が自分のアプリケーションに報告することができます。 Ack Vectorは他の人のためのいくつかのCCIDsとオプションのために必須である送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Send Ack Vector has feature number 6 and is server-priority. It takes one-byte Boolean values. DCCP A MUST send Ack Vector options on its acknowledgements when Send Ack Vector/A has value one, although it MAY send Ack Vector options even when Send Ack Vector/A is zero. Values of two or more are reserved. New connections start with Send Ack Vector 0 for both endpoints. DCCP B sends a &#34;Change R(Send Ack Vector, 1)&#34; option to DCCP A to ask A to send Ack Vector options as part of its acknowledgement traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信のAck Vectorがフィーチャー番号6を持っていると、サーバーの優先順位です。これは、1バイトのブール値をとります。送信のAckベクトル/ Aの値が1を持っていたときに送るのAckベクトル/ Aがゼロの場合であっても、それがAckでベクトルオプションを送るかもしれないがDCCP Aは、その確認応答上でACKベクトルオプションを送らなければなりません。二つ以上の値が予約されています。新しい接続は両方の終点のための送信のAckベクトル0で始まります。 DCCP Bは、「変更R（Ackをベクトル、1を送信）」の承認トラフィックの一部としてのAckベクトルオプションを送信するように依頼するDCCP Aへのオプションを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.6. Slow Receiver Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.6. スローレシーバーオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An HC-Receiver sends the Slow Receiver option to its sender to indicate that it is having trouble keeping up with the sender&#39;s data. The HC-Sender SHOULD NOT increase its sending rate for approximately one round-trip time after seeing a packet with a Slow Receiver option. After one round-trip time, the effect of Slow Receiver disappears, allowing the HC-Sender to increase its rate. Therefore, the HC-Receiver SHOULD continue to send Slow Receiver options if it needs to prevent the HC-Sender from going faster in the long term. The Slow Receiver option does not indicate congestion, and the HC-Sender need not reduce its sending rate. (If necessary, the receiver can force the sender to slow down by dropping packets, with or without Data Dropped, or by reporting false ECN marks.) APIs should let receiver applications set Slow Receiver and sending applications determine whether their receivers are Slow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-レシーバは、それがトラブルの送信者のデータに追いついを持っていることを示すために、その送信者にスローレシーバーオプションを送信します。 HC-送信者は、スローレシーバオプションでパケットを見た後、約1往復時間のためにその送信レートを増加させるべきではありません。 1ラウンドトリップ時間の後、スローレシーバーの効果は、HC-Senderがその速度を増加させることができ、表示されなくなります。そのため、HC-レシーバは、それが長期的に速く行くからHC-送信者を防ぐために必要がある場合にスローレシーバーオプションを送信し続けるべきです。スローレシーバーオプションは、輻輳を示すものではありません、とHC-送信者は、その送信レートを下げる必要はありません。 （必要であれば、受信機は、またはデータ、または虚偽のECNマークを報告することによってドロップせずに、パケットをドロップすることによって減速し、送信者を強制することができます。）APIは、受信機アプリケーションが遅いレシーバ設定と送信アプリケーションは受信機が低速であるかどうかを確認させてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Slow Receiver is a one-byte option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スローレシーバは、1バイトのオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+
   |00000010|
   +--------+
    Type=2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Slow Receiver does not specify why the receiver is having trouble keeping up with the sender. Possible reasons include lack of buffer space, CPU overload, and application quotas. A sending application might react to Slow Receiver by reducing its application-level sending rate, for example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機はトラブルの送信者に追いついを持っている理由遅いレシーバが指定されていません。考えられる理由は、バッファスペースの不足、CPUの過負荷、およびアプリケーションのクォータがあります。送信側アプリケーションは、例えば、そのアプリケーションレベル送信速度を低下させることによって受信を遅くする反応するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sending application should not react to Slow Receiver by sending more data, however. Although the optimal response to a CPU-bound receiver might be to reduce compression and send more data (a highly-compressed data format might overwhelm a slow CPU more seriously than would the higher memory requirements of a less-compressed data format), this kind of format change should be requested at the application level, not via the Slow Receiver option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信側アプリケーションは、しかし、より多くのデータを送信することにより、レシーバを遅らせるために反応すべきではありません。 CPUバウンド受信に最適な応答は、より多くのデータを圧縮を低減し、送信するかもしれないが、このような（高圧縮データフォーマットは、より深刻な場合とあまり圧縮データフォーマットの高いメモリ要件より遅いCPUを圧倒する可能性があります）フォーマット変更のないスローレシーバーのオプションを使用して、アプリケーションレベルで要求されるべき。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Slow Receiver implements a portion of TCP&#39;s receive window functionality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スローレシーバーは、TCPの受信ウィンドウの機能の一部を実装しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7. Data Dropped Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7. データは、オプションをドロップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Data Dropped option indicates that the application data on one or more received packets did not actually reach the application. Data Dropped additionally reports why the data was dropped: perhaps the data was corrupt, or perhaps the receiver cannot keep up with the sender&#39;s current rate and the data was dropped in some receive buffer. Using Data Dropped, DCCP endpoints can discriminate between different kinds of loss; this differs from TCP, in which all loss is reported the same way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データはオプションが1つまたは複数の受信したパケットのアプリケーションデータが実際にアプリケーションに到達しなかったことを示して低下しました。おそらく、データが破損した、またはおそらく受信側は送信者の現在のレートに追いつくことができず、データがいくつかに落とされた受信バッファ：さらにドロップされたデータは、データが削除された理由を報告します。データがドロップ用いて、DCCP終点は損失の異なる種類を区別することができます。これは、すべての損失が同じように報告されているTCPとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless it is explicitly specified otherwise, DCCP congestion control mechanisms MUST react as if each Data Dropped packet was marked as ECN Congestion Experienced by the network. We intend for Data Dropped to enable research into richer congestion responses to corrupt and other endpoint-dropped packets, but DCCP CCIDs MUST react conservatively to Data Dropped until this behavior is standardized. Section 11.7.2, below, describes congestion responses for all current Drop Codes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが明示的に指定されていない限り、各データパケットを落とした場合にネットワークが経験するECNの輻輳としてマークされていたとして、DCCP輻輳制御メカニズムが反応しなければなりません。データが破損していると、他のエンドポイント・破棄されたパケットに、より豊かな混雑応答の研究を可能にするためにドロップされたが、この動作は標準化されるまで、DCCPのCCIDsがデータに保守的に反応しなければならないドロップのために私たちは意図しています。セクション11.7.2は、以下の、現在のすべてのドロップコードのための輻輳応答を記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a received packet&#39;s application data is dropped for one of the reasons listed below, this SHOULD be reported using a Data Dropped option. Alternatively, the receiver MAY choose to report as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したパケットのアプリケーションデータは、下記のいずれかの理由で削除された場合、これは、データがDroppedオプションを使用して報告する必要があります。また、受信機は、として報告することを選ぶかもしれ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;received&#34; only those packets whose data were not dropped, subject to the constraint that packets not reported as received MUST NOT have had their options processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受け取ったとして報告されなかったパケットの制約を受け、データがドロップされなかったパケットのみが、そのオプションを処理していた持ってはいけません「受信」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The option&#39;s data looks like this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションのデータは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+--------+--------
   |00101000| Length | Block  | Block  | Block  |  ...
   +--------+--------+--------+--------+--------+--------
    Type=40          \___________ Vector ___________ ...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Vector consists of a series of bytes, called Blocks, each of whose encoding corresponds to one of two choices:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベクターは、二つの選択肢の一つに対応するそれぞれその符号化ブロックと呼ばれる一連のバイトで構成さ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7                  0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+
   |0| Run Length  |       or       |1|DrpCd|Run Len|
   +-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+
     Normal Block                      Drop Block
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first byte in the first Data Dropped option refers to the packet indicated by the Acknowledgement Number; subsequent bytes refer to older packets. Data Dropped MUST NOT be sent on DCCP-Data or DCCP-Request packets, which lack an Acknowledgement Number, and any Data Dropped options received on such packets MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のデータ削除されたオプションの最初のバイトは、肯定応答番号が示すパケットを指します。後続のバイトは、古いパケットを参照してください。データは、確認応答番号が不足しているDCCP-データやDCCP-Requestパケット、に送ってはいけません滴下し、そのようなパケットで受信したすべてのデータアイテムドロップのオプションは無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Normal Blocks, which have high bit 0, indicate that any received packets in the Run Length had their data delivered to the application. Drop Blocks, which have high bit 1, indicate that received packets in the Run Len[gth] were not delivered as usual. The 3-bit Drop Code [DrpCd] field says what happened; generally, no data from that packet reached the application. Packets reported as &#34;not yet received&#34; MUST be included in Normal Blocks; packets not covered by any Data Dropped option are treated as if they were in a Normal Block. Defined Drop Codes for Drop Blocks are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高ビット0を持っている通常のブロックは、ランレングスのいずれかの受信したパケットは、そのデータがアプリケーションに渡さなかったことを示しています。高いビット1を有するドロップブロックは、実行レン[GTH]における受信パケットを通常どおりに配信されなかったことを示しています。 3ビットのドロップコード[DrpCd]フィールドには、何が起こったかを言います。一般的に、そのパケットからのデータは、アプリケーションに達していません。 「まだ受け取っていない」と報告されたパケットは、通常のブロックに含まれなければなりません。彼らは通常のブロックにあったかのようにDroppedオプションを任意のデータでカバーされていないパケットが処理されます。ドロップブロックのために定義されたドロップコードは以下の通りです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  Drop Code  Meaning
                  ---------  -------
                      0      Protocol Constraints
                      1      Application Not Listening
                      2      Receive Buffer
                      3      Corrupt
                     4-6     Reserved
                      7      Delivered Corrupt
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Table 7: DCCP Drop Codes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
表7：DCCPドロップコード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In more detail:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに詳細に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0 The packet data was dropped due to protocol constraints. For example, the data was included on a DCCP-Request packet, but the receiving application does not allow such piggybacking; or the data was included on a packet with inappropriately low Checksum Coverage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0のパケットデータは、プロトコルの制約のために滴下しました。例えば、データはDCCP-Requestパケットに含まれていたが、受信側アプリケーションは、ピギーバックを可能にしません。またはデータが不適切に低いチェックサムカバー範囲を持つパケットに含まれていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1 The packet data was dropped because the application is no longer listening. See Section 11.7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
アプリケーションは、もはや聞いているので、1パケットデータは廃棄されませんでした。 11.7.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2 The packet data was dropped in a receive buffer, probably because of receive buffer overflow. See Section 11.7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2パケットデータは、おそらく受信バッファオーバーフロー、受信バッファに滴下しました。 11.7.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3 The packet data was dropped due to corruption. See Section 9.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3パケットデータが破損が原因で滴下しました。セクション9.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
7 The packet data was corrupted but was delivered to the application anyway. See Section 9.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
7パケットデータが破損しましたが、とにかくアプリケーションに配信されました。セクション9.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, assume that a packet arrives with Acknowledgement Number 100, an Ack Vector reporting all packets as received, and a Data Dropped option containing the decimal values 0,160,3,162. Then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、パケットが受信されるすべてのパケットを報告確認応答番号100は、ACKベクトルで到着することを前提とし、データは小数点以下の値0,160,3,162を含むオプションを落としました。その後：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet 100 was received (Acknowledgement Number 100, Normal Block, Run Length 0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット100は、受信しました（承認番号100、ノーマルブロックは、長さ0を実行します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet 99 was dropped in a receive buffer (Drop Block, Drop Code 2, Run Length 0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット99は、受信バッファ（ドロップブロック、ドロップコード2、ランレングス0）に滴下しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packets 98, 97, 96, and 95 were received (Normal Block, Run Length 3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット98、97、96、及び95は、（通常ブロック、ランレングス3）受信されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packets 95, 94, and 93 were dropped in the receive buffer (Drop Block, Drop Code 2, Run Length 2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット95、94、および93は、受信バッファ（ドロップブロック、ドロップコード2、ランレングス2）で削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Run lengths of more than 128 (for Normal Blocks) or 16 (for Drop Blocks) must be encoded in multiple Blocks. A single Data Dropped option can acknowledge up to 32384 Normal Block data packets, although the receiver SHOULD NOT send a Data Dropped option when all relevant packets fit into Normal Blocks. Should more packets need to be acknowledged than can fit in 253 bytes of Data Dropped, then multiple Data Dropped options can be sent. The second option will begin where the first left off, and so forth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ドロップブロックのための）を実行（ノーマルブロック用）128以上の長さ、または16は、複数のブロックに符号化されなければなりません。関連するすべてのパケットは通常のブロックに収まるとき、受信機がデータを送信することはできませんが、32384個の通常のブロックデータパケットまで認めることができDroppedオプションを単一のデータは、オプションを落としました。データの253バイトに収まることができるより多くのパケットが承認される必要があるべきで落とし、その後、複数のデータがオプションを送信することができますドロップ。最初は、などやめて、どこ番目のオプションが開始されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One or more Data Dropped options that, together, report the status of more packets than have been sent, or that change the status of a packet, or that disagree with Ack Vector or equivalent options (by reporting a &#34;not yet received&#34; packet as &#34;dropped in the receive buffer&#34;, for example) SHOULD be considered invalid. The receiving DCCP SHOULD either ignore such options, or respond by resetting the connection with Reset Code 5, &#34;Option Error&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つ以上のデータは、として、「未受信」パケットを報告することで、一緒に、送られてきたよりも多くのパケットの状況を報告し、またはそのパケットのステータスを変更、またはそれがAckでベクタまたは同等のオプションと一致しないオプションを（ドロップ無効と考慮されるべきである）、例えば、「受信バッファにドロップ」。受信DCCPは、いずれかのようなオプションを無視する、またはリセットコード5、「オプション誤り」との接続をリセットすることによって応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP application interface should let receiving applications specify the Drop Codes corresponding to received packets. For example, this would let applications calculate their own checksums but still report &#34;dropped due to corruption&#34; packets via the Data Dropped option. The interface SHOULD NOT let applications reduce the &#34;seriousness&#34; of a packet&#39;s Drop Code; for example, the application should not be able to upgrade a packet from delivered corrupt (Drop Code 7) to delivered normally (no Drop Code).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPアプリケーションインターフェースは、受信アプリケーションは、受信したパケットに対応するドロップコードを指定できなければなりません。例えば、これは、アプリケーションが独自のチェックサムを計算してみましょうが、まだ報告するデータドロップされたオプションを使用してパケット「による腐敗に落ちました」。インタフェースは、アプリケーションが、パケットのドロップコードの「深刻さ」を軽減させてはいけません。例えば、アプリケーションが正常に配信する配信壊れた（ドロップコード7）からパケット（ノードロップコード）をアップグレードすることはできないはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Dropped information is transmitted reliably. That is, endpoints SHOULD continue to transmit Data Dropped options until receiving an acknowledgement indicating that the relevant options have been processed. In Ack Vector terms, each acknowledgement should contain Data Dropped options that cover the whole Acknowledgement Window (Section 11.4.2), although when every packet in that window would be placed in a Normal Block, no actual option is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データは、情報が確実に伝達されて下落しました。これは、エンドポイントは、データが関連するオプションが処理されたことを示す確認応答を受信するまでのオプションをドロップ送信し続けるべきです。 Ackベクトル項では、各肯定応答データが含まれている必要があり、そのウィンドウ内のすべてのパケットが正常なブロックに置かれるだろうというとき、実際のオプションは必要ありませんが、全体の確認応答ウィンドウ（11.4.2）をカバーするオプションを落としました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.1. Data Dropped and Normal Congestion Response
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.1. ドロップされたデータと通常の混雑応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When deciding on a response to a particular acknowledgement or set of acknowledgements containing Data Dropped options, a congestion control mechanism MUST consider dropped packets, ECN Congestion Experienced marks (including marked packets that are included in Data Dropped), and packets singled out in Data Dropped. For window-based mechanisms, the valid response space is defined as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションをドロップ、輻輳制御機構がドロップされたパケットを考慮する必要があり、特定の承認に対する応答に決定するか、データを含む肯定応答の設定した場合、ECNの輻輳が（データにドロップ含まれているマークされたパケットを含む）のマークを経験したし、データに白羽のパケットがドロップされました。次のようにウィンドウベースのメカニズムに関しては、有効な応答空間が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assume an old window of W. Independently calculate a new window W_new1 that assumes no packets were Data Dropped (so W_new1 contains only the normal congestion response), and a new window W_new2 that assumes no packets were lost or marked (so W_new2 contains only the Data Dropped response). We are assuming that Data Dropped recommended a reduction in congestion window, so W_new2 &lt; W.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何のパケットを負いません新しいウィンドウW_new1を計算する独立しW.の古い窓を想定したデータが（そうW_new1のみ通常の混雑応答が含まれている）滴下し、何のパケットを負いません新しいウィンドウW_new2た（紛失したり、マークされていたので、W_new2のみ含まれていData）は、応答を落としました。私たちは、そうW_new2 &lt;W.、データが輻輳ウィンドウの減少を推奨ドロップすることを想定しています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Then the actual new window W_new MUST NOT be larger than the minimum of W_new1 and W_new2; and the sender MAY combine the two responses, by setting
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして、実際の新しいウィンドウW_newはW_new1とW_new2の最小値より大きくにすることはできません。そして送信者が設定することで、2つの応答を組み合わせてもよいです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
W_new = W + min(W_new1 - W, 0) + min(W_new2 - W, 0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
W_new = W +分（W_new1  -  W、0）+分（W_new2  -  W 0）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The details of how this is accomplished are specified in CCID profile documents. Non-window-based congestion control mechanisms MUST behave analogously; again, CCID profiles define how.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これを達成する方法の詳細については、CCIDプロフィール文書に指定されています。非ウィンドウベースの輻輳制御メカニズムは同様に動作しなければなりません。再び、CCIDプロファイルがどのように定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.2. Particular Drop Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.7.2. 特定のドロップコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Drop Code 0, Protocol Constraints, does not indicate any kind of congestion, so the sender&#39;s CCID SHOULD react to packets with Drop Code 0 as if they were received (with or without ECN Congestion Experienced marks, as appropriate). However, the sending endpoint SHOULD NOT send data until it believes the protocol constraint no longer applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らが受け取ったかのように、送信者のCCIDは、（またはECNの輻輳に遭遇したマークなしで必要に応じて、）ドロップコード0でパケットに反応する必要がありますので、渋滞のいずれかの種類を示すものではありません、コード0、プロトコルの制約をドロップします。それは、プロトコルの制約が適用されなくなり信じていなくなるまでしかし、送信エンドポイントは、データを送るべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Drop Code 1, Application Not Listening, means the application running at the endpoint that sent the option is no longer listening for data. For example, a server might close its receiving half-connection to new data after receiving a complete request from the client. This would limit the amount of state available at the server for incoming data and thus reduce the potential damage from certain denial-of-service attacks. A Data Dropped option containing Drop Code 1 SHOULD be sent whenever received data is ignored due to a non-listening application. Once an endpoint reports Drop Code 1 for a packet, it SHOULD report Drop Code 1 for every succeeding data packet on that half-connection; once an endpoint receives a Drop State 1 report, it SHOULD expect that no more data will ever be delivered to the other endpoint&#39;s application, so it SHOULD NOT send more data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは聞いていない、コード1をドロップし、オプションはもはやデータを待機して送信されていないエンドポイントで実行中のアプリケーションを意味します。例えば、サーバは、クライアントからの完全な要求を受信した後、新しいデータへの受信半接続を閉じることがあります。これは、着信データ用のサーバで利用可能な状態の量を制限するため、特定のサービス拒否攻撃からの潜在的な損傷を低減するであろう。データは、受信したデータは無視されるたびに1による非リスニングアプリケーションに送信されるべきでドロップコードを含むオプションを落としました。エンドポイントは、パケットのドロップコード1を報告したら、それはその半分接続上のすべての後続のデータパケットのドロップコード1を報告しなければなりません。エンドポイントがドロップ状態1つのレポートを受信すると、それはそれ以上のデータはこれまで、他のエンドポイントのアプリケーションに配信されませんので、それはより多くのデータを送ってはならないことを期待してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Drop Code 2, Receive Buffer, indicates congestion inside the receiving host. For instance, if a drop-from-tail kernel socket buffer is too full to accept a packet&#39;s application data, that packet should be reported as Drop Code 2. For a drop-from-head or more complex socket buffer, the dropped packet should be reported as Drop Code 2. DCCP implementations may also provide an API by which applications can mark received packets as Drop Code 2, indicating that the application ran out of space in its user-level receive buffer. (However, it is not generally useful to report packets as dropped due to Drop Code 2 after more than a couple of round-trip times have passed. The HC-Sender may have forgotten its acknowledgement state for the packet by that time, so the Data Dropped report will have no effect.) Every packet newly acknowledged as Drop Code 2 SHOULD reduce the sender&#39;s instantaneous rate by one packet per round-trip time, unless the sender is already sending one packet per RTT or less. Each CCID profile defines the CCID-specific mechanism by which this is accomplished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信バッファ、コード2をドロップし、受信ホスト内の混雑を示します。例えば、ドロップからテールカーネルソケットバッファは、パケットのアプリケーションデータを受け入れるにはあまりにもいっぱいになった場合、そのパケットはからヘッドドロップまたはより複雑なソケットバッファのドロップコード2として報告しなければならない、ドロップされたパケットべき2. DCCP実装は、アプリケーションが受信バッファそのユーザレベルのスペースが不足していることを示す、アプリケーションは、ドロップコード2として受信したパケットにマークを付けることが可能なAPIを提供することができるドロップコードとして報告されます。 （ただし、ドロップとして往復時間以上のカップルが経過した後に起因する2ドロップコードに。HC-Senderは、その時点でのパケットのための承認状態を忘れてしまったかもしれパケットを報告するために一般的に有用ではないので、データは、報告書は効果がありませんドロップされた。）、送信者が既にRTT以下ごとに1つのパケットを送信している場合を除き、新たにドロップコード2として認めすべてのパケットは、ラウンドトリップ時間あたり1つのパケットで送信者の瞬間率を減らす必要があります。各CCIDプロフィールは、これが達成されることにより、CCID特有のメカニズムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Currently, the other Drop Codes (namely Drop Code 3, Corrupt; Drop Code 7, Delivered Corrupt; and reserved Drop Codes 4-6) MUST cause the relevant CCID to behave as if the relevant packets were ECN marked (ECN Congestion Experienced).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、他のドロップコード関連のパケットはECNが（経験豊富なECNの輻輳）をマークしたかのように、関連CCIDの振る舞いを引き起こす必要があります（つまりドロップコード3、腐敗;＆ドロップコード4-6を予約し、ドロップコード7は、壊れ配信します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Explicit Congestion Notification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.明示的輻輳通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DCCP protocol is fully ECN-aware [RFC3168]. Each CCID specifies how its endpoints respond to ECN marks. Furthermore, DCCP, unlike TCP, allows senders to control the rate at which acknowledgements are generated (with options like Ack Ratio); since acknowledgements are congestion controlled, they also qualify as ECN-Capable Transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPプロトコルは、[RFC3168]完全ECN-認識しています。そのエンドポイントはECNマークへの対応方法を各CCIDを指定します。また、DCCPは、TCPとは異なり、送信者が（肯定応答率のようなオプションで）確認応答が生成される速度を制御することを可能にします。確認応答は混雑が制御されているので、彼らはまた、ECN-できるTransportとしての資格。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each CCID profile describes how that CCID interacts with ECN, both for data traffic and pure-acknowledgement traffic. A sender SHOULD set ECN-Capable Transport on its packets&#39; IP headers unless the receiver&#39;s ECN Incapable feature is on or the relevant CCID disallows it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各CCIDプロフィールは、CCIDは両方のデータトラフィックと純粋-承認トラフィックのため、ECNと対話する方法を説明します。受信者のECNできない機能がオンであるか、関連CCIDはそれを禁止しない限り、送信者は、そのパケットのIPヘッダにECN-できるTransportを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of this section describes the ECN Incapable feature and the interaction of the ECN Nonce with acknowledgement options such as Ack Vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの残りの部分は、ECNできない機能や、Ackをベクトルとして承認オプションとECNナンスの相互作用を記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. ECN Incapable Feature
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.  ECNできない機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints are ECN-aware by default, but the ECN Incapable feature lets an endpoint reject the use of Explicit Congestion Notification. The use of this feature is NOT RECOMMENDED. ECN incapability both avoids ECN&#39;s possible benefits and prevents senders from using the ECN Nonce to check for receiver misbehavior. A DCCP stack MAY therefore leave the ECN Incapable feature unimplemented, acting as if all connections were ECN capable. Note that the inappropriate firewall interactions that dogged TCP&#39;s implementation of ECN [RFC3360] involve TCP header bits, not the IP header&#39;s ECN bits; we know of no middlebox that would block ECN-capable DCCP packets but allow ECN-incapable DCCP packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPのエンドポイントは、デフォルトではECN-認識していますが、ECNできない機能は、エンドポイントが明示的輻輳通知の使用を拒否することができます。この機能の使用は推奨されません。 ECN不能は、両方のECNの可能性の利点を回避し、受信不正行為をチェックするためにECN nonceを使用してから送信者を防ぐことができます。 DCCPスタックは、したがって、すべての接続がECNが可能であるかのように作用して、実装されていないECNできない機能を残すことができます。 ECN [RFC3360]のTCPの実装を付きまとっ不適切ファイアウォール相互作用がTCPヘッダービットではなく、IPヘッダーのECNビットを含むことに留意されたいです。我々は、ECN対応のDCCPのパケットをブロックするが、ECN-不可能DCCPパケットを可能にする無ミドルを知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECN Incapable has feature number 4 and is server-priority. It takes one-byte Boolean values. DCCP A MUST be able to read ECN bits from received frames&#39; IP headers when ECN Incapable/A is zero. (This is independent of whether it can set ECN bits on sent frames.) DCCP A thus sends a &#34;Change L(ECN Inapable, 1)&#34; option to DCCP B to inform it that A cannot read ECN bits. If the ECN Incapable/A feature is one, then all of DCCP B&#39;s packets MUST be sent as ECN incapable. New connections start with ECN Incapable 0 (that is, ECN capable) for both endpoints. Values of two or more are reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECN不可能では機能番号4を持ち、サーバーの優先順位です。これは、1バイトのブール値をとります。 DCCP Aは、ECN不能/ Aがゼロであるとき、受信したフレームのIPヘッダからECNビットを読み取ることができなければなりません。 （これは、それが送信されたフレームにECNビットを設定することができるかどうかとは無関係である。）DCCP Aは、このように「変化L（ECN Inapable、1）」AはECNビットを読み取ることができないことを知らせるためにDCCP Bにオプションを送ります。 ECNができない/機能が1であれば、DCCP Bのパケットのすべてが不可能ECNとして送らなければなりません。新しい接続は両方の終点のために（つまり、可能ECNである）ECN不可能な0で始まります。二つ以上の値が予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a DCCP is not ECN capable, it MUST send Mandatory &#34;Change L(ECN Incapable, 1)&#34; options to the other endpoint until acknowledged (by &#34;Confirm R(ECN Incapable, 1)&#34;) or the connection closes. Furthermore, it MUST NOT accept any data until the other endpoint sends &#34;Confirm R(ECN Incapable, 1)&#34;. It SHOULD send Data Dropped options on its acknowledgements, with Drop Code 0 (&#34;protocol constraints&#34;), if the other endpoint does send data inappropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPが可能なECNされていない場合（「R（ECNできない、1）を確認してください」で）認めたり、接続が閉じるまで、それは他のエンドポイントに必須の「変更L（ECNできない、1）」オプションを送らなければなりません。さらに、それは他のエンドポイントに送信するまでの任意のデータを受け入れてはいけません「R（1、ECNができない）確認」。これは、他のエンドポイントが不適切にデータを送信した場合、データは、ドロップコード0（「プロトコルの制約」）と、その確認応答のオプションをドロップ送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. ECN Nonces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.  ECN Nuncios
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion avoidance will not occur, and the receiver will sometimes get its data faster, if the sender isn&#39;t told about congestion events. Thus, the receiver has some incentive to falsify acknowledgement information, reporting that marked or dropped packets were actually received unmarked. This problem is more serious with DCCP than with TCP, since TCP provides reliable transport: it is more difficult with TCP to lie about lost packets without breaking the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳回避は発生しません、と送信者が輻輳イベントについて語られていない場合、受信機は時々、より高速にデータを取得します。このように、受信機は、パケットをマークまたは削除の報告が実際にマークされていない受信した、送達確認情報を改ざんするためにいくつかのインセンティブを持っています。 TCPは信頼性の高いトランスポートを提供するので、この問題は、TCPよりもDCCPとより深刻である：アプリケーションを壊すことなく、失われたパケット偽るためにTCPとより困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECN Nonces are a general mechanism to prevent ECN cheating (or loss cheating). Two values for the two-bit ECN header field indicate ECN-Capable Transport, 01 and 10. The second code point, 10, is the ECN Nonce. In general, a protocol sender chooses between these code points randomly on its output packets, remembering the sequence it chose. On every acknowledgement, the protocol receiver reports the number of ECN Nonces it has received thus far. This is called the ECN Nonce Echo. Since ECN marking and packet dropping both destroy the ECN Nonce, a receiver that lies about an ECN mark or packet drop has a 50% chance of guessing right and avoiding discipline. The sender may react punitively to an ECN Nonce mismatch, possibly up to dropping the connection. The ECN Nonce Echo field need not be an integer; one bit is enough to catch 50% of infractions, and the probability of success drops exponentially as more packets are sent [RFC3540].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECNナンスは、ECN浮気（または損失の不正行為）を防ぐために、一般的なメカニズムです。 2つの2ビットECNヘッダフィールドの値ECN-可能なトランスポートを示し、01及び10の第2のコードポイント、10は、ECNノンスです。一般に、プロトコルの送信者は、それが選択したシーケンスを記憶、ランダムにその出力パケットにこれらのコード・ポイントとの間で選択します。すべての承認には、プロトコルの受信機は、それがこれまでに受けたECNナンスの数を報告します。これは、電子証券取引ネットワークのNonceエコーと呼ばれています。 ECNマーキングと、パケットがドロップ両方のECNナンス、右推測と規律を回避する50％のチャンスがあるECNマークやパケット損失についてのある受信機を破壊して以来。送信者は、おそらく、接続をドロップするまで、電子証券取引ネットワークのNonceの不一致にpunitively反応することができます。 ECNナンスエコーフィールドは整数である必要はありません。 1ビットは、違反の50％を捕捉するのに十分であり、そしてより多くのパケットが[RFC3540]を送信しているように、成功の確率が指数関数的に低下します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In DCCP, the ECN Nonce Echo field is encoded in acknowledgement options. For example, the Ack Vector option comes in two forms, Ack Vector [Nonce 0] (option 38) and Ack Vector [Nonce 1] (option 39), corresponding to the two values for a one-bit ECN Nonce Echo. The Nonce Echo for a given Ack Vector equals the one-bit sum (exclusive-or, or parity) of ECN nonces for packets reported by that Ack Vector as received and not ECN marked. Thus, only packets marked as State 0 matter for this calculation (that is, valid received packets that were not ECN marked). Every Ack Vector option is detailed enough for the sender to determine what the Nonce Echo should have been. It can check this calculation against the actual Nonce Echo and complain if there is a mismatch. (The Ack Vector could conceivably report every packet&#39;s ECN Nonce state, but this would severely limit its compressibility without providing much extra protection.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPでは、ECNのNonceエコーフィールドには、確認応答のオプションでエンコードされています。例えば、肯定応答ベクトルオプションは、2つの形式が、肯定応答ベクトル[ノンス0]（オプション38）とACKベクトル[ノンス1]（オプション39）、1ビットECNノンスエコーのための2つの値に対応します。所与のAckベクトルのノンスエコーが受信されないECNがマークとしてその肯定応答ベクトルによって報告されたパケットのECNのナンスの1ビットの和（排他的論理和、またはパリティ）に等しいです。したがって、唯一の（つまり、マークされECNれなかった有効な受信パケット）この計算の状態0の問題としてマークされたパケット。すべてのAckベクトルオプションは、ノンスエコーがされているべきかを決定するために、送信者のために十分に詳述されています。これは、実際のNonceエコーに対してこの計算をチェックし、不一致がある場合は文句を言うことができます。 （のAck Vectorが考えられるすべてのパケットのECNナンス状態を報告することがありますが、これは深刻な多くの特別な保護を提供することなく、その圧縮性を制限します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each DCCP sender SHOULD set ECN Nonces on its packets and remember which packets had nonces. When a sender detects an ECN Nonce Echo mismatch, it behaves as described in the next section. Each DCCP receiver MUST calculate and use the correct value for ECN Nonce Echo when sending acknowledgement options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各DCCP送信者は、そのパケットにECNナンスを設定し、ナンスを持っていたパケットを覚えておいてください。送信者が電子証券取引ネットワークのNonceエコーの不一致を検出すると、次のセクションで説明するように、それが動作します。肯定応答オプションを送信するとき、各DCCP受信機は、ECNノンスエコーの正しい値を計算し、使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECN incapability, as indicated by the ECN Incapable feature, is handled as follows: an endpoint sending packets to an ECN-incapable receiver MUST send its packets as ECN incapable, and an ECN-incapable receiver MUST use the value zero for all ECN Nonce Echoes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECNできない機能によって示されるように、以下のようにECN不能は、処理される：ECN非対応の受信機にパケットを送信するエンドポイントがECNできないように、そのパケットを送信しなければならない、およびECN非対応受信機は、すべてのECNノンスエコーの値ゼロを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. Aggression Penalties
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. アグレッション罰則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP endpoints have several mechanisms for detecting congestion-related misbehavior. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP終点は、輻輳関連の不正行為を検出するためのいくつかのメカニズムを持っています。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sender can detect an ECN Nonce Echo mismatch, indicating possible receiver misbehavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O送信側は可能受信不正行為を示し、ECNノンスエコーミスマッチを検出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A receiver can detect whether the sender is responding to congestion feedback or Slow Receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O受信側は、送信側が輻輳フィードバックまたは遅い受信に応答しているかどうかを検出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An endpoint may be able to detect that its peer is reporting inappropriately small Elapsed Time values (Section 13.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oエンドポイントは、そのピアが不適切に小さい経過時間値（13.2）を報告していることを検出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint that detects possible congestion-related misbehavior SHOULD try to verify that its peer is truly misbehaving. For example, a sending endpoint might send a packet whose ECN header field is set to Congestion Experienced, 11; a receiver that doesn&#39;t report a corresponding mark is most likely misbehaving.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能混雑関連の不正行為を検出したエンドポイントは、その相手が本当に不正な動作していることを確認してみてください。例えば、送信エンドポイントは、そのECNヘッダフィールドは輻輳経験、11に設定されているパケットを送るかもしれません。対応するマークを報告しない受信機は、ほとんどの誤動作です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon detecting possible misbehavior, a sender SHOULD respond as if the receiver had reported one or more recent packets as ECN-marked (instead of unmarked), while a receiver SHOULD report one or more recent non-marked packets as ECN-marked. Alternately, a sender might act as if the receiver had sent a Slow Receiver option, and a receiver might send Slow Receiver options. Other reactions that serve to slow the transfer rate are also acceptable. An entity that detects particularly egregious and ongoing misbehavior MAY also reset the connection with Reset Code 11, &#34;Aggression Penalty&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機は、（代わりにマークされていないの）ECN-マークとして、一つ以上の最近のパケットを報告したかのようにECN-マークとして受信機は、1つまたは複数の最近の非マークされたパケットを報告する必要がありながら、可能な不正行為を検出すると、送信者は、応答する必要があります。代わりに、受信機は遅いレシーバオプションを送っていたかのように送信者が行動するかもしれない、と受信機は、低速レシーバのオプションを送信することがあります。転送速度を遅くするのに役立つ他の反応も許容されます。特に悪質と継続的な不正行為を検出したエンティティは、リセットコード11、「侵略ペナルティ」との接続をリセットする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, ECN Nonce mismatches and other warning signs can result from innocent causes, such as implementation bugs or attack. In particular, a successful DCCP-Data attack (Section 7.5.5) can cause the receiver to report an incorrect ECN Nonce Echo. Therefore, connection reset and other heavyweight mechanisms SHOULD be used only as last resorts, after multiple round-trip times of verified aggression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、ECNナンスの不一致や他の警告標識は、そのような実装のバグや攻撃などの無実の原因に起因することができます。具体的には、成功したDCCP  - データ攻撃（セクション7.5.5）は、受信機が正しくないECNのNonceエコーを報告させることができます。そのため、接続がリセットされ、他のヘビー級のメカニズムを検証侵略の複数の往復時間の後、最後のリゾートとして使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Timing Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.タイミングオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Timestamp, Timestamp Echo, and Elapsed Time options help DCCP endpoints explicitly measure round-trip times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムスタンプ、タイムスタンプエコー、経過時間のオプションは、DCCP終点は明示的に往復時間を測定するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Timestamp Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. タイムスタンプオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This option is permitted in any DCCP packet. The length of the option is 6 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションは、任意のDCCPパケットに許可されています。オプションの長さは6バイトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+--------+--------+
   |00101001|00000110|          Timestamp Value          |
   +--------+--------+--------+--------+--------+--------+
    Type=41  Length=6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The four bytes of option data carry the timestamp of this packet. The timestamp is a 32-bit integer that increases monotonically with time, at a rate of 1 unit per 10 microseconds. At this rate, Timestamp Value will wrap approximately every 11.9 hours. Endpoints need not measure time at this fine granularity; for example, an endpoint that preferred to measure time at millisecond granularity might send Timestamp Values that were all multiples of 100. The precise time corresponding to Timestamp Value zero is not specified: Timestamp Values are only meaningful relative to other Timestamp Values sent on the same connection. A DCCP receiving a Timestamp option SHOULD respond with a Timestamp Echo option on the next packet it sends.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションの4バイトのデータは、このパケットのタイムスタンプを運びます。タイムスタンプは、10マイクロ秒当たり1単位の割合で、時間とともに単調に増加する32ビットの整数です。このレートでは、タイムスタンプ値は約すべての11.9時間をラップします。エンドポイントは、この細かい粒度で時間を計測する必要はありません。タイムスタンプ値は同じで送信され、他のタイムスタンプ値に対してのみ意味相対的：例えば、ミリ秒単位で時間を測定することが好ましい終点は、タイムスタンプ値ゼロに対応する正確な時刻が指定されていないすべての100の倍数であったタイムスタンプ値を送信するかもしれません接続。タイムスタンプオプションを受信DCCPは、送信する次のパケットのタイムスタンプエコーオプションを指定して応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Elapsed Time Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. 経過時間オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This option is permitted in any DCCP packet that contains an Acknowledgement Number; such options received on other packet types MUST be ignored. It indicates how much time has elapsed since the packet being acknowledged -- the packet with the given Acknowledgement Number -- was received. The option may take 4 or 6 bytes, depending on the size of the Elapsed Time value. Elapsed Time helps correct round-trip time estimates when the gap between receiving a packet and acknowledging that packet may be long -- in CCID 3, for example, where acknowledgements are sent infrequently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションは、確認応答番号を含む任意のDCCPパケットに許可されています。他のパケットタイプで受信し、そのようなオプションは無視しなければなりません。これは、パケットが確認されてから経過した時間を示す - 与えられた確認応答番号を持つパケットを - 受信しました。オプションは、経過時間値の大きさに応じて、4つの又は6バイトをとることができます。肯定応答がまれに送信され、例えばCCID 3に - 経過時間がパケットを受信し、そのパケットを認めるとの間に隙間が長いとすることができる場合、正しいラウンドトリップ時間を推定するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+
   |00101011|00000100|   Elapsed Time  |
   +--------+--------+--------+--------+
    Type=43    Len=4
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+--------+--------+
   |00101011|00000110|            Elapsed Time           |
   +--------+--------+--------+--------+--------+--------+
    Type=43    Len=6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The option data, Elapsed Time, represents an estimated lower bound on the amount of time elapsed since the packet being acknowledged was received, with units of hundredths of milliseconds. If Elapsed Time is less than a half-second, the first, smaller form of the option SHOULD be used. Elapsed Times of more than 0.65535 seconds MUST be sent using the second form of the option. The special Elapsed Time value 4294967295, which corresponds to approximately 11.9 hours, is used to represent any Elapsed Time greater than 42949.67294 seconds. DCCP endpoints MUST NOT report Elapsed Times that are significantly larger than the true elapsed times. A connection MAY be reset with Reset Code 11, &#34;Aggression Penalty&#34;, if one endpoint determines that the other is reporting a much-too-large Elapsed Time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションデータ、経過時間、認知されているパケットはミリ秒の100分の1単位で、受信されてから経過した時間の量に下限推定を表します。経過時間が0.5秒未満である場合、オプションの最初の、小型のフォームが使用されるべきです。以上0.65535秒の経過時間は、オプションの二番目の形式を使用させなければなりません。約11.9時間に対応する特別な経過時間値4294967295は、42949.67294秒よりも大きい任意の経過時間を表すために使用されます。 DCCP終点は、真の経過時間よりもかなり大きい経過時間を報告してはなりません。一方のエンドポイントは、他の多くの余りに大きな経過時間を報告していると判断した場合、接続は、リセットコード11、「侵略ペナルティ」でリセットされることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Elapsed Time is measured in hundredths of milliseconds as a compromise between two conflicting goals. First, it provides enough granularity to reduce rounding error when measuring elapsed time over fast LANs; second, it allows many reasonable elapsed times to fit into two bytes of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
経過時間は、相反する2つの目標の間の妥協として、ミリ秒単位の百で測定されます。まず、それは速いLAN上の経過時間を計測丸め誤差を低減するのに十分な精度を提供します。第二、それは多くの合理的な経過時間は、2バイトのデータに適合することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. Timestamp Echo Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. タイムスタンプエコーオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This option is permitted in any DCCP packet, as long as at least one packet carrying the Timestamp option has been received. Generally, a DCCP endpoint should send one Timestamp Echo option for each Timestamp option it receives, and it should send that option as soon as is convenient. The length of the option is between 6 and 10 bytes, depending on whether Elapsed Time is included and how large it is.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションは限りタイムスタンプオプションを運ぶ少なくとも1つのパケットが受信されている、あらゆるDCCPパケットに許可されています。一般的に、DCCP終点は、それが受信した各タイムスタンプオプションの1つのタイムスタンプエコーオプションを送信する必要があり、それは、すぐに便利なように、そのオプションを送信する必要があります。オプションの長さは、経過時間が含まれ、それがどのように大きなされているかどうかに依存して、6〜10バイトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+--------+--------+--------+--------+
   |00101010|00000110|           Timestamp Echo          |
   +--------+--------+--------+--------+--------+--------+
    Type=42    Len=6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+------- ... -------+--------+--------+
   |00101010|00001000|  Timestamp Echo   |   Elapsed Time  |
   +--------+--------+------- ... -------+--------+--------+
    Type=42    Len=8       (4 bytes)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------+--------+------- ... -------+------- ... -------+
   |00101010|00001010|  Timestamp Echo   |    Elapsed Time   |
   +--------+--------+------- ... -------+------- ... -------+
    Type=42   Len=10       (4 bytes)           (4 bytes)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first four bytes of option data, Timestamp Echo, carry a Timestamp Value taken from a preceding received Timestamp option. Usually, this will be the last packet that was received -- the packet indicated by the Acknowledgement Number, if any -- but it might be a preceding packet. Each Timestamp received will generally result in exactly one Timestamp Echo transmitted. If an endpoint has received multiple Timestamp options since the last time it sent a packet, then it MAY ignore all Timestamp options but the one included on the packet with the greatest sequence number. Alternatively, it MAY include multiple Timestamp Echo options in its response, each corresponding to a different Timestamp option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションデータの最初の4バイト、タイムスタンプエコーは、前述の受信タイムスタンプオプションから採取されたタイムスタンプ値を運びます。もしあれば、確認応答番号で示されるパケット -   - 通常、これは、受信された最後のパケットになりますが、それは前のパケットであるかもしれません。各タイムスタンプは、一般的に、正確に1つのタイムスタンプエコーが送信になります受け取りました。エンドポイントは、それがパケットを送信した前回、複数のタイムスタンプオプションを受信した場合、それは、すべてのタイムスタンプオプションを無視するかもしれませんが、一つは、最大のシーケンス番号を持つパケットに含まれています。あるいは、それは、それぞれが異なるタイムスタンプオプションに対応し、その応答で複数のタイムスタンプエコーオプションを含むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Elapsed Time value, similar to that in the Elapsed Time option, indicates the amount of time elapsed since receiving the packet whose timestamp is being echoed. This time MUST have units of hundredths of milliseconds. Elapsed Time is meant to help the Timestamp sender separate the network round-trip time from the Timestamp receiver&#39;s processing time. This may be particularly important for CCIDs where acknowledgements are sent infrequently, so that there might be considerable delay between receiving a Timestamp option and sending the corresponding Timestamp Echo. A missing Elapsed Time field is equivalent to an Elapsed Time of zero. The smallest version of the option SHOULD be used that can hold the relevant Elapsed Time value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
経過時間オプションと同様の経過時間の値は、そのタイムスタンプエコーされたパケットを受信して​​からの経過時間を示しています。この時間はミリ秒の100分の1単位を持たなければなりません。経過時間は、タイムスタンプ、送信者は、タイムスタンプ、受信機の処理時間からネットワーク往復時間を区切る助けるためのものです。タイムスタンプオプションを受信し、対応するタイムスタンプエコーを送信する間にかなりの遅延が生じる可能性がありますように、これは、確認応答が、まれに送信されますのCCIDsのために特に重要であるかもしれません。行方不明経過時間フィールドがゼロの経過時間に相当します。オプションの最小バージョンは、関連する経過時間の値を保持することができる使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Maximum Packet Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.最大パケットサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP implementation MUST maintain the maximum packet size (MPS) allowed for each active DCCP session. The MPS is influenced by the maximum packet size allowed by the current congestion control mechanism (CCMPS), the maximum packet size supported by the path&#39;s links (PMTU, the Path Maximum Transmission Unit) [RFC1191], and the lengths of the IP and DCCP headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP実装は、各アクティブDCCPセッションに許可された最大パケットサイズ（MPS）を維持しなければなりません。 MPSは、現在の輻輳制御機構（CCMPS）によって許容される最大パケット・サイズ、パスのリンクによってサポートされる最大パケットサイズ（PMTU、パスの最大伝送単位）[RFC1191]、およびIPとDCCPの長さに影響されますヘッダ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP application interface SHOULD let the application discover DCCP&#39;s current MPS. Generally, the DCCP implementation will refuse to send any packet bigger than the MPS, returning an appropriate error to the application. A DCCP interface MAY allow applications to request fragmentation for packets larger than PMTU, but not larger than CCMPS. (Packets larger than CCMPS MUST be rejected in any case.) Fragmentation SHOULD NOT be the default, since it decreases robustness: an entire packet is discarded if even one of its fragments is lost. Applications can usually get better error tolerance by producing packets smaller than the PMTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPアプリケーションインターフェースは、アプリケーションがDCCPの現在のMPSを発見させてください。一般的に、DCCPの実装は、アプリケーションに適切なエラーを返す、MPSよりも大きな任意のパケットを送信することを拒否します。 DCCPインタフェースは、アプリケーションがCCMPSより大きいPMTUより大きくはなく、パケットのフラグメンテーションを要求することを可能にし得ます。 （CCMPSよりも大きなパケットは、どのような場合には拒絶しなければなりません。）フラグメンテーションはデフォルトすべきではない、それは堅牢性を減少するので：一つでもそのフラグメントのが失われた場合、パケット全体が廃棄されます。アプリケーションは通常、PMTUより小さいパケットを生成することによって、より良いエラー耐性を得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MPS reported to the application SHOULD be influenced by the size expected to be required for DCCP headers and options. If the application provides data that, when combined with the options the DCCP implementation would like to include, would exceed the MPS, the implementation should either send the options on a separate packet (such as a DCCP-Ack) or lower the MPS, drop the data, and return an appropriate error to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPSはDCCPヘッダーとオプションのために必要とされることが予想される大きさに影響されるべきであるアプリケーションに報告しました。アプリケーションがオプションと組み合わせた場合、DCCP実装が含まれたいデータを提供する場合、MPSを超える、MPSを（例えばDCCP-Ackのような）別のパケットのオプションを送信したり、下げなければならないのいずれかの実装では、ドロップデータ、およびアプリケーションに適切なエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. Measuring PMTU
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. 測定PMTU
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each DCCP endpoint MUST keep track of the current PMTU for each connection, except that this is not required for IPv4 connections whose applications have requested fragmentation. The PMTU SHOULD be initialized from the interface MTU that will be used to send packets. The MPS will be initialized with the minimum of the PMTU and the CCMPS, if any.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、そのアプリケーションの断片化を要求したIPv4接続のために必要とされていないことを除いて、各DCCP終点は、それぞれの接続のために現在のPMTUを追跡する必要があります。 PMTUは、パケットを送信するために使用されるインターフェイスのMTUから初期化する必要があります。もしあればMPSは、PMTUとCCMPSの最小で初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Classical PMTU discovery uses unfragmentable packets. In IPv4, these packets have the IP Don&#39;t Fragment (DF) bit set; in IPv6, all packets are unfragmentable once emitted by an end host. As specified in [RFC1191], when a router receives a packet with DF set that is larger than the next link&#39;s MTU, it sends an ICMP Destination Unreachable message back to the source whose Code indicates that an unfragmentable packet was too large to forward (a &#34;Datagram Too Big&#34; message). When a DCCP implementation receives a Datagram Too Big message, it decreases its PMTU to the Next-Hop MTU value given in the ICMP message. If the MTU given in the message is zero, the sender chooses a value for PMTU using the algorithm described in [RFC1191], Section 7. If the MTU given in the message is greater than the current PMTU, the Datagram Too Big message is ignored, as described in [RFC1191]. (We are aware that this may cause problems for DCCP endpoints behind certain firewalls.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラシックPMTUの発見は、フラグメント化不能のパケットを使用しています。 IPv4では、これらのパケットは、IPを持っているフラグメント（DF）は、ビットセットしないでください。エンドホストから放出された後、IPv6では、すべてのパケットがフラグメント化不能です。 [RFC1191]で指定されているように、ルータは、次のリンクのMTUよりも大きいDFセットでパケットを受信したとき、それは戻って、そのコードフラグメント化不能パケットを転送するにはあまりにも大きかったことを示している（AソースにICMP宛先到達不能メッセージを送信します「データグラムが大きすぎます」というメッセージ）。 DCCP実装がデータグラム過大メッセージを受信すると、ICMPメッセージに指定されたネクストホップMTU値に対するPMTUを低下させます。メッセージに指定されたMTUがゼロである場合、送信者は[RFC1191]に記載されたアルゴリズムを使用して、PMTUの値を選択するメッセージで与えられたMTUが現在のPMTUより大きい場合、第7、データグラム過大メッセージは無視されます、[RFC1191]に記載されているように。 （これは、特定のファイアウォールの背後にあるDCCPエンドポイントの問題を引き起こす可能性があることを認識しています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP implementation may allow the application occasionally to request that PMTU discovery be performed again. This will reset the PMTU to the outgoing interface&#39;s MTU. Such requests SHOULD be rate limited, to one per two seconds, for example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPの実装では、アプリケーションが時折PMTU検出が再度行われることを要求することを可能にし得ます。これは、発信インターフェイスのMTUにPMTUをリセットします。このような要求は、例えば、2秒に1に、レート制限すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP sender MAY treat the reception of an ICMP Datagram Too Big message as an indication that the packet being reported was not lost due to congestion, and so for the purposes of congestion control it MAY ignore the DCCP receiver&#39;s indication that this packet did not arrive. However, if this is done, then the DCCP sender MUST check the ECN bits of the IP header echoed in the ICMP message and only perform this optimization if these ECN bits indicate that the packet did not experience congestion prior to reaching the router whose link MTU it exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPの送信者は報告されているパケットが輻輳のために失われていなかったことを示す指標として、ICMPデータグラム過大メッセージの受信を扱うことができ、その輻輳制御の目的のためには、このパケットが到着しなかったことをDCCP受信機の表示を無視してもよい（MAY） 。しかし、これが行われた場合、その後、DCCPの送信者は、ICMPメッセージにエコーIPヘッダのECNビットをチェックしなければなりませんし、これらのみECNビットは、パケットが前にそのリンクMTUルータに到達する輻輳を経験しなかったことを示している場合は、この最適化を実行しますそれを超えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP implementation SHOULD ensure, as far as possible, that ICMP Datagram Too Big messages were actually generated by routers, so that attackers cannot drive the PMTU down to a falsely small value. The simplest way to do this is to verify that the Sequence Number on the ICMP error&#39;s encapsulated header corresponds to a Sequence Number that the implementation recently sent. (According to current specifications, routers should return the full DCCP header and payload up to a maximum of 576 bytes [RFC1812] or the minimum IPv6 MTU [RFC2463], although they are not required to return more than 64 bits [RFC792]. Any amount greater than 128 bits will include the Sequence Number.) ICMP Datagram Too Big messages with incorrect or missing Sequence Numbers may be ignored, or the DCCP implementation may lower the PMTU only temporarily in response. If more than three odd Datagram Too Big messages are received and the other DCCP endpoint reports more than three lost packets, however, the DCCP implementation SHOULD assume the presence of a confused router and either obey the ICMP messages&#39; PMTU or (on IPv4 networks) switch to allowing fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPの実装では、攻撃者が誤って小さな値までPMTUを駆動することができないように、ICMPデータグラムが大きすぎメッセージは、実際に、ルータによって生成されたことを、可能な限り、確保すべきです。これを実行する最も簡単な方法は、ICMPエラーのカプセル化ヘッダのシーケンス番号は、実装が最近送られたシーケンス番号に対応することを確認することです。それらは64の以上のビット[RFC792]を返すように要求されないが（現在の仕様によれば、ルータは、完全DCCPヘッダーを返すべきであり、576バイト[RFC1812]または最小のIPv6 MTU [RFC2463]の最大値までペイロード。任意128ビットを超える量は、シーケンス番号が含まれます。）正しくないか欠落しているシーケンス番号を持つICMPデータグラムが大きすぎたメッセージは無視してもよいし、DCCPの実装は応答して一時的にしかPMTUを低下させることができます。以上の3つの奇数データグラムすぎるBigメッセージが受信され、他のDCCP終点は以上3つの失われたパケットを報告した場合、しかし、DCCP実装が混乱し、ルータの存在を前提とし、いずれかのICMPメッセージPMTUに従うか、すべきである（IPv4ネットワーク上）断片化を可能に切り替えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP also allows upward probing of the PMTU [PMTUD], where the DCCP endpoint begins by sending small packets with DF set and then gradually increases the packet size until a packet is lost. This mechanism does not require any ICMP error processing. DCCP-Sync packets are the best choice for upward probing, since DCCP-Sync probes do not risk application data loss. The DCCP implementation inserts arbitrary data into the DCCP-Sync application area, padding the packet to the right length. Since every valid DCCP-Sync generates an immediate DCCP-SyncAck in response, the endpoint will have a pretty good idea of when a probe is lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPも上方DCCP終点は、DFがセットされた小さなパケットを送信することによって開始し、パケットが失われるまで、徐々にパケットサイズが増加PMTU [PMTUD]のプロービングを可能にします。このメカニズムは、任意のICMPエラー処理を必要としません。 DCCP-Syncのプローブは、アプリケーションのデータ損失のリスクはありませんので、DCCP-Syncのパケットは、上向きの探査のための最良の選択です。 DCCP実装は、正しい長さのパケットをパディング、DCCP-Syncアプリケーション領域に任意のデータを挿入します。すべての有効なDCCP-Syncは応答して即時DCCP-SyncAckを生成しているため、エンドポイントは、プローブが失われた場合のかなり良いアイデアを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. Sender Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. 送信者の行動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DCCP sender SHOULD send every packet as unfragmentable, as described above, with the following exceptions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の例外を除いて、上記のようにDCCPの送信者は、フラグメント化不能としてすべてのパケットを送信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On IPv4 connections whose applications have requested fragmentation, the sender SHOULD send packets with the DF bit not set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそのアプリケーションの断片化を要求したIPv4接続では、送信者はDFビットが設定されていないとパケットを送信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On IPv6 connections whose applications have requested fragmentation, the sender SHOULD use fragmentation extension headers to fragment packets larger than PMTU into suitably-sized chunks. (Those chunks are, of course, unfragmentable.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそのアプリケーションの断片化を要求したIPv6接続では、送信者は、適切なサイズのチャンクにPMTUより大きいパケットを断片化するフラグメンテーション拡張ヘッダを使用するべきです。 （これらのチャンクは、当然のことながら、フラグメント化不能です。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is undesirable for PMTU discovery to occur on the initial connection setup handshake, as the connection setup process may not be representative of packet sizes used during the connection, and performing MTU discovery on the initial handshake might unnecessarily delay connection establishment. Thus, DCCP-Request and DCCP-Response packets SHOULD be sent as fragmentable. In addition, DCCP-Reset packets SHOULD be sent as fragmentable, although typically these would be small enough to not be a problem. For IPv4 connections, these packets SHOULD be sent with the DF bit not set; for IPv6 connections, they SHOULD be preemptively fragmented to a size not larger than the relevant interface MTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PMTU発見は、接続設定処理は、接続中に使用されるパケットサイズの代表ではないかもしれないように、初期接続設定ハンドシェイクで発生することが、初期ハンドシェークにMTU探索を行うことが不必要に接続確立を遅らせる可能性があるため、Oそれは望ましくありません。したがって、DCCP-要求とDCCP-応答パケットがフラグメント化として送ってください。通常、これらは問題にならないほど十分に小さいだろうが、また、DCCP-リセットパケットは、フラグメント化として送ってください。 IPv4接続のために、これらのパケットはDFビットが設定されていないと送信されるべきです。 IPv6接続のために、彼らは、関連するインターフェイスMTUより大きくないサイズに先制断片化であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the DCCP implementation has decreased the PMTU, the sending application has not requested fragmentation, and the sending application attempts to send a packet larger than the new MPS, the API MUST refuse to send the packet and return an appropriate error to the application. The application should then use the API to query the new value of MPS. The kernel might have some packets buffered for transmission that are smaller than the old MPS but larger than the new MPS. It MAY send these packets as fragmentable, or it MAY discard these packets; it MUST NOT send them as unfragmentable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP実装がPMTUを減少している場合は、送信側アプリケーションは、断片化を要求していない、と送信アプリケーションが新しいMPSよりも大きいパケットを送信しようと、APIは、パケットを送信し、アプリケーションに適切なエラーを返すことを拒否しなければなりません。次に、アプリケーションは、MPSの新しい値を照会するAPIを使用する必要があります。カーネルは古いMPSよりも小さいが、新しいMPSより大きい伝送のためにバッファいくつかのパケットがあるかもしれません。これは、フラグメント化として、これらのパケットを送信することができ、またはそれは、これらのパケットを捨てるかもしれ。それは、フラグメント化不能としてそれらを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Forward Compatibility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.上位互換性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future versions of DCCP may add new options and features. A few simple guidelines will let extended DCCPs interoperate with normal DCCPs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPの将来のバージョンでは、新しいオプションと機能を追加することができます。いくつかの簡単なガイドラインは、拡張DCCPsが通常のDCCPsと相互運用できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DCCP processors MUST NOT act punitively towards options and features they do not understand. For example, DCCP processors MUST NOT reset the connection if some field marked Reserved in this specification is non-zero; if some unknown option is present; or if some feature negotiation option mentions an unknown feature. Instead, DCCP processors MUST ignore these events. The Mandatory option is the single exception: if Mandatory precedes some unknown option or feature, the connection MUST be reset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DCCPプロセッサは、彼らが理解していないオプションや機能に向けてpunitively行動してはなりません。いくつかのフィールドは、この仕様では予約がゼロでマークされている場合たとえば、DCCPプロセッサは、接続をリセットしてはいけません。いくつかの未知のオプションが存在する場合、またはいくつかの特徴交渉オプションは、未知の機能を言及している場合。代わりに、DCCPプロセッサは、これらのイベントを無視しなければなりません。必須オプションは、単一の例外である：必須のいくつかの未知のオプションや機能を先行している場合、接続をリセットする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DCCP processors MUST anticipate the possibility of unknown feature values, which might occur as part of a negotiation for a known feature. For server-priority features, unknown values are handled as a matter of course: since the non-extended DCCP&#39;s priority list will not contain unknown values, the result of the negotiation cannot be an unknown value. A DCCP MUST respond with an empty Confirm option if it is assigned an unacceptable value for some non-negotiable feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DCCPプロセッサは、既知の機能のための交渉の一環として発生する可能性のある未知の特徴値、の可能性を予測しなければなりません。サーバー優先順位の機能については、未知の値は、当然のこととして扱われる：非拡張DCCPの優先順位リストが未知の値が含まれないため、交渉の結果は未知の値にすることはできません。それはいくつかの非交渉機能のために許容できない値が割り当てられている場合DCCPは、空のConfirmオプションで応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each DCCP extension SHOULD be controlled by some feature. The default value of this feature SHOULD correspond to &#34;extension not available&#34;. If an extended DCCP wants to use the extension, it SHOULD attempt to change the feature&#39;s value using a Change L or Change R option. Any non-extended DCCP will ignore the option, thus leaving the feature value at its default, &#34;extension not available&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O各DCCP拡張子は、一部の機能によって制御されなければなりません。この機能のデフォルト値は「利用できない拡張子」に対応する必要があります。拡張DCCP拡張子を使用したい場合は、変更Lまたは変更Rオプションを使用して機能の値を変更しようとすべきです。任意の非拡張DCCPは、「拡張子が使用できない」、これはデフォルトで特徴値を残して、オプションを無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 19 lists DCCP assigned numbers reserved for experimental and testing purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実験やテストの目的のために予約セクション19本のリストDCCP割り当てられた番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. Middlebox Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.ミドルの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes properties of DCCP that firewalls, network address translators, and other middleboxes should consider, including parts of the packet that middleboxes should not change. The intent is to draw attention to aspects of DCCP that may be useful, or dangerous, for middleboxes, or that differ significantly from TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ファイアウォール、ネットワークアドレス変換、およびその他のミドルボックスは、ミドルボックスは変更されないパケットの部分を含め、検討すべきであることをDCCPのプロパティについて説明します。その意図は、ミドルボックスのために、有益な、または危険かもしれDCCPの側面に注意を引くためにある、またはそれはTCPとは大きく異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Service Code field in DCCP-Request packets provides information that may be useful for stateful middleboxes. With Service Code, a middlebox can tell what protocol a connection will use without relying on port numbers. Middleboxes can disallow connections that attempt to access unexpected services by sending a DCCP-Reset with Reset Code 8, &#34;Bad Service Code&#34;. Middleboxes should not modify the Service Code unless they are really changing the service a connection is accessing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP-Requestパケットにおけるサービスコードフィールドには、ステートフルミドルボックスのために有用である可能性がある情報を提供します。サービスコードを使用すると、ミドルは、接続がポート番号に依存せずに使用するどのようなプロトコルを伝えることができます。ミドルボックスはリセットコード8、「悪い接客規範」とDCCP-リセットを送信することにより、予期しないサービスにアクセスしようとの接続を禁止することができます。彼らは本当に接続がアクセスしているサービスを変更されない限り、ミドルボックスは、サービスコードを変更してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Source and Destination Port fields are in the same packet locations as the corresponding fields in TCP and UDP, which may simplify some middlebox implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信元と宛先ポートフィールドは、いくつかのミドル実装を簡素化する可能性がある、TCPとUDPの対応するフィールドと同じパケット位置にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The forward compatibility considerations in Section 15 apply to middleboxes as well. In particular, middleboxes generally shouldn&#39;t act punitively towards options and features they do not understand.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第15節で、前方互換性に関する考慮事項は、同様にミドルボックスに適用されます。特に、ミドルボックスは、一般的に、彼らは理解していないオプションや機能に向けてpunitively行動するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Modifying DCCP Sequence Numbers and Acknowledgement Numbers is more tedious and dangerous than modifying TCP sequence numbers. A middlebox that added packets to or removed packets from a DCCP connection would have to modify acknowledgement options, such as Ack Vector, and CCID-specific options, such as TFRC&#39;s Loss Intervals, at minimum. On ECN-capable connections, the middlebox would have to keep track of ECN Nonce information for packets it introduced or removed, so that the relevant acknowledgement options continued to have correct ECN Nonce Echoes, or risk the connection being reset for &#34;Aggression Penalty&#34;. We therefore recommend that middleboxes not modify packet streams by adding or removing packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPシーケンス番号と確認応答番号を変更すると、TCPのシーケンス番号を変更するよりも手間と危険です。 DCCP接続からのパケットまたは削除パケットを添加ミドルボックスは、最小で、そのような肯定応答ベクトル、及びそのようなTFRCの損失区間としてCCID特有のオプションとして、確認応答オプションを変更しなければなりません。 ECN対応の接続では、ミドルは、関連する確認応答オプションが正しいECNのNonceエコーズを持っている、または「侵略ペナルティ」の接続がリセットされるリスクを継続するように、それが導入または削除パケットにECNナンス情報を追跡する必要があります。したがって、我々は、ミドルボックスは、パケットを追加または削除することによって、パケットストリームを変更しないことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there is less need to modify DCCP&#39;s per-packet sequence numbers than to modify TCP&#39;s per-byte sequence numbers; for example, a middlebox can change the contents of a packet without changing its sequence number. (In TCP, sequence number modification is required to support protocols like FTP that carry variable-length addresses in the data stream. If such an application were deployed over DCCP, middleboxes would simply grow or shrink the relevant packets as necessary without changing their sequence numbers. This might involve fragmenting the packet.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPのバイトあたりのシーケンス番号を変更するよりも、DCCPのパケットごとのシーケンス番号を変更するには以下が必要であることに注意してください。例えば、ミドルボックスは、そのシーケンス番号を変更することなく、パケットの内容を変更することができます。 （TCPでは、シーケンス番号の変更は、データストリーム内の可変長アドレスを運ぶFTPなどのプロトコルをサポートする必要がある。そのようなアプリケーションがDCCP上に展開した場合、中間装置は、単に、それらのシーケンス番号を変更することなく、必要に応じて、関連するパケットを拡大または縮小なります。これは、パケットを断片伴うかもしれません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Middleboxes may, of course, reset connections in progress. Clearly, this requires inserting a packet into one or both packet streams, but the difficult issues do not arise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Middleboxesは、当然のことながら、進行中の接続をリセットすることがあります。明らかに、これは一方または両方のパケット・ストリームにパケットを挿入する必要がありますが、困難な問題は発生しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP is somewhat unfriendly to &#34;connection splicing&#34; [SHHP00], in which clients&#39; connection attempts are intercepted, but possibly later &#34;spliced in&#34; to external server connections via sequence number manipulations. A connection splicer at minimum would have to ensure that the spliced connections agreed on all relevant feature values, which might take some renegotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは、クライアントの接続試行をインターセプトが、おそらく後シーケンス番号の操作を介して、外部のサーバー接続へ 『にスプライスさ』された「接続スプライシング」[SHHP00]、幾分非友好的です。最低でも接続スプライサーは、スプライシングされた接続は、いくつかの再交渉がかかる場合があります関連するすべての特徴値、に合意したことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this section should not be interpreted as a wholesale endorsement of stateful middleboxes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの内容は、ステートフルミドルボックスの卸売承認として解釈されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Relations to Other Specifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
他の仕様との関係17
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. RTP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1.  RTP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Real-Time Transport Protocol, RTP [RFC3550], is currently used over UDP by many of DCCP&#39;s target applications (for instance, streaming media). Therefore, it is important to examine the relationship between DCCP and RTP and, in particular, the question of whether any changes in RTP are necessary or desirable when it is layered over DCCP instead of UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リアルタイムトランスポートプロトコル、RTP [RFC3550]は、現在、（例えば、ストリーミングメディア）DCCPのターゲットアプリケーションの多くでUDP上で使用されています。したがって、DCCPおよびRTPおよび、特に、それはDCCPの代わりにUDP上に積層されたときRTPの変更が必要又は望ましいかどうかの問題との関係を検討することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two potential sources of overhead in the RTP-over-DCCP combination: duplicated acknowledgement information and duplicated sequence numbers. Together, these sources of overhead add slightly more than 4 bytes per packet relative to RTP-over-UDP, and eliminating the redundancy would not reduce the overhead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重複確認応答情報と重複配列番号：2つのRTPオーバーDCCPの組み合わせでオーバーヘッドの潜在的な原因があります。一緒に、オーバーヘッドのこれらのソースは、RTPオーバーUDPパケットに比べ当たりわずかに4よりバイトを追加し、冗長性を排除することはオーバーヘッドを削減しないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, consider acknowledgements. Both RTP and DCCP report feedback about loss rates to data senders, via RTP Control Protocol Sender and Receiver Reports (RTCP SR/RR packets) and via DCCP acknowledgement options. These feedback mechanisms are potentially redundant. However, RTCP SR/RR packets contain information not present in DCCP acknowledgements, such as &#34;interarrival jitter&#34;, and DCCP&#39;s acknowledgements contain information not transmitted by RTCP, such as the ECN Nonce Echo. Neither feedback mechanism makes the other redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、確認応答を考えます。 RTPとRTP制御プロトコルのSenderとReceiverレポート（RTCP SR / RRパケット）を経由し、DCCPの承認オプションを介してデータの送信者への損失率についてDCCPレポートフィードバック、どちらも。これらのフィードバック機構は、潜在的に冗長です。しかし、RTCP SR / RRパケットは、「到着間ジッタ」としてDCCP確認応答、に存在しない情報を含み、DCCPの肯定応答は、ECNノンスエコーとしてRTCPによって送信されない情報を含みます。どちらのフィードバック機構は、他の冗長になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sending both types of feedback need not be particularly costly either. RTCP reports may be sent relatively infrequently: once every 5 seconds on average, for low-bandwidth flows. In DCCP, some feedback mechanisms are expensive -- Ack Vector, for example, is frequent and verbose -- but others are relatively cheap: CCID 3 (TFRC) acknowledgements take between 16 and 32 bytes of options sent once per round-trip time. (Reporting less frequently than once per RTT would make congestion control less responsive to loss.) We therefore conclude that acknowledgement overhead in RTP-over-DCCP need not be significantly higher than for RTP-over-UDP, at least for CCID 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバックの両方のタイプを送信すると、いずれか、特に、高価である必要はありません。 RTCPレポートは、比較的低い頻度で送信されてよい：5秒ごとの平均で、低帯域幅のフローのために。 DCCPでは、いくつかのフィードバック機構は高価である - のAckベクトルは、例えば、頻繁に冗長である - しかし、他のものは、比較的安価である：CCID 3（TFRC）確認応答は、ラウンドトリップ時間ごとに一度送信されたオプションの16と32バイトとの間に取ります。 （それほど頻繁に一度RTTあたりより報告は損失に輻輳制御はあまり反応するだろう。）したがって、我々は、RTPオーバーDCCPに確認応答のオーバーヘッドを締結少なくともCCID 3のために、RTPオーバーUDPに比べて有意に高くある必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One clear redundancy can be addressed at the application level. The verbose packet-by-packet loss reports sent in RTCP Extended Reports Loss RLE Blocks [RFC3611] can be derived from DCCP&#39;s Ack Vector options. (The converse is not true, since Loss RLE Blocks contain no ECN information.) Since DCCP implementations should provide an API for application access to Ack Vector information, RTP-over-DCCP applications might request either DCCP Ack Vectors or RTCP Extended Report Loss RLE Blocks, but not both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つの明確な冗長性は、アプリケーションレベルで対処することができます。 RTCP拡張レポート消失RLEブロック[RFC3611]で送信された冗長パケットごとの損失レポートはDCCPのAckをベクトルオプションから導出することができます。 （損失RLEブロックは何のECN情報を含んでいないので、逆は真ではありません。）DCCPの実装がAckでベクトル情報へのアプリケーションアクセスのためのAPIを提供しなければならないので、RTPオーバーDCCPアプリケーションがDCCPのAckなベクターまたはRTCPのいずれかの拡張レポート損失RLEを要求するかもしれませんブロック、両方ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now consider sequence number redundancy on data packets. The embedded RTP header contains a 16-bit RTP sequence number. Most data packets will use the DCCP-Data type; DCCP-DataAck and DCCP-Ack packets need not usually be sent. The DCCP-Data header is 12 bytes long without options, including a 24-bit sequence number. This is 4 bytes more than a UDP header. Any options required on data packets would add further overhead, although many CCIDs (for instance, CCID 3, TFRC) don&#39;t require options on most data packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
今、データパケットのシーケンス番号の冗長性を考慮してください。埋め込まれたRTPヘッダは、16ビットのRTPシーケンス番号を含みます。ほとんどのデータ・パケットは、DCCP-データ型を使用します。 DCCP-DataAckとDCCP-Ackのパケットが送信され、通常は必要はありません。 DCCP-データヘッダは、24ビットのシーケンス番号を含むオプションなしで12バイト長です。これは、UDPヘッダより4バイト以上です。多くのCCIDs（例えば、CCID 3、TFRC）は、ほとんどのデータ・パケットのオプションを必要としませんが、データパケットに必要なオプションは、さらにオーバーヘッドを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DCCP sequence number cannot be inferred from the RTP sequence number since it increments on non-data packets as well as data packets. The RTP sequence number cannot be inferred from the DCCP sequence number either [RFC3550]. Furthermore, removing RTP&#39;s sequence number would not save any header space because of alignment issues. We therefore recommend that RTP transmitted over DCCP use the same headers currently defined. The 4 byte header cost is a reasonable tradeoff for DCCP&#39;s congestion control features and access to ECN. Truly bandwidth-starved endpoints should use some header compression scheme.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは非データ・パケットとデータ・パケットにインクリメントするので、DCCPシーケンス番号は、RTPシーケンス番号から推測することができません。 RTPシーケンス番号は、DCCP配列番号のいずれか[RFC3550]から推論することはできません。さらに、RTPのシーケンス番号を削除すると、理由は、アライメントの問題のいずれかのヘッダースペースを保存しないでしょう。したがって、我々は、DCCPを介して送信RTPは、現在定義されている同じヘッダーを使用することをお勧めします。 4バイトのヘッダコストはDCCPの輻輳制御機能やECNへのアクセスのための合理的なトレードオフです。真に帯域飢餓エンドポイントは、いくつかのヘッダ圧縮スキームを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. Congestion Manager and Multiplexing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. 輻輳管理および多重化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since DCCP doesn&#39;t provide reliable, ordered delivery, multiple application sub-flows may be multiplexed over a single DCCP connection with no inherent performance penalty. Thus, there is no need for DCCP to provide built-in support for multiple sub-flows. This differs from SCTP [RFC2960].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは信頼性が得られないため、配信を命じ、複数のアプリケーションのサブフローはない本来の性能ペナルティを有する単一のDCCP接続を介して多重化されてもよいです。このように、DCCPは、複数のサブフローのビルトインサポートを提供するための必要はありません。これは、SCTP [RFC2960]とは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications might want to share congestion control state among multiple DCCP flows that share the same source and destination addresses. This functionality could be provided by the Congestion Manager [RFC3124], a generic multiplexing facility. However, the CM would not fully support DCCP without change; it does not gracefully handle multiple congestion control mechanisms, for example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションは、同じ送信元アドレスと宛先アドレスを共有する複数のDCCPの流れの中で輻輳制御状態を共有したい場合があります。この機能は、輻輳マネージャ[RFC3124]、一般的な多重化機能によって提供することができます。しかし、CMは完全に変更することなく、DCCPをサポートしていません。それは優雅例えば、複数の輻輳制御機構を扱いません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP does not provide cryptographic security guarantees. Applications desiring cryptographic security services (integrity, authentication, confidentiality, access control, and anti-replay protection) should use IPsec or end-to-end security of some kind; Secure RTP is one candidate protocol [RFC3711].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは、暗号化セキュリティ保証を提供していません。暗号化セキュリティサービス（整合性、認証、機密性、アクセス制御、およびアンチリプレイ保護を）希望するアプリケーションは、IPsecを使用するか、いくつかの種類のエンドツーエンドのセキュリティ必要があります。セキュアRTPは、一つの候補プロトコル[RFC3711]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nevertheless, DCCP is intended to protect against some classes of attackers: Attackers cannot hijack a DCCP connection (close the connection unexpectedly, or cause attacker data to be accepted by an endpoint as if it came from the sender) unless they can guess valid sequence numbers. Thus, as long as endpoints choose initial sequence numbers well, a DCCP attacker must snoop on data packets to get any reasonable probability of success. Sequence number validity checks provide this guarantee. Section 7.5.5 describes sequence number security further. This security property only holds assuming that DCCP&#39;s random numbers are chosen according to the guidelines in [RFC4086].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにも関わらず、DCCPは攻撃のいくつかのクラスに対して保護することを意図している：彼らは、有効なシーケンス番号を推測することができない限り、攻撃者は、DCCPコネクション（予期せず接続を閉じ、またはそれは、送信者から来たかのように攻撃者のデータは、エンドポイントで受け入れられるために原因を）乗っ取ることができません。このように、エンドポイントがうまく初期シーケンス番号を選択する限り、DCCPの攻撃者は、成功のいずれかの合理的な確率を取得するために、データパケットをスヌーピングしなければなりません。シーケンス番号の有効性チェックは、この保証を提供しています。 7.5.5項では、さらに、シーケンス番号のセキュリティを説明します。このセキュリティプロパティは、DCCPの乱数は、[RFC4086]のガイドラインに従って選択されていると仮定して保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP also provides mechanisms to limit the potential impact of some denial-of-service attacks. These mechanisms include Init Cookie (Section 8.1.4), the DCCP-CloseReq packet (Section 5.5), the Application Not Listening Drop Code (Section 11.7.2), limitations on the processing of options that might cause connection reset (Section 7.5.5), limitations on the processing of some ICMP messages (Section 14.1), and various rate limits, which let servers avoid extensive computation or packet generation (Sections 7.5.3, 8.1.3, and others).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPはまた、いくつかのサービス拒否攻撃の潜在的な影響を制限するためのメカニズムを提供します。これらのメカニズムは、初期クッキー（セクション8.1.4）、DCCP-CloseReqパケット（5.5節）、ドロップコード（セクション11.7.2）を聞いていないアプリケーションを含む、接続リセット（7.5節を引き起こす可能性がありますオプションの処理に関する制限。 5）サーバをさせ、いくつかのICMPメッセージ（セクション14.1）、および種々のレート制限の処理上の制限は広範計算やパケット生成（セクション7.5.3、8.1.3など）を避けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP provides no protection against attackers that can snoop on data packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは、データパケットをスヌーピングすることができ、攻撃者に対する保護機能はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. Security Considerations for Partial Checksums
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. 部分的なチェックサムのためのセキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The partial checksum facility has a separate security impact, particularly in its interaction with authentication and encryption mechanisms. The impact is the same in DCCP as in the UDP-Lite protocol, and what follows was adapted from the corresponding text in the UDP-Lite specification [RFC3828].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
部分的なチェックサム機能は、特に認証と暗号化メカニズムとの相互作用では、個別のセキュリティ影響を有します。衝撃は、UDP-LiteのプロトコルとDCCPに同じであり、何以下がUDP-Liteの仕様[RFC3828]に対応するテキストから適合させました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a DCCP packet&#39;s Checksum Coverage field is not zero, the uncovered portion of a packet may change in transit. This is contrary to the idea behind most authentication mechanisms: authentication succeeds if the packet has not changed in transit. Unless authentication mechanisms that operate only on the sensitive part of packets are developed and used, authentication will always fail for partially-checksummed DCCP packets whose uncovered part has been damaged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPパケットのチェックサムカバー範囲フィールドが0でない場合、パケットの覆われていない部分は、輸送中に変更されることがあります。これは、ほとんどの認証メカニズムの背後にある考え方に反している：パケットが転送中に変更されていない場合、認証に成功しました。パケットの敏感な部分にのみ動作認証機構が開発され使用されていない限り、認証は常にその覆われていない一部損傷した部分的にチェックサムDCCPパケットのために失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPsec integrity check (Encapsulation Security Protocol, ESP, or Authentication Header, AH) is applied (at least) to the entire IP packet payload. Corruption of any bit within that area will then result in the IP receiver&#39;s discarding a DCCP packet, even if the corruption happened in an uncovered part of the DCCP application data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsecの整合性チェック（カプセル化セキュリティプロトコル、ESP、または認証ヘッダー、AH）は、全IPパケットのペイロードに（少なくとも）を適用しています。その領域内の任意のビットの破損は、破損がDCCPアプリケーションデータの覆われていない部分で起こった場合でも、IPの受信機の廃棄DCCPパケットになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When IPsec is used with ESP payload encryption, a link can not determine the specific transport protocol of a packet being forwarded by inspecting the IP packet payload. In this case, the link MUST provide a standard integrity check covering the entire IP packet and payload. DCCP partial checksums provide no benefit in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsecはESPペイロードの暗号化で使用されている場合、リンクがIPパケットのペイロードを検査することにより、転送されるパケットの特定のトランスポートプロトコルを決定することはできません。この場合、リンクはIPパケット全体とペイロードをカバーする標準の整合性チェックを提供しなければなりません。 DCCP部分的なチェックサムは、この場合には利益を提供しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encryption (e.g., at the transport or application levels) may be used. Note that omitting an integrity check can, under certain circumstances, compromise confidentiality [B98].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（トランスポートまたはアプリケーションレベルで例えば）暗号化を使用することができます。 [B98]整合性チェックを省略すると、特定の状況下で、機密性を損なう可能性があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a few bits of an encrypted packet are damaged, the decryption transform will typically spread errors so that the packet becomes too damaged to be of use. Many encryption transforms today exhibit this behavior. There exist encryption transforms, stream ciphers, that do not cause error propagation. Proper use of stream ciphers can be quite difficult, especially when authentication checking is omitted [BB01]. In particular, an attacker can cause predictable changes to the ultimate plaintext, even without being able to decrypt the ciphertext.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化されたパケットの数ビットが破損している場合は、パケットが有用であることがあまりにも破損したように、復号化は一般的にエラーが広がっていく変換します。多くの暗号化は、今日はこの挙動を示す変換します。エラー伝播を引き起こさない暗号化変換、ストリーム暗号は、存在します。ストリーム暗号の適切な使用は、認証チェックは、[BB01]省略されている場合は特に、非常に難しいことができます。具体的には、攻撃者がさえ暗号文を解読できず、最終的に平文に予測可能な変化を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has assigned IP Protocol Number 33 to DCCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、DCCPにIPプロトコル番号33を割り当てています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP introduces eight sets of numbers whose values should be allocated by IANA. We refer to allocation policies, such as Standards Action, outlined in [RFC2434], and most registries reserve some values for experimental and testing use [RFC3692]. In addition, DCCP requires that the IANA Port Numbers registry be opened for DCCP port registrations; Section 19.9 describes how. The IANA should feel free to contact the DCCP Expert Reviewer with questions on any registry, regardless of the registry policy, for clarification or if there is a problem with a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPは値IANAによって割り当てられるべき数字の8セットを紹介します。私たちは、[RFC2434]に概説され、このような標準化アクションとして割り当てポリシー、を参照してください、そしてほとんどのレジストリは、実験と[RFC3692]を使用してテストするためのいくつかの値を予約します。また、DCCPは、IANAポート番号のレジストリがDCCPポートの登録のために開かれることを必要とします。セクション19.9はどのように説明しています。 IANAは、明確化のためにまたは要求に問題がある場合は、関係なく、レジストリポリシーの、いずれかのレジストリ上の質問でDCCPエキスパートレビューに連絡して自由に感じるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1. Packet Types Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1. パケットタイプレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each entry in the DCCP Packet Types registry contains a packet type, which is a number in the range 0-15; a packet type name, such as DCCP-Request; and a reference to the RFC defining the packet type. The registry is initially populated using the values in Table 1 (Section 5.1). This document allocates packet types 0-9, and packet type 14 is permanently reserved for experimental and testing use. Packet types 10-13 and 15 are currently reserved and should be allocated with the Standards Action policy, which requires IESG review and approval and standards-track IETF RFC publication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPパケットタイプレジストリ内の各エントリは、0〜15の数であり、パケットタイプを含み、このようDCCP-要求などのパケットタイプ名;パケットタイプを定義するRFCを参照。レジストリは、最初の表1（セクション5.1）の値を使用して取り込まれます。この文書では、パケットタイプ0-9を割り当て、パケットタイプ14は、永久に、実験やテストの使用のために予約されています。パケットタイプ10-13および15は、現在予約されており、IESGレビューと承認を必要とし、IETF RFC公表を標準トラック標準アクションポリシー、で割り当てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2. Reset Codes Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2. コードレジストリをリセット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each entry in the DCCP Reset Codes registry contains a Reset Code, which is a number in the range 0-255; a short description of the Reset Code, such as &#34;No Connection&#34;; and a reference to the RFC defining the Reset Code. The registry is initially populated using the values in Table 2 (Section 5.6). This document allocates Reset Codes 0-11, and Reset Codes 120-126 are permanently reserved for experimental and testing use. Reset Codes 12-119 and 127 are currently reserved and should be allocated with the IETF Consensus policy, requiring an IETF RFC publication (standards track or not) with IESG review and approval. Reset Codes 128-255 are permanently reserved for CCID-specific registries; each CCID Profile document describes how the corresponding registry is managed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPの各エントリは、レジストリは、0〜255の範囲内の数であり、リセットコードを含み、コードをリセット。そのような「接続なし」としてリセットコードの短い説明。そして、リセットコードを定義するRFCへの参照。レジストリは、最初の表2（セクション5.6）の値を使用して取り込まれます。この文書では、リセットコード0-11を割り当て、120-126は、永久に、実験やテストの使用のために予約されているコードをリセットします。コード12から119及び127は、現在予約されており、IESGレビューと承認を得てIETF RFC刊行物（標準化過程かどうか）を必要とする、IETFコンセンサスポリシーに割り当てるべきリセット。 128-255は、永久にCCID特有の登録簿のために予約されているコードをリセットします。各CCIDプロフィール文書は、対応するレジストリが管理されている方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.3. Option Types Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.3. オプションの種類レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each entry in the DCCP option types registry contains an option type, which is a number in the range 0-255; the name of the option, such as &#34;Slow Receiver&#34;; and a reference to the RFC defining the option type. The registry is initially populated using the values in Table 3 (Section 5.8). This document allocates option types 0-2 and 32-44,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPオプションタイプレジストリ内の各エントリは、0〜255の範囲内の数であり、オプションタイプを含み、そのような「スローレシーバー」としてオプションの名前、;およびオプションタイプを定義するRFCへの参照。レジストリは、最初の表3（セクション5.8）の値を使用して取り込まれます。この文書では、オプションの種類0-2と32-44割り当て
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and option types 31 and 120-126 are permanently reserved for experimental and testing use. Option types 3-30, 45-119, and 127 are currently reserved and should be allocated with the IETF Consensus policy, requiring an IETF RFC publication (standards track or not) with IESG review and approval. Option types 128-255 are permanently reserved for CCID-specific registries; each CCID Profile document describes how the corresponding registry is managed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
およびオプションの種類31および120-126は、永久に、実験やテスト用に予約されています。オプションの種類3-30、45から119、及び127は、現在予約されており、IESGレビューと承認を得てIETF RFC刊行物（標準化過程かどうか）を必要とする、IETFコンセンサスポリシーに割り当てられるべきです。オプションタイプ128-255は恒久的にCCID特有の登録簿のために予約されています。各CCIDプロフィール文書は、対応するレジストリが管理されている方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4. Feature Numbers Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.4. フィーチャー番号レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each entry in the DCCP feature numbers registry contains a feature number, which is a number in the range 0-255; the name of the feature, such as &#34;ECN Incapable&#34;; and a reference to the RFC defining the feature number. The registry is initially populated using the values in Table 4 (Section 6). This document allocates feature numbers 0-9, and feature numbers 120-126 are permanently reserved for experimental and testing use. Feature numbers 10-119 and 127 are currently reserved and should be allocated with the IETF Consensus policy, requiring an IETF RFC publication (standards track or not) with IESG review and approval. Feature numbers 128-255 are permanently reserved for CCID-specific registries; each CCID Profile document describes how the corresponding registry is managed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP機能番号レジストリ内の各エントリは、0〜255の範囲内の数である機能数が含まれ;こうした「ECNできない」などの機能の名前、;そして、機能番号を定義するRFCへの参照。レジストリは、最初の表4（第6節）の値を使用して取り込まれます。この文書では、機能番号0-9、および120-126は、永久に、実験やテストの使用のために予約されている機能番号を割り当てます。機能番号10から119及び127は、現在予約されており、IESGレビューと承認を得てIETF RFC刊行物（標準化過程かどうか）を必要とする、IETFコンセンサスポリシーに割り当てられるべきです。フィーチャー番号128-255は、恒久的にCCID特有の登録簿のために予約されています。各CCIDプロフィール文書は、対応するレジストリが管理されている方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.5. Congestion Control Identifiers Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.5. 輻輳制御識別子レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each entry in the DCCP Congestion Control Identifiers (CCIDs) registry contains a CCID, which is a number in the range 0-255; the name of the CCID, such as &#34;TCP-like Congestion Control&#34;; and a reference to the RFC defining the CCID. The registry is initially populated using the values in Table 5 (Section 10). CCIDs 2 and 3 are allocated by concurrently published profiles, and CCIDs 248-254 are permanently reserved for experimental and testing use. CCIDs 0, 1, 4-247, and 255 are currently reserved and should be allocated with the IETF Consensus policy, requiring an IETF RFC publication (standards track or not) with IESG review and approval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP輻輳制御識別子（のCCIDs）内の各エントリは、レジストリは、0〜255の範囲の数でありCCIDを含み、例えば、「TCP-のような輻輳制御」などCCIDの名前、;そしてCCIDを定義するRFCを参照。レジストリは、最初の表5（第10項）の値を使用して取り込まれます。 CCIDs 2及び3を同時に公開されたプロファイルによって割り当てられ、そして248-254のCCIDsは恒久的実験および試験使用のために予約されています。 CCIDs 0、1、4から247、および255は、現在予約されており、IESGレビューと承認を得てIETF RFC刊行物（標準化過程かどうか）を必要とする、IETFコンセンサスポリシーに割り当てられるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.6. Ack Vector States Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.6.  Ackベクトル州レジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each entry in the DCCP Ack Vector States registry contains an Ack Vector State, which is a number in the range 0-3; the name of the State, such as &#34;Received ECN Marked&#34;; and a reference to the RFC defining the State. The registry is initially populated using the values in Table 6 (Section 11.4). This document allocates States 0, 1, and 3. State 2 is currently reserved and should be allocated with the Standards Action policy, which requires IESG review and approval and standards-track IETF RFC publication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPのAckベクトル国レジストリの各エントリは、範囲0〜3の数字であるのAckベクトルの状態を、含まれています。以下のような国の名前は、「ECNはマーク、受信しました」;そして、状態を定義するRFCへの参照。レジストリは、最初の表6（セクション11.4）の値を使用して取り込まれます。この文書は、米国0、1を割り当て、3ステート2は、現在予約されており、IESGレビューと承認を必要とし、IETF RFC公表を標準トラック標準アクションポリシー、で割り当てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.7. Drop Codes Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.7. ドロップコードレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each entry in the DCCP Drop Codes registry contains a Data Dropped Drop Code, which is a number in the range 0-7; the name of the Drop Code, such as &#34;Application Not Listening&#34;; and a reference to the RFC defining the Drop Code. The registry is initially populated using the values in Table 7 (Section 11.7). This document allocates Drop Codes 0-3 and 7. Drop Codes 4-6 are currently reserved, and should be allocated with the Standards Action policy, which requires IESG review and approval and standards-track IETF RFC publication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPドロップコードレジストリの各エントリは、データが範囲0-7で数あるドロップコードを、ドロップ含まれています。例えば、「聞いていないアプリケーション」としてドロップコードの名前、;ドロップコードを定義するRFCへの参照。レジストリは、最初の表7（セクション11.7）の値を使用して取り込まれます。この文書では、ドロップコード0-3と7ドロップコードを4-6割り当て、現在予約されている、とIESGレビューと承認を必要とし、IETF RFC公表を標準トラック標準アクションポリシー、で割り当てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.8. Service Codes Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.8. サービスコードレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each entry in the Service Codes registry contains a Service Code, which is a number in the range 0-4294967294; a short English description of the intended service; and an optional reference to an RFC or other publicly available specification defining the Service Code. The registry should list the Service Code&#39;s numeric value as a decimal number. When the Service Code may be represented in &#34;SC:&#34; format according to the rules in Section 8.1.2, the registry should also show the corresponding ASCII interpretation of the Service Code minus the &#34;SC:&#34; prefix. Thus, the number 1717858426 would additionally appear as &#34;fdpz&#34;. Service Codes are not DCCP-specific. Service Code 0 is permanently reserved (it represents the absence of a meaningful Service Code), and Service Codes 1056964608-1073741823 (high byte ASCII &#34;?&#34;) are reserved for Private Use. Note that 4294967295 is not a valid Service Code. Most of the remaining Service Codes are allocated First Come First Served, with no RFC publication required; exceptions are listed in Section 8.1.2. This document allocates a single Service Code, 1145656131 (&#34;DISC&#34;). This corresponds to the discard service, which discards all data sent to the service and sends no data in reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サービスコードレジストリの各エントリには、0から4294967294の範囲の数値であるサービスコードを、含まれています。意図したサービスの短い英語の説明。そしてRFCまたは他の公的に利用可能な仕様に任意の参照は、サービスコードを定義します。レジストリは、10進数としてサービスコードの数値をリストする必要があります。サービスコードは「SC：」で表すことができるとき：接頭辞8.1.2項の規則に従ってフォーマット、レジストリはまた、サービスコードの対応するASCII解釈マイナス「SC」を示す必要があります。このように、番号1717858426は、さらに「fdpz」と表示されます。サービスコードは、DCCP-固有のものではありません。サービスコード0は永久に1056964608から1073741823（高バイトのASCII「？」）（それは意味のあるサービスコードが存在しないことを表して）予約、およびサービスコードされた私的使用のために予約されています。 4294967295が有効なサービスコードではないことに注意してください。残りのサービスコードのほとんどは、まず不要RFCの公表で、添え最初に来る割り当てられています。例外は、セクション8.1.2に記載されています。この文書は、単一のサービスコード、1145656131（「DISC」）を割り当てます。これは、サービスに送信されたすべてのデータを破棄し、応答ではデータを送信していない廃棄サービスに対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.9. Port Numbers Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.9. ポート番号のレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCP services may use contact port numbers to provide service to unknown callers, as in TCP and UDP. IANA is therefore requested to open the existing Port Numbers registry for DCCP using the following rules, which we intend to mesh well with existing Port Numbers registration procedures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCCPのサービスは、TCPやUDPのように、未知の発信者にサービスを提供するために、連絡先のポート番号を使用することができます。 IANAは、したがって、我々は既存のポート番号の登録手順とよくメッシュしようとする次のルールを使用して、DCCPのための既存のポート番号のレジストリを開くように要求されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Port numbers are divided into three ranges. The Well Known Ports are those from 0 through 1023, the Registered Ports are those from 1024 through 49151, and the Dynamic and/or Private Ports are those from 49152 through 65535. Well Known and Registered Ports are intended for use by server applications that desire a default contact point on a system. On most systems, Well Known Ports can only be used by system (or root) processes or by programs executed by privileged users, while Registered Ports can be used by ordinary user processes or programs executed by ordinary users. Dynamic and/or Private Ports are intended for temporary use, including client-side ports, out-of-band negotiated ports, and application testing prior to registration of a dedicated port; they MUST NOT be registered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポート番号は、3つの範囲に分割されています。ウェルノウンポートが1023の0からのものであり、登録されたポートは、1024から49151によるものであり、かつ動的および/またはプライベートポート、よく知られており、登録されたポートは、サーバーアプリケーションでの使用を目的としている〜65535 49152からのものであり、望むことシステムのデフォルトの接触点。登録ポートは、通常のユーザープロセスか、通常のユーザーによって実行されるプログラムで使用することができながら、ほとんどのシステムでは、ウェルノウンポートのみが、システム（またはルート）プロセスによって、または特権ユーザーによって実行されるプログラムで使用することができます。動的および/またはプライベートポートは一時的な使用のために意図されている、専用ポートの登録に先立って、クライアント側のポート、アウトバンド交渉し、ポート、およびアプリケーションのテストを含みます。彼らは、登録してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Port Numbers registry should accept registrations for DCCP ports in the Well Known Ports and Registered Ports ranges. Well Known and Registered Ports SHOULD NOT be used without registration. Although in some cases -- such as porting an application from UDP to DCCP -- it may seem natural to use a DCCP port before registration completes, we emphasize that IANA will not guarantee registration of particular Well Known and Registered Ports. Registrations should be requested as early as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポート番号のレジストリは、ウェルノウンポートと登録済みポートの範囲のDCCPポートの登録を受け入れる必要があります。よく知られており、登録されたポートは、登録なしで使用されるべきではありません。そのようなUDPからDCCPにアプリケーションを移植など -   - いくつかのケースではあるが、それは登録が完了する前にDCCPポートを使用するように自然に見えるかもしれませんが、私たちは、IANAが特定のよく知られており、登録されたポートの登録を保証するものではありませんことを強調する。登録は可能な限り早期に要求されるべき。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each port registration SHALL include the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ポートの登録は、以下の情報を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   o  A short port name, consisting entirely of letters (A-Z and a-z),
      digits (0-9), and punctuation characters from &#34;-_+./*&#34; (not
      including the quotes).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The port number that is requested to be registered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O要求されているポート番号を登録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A short English phrase describing the port&#39;s purpose. This MUST include one or more space-separated textual Service Code descriptors naming the port&#39;s corresponding Service Codes (see Section 8.1.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポートの目的を説明する短い英語フレーズO。これは、（8.1.2項を参照）、ポートの対応するサービスコードを命名一つ以上のスペースで区切られたテキスト形式のサービスコードの記述子を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Name and contact information for the person or entity performing the registration, and possibly a reference to a document defining the port&#39;s use. Registrations coming from IETF working groups need only name the working group, but indicating a contact person is recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの名前と、おそらく個人または団体登録を実行し、ポートの使用を定義するドキュメントへの参照のための連絡先情報。 IETFワーキンググループからの登録は、ワーキンググループに名前を付ける必要はなく、担当者を示すことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registrants are encouraged to follow these guidelines when submitting a registration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録者は、登録を提出する際のガイドラインに従うことを奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A port name SHOULD NOT be registered for more than one DCCP port number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oポート名は、複数のDCCPポート番号に登録されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A port name registered for UDP MAY be registered for DCCP as well. Any such registration SHOULD use the same port number as the existing UDP registration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O UDPのために登録されているポート名は、同様にDCCPのために登録することも可能です。任意のそのような登録は、既存のUDPの登録と同じポート番号を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Concrete intent to use a port SHOULD precede port registration. For example, existing UDP ports SHOULD NOT be registered in advance of any intent to use those ports for DCCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oポートを使用するための具体的な目的は、ポートの登録を先行すべき。例えば、既存のUDPポートはDCCPのために、これらのポートを使用するための任意の意思を事前に登録されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A port name generally associated with TCP and/or SCTP SHOULD NOT be registered for DCCP, since that port name implies reliable transport. For example, we discourage registration of any &#34;http&#34; port for DCCP. However, if such a registration makes sense (that is, if there is concrete intent to use such a port), the DCCP registration SHOULD use the same port number as the existing registration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのポート名が信頼できる輸送を意味するので、O、一般的にTCPおよび/またはSCTPに関連付けられているポート名は、DCCPのために登録されるべきではありません。たとえば、私たちはDCCPのための任意の「HTTP」のポートの登録を阻止します。そのような登録が（例えばポートを使用するための具体的な意図がある場合には、である）理にかなっている場合は、DCCP登録は、既存の登録と同じポート番号を使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Multiple DCCP registrations for the same port number are allowed as long as the registrations&#39; Service Codes do not overlap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oポート番号と同じ番号に複数のDCCP登録は限り登録サービスコードが重複しないよう許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document registers the following port. (This should be considered a model registration.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、次のポートを登録します。 （これは、モデル登録考慮されるべきです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
discard 9/dccp Discard SC:DISC # IETF dccp WG, Eddie Kohler &lt;kohler@cs.ucla.edu&gt;, [RFC4340]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DISC＃IETF DCCP WG、エディコーラー&lt;kohler@cs.ucla.edu&gt;、[RFC4340]：9 / DCCP破棄SCを破棄
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The discard service, which accepts DCCP connections on port 9, discards all incoming application data and sends no data in response. Thus, DCCP&#39;s discard port is analogous to TCP&#39;s discard port, and might be used to check the health of a DCCP stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポート9にDCCP接続を受け入れる廃棄サービスは、すべての着信アプリケーションデータを破棄し、それに応答してもデータを送信しません。このように、DCCPの廃棄ポートは、TCPの廃棄ポートに類似しており、DCCPスタックの健康状態をチェックするために使用される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. Thanks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.感謝
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Jitendra Padhye for his help with early versions of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様の初期のバージョンとの彼の助けのためのJitendra Padhyeに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Junwen Lai and Arun Venkataramani, who, as interns at ICIR, built a prototype DCCP implementation. In particular, Junwen Lai recommended that the old feature negotiation mechanism be scrapped and co-designed the current mechanism. Arun Venkataramani&#39;s feedback improved Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICIRでインターンとして、原型DCCPの実装を構築し、JunwenライとアルンVenkataramani、に感謝します。特に、Junwenライが古い特徴交渉メカニズムは、現在のメカニズムを廃棄し、共同設計されることをお勧めします。アルンVenkataramaniのフィードバック改善付録A.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We thank the staff and interns of ICIR and, formerly, ACIRI, the members of the End-to-End Research Group, and the members of the Transport Area Working Group for their feedback on DCCP. We especially thank the DCCP expert reviewers Greg Minshall, Eric Rescorla, and Magnus Westerlund for detailed written comments and problem spotting, and Rob Austein and Steve Bellovin for verbal comments and written notes. We also especially thank Aaron Falk, the working group chair during the development of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちはDCCPの彼らのフィードバックのために、以前は、ACIRI、エンド・ツー・エンドの研究グループのメンバー、および交通地域作業部会のメンバーがスタッフとICIRのインターンに感謝して。我々は、特に口頭コメントと書かれたノートを詳細に書かれたコメントや問題スポッティングのためにDCCPの専門家の査読グレッグMinshall、エリックレスコラ、およびマグヌスウェスターに感謝し、そしてロブAusteinとスティーブBellovin氏。我々はまた、特にアーロンフォーク、この仕様の開発中にワーキンググループの議長に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We also thank those who provided comments and suggestions via the DCCP BOF, Working Group, and mailing lists, including Damon Lanphear, Patrick McManus, Colin Perkins, Sara Karlberg, Kevin Lai, Bernard Aboba, Youngsoo Choi, Pengfei Di, Dan Duchamp, Lars Eggert, Gorry Fairhurst, Derek Fawcus, David Timothy Fleeman, John Loughney, Ghyslain Pelletier, Hagen Paul Pfeifer, Tom Phelan, Stanislav
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、デイモンLanphear、パトリック・マクマナス、コリンパーキンス、サラKarlberg、ケビン・ライ、バーナードAboba、Youngsooチェ、鵬飛ディ、ダン・デュシャン、ラース含むDCCP BOF、ワーキンググループ、およびメーリングリストを介してコメントや提案を提供した者に感謝しますエッゲルト、Gorry Fairhurst、デレクFawcus、デビッド・ティモシーFleeman、ジョンLoughney、Ghyslainペルティエ、ハーゲンポール・ファイファー、トム・フェラン、スタニスラフ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Shalunov, Somsak Vanit-Anunchai, David Vos, Yufei Wang, and Michael Welzl. In particular, Colin Perkins provided extensive, detailed feedback, Michael Welzl suggested the Data Checksum option, Gorry Fairhurst provided extensive feedback on various checksum issues, and Somsak Vanit-Anunchai, Jonathan Billington, and Tul Kongprakaiwoot&#39;s Colored Petri Net model [VBK05] discovered several problems with message exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Shalunov、ソムサックVanit-Anunchai、デビッド・ヴォス、Yufei王、マイケルWelzl。特に、コリンパーキンスは広範囲、詳細なフィードバックを提供し、マイケルWelzlは、データチェックサムオプションを提案し、Gorry Fairhurstは、様々なチェックサムの問題に広範なフィードバックを提供し、ソムサックVanit-Anunchai、ジョナサン・ビリントン、およびTUL Kongprakaiwootのカラーペトリネットモデルは、[VBK05]いくつかの発見しましたメッセージ交換での問題。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A. Appendix: Ack Vector Implementation Notes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.付録：Ackをベクトル実装ノート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix discusses particulars of DCCP acknowledgement handling in the context of an abstract implementation for Ack Vector. It is informative and not normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録では、ACKベクトルのための抽象実装のコンテキストでDCCP承認取り扱いの詳細について説明します。それは有益で規範的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first part of our implementation runs at the HC-Receiver, and therefore acknowledges data packets. It generates Ack Vector options. The implementation has the following characteristics:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちの実装の最初の部分は、HC-レシーバで動作するため、データパケットを認めています。これは、ACKベクトルオプションを生成します。実装は次の特性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o At most one byte of state per acknowledged packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O認めパケットあたりの状態の時に最大で1つのバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o O(1) time to update that state when a new packet arrives (normal case).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新たなパケットが到着したときにその状態を更新するO O（1）時間（通常の場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cumulative acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
累積確認応答O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Quick removal of old state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
古い状態のOクイック除去。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic data structure is a circular buffer containing information about acknowledged packets. Each byte in this buffer contains a state and run length; the state can be 0 (packet received), 1 (packet ECN marked), or 3 (packet not yet received). The buffer grows from right to left. The implementation maintains five variables, aside from the buffer contents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的なデータ構造は、確認応答パケットに関する情報を含む循環バッファです。このバッファ内の各バイトは、状態とランレングスが含まれています。状態が0（パケットを受信）、1（ECNがマークパケット）、または3（パケットがまだ受信していない）であってもよいです。バッファは、右から左に成長します。実装は、バッファの内容とは別に、5つの変数を維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;buf_head&#34; and &#34;buf_tail&#34;, which mark the live portion of the buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファのライブ部分をマーク「buf_head」および「buf_tail」、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;buf_ackno&#34;, the Acknowledgement Number of the most recent packet acknowledged in the buffer. This corresponds to the &#34;head&#34; pointer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「buf_ackno」O、最新のパケットの確認応答番号は、バッファ内に認めました。これは、「ヘッド」ポインタに対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;buf_nonce&#34;, the one-bit sum (exclusive-or, or parity) of the ECN Nonces received on all packets acknowledged by the buffer with State 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O「buf_nonce」は、ECNナンスの1ビットの和（排他的論理和、またはパリティ）は、状態0を有するバッファによって認めすべてのパケットで受信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We draw acknowledgement buffers like this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、このような確認応答バッファを描きます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +---------------------------------------------------------------+
      |S,L|S,L|S,L|S,L|   |   |   |   |S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|
      +---------------------------------------------------------------+
                    ^                   ^
                 buf_tail     buf_head, buf_ackno = A     buf_nonce = E
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
&lt;=== buf_head and buf_tail move this way &lt;===
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
&lt;=== buf_headと、このように移動buf_tail &lt;===
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each &#34;S,L&#34; represents a State/Run length byte. We will draw these buffers showing only their live portion and will add an annotation showing the Acknowledgement Number for the last live byte in the buffer. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それぞれの「S、Lは、」州/ランレングスバイトを表します。私たちは彼らのライブ部分を示すこれらのバッファを描きますし、バッファ内の最後のライブのバイトに対する肯定応答番号を示す注釈を追加します。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +-----------------------------------------------+
      A |S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L| T    BN[E]
        +-----------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, buf_nonce equals E and buf_ackno equals A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、buf_nonceはEに等しく、buf_acknoはA.に等しいです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will use this buffer as a running example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、実行中の一例として、このバッファを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         +---------------------------+
      10 |0,0|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]   [Example Buffer]
         +---------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In concrete terms, its meaning is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように具体的には、その意味は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet 10 was received. (The head of the buffer has sequence number 10, state 0, and run length 0.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット10は、受信しました。 （バッファの先頭は、配列番号10、状態0、及びランレングス0を有します）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packets 9, 8, and 7 have not yet been received. (The three bytes preceding the head each have state 3 and run length 0.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット9,8、および7はまだ受信されていません。 （各ヘッドの前の3つのバイトは、状態3とランレングス0を有します）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packets 6, 5, 4, 3, and 2 were received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット6、5、4、3、2は受信されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet 1 was ECN marked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット1は、ECNがマークしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet 0 was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パケット0を受信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The one-bit sum of the ECN Nonces on packets 10, 6, 5, 4, 3, 2, and 0 equals 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1ビットのパケット10、6、5、4、3、2にECNナンスの和、および0は1に等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, the HC-Receiver must keep some information about the Ack Vectors it has recently sent. For each packet sent carrying an Ack Vector, it remembers four variables:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、HC-レシーバは、それが最近送信したのAckベクトルに関するいくつかの情報を保持しなければなりません。 Ackベクトルを運んで送られた各パケットの場合は、4つの変数を記憶しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;ack_seqno&#34;, the Sequence Number used for the packet. This is an HC-Receiver sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O「ack_seqno」、パケットに使用するシーケンス番号。これは、HC-レシーバのシーケンス番号です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;ack_ptr&#34;, the value of buf_head at the time of acknowledgement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O「ack_ptr」、承認時のbuf_headの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;ack_runlen&#34;, the run length stored in the byte of buffer data at buf_head at the time of acknowledgement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ack_runlen」O、ランレングスは、肯定応答時にbuf_headにおけるバッファデータのバイトに格納されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;ack_ackno&#34;, the Acknowledgement Number used for the packet. This is an HC-Sender sequence number. Since acknowledgements are cumulative, this single number completely specifies all necessary information about the packets acknowledged by this Ack Vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ack_ackno」O、承認番号は、パケットのために使用しました。これは、HC-送信者のシーケンス番号です。確認応答が累積的であるため、この単一の数値は完全にこの肯定応答ベクトルによって承認パケットに関するすべての必要な情報を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;ack_nonce&#34;, the one-bit sum of the ECN Nonces for all State 0 packets in the buffer from buf_head to ack_ackno, inclusive. Initially, this equals the Nonce Echo of the acknowledgement&#39;s Ack Vector (or, if the ack packet contained more than one Ack Vector, the exclusive-or of all the acknowledgement&#39;s Ack Vectors). It changes as information about old acknowledgements is removed (so ack_ptr and buf_head diverge) and as old packets arrive (so they change from State 3 or State 1 to State 0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O「ack_nonce」、ack_acknoするbuf_headから、バッファ内のすべての状態0のパケットのECNナンスの1ビットの合計、包括的。 （ACKパケットが複数のAckベクトル、排他的論理和のすべての承認者のAckのベクトルが含まれている場合、または）最初は、これは確認のAckをベクターのNonceのエコーに等しいです。これは、古い確認応答に関する情報が除去される（そうack_ptrとbuf_head発散）と同じくらい古いパケットが到着を変更する（ので、状態0の状態3又は状態1から変更します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1. Packet Arrival
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1。パケット到着
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes how the HC-Receiver updates its acknowledgement buffer as packets arrive from the HC-Sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、パケットがHC-送信者から到着するようにHC-Receiverはその肯定応答バッファを更新する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1.1. New Packets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1.1。新しいパケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a packet with Sequence Number greater than buf_ackno arrives, the HC-Receiver updates buf_head (by moving it to the left appropriately), buf_ackno (which is set to the new packet&#39;s Sequence Number), and possibly buf_nonce (if the packet arrived unmarked with ECN Nonce 1), in addition to the buffer itself. For example, if HC-Sender packet 11 arrived ECN marked, the Example Buffer above would enter this new state (changes are marked with stars):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
buf_acknoよりも大きいシーケンス番号を持つパケットが到着すると、HC-レシーバアップデートbuf_head（適切に左に移動することによって）、（新たなパケットのシーケンス番号に設定されている）buf_ackno、そしておそらくbuf_nonce（パケットが到着したとマークされていない場合バッファ自体に加えて、ECNノンス1）。 HC-送信者のパケット11は、ECNがマークされ到着した場合たとえば、上記の例のバッファは、この新しい状態を入力します（変更は星でマークされています）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         ** +***----------------------------+
         11 |1,0|0,0|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]
         ** +***----------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the packet&#39;s state equals the state at the head of the buffer, the HC-Receiver may choose to increment its run length (up to the maximum). For example, if HC-Sender packet 11 arrived without ECN marking and with ECN Nonce 0, the Example Buffer might enter this state instead:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットの状態は、バッファの先頭に状態に等しければ、HC-レシーバは、（最大値まで）のランレングスをインクリメントすることもできます。例えば、HC-送信者のパケット11は、ECNマーキングなしで到着した場合やECNノンス0で、例のバッファが代わりにこの状態に入るかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             ** +--*------------------------+
             11 |0,1|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]
             ** +--*------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Of course, the new packet&#39;s sequence number might not equal the expected sequence number. In this case, the HC-Receiver will enter the intervening packets as State 3. If several packets are missing, the HC-Receiver may prefer to enter multiple bytes with run length 0, rather than a single byte with a larger run length; this simplifies table updates if one of the missing packets arrives. For example, if HC-Sender packet 12 arrived with ECN Nonce 1, the Example Buffer would enter this state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もちろん、新しいパケットのシーケンス番号が期待されるシーケンス番号と等しくない場合があります。いくつかのパケットが欠落している場合この場合には、HC-Receiverが状態3の介在パケットに入り、HC-Receiverはランレングス0、というよりも大きいランレングスを有する単一のバイトで複数のバイトを入力することを好むことができます。欠落したパケットの1が到着した場合、これは、テーブルの更新を簡素化します。 HC-センダパケット12は、ECNノンス1で到着した場合、例えば、実施例バッファはこの状態に入るであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ** +*******----------------------------+         *
      12 |0,0|3,0|0,1|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[0]
      ** +*******----------------------------+         *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Of course, the circular buffer may overflow when the HC-Sender is sending data at a very high rate, when the HC-Receiver&#39;s acknowledgements are not reaching the HC-Sender, or when the HC-Sender is forgetting to acknowledge those acks (so the HC-Receiver is unable to clean up old state). In this case, the HC-Receiver should either compress the buffer (by increasing run lengths when possible), transfer its state to a larger buffer, or, as a last resort, drop all received packets, without processing them at all, until its buffer shrinks again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-Senderがそれほど（HC-受信の確認応答がHC-送信者に到達していない、またはHC-SenderがそれらACKを確認するために忘れている場合と、非常に高いレートでデータを送信している場合もちろん、円形のバッファがオーバーフローしてもよいですHC-レシーバ）が古い状態をクリーンアップすることができません。この場合には、HC-Receiverは、（可能な場合ランレングスを増加させることによって）バッファを圧縮しなければならないのいずれか大きいバッファにその状態を転送する、または、最後の手段として、そのまで、すべてでそれらを処理することなく、すべての受信パケットをドロップバッファが再び縮小されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1.2. Old Packets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1.2。オールド・パケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a packet with Sequence Number S &lt;= buf_ackno arrives, the HC-Receiver will scan the table for the byte corresponding to S. (Indexing structures could reduce the complexity of this scan.) If S was previously lost (State 3), and it was stored in a byte with run length 0, the HC-Receiver can simply change the byte&#39;s state. For example, if HC-Sender packet 8 was received with ECN Nonce 0, the Example Buffer would enter this state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号Sとすると、パケット&lt;= buf_acknoが到着すると、HC-レシーバはS.（インデックス構造は、このスキャンの複雑さを軽減することができます。）Sは、以前に失われた場合（状態3）に対応するバイトのテーブルをスキャンして、それはラン長0のバイトに格納されていた、HC-レシーバは単にバイトの状態を変更することができます。 HC-Senderのパケット8は、ECNノンス0で受信された場合、例えば、実施例バッファはこの状態に入るであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               +--------*------------------+
            10 |0,0|3,0|0,0|3,0|0,4|1,0|0,0| 0    BN[1]
               +--------*------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If S was not marked as lost, or if it was not contained in the table, the packet is probably a duplicate and should be ignored. (The new packet&#39;s ECN marking state might differ from the state in the buffer; Section 11.4.1 describes what is allowed then.) If S&#39;s buffer byte has a non-zero run length, then the buffer might need to be reshuffled to make space for one or two new bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
失われたとして、またはそれがテーブルに含まれていなかった場合はSがマークされていなかった場合、パケットはおそらく重複していると無視されるべきです。 （新しいパケットのECNマーキング状態は、バッファ状態は異なる場合があります;。11.4.1は、許可されている内容を説明）Sのバッファ・バイトが非ゼロのラン長を持っている場合、バッファにはスペースを作るために入れ替えが必要になる場合があります1または2の新しいバイトのために。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ack_nonce fields may also need manipulation when old packets arrive. In particular, when S transitions from State 3 or State 1 to State 0, and S had ECN Nonce 1, then the implementation should flip the value of ack_nonce for every acknowledgement with ack_ackno &gt;= S.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
古いパケットが到着したときack_nonceフィールドも操作が必要な場合があります。特に、状態0の状態3又は状態1からSに遷移し、SがECNノンス1を有し、実装はack_ackno&gt; = Sですべての肯定応答のためack_nonceの値を反転すべきです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is impossible with this data structure to shift packets from State 0 to State 1, since the buffer doesn&#39;t store individual packets&#39; ECN Nonces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、バッファは、個々のパケットのECNナンスを格納していないので、状態1の状態0からのパケットをシフトするために、このデータ構造では不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2. Sending Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2。謝辞を送信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever the HC-Receiver needs to generate an acknowledgement, the buffer&#39;s contents can simply be copied into one or more Ack Vector options. Copied Ack Vectors might not be maximally compressed; for example, the Example Buffer above contains three adjacent 3,0 bytes that could be combined into a single 3,2 byte. The HC-Receiver might, therefore, choose to compress the buffer in place before sending the option, or to compress the buffer while copying it; either operation is simple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-Receiverの確認応答を生成する必要があるときはいつでも、バッファの内容は、単に一の以上のAckベクトルオプションにコピーすることができます。コピーされたAckベクターは最大限に圧縮されていない可能性があります。例えば、実施例バッファは、上記単一3,2バイトに組み合わせることができる3つの隣接する3,0バイトを含みます。 HC-レシーバは、したがって、オプションを送信する前に所定の位置にバッファを圧縮する、またはそれをコピーしている間にバッファを圧縮することを選択するかもしれません。どちらかの操作が簡単です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every acknowledgement sent by the HC-Receiver SHOULD include the entire state of the buffer. That is, acknowledgements are cumulative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-受信機によって送信されたすべての肯定応答がバッファ全体の状態が含まれるべきです。これは、確認応答が累積され、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the acknowledgement fits in one Ack Vector, that Ack Vector&#39;s Nonce Echo simply equals buf_nonce. For multiple Ack Vectors, more care is required. The Ack Vectors should be split at points corresponding to previous acknowledgements, since the stored ack_nonce fields provide enough information to calculate correct Nonce Echoes. The implementation should therefore acknowledge data at least once per 253 bytes of buffer state. (Otherwise, there&#39;d be no way to calculate a Nonce Echo.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認応答が1のAckベクトルに収まる場合は、ACKベクトルのナンスエコーは、単にbuf_nonceに等しいこと。複数のACKベクターについて、より多くの注意が必要です。保存されたack_nonceフィールドが正しいノンスエコーを計算するために十分な情報を提供するためのAckベクターは、以前の肯定応答に対応する点で分割されなければなりません。実装は、従って、少なくとも一度バッファ状態の253バイト毎のデータを確認すべきです。 （そうでない場合は、ノンスエコーを計算する方法がないと思います。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each acknowledgement it sends, the HC-Receiver will add an acknowledgement record. ack_seqno will equal the HC-Receiver sequence number it used for the ack packet; ack_ptr will equal buf_head; ack_runlen will equal the run length stored in the buffer&#39;s buf_head byte; ack_ackno will equal buf_ackno; and ack_nonce will equal buf_nonce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが送信する各受信確認のために、HC-レシーバは承認レコードを追加します。 ack_seqnoがACKパケットに使用されるHC-受信シーケンス番号に等しくなります。 ack_ptr buf_headに等しくなります。 ack_runlenは、バッファのbuf_headバイトに保存されているラン長を等しくなります。 ack_ackno buf_acknoに等しくなります。そしてack_nonceはbuf_nonceに等しくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.3. Clearing State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.3。状態をクリア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the HC-Sender&#39;s packets will include acknowledgement numbers, which ack the HC-Receiver&#39;s acknowledgements. When such an ack is received, the HC-Receiver finds the acknowledgement record R with the appropriate ack_seqno and then does the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-送信者のパケットの中には、HC-Receiverの承認をackを確認応答番号が含まれます。そのようなACKが受信されると、HC-Receiverは、適切なack_seqnoと肯定応答レコードRを検索し、その後、次の処理を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the run length in the buffer&#39;s R.ack_ptr byte is greater than R.ack_runlen, then it decrements that run length by R.ack_runlen + 1 and sets buf_tail to R.ack_ptr. Otherwise, it sets buf_tail to R.ack_ptr + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファのR.ack_ptrバイトのラン長がR.ack_runlenよりも大きい場合は、O、それはR.ack_ptrにbuf_tail R.ack_runlen + 1とセットすることにより、そのラン長をデクリメント。それ以外の場合は、R.ack_ptr + 1にbuf_tail設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If R.ack_nonce is 1, it flips buf_nonce, and the value of ack_nonce for every later ack record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R.ack_nonceが1の場合、O、それはbuf_nonce、すべての後にACKレコードのack_nonceの値を反転します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It throws away R and every preceding ack record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OそれはRと、すべての前のACKのレコードを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(The HC-Receiver may choose to keep some older information, in case a lost packet shows up late.) For example, say that the HC-Receiver storing the Example Buffer had sent two acknowledgements already:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（HC-レシーバは、後半に失われたパケットが現れる場合には、いくつかの古い情報を保持することもできます。）例えば、HC-レシーバは例のバッファがすでに2つの確認応答を送っていた保存と言います：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. ack_seqno = 59, ack_runlen = 1, ack_ackno = 3, ack_nonce = 1.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. ack_seqno = 59、ack_runlen = 1、ack_ackno = 3、ack_nonce = 1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. ack_seqno = 60, ack_runlen = 0, ack_ackno = 10, ack_nonce = 0.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. ack_seqno = 60、ack_runlen = 0、ack_ackno = 10、ack_nonce = 0番目
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Say the HC-Receiver then received a DCCP-DataAck packet with Acknowledgement Number 59 from the HC-Sender. This informs the HC-Receiver that the HC-Sender received, and processed, all the information in HC-Receiver packet 59. This packet acknowledged HC-Sender packet 3, so the HC-Sender has now received HC-Receiver&#39;s acknowledgements for packets 0, 1, 2, and 3. The Example Buffer should enter this state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-受信機は、次にHC-送信者からの肯定応答番号59とDCCP-DataAckパケットを受信したと言います。これは、HC-送信者が受信したHC-Receiverを通知し、処理し、HC-レシーバパケット59のすべての情報は、このパケットは、HC-送信者のパケット3を認めたので、HC-送信者は現在、パケット0用HC-Receiverの承認を受けています、1、2、および3例のバッファはこの状態に入るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               +------------------*+ *       *
            10 |0,0|3,0|3,0|3,0|0,2| 4    BN[0]
               +------------------*+ *       *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The tail byte&#39;s run length was adjusted, since packet 3 was in the middle of that byte. Since R.ack_nonce was 1, the buf_nonce field was flipped, as were the ack_nonce fields for later acknowledgements (here, the HC-Receiver Ack 60 record, not shown, has its ack_nonce flipped to 1). The HC-Receiver can also throw away stored information about HC-Receiver Ack 59 and any earlier acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット3は、そのバイトの真ん中にあったので、テール・バイトのラン長は、調整しました。 R.ack_nonceが1であったので、後に肯定応答するためのack_nonceフィールドたように、buf_nonceフィールドは、反転した（ここで、HCレシーバのAck 60レコード、図示しないが、そのack_nonceは1に反転しています）。 HC-また、受信機は、HC-レシーバのAck 59およびそれ以前の承認に関する離れて保存されている情報を投げることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A careful implementation might try to ensure reasonable robustness to reordering. Suppose that the Example Buffer is as before, but that packet 9 now arrives, out of sequence. The buffer would enter this state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
慎重な実装では、並べ替えに合理的な堅牢性を確保しようとするかもしれません。シーケンスのうちの、例のバッファが以前のようにですが、そのパケット9が今到着したと仮定します。バッファは、この状態を入力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                +----*----------------------+
             10 |0,0|0,0|3,0|3,0|0,4|1,0|0,0| 0     BN[1]
                +----*----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The danger is that the HC-Sender might acknowledge the HC-Receiver&#39;s previous acknowledgement (with sequence number 60), which says that Packet 9 was not received, before the HC-Receiver has a chance to send a new acknowledgement saying that Packet 9 actually was received. Therefore, when packet 9 arrived, the HC-Receiver might modify its acknowledgement record as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
危険なのはHC-SenderがHC-レシーバが実際にそのパケット9を言って新しい確認応答を送信する機会を持って前に、パケット9は、受信されなかったことを言って、（シーケンス番号60を持つ）HC-Receiverの前の承認を認める可能性があるということです受信されました。パケット9が到着したとき、次のようにそのため、HC-レシーバは、その承認レコードを変更することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. ack_seqno = 59, ack_ackno = 3, ack_nonce = 1.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. ack_seqno = 59、ack_ackno = 3、ack_nonce =第一
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. ack_seqno = 60, ack_ackno = 3, ack_nonce = 1.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. ack_seqno = 60、ack_ackno = 3、ack_nonce =第一
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That is, Ack 60 is now treated like a duplicate of Ack 59. This would prevent the Tail pointer from moving past packet 9 until the HC-Receiver knows that the HC-Sender has seen an Ack Vector indicating that packet&#39;s arrival.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、ACK 60は今HC-Senderは、パケットの到着ことを示すACKベクトルを見ていることを知っている。これは、HC-レシーバまでの過去パケット9を移動するテールポインタを妨げるのAck 59の重複のように扱われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4. Processing Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4。処理謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the HC-Sender receives an acknowledgement, it generally cares about the number of packets that were dropped and/or ECN marked. It simply reads this off the Ack Vector. Additionally, it should check the ECN Nonce for correctness. (As described in Section 11.4.1, it may want to keep more detailed information about acknowledged packets in case packets change states between acknowledgements, or in case the application queries whether a packet arrived.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-Senderが確認応答を受信すると、それは一般的にドロップされたおよび/またはECNがマークされたパケット数を気に。それは単にのAckベクトルを、これをオフに読み込みます。さらに、それが正しいかECN nonceを確認する必要があります。 （11.4.1項で説明したように、それは、パケットが到着したかどうかをアプリケーションのクエリを確認応答の間の状態を変更したり、ケースにケースパケットで確認応答パケットについてのより詳細な情報を保持することをお勧めします。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HC-Sender must also acknowledge the HC-Receiver&#39;s acknowledgements so that the HC-Receiver can free old Ack Vector state. (Since Ack Vector acknowledgements are reliable, the HC-Receiver must maintain and resend Ack Vector information until it is sure that the HC-Sender has received that information.) A simple algorithm suffices: since Ack Vector acknowledgements are cumulative, a single acknowledgement number tells HC-Receiver how much ack information has arrived. Assuming that the HC-Receiver sends no data, the HC-Sender can ensure that at least once a round-trip time, it sends a DCCP-DataAck packet acknowledging the latest DCCP-Ack packet it has received. Of course, the HC-Sender only needs to acknowledge the HC-Receiver&#39;s acknowledgements if the HC-Sender is also sending data. If the HC-Sender is not sending data, then the HC-Receiver&#39;s Ack Vector state is stable, and there is no need to shrink it. The HC-Sender must watch for drops and ECN marks on received DCCP-Ack packets so that it can adjust the HC-Receiver&#39;s ack-sending rate in response to congestion, for example, with Ack Ratio.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HC-レシーバが古いのAckベクトル状態を解放できるように、HC-送信者はまた、HC-Receiverの承認を確認する必要があります。 （肯定応答ベクトル肯定応答が信頼されているので、HC-Senderがその情報を受信したことを確認するまで、HC-受信機は、ACKベクトル情報を維持し、再送信しなければならない。）単純なアルゴリズムで十分：のAckベクトル確認応答が累積的であるため、単一確認応答番号ACK情報が到着したどのくらいのHC-Receiverを伝えます。 HC-レシーバがデータを送信しないと仮定すると、HC-送信者は、少なくとも一回のラウンドトリップ時間、それが受信した最新のDCCP-Ackパケットを認めDCCP-DataAckパケットを送信していることを確認することができます。もちろん、HC-送信者にのみHC-Senderは、データを送信している場合はHC-Receiverの確認応答を確認する必要があります。 HC-Senderがデータを送信していない場合は、HC-ReceiverのAckをベクトル状態は安定しており、それを縮小する必要はありません。それがACK比で、例えば、混雑に応じて、HC-ReceiverのACK-送信レートを調整できるように、HC-送信者は受信DCCP-ACKパケットに低下し、ECNマークを監視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the other half-connection is not quiescent -- that is, the HC-Receiver is sending data to the HC-Sender, possibly using another CCID -- then the acknowledgements on that half-connection are sufficient for the HC-Receiver to free its state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りの半分接続が休止されていない場合 - つまり、HC-レシーバはおそらく別のCCIDを使用して、HC-Senderにデータを送信している - その半分の接続の確認応答が自由にHC-レシーバには十分ですその状態。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B. Appendix: Partial Checksumming Design Motivation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.付録：部分的なチェックサムのデザイン動機
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A great deal of discussion has taken place regarding the utility of allowing a DCCP sender to restrict the checksum so that it does not cover the complete packet. This section attempts to capture some of the rationale behind specific details of DCCP design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
議論の偉大な取引が、それは完全なパケットをカバーしないように、DCCP送信者がチェックサムを制限することを可能にする有用性について行われました。このセクションでは、DCCP設計の具体的な詳細の根拠の一部を捕獲しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many of the applications that we envisage using DCCP are resilient to some degree of data loss, or they would typically have chosen a reliable transport. Some of these applications may also be resilient to data corruption -- some audio payloads, for example. These resilient applications might rather receive corrupted data than have DCCP drop corrupted packets. This is particularly because of congestion control: DCCP cannot tell the difference between packets dropped due to corruption and packets dropped due to congestion, and so it must reduce the transmission rate accordingly. This response may cause the connection to receive less bandwidth than it is due; corruption in some networking technologies is independent of, or at least not always correlated to, congestion. Therefore, corrupted packets do not need to cause as strong a reduction in transmission rate as the congestion response would dictate (as long as the DCCP header and options are not corrupt).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちはDCCPを使用して想定するアプリケーションの多くは、データ損失のある程度弾力性のある、またはそれらは一般的に信頼性の高いトランスポートを選択しているだろう。これらのアプリケーションのいくつかは、データの破損に弾力があり - いくつかのオーディオペイロード、例えば。これらの弾力性のアプリケーションではなく、DCCPドロップ破損したパケットを持っているよりも破損したデータを受信する場合があります。これは、輻輳制御のために特にです：DCCPが原因汚職に低下し、パケットが輻輳による滴下し、それはそれに応じて伝送速度を減少させなければならないパケット間の違いを見分けることはできません。この応答は、それが原因であるよりも少ない帯域幅を受け取るために接続を引き起こす可能性があります。いくつかのネットワーク技術の腐敗は独立して、または少なくとも常に混雑、に相関していません。そのため、破損したパケットは、（限り、DCCPヘッダーとオプションが破損していないよう）指示するでしょう輻輳応答として送信レートのような強力な低下を引き起こすする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus DCCP allows the checksum to cover all of the packet, just the DCCP header, or both the DCCP header and some number of bytes from the application data. If the application cannot tolerate any data corruption, then the checksum must cover the whole packet. If the application would prefer to tolerate some corruption rather than have the packet dropped, then it can set the checksum to cover only part of the packet (but always the DCCP header). In addition, if the application wishes to decouple checksumming of the DCCP header from checksumming of the application data, it may do so by including the Data Checksum option. This would allow DCCP to discard corrupted application data without mistaking the corruption for network congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがってDCCPは、チェックサムは、パケットのすべて、単にDCCPヘッダー、またはDCCPヘッダおよびアプリケーションデータから数バイトの両方をカバーすることを可能にします。アプリケーションがデータの破損に耐えることができない場合は、チェックサムは、パケット全体をカバーしなければなりません。アプリケーションは、いくつかの汚職を容認することを好む場合ではなく、パケットは廃棄されている、それだけでパケットの一部（常にDCCPヘッダー）をカバーするためにチェックサムを設定することができます。アプリケーションは、アプリケーションデータのチェックサムからDCCPヘッダのチェックサムを分離したい場合に加えて、それは、データチェックサムオプションを含めることによって、これを行うことができます。これは、DCCPは、ネットワークの混雑のために破損を間違えずに破損したアプリケーションデータを破棄することが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, from the application point of view, partial checksums seem to be a desirable feature. However, the usefulness of partial checksums depends on partially corrupted packets being delivered to the receiver. If the link-layer CRC always discards corrupted packets, then this will not happen, and so the usefulness of partial checksums would be restricted to corruption that occurred in routers and other places not covered by link CRCs. There does not appear to be consensus on how likely it is that future network links that suffer significant corruption will not cover the entire packet with a single strong CRC. DCCP makes it possible to tailor such links to the application, but it is difficult to predict if this will be compelling for future link technologies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、アプリケーションの観点から、部分的チェックサムは望ましい特徴であるように見えます。しかし、部分的なチェックサムの有用性は、部分的に破損したパケットが受信機に配信さに依存します。リンク層のCRCは、常に破損したパケットを破棄した場合、これは発生しません、ので、部分的なチェックサムの有用性は、ルータやリンクのCRCで保護されていない他の場所で発生した破損に限定されるであろう。それは重大な破損を受け、将来のネットワークリンクは、単一の強力なCRCを持つパケット全体をカバーしていないということですかそうでコンセンサスがあるように表示されません。 DCCPは、アプリケーションにこのようなリンクを調整することが可能となり、これは将来のリンク技術のための説得力になるかどうかを予測することは困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, partial checksums do not co-exist well with IP-level authentication mechanisms such as IPsec AH, which cover the entire packet with a cryptographic hash. Thus, if cryptographic authentication mechanisms are required to co-exist with partial checksums, the authentication must be carried in the application data. A possible mode of usage would appear to be similar to that of Secure RTP. However, such &#34;application-level&#34; authentication does not protect the DCCP option negotiation and state machine from forged packets. An alternative would be to use IPsec ESP, and to use encryption to protect the DCCP headers against attack, while using the DCCP header validity checks to authenticate that the header is from someone who possessed the correct key. While this is resistant to replay (due to the DCCP sequence number), it is not by itself resistant to some forms of man-in-the-middle attacks because the application data is not tightly coupled to the packet header. Thus, an application-level authentication probably needs to be coupled with IPsec ESP or a similar mechanism to provide a reasonably complete security solution. The overhead of such a solution might be unacceptable for some applications that would otherwise wish to use partial checksums.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加えて、部分的チェックサムは、暗号ハッシュとパケット全体を覆うようにIPsec AHなどのIPレベルの認証メカニズムとよく共存していません。暗号認証メカニズムは、部分チェックサムと共存する必要がある場合はこのように、認証は、アプリケーションデータに実行されなければなりません。利用可能なモードでは、Secure RTPのものと同様であるように思われます。しかし、そのような「アプリケーションレベル」の認証を偽造パケットからDCCPオプションのネゴシエーションやステートマシンを保護しません。代替は、IPsec ESPを使用すると、ヘッダが正しいキーを持っていた誰かからのものであることを認証するためにDCCPヘッダーの妥当性チェックを使用している間、攻撃に対してDCCPヘッダを保護するために暗号化を使用することであろう。これは（これはDCCPのシーケンス番号に）再生に対して耐性であるが、アプリケーションデータがしっかりパケットヘッダに連結されていないので、それはそれ自体でman-in-the-middle攻撃のいくつかの形態に耐性ではありません。このように、アプリケーションレベルの認証は、おそらくIPsecのESPまたは合理的に完全なセキュリティソリューションを提供するために、同様のメカニズムと結合する必要があります。このようなソリューションのオーバーヘッドはそうでない部分のチェックサムを使用したいでしょういくつかのアプリケーションのために受け入れられないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On balance, the authors believe that DCCP partial checksums have the potential to enable some future uses that would otherwise be difficult. As the cost and complexity of supporting them is small, it seems worth including them at this time. It remains to be seen whether they are useful in practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バランスで、著者はDCCP部分的なチェックサムがそうでなければ困難であろういくつかの将来の使用を可能にする可能性を持っていると信じています。それらが小さいサポートのコストと複雑さと、それはこの時点でそれらを含めて価値があると思われます。それは、彼らが実際に有用であるかどうかを見守らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Normative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
引用規格
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191] Mogul, J. and S. Deering, &#34;Path MTU discovery&#34;, RFC 1191, November 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191]ムガール人、J.とS.デアリング、 &#34;パスMTUディスカバリ&#34;、RFC 1191、1990年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2434] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 2434, October 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2434] Narten氏、T.とH. Alvestrand、 &#34;RFCsにIANA問題部に書くためのガイドライン&#34;、BCP 26、RFC 2434、1998年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460]デアリング、S.とR. Hindenと、 &#34;インターネットプロトコルバージョン6（IPv6）の仕様&#34;、RFC 2460、1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, September 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;IPに明示的輻輳通知の添加（ECN）&#34; [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、2001年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3309] Stone, J., Stewart, R., and D. Otis, &#34;Stream Control Transmission Protocol (SCTP) Checksum Change&#34;, RFC 3309, September 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3309]石、J.、スチュワート、R.、およびD.オーティス、 &#34;ストリーム制御伝送プロトコル（SCTP）チェックサムの変更&#34;、RFC 3309、2002年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3692] Narten, T., &#34;Assigning Experimental and Testing Numbers Considered Useful&#34;, BCP 82, RFC 3692, January 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3692] Narten氏、T.、 &#34;役に立つと考えられ割り当て実験とテスト番号&#34;、BCP 82、RFC 3692、2004年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3775] Johnson, D., Perkins, C., and J. Arkko, &#34;Mobility Support in IPv6&#34;, RFC 3775, June 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3775]ジョンソン、D.、パーキンス、C.、およびJ. Arkko、 &#34;IPv6におけるモビリティサポート&#34;、RFC 3775、2004年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3828] Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., and G. Fairhurst, &#34;The Lightweight User Datagram Protocol (UDP-Lite)&#34;, RFC 3828, July 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3828] Larzon、L-A。、Degermark、M.、ピンク、S.、ヨンソン、L-E。、およびG. Fairhurst、 &#34;軽量ユーザーデータグラムプロトコル（UDP-Liteの）&#34;、RFC 3828、2004年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Informative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[B98] Bellovin, S.M., &#34;Cryptography and the Internet&#34;, CRYPTO &#39;98 (LNCS 1462), pp 46-55, August 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[B98] Bellovin氏、S.M.、 &#34;暗号とインターネット&#34;、CRYPTO &#39;98（LNCS 1462）、頁46-55、1988年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BB01] Bellovin, S.M. and M. Blaze, &#34;Cryptographic Modes of Operation for the Internet&#34;, 2nd NIST Workshop on Modes of Operation, August 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BB01] Bellovin氏、S。M.そして、M.ブレイズ、「インターネットのための操作の暗号モード」、オペレーション、2001年8月のモードに関する第2回ワークショップNIST。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[M85] Morris, R.T., &#34;A Weakness in the 4.2BSD Unix TCP/IP Software&#34;, Computer Science Technical Report 117, AT&amp;T Bell Laboratories, Murray Hill, NJ, February 1985.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[M85]モリス、R.T.、 &#34;4.2BSD UnixのTCP / IPソフトウェアで弱点&#34;、コンピュータサイエンステクニカルレポート117、AT＆Tベル研究所、マリーヒル、ニュージャージー州、1985年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PMTUD] Mathis, M. and J. Heffner, &#34;Path MTU Discovery&#34;, Work in Progress, March 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PMTUD]マシス、M.とJ. Heffner、 &#34;パスMTUディスカバリー&#34;、進歩、2006年3月での作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC792] Postel, J., &#34;Internet Control Message Protocol&#34;, STD 5, RFC 792, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC792]ポステル、J.、 &#34;インターネット制御メッセージプロトコル&#34;、STD 5、RFC 792、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1812] Baker, F., &#34;Requirements for IP Version 4 Routers&#34;, RFC 1812, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1812]ベイカー、F.、RFC 1812、1995年6月 &#34;IPバージョン4つのルータのための要件&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1948] Bellovin, S., &#34;Defending Against Sequence Number Attacks&#34;, RFC 1948, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1948] Bellovin氏、S.、 &#34;シーケンス番号攻撃からの保護&#34;、RFC 1948、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1982] Elz, R. and R. Bush, &#34;Serial Number Arithmetic&#34;, RFC 1982, August 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1982]エルツ、R.とR.ブッシュ大統領、 &#34;シリアル番号演算&#34;、RFC 1982、1996年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &#34;TCP Selective Acknowledgement Options&#34;, RFC 2018, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 &#34;TCPの選択確認応答オプション&#34;、RFC 2018、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2401] Kent, S. and R. Atkinson, &#34;Security Architecture for the Internet Protocol&#34;, RFC 2401, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2401]ケント、S.とR.アトキンソン、 &#34;インターネットプロトコルのためのセキュリティー体系&#34;、RFC 2401、1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2463] Conta, A. and S. Deering, &#34;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification&#34;, RFC 2463, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2463]コンタ、A.、およびS.デアリング、 &#34;インターネットプロトコルバージョン6（IPv6）仕様のためのインターネット制御メッセージプロトコル（ICMPv6の）&#34;、RFC 2463（1998年12月）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2581] Allman, M., Paxson, V., and W. Stevens, &#34;TCP Congestion Control&#34;, RFC 2581, April 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2581]オールマン、M.、パクソン、V.、およびW.スティーブンス、 &#34;TCP輻輳制御&#34;、RFC 2581、1999年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2960] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V. Paxson, &#34;Stream Control Transmission Protocol&#34;, RFC 2960, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2960]スチュワート、R.、謝、Q.、Morneault、K.、シャープ、C.、Schwarzbauer、H.、テイラー、T.、Rytina、I.、カラ、M.、チャン、L.、およびV 。パクソン、 &#34;ストリーム制御伝送プロトコル&#34;、RFC 2960、2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3124] Balakrishnan, H. and S. Seshan, &#34;The Congestion Manager&#34;, RFC 3124, June 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3124]バラクリシュナン、H.とS. Seshan、 &#34;輻輳管理&#34;、RFC 3124、2001年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3360] Floyd, S., &#34;Inappropriate TCP Resets Considered Harmful&#34;, BCP 60, RFC 3360, August 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3360]フロイド、S.、 &#34;有害考慮不適切なTCPリセット&#34;、BCP 60、RFC 3360、2002年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3448] Handley, M., Floyd, S., Padhye, J., and J. Widmer, &#34;TCP Friendly Rate Control (TFRC): Protocol Specification&#34;, RFC 3448, January 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3448]ハンドレー、M.、フロイド、S.、Padhye、J.、およびJ.ウィトマー、 &#34;TCPフレンドリーレート制御（TFRC）：プロトコル仕様&#34;、RFC 3448、2003年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3540] Spring, N., Wetherall, D., and D. Ely, &#34;Robust Explicit Congestion Notification (ECN) Signaling with Nonces&#34;, RFC 3540, June 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3540]春、N.、Wetherall、D.、およびD.イーリー、 &#34;ロバスト明示的輻輳通知（ECN）ナンスとシグナリング&#34;、RFC 3540、2003年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, STD 64, RFC 3550, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 &#34;RTP：リアルタイムアプリケーションのためのトランスポートプロトコル&#34;、STD 64、RFC 3550、2003年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3611] Friedman, T., Caceres, R., and A. Clark, &#34;RTP Control Protocol Extended Reports (RTCP XR)&#34;, RFC 3611, November 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3611]フリードマン、T.、カセレス、R.、およびA.クラーク、 &#34;RTP制御プロトコル拡張レポート（RTCP XR）&#34;、RFC 3611、2003年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &#34;The Secure Real-time Transport Protocol (SRTP)&#34;, RFC 3711, March 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3711] Baugher、M.、マグリュー、D.、Naslund、M.、カララ、E.、およびK. Norrman、 &#34;セキュアリアルタイム転送プロトコル（SRTP）&#34;、RFC 3711、2004年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3819] Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, &#34;Advice for Internet Subnetwork Designers&#34;, BCP 89, RFC 3819, July 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3819]カーン、P.、ボルマン、C.、Fairhurst、G.、グロスマン、D.、ルートヴィヒ、R.、Mahdavi、J.、モンテネグロ、G.、タッチ、J.、およびL.ウッド、「アドバイスインターネットサブネットワークデザイナー」、BCP 89、RFC 3819、2004年7月のため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086]イーストレーク、D.、3、シラー、J.、およびS.クロッカー、 &#34;セキュリティのためのランダム要件&#34;、BCP 106、RFC 4086、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4341] Floyd, S. and E. Kohler, &#34;Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control&#34;, RFC 4341, March 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4341]フロイド、S.、およびE.コーラー、 &#34;データグラム輻輳制御プロトコル（DCCP）輻輳制御ID 2用のプロフィール：TCPのような輻輳制御&#34;、RFC 4341、2006年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4342] Floyd, S., Kohler, E., and J. Padhye, &#34;Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)&#34;, RFC 4342, March 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4342]フロイド、S.、コーラー、E.、およびJ. Padhye、 &#34;データグラム混雑制御プロトコル（DCCP）輻輳制御ID 3のプロフィール：TCPフレンドリーレート制御（TFRC）&#34;、RFC 4342、2006年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHHP00] Spatscheck, O., Hansen, J.S., Hartman, J.H., and L.L. Peterson, &#34;Optimizing TCP Forwarder Performance&#34;, IEEE/ACM Transactions on Networking 8(2):146-157, April 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;TCPフォワーダパフォーマンスの最適化&#34; [SHHP00] Spatscheck、O.、ハンセン、J.S.、ハートマン、J.H.、およびL.L.ピーターソン、ネットワーク8上のIEEE / ACMの取引（2）：146-157、2000年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SYNCOOKIES] Bernstein, D.J., &#34;SYN Cookies&#34;, http://cr.yp.to/syncookies.html, as of March 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2006年3月のように[syncookies機能]バーンスタイン、D.J.、 &#34;SYNクッキー&#34;、http://cr.yp.to/syncookies.html、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[VBK05] Vanit-Anunchai, S., Billington, J., and T. Kongprakaiwoot, &#34;Discovering Chatter and Incompleteness in the Datagram Congestion Control Protocol&#34;, FORTE 2005, pp 143-158, October 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【VBK05] Vanit-Anunchai、S.、ビリントン、J.、およびT. Kongprakaiwoot、 &#34;データグラム輻輳制御プロトコルで発見びびり及び不完全&#34;、FORTE 2005頁143-158、2005年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eddie Kohler 4531C Boelter Hall UCLA Computer Science Department Los Angeles, CA 90095 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エディー・コーラー4531C BoelterホールUCLAコンピュータサイエンス学部ロサンゼルス、CA 90095 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: kohler@cs.ucla.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：kohler@cs.ucla.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark Handley Department of Computer Science University College London Gower Street London WC1E 6BT UK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンピュータサイエンス大学ロンドンガウアーストリートロンドンWC1E 6BT英国のマーク・ハンドリー部門
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: M.Handley@cs.ucl.ac.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：M.Handley@cs.ucl.ac.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sally Floyd ICSI Center for Internet Research 1947 Center Street, Suite 600 Berkeley, CA 94704 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネットリサーチ1947センターストリートのためのサリーフロイドICSIセンター、スイート600バークレー、CA 94704 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: floyd@icir.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：floyd@icir.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2006）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
