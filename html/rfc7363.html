<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7363 - Self-Tuning Distributed Hash Table (DHT) for REsource LOcation And Discovery (RELOAD) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7363</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7363 - Self-Tuning Distributed Hash Table (DHT) for REsource LOcation And Discovery (RELOAD) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7363">
              https://tools.ietf.org/html/rfc7363
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7363 - リソースの場所と発見のためのセルフチューニング分散ハッシュテーブル（DHT）（RELOAD）</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                        J. Maenpaa
Request for Comments: 7363                                  G. Camarillo
Category: Standards Track                                       Ericsson
ISSN: 2070-1721                                           September 2014
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                Self-Tuning Distributed Hash Table (DHT)
              for REsource LOcation And Discovery (RELOAD)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REsource LOcation And Discovery (RELOAD) is a peer-to-peer (P2P) signaling protocol that provides an overlay network service. Peers in a RELOAD overlay network collectively run an overlay algorithm to organize the overlay and to store and retrieve data. This document describes how the default topology plugin of RELOAD can be extended to support self-tuning, that is, to adapt to changing operating conditions such as churn and network size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースロケーションとDiscovery（リロード）は、オーバレイネットワークサービスを提供するピア・ツー・ピア（P2P）シグナリングプロトコルです。 RELOADオーバーレイネットワークにおけるピアは、まとめオーバーレイを整理するために、データを格納および取得するためにオーバーレイアルゴリズムを実行します。この文書では、RELOADのデフォルトのトポロジーのプラグインは、このような解約やネットワークサイズなどの動作条件の変化に適応するために、つまり、セルフチューニングをサポートするように拡張することができる方法を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7363.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7363で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................2
   2. Terminology .....................................................3
   3. Introduction to Stabilization in DHTs ...........................5
      3.1. Reactive versus Periodic Stabilization .....................5
      3.2. Configuring Periodic Stabilization .........................6
      3.3. Adaptive Stabilization .....................................7
   4. Introduction to Chord ...........................................7
   5. Extending Chord-Reload to Support Self-Tuning ...................9
      5.1. Update Requests ............................................9
      5.2. Neighbor Stabilization ....................................10
      5.3. Finger Stabilization ......................................11
      5.4. Adjusting Finger Table Size ...............................11
      5.5. Detecting Partitioning ....................................11
      5.6. Leaving the Overlay .......................................11
   6. Self-Tuning Chord Parameters ...................................12
      6.1. Estimating Overlay Size ...................................12
      6.2. Determining Routing Table Size ............................13
      6.3. Estimating Failure Rate ...................................13
           6.3.1. Detecting Failures .................................14
      6.4. Estimating Join Rate ......................................14
      6.5. Estimate Sharing ..........................................15
      6.6. Calculating the Stabilization Interval ....................17
   7. Overlay Configuration Document Extension .......................17
   8. Security Considerations ........................................18
   9. IANA Considerations ............................................18
      9.1. Message Extensions ........................................18
      9.2. New Overlay Algorithm Type ................................19
      9.3. A New IETF XML Registry ...................................19
   10. Acknowledgments ...............................................19
   11. References ....................................................19
      11.1. Normative References .....................................19
      11.2. Informative References ...................................20
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REsource LOcation And Discovery (RELOAD) [RFC6940] is a peer-to-peer signaling protocol that can be used to maintain an overlay network and to store data in and retrieve data from the overlay. For interoperability reasons, RELOAD specifies one overlay algorithm, called &#34;chord-reload&#34;, that is mandatory to implement. This document extends the chord-reload algorithm by introducing self-tuning behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースロケーションと発見（リロード）[RFC6940]は、オーバーレイネットワークを維持し、データを保存し、オーバーレイからデータを取得するために使用することができるピア・ツー・ピアシグナリングプロトコルです。相互運用性の理由から、RELOADは実装が必須である「和音リロード」と呼ばれる1つのオーバーレイ・アルゴリズムを、指定します。この文書では、セルフチューニング動作を導入することにより、和音リロードアルゴリズムを拡張します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHT-based overlay networks are self-organizing, scalable, and reliable. However, these features come at a cost: peers in the overlay network need to consume network bandwidth to maintain routing state. Most DHTs use a periodic stabilization routine to counter the undesirable effects of churn on routing. To configure the parameters of a DHT, some characteristics such as churn rate and network size need to be known in advance. These characteristics are then used to configure the DHT in a static fashion by using fixed values for parameters such as the size of the successor set, size of the routing table, and rate of maintenance messages. The problem with this approach is that it is not possible to achieve a low failure rate and a low communication overhead by using fixed parameters. Instead, a better approach is to allow the system to take into account the evolution of network conditions and adapt to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHTベースのオーバーレイネットワークは、自己組織化、スケーラブル、かつ信頼性があります。しかし、これらの機能はコストで来る：オーバーレイネットワークにおけるピアが状態をルーティング維持するために、ネットワークの帯域幅を消費する必要があります。ほとんどのDHTは、ルーティング上の解約の望ましくない影響に対抗するために定期的な安定化ルーチンを使用します。 DHTのパラメータを設定するために、解約率とネットワークサイズなどのいくつかの特性が事前に知られている必要があります。これらの特性は、その後、後続セット、ルーティングテーブルのサイズ、および保守メッセージの速度の大きさなどのパラメータの固定値を使用して、静的な方法でDHTを構成するために使用されます。このアプローチの問題点は、固定されたパラメータを用いて、低故障率と低い通信オーバーヘッドを達成することは不可能であるということです。代わりに、より良いアプローチは、システムは、アカウントにネットワークの状態の進化を取り、それらに適応できるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document extends the mandatory-to-implement chord-reload algorithm by making it self-tuning. The use of the self-tuning feature is optional. However, when used, it needs to be supported by all peers in the RELOAD overlay network. The fact that a RELOAD overlay uses the self-tuning feature is indicated in the RELOAD overlay configuration document using the CHORD-SELF-TUNING algorithm name specified in Section 9.2 in the topology-plugin element. Two main advantages of self-tuning are that users no longer need to tune every DHT parameter correctly for a given operating environment and that the system adapts to changing operating conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、その自己チューニングすることによって、実装に必須の弦リロードアルゴリズムを拡張します。セルフチューニング機能の使用はオプションです。使用された場合しかし、それはRELOADオーバーレイネットワーク内のすべてのピアによってサポートされる必要があります。 RELOADオーバーレイはセルフチューニング機能を使用するという事実は、トポロジ・プラグイン要素内の9.2節で指定されたCHORD-セルフチューニングアルゴリズム名を使用してRELOADオーバーレイ設定文書で示されています。セルフチューニングの2つの主な利点は、ユーザーがもはや特定の動作環境のために、システムが動作条件の変化に適応していること、すべてのDHTパラメータを正しくチューニングする必要はありませんということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remainder of this document is structured as follows: Section 2 provides definitions of terms used in this document. Section 3 discusses alternative approaches to stabilization operations in DHTs, including reactive stabilization, periodic stabilization, and adaptive stabilization. Section 4 gives an introduction to the Chord DHT algorithm. Section 5 describes how this document extends the stabilization routine of the chord-reload algorithm. Section 6 describes how the stabilization rate and routing table size are calculated in an adaptive fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように、この文書の残りの部分は構成されている：第2節では、本書で使用される用語の定義を提供します。第3節では、反応性の安定化、定期的な安定化、および適応安定化を含むのDHTにおける安定化事業への代替アプローチを、説明します。第4節では、和音DHTアルゴリズムを紹介しています。第5節は、この文書は和音リロードアルゴリズムの安定化ルーチンを拡張する方法について説明します。セクション6は、安定化レートおよびルーティングテーブルサイズは適応方法で計算される方法を記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、 &#34;SHALL&#34;、 &#34;SHOULD&#34;、 &#34;ないもの&#34;、 &#34;推奨&#34; &#34;ない（SHOULD NOT）&#34;、 &#34;MAY&#34;、 &#34;推奨NOT&#34;、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses terminology and definitions from the RELOAD base specification [RFC6940].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書リロードベース仕様[RFC6940]の用語および定義を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
numBitsInNodeId: Specifies the number of bits in a RELOAD Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
numBitsInNodeIdは：リロードノードIDのビット数を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHT: Distributed Hash Tables are a class of decentralized distributed systems that provide a lookup service similar to a regular hash table. Given a key, any peer participating in the system can retrieve the value associated with that key. The responsibility for maintaining the mapping from keys to values is distributed among the peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHT：分散ハッシュテーブルは、通常のハッシュテーブルに似た検索サービスを提供分散型分散システムの一種です。キー考えると、システムに参加するすべてのピアは、そのキーに関連付けられた値を取得することができます。値へのキーのマッピングを維持する責任は、ピア間で分配されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chord Ring: The Chord DHT uses ring topology and orders identifiers on an identifier circle of size 2^numBitsInNodeId. This identifier circle is called the Chord ring. On the Chord ring, the responsibility for a key k is assigned to the node whose identifier equals to or immediately follows k.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードリング：コードDHTサイズ2 ^ numBitsInNodeIdの識別子サークルでリングトポロジと注文識別子を使用します。この識別子サークルは、Chordリングと呼ばれています。 Chordリングに、キーKの責任は、その識別子に等しいか、または直ちにKを次のノードに割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finger Table: A data structure with up to (but typically less than) numBitsInNodeId entries maintained by each peer in a Chord-based overlay. The ith entry in the finger table of peer n contains the identity of the first peer that succeeds n by at least 2^(numBitsInNodeId-i) on the Chord ring. This peer is called the ith finger of peer n. As an example, the first entry in the finger table of peer n contains a peer halfway around the Chord ring from peer n. The purpose of the finger table is to accelerate lookups.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィンガーテーブル：コードベースのオーバレイ内の各ピアによって維持されるまでnumBitsInNodeId（典型的にはより少ない）エントリを有するデータ構造。ピアnのフィンガーテーブル内のi番目のエントリは、Chordリング上に少なくとも2 ^（numBitsInNodeId-I）でnは成功した最初のピアのアイデンティティを含んでいます。このピアはピアnのi番目の指と呼ばれています。一例として、ピアnのフィンガーテーブルの最初のエントリは、ピアNからChordリングの周りピア途中を含んでいます。フィンガーテーブルの目的は、検索を加速することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n.id: In this document, this abbreviation is used to refer to the Node-ID of peer n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
n.id：この文書では、この略語は、ピアNのノードIDを参照するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O(g(n)): Informally, saying that some equation f(n) = O(g(n)) means that f(n) is less than some constant multiple of g(n). For the formal definition, please refer to [Weiss1998].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O（G（N））：非公式に、いくつかの式f（n）は= O（G（N））はF（n）はG（N）の一部の定数倍未満であることを意味するという。正式な定義については、[Weiss1998]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Omega(g(n)): Informally, saying that some equation f(n) = Omega(g(n)) means that f(n) is more than some constant multiple of g(n). For the formal definition, please refer to [Weiss1998].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オメガ（G（N））：非公式に、いくつかの式f（N）という=オメガ（G（N））はF（n）はGのいくつかの定数倍（N）以上であることを意味します。正式な定義については、[Weiss1998]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Percentile: The Pth (0&lt;=P&lt;=100) percentile of N values arranged in ascending order is obtained by first calculating the (ordinal) rank n=(P/100)*N, rounding the result to the nearest integer and then taking the value corresponding to that rank.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パーセンタイル：昇順に配列されたN値のPTH（0 &lt;= P &lt;= 100）パーセンタイルはまず最も近い整数に結果を丸めると、（序）ランクN =（P / 100）* Nを計算することによって得られます。そのランクに対応する値を取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Predecessor List: A data structure containing the first r predecessors of a peer on the Chord ring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先行リスト：Chordリング上のピアの第1のR前任者を含むデータ構造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Successor List: A data structure containing the first r successors of a peer on the Chord ring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後続リスト：Chordリング上のピアの第1のR後継を含むデータ構造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neighborhood Set: A term used to refer to the set of peers included in the successor and predecessor lists of a given peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
近隣セット：所与のピアの後継と先行リストに含まれるピアのセットを参照するために使用される用語。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routing Table: Contents of a given peer&#39;s routing table include the set of peers that the peer can use to route overlay messages. The routing table is made up of the finger table, successor list, and predecessor list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングテーブル：指定したピアのルーティングテーブルの内容は、ピアがルートオーバーレイメッセージに使用できるピアのセットが含まれています。ルーティングテーブルは、フィンガーテーブル、後継者のリスト、および前身のリストで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Introduction to Stabilization in DHTs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
DHTで安定3.入門
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHTs use stabilization routines to counter the undesirable effects of churn on routing. The purpose of stabilization is to keep the routing information of each peer in the overlay consistent with the constantly changing overlay topology. There are two alternative approaches to stabilization: periodic and reactive [Rhea2004]. Periodic stabilization can either use a fixed stabilization rate or calculate the stabilization rate in an adaptive fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHTは、ルーティング上の解約の望ましくない影響に対抗するための安定化ルーチンを使用しています。安定化の目的は、常に変化オーバーレイトポロジーと一致するオーバーレイ内の各ピアのルーティング情報を維持することです。定期的な反応性[Rhea2004]：安定化には2つの代替アプローチがあります。定期的な安定化は、固定された安定化レートを使用するか、適応的な方法で安定化レートを計算することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Reactive versus Periodic Stabilization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 定期的な安定化対反応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In reactive stabilization, a peer reacts to the loss of a peer in its neighborhood set or to the appearance of a new peer that should be added to its neighborhood set by sending a copy of its neighbor table to all peers in the neighborhood set. Periodic recovery, in contrast, takes place independently of changes in the neighborhood set. In periodic recovery, a peer periodically shares its neighborhood set with each or a subset of the members of that set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
反応性の安定化では、ピアは、その近傍のセットや近所のセット内のすべてのピアにそのネイバーテーブルのコピーを送信することにより、設定しその近傍に追加すべき新しいピアの外観ピアの損失に反応します。定期的な回復は、対照的に、近所のセットでの変更とは無関係に行われます。定期的な回復では、ピアは、定期的に各あるいはそのセットのメンバーのサブセットとその近傍のセットを共有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chord-reload algorithm [RFC6940] supports both reactive and periodic stabilization. It has been shown in [Rhea2004] that reactive stabilization works well for small neighborhood sets (i.e., small overlays) and moderate churn. However, in large-scale (e.g., 1000 peers or more [Rhea2004]) or high-churn overlays, reactive stabilization runs the risk of creating a positive feedback cycle, which can eventually result in congestion collapse. In [Rhea2004], it is shown that a 1000-peer overlay under churn uses significantly less bandwidth and has lower latencies when periodic stabilization is used than when reactive stabilization is used. Although in the experiments carried out in [Rhea2004], reactive stabilization performed well when there was no churn, its bandwidth use was observed to jump dramatically under churn. At higher churn rates and larger scale overlays, periodic stabilization uses less bandwidth and the resulting lower contention for the network leads to lower latencies. For this reason, most DHTs, such as CAN [CAN], Chord [Chord], Pastry [Pastry], and Bamboo [Rhea2004], use periodic stabilization [Ghinita2006]. As an example, the first version of Bamboo used reactive stabilization, which caused Bamboo to suffer from degradation in performance under churn. To fix this problem, Bamboo was modified to use periodic stabilization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
和音リロードアルゴリズム[RFC6940]は無効と定期の両方の安定化をサポートしています。反応性安定化が小さい近傍セット（即ち、小さなオーバーレイ）と適度解約のためにうまく機能すること[Rhea2004]に示されています。しかし、大規模（例えば1000のピア以上【Rhea2004]）または高チャーンオーバーレイにおいて、反応性安定化は、最終的に輻輳崩壊をもたらし得る正のフィードバックサイクルを作成する危険を冒します。 【Rhea2004】においては、チャーン下1000ピアオーバーレイが有意に少ない帯域幅を使用し、定期的な安定化が使用される場合、反応性の安定化よりも、使用されたときに低いレイテンシを有することが示されています。何の解約がなかったとき[Rhea2004]で行った実験では、反応性の安定化が十分に行われますが、その帯域幅の使用は、解約の下で劇的にジャンプすることが観察されました。高い解約率と大規模なオーバーレイでは、定期的な安定化は少ない帯域幅を使用し、ネットワークのための結果の下の競合が低レイテンシにつながります。この理由のため、例えばCANなどのほとんどのDHTは、コード[コード]、ペストリー[ペストリー]、及び竹[Rhea2004]、周期安定化[Ghinita2006]を使用する[CAN]。一例として、竹の最初のバージョンは、竹が解約下性能低下に悩まさせる反応安定性を、使用しました。この問題を解決するには、竹は、定期的な安定化を使用するように変更されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Chord, periodic stabilization is typically done both for successors and fingers. An alternative strategy is analyzed in [Krishnamurthy2008]. In this strategy, called the &#34;correction-on-change maintenance strategy&#34;, a peer periodically stabilizes its successors but does not do so for its fingers. Instead, finger pointers are stabilized in a reactive fashion. The results obtained in [Krishnamurthy2008] imply that although the correction-on-change strategy works well when churn is low, periodic stabilization outperforms the correction-on-change strategy when churn is high.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードでは、定期的な安定化は、一般的に後継者と指の両方に行われます。代替戦略は[Krishnamurthy2008]で分析されます。この戦略では、ピアは定期的にその後継者を安定させるが、その指のためにそうしない、「補正オンチェンジメンテナンス戦略」と呼ばれます。代わりに、指ポインタが反応する形で安定化されています。 【Krishnamurthy2008]で得られた結果は、チャーンが低い場合に補正オン変化戦略はうまく機能するが、定期的な安定化は、チャーンが高い補正オン変化戦略を凌駕することを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Configuring Periodic Stabilization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 定期的な安定化の設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When periodic stabilization is used, one faces the problem of selecting an appropriate execution rate for the stabilization procedure. If the execution rate of periodic stabilization is high, changes in the system can be quickly detected, but at the disadvantage of increased communication overhead. Alternatively, if the stabilization rate is low and the churn rate is high, routing tables become inaccurate and DHT performance deteriorates. Thus, the problem is setting the parameters so that the overlay achieves the desired reliability and performance even in challenging conditions, such as under heavy churn. This naturally results in high cost during periods when the churn level is lower than expected, or alternatively, poor performance or even network partitioning in worse than expected conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定期的な安定化が使用される場合、一方は安定化処置のための適切な実行速度を選択する問題に直面しています。定期的な安定化の実行速度が高い場合、システムの変化を迅速に検出するが、増加した通信オーバヘッドの欠点にすることができます。安定化率が低く、解約率が高い場合あるいは、ルーティングテーブルが不正確になるとDHTの性能が劣化します。オーバーレイはさらに、そのような重い解約下などの厳しい状況において、所望の信頼性と性能を達成するように、したがって、問題は、パラメータを設定します。これは、当然解約レベルが予想よりも低い場合、あるいは予想より悪い条件で、パフォーマンスの低下、あるいはネットワーク分割期間に高コストになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to selecting an appropriate stabilization interval, regardless of whether or not periodic stabilization is used, an appropriate size needs to be selected for the neighborhood set and for the finger table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適切な安定化間隔を選択することに加えて、関係なく、定期的な安定化が使用されているか否かの、適切な大きさは、近隣セットおよびフィンガーテーブルのために選択される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current approach is to configure overlays statically. This works in situations where perfect information about the future is available. In situations where the operating conditions of the network are known in advance and remain static throughout the lifetime of the system, it is possible to choose fixed optimal values for parameters such as stabilization rate, neighborhood set size and routing table size. However, if the operating conditions (e.g., the size of the overlay and its churn rate) do not remain static but evolve with time, it is not possible to achieve both a low lookup failure rate and a low communication overhead by using fixed parameters [Ghinita2006].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のアプローチは、静的にオーバーレイを設定することです。これは、将来に関する完璧な情報が利用可能である状況で動作します。ネットワークの動作状態が予め知られており、システムの寿命全体にわたって静的なままされる状況では、そのような安定化速度、近隣セットのサイズおよびルーティングテーブルサイズなどのパラメータのための固定された最適な値を選択することが可能です。動作条件（例えば、オーバーレイ及びその解約率の大きさ）が静止したままが、時間とともに進化していない場合は、固定パラメータを使用することにより、低ルックアップ故障率と低通信オーバーヘッドの両方を達成することは不可能です[ Ghinita2006]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, to configure the Chord DHT algorithm, one needs to select values for the following parameters: size of successor list, stabilization interval, and size of the finger table. To select an appropriate value for the stabilization interval, one needs to know the expected churn rate and overlay size. According to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後続リストのサイズ、安定化間隔、およびフィンガーテーブルのサイズ：一例として、コードDHTアルゴリズムを構成するために、一つは、次のパラメータの値を選択する必要があります。安定化間隔の適切な値を選択するには、一つは予想解約率とオーバーレイのサイズを知っておく必要があります。による
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Liben-Nowell2002], a Chord network in a ring-like state remains in a ring-like state as long as peers send Omega(square(log(N))) messages before N new peers join or N/2 peers fail. Thus, in a 500-peer overlay churning at a rate such that one peer joins and one peer leaves the network every 30 seconds, an appropriate stabilization interval would be on the order of 93 s. According to [Chord], the size of the successor list and finger table should be on the order of log(N). Already a successor list of a modest size (e.g., log2(N) or 2*log2(N), which is the successor list size used in [Chord]) makes it very unlikely that a peer will lose all of its successors, which would cause the Chord ring to become disconnected. Thus, in a 500-peer network each peer should maintain on the order of nine successors and fingers. However, if the churn rate doubles and the network size remains unchanged, the stabilization rate should double as well. That is, the appropriate maintenance interval would now be on the order of 46 s. On the other hand, if the churn rate becomes, e.g., six-fold and the size of the network grows to 2000 peers, on the order of 11 fingers and successors should be maintained and the stabilization interval should be on the order of 42 s. If one continued using the old values, this could result in inaccurate routing tables, network partitioning, and deteriorating performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[リベニ-Nowell2002]、リング状の状態でコード・ネットワークであればN新しいピアは参加又はN / 2ピアが失敗する前に、ピアは、オメガ（正方形（）（Nログ））メッセージを送信するように、リング状の状態のままです。従って、一つのピアが参加し、一方のピアがネットワークごとに30秒を残すような速度でかき回す500ピアオーバレイに、適切な安定化間隔が93秒のオーダーであろう。 [コード]によれば、後続リストとフィンガーテーブルのサイズは、log（N）のオーダーであるべきです。すでに控えめな大きさ（例えば、LOG2（N）または[コード]で使用される後継者リストのサイズである2 * LOG2（N）、）の後継者リストには、ピアがその後継のすべてを失うことになること、それは非常に低いなり、そのChordリングが切断してしまいます。従って、500-ピア・ネットワーク内の各ピアは、9つの後継と指のために維持しなければなりません。解約率が倍増し、ネットワークサイズが変わらない場合は、安定化率も同様に倍増する必要があります。つまり、適切なメンテナンス間隔は現在、46秒程度になります。一方、解約率になった場合、例えば、6倍、ネットワークのサイズ2000のピアに成長し、11本の指及び後継の順序で維持されるべきであり、安定化間隔が42秒のオーダーであるべきです。 1は、古い値を使用し続けた場合、これは不正確なルーティングテーブル、ネットワーク分割、および悪化パフォーマンスにつながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Adaptive Stabilization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 適応安定化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A self-tuning DHT takes into consideration the continuous evolution of network conditions and adapts to them. In a self-tuning DHT, each peer collects statistical data about the network and dynamically adjusts its stabilization rate, neighborhood set size, and finger table size based on the analysis of the data [Ghinita2006]. Reference [Mahajan2003] shows that by using self-tuning, it is possible to achieve high reliability and performance even in adverse conditions with low maintenance cost. Adaptive stabilization has been shown to outperform periodic stabilization in terms of both lookup failures and communication overhead [Ghinita2006].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セルフチューニングDHTを考慮にネットワークの状況の継続的な進化を取り、それらに適応します。セルフチューニングDHTにおいて、各ピアは、ネットワークに関する統計データを収集し、動的データ[Ghinita2006]の分析に基づいて、その安定化の速度、近隣セットのサイズ、およびフィンガーテーブルのサイズを調整します。参考文献[Mahajan2003]セルフチューニングを使用することによって、それも低メンテナンスコストで不利な条件での高い信頼性と性能を達成することが可能であることを示しています。適応的な安定化は、ルックアップ失敗と通信オーバヘッド[Ghinita2006]の両方の点で周期的安定化を上回ることが示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Introduction to Chord
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
コード4.入門
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chord [Chord] is a structured P2P algorithm that uses consistent hashing to build a DHT out of several independent peers. Consistent hashing assigns each peer and resource a fixed-length identifier. Peers use SHA-1 as the base hash function to generate the identifiers. As specified in RELOAD base [RFC6940], the length of the identifiers is numBitsInNodeId=128 bits. The identifiers are ordered on an identifier circle of size 2^numBitsInNodeId. On the identifier circle, key k is assigned to the first peer whose identifier equals or follows the identifier of k in the identifier space. The identifier circle is called the Chord ring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コード[コード]は、いくつかの独立したピアのうち、DHTを構築するために一貫性のあるハッシュを使用して構造化P2Pアルゴリズムです。一貫したハッシングは、各ピアを割り当て、固定長の識別子をリソース。ピアは、識別子を生成するために、ベースハッシュ関数としてSHA-1を使用します。リロードベース[RFC6940]で指定されるように、識別子の長さはnumBitsInNodeId = 128ビットです。識別子は、大きさ2 ^ numBitsInNodeIdの識別子円上に並べられます。識別子円上に、鍵Kは、その識別子に等しい又は識別子空間におけるkの識別子に続く最初のピアに割り当てられます。識別子円はChordリングと呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Different DHTs differ significantly in performance when bandwidth is limited. It has been shown that when compared to other DHTs, the advantages of Chord include that it uses bandwidth efficiently and can achieve low lookup latencies at little cost [Li2004].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帯域幅が制限されているときに別のDHTは、性能に大きく異なります。他のDHTと比較した場合、コードの利点は、それが効率的に帯域幅を使用し、[Li2004】少ないコストで低ルックアップ待ち時間を達成できることを含むことが示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simple lookup mechanism could be implemented on a Chord ring by requiring each peer to only know how to contact its current successor on the identifier circle. Queries for a given identifier could then be passed around the circle via the successor pointers until they encounter the first peer whose identifier is equal to or larger than the desired identifier. Such a lookup scheme uses a number of messages that grows linearly with the number of peers. To reduce the cost of lookups, Chord maintains also additional routing information; each peer n maintains a data structure with up to numBitsInNodeId entries, called the finger table. The first entry in the finger table of peer n contains the peer halfway around the ring from peer n. The second entry contains the peer that is 1/4th of the way around, the third entry the peer that is 1/8th of the way around, etc. In other words, the ith entry in the finger table at peer n contains the identity of the first peer s that succeeds n by at least 2^(numBitsInNodeId-i) on the Chord ring. This peer is called the ith finger of peer n. The interval between two consecutive fingers is called a finger interval. The ith finger interval of peer n covers the range [n.id + 2^(numBitsInNodeId-i), n.id + 2^(numBitsInNodeId-i+1)) on the Chord ring. In an N-peer network, each peer maintains information about O(log(N)) other peers in its finger table. As an example, if N=100000, it is sufficient to maintain 17 fingers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単純なルックアップメカニズムは、それぞれ識別子のみ円上の現在の後継者に連絡する方法を知っているピア要求することにより、Chordリングに実装することができます。彼らは、その識別子に等しいか、または所望の識別子よりも大きい最初のピアに遭遇するまで、指定された識別子のクエリは、次に、後続ポインタを介して、円の周りに通すことができます。このような検索方式は、ピアの数に対して直線的に増大するメッセージの数を使用しています。検索のコストを削減するために、コードはまた、追加のルーティング情報を保持します。各ピアN numBitsInNodeIdエントリまで持つデータ構造を維持するには、フィンガーテーブルと呼ばれます。ピアnのフィンガーテーブルの最初のエントリは、ピアNからリングの周りピア途中を含んでいます。 2番目のエントリは、換言すれば、等を回避する方法の1/4であるピア、3番目のエントリを回避する方法の1/8であるピアが含まれ、ピアnにおけるフィンガーテーブル内のi番目のエントリは、IDが含まれていますChordリング上に少なくとも2 ^（numBitsInNodeId-I）でnは成功した第1のピア秒。このピアはピアnのi番目の指と呼ばれています。二つの連続の指の間隔を指間隔と呼ばれています。ピアnのi番目の指の間隔が範囲をカバー[n.id + 2 ^（numBitsInNodeId-I）、n.id + 2 ^（numBitsInNodeId-I + 1））Chordリングに。 N  - ピア・ネットワークでは、各ピアは、そのフィンガーテーブルにおけるOについての情報（ログ（N））他のピアを維持します。 Nは100000 =場合の例として、17本の指を維持するのに十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chord needs all peers&#39; successor pointers to be up to date in order to ensure that lookups produce correct results as the set of participating peers changes. To achieve this, peers run a stabilization protocol periodically in the background. The stabilization protocol of the original Chord algorithm uses two operations: successor stabilization and finger stabilization. However, the Chord algorithm of RELOAD base defines two additional stabilization components, as will be discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードは、ルックアップが参加しているピアの設定が変更された正しい結果を生成することを確実にするために、最新であることを、すべてのピアの後継ポインタを必要とします。これを達成するために、ピアは、バックグラウンドで定期的に安定化プロトコルを実行します。後継の安定化と指の安定化：元のコードのアルゴリズムの安定化プロトコルは、2つの操作を使用しています。後述するようにしかし、リロードベースのコード・アルゴリズムは、二つの追加の安定化成分を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To increase robustness in the event of peer failures, each Chord peer maintains a successor list of size r, containing the peer&#39;s first r successors. The benefit of successor lists is that if each peer fails independently with probability p, the probability that all r successors fail simultaneously is only p^r.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア失敗の場合にロバスト性を高めるために、各コード・ピアは、ピアの最初のr個の後継を含む、サイズrの後継者リストを維持します。後継者リストの利点は、各ピアは、確率pで独立して失敗した場合、すべての後継者が同時に故障rの確率はpのみ^ Rであるということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The original Chord algorithm maintains only a single predecessor pointer. However, multiple predecessor pointers (i.e., a predecessor list) can be maintained to speed up recovery from predecessor failures. The routing table of a peer consists of the successor list, finger table, and predecessor list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オリジナルのコード・アルゴリズムは、単一の前身ポインタを維持しています。しかし、複数の先行ポインタ（すなわち、先行リスト）先行障害からの回復をスピードアップするために維持することができます。ピアのルーティングテーブルは、後継者リスト、フィンガーテーブル、及び先行リストから成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Extending Chord-Reload to Support Self-Tuning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.セルフチューニングをサポートするためのコードリロードを拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes how the mandatory-to-implement chord-reload algorithm defined in RELOAD base [RFC6940] can be extended to support self-tuning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、強制的に実装リロードベース[RFC6940]で定義されたコードリロードアルゴリズムはセルフチューニングをサポートするように拡張することができる方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chord-reload algorithm supports both reactive and periodic recovery strategies. When the self-tuning mechanisms defined in this document are used, the periodic recovery strategy is used. Further, chord-reload specifies that at least three predecessors and three successors need to be maintained. When the self-tuning mechanisms are used, the appropriate sizes of the successor list and predecessor list are determined in an adaptive fashion based on the estimated network size, as will be described in Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
和音リロードアルゴリズムは、反応性と定期的な回復戦略の両方をサポートしています。この文書で定義されたセルフチューニング・メカニズムを使用する場合には、定期的な回復戦略が使用されています。さらに、和音リロードは、少なくとも3人の前任者と3つの後継者を維持する必要があることを指定します。自己調整メカニズムが使用される場合、後続リストと先行リストの適切なサイズは、セクション6で説明されるように、推定されたネットワークのサイズに基づいて、適応的な方法で決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in RELOAD base [RFC6940], each peer maintains a stabilization timer. When the stabilization timer fires, the peer restarts the timer and carries out the overlay stabilization routine. Overlay stabilization has four components in chord-reload:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードベース[RFC6940]で指定されるように、各ピアは、安定化タイマーを維持します。安定タイマ火災は、ピアは、タイマーを再起動し、オーバーレイ安定化ルーチンを実行するとき。オーバーレイ安定化は和音リロードの4つのコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Update the neighbor table. We refer to this as &#34;neighbor stabilization&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.ネイバーテーブルを更新します。私たちは、「隣人の安定化」としてこれを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Refreshing the finger table. We refer to this as &#34;finger stabilization&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.フィンガーテーブルを更新します。私たちは、「指の安定化」としてこれを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Adjusting finger table size.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.調整フィンガーテーブルのサイズ。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Detecting partitioning. We refer to this as &#34;strong stabilization&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.パーティションを検出します。私たちは、「強い安定」としてこれを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in RELOAD base [RFC6940], a peer sends periodic messages as part of the neighbor stabilization, finger stabilization, and strong stabilization routines. In neighbor stabilization, a peer periodically sends an Update request to every peer in its connection table. The default time is every ten minutes. In finger stabilization, a peer periodically searches for new peers to include in its finger table. This time defaults to one hour. This document specifies how the neighbor stabilization and finger stabilization intervals can be determined in an adaptive fashion based on the operating conditions of the overlay. The subsections below describe how this document extends the four components of stabilization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードベース[RFC6940]で指定されるように、ピアは、近隣の安定化、指の安定化、および強力な安定化ルーチンの一部として定期的にメッセージを送信します。近隣の安定化では、ピアは、定期的にその接続テーブル内のすべてのピアへの更新要求を送信します。デフォルトの時間は10分ごとです。指の安定化では、ピアは、定期的にそのフィンガーテーブルに含める新しいピアを検索します。一時間にこの時間は、デフォルト設定されています。この文書では、隣人の安定化と指の安定化間隔がオーバーレイの動作条件に基づく適応形で決定することができる方法を指定します。以下のサブセクションでは、この文書は安定化の4つのコンポーネントが拡張する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Update Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 更新要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in RELOAD base [RFC6940], the neighbor and finger stabilization procedures are implemented using Update requests. RELOAD base defines three types of Update requests: &#39;peer_ready&#39;,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードベース[RFC6940]に記載されているように、隣接指安定化手順は、更新要求を使用して実装されています。 RELOADベースは更新要求の3種類を定義しています。「peer_ready」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#39;neighbors&#39;, and &#39;full&#39;. Regardless of the type, all Update requests include an &#39;uptime&#39; field. The self-tuning extensions require information on the uptimes of peers in the routing table. The sender of an Update request includes its current uptime (in seconds) in the &#39;uptime&#39; field. Regardless of the type, all Update requests MUST include an &#39;uptime&#39; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「隣人」、および「フル」。タイプに関係なく、すべての更新要求は、「稼働時間」フィールドが含まれます。セルフチューニング機能拡張は、ルーティングテーブル内のピアの稼働時間に関する情報を必要としています。更新リクエストの送信者が「稼働時間」フィールドに（秒）、現在の稼働時間を含んでいます。タイプに関係なく、すべての更新要求は、「稼働時間」フィールドを含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When self-tuning is used, each peer decides independently the appropriate size for the successor list, predecessor list, and finger table. Thus, the &#39;predecessors&#39;, &#39;successors&#39;, and &#39;fingers&#39; fields included in RELOAD Update requests are of variable length. As specified in RELOAD [RFC6940], variable-length fields are on the wire preceded by length bytes. In the case of the successor list, predecessor list, and finger table, there are two length bytes (allowing lengths up to 2^16-1). The number of NodeId structures included in each field can be calculated based on the length bytes since the size of a single NodeId structure is 16 bytes. If a peer receives more entries than fit into its successor list, predecessor list, or finger table, the peer MUST ignore the extra entries. A peer may also receive less entries than it currently has in its own data structure. In that case, it uses the received entries to update only a subset of the entries in its data structure. As an example, a peer that has a successor list of size 8 may receive a successor list of size 4 from its immediate successor. In that case, the received successor list can only be used to update the first few successors on the peer&#39;s successor list. The rest of the successors will remain intact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セルフチューニングが使用される場合、各ピアは、独立して、後続リスト、先行リスト、およびフィンガーテーブルの適切なサイズを決定します。このように、「前任者」、「後継者」、および「指のフィールドはRELOAD更新要求に含まれる変数の長さのものです。 RELOAD [RFC6940]で指定されるように、可変長フィールドは、長さバイトが先行線上にあります。後続リスト、先行リスト、およびフィンガーテーブルの場合には、（2 ^ 16-1までの長さを可能にする）は、2つの長さのバイトがあります。単一NODEID構造のサイズは16バイトであるので、各フィールドに含まNODEID構造の数は、長さバイトに基づいて算出することができます。ピアがその後継者リスト、前任者のリスト、または指テーブルにフィットよりも多くのエントリを受信した場合、ピアは余分なエントリを無視しなければなりません。ピアは、それが現在、独自のデータ構造内に有しているよりも少ないエントリを受信することができます。その場合には、そのデータ構造内のエントリのサブセットのみを更新するために受信されたエントリを使用しています。一例として、サイズ8の後継者リストを有するピアは、その直後の後続のサイズ4の後継者リストを受信することができます。その場合には、受信後継者リストは、ピアの後継者リストの最初の数後継者を更新するために使用することができます。後継者の残りの部分はそのまま残ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Neighbor Stabilization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 近隣の安定化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the neighbor stabilization operation of chord-reload, a peer periodically sends an Update request to every peer in its connection table. In a small, low-churn overlay, the amount of traffic this process generates is typically acceptable. However, in a large-scale overlay churning at a moderate or high churn rate, the traffic load may no longer be acceptable since the size of the connection table is large and the stabilization interval relatively short. The self-tuning mechanisms described in this document are especially designed for overlays of the latter type. Therefore, when the self-tuning mechanisms are used, each peer only sends a periodic Update request to its first predecessor and first successor on the Chord ring; it MUST NOT send Update requests to others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードリロードの隣接安定動作では、ピアは、定期的に接続テーブル内のすべてのピアに更新要求を送信します。小さな、低解約オーバーレイでは、このプロセスが生成するトラフィックの量は、典型的には許容可能です。接続テーブルのサイズが大きく、安定化間隔が比較的短いので、中程度または高い解約率でかき回す大規模なオーバーレイで、トラフィック負荷は、もはや許容できないかもしれません。この文書に記載された自己調整機構は、特に後者のタイプのオーバーレイのために設計されています。自己調整メカニズムが使用される場合、したがって、それぞれは、ピアChordリング上の最初の前身と第後継者に定期的に更新要求を送信します。それは他の人への更新要求を送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The neighbor stabilization routine is executed when the stabilization timer fires. To begin the neighbor stabilization routine, a peer sends an Update request to its first successor and its first predecessor. The type of the Update request MUST be &#39;neighbors&#39;. The Update request includes the successor and predecessor lists of the sender. If a peer receiving such an Update request learns from the predecessor and successor lists included in the request that new peers can be included in its neighborhood set, it sends Attach requests to the new peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
近隣の安定化ルーチンが時に安定タイマーが起動実行されます。近隣の安定化ルーチンを開始するには、ピアは、その最初の後継者とその最初の前身に更新要求を送信します。更新要求のタイプは、「隣人」でなければなりません。更新要求は、送信者の後継者と前任者のリストが含まれています。このような更新要求を受けたピアは新しいピアがその近傍セットに含めることができ、要求に含まれて前任者と後継者のリストから学習した場合、それは新しいピアに要求を添付し送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a new peer has been added to the predecessor or successor list, an Update request of type &#39;peer_ready&#39; is sent to the new peer. This allows the new peer to insert the sender into its neighborhood set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいピアが先行または後続リストに追加された後、型「peer_ready」の更新要求が新しいピアに送信されます。これは、その近傍セットに差出人を挿入する新しいピアすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Finger Stabilization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 指の安定化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chord-reload specifies two alternative methods for searching for new peers to the finger table. Both of the alternatives can be used with the self-tuning extensions defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
和音リロードは、フィンガーテーブルに新しいピアを検索するための2つの代替方法を指定します。選択肢のどちらも、この文書で定義されたセルフチューニング機能拡張で使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Immediately after a new peer has been added to the finger table, a Probe request is sent to the new peer to fetch its uptime. The &#39;requested_info&#39; field of the Probe request MUST be set to contain the ProbeInformationType &#39;uptime&#39; defined in RELOAD base [RFC6940].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいピアがフィンガーテーブルに追加された直後に、プローブ要求は、その稼働時間を取得するために、新しいピアに送信されます。プローブリクエストの「requested_info」フィールドリロードベース[RFC6940]で定義さProbeInformationType「稼働時間」を含むように設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Adjusting Finger Table Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. フィンガーテーブルサイズの調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chord-reload algorithm defines how a peer can make sure that the finger table is appropriately sized to allow for efficient routing. Since the self-tuning mechanisms specified in this document produce a network size estimate, this estimate can be directly used to calculate the optimal size for the finger table. This mechanism is used instead of the one specified by chord-reload. A peer uses the network size estimate to determine whether it needs to adjust the size of its finger table each time when the stabilization timer fires. The way this is done is explained in Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードリロードアルゴリズムは、ピアは、フィンガーテーブルが適切に効率的なルーティングを可能にするように寸法決めされていることを確認することができる方法を定義します。この文書で指定されたセルフチューニングメカニズムは、ネットワークサイズの推定値を生成するので、この推定値は、直接フィンガーテーブルの最適なサイズを計算するために使用することができます。このメカニズムは、代わりに弦リロードで指定された一つで使用されています。ピアは、それが毎回安定タイマ起動そのフィンガーテーブルのサイズを調整する必要があるかどうかを決定するために、ネットワーク・サイズの推定値を使用します。これが行われる方法は、セクション6.2で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Detecting Partitioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. パーティションを検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not require any changes to the mechanism chord-reload uses to detect network partitioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、和音リロードがネットワーク分割を検出するために使用するメカニズムを変更する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. Leaving the Overlay
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. オーバーレイを残します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in RELOAD base [RFC6940], a leaving peer SHOULD send a Leave request to all members of its neighbor table prior to leaving the overlay. The &#39;overlay_specific_data&#39; field MUST contain the ChordLeaveData structure. The Leave requests that are sent to successors contain the predecessor list of the leaving peer. The Leave requests that are sent to the predecessors contain the successor list of the leaving peer. If a given successor can identify better predecessors (that is, predecessors that are closer to it on the Chord ring than its existing predecessors) than are already included in its predecessor lists by investigating the predecessor list it receives from the leaving peer, it sends Attach requests to them. Similarly, if a given predecessor identifies better successors by investigating the successor list it receives from the leaving peer, it sends Attach requests to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードベース[RFC6940]で指定されるように、離脱ピア前オーバーレイを出るまでその隣接テーブルのすべてのメンバーに離脱要求を送るべきです。 「overlay_specific_data」フィールドはChordLeaveData構造を含まなければなりません。後継者に送信された休暇申請を残しピアの前身のリストが含まれています。前任者に送信された休暇申請を残しピアの後継者リストが含まれています。与えられた後継者は、より良い前任者を特定できた場合（つまり、その既存の前任者よりもChordリング上のそれに近い前身である）は、すでにそれは残してピアから受信した前任者のリストを調べることにより、その前身リストに含まれているよりも、それがアタッチ送ります彼らに要求します。与えられた前任者は、それが残しピアから受信した後継者リストを調査することによって、より良い後継者を特定した場合も、それは彼らに要求を添付し送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Self-Tuning Chord Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.セルフチューニングコードのパラメータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section specifies how to determine an appropriate stabilization rate and routing table size in an adaptive fashion. The proposed mechanism is based on [Mahajan2003], [Liben-Nowell2002], and [Ghinita2006]. To calculate an appropriate stabilization rate, the values of three parameters must be estimated: overlay size N, failure rate U, and join rate L. To calculate an appropriate routing table size, the estimated network size N can be used. Peers in the overlay MUST recalculate the values of the parameters to self-tune the chord-reload algorithm at the end of each stabilization period before restarting the stabilization timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、適応様式で適切な安定化レート及びルーティングテーブルのサイズを決定する方法を指定します。提案されたメカニズムは、[Mahajan2003]に基づいており、[リベニ-Nowell2002]、および[Ghinita2006]。適切な安定化レートを計算するために、3つのパラメータの値を推定しなければならない：オーバーレイサイズN、故障率U、および適切なルーティングテーブルのサイズを算出する速度L.を結合し、推定されたネットワークサイズNを使用することができます。オーバーレイ内のピアは、安定化のタイマーを再起動する前に、各安定化期間の終了時に自己チューニングする弦リロードアルゴリズムをパラメータの値を再計算する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Estimating Overlay Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 見積もりオーバーレイサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Techniques for estimating the size of an overlay network have been proposed, for instance, in [Mahajan2003], [Horowitz2003], [Kostoulas2005], [Binzenhofer2006], and [Ghinita2006]. In Chord, the density of peer identifiers in the neighborhood set can be used to produce an estimate of the size of the overlay, N [Mahajan2003]. Since peer identifiers are picked randomly with uniform probability from the numBitsInNodeId-bit identifier space, the average distance between peer identifiers in the successor set is (2^numBitsInNodeId)/N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバレイネットワークの大きさを推定するための技術は、[Ghinita2006] [Binzenhofer2006]、[Kostoulas2005]、[Horowitz2003]、[Mahajan2003]において、例えば、提案されてきました。コードでは、近隣セット内のピア識別子の密度は、オーバーレイ、N [Mahajan2003]の大きさの推定値を生成するために使用することができます。ピア識別子はnumBitsInNodeIdビットの識別子空間から一様な確率でランダムに選択されているので、後続セット内のピア識別子との間の平均距離は、（2 ^ numBitsInNodeId）/ Nです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To estimate the overlay network size, a peer computes the average inter-peer distance d between the successive peers starting from the most distant predecessor and ending to the most distant successor in the successor list. The estimated network size is calculated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバレイネットワークのサイズを推定するために、ピアは、連続するピア最も遠い前任者から出発し、後続リストの中で最も遠い後継者に終了の間の平均相互ピア距離dを算出します。推定ネットワークサイズは次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                         2^numBitsInNodeId
                    N = -------------------
                                d
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This estimate has been found to be accurate within 15% of the real network size [Ghinita2006]. Of course, the size of the neighborhood set affects the accuracy of the estimate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この推定値は、実際のネットワークサイズ[Ghinita2006]の15％以内に正確であることが見出されています。もちろん、近所セットのサイズは、推定値の精度に影響を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During the join process, a joining peer fills its routing table by sending a series of Ping and Attach requests, as specified in RELOAD base [RFC6940]. Thus, a joining peer immediately has enough information at its disposal to calculate an estimate of the network size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加入プロセス中に、参加ピアは、リロードベース[RFC6940]で指定されるように、Pingの一連の送信と要求を添付することによって、そのルーティングテーブルを埋めます。したがって、接合ピアは直ちにネットワークの大きさの推定値を計算するために、その処分で十分な情報を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Determining Routing Table Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. ルーティングテーブルのサイズの決定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in RELOAD base [RFC6940], the finger table must contain at least 16 entries. When the self-tuning mechanisms are used, the size of the finger table MUST be set to max(ceiling(log2(N)), 16) using the estimated network size N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードベース[RFC6940]で指定されるように、フィンガーテーブルは、少なくとも16個のエントリを含んでいなければなりません。自己調整メカニズムが使用される場合、フィンガーテーブルのサイズは、推定されたネットワークのサイズNを用いて、MAX（天井（LOG2（N））、16）に設定しなければなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of the successor list MUST be set to a maximum of ceiling(log2(N)). An implementation can place a lower limit on the size of the successor list. As an example, the implementation might require the size of the successor list to be always at least three.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後続リストのサイズは、天井（LOG2（N））の最大値に設定しなければなりません。実装は、後継者リストのサイズに下限を配置することができます。例として、実装は常に、少なくとも3であることを後継者リストのサイズが必要な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of the predecessor list MUST be set to ceiling(log2(N)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先行リストのサイズは、天井（LOG2（N））に設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Estimating Failure Rate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 推定故障率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A typical approach is to assume that peers join the overlay according to a Poisson process with rate L and leave according to a Poisson process with rate parameter U [Mahajan2003]. The value of U can be estimated using peer failures in the finger table and neighborhood set [Mahajan2003]. If peers fail with rate U, a peer with M unique peer identifiers in its routing table should observe K failures in time K/(M*U). Every peer in the overlay maintains a history of the last K failures. The current time is inserted into the history when the peer joins the overlay. The estimate of U is calculated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的なアプローチは、ピアがU [Mahajan2003】率パラメータを有するポアソン過程に従うレートLを有するポアソン過程に従うオーバーレイに参加しておくことを前提とすることにあります。 Uの値は、[Mahajan2003]設定フィンガーテーブル及び周辺にピア失敗を使用して推定することができます。ピアが速度Uで失敗した場合は、そのルーティングテーブル内のM固有のピア識別子とピアは時間K /（M * U）にK障害を観察しなければなりません。オーバーレイ内のすべてのピアは、最後のKの失敗の履歴を保持します。ピアがオーバーレイに参加したときに、現在の時刻が歴史の中に挿入されています。 Uの推定値は次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             k
                     U = --------,
                          M * Tk
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where M is the number of unique peer identifiers in the routing table, Tk is the time between the first and the last failure in the history, and k is the number of failures in the history. If k is smaller than K, the estimate is computed as if there was a failure at the current time. It has been shown that an estimate calculated in a similar manner is accurate within 17% of the real value of U [Ghinita2006].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mは、ルーティングテーブル内の固有のピア識別子の数であり、Tkが第一および歴史の中で最後の故障の間の時間であり、kは歴史の中で失敗した回数です。 kがKより小さい場合、現在の時点で障害が発生したかのように、推定値が計算されます。同様に算出推定値はU [Ghinita2006]の実際の値の17％以内に正確であることが示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of the failure history K affects the accuracy of the estimate of U. One can increase the accuracy by increasing K. However, this has the side effect of decreasing responsiveness to changes in the failure rate. On the other hand, a small history size may cause a peer to overreact each time a new failure occurs. In [Ghinita2006], K is set to 25% of the routing table size. Use of this value is RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
故障履歴KのサイズしかしK.を増加させることによって、精度を高めることができるU.つの推定値の精度に影響を与え、これが故障率の変化に対する応答性を低下させる副作用を有します。一方、小さな歴史のサイズは、ピアは、新たな障害が発生するたびに過剰に反応する可能性があります。 【Ghinita2006]において、Kは、ルーティングテーブルのサイズの25％に設定されています。この値の使用を推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. Detecting Failures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. 障害の検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A new failure is inserted to the failure history in the following cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい障害は、以下の場合に故障履歴に挿入されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. A Leave request is received from a neighbor.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.休暇要求がネイバーから受信されます。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A peer fails to reply to a Ping request sent in the situation explained below. If no packets have been received on a connection during the past 2*Tr seconds (where Tr is the inactivity timer defined by Interactive Connectivity Establishment (ICE) [RFC5245]), a RELOAD Ping request MUST be sent to the remote peer. RELOAD mandates the use of Session Traversal Utilities for NAT (STUN) [RFC5389] for keepalives. STUN keepalives take the form of STUN Binding Indication transactions. As specified in ICE [RFC5245], a peer sends a STUN Binding Indication if there has been no packet sent on a connection for Tr seconds. Tr is configurable and has a default of 15 seconds. Although STUN Binding Indications do not generate a response, the fact that a peer has failed can be learned from the lack of packets (Binding Indications or application protocol packets) received from the peer. If the remote peer fails to reply to the Ping request, the sender should consider the remote peer to have failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.ピアは状況で送信されたPing要求に応答する失敗し、以下に説明します。パケットが（Trはインタラクティブ接続確立（ICE）[RFC5245]で定義された非アクティブタイマーです）過去2 * Trの秒の間の接続で受信されていない場合は、RELOAD Ping要求は、リモートピアに送らなければなりません。 RELOADは、キープアライブのためのNAT（STUN）[RFC5389]のセッショントラバーサルユーティリティの使用を義務付け。 STUNキープアライブはSTUNバインディング表示取引の形をとります。 ICE [RFC5245]で指定されているようにのTr秒間接続で送信されるいかなるパケットがなかった場合、ピアはSTUNバインディング指示を送信します。 Trが設定可能で、デフォルトの15秒を持っています。 STUNバインディング指示は応答を生成しないが、ピアが失敗したという事実は（適応症またはアプリケーション・プロトコル・パケットを結合）パケットの欠如から学習ピアから受信することができます。リモートピアがping要求に応答しなかった場合、送信者は、リモートピアが失敗したと考えるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an alternative to relying on STUN keepalives to detect peer failure, a peer could send additional, frequent RELOAD messages to every peer in its connection table. These messages could be Update requests, in which case they would serve two purposes: detecting peer failure and stabilization. However, as the cost of this approach can be very high in terms of bandwidth consumption and traffic load, especially in large-scale overlays experiencing churn, its use is NOT RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアの障害を検出するために、STUNキープアライブに頼る代わりに、ピアはその接続テーブル内のすべてのピアへの追加、頻繁RELOADメッセージを送信することができます。ピアの障害と安定化を検出する：これらのメッセージは、彼らは2つの目的があります。その場合には更新要求、である可能性があります。しかし、このアプローチの費用として、特に解約を経験して、大規模なオーバーレイでは、その使用は推奨されません、帯域幅の消費やトラフィック負荷の点で非常に高くなることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Estimating Join Rate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. レートに参加推定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reference [Ghinita2006] proposes that a peer can estimate the join rate based on the uptime of the peers in its routing table. An increase in peer join rate will be reflected by a decrease in the average age of peers in the routing table. Thus, each peer maintained an array of the ages of the peers in its routing table sorted in increasing order. Using this information, an estimate of the global peer join rate L is calculated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考文献[Ghinita2006]ピアは、そのルーティングテーブル内のピアの稼働時間に基づいて、参加率を推定することができることを提案しています。ピアの増加は、速度は、ルーティングテーブル内のピアの平均年齢の減少によって反映されるジョイン。したがって、各ピアは、昇順にソートそのルーティングテーブル内のピアの年齢の配列を維持しました。この情報を使用して、グローバルピアの推定値は、レートLは次のように計算され参加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                  N
                    L = ----------------------,
                         Ages[floor(rsize/2)]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where Ages is an array containing the ages of the peers in the routing table sorted in increasing order and rsize is the size of the routing table. It has been shown that the estimate obtained by using this method is accurate within 22% of the real join rate [Ghinita2006]. Of course, the size of the routing table affects the accuracy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
年齢は、昇順とRSIZEにソートルーティングテーブル内のピアの年齢を含む配列は、ルーティングテーブルのサイズである場合。なお、この方法を用いて得られた推定値は実際の参加率[Ghinita2006]の22％以内に正確であることが示されています。もちろん、ルーティングテーブルのサイズは、精度に影響を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order for this mechanism to work, peers need to exchange information about the time they have been present in the overlay. Peers receive the uptimes of their successors and predecessors during the stabilization operations since all Update requests carry uptime values. A joining peer learns the uptime of the admitting peer since it receives an Update from the admitting peer during the join procedure. Peers learn the uptimes of new fingers since they can fetch the uptime using a Probe request after having attached to the new finger.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムが機能するためには、ピアは、彼らがオーバーレイに存在していた時間についての情報を交換する必要があります。すべての更新要求がアップタイムの値を運ぶので、ピアは安定化作業中にその後継と前任者の稼働時間を受けます。それは参加手順中に認めるピアからアップデートを受信するので、接合ピアは認めるピアの稼働時間を学習します。彼らは新しい指に添付した後、プローブ要求を使用して稼働時間を取得することができますので、ピアは、新たな指の稼働時間を学びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. Estimate Sharing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. 見積りの共有
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To improve the accuracy of network size, join rate, and leave rate estimates, peers share their estimates. When the stabilization timer fires, a peer selects number-of-peers-to-probe random peers from its finger table and send each of them a Probe request. The targets of Probe requests are selected from the finger table rather than from the neighbor table since neighbors are likely to make similar errors when calculating their estimates. The number-of-peers-to-probe is a new element in the overlay configuration document. It is defined in Section 7. Both the Probe request and the answer returned by the target peer MUST contain a new message extension whose MessageExtensionType is &#39;self_tuning_data&#39;. This extension type is defined in Section 9.1. The &#39;extension_contents&#39; field of the MessageExtension structure MUST contain a SelfTuningData structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
率推定値を、ネットワークサイズの精度を向上させる割合に参加し、終了するには、ピアは彼らの見積もりを共有しています。安定タイマ起動は、ピアが選択したとき数のピア・ツー・プローブそのフィンガーテーブルからランダムなピアをそれらのプローブ要求をそれぞれ送信します。隣人が彼らの推定値を計算する際に同様のエラーをする可能性があるため、プローブ要求のターゲットはフィンガーテーブルからではなく、ネイバーテーブルから選択されています。数のピア・ツー・プローブは、オーバーレイ設定文書の新しい要素です。これは、セクション7プローブ要求とそのMessageExtensionType「self_tuning_data」で新しいメッセージ拡張を含まなければならない対象のピアによって返された答えの両方で定義されています。この拡張タイプは、セクション9.1で定義されています。 MessageExtension構造の「extension_contents」フィールドはSelfTuningData構造を含まなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               struct {
                 uint32                   network_size;
                 uint32                   join_rate;
                 uint32                   leave_rate;
               } SelfTuningData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the SelfTuningData structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにSelfTuningData構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
network_size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
network_size
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The latest network size estimate calculated by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
送信側で計算最新のネットワークサイズの見積もり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
join_rate
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
join_rate
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The latest join rate estimate calculated by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
送信側で計算した最新の参加率推定値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
leave_rate
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
leave_rate
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The latest leave rate estimate calculated by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
送信側で計算最新の休職率推定値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The join and leave rates are expressed as joins or failures per 24 hours. As an example, if the global join rate estimate a peer has calculated is 0.123 peers/s, it would include in the &#39;join_rate&#39; field the ceiling of the value 10627.2 (24*60*60*0.123 = 10627.2), that is, the value 10628.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結合や、24時間あたりの障害として参加し、去る率が表現されています。ピアが計算したグローバル参加率推定値は0.123ピア/ sである場合の例として、それはjoin_rate &#39;フィールドの値10627.2（24 * 60 * 60 * 0.123 = 10627.2）の天井を含むであろう、すなわち、値10628。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#39;type&#39; field of the MessageExtension structure MUST be set to contain the value &#39;self_tuning_data&#39;. The &#39;critical&#39; field of the structure MUST be set to False.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MessageExtension構造の「タイプ」フィールドには、値「self_tuning_data」を含むように設定しなければなりません。構造の「重要な」フィールドはfalseに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer stores all estimates it receives in Probe requests and answers during a stabilization interval. When the stabilization timer fires, the peer calculates the estimates to be used during the next stabilization interval by taking the 75th percentile (i.e., third quartile) of a data set containing its own estimate and the received estimates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア格納すべては、それが安定化間隔の間、プローブ要求および応答で受信推定します。安定タイマ火災は、ピアは、推定値は、それ自身の推定値を含むデータセットと受信された推定値の75パーセンタイル（すなわち、第三四分位数）を取ることによって、次の安定化間隔の間に使用されるように計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The default value for number-of-peers-to-probe is 4. This default value is recommended to allow a peer to receive a sufficiently large set of estimates from other peers. With a value of 4, a peer receives four estimates in Probe answers. On the average, each peer also receives four Probe requests each carrying an estimate. Thus, on the average, each peer has nine estimates (including its own) that it can use at the end of the stabilization interval. A value smaller than 4 is NOT RECOMMENDED to keep the number of received estimates high enough. As an example, if the value were 2, there would be peers in the overlay that would only receive two estimates during a stabilization interval. Such peers would only have three estimates available at the end of the interval, which may not be reliable enough since even a single exceptionally high or low estimate can have a large impact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数のピア・ツー・プローブのデフォルト値はこのデフォルト値は、ピアが他のピアからの推定値の十分に大きなセットを受信することを可能にすることが推奨される4です。 4の値と、ピアは、プローブ応答の4つの推定値を受信します。平均して、各ピアは、4つのプローブ要求推定値を運ぶそれぞれを受信します。このように、平均して、各ピアは、それが安定化間隔の終わりに使用することができる（それ自身を含む）9つの推定値を有しています。 4より小さい値が十分に高い受信推定値の数を維持することが推奨されていません。値が2であれば、一例として、唯一の安定化間隔の間に2つの推定値を受信するオーバーレイ内のピアが存在することになります。そのようなピアは、1つでも非常に高い又は低い推定値が大きな影響を持つことができるので、十分に信頼性がないかもしれない間隔の終わりに利用可能な3つの推定値を有するであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. Calculating the Stabilization Interval
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. 安定化間隔の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
According to [Liben-Nowell2002], a Chord network in a ring-like state remains in a ring-like state as long as peers send Omega(square(log(N))) messages before N new peers join or N/2 peers fail. We can use the estimate of peer failure rate, U, to calculate the time Tf in which N/2 peers fail:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[リベニ-Nowell2002]によれば、リング状の状態でコード・ネットワークであればピアがN新しいピアは参加前に、オメガ（正方形（ログ（N）））メッセージを送信したりN / 2ピアとしてリング状の状態のままで不合格。我々は、N / 2のピアが失敗Tfとする時間を計算するために、ピア失敗率、Uの推定値を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                  1
                           Tf = ------
                                 2*U
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on this estimate, a stabilization interval Tstab-1 is calculated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この推定値に基づいて、安定化間隔Tstab-1は次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                           Tf
                           Tstab-1 = -----------------
                                      square(log2(N))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, the estimated join rate L can be used to calculate the time in which N new peers join the overlay. Based on the estimate of L, a stabilization interval Tstab-2 is calculated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、推定加入率LはN新しいピアがオーバーレイに参加する時間を計算するのに使用することができます。 Lの推定値に基づいて、安定化間隔Tstab-2は、以下のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                               N
                            Tstab-2 = ---------------------
                                       L * square(log2(N))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the actual stabilization interval Tstab that is used can be obtained by taking the minimum of Tstab-1 and Tstab-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、使用される実際の安定化間隔TstabはTstab-1及びTstab-2の最小値を取ることによって得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results obtained in [Maenpaa2009] indicate that making the stabilization interval too small has the effect of making the overlay less stable (e.g., in terms of detected loops and path failures). Thus, a lower limit should be used for the stabilization period. Based on the results in [Maenpaa2009], a lower limit of 15 s is RECOMMENDED, since using a stabilization period smaller than this will with a high probability cause too much traffic in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Maenpaa2009]で得られた結果は、安定化間隔があまりにも小さくすることが（検出ループとパス障害の点で、例えば）オーバーレイがより安定する効果を有することを示します。従って、下限は安定化期間に使用されるべきです。 【Maenpaa2009]における結果に基づいて、15のSの下限は、オーバーレイに高い確率原因すぎるトラフィックと、この意志よりも小さい安定化期間を利用しているため、推奨されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Overlay Configuration Document Extension
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.オーバーレイ設定文書拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document extends the RELOAD overlay configuration document by adding one new element, &#34;number-of-peers-to-probe&#34;, inside each &#34;configuration&#34; element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、「数のピア・ツー・プローブ」は、それぞれ「構成」要素内部に一つの新たな要素を追加することによって、リロードオーバーレイ設定文書を拡張します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
self-tuning:number-of-peers-to-probe: The number of fingers to which Probe requests are sent to obtain their network size, join rate, and leave rate estimates. The default value is 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セルフチューニング：数のピア・ツー・プローブ：プローブ要求は、そのネットワークのサイズを取得率への参加、および速度の推定値を残して送信されるに指の数。デフォルト値は4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RELAX NG grammar for this element is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この要素のRELAX NG文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
namespace self-tuning = &#34;urn:ietf:params:xml:ns:p2p:self-tuning&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前空間のセルフチューニング= &#34;壷：IETF：のparams：XML：NS：P2P：セルフチューニング&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
parameter &amp;= element self-tuning:number-of-peers-to-probe { xsd:unsignedInt }?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメーター＆=エレメントセルフチューニング：数のピア・ツー・プローブ{XSD：unsignedInt型}？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This namespace is added into the &lt;mandatory-extension&gt; element in the overlay configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この名前空間は、オーバーレイ・コンフィギュレーション・ファイルの&lt;必須拡張&gt;要素に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the same way as malicious or compromised peers implementing the RELOAD base protocol [RFC6940] can advertise false network metrics or distribute false routing table information for instance in RELOAD Update messages, malicious peers implementing this specification may share false join rate, leave rate, and network size estimates. For such attacks, the same security concerns apply as in the RELOAD base specification. In addition, as long as the amount of malicious peers in the overlay remains modest, the statistical mechanisms applied in Section 6.5 (i.e., the use of 75th percentiles) to process the shared estimates a peer obtains help ensure that estimates that are clearly different from (i.e., larger or smaller than) other received estimates will not significantly influence the process of adapting the stabilization interval and routing table size. However, it should be noted that if an attacker is able to impersonate a high number of other peers in the overlay in strategic locations, it may be able to send a high enough number of false estimates to a victim and therefore influence the victim&#39;s choice of a stabilization interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードベースプロトコル[RFC6940]を実装悪意のあるまたは損なわピアが偽のネットワークメトリックをアドバタイズまたはリロード更新メッセージで、例えば、偽のルーティングテーブル情報を配信することができると同様に、この仕様を実装悪意のあるピアが速度を残し、偽参加率を共有すること、およびネットワークサイズの見積もり。このような攻撃のために、同じセキュリティ上の懸念は、RELOADベース仕様のように適用されます。また、限りオーバーレイにおける悪意あるピアの量が適度なままで、統計的なメカニズムは、セクション6.5で適用（すなわち、75パーセンタイルの使用）ピアが助ける取得共有推定値を処理するためには、確実にそれとは明らかに異なる推定（すなわち、より大きいまたはより小さい）の他の受信された推定値は有意に安定化間隔およびルーティングテーブルサイズを適合させるプロセスに影響を与えないであろう。しかし、攻撃者が戦略的な場所でオーバーレイ内の他のピアの高い数を偽装することができる場合、被害者に誤った推定値の高い十分な数を送信することができ、したがって、被害者の選択に影響を与える可能性があることに留意すべきです安定化間隔。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Message Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. メッセージ拡張機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document introduces one additional extension to the &#34;RELOAD Extensions Registry&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、「RELOAD拡張レジストリ」への1つの追加の拡張が導入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  +------------------+-------+---------------+
                  | Extension Name   |  Code | Specification |
                  +------------------+-------+---------------+
                  | self_tuning_data |   0x3 |      RFC 7363 |
                  +------------------+-------+---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the extension are defined in Section 6.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張の内容はセクション6.5で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. New Overlay Algorithm Type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 新しいオーバーレイアルゴリズムのタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document introduces one additional overlay algorithm type to the &#34;RELOAD Overlay Algorithm Types&#34; registry:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、「RELOADオーバーレイアルゴリズムタイプ」レジストリに一つの追加オーバーレイアルゴリズムの種類を紹介します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  +-------------------+-----------+
                  | Algorithm Name    | Reference |
                  +-------------------+-----------+
                  | CHORD-SELF-TUNING | RFC 7363  |
                  +-------------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. A New IETF XML Registry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. 新しいIETF XMLレジストリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document registers one new URI for the self-tuning namespace in the &#34;ns&#34; subregistry of the IETF XML registry defined in [RFC3688].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、[RFC3688]で定義されたIETF XMLレジストリの「NS」副登録でセルフチューニングの名前空間のために1新しいURIを登録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI: urn:ietf:params:xml:ns:p2p:self-tuning
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI：URN：IETF：のparams：XML：NS：P2P：セルフチューニング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registrant Contact: The IESG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録者連絡先：IESG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML: N/A, the requested URI is an XML namespace
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML：N / Aは、要求されたURIは、XML名前空間です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Jani Hautakorpi for his contributions to the document. The authors would also like to thank Carlos Bernardos, Martin Durst, Alissa Cooper, Tobias Gondrom, and Barry Leiba for their comments on the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作者は、ドキュメントへの貢献のためのヤニHautakorpiに感謝したいと思います。著者はまた、ドキュメントの彼らのコメントのためにカルロスBernardos、マーティン・ダースト、アリッサ・クーパー、トビアスGondrom、そしてバリー・レイバに感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245] Rosenberg, J., &#34;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols&#34;, RFC 5245, April 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245]ローゼンバーグ、J.、 &#34;インタラクティブ接続確立（ICE）：オファー/回答プロトコルのためのネットワークアドレス変換（NAT）トラバーサルのための議定書&#34;、RFC 5245、2010年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &#34;Session Traversal Utilities for NAT (STUN)&#34;, RFC 5389, October 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389]ローゼンバーグ、J.、マーイ、R.、マシューズ、P.、およびD.翼、 &#34;NAT（STUN）のセッショントラバーサルユーティリティ&#34;、RFC 5389、2008年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6940] Jennings, C., Lowekamp, B., Rescorla, E., Baset, S., and H. Schulzrinne, &#34;REsource LOcation And Discovery (RELOAD) Base Protocol&#34;, RFC 6940, January 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6940]ジェニングス、C.、Lowekamp、B.、レスコラ、E.、BASET、S.、およびH. Schulzrinneと、 &#34;リソースロケーションと発見（リロード）ベースプロトコル&#34;、RFC 6940、2014年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Binzenhofer2006] Binzenhofer, A., Kunzmann, G., and R. Henjes, &#34;A Scalable Algorithm to Monitor Chord-Based P2P Systems at Runtime&#34;, In Proceedings of the 20th IEEE International Parallel and Distributed Processing Symposium (IPDPS), pp. 1-8, April 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Binzenhofer2006] Binzenhofer、A.、Kunzmann、G.、およびR. Henjes、第20回IEEE国際並列分散処理シンポジウム（IPDPS）の議事録、PPにおいて、「スケーラブルアルゴリズムは、実行時にコードベースのP2Pシステムを監視します」 。1-8、2006年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CAN] Ratnasamy, S., Francis, P., Handley, M., Karp, R., and S. Schenker, &#34;A Scalable Content-Addressable Network&#34;, In Proceedings of the 2001 Conference on Applications, Technologies, Architectures and Protocols for Computer Communications, pp. 161-172, August 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CAN] Ratnasamy、S.、フランシス、P.、ハンドレー、M.、カープ、R.、およびS.シェンカー、 &#34;スケーラブルな内容アドレスネットワーク&#34; 2001年会議の議事録において応用上、技術、アーキテクチャおよびコンピュータ通信、頁161-172、2001年8月のためのプロトコル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Chord] Stoica, I., Morris, R., Liben-Nowell, D., Karger, D., Kaashoek, M., Dabek, F., and H. Balakrishnan, &#34;Chord: A Scalable Peer-to-peer Lookup Service for Internet Applications&#34;, IEEE/ACM Transactions on Networking, Volume 11, Issue 1, pp. 17-32, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[コード] Stoicaの、I.、モリス、R.、リベニ-Nowell、D.、カーガー、D.、Kaashoek、M.、Dabek、F.、及びH.バラクリシュナン、「コード：スケーラブルなピアツーピアインターネットアプリケーションのためのルックアップサービス」、ネットワーク上のIEEE / ACM取引、11巻、1号、頁17-32、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ghinita2006] Ghinita, G. and Y. Teo, &#34;An Adaptive Stabilization Framework for Distributed Hash Tables&#34;, In Proceedings of the 20th IEEE International Parallel and Distributed Processing Symposium (IPDPS), pp. 29-38, April 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ghinita2006] Ghinita、G.およびY.テオ、「分散ハッシュテーブルのための適応安定化フレームワーク」、第20回IEEE国際パラレルの議事録と分散処理シンポジウム（IPDPS）、頁29-38、2006年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Horowitz2003] Horowitz, K. and D. Malkhi, &#34;Estimating Network Size from Local Information&#34;, Information Processing Letters, Volume 88, Issue 5, pp. 237-243, December 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Horowitz2003]ホロヴィッツ、K.、およびD. Malkhi、 &#34;地域情報から推定ネットワークサイズ&#34;、情報処理レター、88巻、5号、頁237-243、2003年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Kostoulas2005] Kostoulas, D., Psaltoulis, D., Gupta, I., Birman, K., and A. Demers, &#34;Decentralized Schemes for Size Estimation in Large and Dynamic Groups&#34;, In Proceedings of the 4th IEEE International Symposium on Network Computing and Applications, pp. 41-48, July 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4回IEEE国際シンポジウムの議事録[Kostoulas2005] Kostoulas、D.、Psaltoulis、D.、グプタ、I.、バーマン、K.、およびA.デマーズ、「大規模かつダイナミックグループでのサイズ推定のための分散方式」、ネットワークコンピューティングとアプリケーション、頁41-48、2005年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Krishnamurthy2008] Krishnamurthy, S., El-Ansary, S., Aurell, E., and S. Haridi, &#34;Comparing Maintenance Strategies for Overlays&#34;, In Proceedings of the 16th Euromicro Conference on Parallel, Distributed and Network-Based Processing, pp. 473-482, February 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
平行な第16 Euromicro会議の議事録において【Krishnamurthy2008] Krishnamurthy、S.、エルAnsary、S.、Aurell、E.、およびS. Haridi、「オーバーレイの保守戦略の比較」、分散およびネットワークベースの処理、頁473から482まで、2008年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Li2004] Li, J., Strinbling, J., Gil, T., Morris, R., and M. Kaashoek, &#34;Comparing the Performance of Distributed Hash Tables Under Churn&#34;, Peer-to-Peer Systems III, Volume 3279 of Lecture Notes in Computer Science, Springer, pp. 87-99, February 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Li2004】リチウム、J.、Strinbling、J.、ギル、T.、モリス、R.、およびM. Kaashoek、「チャーン下で分散ハッシュテーブルの性能を比較」、ピアツーピアシステムIII巻3279コンピュータサイエンス、スプリンガー、頁87-99、2005年2月に講義ノートの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Liben-Nowell2002] Liben-Nowell, D., Balakrishnan, H., and D. Karger, &#34;Observations on the Dynamic Evolution of Peer-to-Peer Networks&#34;, In Proceedings of the 1st International Workshop on Peer-to-Peer Systems (IPTPS), pp. 22-33, March 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[リベニ-Nowell2002]リベニ-Nowell、D.、バラクリシュナン、H.、およびD.カーガー、ピア・ツー・ピアの第1回国際ワークショップの議事録では、「ピアツーピアネットワークの動的進化に関する考察」システムズ（IPTPS）、頁22-33、2002年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Maenpaa2009] Maenpaa, J. and G. Camarillo, &#34;A Study on Maintenance Operations in a Chord-Based Peer-to-Peer Session Initiation Protocol Overlay Network&#34;, In Proceedings of the 23rd IEEE International Parallel and Distributed Processing Symposium (IPDPS), pp. 1-9, May 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Maenpaa2009] Maenpaa、J.及びG.カマリロ、第23回IEEE国際並列分散処理シンポジウム（IPDPS）の議事録では、「コードベースのピア・ツー・ピアセッション開始プロトコルオーバーレイネットワークにおけるメンテナンス操作に関する研究」 、頁1-9、2009年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Mahajan2003] Mahajan, R., Castro, M., and A. Rowstron, &#34;Controlling the Cost of Reliability in Peer-to-Peer Overlays&#34;, In Proceedings of the 2nd International Workshop on Peer-to-Peer Systems (IPTPS), pp. 21-32, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Mahajan2003]マハジャン、R.、カストロ、M.、およびA. Rowstron、「ピア・ツー・ピアオーバーレイにおける信頼性のコストを制御」、ピアツーピアシステムに関する第2回国際ワークショップの議事録（IPTPS）において、頁21-32、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pastry] Rowstron, A. and P. Druschel, &#34;Pastry: Scalable, Decentralized Object Location and Routing for Large-Scale Peer-to-Peer Systems&#34;, In Proceedings of the IFIP/ACM International Conference on Distributed Systems Platforms, pp. 329-350, November 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分散システムプラットフォーム、頁上のIFIP / ACM国際会議の議事録には、[ペストリー] Rowstron、A.、およびP. Druschel、「大規模ピアツーピアシステムのためのスケーラブルな分散オブジェクトの場所とルーティング菓子」。 329から350まで、2001年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3688] Mealling, M., &#34;The IETF XML Registry&#34;, BCP 81, RFC 3688, January 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3688] Mealling、M.、 &#34;IETF XMLレジストリ&#34;、BCP 81、RFC 3688、2004年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Rhea2004] Rhea, S., Geels, D., Roscoe, T., and J. Kubiatowicz, &#34;Handling Churn in a DHT&#34;, In Proceedings of the USENIX Annual Technical Conference, pp. 127-140, June 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;DHTでチャーンを処理する&#34; [Rhea2004]レア、S.、Geels、D.、ロスコー、T.、およびJ. Kubiatowicz、USENIX年次技術会議議事録、頁127-140、2004年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Weiss1998] Weiss, M., &#34;Data Structures and Algorithm Analysis in C++&#34;, Addison-Wesley Longman Publishing Co., Inc., 2nd Edition, ISBN 0201361221, 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、アディソン・ウェスリー・ロングマン出版社、第2版、ISBN 0201361221、1998年 &#34;C ++におけるデータ構造とアルゴリズム解析&#34; [Weiss1998]ワイス、M.、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jouni Maenpaa Ericsson Hirsalantie 11 Jorvas 02420 Finland
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JouniMäenpääエリクソンHirsalantie 11 02420 Jorvasフィンランド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: Jouni.Maenpaa@ericsson.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：Jouni.Maenpaa@ericsson.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Gonzalo Camarillo Ericsson Hirsalantie 11 Jorvas 02420 Finland
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゴンサロ・カマリロエリクソンHirsalantie 11 Jorvas 02420フィンランド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: Gonzalo.Camarillo@ericsson.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：Gonzalo.Camarillo@ericsson.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
