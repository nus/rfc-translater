<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 3539 - Authentication, Authorization and Accounting (AAA) Transport Profile 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 3539 - Authentication, Authorization and Accounting (AAA) Transport Profile 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc3539">
              https://tools.ietf.org/html/rfc3539
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 3539 - 認証、認可およびアカウンティング（AAA）のトランスポート・プロファイル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                           B. Aboba
Request for Comments: 3539                                     Microsoft
Category: Standards Track                                        J. Wood
                                                  Sun Microsystems, Inc.
                                                               June 2003
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authentication, Authorization and Accounting (AAA) Transport Profile
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証、認可およびアカウンティング（AAA）のトランスポート・プロファイル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document discusses transport issues that arise within protocols for Authentication, Authorization and Accounting (AAA). It also provides recommendations on the use of transport by AAA protocols. This includes usage of standards-track RFCs as well as experimental proposals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、認証、認可及びアカウンティング（AAA）のためのプロトコル内で発生輸送の問題を論じています。また、AAAプロトコルによる輸送の使用に関する推奨事項を提供します。これは、標準化過程のRFCの利用だけでなく、実験的な提案を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2
       1.1.  Requirements Language. . . . . . . . . . . . . . . . . .  2
       1.2.  Terminology. . . . . . . . . . . . . . . . . . . . . . .  2
   2.  Issues in Transport Usage. . . . . . . . . . . . . . . . . . .  5
       2.1.  Application-driven Versus Network-driven . . . . . . . .  5
       2.2.  Slow Failover. . . . . . . . . . . . . . . . . . . . . .  6
       2.3.  Use of Nagle Algorithm . . . . . . . . . . . . . . . . .  7
       2.4.  Multiple Connections . . . . . . . . . . . . . . . . . .  7
       2.5.  Duplicate Detection. . . . . . . . . . . . . . . . . . .  8
       2.6.  Invalidation of Transport Parameter Estimates. . . . . .  8
       2.7.  Inability to use Fast Re-Transmit. . . . . . . . . . . .  9
       2.8.  Congestion Avoidance . . . . . . . . . . . . . . . . . .  9
       2.9.  Delayed Acknowledgments. . . . . . . . . . . . . . . . . 11
       2.10. Premature Failover . . . . . . . . . . . . . . . . . . . 11
       2.11. Head of Line Blocking. . . . . . . . . . . . . . . . . . 11
       2.12. Connection Load Balancing. . . . . . . . . . . . . . . . 12
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   3.  AAA Transport Profile. . . . . . . . . . . . . . . . . . . . . 12
       3.1.  Transport Mappings . . . . . . . . . . . . . . . . . . . 12
       3.2.  Use of Nagle Algorithm . . . . . . . . . . . . . . . . . 12
       3.3.  Multiple Connections . . . . . . . . . . . . . . . . . . 13
       3.4.  Application Layer Watchdog . . . . . . . . . . . . . . . 13
       3.5.  Duplicate Detection. . . . . . . . . . . . . . . . . . . 19
       3.6.  Invalidation of Transport Parameter Estimates. . . . . . 20
       3.7.  Inability to use Fast Re-Transmit. . . . . . . . . . . . 21
       3.8.  Head of Line Blocking. . . . . . . . . . . . . . . . . . 22
       3.9.  Congestion Avoidance . . . . . . . . . . . . . . . . . . 23
       3.10. Premature Failover . . . . . . . . . . . . . . . . . . . 24
   4.  Security Considerations. . . . . . . . . . . . . . . . . . . . 24
   5.  IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 25
   6.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 25
       6.1.  Normative References . . . . . . . . . . . . . . . . . . 25
       6.2.  Informative References . . . . . . . . . . . . . . . . . 26
   Appendix A - Detailed Watchdog Algorithm Description . . . . . . . 28
   Appendix B - AAA Agents. . . . . . . . . . . . . . . . . . . . . . 33
       B.1.  Relays and Proxies . . . . . . . . . . . . . . . . . . . 33
       B.2.  Re-directs . . . . . . . . . . . . . . . . . . . . . . . 35
       B.3.  Store and Forward Proxies. . . . . . . . . . . . . . . . 36
       B.4.  Transport Layer Proxies. . . . . . . . . . . . . . . . . 38
   Intellectual Property Statement. . . . . . . . . . . . . . . . . . 39
   Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . 39
   Author Addresses . . . . . . . . . . . . . . . . . . . . . . . . . 40
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 41
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document discusses transport issues that arise within protocols for Authentication, Authorization and Accounting (AAA). It also provides recommendations on the use of transport by AAA protocols. This includes usage of standards-track RFCs as well as experimental proposals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、認証、認可及びアカウンティング（AAA）のためのプロトコル内で発生輸送の問題を論じています。また、AAAプロトコルによる輸送の使用に関する推奨事項を提供します。これは、標準化過程のRFCの利用だけでなく、実験的な提案を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this document, the key words &#34;MAY&#34;, &#34;MUST, &#34;MUST NOT&#34;, &#34;optional&#34;, &#34;recommended&#34;, &#34;SHOULD&#34;, and &#34;SHOULD NOT&#34;, are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書に記載されている、キーワード &#34;MAY&#34;、「MUST、 &#34;MUST NOT&#34;、 &#34;オプション&#34;、 &#34;推奨&#34;、 &#34;SHOULD&#34;、および &#34;the&#34; はならない、[RFC2119]に記載されているように解釈されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Accounting The act of collecting information on resource usage for the purpose of trend analysis, auditing, billing, or cost allocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トレンド分析、監査、請求、または費用配分の目的のために、リソースの使用状況に関する情報を収集する行為を占めています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Administrative Domain An internet, or a collection of networks, computers, and databases under a common administration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターネット、または一般的な管理下にあるネットワーク、コンピュータ、およびデータベースの収集管理ドメイン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Agent A AAA agent is an intermediary that communicates with AAA clients and servers. Several types of AAA agents exist, including Relays, Re-directs, and Proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エージェントA AAAエージェントは、AAAクライアントとサーバとの通信の仲介です。 AAA剤のいくつかのタイプは、リレー、再指示、およびプロキシを含め、存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Application-driven transport Transport behavior is said to be &#34;application-driven&#34; when the rate at which messages are sent is limited by the rate at which the application generates data, rather than by the size of the congestion window. In the most extreme case, the time between transactions exceeds the round-trip time between sender and receiver, implying that the application operates with an effective congestion window of one. AAA transport is typically application driven.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション駆動型輸送トランスポートの動作は、「アプリケーション・ドリブン」メッセージが送信されるレートは、アプリケーションがデータを生成する速度によってではなく、輻輳ウィンドウのサイズによって制限されると言われています。最も極端な場合には、トランザクション間の時間は、アプリケーションが一方の有効な混雑ウィンドウで動作することを意味し、送信者と受信者との間の往復時間を超え。 AAAの輸送は、一般的に駆動型アプリケーションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Attribute Value Pair (AVP) The variable length concatenation of a unique Attribute (represented by an integer) and a Value containing the actual value identified by the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
値ペア（AVP）（整数で表される）固有の属性および属性によって識別される実際の値を含む値の可変長連結属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authentication The act of verifying a claimed identity, in the form of a pre-existing label from a mutually known name space, as the originator of a message (message authentication) or as the end-point of a channel (entity authentication).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージ（メッセージ認証）の発信元として、またはチャネル（エンティティ認証）のエンドポイントとして、互いに既知の名前空間から既存のラベルの形で、要求されたアイデンティティを検証する行為を認証。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authorization The act of determining if a particular right, such as access to some resource, can be granted to the presenter of a particular credential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認可の場合、このようないくつかのリソースへのアクセスなど、特定の権利を、決定の行為は、特定の資格のプレゼンターに付与することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Billing The act of preparing an invoice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
請求書を準備する行為を課金。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Network Access Identifier The Network Access Identifier (NAI) is the userID submitted by the host during network access authentication. In roaming, the purpose of the NAI is to identify the user as well as to assist in the routing of the authentication request. The NAI may not necessarily be the same as the user&#39;s e-mail address or the user-ID submitted in an application layer authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークアクセス識別子[ネットワークアクセス識別子（NAI）はネットワークアクセス認証中にホストから提出されたユーザーIDです。ローミングでは、NAIの目的は、ユーザを識別するために、ならびに認証要求のルーティングを補助することです。 NAIは、必ずしもユーザーの電子メールアドレスまたはアプリケーション層認証に提出し、ユーザーIDと同じではないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Network Access Server (NAS) A Network Access Server (NAS) is a device that hosts connect to in order to get access to the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークアクセスサーバー（NAS）Aネットワークアクセスサーバ（NAS）は、ネットワークへのアクセスを得るためにに接続するホストデバイスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxy In addition to forwarding requests and responses, proxies enforce policies relating to resource usage and provisioning. This is typically accomplished by tracking the state of NAS devices. While proxies typically do not respond to client Requests prior to receiving a Response from the server, they may originate Reject messages in cases where policies are violated. As a result, proxies need to understand the semantics of the messages passing through them, and may not support all extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシは、転送要求と応答に加えて、プロキシは、使用してプロビジョニングを資源に関連するポリシーを適用します。これは、典型的には、NASデバイスの状態を追跡することによって達成されます。プロキシは通常、サーバからの応答を受信する前に、クライアントの要求に応答しませんが、彼らは、ポリシーに違反した場合にメッセージを拒否生じてもよいです。その結果、プロキシがそれらを通過するメッセージの意味を理解する必要があり、すべての拡張機能をサポートしていないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Local Proxy A Local Proxy is a proxy that exists within the same administrative domain as the network device (e.g. NAS) that issued the AAA request. Typically a local proxy is used to multiplex AAA messages to and from a large number of network devices, and may implement policy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ローカルプロキシAローカルプロキシは、AAA要求を発行したネットワーク装置（例えば、NAS）と同じ管理ドメイン内に存在するプロキシです。典型的には、ローカルプロキシは、ネットワーク機器の数が多いためとからAAAメッセージを多重化するために使用され、ポリシーを実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Store and forward proxy Store and forward proxies distinguish themselves from other proxy species by sending a reply to the NAS prior to proxying the request to the server. As a result, store and forward proxies need to implement AAA client and server functionality for the messages that they handle. Store and Forward proxies also typically keep state on conversations in progress in order to assure delivery of proxied Requests and Responses. While store and forward proxies are most frequently deployed for accounting, they also can be used to implement authentication/authorization policy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ストアアンドフォワードプロキシストアアンドフォワードプロキシはサーバへのリクエストをプロキシするNAS前に応答を送信することによって、他のプロキシ種から身を区別します。その結果、ストアアンドフォワードプロキシは、彼らが扱うメッセージのためにAAAクライアントとサーバーの機能を実装する必要があります。ストアアンドフォワードプロキシは、典型的には、プロキシ要求および応答の配信を保証するために進行中の会話の状態を保ちます。ストアアンドフォワードプロキシが最も頻繁に会計のために配備されているが、それらはまた、認証/認可ポリシーを実装するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Network-driven transport Transport behavior is said to be &#34;network driven&#34; when the rate at which messages are sent is limited by the congestion window, not by the rate at which the application can generate data. File transfer is an example of an application where transport is network driven.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワーク主導型輸送トランスポートの動作は、メッセージが送信される速度は、輻輳ウィンドウによってではなく、アプリケーションがデータを生成することができる速度によって制限されている場合、「ネットワークが駆動される」と言われています。ファイル転送は、トランスポートがネットワークを駆動するアプリケーションの一例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Re-direct Rather than forwarding Requests and Responses between clients and servers, Re-directs refer clients to servers and allow them to communicate directly. Since Re-directs do not sit in the forwarding path, they do not alter any AVPs transitting between client and server. Re-directs do not originate messages and are capable of handling any message type. A Re-direct may be configured only to re-direct messages of certain types, while acting as a Relay or Proxy for other types. As with Relays, re-directs do not keep state with respect to conversations or NAS resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再直接ではなく、クライアントとサーバ間の要求と応答を転送するよりも、サーバーへのクライアントを参照し、それらを直接通信できるように再指示します。再指示は、転送パスに座っていないので、彼らは、クライアントとサーバーの間でtransitting任意のAVPを変更しません。再指示したメッセージを発信し、任意のメッセージタイプを扱うことができるしません。他のタイプのリレーまたはプロキシとして動作しながら、再直接には、特定の種類のみに再直接メッセージを構成することができます。リレーと同様に、再指示会話やNASリソースに関する状態を保持しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Relay Relays forward requests and responses based on routing-related AVPs and domain forwarding table entries. Since relays do not enforce policies, they do not examine or alter non-routing AVPs. As a result, relays never originate messages, do not need to understand the semantics of messages or non-routing AVPs, and are capable of handling any extension or message type. Since relays make decisions based on information in routing AVPs and domain forwarding tables they do not keep state on NAS resource usage or conversations in progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルーティング関連のAVPとドメイン転送テーブルのエントリに基づいてリレーリレー前方要求と応答。リレーはポリシーを強制していないので、彼らは非ルーティングAVPを調べたり、変更されることはありません。その結果、メッセージを発信決してリレー、メッセージまたは非ルーティングのAVPの意味を理解する必要があり、任意の拡張子またはメッセージタイプを処理することができるしません。リレーは、ルーティングのAVPとドメイン転送テーブル内の情報に基づいて意思決定を行うので、彼らは、NASリソースの使用状況や進行中の会話に状態を保持しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Issues in AAA Transport Usage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
AAA輸送用法2.問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Issues that arise in AAA transport usage include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA輸送用法に発生する問題は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Application-driven versus network-driven Slow failover Use of Nagle Algorithm Multiple connections Duplicate detection Invalidation of transport parameter estimates Inability to use fast re-transmit Congestion avoidance Delayed acknowledgments Premature Failover Head of line blocking Connection load balancing
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション主導のNagleアルゴリズム複数の接続のネットワーク主導型スローフェイルオーバーの使用に対する接続の負荷分散を遮断未熟フェールオーバヘッドラインの高速再送信輻輳回避遅延確認応答を使用するように、トランスポートパラメータ推定値の無力の検出無効化を重複
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We discuss each of these issues in turn.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは、順番に、これらの問題のそれぞれを議論します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Application-driven versus Network-driven
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。アプリケーション主導型ネットワーク主導の対
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA transport behavior is typically application rather than network driven. This means that the rate at which messages are sent is typically limited by how quickly they are generated by the application, rather than by the size of the congestion window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA輸送挙動は、一般的に駆動型アプリケーションではなく、ネットワークです。これは、メッセージが送信される速度は、通常、それらがアプリケーションによってではなく、輻輳ウィンドウのサイズによって生成されたどのように迅速で制限されることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, let us assume a 48-port NAS with an average session time of 20 minutes. This device will, on average, send only 144 authentication/authorization requests/hour, and an equivalent number of accounting requests. This represents an average inter-packet spacing of 25 seconds, which is much larger than the Round Trip Time (RTT) in most networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、私たちは20分のセッションの平均時間で48ポートNASを想定してみましょう。このデバイスは、平均的に、唯一の144認証/認可要求/時間、およびアカウンティング要求の同等の番号を送信します。これは、ほとんどのネットワークでのラウンドトリップ時間（RTT）よりもはるかに大きい25秒、平均パケット間の間隔を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Even on much larger NAS devices, the inter-packet spacing is often larger than the RTT. For example, consider a 2048-port NAS with an average session time of 10 minutes. It will on average send 3.4 authentication/authorization requests/second, and an equivalent number of accounting requests. This translates to an average inter-packet spacing of 293 ms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でも、はるかに大きいNASデバイス上で、パケット間の間隔はRTTよりも大きいことが多いです。例えば、10分の平均セッション時間で2048ポートNASを検討します。これは、平均送信3.4認証/認可リクエスト/秒、およびアカウンティング要求の同等の数になります。これは、293ミリ秒の平均パケット間の間隔に変換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, even where transport behavior is largely application-driven, periods of network-driven behavior can occur. For example, after a NAS reboot, previously stored accounting records may be sent to the accounting server in rapid succession. Similarly, after recovery from a power failure, users may respond with a large number of simultaneous logins. In both cases, AAA messages may be generated more quickly than the network will allow them to be sent, and a queue will build up.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかしながら、輸送挙動は大部分のアプリケーション駆動の場合であっても、ネットワーク主導型の挙動の期間が発生する可能性があります。例えば、NASの再起動後、以前に格納された会計帳簿は矢継ぎ早にアカウンティングサーバに送信することができます。同様に、電源障害から回復した後、ユーザーが同時ログイン数の多い応答することができます。どちらの場合も、AAAメッセージは、ネットワークがそれらを送信することができるようになり、キューが構築されますよりも迅速に生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Network congestion can occur when transport behavior is network-driven or application-driven. For example, while a single NAS may not send substantial AAA traffic, many NASes may communicate with a single AAA proxy or server. As a result, routers close to a heavily loaded proxy or server may experience congestion, even though traffic from each individual NAS is light. Such &#34;convergent congestion&#34; can result in dropped packets in routers near the AAA server, or even within the AAA server itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輸送の挙動は、ネットワーク主導型またはアプリケーション駆動されると、ネットワークの輻輳が発生する可能性があります。単一のNASは、実質的なAAAトラフィックを送信しないかもしれないが、例えば、多くのNASは、単一のAAAプロキシまたはサーバと通信してもよいです。その結果、高負荷プロキシまたはサーバーに近いルータは、個々のNASからのトラフィックが光であっても、輻輳が発生することがあります。このような「収束渋滞」AAAサーバの近くに、あるいはAAAサーバ自体の内部ルータで破棄されたパケットをもたらす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let us consider what happens when 10,000 48-ports NASes, each with an average session time of 20 minutes, are configured with the same AAA agent or server. The unfortunate proxy or server would receive 400 authentication/authorization requests/second and an equivalent number of accounting requests. For 1000 octet requests, this would generate 6.4 Mbps of incoming traffic at the AAA agent or server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは20分の平均セッション時間10,000 48ポートのNAS、それぞれが、同じAAAのエージェントまたはサーバーで構成されているときに何が起こるかを考えてみましょう。不幸なプロキシまたはサーバが400、認証/認可要求/秒およびアカウンティング要求の同等の数を受け取ることになります。 1000のオクテット要求の場合、これはAAAのエージェントまたはサーバーでの着信トラフィックの6.4 Mbpsのを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While this transaction load is within the capabilities of the fastest AAA agents and servers, implementations exist that cannot handle such a high load. Thus high queuing delays and/or dropped packets may be experienced at the agent or server, even if routers on the path are not congested. Thus, a well designed AAA protocol needs to be able to handle congestion occurring at the AAA server, as well as congestion experienced within the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このトランザクションの負荷が最速AAAエージェントとサーバの能力の範囲内ですが、実装はそのような高い負荷を処理することはできませんが存在します。このように高いキューイング遅延および/またはドロップされたパケットは、パス上のルータが混雑していない場合であっても、エージェントまたはサーバーで経験することができます。したがって、適切に設計AAAプロトコルは、AAAサーバで発生する輻輳を処理することができる必要があるだけでなく、輻輳がネットワーク内で経験しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Slow Failover
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2。スローフェイルオーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where TCP [RFC793] is used as the transport, AAA implementations will experience very slow fail over times if they wait until a TCP connection times out before resending on another connection. This is not an issue for SCTP [RFC2960], which supports endpoint and path failure detection. As described in section 8 of [RFC2960], when the number of retransmissions exceeds the maximum (&#34;Association.Max.Retrans&#34;), the peer endpoint is considered unreachable, the association enters the CLOSED state, and the failure is reported to the application. This enables more rapid failure detection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP [RFC793]トランスポートとして使用する場合には、AAAの実装は非常に遅く発生します、彼らは別の接続に再送信する前に、TCP接続までの時間を待っていれば回以上失敗します。これは、エンドポイントとパス障害検出をサポートしていSCTP [RFC2960]のための問題ではありません。 [RFC2960]のセクション8で説明したように再送回数が最大（「Association.Max.Retrans」）を超えたとき、ピアエンドポイントが到達不能であると考えられる、関連付けは、CLOSED状態に入り、そして障害がアプリケーションに通知されます。これは、より迅速な障害検出を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Use of Nagle Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3。 Nagleアルゴリズムの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA protocol messages are often smaller than the maximum segment size (MSS). While exceptions occur when certificate-based authentication messages are issued or where a low path MTU is found, typically AAA protocol messages are less than 1000 octets. Therefore, when using TCP [RFC793], the total packet count and associated network overhead can be reduced by combining multiple AAA messages within a single packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAプロトコルメッセージは、最大セグメントサイズ（MSS）よりもしばしば小さいです。証明書ベースの認証メッセージが発行されたときに例外が発生したり、低いパスMTUが発見された場合、通常、AAAプロトコルメッセージは1000未満のオクテットです。一方でTCP [RFC793]を使用する場合したがって、総パケット数と関連するネットワークオーバーヘッドは、単一のパケット内の複数のAAAメッセージを組み合わせることにより低減することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where AAA runs over TCP and transport behavior is network-driven, such as after a reboot when many users login simultaneously, or many stored accounting records need to be sent, the Nagle algorithm will result in &#34;transport layer batching&#34; of AAA messages. While this does not reduce the work required by the application in parsing packets and responding to the messages, it does reduce the number of packets processed by routers along the path. The Nagle algorithm is not used with SCTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAは、TCP上で実行され、多くのユーザーが同時にログインする、または多くの保存された会計記録を送信する必要がある場合、トランスポートの動作は、再起動後のように、ネットワーク主導型、などである場合は、Nagleアルゴリズムは、AAAメッセージの「トランスポート層のバッチ処理」になります。これは、パケットを解析し、メッセージへの応答におけるアプリケーションで必要な作業を削減しませんが、それはパスに沿ったルータによって処理されたパケットの数を減らすん。 Nagleアルゴリズムは、SCTPで使用されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where AAA transport is application-driven, the NAS will typically receive a reply from the home server prior to having another request to send. This implies, for example, that accounting requests will typically be sent individually rather than being batched by the transport layer. As a result, within the application-driven regime, the Nagle algorithm [RFC896] is ineffective.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA輸送がアプリケーション主導型である場合、NASは、一般的に前に送信するための別の要求を有す​​ることにホームサーバーからの応答を受信します。これはアカウンティング要求は、通常、トランスポート層によってバッチ処理されるのではなく、個別に送信されることを、例えば、暗示します。結果として、アプリケーション駆動型レジーム内、Nagleアルゴリズムは、[RFC896]無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. Multiple Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4。複数の接続
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the RADIUS [RFC2865] Identifier field is a single octet, a maximum of 256 requests can be in progress between two endpoints described by a 5-tuple: (Client IP address, Client port, UDP, Server IP address, Server port). In order to get around this limitation, RADIUS clients have utilized more than one sending port, sometimes even going to the extreme of using a different UDP source port for each NAS port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（クライアントIPアドレス、クライアントポート、UDP、サーバのIPアドレス、サーバーポート）：RADIUS [RFC2865]識別子フィールドは、単一のオクテットであることから、256の要求の最大値は5タプルによって説明した2つのエンドポイント間で進行中であることができます。この制限を回避するためには、RADIUSクライアントは、時には、各NASポートごとに異なるUDPソースポートを使用しての極端に行く、複数の送信ポートを利用してきました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Were this behavior to be extended to AAA protocols operating over reliable transport, the result would be multiplication of the effective slow-start ramp-up by the number of connections. For example, if a AAA client had ten connections open to a AAA agent, and used a per-connection initial window [RFC3390] of 2, then the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この動作は、信頼性の高いトランスポート上で動作するAAAプロトコルに拡張することがあったが、結果は接続数による効果的なスロースタートランプアップの乗算になります。たとえば、AAAクライアントは、その後、AAAエージェントへのオープン10個の接続を持っていた、と2の接続ごとの初期ウィンドウ[RFC3390]を使用した場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
effective initial window would be 20. This is inappropriate, since it would permit the AAA client to send a large burst of packets into the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
効果的な初期ウィンドウは、それがネットワークにパケットの大バーストを送信するためにAAAクライアントを可能にするので、これは、不適切である20になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. Duplicate Detection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5。重複検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where a AAA client maintains connections to multiple AAA agents or servers, and where failover/failback or connection load balancing is supported, it is possible for multiple agents or servers to receive duplicate copies of the same transaction. A transaction may be sent on another connection before expiration of the &#34;time wait&#34; interval necessary to guarantee that all packets sent on the original connection have left the network. Therefore it is conceivable that transactions sent on the alternate connection will arrive before those sent on the failed connection. As a result, AAA agents and servers MUST be prepared to handle duplicates, and MUST assume that duplicates can arrive on any connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どこAAAクライアントが複数のAAAエージェントまたはサーバーへの接続を維持し、フェイルオーバー/フェイルバックまたは接続ロード・バランシングがサポートされている複数のエージェントやサーバが同じトランザクションの重複コピーを受信することが可能です。トランザクションは、元の接続で送信されたすべてのパケットがネットワークを残していることを保証するために必要な「時間待ち」期間の満了前に別の接続で送信することができます。したがって、代替接続上で送信されたトランザクションが失敗した接続上で送信され、それらの前に到着することが考えられます。結果として、AAAエージェントとサーバは重複を処理するために準備する必要があり、そして重複が任意の接続で到着できると仮定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, in billing, it is necessary to be able to weed out duplicate accounting records, based on the accounting session-id, event-timestamp and NAS identification information. Where authentication requests are always idempotent, the resultant duplicate responses from multiple servers will presumably be identical, so that little harm will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、課金では、課金セッションID、イベントタイムスタンプとNAS識別情報に基づいて、重複したアカウンティングレコードを取り除くことができることが必要です。認証要求は常に冪等である場合、ほとんど害が発生するように、複数のサーバからの結果の重複した回答は、おそらく、同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, there are situations where the response to an authentication request will depend on a previously established state, such as when simultaneous usage restrictions are being enforced. In such cases, authentication requests will not be idempotent. For example, while an initial request might elicit an Accept response, a duplicate request might elicit a Reject response from another server, if the user were already presumed to be logged in, and only one simultaneous session were permitted. In these situations, the AAA client might receive both Accept and Reject responses to the same duplicate request, and the outcome will depend on which response arrives first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、そのような同時使用制限が適用されているときのように、認証要求に対する応答は、以前に確立された状態に依存します状況が、あります。このような場合には、認証要求は冪等されることはありません。最初の要求が受け入れ応答を惹起する可能性がある一方で、ユーザーがすでにログインしていると推定された、そして唯一の同時セッションが許可された場合、例えば、重複したリクエストは、別のサーバからの拒否応答を誘発することがあります。このような状況では、AAAクライアントが両方受信受け入れ、同じ複製要求に対する応答を拒否し、結果は最初に到着する応答に依存しますがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6. Invalidation of Transport Parameter Estimates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6。交通パラメータ推定値の無効化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Congestion control principles [Congest],[RFC2914] require the ability of a transport protocol to respond effectively to congestion, as sensed via increasing delays, packet loss, or explicit congestion notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳制御の原理[輻輳]、[RFC2914]増加の遅延、パケット損失、または明示的輻輳通知を介して感知され、渋滞に効果的に対応するトランスポートプロトコルの能力を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With network-driven applications, it is possible to respond to congestion on a timescale comparable to the round-trip time (RTT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワーク主導型のアプリケーションでは、ラウンドトリップ時間（RTT）に匹敵するタイムスケール上の混雑に対応することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, with AAA protocols, the time between sends may be longer than the RTT, so that the network conditions can not be assumed to persist between sends. For example, the congestion window may grow during a period in which congestion is being experienced because few packets are sent, limiting the opportunity for feedback. Similarly, after congestion is detected, the congestion window may remain small, even though the network conditions that existed at the time of congestion no longer apply by the time when the next packets are sent. In addition, due to the low sampling interval, estimates of RTT and RTO made via the procedure described in [RFC2988] may become invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワーク状態が送信する間持続すると仮定することができないように、しかし、AAAプロトコルを用いて、送信間の時間は、長いRTTよりもできます。例えば、輻輳ウィンドウは、いくつかのパケットが送信されるため、輻輳がフィードバックの機会を制限し、経験されている期間中に成長することがあります。輻輳が検出された後、同様に、輻輳ウィンドウはもはや輻輳時に存在していないネットワーク条件は、次のパケットが送信される時間によって適用にもかかわらず、小さいままであり得ます。加えて、低いサンプリング間隔に、RTTとRTOの推定値が無効になることがあり、[RFC2988]に記載の手順を介して行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.7. Inability to Use Fast Re-transmit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.7。高速再送信を使用することができません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When congestion window validation [RFC2861] is implemented, the result is that AAA protocols operate much of the time in slow-start with an initial congestion window set to 1 or 2, depending on the implementation [RFC3390]. This implies that AAA protocols gain little benefit from the windowing features of reliable transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳ウィンドウの検証[RFC2861]が実装されている場合、結果は、AAAプロトコルが実装[RFC3390]に応じて、1または2に設定された初期混雑ウィンドウと遅い開始時間の多くを操作することです。これは、AAAプロトコルは、信頼性の高い輸送のウィンドウ機能からほとんど利益を得ることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the congestion window is so small, it is generally not possible to receive enough duplicate ACKs (3) to trigger fast re-transmit. In addition, since AAA traffic is two-way, ACKs including data will not count as part of the duplicate ACKs necessary to trigger fast re-transmit. As a result, dropped packets will require a retransmission timeout (RTO).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳ウィンドウは非常に小さいので、十分に重複ACK（3）高速再送信をトリガするために受信するために、一般的には不可能です。また、AAAトラフィックが双方向であることから、ACKを含むデータは、高速再送信をトリガするために必要な重複ACKの一部としてカウントされません。その結果、再送タイムアウト（RTO）が必要となり、パケットを落としました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8. Congestion Avoidance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8。輻輳回避
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The law of conservation of packets [Congest] suggests that a client should not send another packet into the network until it can be reasonably sure that a packet has exited the network on the same path. In the case of a AAA client, the law suggests that it should not retransmit to the same server or choose another server until it can be reasonably sure that a packet has exited the network on the same path. If the client advances the window as responses arrive, then the client will &#34;self clock&#34;, adjusting its transmission rate to the available bandwidth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットの保存則[混雑は]パケットが同じパス上のネットワークを終了したことを合理的に確認することができますまで、クライアントがネットワークに別のパケットを送るべきではないことを示唆しています。 AAAクライアントの場合は、法律がパケットが同じパスにネットワークを終了したことを合理的に確認することができますまで、それは同じサーバに再送信するか、別のサーバーを選択するべきではないことを示唆しています。応答が到着すると、クライアントはウィンドウを進めた場合、クライアントは、「自己の時計は」、利用可能な帯域幅への伝送速度を調整します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While a AAA client using a reliable transport such as TCP [RFC793] or SCTP [RFC2960] will self-clock when communicating directly with a AAA-server, end-to-end self-clocking is not assured when AAA agents are present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAサーバと直接通信する際にAAAエージェントが存在する場合、このようなTCP [RFC793]又はSCTP [RFC2960]などの信頼性の高いトランスポートを使用して、AAAクライアントは、エンドツーエンドの自己クロッキングは、自己クロック保証されないだろうが。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described in the Appendix, AAA agents include Relays, Proxies, Re-directs, Store and Forward proxies, and Transport proxies. Of these agents, only Transport proxies and Re-directs provide a direct transport connection between the AAA client and server, allowing end-to-end self-clocking to occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録で説明したように、AAAのエージェントは、リレー、プロキシ、再指示し、ストアアンドフォワードプロキシ、およびTransportプロキシが含まれています。これらの薬剤の、唯一の交通プロキシと再指示は、エンドツーエンドの自己クロッキングが発生することができ、AAAクライアントとサーバの間の直接のトランスポート接続を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With Relays, Proxies or Store and Forward proxies, two separate and de-coupled transport connections are used. One connection operates between the AAA client and agent, and another between the agent and server. Since the two transport connections are de-coupled, transport layer ACKs do not flow end-to-end, and self-clocking does not occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リレー、プロキシまたはストアアンドフォワードプロキシでは、二つの別々のデ結合された交通機関の接続が使用されています。一方の接続は、エージェントとサーバ間のAAAクライアントとエージェント、および他の間を運行しています。二つの伝送接続は切り離されているため、トランスポート層ACKは、エンドツーエンドの流れず、自己クロッキングは発生しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, consider what happens when the bottleneck exists between a AAA Relay and a AAA server. Self-clocking will occur between the AAA client and AAA Relay, causing the AAA client to adjust its sending rate to the rate at which transport ACKs flow back from the AAA Relay. However, since this rate is higher than the bottleneck bandwidth, the overall system will not self-clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、ボトルネックがAAAリレーとAAAサーバの間に存在するときに何が起こるかを検討してください。自己クロッキングは、AAAクライアントは、トランスポートACKがAAAリレーから逆流する速度に、その送信レートを調整させる、AAAクライアントとAAAリレーとの間に発生します。このレートは、ボトルネック帯域よりも高くなっているので、全体的なシステムは、自己クロックではないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since there is no direct transport connection between the AAA client and AAA server, the AAA client does not have the ability to estimate end-to-end transport parameters and adjust its sending rate to the bottleneck bandwidth between the Relay and server. As a result, the incoming rate at the AAA Relay can be higher than the rate at which packets can be sent to the AAA server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAクライアントとAAAサーバの間に直接のトランスポート接続が存在しないため、AAAクライアントは、エンドツーエンドのトランスポートパラメータを推定し、リレーとサーバ間のボトルネック帯域への送信レートを調整する能力を持っていません。結果として、AAAリレーにおける受信レートは、パケットがAAAサーバに送信することができる速度よりも高くすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this case, the end-to-end performance will be determined by details of the agent implementation. In general, the end-to-end transport performance in the presence of Relays, Proxies or Store and Forward proxies will always be worse in terms of delay and packet loss than if the AAA client and server were communicating directly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この場合には、エンドツーエンドのパフォーマンスは、エージェントの実装の詳細によって決定されるであろう。 AAAクライアントとサーバが直接通信しているかよりも、一般的には、リレー、プロキシまたはストアアンドフォワードプロキシの存在下でのエンド・ツー・エンドの輸送能力は常に遅延やパケットロスの面で悪くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if the agent operates with a large receive buffer, it is possible that a large queue will develop on the receiving side, since the AAA client is able to send packets to the AAA agent more rapidly than the agent can send them to the AAA server. Eventually, the buffer will overflow, causing wholesale packet loss as well as high delay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エージェントは、大きな受信バッファで動作した場合、AAAクライアントエージェントがそれらを送信することができますよりも急速にAAAエージェントにパケットを送信することが可能であるため、大規模なキューは、受信側で開発することは可能ですAAAサーバ。最終的に、バッファは卸売パケット損失ならびに高い遅延を引き起こし、オーバーフローします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Methods to induce fine-grained coupling between the two transport connections are difficult to implement. One possible solution is for the AAA agent to operate with a receive buffer that is no larger than its send buffer. If this is done, &#34;back pressure&#34; (closing of the receive window) will cause the agent to reduce the AAA client sending rate when the agent send buffer fills. However, unless multiple connections exist between the AAA client and AAA agent, closing of the receive window will affect all traffic sent by the AAA client, even traffic destined to AAA servers where no bottleneck exists. Since multiple connections between a AAA client and agent result in multiplication of the effective slow-start ramp rate, this is not recommended. As a result, use of &#34;back pressure&#34; cannot enable individual AAA client-server conversations to self-clock, and this technique appears impractical for use in AAA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2つの交通機関の接続の間できめ細かい結合を誘導する方法は、実施することが困難です。 AAAエージェントがその送信バッファより大きくない受信バッファで動作するための1つの可能なソリューションです。これが行われた場合、「背圧」（受信ウィンドウの閉鎖は）エージェントは、エージェントがいっぱいバッファを送信レートを送信するAAAクライアントを減らすことになります。ただし、複数の接続には、AAAクライアントとAAAのエージェント、AAAクライアントから送信されるすべてのトラフィック、ボトルネックが存在しないAAAサーバ宛てにもトラフィックに影響を及ぼします受信ウィンドウのクローズの間に存在していない限り。効果的なスロースタートのランプ・レートの乗算でAAAクライアントとエージェントの結果との間に複数の接続ので、これはお勧めしません。その結果、「背圧」の使用は、自己クロックに個々のAAAクライアント - サーバの会話を有効にすることはできませんが、この技術はAAAでの使用のために実用的でない表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9. Delayed Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.9。遅延謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described in Appendix B, ACKs may comprise as much as half of the traffic generated in a AAA exchange. This occurs because AAA conversations are typically application-driven, and therefore there is frequently not enough traffic to enable ACK piggybacking. As a result, AAA protocols running over TCP or SCTP transport may experience a doubling of traffic as compared with implementations utilizing UDP transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録Bに記載されているように、ACKはAAA交換で生成されるトラフィックの半分ほどに含むことができます。 AAAの会話は、通常、アプリケーション主導型であるため、ACKのピギーバックを可能にするために十分なトラフィックが頻繁に存在しないため、これが発生します。その結果、TCPまたはSCTPトランスポート上で実行されているAAAプロトコルはUDPトランスポートを利用し実装と比較して、トラフィックの倍増が発生することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is typically not possible to address this issue via the sockets API. ACK parameters (such as the value of the delayed ACK timer) are typically fixed by TCP and SCTP implementations and are therefore not tunable by the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソケットAPIを介してこの問題に対処するために一般的には不可能です。 （例えば、遅延ACKタイマの値など）ACKのパラメータは、典型的には、TCPとSCTP実装によって固定されており、したがって、アプリケーションによって調整可能れません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10. Premature Failover
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.10。早期のフェイルオーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RADIUS failover implementations are typically based on the concept of primary and secondary servers, in which all traffic flows to the primary server unless it is unavailable. However, the failover algorithm was not specified in [RFC2865] or [RFC2866]. As a result, RADIUS failover implementations vary in quality, with some failing over prematurely, violating the law of &#34;conservation of packets&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RADIUSフェイルオーバーの実装は、一般的に、それが使用できない場合を除き、すべてのトラフィックは、プライマリサーバに流れる、プライマリサーバとセカンダリサーバの概念に基づいています。しかし、フェイルオーバーアルゴリズムは[RFC2865]または[RFC2866]で指定されませんでした。その結果、RADIUSフェイルオーバーの実装はいくつかは、「パケットの保全」の法律を違反し、途中でフェールオーバーすると、品質が異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where a Relay, Proxy or Store and Forward proxy is present, the AAA client has no direct connection to a AAA server, and is unable to estimate the end-to-end transport parameters. As a result, a AAA client awaiting an application-layer response from the server has no transport-based mechanism for determining an appropriate failover timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リレー、プロキシまたはストア・アンド・フォワードプロキシが存在する場合、AAAクライアントは、AAAサーバに直接接続されていない、とエンドツーエンドのトランスポート・パラメータを推定することができません。結果として、サーバからアプリケーション層の応答を待っているAAAクライアントは、適切なフェイルオーバ・タイマを決定するためのトランスポートベースのメカニズムを有していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if the path between the AAA agent and server includes a high delay link, or if the AAA server is very heavily loaded, it is possible that the NAS will failover to another agent while packets are still in flight. This violates the principle of &#34;conservation of packets&#34;, since the AAA client will inject additional packets into the network before having evidence that a previously sent packet has left the network. Such behavior can result in a worse situation on an already congested link, resulting in congestive collapse [Congest].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、場合AAAエージェントとサーバ間のパスは、高遅延のリンクが含まれ、またはAAAサーバは非常に負荷が高い場合、パケットが飛行中に残っている間、NASは、別のエージェントにフェイルオーバーする可能性があります。 AAAクライアントが以前に送信されたパケットがネットワークを残しているという証拠を持つ前に、ネットワークに追加パケットを注入しますので、これは、「パケットの保全」の原則に違反します。このような行動は、うっ血性崩壊[輻輳]で、その結果、すでに混雑したリンク上に悪い状況につながることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.11. Head of Line Blocking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.11。ラインブロッキングのヘッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Head of line blocking occurs during periods of packet loss where the time between sends is shorter than the re-transmission timeout value (RTO). In such situations, packets back up in the send queue until the lost packet can be successfully re-transmitted. This can be an issue for SCTP when using ordered delivery over a single stream, and for TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ラインブロックの先頭が送信の間の時間は、再送タイムアウト値（RTO）より短いパケット損失の期間中に生じます。このような状況、送信キュー内のパケットのバックアップ失われたパケットが正常に再送信することができるようになるまでには。これは、単一のストリームを超える、およびTCPのための注文の配信を使用してSCTPのための問題になることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Head of line blocking is typically an issue only on larger NASes. For example, a 48-port NAS with an average inter-packet spacing of 25 seconds is unlikely to have an RTO greater than this, unless severe packet loss has been experienced. However, a 2048-port NAS with an average inter-packet spacing of 293 ms may experience head-of-line blocking since the inter-packet spacing is less than the minimum RTO value of 1 second [RFC2988].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
行ブロッキングのヘッドは大きなNASで、一般的な問題です。深刻なパケット損失が経験されていない限り、例えば、25秒間の平均パケット間の間隔が48ポートNASは、これよりも大きいRTOを持っていることはほとんどありません。パケット間間隔が1秒[RFC2988]の最小RTO値未満であるので、293ミリ秒の平均のパケット間間隔を有する2048ポートNASヘッドオブラインブロッキングを経験し得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.12. Connection Load Balancing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.12。接続ロード・バランシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to lessen queuing delays and address head of line blocking, a AAA implementation may wish to load balance between connections to multiple destinations. While it is possible to employ dynamic load balancing techniques, this level of sophistication may not be required. In many situations, adequate reliability and load balancing can be achieved via static load balancing, where traffic is distributed between destinations based on static &#34;weights&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キューイング遅延やラインブロックのアドレスヘッドを軽減するためには、AAAの実装では、複数の宛先への接続との間のバランスをロードしたいことがあります。それは動的負荷分散技術を採用することは可能ですが、洗練されたこのレベルが必要とされないことがあります。多くの状況では、十分な信頼性とロードバランシングは、トラフィックが静的な「重み」に基づいて目的地の間に分散された静的な負荷分散、を介して達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. AAA Transport Profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. AAA輸送プロフィール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to address AAA transport issues, it is recommended that AAA protocols make use of standards track as well as experimental techniques. More details are provided in the sections that follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA輸送の問題に対処するためには、追跡するだけでなく、実験技術AAAプロトコルが標準規格を利用することをお勧めします。詳細は以下のセクションで提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Transport Mappings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。交通のマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA Servers MUST support TCP and SCTP. AAA clients SHOULD support SCTP, but MUST support TCP if SCTP is not available. As support for SCTP improves, it is possible that SCTP support will be required on clients at some point in the future. AAA agents inherit all the obligations of Servers with respect to transport support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAサーバは、TCPやSCTPをサポートしなければなりません。 AAAクライアントは、SCTPをサポートする必要がありますが、SCTPが利用できない場合、TCPをサポートしなければなりません。 SCTPのサポートが向上したように、SCTPのサポートは、将来のある時点で、クライアント上で必要とされる可能性があります。 AAAエージェントがサポートを輸送に関してサーバーのすべての義務を継承します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Use of Nagle Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。 Nagleアルゴリズムの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While AAA protocols typically operate in the application-driven regime, there are circumstances in which they are network driven. For example, where an NAS reboots, or where connectivity is restored between an NAS and a AAA agent, it is possible that multiple packets will be available for sending.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAプロトコルは、典型的には、アプリケーション駆動型レジームで動作している間、彼らはネットワーク駆動される状況があります。 NASが再起動、または接続がNASとAAAエージェントとの間で復元される場合、例えば、複数のパケットが送信のために利用可能になる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a result, there are circumstances where the transport-layer batching provided by the Nagle Algorithm (12) is useful, and as a result, AAA implementations running over TCP MUST enable the Nagle algorithm, [RFC896]. The Nagle algorithm is not used with SCTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
結果として、Nagleアルゴリズム（12）によって提供されるトランスポート層のバッチが有用であり、その結果として、AAA実装は[RFC896]、Nagleアルゴリズムを有効にする必要があり、TCP上で実行されている状況があります。 Nagleアルゴリズムは、SCTPで使用されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Multiple Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。複数の接続
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA protocols SHOULD use only a single persistent connection between a AAA client and a AAA agent or server. They SHOULD provide for pipelining of requests, so that more than one request can be in progress at a time. In order to minimize use of inactive connections in roaming situations, a AAA client or agent MAY bring down a connection to a AAA agent or server if the connection has been unutilized (discounting the watchdog) for a certain period of time, which MUST NOT be less than BRINGDOWN_INTERVAL (5 minutes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAプロトコルは、AAAクライアントとAAAのエージェントまたはサーバー間の唯一の単一の持続的接続を使用する必要があります。複数の要求が一度に進行中であることができるように彼らは、リクエストのパイプラインを提供すべきです。接続がであってはならない、一定時間（ウォッチドッグを割り引く）未利用された場合の状況をローミングにおける非アクティブな接続の使用を最小限にするためには、AAAクライアントまたはエージェントはAAAのエージェントまたはサーバーへの接続をダウンさせるかもしれませんBRINGDOWN_INTERVAL（5分）よりも少ないです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While a AAA client/agent SHOULD only use a single persistent connection to a given AAA agent or server, it MAY have connections to multiple AAA agents or servers. A AAA client/agent connected to multiple agents/servers can treat them as primary/secondary or balance load between them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAクライアント/エージェントのみが与えられたAAAのエージェントまたはサーバーへの単一の持続的接続を使用する必要がありますが、それは複数のAAAエージェントまたはサーバーへの接続を持っているかもしれません。 AAAクライアント/エージェントは複数のエージェント/サーバに接続され、それらの間のプライマリ/セカンダリまたはバランス負荷として扱うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Application Layer Watchdog
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4。アプリケーション層のウォッチドッグ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to enable AAA implementations to more quickly detect transport and application-layer failures, AAA protocols MUST support an application layer watchdog message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
より迅速輸送およびアプリケーション層の障害を検出するために、AAA実装を可能にするために、AAAプロトコルは、アプリケーション層ウォッチドッグメッセージをサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The application layer watchdog message enables failover from a peer that has failed, either because it is unreachable or because its applications functions have failed. This is distinct from the purpose of the SCTP heartbeat, which is to enable failover between interfaces. The SCTP heartbeat may enable a failover to another path to reach the same server, but does not address the situation where the server system or the application service has failed. Therefore both mechanisms MAY be used together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション層のウォッチドッグ・メッセージは、それが到達不能であるか、そのアプリケーションの機能に障害が発生しているのでどちらかのために、失敗したピアからのフェイルオーバーが可能になります。これは、インターフェイス間のフェイルオーバーを可能にすることであるSCTPハートビートの目的は区別されます。 SCTPハートビートは、同じサーバーに到達するために別のパスへのフェイルオーバーを可能にするかもしれないが、サーバ・システムやアプリケーションサービスに障害が発生した状況に対処しません。したがって、両方のメカニズムを併用してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The watchdog is used in order to enable a AAA client or agent to determine when to resend on another connection. It operates on all open connections and is used to suspend and eventually close connections that are experiencing difficulties. The watchdog is also used to re-open and validate connections that have returned to health. The watchdog may be utilized either within primary/secondary or load balancing configurations. However, it is not intended as a cluster heartbeat mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウォッチドッグは、別の接続で再送するかを決定するためにAAAクライアントまたはエージェントを有効にするために使用されています。これは、すべての開いている接続上で動作し、困難を経験している近くの接続を中断し、最終的に使用されます。ウォッチドッグはまた、再オープンし、健康に戻ってきたの接続を検証するために使用されます。ウォッチドッグは、いずれかのプライマリ/セカンダリ又は負荷分散構成内で利用することができます。しかし、クラスタハートビート・メカニズムとして意図されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The application layer watchdog is designed to detect failures of the immediate peer, and not to be affected by failures of downstream proxies or servers. This prevents instability in downstream AAA components from propagating upstream. While the receipt of any AAA Response from a peer is taken as evidence that the peer is up, lack of a Response is insufficient to conclude that the peer is down. Since the lack of Response may be the result of problems with a downstream proxy or server, only after failure to respond to the watchdog message can it be determined that the peer is down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション層のウォッチドッグはすぐにピアの障害を検出するように設計されており、下流のプロキシまたはサーバの障害によって影響を受けません。これは、上流伝播下流AAAコンポーネントに不安定性を防止します。ピアからのすべてのAAA応答の受信がピアが起動していることを証拠として採用されている間、応答の欠如は、ピアがダウンしていると結論するには不十分です。応答の欠如が下流のプロキシまたはサーバーの問題の結果である可能性がありますので、唯一の障害発生後、ウォッチドッグ・メッセージに応答するには、ピアがダウンしていると判断することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the watchdog algorithm takes any AAA Response into account in determining peer liveness, decreases in the watchdog timer interval do not significantly increase the level of watchdog traffic on heavily loaded networks. This is because watchdog messages do not need to be sent where other AAA Response traffic serves as a constant reminder of peer liveness. Watchdog traffic only increases when AAA traffic is light, and therefore a AAA Response &#34;signal&#34; is not present. Nevertheless, decreasing the timer interval TWINIT does increase the probability of false failover significantly, and so this decision should be made with care.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウォッチドッグ・アルゴリズムは、ピアライブネスを決定する際に考慮に任意のAAA応答がかかるため、かなり負荷の高いネットワーク上のウォッチドッグ・トラフィックのレベルを増加させない、ウォッチドッグタイマ間隔で減少しています。ウォッチドッグ・メッセージは、他のAAA応答トラフィックは、ピアライブネスの定数リマインダとして機能場所を送信する必要がないためです。 AAAトラフィックが光であるため、AAA応答「信号が」存在しない場合、ウォッチドッグ・トラフィックだけ増加します。それにもかかわらず、タイマー間隔TWINITを減少させると大幅に偽のフェイルオーバーの確率を高めるんので、この決定は、慎重になされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1. Algorithm Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1。アルゴリズムの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The watchdog behavior is controlled by an algorithm defined in this section. This algorithm is appropriate for use either within primary/secondary or load balancing configurations. Implementations SHOULD implement this algorithm, which operates as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウォッチドッグの動作は、このセクションで定義されたアルゴリズムによって制御されます。このアルゴリズムは、使用に適しているいずれかのプライマリ/セカンダリまたはロードバランシングコンフィギュレーション内。実装は次のように動作する、このアルゴリズムを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1] Watchdog behavior is controlled by a single timer (Tw). The initial value of Tw, prior to jittering is Twinit. The default value of Twinit is 30 seconds. This value was selected because it minimizes the probability that failover will be initiated due to a routing flap, as noted in [Paxson].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1]ウォッチドッグ挙動は、単一のタイマ（TW）により制御されます。前ジッタへTwの初期値は、Twinitです。 Twinitのデフォルト値は30秒​​です。それは[パクソン]で述べたように、フェイルオーバーが、原因ルーティングフラップに開始される可能性を最小限に抑えるため、この値を選択しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       While Twinit MAY be set as low as 6 seconds (not including
       jitter), it MUST NOT be set lower than this.  Note that setting
       such a low value for Twinit is likely to result in an increased
       probability of duplicates, as well as an increase in spurious
       failover and failback attempts.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to avoid synchronization behaviors that can occur with fixed timers among distributed systems, each time the watchdog interval is calculated with a jitter by using the Twinit value and randomly adding a value drawn between -2 and 2 seconds. Alternative calculations to create jitter MAY be used. These MUST be pseudo-random, generated by a PRNG seeded as per [RFC1750].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
分散システムの間で固定タイマーで発生する可能性が同期動作を回避するために、それぞれの時間は、ウォッチドッグ間隔はTwinit値を用いてランダム-2と2秒の間に引かれた値を加算することにより、ジッタを算出します。ジッタを作成するための代替の計算が使用されるかもしれません。これらは、擬似ランダム、PRNGは[RFC1750]に従って播種することによって生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2] When any AAA message is received, Tw is reset. This need not be a response to a watchdog request. Receiving a watchdog response from a peer constitutes activity, and Tw should be reset. If the watchdog timer expires and no watchdog response is pending, then a watchdog message is sent. On sending a watchdog request, Tw is reset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意AAAメッセージを受信した場合[2]、Twがリセットされます。これは、ウォッチドッグ要求に応答する必要はありません。ピアからのウォッチドッグ・レスポンスを受信すると、アクティビティを構成し、Twがリセットされなければなりません。ウォッチドッグ・タイマーが切れると何のウォッチドッグ応答が保留されていない場合は、ウォッチドッグメッセージが送信されます。ウォッチドッグ・リクエストを送信するには、Twがリセットされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Watchdog packets are not retransmitted by the AAA protocol, since
       AAA protocols run over reliable transports that will handle all
       retransmissions internally.  As a result, a watchdog request is
       only sent when there is no watchdog response pending.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3] If the watchdog timer expires and a watchdog response is pending, then failover is initiated. In order for a AAA client or agent to perform failover procedures, it is necessary to maintain a pending message queue for a given peer. When an answer message is received, the corresponding request is removed from the queue. The Hop-by-Hop Identifier field MAY be used to match the answer with the queued request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウォッチドッグタイマが満了すると、ウォッチドッグ応答が保留されている場合は、[3]、その後、フェイルオーバーが開始されます。フェイルオーバー手順を実行するためのAAAクライアントまたはエージェントのためには、与えられたピアの保留中のメッセージキューを維持する必要があります。応答メッセージが受信されると、対応する要求をキューから削除されます。ホップバイホップ識別子フィールドは、キューに入れられたリクエストに答えを一致させるために使用されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       When failover is initiated, all messages in the queue are sent to
       an alternate agent, if available.  Multiple identical requests or
       answers may be received as a result of a failover.  The
       combination of an end-to-end identifier and the origin host MUST
       be used to identify duplicate messages.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that where traffic is heavy, the application layer watchdog can take as long as 2Tw to determine that a peer has gone down. For peers receiving a high volume of AAA Requests, AAA Responses will continually reset the timer, so that after a failure it will take Tw for the lack of traffic to be noticed, and for the watchdog message to be sent. Another Tw will elapse before failover is initiated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トラフィックが重いです2Twは、ピアがダウンしたと判断すると、アプリケーション層のウォッチドッグは限り取ることに注意してください。ピアはAAA要求の高いボリュームを受信するために、AAA応答が失敗した後、それが注目されるべきトラフィックの不足のためTwのがかかりますように、継続的に、タイマーをリセットし、ウォッチドッグ・メッセージを送信します。フェイルオーバーが開始される前に別のTwが経過します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On a lightly loaded network without much AAA Response traffic, the watchdog timer will typically expire without being reset, so that a watchdog response will be outstanding and failover will be initiated after only a single timer interval has expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウォッチドッグ応答が優れただろうとフェイルオーバーは、単一のタイマー間隔が経過した後に開始されるように多くのAAAの応答トラフィックのない負荷の軽いネットワークでは、ウォッチドッグタイマは、一般的に、リセットされずに期限切れになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4] The client MUST NOT close the primary connection until the primary&#39;s watchdog timer has expired at least twice without a response (note that the watchdog is not sent a second time, however). Once this has occurred, the client SHOULD cause a transport reset or close to be done on the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
主のウォッチドッグタイマは、応答（ただし、ウォッチドッグが二度目に送信されないことに注意）なしで少なくとも二回切れるまで[4]クライアントは、プライマリ接続を閉じてはなりません。これが発生すると、クライアントが接続上で行うことに近いまたはトランスポートリセットが発生する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Once the primary connection has failed, subsequent requests are
       sent to the alternate server until the watchdog timer on the
       primary connection is reset.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suspension of the primary connection prevents flapping between primary and alternate connections, and ensures that failover behavior remains consistent. The application may not receive a response to the watchdog request message due to a connectivity problem, in which case a transport layer ACK will not have been received, or the lack of response may be due to an application problem. Without transport layer visibility, the application is unable to tell the difference, and must behave conservatively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プライマリ接続の懸濁液を、一次および代替接続間羽ばたき防止し、フェイルオーバー動作が一貫したままこ​​とを保証します。アプリケーションが原因トランスポート層ACKが受信されていないか、または応答の欠如は、アプリケーションの問題が原因である可能性があり、その場合、接続の問題にウォッチドッグ要求メッセージに対する応答を受信することができません。トランスポート層の可視性がなければ、アプリケーションは違いを見分けることができない、と控えめに動作する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In situations where no transport layer ACK is received on the primary connection after multiple re-transmissions, the RTO will be exponentially backed off as described in [RFC2988]. Due to Karn&#39;s algorithm as implemented in SCTP and TCP, the RTO estimator will not be reset until another ACK is received in response to a non-re-transmitted request. Thus, in cases where the problem occurs at the transport layer, after the client fails over to the alternate server, the RTO of the primary will remain at a high value unless an ACK is received on the primary connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2988]に記載されているように何輸送層ACKは、複数の再送信の後に、一次接続上で受信されていない状況では、RTOは、指数関数的に後退します。別のACKが非再送信された要求に応答して受信されるまでによるSCTPとTCPに実装されるカーンのアルゴリズムに、RTO推定器はリセットされないであろう。 ACKは、一次接続上で受信されていない限り、このように、クライアントが代替サーバにフェイルオーバーした後に問題が、トランスポート層で発生した場合には、一次のRTOは、高い値に留まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case where the problem occurs at the transport layer, subsequent requests sent on the primary connection will not receive the same service as was originally provided. For example, instead of failover occurring after 3 retransmissions, failover might occur without even a single retransmission if RTO has been sufficiently backed off. Of course, if the lack of a watchdog response was due to an application layer problem, then RTO will not have been backed off. However, without transport layer visibility, there is no way for the application to know this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
元々提供されたように問題はトランスポート層で発生した場合に、一次接続上で送信された後続の要求は、同一のサービスを受信しないであろう。たとえば、代わりにフェイルオーバーが3つの再送信した後に発生するのは、フェールオーバーは、RTOが十分にオフにバックアップされている場合でも、単一の再送信せずに発生する可能性があります。ウォッチドッグ応答の欠如は、アプリケーション層の問題によるものであった場合はもちろん、その後、RTOはオフにバックアップされていません。しかし、トランスポート層の可視性なしで、アプリケーションがこれを知る方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suspending use of the primary connection until a response to a watchdog message is received guarantees that the RTO timer will have been reset before the primary connection is reused. If no response is received after the second watchdog timer expiration, then the primary connection is closed and the suspension becomes permanent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウォッチドッグ・メッセージへの応答がプライマリ接続が再利用される前に、RTOタイマがリセットされてしまうという保証を受信されるまで、プライマリ接続の使用を一時停止。応答が第二のウォッチドッグタイマの満了後に受信されない場合、プライマリ接続が閉じられ、懸濁液は、永久なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5] While the connection is in the closed state, the AAA client MUST NOT attempt to send further watchdog messages on the connection. However, after the connection is closed, the AAA client continues to periodically attempt to reopen the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続が閉じられた状態にある間に、[5]、AAAクライアントが接続でさらにウォッチドッグ・メッセージを送信することを試みてはいけません。接続が閉じられた後しかし、AAAクライアントが定期的に接続を再開しようとし続けています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       The AAA client SHOULD wait for the transport layer to report
       connection failure before attempting again, but MAY choose to
       bound this wait time by the watchdog interval, Tw.  If the
       connection is successfully opened, then the watchdog message is
       sent.  Once three watchdog messages have been sent and responded
       to, the connection is returned to service, and transactions are
       once again sent over it.  Connection validation via receipt of
       multiple watchdogs is not required when a connection is initially
       brought up -- in this case, the connection can immediately be put
       into service.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[6] When using SCTP as a transport, it is not necessary to disable SCTP&#39;s transport-layer heartbeats. However, if AAA implementations have access to SCTP&#39;s heartbeat parameters, they MAY chose to ensure that SCTP&#39;s heartbeat interval is longer than the AAA watchdog interval, Tw. This will ensure that alternate paths are still probed by SCTP, while the primary path has a minimum of heartbeat redundancy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トランスポートとしてSCTPを使用する場合は、[6]、SCTPのトランスポート層のハートビートを無効にする必要はありません。 AAAの実装は、SCTPのハートビートパラメータへのアクセスを持っている場合は、彼らはSCTPのハートビート間隔が長くAAAウォッチドッグ間隔、Twよりであることを保証するために選択することができます。これは、プライマリパスがハートビート冗長性の最小値を有している代替パスがまだ、SCTPによってプローブされることを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2. Primary/Secondary Failover Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2。プライマリ/セカンダリフェールオーバーサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The watchdog timer MAY be integrated with primary/secondary style failover so as to provide improved reliability and basic load balancing. In order to balance load among multiple AAA servers, each AAA server is designated the primary for a portion of the clients, and designated as secondaries of varying priority for the remainder. In this way, load can be balanced among the AAA servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
信頼性の向上と、基本的な負荷分散を提供するように、ウォッチドッグタイマは、プライマリ/セカンダリスタイルのフェイルオーバーと統合することができます。複数のAAAサーバ間で負荷を分散するために、各AAAサーバは、クライアントの部分のための主要な指定され、残りの優先度を変えるのセカンダリとして指定します。このように、負荷は、AAAサーバの間でバランスをとることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Within primary/secondary configurations, the watchdog timer operates as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにプライマリ/セカンダリ構成の中では、ウォッチドッグタイマは動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1] Assume that each client or agent is initially configured with a single primary agent or server, and one or more secondary connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1]各クライアントまたはエージェントは、最初に単一の一次エージェントまたはサーバ、および1つまたは複数の二次接続で構成されているものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2] The watchdog mechanism is used to suspend and eventually close primary connections that are experiencing difficulties. It is also used to re-open and validate connections that have returned to health.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2]ウォッチドッグ機構が一時停止し、最終的に困難を経験しているプラ​​イマリ接続を閉じるために使用されます。また、再オープンし、健康に戻ってきたの接続を検証するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3] Once a secondary is promoted to primary status, either on a temporary or permanent basis, the next server on the list of secondaries is promoted to fill the open secondary slot.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3]一時的または永続的にのいずれかで、プライマリ状態に昇格された二次たら、セカンダリのリスト上の次のサーバは、オープン二次スロットを埋めるために促進されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4] The client or agent periodically attempts to re-open closed connections, so that it is possible that a previously closed connection can be returned to service and become eligible for use again. Implementations will typically retain a limit on the number of connections open at a time, so that once a previously closed connection is brought online again, the lowest priority secondary connection will be closed. In order to prevent periodic closing and re-opening of secondary connections, it is recommended that functioning connections remain open for a minimum of 5 minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以前に閉じられた接続がサービスに戻され、再度使用するために対象になることができることが可能となるように[4]クライアントまたはエージェントは、定期的に再オープン接続を閉鎖しようとします。以前クローズ接続が再びオンラインになると、最も低い優先度の二次接続がクローズされるように、実装は、通常、一度にオープン接続数の制限を保持します。周期的な閉鎖とセカンダリ接続の再開放を防止するためには、機能の接続が5分以上開いたままにすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5] In order to enable diagnosis of failover behavior, it is recommended that a table of failover events be kept within the MIB. These failover events SHOULD include appropriate transaction identifiers so that client and server data can be compared, providing insight into the cause of the problem (transport or application layer).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5]フェイルオーバー動作の診断を可能にするためには、フェイルオーバー・イベントのテーブルをMIB内に維持することが推奨されます。クライアントとサーバーのデータが問題（輸送またはアプリケーション層）の原因への洞察を提供し、比較できるように、これらのフェイルオーバー・イベントは、適切なトランザクション識別子を含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.3. Connection Load Balancing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.3。接続ロード・バランシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Primary/secondary failover is capable of providing improved resilience and basic load balancing. However, it does not address TCP head of line blocking, since only a single connection is in use at a time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プライマリ/セカンダリフェールオーバーが改善された弾力性と基本的な負荷分散を提供することが可能です。唯一の単一の接続が一度に使用されているので、しかし、それは、ラインブロッキングのTCPヘッドに対応していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A AAA client or agent maintaining connections to multiple agents or servers MAY load balance between them. Establishing connections to multiple agents or servers reduces, but does not eliminate, head of line blocking issues experienced on TCP connections. This issue does not exist with SCTP connections utilizing multiple streams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数のエージェントまたはサーバーへの接続を維持するAAAクライアントまたはエージェントがそれらの間のバランスをロードします。複数のエージェントまたはサーバーへの接続を確立することは減少しますが、TCP接続上で経験した問題をブロックラインの先頭がなくなるわけではありません。この問題は、複数のストリームを利用SCTP接続には存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In connection load balancing configurations, the application watchdog operates as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように接続ロード・バランシングの構成では、アプリケーションウォッチドッグが動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1] Assume that each client or agent is initially configured with connections to multiple AAA agents or servers, with one connection between a given client/agent and an agent/server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1]各クライアントまたはエージェントが最初に与えられたクライアント/エージェントとエージェント/サーバ間の1つの接続と、複数のAAAエージェント、またはサーバへの接続で構成されているものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2] In static load balancing, transactions are apportioned among the connections based on the total number of connections and a &#34;weight&#34; assigned to each connection. Pearson&#39;s hash [RFC3074] applied to the NAI [RFC2486] can be used to determine which connection will handle a given transaction. Hashing on the NAI provides highly granular load balancing, while ensuring that all traffic for a given conversation will be sent to the same agent or server. In dynamic load balancing, the value of the &#34;weight&#34; can vary based on conditions such as AAA server load. Such techniques, while sophisticated, are beyond the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2]静的負荷分散において、トランザクションは、接続の総数と各接続に割り当てられた「重み」に基づいて接続間で配分されます。ピアソンのハッシュ[RFC3074]はNAI [RFC2486]に適用される特定のトランザクションを処理するどの接続を決定するために使用することができます。特定の会話のすべてのトラフィックが同じエージェントまたはサーバーに送信されることを確保しながら、NAIにハッシュする、きめ細かいロード・バランシングを提供します。動的負荷分散では、「重量」の値は、AAAサーバ負荷などの条件に基づいて変化することができます。このような技術は、洗練された一方で、このドキュメントの範囲を超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3] Transactions are distributed to connections based on the total number of available connections and their weights. A change in the number of available connections forces recomputation of the hash table. In order not to cause conversations in progress to be switched to new destinations, on recomputation, a transitional period is required in which both old and new hash tables are needed in order to permit aging out of conversations in progress. Note that this requires a way to easily determine whether a Request represents a new conversation or the continuation of an existing conversation. As a result, removing and adding of connections is an expensive operation, and it is recommended that the hash table only be recomputed once a connection is closed or returned to service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3]トランザクションは、利用可能な接続とその重みの合計数に基づいて、接続に分配されます。ハッシュテーブルの使用可能な接続を強制的に再計算の数の変化。進行中の会話は新しい宛先に切り替えることが原因としないようにするためには、再計算の上、移行期間は、新旧両方のハッシュテーブルが進行中の会話のうち、老朽化可能にするために必要とされている必要があります。これは簡単にリクエストが新しい会話したり、既存の会話の継続を表しているかどうかを決定するための方法が必要であることに注意してください。結果として、除去し、接続の追加は高価な操作であり、それは、接続が閉じられ又はサービスに戻されると、ハッシュテーブルのみを再計算することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Suspended connections, although they are not used, do not force
       hash table reconfiguration until they are closed.  Similarly,
       re-opened connections not accumulating sufficient watchdog
       responses do not force a reconfiguration until they are returned
       to service.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While a connection is suspended, transactions that were to have been assigned to it are instead assigned to the next available server. While this results in a momentary imbalance, it is felt that this is a relatively small price to pay in order to reduce hash table thrashing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続が中断されているが、それに割り当てられているためにした取引は、代わりに次の使用可能なサーバーに割り当てられています。これは瞬間的な不均衡につながるが、ハッシュテーブルのスラッシングを減らすために支払うために比較的小さい価格であると感じています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4] In order to enable diagnosis of load balancing behavior, it is recommended that in addition to a table of failover events, a table of statistics be kept on each client, indexed by a AAA server. That way, the effectiveness of the load balancing algorithm can be evaluated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4]ロードバランシング動作の診断を可能にするためには、フェイルオーバー・イベントのテーブルに加えて、統計の表をAAAサーバによってインデックス付け、各クライアント上に保持することが推奨されます。こうすることで、負荷分散アルゴリズムの有効性を評価することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Duplicate Detection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5。重複検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multiple facilities are required to enable duplicate detection. These include session identifiers as well as hop-by-hop and end-to-end message identifiers. Hop-by-hop identifiers whose value may change at each hop are not sufficient, since a AAA server may receive the same message from multiple agents. For example, a AAA client can send a request to Agent1, then failover and resend the request to Agent2; both agents forward the request to the home AAA server, with different hop-by-hop identifiers. A Session Identifier is insufficient as it does not distinguish different messages for the the same session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の施設は、重複検出を有効にする必要があります。これらは、セッション識別子、ならびにホップバイホップとエンドツーエンドのメッセージ識別子を含みます。 AAAサーバは、複数のエージェントから同じメッセージを受信することができるので、その値は各ホップで変更することができるホップバイホップ識別子は、十分ではありません。たとえば、AAAクライアントは、フェイルオーバーおよびエージェント2に要求を再送信し、その後、エージェント1に要求を送信することができます。両方の薬剤は、異なるホップバイホップ識別子と、ホームAAAサーバに要求を転送します。それは同じセッションのために異なるメッセージを区別しないように、セッション識別子は不十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proper treatment of the end-to-end message identifier ensures that AAA operations are idempotent. For example, without an end-to-end identifier, a AAA server keeping track of simultaneous logins might send an Accept in response to an initial Request, and then a Reject in response to a duplicate Request (where the user was allowed only one simultaneous login). Depending on which Response arrived first, the user might be allowed access or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンドツーエンドのメッセージ識別子の適切な処置は、AAA操作が冪等であることを保証します。例えば、エンドツーエンドの識別子なしに、同時ログインを追跡するAAAサーバは、最初の要求に応答して受け入れ、そして、ユーザが一つだけが同時せた重複要求（に応答拒否を送信するかもしれませんログインする）。これに応じて応答が、最初に到着したユーザーがアクセスを許可またはいない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, if the server were to store the end-to-end message identifier along with the simultaneous login information, then the duplicate Request (which utilizes the same end-to-end message identifier) could be identified and the correct response could be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、次に同時ログイン情報、（同一のエンド・ツー・エンドのメッセージ識別子を利用する）重複要求と共に、エンドツーエンドのメッセージ識別子を格納した場合しかし、同定することができ、正しい応答を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Invalidation of Transport Parameter Estimates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6。交通パラメータ推定値の無効化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to address invalidation of transport parameter estimates, AAA protocol implementations MAY utilize Congestion Window Validation [RFC2861] and RTO validation when using TCP. This specification also recommends a procedure for RTO validation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPを使用する場合、トランスポートパラメータ推定値の無効化に対処するために、AAAプロトコルの実装は、輻輳ウィンドウ検証[RFC2861]とRTOの検証を利用することができます。また、この仕様はRTOの検証のための手順を推奨しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2581] and [RFC2861] both recommend that a connection go into slow-start after a period where no traffic has been sent within the RTO interval. [RFC2861] recommends only increasing the congestion window if it was full when the ACK arrived. The congestion window is reduced by half once every RTO interval if no traffic is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2581]と[RFC2861]は、両方の接続がトラフィックがRTO間隔内に送信されていない期間の後のスロースタートに入ることをお勧めします。 [RFC2861]はACKが到着したとき、それは完全だった場合のみ、輻輳ウィンドウの増加をお勧めします。トラフィックが受信されない場合、輻輳ウィンドウを半分に一度RTO間隔によって低減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When Congestion Window Validation is used, the congestion window will not build during application-driven periods, and instead will be decayed. As a result, AAA applications operating within the application-driven regime will typically run with a congestion window equal to the initial window much of the time, operating in &#34;perpetual slowstart&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳ウィンドウ検証を使用すると、輻輳ウィンドウは、アプリケーション主導の期間中に構築しなくなり、代わりに減衰されます。その結果、アプリケーション主導の政権内で動作するAAAのアプリケーションは、典型的には、「永遠のスロースタート」で動作し、時間の非常に初期の窓に等しい混雑ウィンドウで実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
During periods in which AAA behavior is application-driven this will have no effect. Since the time between packets will be larger than RTT, AAA will operate with an effective congestion window equal to the initial window. However, during network-driven periods, the effect will be to space out sending of AAA packets. Thus instead of being able to send a large burst of packets into the network, a client will need to wait several RTTs as the congestion window builds during slow-start.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
中期間中AAAの動作は、アプリケーション主導型これは効果がありませんです。パケット間の時間がRTTよりも大きくなるので、AAAは、初期画面に等しい有効な混雑ウィンドウで動作します。しかし、ネットワーク主導の期間中、効果はAAAパケットの送信外空間になります。したがって、代わりにネットワークにパケットの大バーストを送信することができるという、クライアントは、輻輳ウィンドウはスロースタート時に構築するなど、いくつかのRTTを待つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, a client operating over TCP with an initial window of 2, with 35 AAA requests to send would take approximately 6 RTTs to send them, as the congestion window builds during slow start: 2, 3, 3, 6, 9, 12. After the backlog is cleared, the implementation will once again be application-driven and the congestion window size will decay. If the client were using SCTP, the number of RTTs needed to transmit all requests would usually be less, and would depend on the size of the requests, since SCTP tracks the progress for the opening of the congestion window by bytes, not segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2、3、3、6、9、12：輻輳ウィンドウは、スロースタート中に構築するよう例えば、送信するための35回のAAA要求と2の初期ウィンドウでTCP上で動作するクライアントは、それらを送信するために約6つのRTTを取りますバックログがクリアされた後、実装は再びアプリケーション主導型と減衰します輻輳ウィンドウサイズになります。クライアントがSCTPを使用していた場合、RTTの数がすべての要求を送信するために必要な通常より少なくなり、そしてSCTPはバイトではなく、セグメント別の輻輳ウィンドウのオープンのための進行状況を追跡するので、要求のサイズに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that [RFC2861] and [RFC2988] do not address the issue of RTO validation. This is also a problem, particularly when the Congestion Manager [RFC3124] is implemented. During periods of high packet loss, the RTO may be repeatedly increased via exponential back-off, and may attain a high value. Due to lack of timely feedback on RTT and RTO during application-driven periods, the high RTO estimate may persist long after the conditions that generated it have dissipated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2861]と[RFC2988]はRTOの検証の問題に対処していないことに注意してください。これは、輻輳マネージャ[RFC3124]が実装されている場合は特に、また問題です。高いパケット損失の期間中、RTOが繰り返し指数バックオフを介して増加させることができる、と高い値を達成することができます。それを生成した条件が消失した後にアプリケーション主導の期間中のRTTとRTOのタイムリーなフィードバックの欠如に起因する、高いRTO推定値が長く持続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTO validation MAY be used to address this issue for TCP, via the following procedure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTOの検証は、以下の手順を経て、TCPのために、この問題に対処するために使用することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After the congestion window is decayed according to [RFC2861], reset the estimated RTO to 3 seconds. After the next packet comes in, re-calculate RTTavg, RTTdev, and RTO according to the method described in [RFC2581].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳ウィンドウは、[RFC2861]に記載の減衰された後、3秒と推定RTOをリセットします。次のパケットが到着した後、[RFC2581]に記載された方法に従ってRTTavg、RTTdev、及びRTOを再計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To address this issue for SCTP, AAA implementations SHOULD use SCTP heartbeats. [RFC2960] states that heartbeats should be enabled by default, with an interval of 30 seconds. If this interval proves to be too long to resolve this issue, AAA implementations MAY reduce the heartbeat interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCTPのために、この問題に対処するには、AAA実装はSCTPハートビートを使用すべきです。 [RFC2960]はハートビートが30秒の間隔で、デフォルトで有効にする必要があると述べています。この間隔は、この問題を解決するには長すぎることが判明した場合、AAAの実装は、ハートビート間隔を減らすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. Inability to Use Fast Re-Transmit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7。高速再送信を使用することができません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When Congestion Window Validation [RFC2861] is used, AAA implementations will operate with a congestion window equal to the initial window much of the time. As a result, the window size will often not be large enough to enable use of fast re-transmit for TCP. In addition, since AAA traffic is two-way, ACKs carrying data will not count towards triggering fast re-transmit. SCTP is less likely to encounter this issue, so the measures described below apply to TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳ウィンドウ検証[RFC2861]を使用する場合、AAA実装は時間のはるかに初期画面に等しい混雑ウィンドウで動作します。その結果、ウィンドウサイズは、多くの場合、TCPのための高速再送信の使用を可能にするのに十分な大きさではありません。また、AAAトラフィックが双方向であることから、ACKを搬送するデータは、高速再送信をトリガにカウントされません。 SCTPは、この問題が発生する可能性が低いので、下記の対策は、TCPに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To address this issue, AAA implementations SHOULD support selective acknowledgement as described in [RFC2018] and [RFC2883]. AAA implementations SHOULD also implement Limited Transmit for TCP, as described in [RFC3042]. Rather than reducing the number of duplicate ACKs required for triggering fast recovery, which would increase the number of inappropriate re-transmissions, Limited Transmit enables the window size be increased, thus enabling the sending of additional packets which in turn may trigger fast re-transmit without a change to the algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2018]及び[RFC2883]に記載されているように、この問題に対処するために、AAA実装は選択的確認応答をサポートしなければなりません。 [RFC3042]に記載されているようにAAA実装はまた、TCPための限られた送信を実装する必要があります。むしろ不適切な再送信の数を増加させるであろう速い回復をトリガするために必要な重複ACKの数を減少させるよりも、限定送信は、このように順番に高速再送信をトリガすることができる追加のパケットの送信を可能にする、ウィンドウサイズを大きくすることが可能アルゴリズムの変更なし。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, if congestion window validation [RFC2861] is implemented, this proposal will only have an effect in situations where the time between packets is less than the estimated retransmission timeout (RTO). If the time between packets is greater than RTO, additional packets will typically not be available for sending so as to take advantage of the increased window size. As a result, AAA protocols will typically operate with the lowest possible congestion window size, resulting in a re-transmission timeout for every lost packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳ウィンドウの検証[RFC2861]が実装されている場合しかし、この提案は、パケット間の時間は、推定再送タイムアウト（RTO）未満である状況において効果を有するであろう。パケット間の時間がRTOよりも大きい場合は、追加のパケットは、一般的に増加し、ウィンドウサイズを利用するように送信するために使用することはできません。結果として、AAAプロトコルは、典型的には、すべての失われたパケットの再送信タイムアウトになり、可能な最低の輻輳ウィンドウサイズで動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. Head of Line Blocking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8。ラインブロッキングのヘッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP inherently does not provide a solution to the head-of-line blocking problem, although its effects can be lessened by implementation of Limited Transmit [RFC3042], and connection load balancing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その効果は限定ミット[RFC3042]、および接続ロード・バランシングの実装によって軽減することができますが、TCPは本質的に、ヘッドオブラインブロッキングの問題に対する解決策を提供していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8.1. Using SCTP Streams to Prevent Head of Line Blocking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8.1。ラインの先頭の阻止を防ぐために、SCTPストリームの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each AAA node SHOULD distribute its messages evenly across the range of SCTP streams that it and its peer have agreed upon. (A lost message in one stream will not cause any other streams to block.) A trivial and effective implementation of this simply increments a counter for the stream ID to send on. When the counter reaches the maximum number of streams for the association, it resets to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
均等SCTPの範囲にわたって、そのメッセージを配信する各AAAノードは、そのピアが合意されていることをストリーム。 （一つのストリームで失われたメッセージが他のストリームをブロックすることはありません。）この些細なかつ有効な実施は、単に上の送信するストリームIDのためのカウンタをインクリメントします。カウンタは、関連付けのためのストリームの最大数に達すると、0にリセットします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA peers MUST be able to accept messages on any stream. Note that streams are used *solely* to prevent head-of-the-line blocking. All identifying information is carried within the Diameter payload. Messages distributed across multiple streams may not be received in the order they are sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAピアがどのストリーム上のメッセージを受け入れることができなければなりません。ストリームは、ヘッドオブラインブロッキングを防ぐために*のみ*を使用していることに注意してください。すべての識別情報は、直径ペイロード内で搬送されます。複数のストリームに分散メッセージは、それらが送信される順序で受信されなくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCTP peers can allocate up to 65535 streams for an association. The cost for idle streams may or may not be zero, depending on the implementation, and the cost for non-idle streams is always greater than 0. So administrators may wish to limit the number of possible streams on their diameter nodes according to the resources (i.e. memory, CPU power, etc.) of a particular node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCTPピアは、協会のために65535個のまでのストリームを割り当てることができます。アイドル・ストリームのためのコストは、またはしない場合があり、実装に依存して、ゼロであってもよく、非アイドルストリームのコストはいつも管理者がリソースに応じてそれらの直径ノードに可能なストリームの数を制限したい場合が0よりも大きいです特定のノード（すなわち、メモリ、CPUパワー、等）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On a Diameter client, the number of streams may be determined by the maximum number of peak users on the NAS. If a stream is available per user, then this should be sufficient to prevent head-of-line blocking. On a Diameter proxy, the number of streams may be determined by the maximum number of peak sessions in progress from that proxy to each downstream AAA server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Diameterクライアントに、ストリームの数は、NAS上のピークユーザの最大数によって決定することができます。ストリームは、ユーザごとに利用可能である場合、これはヘッドオブラインブロッキングを防ぐのに十分であるべきです。直径プロキシで、ストリームの数は、各ダウンストリームAAAサーバへのプロキシから進行中のピークセッションの最大数によって決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stream IDs do not need to be preserved by relay agents. This simplifies implementation, as agents can easily handle forwarding between two associations with different numbers of streams. For example, consider the following case, where a relay server DRL forwards messages between a NAS and a home server, HMS. The NAS and DRL have agreed upon 1000 streams for their association, and DRL and HMS have agreed upon 2000 streams for their association. The following figure shows the message flow from NAS to HMS via DRL, and the stream ID assignments for each message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ストリームIDは、リレーエージェントによって保存する必要はありません。薬剤は容易ストリームの異なる数を有する2つの団体の間での転送を処理することができ、これは、実装を簡素化します。例えば、中継サーバDRLは、NASとホームサーバ、HMS間でメッセージを転送し、次の場合を考えます。 NASとDRLは、その関連付けのために1000個のストリームに合意しており、DRLとHMSは、そのアソシエーションの2000年のストリームに合意しています。次の図は、メッセージごとにDRLを介してHMSにNASからのメッセージフロー、及びストリームIDの割り当てを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------+                   +------+                   +------+
   |      |                   |      |                   |      |
   | NAS  |    ---------&gt;     | DRL  |     ---------&gt;    | HMS  |
   |      |                   |      |                   |      |
   +------+   1000 streams    +------+    2000 streams   +------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              msg 1: str id 0             msg 1: str id 0
              msg 2: str id 1             msg 2: str id 1
              ...
              msg 1000: str id 999        msg 1000: str id 999
              msg 1001: str id 0          msg 1001: str id 1000
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DRL can forward messages 1 through 1000 to HMS using the same stream ID that NAS used to send to DRL. However, since the NAS / DRL association has only 1000 streams, NAS wraps around to stream ID 0 when sending message 1001. The DRL / HMS association, on the other hand, has 2000 streams, so DRL can reassign message 1001 to stream ID 1000 when forwarding it on to HMS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DRLは、NASは、DRLに送信するために使用したのと同じストリームIDを使用してHMS 1000を介してメッセージ1を転送することができます。 DRLは、ID 1000をストリーミングするメッセージ1001を再割り当てできるように、NAS / DRLアソシエーションのみ千ストリームを有しているので、NASは、DRL / HMSアソシエーションメッセージ1001を送信するときにID 0をストリーミングするためにラップアラウンドし、一方、2000のストリームを有しますHMSにそれを転送するとき。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This distribution scheme acts like a hash table. It is possible, yet unlikely, that two messages will end up in the same stream, and even less likely that there will be message loss resulting in blocking when this happens. If it does turn out to be a problem, local administrators can increase the number of streams on their nodes to improve performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この配信方式は、ハッシュテーブルのような役割を果たします。これは、2つのメッセージが同じストリームで終わるだろうということ、さらには可能性が低いこの問題が発生したときに、ブロッキングが生じメッセージの損失があることを、まだ、可能性は低い可能です。それが問題になることが判明しない場合は、ローカル管理者は、パフォーマンスを向上させるために、そのノード上でストリームの数を増やすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9. Congestion Avoidance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9。輻輳回避
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to improve upon default timer estimates, AAA implementations MAY implement the Congestion Manager (CM) [RFC3124]. CM is an end-system module that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デフォルトのタイマーの推定を改善するためには、AAA実装は輻輳マネージャ（CM）[RFC3124]を実装してもよい（MAY）。 CMはそのエンド・システム・モジュールです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       (i) Enables an ensemble of multiple concurrent streams from a
           sender destined to the same receiver and sharing the same
           congestion properties to perform proper congestion avoidance
           and control, and
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(ii) Allows applications to easily adapt to network congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（ⅱ）のアプリケーションが簡単にネットワークの輻輳に適応することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CM helps integrate congestion management across all applications and transport protocols. The CM maintains congestion parameters (available aggregate and per-stream bandwidth, per-receiver round-trip times, etc.) and exports an API that enables applications to learn about network characteristics, pass information to the CM, share congestion information with each other, and schedule data transmissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CMは、すべてのアプリケーションおよびトランスポートプロトコル間で輻輳管理を統合するのに役立ちます。 CMは（等利用可能な骨材とあたりストリーム帯域ごとの受信機の往復回）混雑パラメータを維持し、アプリケーションがネットワーク特性について学習を可能にするAPIをエクスポートし、互いにCM、共有渋滞情報に情報を渡します、およびスケジュールデータ伝送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CM enables the AAA application to access transport parameters (RTTavg, RTTdev) via callbacks. RTO estimates are currently not available via the callback interface, though they probably should be. Where available, transport parameters SHOULD be used to improve upon default timer values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CMは、コールバックを介してトランスポートパラメータ（RTTavg、RTTdev）にアクセスするためのAAAのアプリケーションを可能にします。彼らはおそらくあるべきにもかかわらずRTO推定値は、コールバックインタフェースを介して、現在は利用できません。利用可能な場合、トランスポートパラメータは、デフォルトのタイマー値を改善するために使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10. Premature Failover
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10。早期のフェイルオーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Premature failover is prevented by the watchdog functionality described above. If the next hop does not return a reply, the AAA client will send a watchdog message to it to verify liveness. If a watchdog reply is received, then the AAA client will know that the next hop server is functioning at the application layer. As a result, it is only necessary to provide terminal error messages, such as the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
早期フェイルオーバーは、上記ウォッチドッグ機能によって防止されます。次のホップが応答を返さない場合は、AAAクライアントが生存性を検証するために、それにウォッチドッグ・メッセージを送信します。ウォッチドッグ応答が受信されている場合は、AAAクライアントは、次ホップサーバーは、アプリケーション層で機能していることを知っています。その結果、次のような端末のエラーメッセージを提供することだけが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;Busy&#34;: agent/Server too busy to handle additional requests, NAS should failover all requests to another agent/server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「忙しい」：追加の要求を処理するにはあまりにも忙しいエージェント/サーバ、NASは、別のエージェント/サーバーへのすべての要求をフェイルオーバーする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;Can&#39;t Locate&#34;: agent can&#39;t locate the AAA server for the indicated realm; NAS should failover that request to another proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「検出できない」：エージェントは、指定されたレルムのAAAサーバを見つけることができません。 NASは、別のプロキシにその要求をフェイルオーバーする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;Can&#39;t Forward&#34;: agent has tried both primary and secondary AAA servers with no response; NAS should failover the request to another agent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「転送することはできません」：エージェントが応答なしでプライマリとセカンダリの両方のAAAサーバを試してみました。 NASは、別のエージェントにリクエストをフェイルオーバーする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that these messages differ in their scope. The &#34;Busy&#34; message tells the NAS that the agent/server is too busy for ANY request. The &#34;Can&#39;t Locate&#34; and &#34;Can&#39;t Forward&#34; messages indicate that the ultimate destination cannot be reached or isn&#39;t responding, implying per-request failover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのメッセージは、その範囲が異なることに注意してください。 「ビジー」メッセージは、エージェント/サーバはすべての要求のために忙しすぎていることをNASに指示します。 「フォワードできません」というメッセージが最終目的地に到達することができないか、要求ごとのフェイルオーバーを示唆し、応答していないことを示し、「検出できない」と。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.セキュリティについての考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since AAA clients, agents and servers serve as network access gatekeepers, they are tempting targets for attackers. General security considerations concerning TCP congestion control are discussed in [RFC2581]. However, there are some additional considerations that apply to this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAクライアント、エージェントとサーバーがネットワークアクセスゲートキーパーとして機能しているので、彼らは攻撃者のための魅力的な標的です。 TCPの輻輳制御に関する一般的なセキュリティ上の考慮事項は、[RFC2581]で議論されています。しかし、この仕様に適用されるいくつかの追加の考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By enabling failover between AAA agents, this specification improves the resilience of AAA applications. However, it may also open avenues for denial of service attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAエージェントとの間のフェイルオーバーを可能にすることにより、本明細書はAAAアプリケーションの回復力を向上させることができます。しかし、それはまた、サービス拒否攻撃のために道を開く可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The failover algorithm is driven by lack of response to AAA requests and watchdog packets. On a lightly loaded network where AAA responses would not be received prior to expiration of the watchdog timer, an attacker can swamp the network, causing watchdog packets to be dropped. This will cause the AAA client to switch to another AAA agent, where the attack can be repeated. By causing the AAA client to cycle between AAA agents, service can be denied to users desiring network access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フェイルオーバーアルゴリズムは、AAA要求とウォッチドッグパケットに対する応答の欠如によって駆動されます。 AAAの応答は前にウォッチドッグタイマの満了に受信されない負荷の軽いネットワークでは、攻撃者がウォッチドッグパケットがドロップさせる、ネットワークを圧倒することができます。これは、AAAクライアントは攻撃を繰り返すことができる別のAAAエージェント、に切り替えることになります。 AAAエージェント間のサイクルにAAAクライアントを引き起こすことによって、サービスは、ネットワークアクセスを希望するユーザーに拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where TLS [RFC2246] is being used to provide AAA security, there will be a vulnerability to spoofed reset packets, as well as other transport layer denial of service attacks (e.g. SYN flooding). Since SCTP offers improved denial of service resilience compared with TCP, where AAA applications run over SCTP, this can be mitigated to some extent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS [RFC2246]はAAAセキュリティを提供するために使用されている場合、リセットパケットを偽装する脆弱性、ならびにサービス攻撃（例えば、SYNフラッディング）の他のトランスポート層拒否が存在するであろう。 SCTPは、AAAのアプリケーションがSCTP上で実行するTCPと比較サービス回復力の改善拒否を提供していますので、これはある程度緩和することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where IPsec [RFC2401] is used to provide security, it is important that IPsec policy require IPsec on incoming packets. In order to enable a AAA client to determine what security mechanisms are in use on an agent or server without prior knowledge, it may be tempting to initiate a connection in the clear, and then to have the AAA agent respond with IKE [RFC2409]. While this approach minimizes required client configuration, it increases the vulnerability to denial of service attack, since a connection request can now not only tie up transport resources, but also resources within the IKE implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPsecの[RFC2401]は、セキュリティを提供するために使用される場合、IPsecポリシーが着信パケットにIPsecを必要とすることが重要です。セキュリティメカニズムは、事前知識なしエージェントまたはサーバー上で使用されているかを決定するためにAAAクライアントを有効にするためには、AAA剤はIKE [RFC2409]で応答有するように、クリアで接続を開始し、そしてするために魅力的であってもよいです。このアプローチは、必要なクライアント構成を最小限に抑えながら、それはIKE実装内の接続要求は、現在唯一のトランスポートリソースをタイアップすることができないため、サービス拒否攻撃に対する脆弱性を増加させるだけでなく、資源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document does not create any new number spaces for IANA administration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、IANAの投与のための任意の新しい番号のスペースを作成しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リファレンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC793]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC896] Nagle, J., &#34;Congestion Control in IP/TCP internetworks&#34;, RFC 896, January 1984.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC896]ネーグル、J.、 &#34;IP / TCPインターネットワークにおける輻輳制御&#34;、RFC 896、1984年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1750] Eastlake, D., Crocker, S. and J. Schiller, &#34;Randomness Recommendations for Security&#34;, RFC 1750, December 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1750]イーストレイク、D.、クロッカー、S.とJ.シラー、 &#34;セキュリティのためのランダム性に関する推奨事項&#34;、RFC 1750、1994年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S. and A. Romanow, &#34;TCP Selective Acknowledgment Options&#34;, RFC 2018, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.とA. Romanow、 &#34;TCPの選択確認応答オプション&#34;、RFC 2018、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2486] Aboba, B. and M. Beadles, &#34;The Network Access Identifier&#34;, RFC 2486, January 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2486] Aboba、B.及びM. Beadles、 &#34;ネットワークアクセス識別子&#34;、RFC 2486、1999年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2581] Allman, M., Paxson, V. and W. Stevens, &#34;TCP Congestion Control&#34;, RFC 2581, April 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2581]オールマン、M.、パクソン、V.とW.スティーブンス、 &#34;TCP輻輳制御&#34;、RFC 2581、1999年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., Podolsky, M. and A. Romanow, &#34;An Extension to the Selective Acknowledgment (SACK) Option for TCP&#34;, RFC 2883, July 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2883]フロイド、S.、Mahdavi、J.、マティス、M.、ポドルスキー、M.及びA. Romanow、 &#34;TCPのための選択的確認応答（SACK）オプションの拡張&#34;、RFC 2883、2000年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2960] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L. and V. Paxson, &#34;Stream Control Transmission Protocol&#34;, RFC 2960, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2960]スチュワート、R.、謝、Q.、Morneault、K.、シャープ、C.、Schwarzbauer、H.、テイラー、T.、Rytina、I.、カラ、M.、チャン、L.およびV.パクソン、 &#34;ストリーム制御伝送プロトコル&#34;、RFC 2960、2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2988] Paxson, V. and M. Allman, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 2988, November 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2988]パクソン、V.とM.オールマン、 &#34;コンピューティングTCPの再送信タイマー&#34;、RFC 2988、2000年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3042] Allman, M., Balakrishnan H. and S. Floyd, &#34;Enhancing TCP&#39;s Loss Recovery Using Limited Transmit&#34;, RFC 3042, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3042]オールマン、M.、バラクリシュナンH.とS.フロイド、 &#34;株式会社トランスミットを使用したTCPの損失回復の強化&#34;、RFC 3042、2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3074] Volz, B., Gonczi, S., Lemon, T. and R. Stevens, &#34;DHC Load Balancing Algorithm&#34;, RFC 3074, February 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3074]フォルツ、B.、Gonczi、S.、レモン、T.及びR.スティーブンス、 &#34;DHCロードバランシングアルゴリズム&#34;、RFC 3074、2001年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3124] Balakrishnan, H. and S. Seshan, &#34;The Congestion Manager&#34;, RFC 3124, June 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3124]バラクリシュナン、H.とS. Seshan、 &#34;輻輳管理&#34;、RFC 3124、2001年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2246] Dierks, T. and C. Allen, &#34;The TLS Protocol Version 1.0&#34;, RFC 2246, January 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2246]ダークス、T.とC.アレン、 &#34;TLSプロトコルバージョン1.0&#34;、RFC 2246、1999年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2401] Atkinson, R. and S. Kent, &#34;Security Architecture for the Internet Protocol&#34;, RFC 2401, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2401]アトキンソン、R.とS.ケント、「インターネットプロトコルのためのセキュリティー体系」、RFC2401、1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2409] Harkins, D. and D. Carrel, &#34;The Internet Key Exchange (IKE)&#34;, RFC 2409, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2409]ハーキンとD.とD.カレル、 &#34;インターネットキー交換（IKE）&#34;、RFC 2409、1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2607] Aboba, B. and J. Vollbrecht, &#34;Proxy Chaining and Policy Implementation in Roaming&#34;, RFC 2607, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2607] Aboba、B.、およびJ. Vollbrecht、 &#34;ローミング中のプロキシ連鎖とポリシー実装&#34;、RFC 2607、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2861] Handley, M., Padhye, J. and S. Floyd, &#34;TCP Congestion Window Validation&#34;, RFC 2861, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2861]ハンドレー、M.、Padhye、J.及びS.フロイド、 &#34;TCP輻輳ウィンドウ検証&#34;、RFC 2861、2000年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2865] Rigney, C., Willens, S., Rubens, A. and W. Simpson, &#34;Remote Authentication Dial In User Service (RADIUS)&#34;, RFC 2865, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2865] Rigney、C.、ウィレンス、S.、ルーベン、A.とW.シンプソン、RFC 2865、2000年6月 &#34;ユーザーサービス（RADIUS）でリモート認証ダイヤル&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2866] Rigney, C., &#34;RADIUS Accounting&#34;, RFC 2866, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2866] Rigney、C.、 &#34;RADIUSアカウンティング&#34;、RFC 2866、2000年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2914] Floyd, S., &#34;Congestion Control Principles&#34;, BCP 41, RFC 2914, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2914]フロイド、S.、 &#34;輻輳制御の原理&#34;、BCP 41、RFC 2914、2000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2975] Aboba, B., Arkko, J. and D. Harrington, &#34;Introduction to Accounting Management&#34;, RFC 2975, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2975] Aboba、B.、Arkko、J.とD.ハリントン、 &#34;会計管理の概要&#34;、RFC 2975、2000年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3390] Allman, M., Floyd, S. and C. Partridge, &#34;Increasing TCP&#39;s Initial Window&#34;, RFC 3390, October 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3390]オールマン、M.、フロイド、S.とC.ヤマウズラ、 &#34;増加するTCPの初期ウィンドウ&#34;、RFC 3390、2002年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Congest] Jacobson, V., &#34;Congestion Avoidance and Control&#34;, Computer Communication Review, vol. 18, no. 4, pp. 314-329, Aug. 1988. ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[混雑する]ジェーコブソン、V.、「輻輳回避とコントロール」、コンピュータコミュニケーションレビュー、巻。 18、ありません。 4、頁314から329 8月1988 ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Paxson] Paxson, V., &#34;Measurement and Analysis of End-to-End Internet Dynamics&#34;, Ph.D. Thesis, Computer Science Division, University of California, Berkeley, April 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[パクソン]パクソン、V.、「エンドツーエンドのインターネットダイナミクスの測定と分析」、博士論文、コンピュータサイエンス部門、カリフォルニア大学バークレー校、1997年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A - Detailed Watchdog Algorithm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A  - 詳細なウォッチドッグアルゴリズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this Appendix, the memory control structure that contains all information regarding a specific peer is referred to as a Peer Control Block, or PCB. The PCB contains the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録では、特定のピアに関する全ての情報を含むメモリ制御構造は、ピア制御ブロック、又はPCBと呼ばれます。 PCBは、次のフィールドがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status: OKAY: The connection is up SUSPECT: Failover has been initiated on the connection. DOWN: Connection has been closed. REOPEN: Attempting to reopen a closed connection INITIAL: The initial state of the pcb when it is first created. The pcb has never been opened.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステータス：OKAY：接続がSUSPECTアップです：フェールオーバーが接続上で開始されました。 DOWN：接続が閉じられています。 REOPEN：それが最初に作成されたとき、PCBの初期状態：クローズ接続INITIALを再開しようとしています。 PCBが開かれたことがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Variables: Pending: Set to TRUE if there is an outstanding unanswered watchdog request Tw: Watchdog timer value NumDWA: Number of DWAs received during REOPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変数：保留中：ウォッチドッグタイマ値NumDWA：卓越した未回答ウォッチドッグ要求Twが存在する場合にTRUEに設定しDWAsの数がREOPEN中に受信しました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tw is the watchdog timer, measured in seconds. Every second, Tw is decremented. When it reaches 0, the OnTimerElapsed event (see below) is invoked. Pseudo-code for the algorithm is included on the following pages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Twが秒単位で測定されたウォッチドッグタイマ、です。毎秒、Twが減算されます。それが0になると、OnTimerElapsedイベントが（下記参照）が呼び出されます。アルゴリズムの擬似コードは、以下のページに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   SetWatchdog()
   {
   /*
    SetWatchdog() is called whenever it is necessary
    to reset the watchdog timer Tw.  The value of the
    watchdog timer is calculated based on the default
    initial value TWINIT and a jitter ranging from
    -2 to 2 seconds.  The default for TWINIT is 30 seconds,
    and MUST NOT be set lower than 6 seconds.
   */
       Tw=TWINIT -2.0 + 4.0 * random() ;
       SetTimer(Tw) ;
       return ;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    OnReceive() is called whenever a message
    is received from the peer.  This message MAY
    be a request or an answer, and can include
    DWR and DWA messages.  Pending is assumed to
    be a global variable.
   */
   OnReceive(pcb, msgType)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   {
      if (msgType == DWA) {
           Pending = FALSE;
           }
      switch (pcb-&gt;Status){
      case OKAY:
           SetWatchdog();
           break;
      case SUSPECT:
           pcb-&gt;Status = OKAY;
           Failback(pcb);
           SetWatchdog();
           break;
      case REOPEN:
           if (msgType == DWA) {
              NumDWA++;
              if (NumDWA == 3) {
                 pcb-&gt;status = OKAY;
                 Failback();
              }
           } else {
              Throwaway(received packet);
           }
           break;
      case INITIAL:
      case DOWN:
           Throwaway(received packet);
           break;
      default:
           Error(&#34;Shouldn&#39;t be here!&#34;);
           break;
      }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
   OnTimerElapsed() is called whenever Tw reaches zero (0).
   */
   OnTimerElapsed(pcb)
   {
       switch (pcb-&gt;status){
          case OKAY:
             if (!Pending) {
                SendWatchdog(pcb);
                SetWatchdog();
                Pending = TRUE;
                break;
             }
             pcb-&gt;status = SUSPECT;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             FailOver(pcb);
             SetWatchdog();
             break ;
          case SUSPECT:
             pcb-&gt;status = DOWN;
             CloseConnection(pcb);
             SetWatchdog();
             break;
          case INITIAL:
          case DOWN:
             AttemptOpen(pcb);
             SetWatchdog();
             break;
          case REOPEN:
             if (!Pending) {
                SendWatchdog(pbc);
                SetWatchdog();
                Pending = TRUE;
                break;
             }
             if (NumDWA &lt; 0) {
                pcb-&gt;status = DOWN;
                CloseConnection(pcb);
             } else {
                NumDWA = -1;
             }
             SetWatchdog();
             break;
          default:
             error(&#34;Shouldn&#39;t be here!);
             break;
          }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
   OnConnectionUp() is called whenever a connection comes up
   */
   OnConnectionUp(pcb)
   {
       switch (pcb-&gt;status){
          case INITIAL:
             pcb-&gt;status = OKAY;
             SetWatchdog();
             break;
          case DOWN:
             pcb-&gt;status = REOPEN;
             NumDWA = 0;
             SendWatchdog(pcb);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             SetWatchdog();
             Pending = TRUE;
             break;
          default:
             error(&#34;Shouldn&#39;t be here!);
             break;
          }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
   OnConnectionDown() is called whenever a connection goes down
   */
   OnConnectionDown(pcb)
   {
       pcb-&gt;status = DOWN;
       CloseConnection();
       switch (pcb-&gt;status){
          case OKAY:
             Failover(pcb);
             SetWatchdog();
             break;
          case SUSPECT:
          case REOPEN:
             SetWatchdog();
             break;
          default:
             error(&#34;Shouldn&#39;t be here!);
             break;
          }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*  Here is the state machine equivalent to the above code:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   STATE         Event                Actions              New State
   =====         ------               -------              ----------
   OKAY          Receive DWA          Pending = FALSE
                                      SetWatchdog()        OKAY
   OKAY          Receive non-DWA      SetWatchdog()        OKAY
   SUSPECT       Receive DWA          Pending = FALSE
                                      Failback()
                                      SetWatchdog()        OKAY
   SUSPECT       Receive non-DWA      Failback()
                                      SetWatchdog()        OKAY
   REOPEN        Receive DWA &amp;        Pending = FALSE
                 NumDWA == 2          NumDWA++
                                      Failback()           OKAY
   REOPEN        Receive DWA &amp;        Pending = FALSE
                 NumDWA &lt; 2           NumDWA++             REOPEN
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   STATE         Event                Actions              New State
   =====         ------               -------              ----------
   REOPEN        Receive non-DWA      Throwaway()          REOPEN
   INITIAL       Receive DWA          Pending = FALSE
                                      Throwaway()          INITIAL
   INITIAL       Receive non-DWA      Throwaway()          INITIAL
   DOWN          Receive DWA          Pending = FALSE
                                      Throwaway()          DOWN
   DOWN          Receive non-DWA      Throwaway()          DOWN
   OKAY          Timer expires &amp;      SendWatchdog()
                 !Pending             SetWatchdog()
                                      Pending = TRUE       OKAY
   OKAY          Timer expires &amp;      Failover()
                 Pending              SetWatchdog()        SUSPECT
   SUSPECT       Timer expires        CloseConnection()
                                      SetWatchdog()        DOWN
   INITIAL       Timer expires        AttemptOpen()
                                      SetWatchdog()        INITIAL
   DOWN          Timer expires        AttemptOpen()
                                      SetWatchdog()        DOWN
   REOPEN        Timer expires &amp;      SendWatchdog()
                 !Pending             SetWatchdog()
                                      Pending = TRUE       REOPEN
   REOPEN        Timer expires &amp;      CloseConnection()
                 Pending &amp;            SetWatchdog()
                 NumDWA &lt; 0                                DOWN
   REOPEN        Timer expires &amp;      NumDWA = -1
                 Pending &amp;            SetWatchdog()
                 NumDWA &gt;= 0                               REOPEN
   INITIAL       Connection up        SetWatchdog()        OKAY
   DOWN          Connection up        NumDWA = 0
                                      SendWatchdog()
                                      SetWatchdog()
                                      Pending = TRUE       REOPEN
   OKAY          Connection down      CloseConnection()
                                      Failover()
                                      SetWatchdog()        DOWN
   SUSPECT       Connection down      CloseConnection()
                                      SetWatchdog()        DOWN
   REOPEN        Connection down      CloseConnection()
                                      SetWatchdog()        DOWN
   */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B - AAA Agents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録B  -  AAAエージェント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described in [RFC2865] and [RFC2607], AAA agents have become popular in order to support services such as roaming and shared use networks. Such agents are used both for authentication/authorization, as well as accounting [RFC2975].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2865]及び[RFC2607]に記載されているように、AAA剤は、ローミングなどのサービスと共用ネットワークをサポートするために普及しています。このような薬剤は、両方の認証/許可、ならびにアカウンティング[RFC2975]のために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA agents include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAのエージェントは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Relays Proxies Re-directs Store and Forward proxies Transport layer proxies
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リレープロキシストア＆フォワードプロキシトランスポート層プロキシを再指示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The transport layer behavior of each of these agents is described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの薬剤のそれぞれのトランスポート層の動作について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1 Relays and Proxies
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1リレーおよびプロキシ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the application-layer behavior of relays and proxies are different, at the transport layer the behavior is similar. In both cases, two connections are established: one from the AAA client (NAS) to the relay/proxy, and another from the relay/proxy to the AAA server. The relay/proxy does not respond to a client request until it receives a response from the server. Since the two connections are de-coupled, the end-to-end conversation between the client and server may not self clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リレーやプロキシのアプリケーション層の動作が異なっているが、トランスポート層で動作も同様です。中継/プロキシにAAAクライアント（NAS）からの1つを、およびAAAサーバに中継/プロキシから別の：両方の場合において、2つの接続が確立されています。それはサーバからの応答を受信するまでリレー/プロキシは、クライアントの要求に応答しません。 2つの接続が切り離されているので、クライアントとサーバ間のエンドツーエンドの会話は、自己のクロックではないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since AAA transport is typically application-driven, there is frequently not enough traffic to enable ACK piggybacking. As a result, the Nagle algorithm is rarely triggered, and delayed ACKs may comprise nearly half the traffic. Thus AAA protocols running over reliable transport will see packet traffic nearly double that experienced with UDP transport. Since ACK parameters (such as the value of the delayed ACK timer) are typically fixed by the TCP implementation and are not tunable by the application, there is little that can be done about this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAAの輸送は、通常、アプリケーション主導型であるため、ACKのピギーバックを可能にするために十分なトラフィックが頻繁にありません。その結果、Nagleアルゴリズムはほとんど誘発されず、ACKがほぼ半分のトラフィックを含んでいてもよい遅れています。したがって、信頼性の高いトランスポート上で実行されているAAAプロトコルはUDP輸送で経験ほぼ倍増パケットトラフィックが表示されます。 （例えば、遅延ACKタイマの値など）ACKパラメータは、典型的には、TCPの実装によって固定され、アプリケーションによって調整可能ていないので、これについて行うことができ、そのほとんどがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A typical trace of a conversation between a NAS, proxy and server is shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NAS、プロキシとサーバの間の会話の代表的トレースを以下に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Time            NAS           Relay/Proxy           Server
   ------          ---           -----------           ------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   0               Request
                   -------&gt;
   OTTnp + Tpr                     Request
                                   -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + TdA                     Delayed ACK
                                   &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTps +                                 Reply/ACK
   Tpr + Tsr                                       &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTps +
   Tpr + Tsr +                     Reply
   OTTsp + TpR                     &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTps +
   Tpr + Tsr +                     Delayed ACK
   OTTsp + TdA                     -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTps +
   OTTsp + OTTpn +
   Tpr + Tsr +      Delayed ACK
   TpR + TdA        -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Key
   ---
   OTT   = One-way Trip Time
   OTTnp = One-way trip time (NAS to Relay/Proxy)
   OTTpn = One-way trip time (Relay/Proxy to NAS)
   OTTps = One-way trip time (Relay/Proxy to Server)
   OTTsp = One-way trip time (Server to Relay/Proxy)
   TdA   = Delayed ACK timer
   Tpr   = Relay/Proxy request processing time
   TpR   = Relay/Proxy reply processing time
   Tsr   = Server request processing time
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At time 0, the NAS sends a request to the relay/proxy. Ignoring the serialization time, the request arrives at the relay/proxy at time OTTnp, and the relay/proxy takes an additional Tpr in order to forward the request toward the home server. At time TdA after receiving the request, the relay/proxy sends a delayed ACK. The delayed ACK is sent, rather than being piggybacked on the reply, as long as TdA &lt; OTTps + OTTsp + Tpr + Tsr + TpR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時間0で、NASは、リレー/プロキシにリクエストを送信します。シリアル化の時間を無視して、要求が時間OTTnpでリレー/プロキシに到着し、リレー/プロキシは、ホームサーバーに向けて要求を転送するために追加Tprのを取ります。当時TDAは、要求を受信した後、リレー/プロキシは、遅延ACKを送信します。遅延ACKをTDA &lt;OTTps + OTTsp + Tprの+ Tsrの+ TPR限り、むしろ応答にピギーバックされるよりも、送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Typically Tpr &lt; TdA, so that the delayed ACK is sent after the relay/proxy forwards the request toward the server, but before the relay/proxy receives the reply from the server. However, depending on the TCP implementation on the relay/proxy and when the request is received, it is also possible for the delayed ACK to be sent prior to forwarding the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
典型的にはTprの&lt;TDA、中継/プロキシがサーバに向けて要求を転送した後、しかし中継/プロキシサーバから応答を受信する前に、遅延されたACKが送信されるようになっています。しかし、TCP中継/プロキシに実装し、要求を受信した場合、また、遅延されたACK要求を転送する前に送信することが可能であるに応じ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At time OTTnp + OTTps + Tpr, the server receives the request, and Tsr later, it generates the reply. Where Tsr &lt; TdA, the reply will contain a piggybacked ACK. However, depending on the server responsiveness and TCP implementation, the ACK and reply may be sent separately. This can occur, for example, where a slow database or storage system must be accessed prior to sending the reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時間OTTnp + OTTps + Tprので、サーバは要求を受信し、TSRは、後に、それが応答を生成します。どこTsrの&lt;TDAは、返信がピギーバックACKが含まれています。ただし、サーバーの応答性とTCPの実装に依存し、ACKと応答が別々に送信することができます。これは、遅いデータベース又はストレージシステムが応答を送信する前にアクセスする必要があり、例えば、のために、起こり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At time OTTnp + OTTps + OTTsp + Tpr + Tsr the reply/ACK reaches the relay/proxy, which then takes TpR additional time to forward the reply to the NAS. At TdA after receiving the reply, the relay/proxy generates a delayed ACK. Typically TpR &lt; TdA so that the delayed ACK is sent to the server after the relay/proxy forwards the reply to the NAS. However, depending on the circumstances and the relay/proxy TCP implementation, the delayed ACK may be sent first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時間OTTnp + OTTps + OTTsp + Tprの+ Tsrのに応答/ ACKは、次に、NASへの応答を転送するTPR追加の時間がかかる中継/プロキシに到達します。 TDAで返信を受け取った後、リレー/プロキシは、遅延ACKを生成します。典型的には、TPR &lt;TDA中継/プロキシがNASに応答を転送した後に遅延ACKをサーバに送信されるようになっています。しかし、状況及び中継/プロキシTCPの実装に応じて、遅延ACKが最初に送信されても​​よいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As with a delayed ACK sent in response to a request, which may be piggybacked if the reply can be received quickly enough, piggybacking of the ACK sent in response to a reply from the server is only possible if additional request traffic is available. However, due to the high inter-packet spacings in typical AAA scenarios, this is unlikely unless the AAA protocol supports a reply ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答がサーバからの応答に応じて送信されるACKのピギーバック、十分に迅速に受信することができるならば、ピギーバックすることができるの要求に応答して送信遅延ACKと同様に、追加の要求トラフィックが利用可能な場合にのみ可能です。 AAAプロトコルが応答ACKをサポートしていない限り、しかし、典型的なAAAのシナリオで高いパケット間の間隔に起因し、これはほとんどありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At time OTTnp + OTTps + OTTsp + OTTpn + Tpr + Tsr + TpR the NAS receives the reply. TdA later, a delayed ACK is generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
当時OTTnp + OTTps + OTTsp + OTTpn + Tprの+ Tsrの+ TPR NASは、応答を受信します。 TDA後に、遅延ACKが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2 Re-directs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2リダイレクト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Re-directs operate by referring a NAS to the AAA server, enabling the NAS to talk to the AAA server directly. Since a direct transport connection is established, the end-to-end connection will self-clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再指示直接AAAサーバと通信するためにNASを可能にする、AAAサーバにNASを参照することによって動作します。直接トランスポート接続が確立されているため、エンド・ツー・エンドの接続は、自己クロックなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With re-directs, delayed ACKs are less frequent than with application-layer proxies since the Re-direct and Server will typically piggyback replies with ACKs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再指示で再直接およびサーバは、典型的には、ACKを用いて応答をピギーバックするので、遅延ACKはアプリケーション層プロキシよりも少ない頻度です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sequence of events is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにイベントの順序は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Time            NAS             Re-direct       Server
   ------          ---             ---------       ------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   0               Request
                   -------&gt;
   OTTnp + Tpr                     Redirect/ACK
                                   &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + Tpr +   Request
   OTTpn + Tnr     -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTpn +
   Tpr + Tsr +                                     Reply/ACK
   OTTns                                           &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTpn +
   OTTns + OTTsn +
   Tpr + Tsr +      Delayed ACK
   TdA              -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Key
   ---
   OTT   = One-way Trip Time
   OTTnp = One-way trip time (NAS to Re-direct)
   OTTpn = One-way trip time (Re-direct to NAS)
   OTTns = One-way trip time (NAS to Server)
   OTTsn = One-way trip time (Server to NAS)
   TdA   = Delayed ACK timer
   Tpr   = Re-direct processing time
   Tnr   = NAS re-direct processing time
   Tsr   = Server request processing time
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3 Store and Forward Proxies
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3ストア＆フォワードプロキシ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With a store and forward proxy, the proxy may send a reply to the NAS prior to forwarding the request to the server. While store and forward proxies are most frequently deployed for accounting [RFC2975], they also can be used to implement authentication/authorization policy, as described in [RFC2607].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ストアアンドフォワードプロキシでは、プロキシサーバに要求を転送するためにNAS前に応答を送信してもよいです。ストアアンドフォワードプロキシが最も頻繁に[RFC2975]を占めるために展開されますが、[RFC2607]で説明したように、彼らはまた、認証/認可ポリシーを実装するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As noted in [RFC2975], store and forward proxies can have a negative effect on accounting reliability. By sending a reply to the NAS without receiving one from the accounting server, store and forward proxies fool the NAS into thinking that the accounting request had been accepted by the accounting server when this is not the case. As a result, the NAS can delete the accounting packet from non-volatile storage before it has been accepted by the accounting server. That leaves the proxy responsible for delivering accounting packets. If the proxy involves moving parts (e.g. a disk drive) while the NAS does not, overall system reliability can be reduced. As a result, store and forward proxies SHOULD NOT be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2975]で述べたように、ストアアンドフォワードプロキシは、会計の信頼性に悪影響を与えることができます。会計上のサーバから1つを受信することなく、NASへの応答を送信することにより、ストアアンドフォワードプロキシそうでないときアカウンティング要求は、アカウンティングサーバによって受け入れられていたことを考えることにNASをだまします。それはアカウンティングサーバによって承認された前の結果、NASは、不揮発性ストレージから会計パケットを削除することができます。これはアカウンティングパケットを提供するための責任プロキシを残します。プロキシ部品（例えば、ディスクドライブ）を移動させることを含む場合NASはないが、システム全体の信頼性を低減させることができます。その結果、ストアアンドフォワードプロキシを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sequence of events is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにイベントの順序は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Time            NAS             Proxy           Server
   ------          ---             -----           ------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   0               Request
                   -------&gt;
   OTTnp + TpR                     Reply/ACK
                                   &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + Tpr                     Request
                                   -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTph +                                 Reply/ACK
   Tpr + Tsr                                       &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTph +
   Tpr + Tsr +                     Reply
   OTThp + TpR                     &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTph +
   Tpr + Tsr +                     Delayed ACK
   OTThp + TdA                     -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTph +
   OTThp + OTTpn +
   Tpr + Tsr +      Delayed ACK
   TpR + TdA        -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Key
   ---
   OTT   = One-way Trip Time
   OTTnp = One-way trip time (NAS to Proxy)
   OTTpn = One-way trip time (Proxy to NAS)
   OTTph = One-way trip time (Proxy to Home server)
   OTThp = One-way trip time (Home Server to Proxy)
   TdA   = Delayed ACK timer
   Tpr   = Proxy request processing time
   TpR   = Proxy reply processing time
   Tsr   = Server request processing time
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.4 Transport Layer Proxies
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.4トランスポート層プロキシ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to acting as proxies at the application layer, transport layer proxies forward transport ACKs between the AAA client and server. This splices together the client-proxy and proxy-server connections into a single connection that behaves as though it operates end-to-end, exhibiting self-clocking. However, since transport proxies operate at the transport layer, they cannot be implemented purely as applications and they are rarely deployed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション層でのプロキシとして機能に加えて、トランスポート層のプロキシAAAクライアントとサーバ間の順方向輸送のACK。これは、自己クロッキングを呈する、エンドツーエンドを運営しているかのように振る舞う単一の接続にクライアントプロキシおよびプロキシ・サーバー接続を一緒にスプライス。トランスポート・プロキシは、トランスポート層で動作するのでしかし、彼らは、アプリケーションとして、純粋に実装することはできませんし、彼らはほとんど導入されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With a transport proxy, the sequence of events is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにトランスポート・プロキシを使用すると、一連のイベントは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Time            NAS             Proxy           Home Server
   ------          ---             -----           -----------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   0               Request
                   -------&gt;
   OTTnp + Tpr                     Request
                                   -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTph +                                 Reply/ACK
   Tpr + Tsr                                       &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTph +
   Tpr + Tsr +                     Reply/ACK
   OTThp + TpR                     &lt;-------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTph +
   OTThp + OTTpn +
   Tpr + Tsr +      Delayed ACK
   TpR + TdA        -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   OTTnp + OTTph +
   OTThp + OTTpn +
   Tpr + Tsr +                     Delayed ACK
   TpR + TpD                       -------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Key
   ---
   OTT   = One-way Trip Time
   OTTnp = One-way trip time (NAS to Proxy)
   OTTpn = One-way trip time (Proxy to NAS)
   OTTph = One-way trip time (Proxy to Home server)
   OTThp = One-way trip time (Home Server to Proxy)
   TdA   = Delayed ACK timer
   Tpr   = Proxy request processing time
   TpR   = Proxy reply processing time
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tsr = Server request processing time TpD = Proxy delayed ack processing time
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TSR =サーバー要求処理時間TPD =プロキシは、ACK処理時間を遅らせ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Intellectual Property Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
知的財産に関する声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on the IETF&#39;s procedures with respect to rights in standards-track and standards-related documentation can be found in BCP-11. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementors or users of this specification can be obtained from the IETF Secretariat.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、そのような権限下で、ライセンスがたりないかもしれない可能性があるためにどの本書または程度に記載されている技術の実装や使用に関係すると主張される可能性があります任意の知的財産やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能。また、そうした権利を特定するために取り組んできたことを表していないん。スタンダードトラックおよび標準関連文書における権利に関するIETFの手続きの情報は、BCP-11に記載されています。権利の主張のコピーは、出版のために利用可能とライセンスの保証が利用できるようにする、または本仕様の実装者または利用者が、そのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますIETF事務局から。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to practice this standard. Please address the information to the IETF Executive Director.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、その注意にこの標準を実践するために必要な場合があり技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 IETF専務に情​​報を扱ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thanks to Allison Mankin of AT&amp;T, Barney Wolff of Databus, Steve Rich of Cisco, Randy Bush of AT&amp;T, Bo Landarv of IP Unplugged, Jari Arkko of Ericsson, and Pat Calhoun of Blackstorm Networks for fruitful discussions relating to AAA transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AAA輸送に関する実りある議論のためのAT＆Tのアリソンマンキン、データバスのバーニー・ウルフ、シスコのスティーブ・リッチ、AT＆Tのランディブッシュ、IPアンプラグドのボーLandarv、エリクソンのヤリArkko、およびBlackstormネットワークのパットカルフーンに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bernard Aboba Microsoft Corporation One Microsoft Way Redmond, WA 98052
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バーナードAbobaマイクロソフト社1マイクロソフト道、レッドモンド、ワシントン98052
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 425 706 6605 Fax: +1 425 936 7329 EMail: bernarda@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 425 706 6605ファックス：+1 425 936 7329 Eメール：bernarda@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jonathan Wood Sun Microsystems, Inc. 901 San Antonio Road Palo Alto, CA 94303
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジョナサン・ウッドサン・マイクロシステムズ株式会社901サンアントニオの道パロアルト、CA 94303
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: jonwood@speakeasy.net
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：jonwood@speakeasy.net
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
