<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7046 - A Common API for Transparent Hybrid Multicast 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7046 - A Common API for Transparent Hybrid Multicast 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7046">
              https://tools.ietf.org/html/rfc7046
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7046 - 透明ハイブリッドマルチキャストのための共通API</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Research Task Force (IRTF)                         M. Waehlisch
Request for Comments: 7046                          link-lab &amp; FU Berlin
Category: Experimental                                        T. Schmidt
ISSN: 2070-1721                                              HAW Hamburg
                                                               S. Venaas
                                                           Cisco Systems
                                                           December 2013
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             A Common API for Transparent Hybrid Multicast
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Group communication services exist in a large variety of flavors and technical implementations at different protocol layers. Multicast data distribution is most efficiently performed on the lowest available layer, but a heterogeneous deployment status of multicast technologies throughout the Internet requires an adaptive service binding at runtime. Today, it is difficult to write an application that runs everywhere and at the same time makes use of the most efficient multicast service available in the network. Facing robustness requirements, developers are frequently forced to use a stable upper-layer protocol provided by the application itself. This document describes a common multicast API that is suitable for transparent communication in underlay and overlay and that grants access to the different flavors of multicast. It proposes an abstract naming scheme that uses multicast URIs, and it discusses mapping mechanisms between different namespaces and distribution technologies. Additionally, this document describes the application of this API for building gateways that interconnect current Multicast Domains throughout the Internet. It reports on an implementation of the programming Interface, including service middleware. This document is a product of the Scalable Adaptive Multicast (SAM) Research Group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ通信サービスは、異なるプロトコル層におけるフレーバーおよび技術の実装の多種多様に存在します。マルチキャストデータ配信は、最も効率的に利用可能な最低層で実行されますが、インターネットを通じてマルチキャスト技術の異機種間の配置状況は、実行時にバインディング適応サービスを必要とします。今日、どこでも動作するアプリケーションを記述することは困難であると同時に、ネットワークで利用可能な最も効率的なマルチキャストサービスを利用します。ロバスト性の要件に直面して、開発者はしばしば、アプリケーション自体によって提供される安定した上位層プロトコルを使用することを余儀なくされています。この文書では、アンダーレイとオーバーレイに透明の通信に適しており、それは、マルチキャストの異なる味へのアクセスを許可する一般的なマルチキャストAPIについて説明します。これは、マルチキャストのURIを使用して、抽象命名方式を提案し、それは別の名前空間と配布技術との間のマッピングの仕組みについて説明します。また、この文書は、インターネットを通じて、現在のマルチキャストドメインを相互接続するゲートウェイを構築するため、このAPIのアプリケーションを記述しています。これは、サービスミドルウェアを含む、プログラミングインタフェースの実装について報告します。この文書では、スケーラブルアダプティブマルチキャスト（SAM）研究グループの製品です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Scalable Adaptive Multicast Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットリサーチタスクフォースのスケーラブル適応マルチキャスト研究グループ（IRTF）のコンセンサスを表しています。 IRSGによって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7046.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7046で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................4
      1.1. Use Cases for the Common API ...............................6
      1.2. Illustrative Examples ......................................7
           1.2.1. Support of Multiple Underlying Technologies .........7
           1.2.2. Support of Multi-Resolution Multicast ...............9
   2. Terminology ....................................................10
   3. Overview .......................................................10
      3.1. Objectives and Reference Scenarios ........................10
      3.2. Group Communication API and Protocol Stack ................12
      3.3. Naming and Addressing .....................................14
      3.4. Namespaces ................................................15
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      3.5. Name-to-Address Mapping ...................................15
           3.5.1. Canonical Mapping ..................................16
           3.5.2. Mapping at End Points ..............................16
           3.5.3. Mapping at Inter-Domain Multicast Gateways .........16
      3.6. A Note on Explicit Multicast (Xcast) ......................16
      3.7. MTU Handling ..............................................17
   4. Common Multicast API ...........................................18
      4.1. Notation ..................................................18
      4.2. URI Scheme Definition .....................................18
           4.2.1. Syntax .............................................18
           4.2.2. Semantic ...........................................19
           4.2.3. Generic Namespaces .................................20
           4.2.4. Application-Centric Namespaces .....................20
           4.2.5. Future Namespaces ..................................20
      4.3. Additional Abstract Data Types ............................21
           4.3.1. Interface ..........................................21
           4.3.2. Membership Events ..................................21
      4.4. Group Management Calls ....................................22
           4.4.1. Create .............................................22
           4.4.2. Delete .............................................22
           4.4.3. Join ...............................................22
           4.4.4. Leave ..............................................23
           4.4.5. Source Register ....................................23
           4.4.6. Source Deregister ..................................23
      4.5. Send and Receive Calls ....................................24
           4.5.1. Send ...............................................24
           4.5.2. Receive ............................................24
      4.6. Socket Options ............................................25
           4.6.1. Get Interfaces .....................................25
           4.6.2. Add Interface ......................................25
           4.6.3. Delete Interface ...................................26
           4.6.4. Set TTL ............................................26
           4.6.5. Get TTL ............................................26
           4.6.6. Atomic Message Size ................................27
      4.7. Service Calls .............................................27
           4.7.1. Group Set ..........................................27
           4.7.2. Neighbor Set .......................................28
           4.7.3. Children Set .......................................28
           4.7.4. Parent Set .........................................28
           4.7.5. Designated Host ....................................29
           4.7.6. Enable Membership Events ...........................29
           4.7.7. Disable Membership Events ..........................30
           4.7.8. Maximum Message Size ...............................30
   5. Implementation .................................................30
   6. IANA Considerations ............................................30
   7. Security Considerations ........................................31
   8. Acknowledgements ...............................................31
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   9. References .....................................................32
      9.1. Normative References ......................................32
      9.2. Informative References ....................................33
   Appendix A. C Signatures ..........................................35
   Appendix B. Use Case for the API ..................................37
   Appendix C. Deployment Use Cases for Hybrid Multicast .............38
     C.1. DVMRP ......................................................38
     C.2. PIM-SM .....................................................38
     C.3. PIM-SSM ....................................................39
     C.4. BIDIR-PIM ..................................................40
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Currently, group application programmers need to choose the distribution technology that the application will require at runtime. There is no common communication Interface that abstracts multicast transmission and subscriptions from the deployment state at runtime, nor has the use of DNS for Group Addresses been established. The standard multicast socket options [RFC3493] [RFC3678] are bound to an IP version by not distinguishing between the naming and addressing of multicast identifiers. Group communication, however,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在、グループのアプリケーションプログラマは、アプリケーションが実行時に必要となる配信技術を選択する必要があります。実行時に展開状態からマルチキャスト伝送とサブスクリプションを抽象化し、また確立されたグループアドレスのためのDNSの使用を持っている共通の通信インターフェースはありません。標準のマルチキャストソケットオプション[RFC3493] [RFC3678]は、ネーミングを区別し、マルチキャスト識別子のアドレッシングないでIPバージョンにバインドされています。グループ通信は、しかし、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o is commonly implemented in different flavors, such as any-source multicast (ASM) vs. source-specific multicast (SSM),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oは、一般に、そのような任意のソースのマルチキャストソース固有マルチキャスト対（ASM）（SSM）のように、異なる風味で実装されて
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o is commonly implemented on different layers (e.g., IP vs. application-layer multicast), and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oは、一般的に異なる層（例えば、IPアプリケーションレイヤマルチキャスト対）上に実装され、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o may be based on different technologies on the same tier, as seen with IPv4 vs. IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPv6の対のIPv4で見られるように、O、同じ層上の異なる技術に基づくことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The objective of this document is to provide for programmers a universal access to group services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの目的は、プログラマのためのグループサービスへの普遍的なアクセスを提供することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast application development should be decoupled from technological deployment throughout the infrastructure. It requires a common multicast API that offers calls to transmit and receive multicast data independent of the supporting layer and the underlying technological details. For inter-technology transmissions, a consistent view of multicast states is needed as well. This document describes an abstract group communication API and core functions necessary for transparent operations. Specific implementation guidelines with respect to operating systems or programming languages are out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストアプリケーションの開発は、インフラストラクチャ全体の技術の展開からデカップリングする必要があります。これは、支持層とその下にある技術的な詳細のマルチキャストデータの独立を送受信するための呼び出しを提供しています一般的なマルチキャストAPIが必要です。技術間の送信では、マルチキャスト状態の一貫したビューも同様に必要とされています。この文書では、透明動作に必要な抽象グループ通信APIとコア機能について説明します。オペレーティングシステムやプログラミング言語についての具体的な実施ガイドラインは、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In contrast to the standard multicast socket Interface, the API introduced in this document abstracts naming from addressing. Using a multicast address in the current socket API predefines the corresponding routing layer. In this specification, the multicast name used for joining a group denotes an application-layer data stream that is identified by a multicast URI, independent of its binding to a specific distribution technology. Such a Group Name can be mapped to variable routing identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
標準のマルチキャストソケットインタフェースとは対照的に、APIは、アドレッシングから命名本書の抄録で導入します。現在のソケットAPIのマルチキャストアドレスを使用して、対応するルーティング層をあらかじめ定義します。本明細書では、グループに参加するために使用されるマルチキャスト名前は、その特定の配信技術への結合から独立してマルチキャストURIによって識別されるアプリケーション層のデータストリームを表します。このようなグループ名は、変数ルーティング識別子にマッピングすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The aim of this common API is twofold:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この共通APIの目的は2つあり：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Enable any application programmer to implement group-oriented data communication independent of the underlying delivery mechanisms. In particular, allow for a late binding of group applications to multicast technologies that makes applications efficient but robust with respect to deployment aspects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O基礎となる配信メカニズムのグループ指向データ通信独立を実装する任意のアプリケーション・プログラマを有効にします。具体的には、展開面に関してアプリケーションが効率的でなく、堅牢にマルチキャスト技術へのグループのアプリケーションの遅延バインディングを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Allow for flexible namespace support in group addressing and thereby separate naming and addressing (or routing) schemes from the application design. This abstraction not only decouples programs from specific aspects of underlying protocols but may open application design to extend to specifically flavored group services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oアプリケーションの設計からアドレッシンググループ可撓性名前空間のサポートを可能にし、それによって別個の命名およびアドレッシング（またはルーティング）方式。この抽象化は、基礎となるプロトコルの特定の側面からプログラムを切り離すが、特に味のするグループサービスを拡張するためのアプリケーションの設計を開くことができないだけ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast technologies may be of various peer-to-peer kinds, IPv4 or IPv6 network-layer multicast, or implemented by some other application service. Corresponding namespaces may be IP addresses or DNS naming, overlay hashes, or other application-layer group identifiers like &lt;sip:*@peanuts.org&gt;, but they can also be names independently defined by the applications. Common namespaces are introduced later in this document but follow an open concept suitable for further extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャスト技術は、様々なピア・ツー・ピアの種類、IPv4またはIPv6ネットワークレイヤマルチキャストであること、またはいくつかの他のアプリケーションサービスによって実現してもよいです。対応する名前空間は次のようにIPアドレスやDNSの名前付け、オーバーレイハッシュ、または他のアプリケーション層のグループ識別子であってもよい。&lt;SIP：* @ peanuts.org&gt;、彼らはまた、独立したアプリケーションによって定義された名前することができます。一般的な名前空間は、このドキュメントの導入が、さらなる拡張に適したオープンコンセプトに従っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document also discusses mapping mechanisms between different namespaces and forwarding technologies and proposes expressions of defaults for an intended binding. Additionally, the multicast API provides internal Interfaces to access current multicast states at the host. Multiple multicast protocols may run in parallel on a single host. These protocols may interact to provide a gateway function that bridges data between different domains. The usage of this API at gateways operating between current multicast instances throughout the Internet is described as well. Finally, a report on an implementation of the programming Interface, including service middleware, is presented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書はまた、異なる名前空間と転送技術との間のマッピングメカニズムを説明し、意図的な結合のためのデフォルトの式を提案しています。また、マルチキャストAPIは、ホストで現在のマルチキャストの状態にアクセスするための内部インタフェースを提供します。複数のマルチキャストプロトコルは、単一のホスト上で並列に実行することができます。これらのプロトコルは、異なるドメイン間でデータをブリッジゲートウェイ機能を提供するように相互作用することができます。インターネットを通じて現在のマルチキャストのインスタンス間で動作するゲートウェイでこのAPIの利用も同様に記述されています。最後に、サービスミドルウェアを含む、プログラミングインタフェースの実装に関する報告書は、提示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document represents the consensus of the SAM Research Group. It has been reviewed by the Research Group members active in the specific area of work. In addition, this document has been comprehensively reviewed by people who are not &#34;in&#34; the Research Group but are experts in the area.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、SAM研究グループのコンセンサスを表しています。それは仕事の特定の領域に積極的に研究グループのメンバーによって検討されています。また、この文書は包括研究グループ「に」ありませんが、エリア内の専門家である人々によって検討されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Use Cases for the Common API
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。共通APIの使用例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following generic use cases can be identified; these use cases require an abstract common API for multicast services:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の一般的なユースケースを識別することができます。これらのユースケースは、マルチキャストサービスのための抽象共通APIが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Application Programming Independent of Technologies: Application programmers are provided with group primitives that remain independent of multicast technologies and their deployment in target domains. Thus, for a given application, they can develop a program that will run in every deployment scenario. The use of Group Names in the form of abstract metadata types allows applications to remain namespace-agnostic in the sense that the resolution of namespaces and name-to-address mappings may be delegated to a system service at runtime. Complexity is thereby minimized, as developers need not care about how data is distributed in groups, while the system service can take advantage of extended information of the network environment as acquired at startup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Technologies社のアプリケーション・プログラミング・独立：アプリケーションプログラマは、マルチキャスト技術とターゲットドメインでの展開とは独立したままグループプリミティブが設けられています。このように、与えられたアプリケーションのために、彼らはすべての展開シナリオで実行するプログラムを開発することができます。抽象メタデータ型の形式でグループ名を使用すると、アプリケーションが名前空間と名前とアドレスのマッピングの解像度は、実行時にシステムサービスに委任することができるという意味で、名前空間に依存しないままにすることができます。開発者は、データがグループにどのように分配されるかを気にする必要はないと起動時に取得したシステムサービスは、ネットワーク環境の拡張情報を活用することができますしながら、複雑さは、それによって、最小化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Global Identification of Groups: Groups can be identified independent of technological instantiations and beyond deployment domains. Taking advantage of the abstract naming, an application can thus match data received from different Interface technologies (e.g., IPv4, IPv6, and overlays) to belong to the same group. This not only increases flexibility -- an application may, for instance, combine heterogeneous multipath streams -- but also simplifies the design and implementation of gateways.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グローバルグループの同定：グループは、技術インスタンスのと展開のドメインを越えた独立した識別することができます。抽象命名を利用して、このようにデータを一致させることができ、アプリケーションは、同じグループに属するように異なるインタフェース技術（例えば、IPv4の、IPv6、およびオーバーレイ）から受け取りました。アプリケーションは、例えば、異種のマルチストリームを組み合わせることができる -   - これは、柔軟性を増加させるだけでなく、ゲートウェイの設計と実装を簡素化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Uniform Access to Multicast Flavors: The URI naming scheme uniformly supports different flavors of group communication, such as any-source multicast and source-specific multicast, and selective broadcast, independent of their service instantiation. The traditional SSM model, for instance, can experience manifold support by directly mapping the multicast URI (i.e., &#34;group@instantiation&#34;) to an (S,G) state on the IP layer, by first resolving S for a subsequent Group Address query, by transferring this process to any of the various source-specific overlay schemes, or by delegating to a plain replication server. The application programmer can invoke any of these underlying mechanisms with the same line of code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストフレーバーへの均一なアクセス：URIの命名方式は一様に、このような彼らのサービスのインスタンス化とは無関係に任意のソースのマルチキャストおよびソース固有のマルチキャスト、および選択放送などのグループ通信の異なる味を、サポートしています。従来のSSMモデルは、例えば、最初に、後続のグループアドレスの問い合わせのためのSを解決することによって、直接IP層の上に（S、G）状態にマルチキャストURI（すなわち、「グループ@のインスタンス化」）をマッピングすることにより、マニホールドのサポートを体験することができます様々なソース固有のオーバーレイ方式のいずれかに、このプロセスを転送することにより、またはプレーン複製サーバに委譲することによって。アプリケーションプログラマは、コードの同じ行で、これらの基礎となるメカニズムのいずれかを呼び出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Simplified Service Deployment through Generic Gateways: The common multicast API allows for an implementation of abstract gateway functions with mappings to specific technologies residing at the system level. Generic gateways may provide a simple bridging service and facilitate an inter-domain deployment of multicast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジェネリックゲートウェイを通じて簡体サービスの展開：一般的なマルチキャストAPIは、システムレベルで常駐する特定の技術へのマッピングを持つ抽象ゲートウェイ機能の実装が可能になります。一般的なゲートウェイは、単純なブリッジングサービスを提供し、マルチキャストのドメイン間の展開を容易にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mobility-Agnostic Group Communication: Group naming and management as foreseen in the common multicast API remain independent of locators. Naturally, applications stay unaware of any mobility-related address changes. Handover-initiated re-addressing is delegated to the mapping services at the system level and may be designed to smoothly interact with mobility management solutions provided at the network or transport layer (see [RFC5757] for mobility-related aspects).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モビリティ・不可知論者グループ通信：一般的なマルチキャストAPIに予見としてグループは、ネーミングおよび管理ロケータの独立したまま。当然のことながら、アプリケーションは、任意のモビリティ関連アドレス変更を認識しないままです。ハンドオーバ開始システムレベルでマッピングサービスに委譲され、再アドレッシング及び円滑ネットワークまたはトランスポート層に設けられたモビリティ管理ソリューションと相互作用するように設計されてもよい（モビリティ関連の態様に関して[RFC5757]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Illustrative Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。具体的な例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.1. Support of Multiple Underlying Technologies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.1。複数の基礎となるテクノロジのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On a very high level, the common multicast API provides the application programmer with one single Interface to manage multicast content independent of the technology underneath. Considering the following simple example in Figure 1, a multicast source S is connected via IPv4 and IPv6. It distributes one flow of multicast content (e.g., a movie). Receivers are connected via IPv4/v6 and Overlay Multicast (OM), respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非常に高いレベルでは、一般的なマルチキャストAPIは、下の技術のマルチキャストコンテンツの独立を管理するために、1つのインターフェイスを持つアプリケーションプログラマを提供します。図1の次の簡単な例を考えると、マルチキャストソースSは、IPv4とIPv6を介して接続されています。これは、マルチキャストコンテンツ（例えば、映画）の流れを分配します。受信機は、それぞれ、V6のIPv4 /オーバーレイマルチキャスト（OM）を介して接続されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    +-------+       +-------+                       +-------+
    |   S   |       |  R1   |                       |  R3   |
    +-------+       +-------+                       +-------+
   v6|   v4|           |v4                             |OM
     |     |          /                                |
     |  ***| ***  ***/ **                          *** /***  ***  ***
      \*   |*   **  /**   *                       *   /*   **   **   *
      *\   \_______/_______*__v4__+-------+      *   /                *
       *\    IPv4/v6      *       |  R2   |__OM__ *_/ Overlay Mcast  *
      *  \_________________*__v6__+-------+      *                    *
       *   **   **   **   *                       *    **   **   **  *
        ***  ***  ***  ***                         ***  ***  ***  ***
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1: Common Scenario: Source S Sends the Same Multicast Content via Different Technologies
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1：一般的なシナリオ：ソースSは、異なる技術を経由して同一のマルチキャストコンテンツを送信します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using the current BSD socket API, the application programmer needs to decide on the IP technologies at coding time. Additional distribution techniques, such as overlay multicast, must be individually integrated into the application. For each technology, the application programmer needs to create a separate socket and initiate a dedicated join or send. As the current socket API does not distinguish between Group Name and Group Address, the content will be delivered multiple times to the same receiver (cf. R2). Whenever the source distributes content via a technology that is not supported by the receivers or its Internet Service Provider (cf. R3), a gateway is required. Gateway functions rely on a coherent view of the Multicast Group states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のBSDソケットAPIを使用して、アプリケーションプログラマは時間をコーディングにIP技術を決定する必要があります。そのようなオーバレイマルチキャストなどの追加の配信技術は、個々のアプリケーションに統合されなければなりません。各技術について、アプリケーションプログラマは別のソケットを作成する必要があり、参加したり、送信専用を開始します。現在のソケットAPIは、グループ名とグループアドレスを区別しないように、コンテンツは同じレシーバ（参照：R2）に複数回配信されます。ソースは受信者またはそのインターネットサービスプロバイダ（参照R3）でサポートされていない技術を経由してコンテンツを配信するたびに、ゲートウェイが必要です。ゲートウェイ機能は、マルチキャストグループの状態のコヒーレントビューに依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The common multicast API simplifies programming of multicast applications, as it abstracts content distribution from specific technologies. In addition to calls that implement the receiving and sending of multicast data, the API provides service calls to grant access to internal multicast states at the host. The API description provided in this document defines a minimal set of programming Interfaces to the system components at the host to operate group communication. It is left to specific implementations to provide additional convenience functions for programmers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは特定の技術からのコンテンツ配信を抽象化などの一般的なマルチキャストAPIは、マルチキャストアプリケーションのプログラミングを簡素化します。マルチキャストデータの受信と送信を実装通話に加えて、APIは、サービスがホストに内部のマルチキャスト状態へのアクセスを許可するために呼び出しています。本書で提供されるAPIの説明は、グループ通信を動作させるホストのシステム構成要素へのプログラミング・インターフェースの最小セットを定義します。プログラマのための追加の便利な機能を提供するために、特定の実装に任されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The implementation of content distribution for the example shown in Figure 1 may then look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1に示す例のコンテンツ配信の実装は、次にようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     //Initialize multicast socket
     MulticastSocket m = new MulticastSocket();
     //Associate all available Interfaces
     m.addInterface(getInterfaces());
     //Subscribe to Multicast Group
     m.join(URI(&#34;ham:opaque:news@cnn.com&#34;));
     //Send to Multicast Group
     m.send(URI(&#34;ham:opaque:news@cnn.com&#34;),message);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Send/receive example using the common multicast API
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的なマルチキャストAPIを使用した例を受信/送信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The gateway function for R2 can be implemented by service calls that look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
R2のためのゲートウェイ機能は次のようになり、サービスコールによって実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     //Initialize multicast socket
     MulticastSocket m = new MulticastSocket();
     //Check (a) host is designated multicast node for this Interface
     //      (b) receivers exist
     for all this.getInterfaces() {
       if(designatedHost(this.interface) &amp;&amp;
            childrenSet(this.interface,
               URI(&#34;ham:opaque:news@cnn.com&#34;)) != NULL) {
         m.addInterface(this.interface);
       }
     }
     while(true) {
       m.send(URI(&#34;ham:opaque:news@cnn.com&#34;),message);
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Gateway example using the common multicast API
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的なマルチキャストAPIを使用してゲートウェイの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.2. Support of Multi-Resolution Multicast
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.2。多重解像度マルチキャストのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multi-resolution multicast adjusts the multicast stream to consider heterogeneous end devices. The multicast data (e.g., available by different compression levels) is typically announced using multiple multicast addresses that are unrelated to each other. Using the common API, multi-resolution multicast can be implemented transparently by an operator with the help of name-to-address mapping, or by systematic naming from a subscriber-centric perspective.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチ解像度のマルチキャストは、異種のエンドデバイスを検討するマルチキャストストリームを調整します。 （異なる圧縮レベルにより、例えば、利用可能な）マルチキャストデータは、典型的には、相互に無関係である複数のマルチキャストアドレスを使用して発表されています。共通APIを使用して、マルチ解像度のマルチキャストは、名前からアドレスのマッピングの助けを借りて、オペレータによって透過的に実装され、または加入者中心の視点から体系的命名することによってすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Operator-Centric: An operator deploys a domain-specific mapping. In this case, any multicast receiver (e.g., mobile or DSL user) subscribes to the same multicast name, which will be resolved locally to different multicast addresses. In this case, each Group Address represents a different level of data quality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オペレータ中心の：オペレータは、ドメイン固有のマッピングをデプロイします。この場合には、任意のマルチキャスト受信機（例えば、モバイル又はDSLユーザ）は、異なるマルチキャストアドレスに局所的に解決される同じマルチキャスト名前、に加入します。この場合、各グループアドレスは、データ品質の異なるレベルを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Subscriber-Centric: In a subscriber-centric example, the multicast receiver chooses the quality in advance, based on a predefined naming syntax. Consider a layered video stream &#34;blockbuster&#34; available at different qualities Q_i, each of which consists of the base layer plus the sum of EL_j, j &lt;= i enhancement layers. Each individual layer may then be accessible by a name &#34;EL_j.Q_i.blockbuster&#34;, j &lt;= i, while a specific quality aggregates the corresponding layers to &#34;Q_i.blockbuster&#34;, and the full-size movie may be just called &#34;blockbuster&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
加入者中心のは：加入者中心の例では、マルチキャスト受信側は、事前定義された命名構文に基づいて、予め品質を選択します。ベースレイヤプラスEL_j、J &lt;=の和から成る各々はQ_I、Iエンハンスメントレイヤ異なる品質で利用可能な階層化ビデオストリーム「ブロックバスター」を考えます。個々の層は、名前「EL_j.Q_i.blockbuster」、J &lt;具体的な品質が対応する層に「Q_i.blockbuster」、およびフルサイズの映画を集約しながら、=私は、ちょうど呼ばれる「大ヒットによってアクセスすることができます」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document uses the terminology as defined for the multicast protocols discussed in [RFC2710], [RFC3376], [RFC3810], [RFC4601], and [RFC4604]. In addition, the following terms will be used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは[RFC2710]で説明したマルチキャストプロトコルのために定義されるような用語を使用して、[RFC3376]、[RFC3810]、[RFC4601]及び[RFC4604]。また、以下の用語が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Group Address: A Group Address is a routing identifier. It represents a technological specifier and thus reflects the distribution technology in use. Multicast packet forwarding is based on this address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ住所：グループアドレスは、ルーティング識別子です。それは技術的な指定子を表し、したがって、使用中の配信技術を反映しています。マルチキャストパケットの転送は、このアドレスに基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Group Name: A Group Name is an application identifier used by applications to manage communication in a Multicast Group (e.g., join/leave and send/receive). The Group Name does not predefine any distribution technologies. Even if it syntactically corresponds to an address, it solely represents a logical identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名：グループ名は、マルチキャストグループ（例えば、参加/ままにして送信/受信）における通信を管理するためにアプリケーションによって使用されるアプリケーション識別子です。グループ名は、任意の配布技術を事前に定義しません。それは構文的アドレスに対応したとしても、それは単に論理識別子を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast Namespace: A Multicast Namespace is a collection of designators (i.e., names or addresses) for groups that share a common syntax. Typical instances of namespaces are IPv4 or IPv6 multicast addresses, overlay group IDs, Group Names defined on the application layer (e.g., SIP or email), or some human-readable string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャスト名前空間：マルチキャスト名前空間には、共通の構文を共有するグループのための指示子のコレクション（すなわち、名前や住所）です。名前空間の典型的な例は、アプリケーション層（例えば、SIPまたは電子メール）、またはいくつかの人間が読み取り可能な文字列に定義されたIPv4またはIPv6マルチキャストアドレス、オーバーレイ・グループID、グループ名です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Interface: An Interface is a forwarding instance of a distribution technology on a given node, for example, the IP Interface 192.168.1.1 at an IPv4 host, or an overlay routing Interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターフェイス：インターフェイスは、IPv4ホストの所与のノード、例えば、IPインターフェース192.168.1.1、またはインタフェースルーティングオーバレイ上の配信技術の転送インスタンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast Domain: A Multicast Domain hosts nodes and routers of a common, single multicast forwarding technology and is bound to a single namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストドメイン：マルチキャストドメインは、一般的な、単一のマルチキャスト転送技術のノードとルータをホストし、単一の名前空間にバインドされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Inter-domain Multicast Gateway (IMG): An IMG is an entity that interconnects different Multicast Domains. Its objective is to forward data between these domains, e.g., between an IP layer and overlay multicast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドメイン間のマルチキャストゲートウェイ（IMG）：IMGは異なるマルチキャストドメインを相互接続するエンティティです。その目的は、IP層とオーバレイマルチキャストの間に、例えば、これらのドメイン間でデータを転送することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Objectives and Reference Scenarios
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。目的とリファレンスシナリオ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The default use case addressed in this document targets applications that participate in a group by using some common identifier taken from some common namespace. This Group Name is typically learned at runtime from user interaction, such as the selection of an IPTV channel, or from dynamic session negotiations as used with the Session Initiation Protocol (SIP) [RFC3261] or Peer-to-Peer SIP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本書で扱わデフォルトのユースケースは、いくつかの共通の名前空間から取られたいくつかの共通の識別子を使用して、グループに参加するアプリケーションをターゲットとしています。このグループ名は、典型的に、またはセッション開始プロトコル（SIP）[RFC3261]またはピア・ツー・ピアSIPで使用される動的セッションネゴシエーションからIPTVチャネルの選択として、ユーザーとの対話から、実行時に学習され
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(P2PSIP) [SIP-RELOAD], but may as well have been predefined for an application as a common Group Name. Technology-specific system functions then transparently map the Group Name to Group Addresses such that
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（P2PSIP）[SIPリロード]が、同様に、共通のグループ名などのアプリケーションのために事前に定義されていてもよいです。技術特有のシステム機能は、透過的に、このようなグループアドレスにグループ名をマッピング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o programmers can process Group Names in their programs without the need to consider technological mappings that relate to designated deployments in target domains;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oプログラマは、ターゲットドメイン内の指定の展開に関連する技術のマッピングを考慮することなく、自分たちのプログラムにグループ名を処理することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o applications can identify packets that belong to a logically named group, independent of the Interface technology used for sending and receiving packets; this shall also hold true for multicast gateways.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oアプリケーションは、パケットを送受信するために使用するインターフェース技術とは無関係に、論理的に名前のグループに属しているパケットを識別することができます。これは、マルチキャストゲートウェイに当てはまるものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document considers two reference scenarios that cover the following hybrid deployment cases displayed in Figure 2:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、図2に表示され、次のハイブリッド展開のケースをカバーする二つの基準シナリオを考慮する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Multicast Domains running the same multicast technology but remaining isolated, possibly only connected by network-layer unicast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
おそらく唯一のネットワーク層ユニキャスト接続、同じマルチキャスト技術を実行しているが、単離された残り1のマルチキャストドメイン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Multicast Domains running different multicast technologies but hosting nodes that are members of the same Multicast Group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.マルチキャストドメインが異なるマルチキャスト技術を実行しているが、同じマルチキャストグループのメンバーであるノードをホストしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                       +-------+         +-------+
                                       | Member|         | Member|
                                       |  Foo  |         |   G   |
                                       +-------+         +-------+
                                             \            /
                                           ***  ***  ***  ***
                                          *   **   **   **   *
                                         *                    *
                                          *  Mcast Tech. A   *
                                         *                    *
                                          *   **   **   **   *
                                           ***  ***  ***  ***
   +-------+          +-------+                     |
   | Member|          | Member|                 +-------+
   |   G   |          |  Foo  |                 |  IMG  |
   +-------+          +-------+                 +-------+
       |                |                           |
       ***  ***  ***  ***                 ***  ***  ***  ***
      *   **   **   **   *               *   **   **   **   *
     *                    *  +-------+  *                    *
      *  Mcast Tech. A   * --|  IMG  |-- *  Mcast Tech. B   *   +------+
     *                    *  +-------+  *                    * -|Member|
      *   **   **   **   *               *   **   **   **   *   |  G   |
       ***  ***  ***  ***                 ***  ***  ***  ***    +------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 2: Reference Scenarios for Hybrid Multicast, Interconnecting Group Members from Isolated Homogeneous and Heterogeneous Domains
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図2：ハイブリッドマルチキャストのためのリファレンスシナリオ、孤立同種および異種ドメインからグループメンバーの相互接続
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Group Communication API and Protocol Stack
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。グループ通信のAPIとプロトコルスタック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The group communication API abstracts the socket concept and consists of four parts. Two parts combine the essential communication functions, while the remaining two offer optional extensions for enhanced monitoring and management:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ通信APIは、ソケットの概念を抽象化し、4つの部分から構成されています。強化監視と管理のための2つのオファーオプションの拡張機能を維持しながら2つの部分が、基本的な通信機能を組み合わせます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Group Management Calls: provide the minimal API to instantiate an abstract multicast socket and manage group membership;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ管理は呼び出し：抽象マルチキャストソケットをインスタンス化し、グループメンバーシップを管理するために、最小限のAPIを提供すること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Send/Receive Calls: provide the minimal API to send and receive multicast data in a technology-transparent fashion;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コールを受信/送信：技術透明な方法でマルチキャストデータを送受信する最小限のAPIを提供すること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Socket Options: provide extension calls for an explicit configuration of the multicast socket, such as setting hop limits or associated Interfaces;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソケットオプション：そのようなホップ限界または関連するインターフェースを設定するように、マルチキャストソケットを明示的に構成するための拡張コールを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service Calls: provide extension calls that grant access to internal multicast states of an Interface, such as the Multicast Groups under subscription or the multicast forwarding information base.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスコール：拡張機能を提供し、このようなサブスクリプションの下でマルチキャストグループやマルチキャスト転送情報ベースとして、インタフェースの内部マルチキャスト状態、への補助金のアクセスを呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast applications that use the common API require assistance from a group communication stack. This protocol stack serves two needs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
共通APIを使用するマルチキャストアプリケーションは、グループ通信スタックからの支援を必要としています。このプロトコル・スタックは、二つのニーズを提供しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o It provides system-level support to transfer the abstract functions of the common API, including namespace support, into protocol operations at Interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれは、界面でのプロトコル操作に、名前空間のサポートを含む共通のAPIの抽象機能を転送するシステムレベルのサポートを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o It provides group communication services across different multicast technologies at the local host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれは、ローカルホストで異なるマルチキャストテクノロジー間グループ通信サービスを提供しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A general initiation of a multicast communication in this setting proceeds as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように、この設定が進行中のマルチキャスト通信の一般的な開始
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. An application opens an abstract multicast socket.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.アプリケーションは、抽象マルチキャストソケットを開きます。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. The application subscribes to / leaves / (de)registers a group using a Group Name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.アプリケーションは、加入に/葉/（デ）グループ名を使用してグループを登録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. An intrinsic function of the stack maps the logical group ID (Group Name) to a technical group ID (Group Address). This function may make use of deployment-specific knowledge, such as available technologies and Group Address management in its domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スタックの3本来の機能は、技術的なグループID（グループアドレス）に論理グループID（グループ名）をマッピングします。この機能は、そのドメインで利用可能な技術とグループアドレス管理などのデプロイメント固有の知識、を利用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Packet distribution proceeds to and from one or several multicast-enabled Interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.パケット分布および1つまたはいくつかのマルチキャスト対応インターフェイスから進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The abstract multicast socket represents a group communication channel composed of one or multiple Interfaces. A socket may be created without explicit Interface association by the application, which leaves the choice of the underlying forwarding technology to the group communication stack. However, an application may also bind the socket to one or multiple dedicated Interfaces and therefore predefine the forwarding technology and the Multicast Namespace(s) of the Group Address(es).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象マルチキャストソケットは、一つまたは複数のインターフェイスからなるグループ通信チャネルを表します。ソケットは、グループ通信スタックに根本的な転送技術の選択肢を残しアプリケーションによって明示的なインターフェイスの関連付けなしで作成することができます。ただし、アプリケーションはまた、一つまたは複数の専用インターフェースにソケットを結合することができるので、転送技術とグループアドレス（ES）のマルチキャスト名前空間（複数可）を事前に定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Applications are not required to maintain mapping states for Group Addresses. The group communication stack accounts for the mapping of the Group Name to the Group Address(es) and vice versa. Multicast data passed to the application will be augmented by the corresponding Group Name. Multiple multicast subscriptions thus can be conducted on a single multicast socket without the need for Group Name encoding on the application side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは、グループアドレスのマッピング状態を維持するために必要とされていません。グループアドレス（ES）およびその逆にグループ名のマッピングのためのグループ通信スタック・アカウント。アプリケーションに渡されたマルチキャストデータは、対応するグループ名によって拡張されます。複数のマルチキャストサブスクリプションは、このようにアプリケーション側でグループ名符号化を必要とせずに単一のマルチキャストソケットで行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hosts may support several multicast protocols. The group communication stack discovers available multicast-enabled Interfaces. It provides a minimal hybrid function that bridges data between different Interfaces and Multicast Domains. The details of service discovery are out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストは、複数のマルチキャストプロトコルをサポートすることができます。グループ通信スタックが可能なマルチキャスト対応のインターフェイスを検出します。これは、異なるインタフェースおよびマルチキャストドメイン間でデータをブリッジ最小ハイブリッド機能を提供します。サービス検出の詳細は、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The extended multicast functions can be implemented by middleware, as conceptually presented in Figure 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
概念的には、図3に示すように拡張されたマルチキャスト機能は、ミドルウェアによって実現することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        *-------*     *-------*
        | App 1 |     | App 2 |
        *-------*     *-------*
            |             |
        *---------------------*         ---|
        |   Middleware        |            |
        *---------------------*            |
             |          |                  |
        *---------*     |                  |
        | Overlay |     |                   \  Group Communication
        *---------*     |                   /  Stack
             |          |                  |
             |          |                  |
        *---------------------*            |
        |   Underlay          |            |
        *---------------------*         ---|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 3: Architecture of a Group Communication Stack with Middleware Offering Uniform Access to Multicast in Underlay and Overlay
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図3：ミドルウェアは、アンダーレイとオーバーレイでマルチキャストへの統一アクセスを提供するとのグループ通信スタックのアーキテクチャ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Naming and Addressing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。命名とアドレッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Applications use Group Names to identify groups. Names can uniquely determine a group in a global communication context and hide technological deployment for data distribution from the application. In contrast, multicast forwarding operates on Group Addresses. Even though both identifiers may be symbolically identical, they carry different meanings. They may also belong to different Multicast Namespaces. The namespace of a Group Address reflects a routing technology, while the namespace of a Group Name represents the context in which the application operates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは、グループを識別するために、グループ名を使用します。名前は一意のグローバル通信コンテキストにグループを決定し、アプリケーションからのデータ配信のための技術展開を隠すことができます。これとは対照的に、マルチキャスト転送は、グループアドレス上で動作します。両方の識別子が象徴的に同一であっても、彼らは異なる意味を運びます。彼らはまた、別のマルチキャスト名前空間に属していてもよいです。グループ名の名前空間は、アプリケーションが動作する状況を表しているグループアドレスの名前空間は、ルーティング技術を反映しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIs [RFC3986] are a common way to represent namespace-specific identifiers in applications in the form of an abstract metadata type. Throughout this document, all Group Names follow a URI notation using the syntax defined in Section 4.2. Examples are ham:ip:224.1.2.3:5000 for a canonical IPv4 ASM group at UDP port 5000 and ham:sip:news@cnn.com for application-specific naming with service instantiator and default port selection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIは[RFC3986]は抽象メタデータ型の形式でアプリケーション名前空間固有の識別子を表現する一般的な方法です。本書では、すべてのグループ名は、セクション4.2で定義された構文を使用してURI表記に従ってください。サービスインスタンと、デフォルトのポート選択とアプリケーション固有の命名news@cnn.com：IP：224.1.2.3：5000 UDPポート5000とハムの標準的なIPv4のASMグループ用：SIP例としては、ハムです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An implementation of the group communication stack can provide convenience functions that detect the namespace of a Group Name or further optimize service instantiation. In practice, such a library would provide support for high-level data types to the application, similar to some versions of the current socket API (e.g., InetAddress in Java). Using this data type could implicitly determine the namespace. The details of automatic namespace identification or service handling are out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ通信スタックの実装では、グループ名またはさらなる最適化サービスインスタンスの名前空間を検出する便利な機能を提供することができます。実際に、そのようなライブラリは、現在のソケットAPI（Javaで例えば、InetAddressの）のいくつかのバージョンと同様のアプリケーションにハイレベルのデータ型のサポートを提供します。このデータ型を使用すると、暗黙的に名前空間を決定することができます。自動名前空間の識別やサービスの取り扱いの詳細は、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Namespaces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4。名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Namespace identifiers in URIs are placed in the scheme element and characterize syntax and semantics of the group identifier. They enable the use of convenience functions and high-level data types while processing URIs. When used in names, they may indicate an application context or may facilitate a default mapping and a recovery of names from addresses. When used in addresses, they characterize the group identifier&#39;s type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIの中に名前空間識別子は、スキーム要素に入れ、グループ識別子の構文と意味論を特徴付けています。 URIを処理している間、彼らは便利な機能とハイレベルのデータ・タイプの使用を可能にします。名前に使用すると、彼らは、アプリケーション・コンテキストを示すことか、デフォルトのマッピングとアドレスから名前の回復を容易にすることができます。アドレスで使用する場合、彼らはグループ識別子のタイプを特徴づけます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In compliance with the URI concept, namespace schemes can be added. Examples of schemes are generic (see Section 4.2.3) or inherited from applications (see Section 4.2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIの概念に準拠して、名前空間スキームを追加することができます。スキームの例としては、一般的な（4.2.3項を参照）、またはアプリケーション（4.2.4項を参照）から継承されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Name-to-Address Mapping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5。名前からアドレスへのマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The multicast communication paradigm requires all group members to subscribe to the same Group Name, taken from a common Multicast Namespace, and to thereby identify the group in a technology-agnostic way. Following this common API, a sender correspondingly registers a Group Name prior to transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャスト通信パラダイムは、共通のマルチキャスト名前空間から取られた同じグループ名に加入し、それによって技術に依存しない方法でグループを識別するために、すべてのグループメンバーが必要です。この共通APIの後に、送信者は、それに応じて、送信する前にグループ名を登録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At communication end points, Group Names require a mapping to Group Addresses prior to service instantiation at the Interfaces of the end points. Similarly, a mapping is needed at gateways to consistently translate between Group Addresses from different namespaces. Two requirements need to be met by a mapping function that translates between Multicast Names and Addresses:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
通信エンドポイントで、グループ名は、グループへのマッピングは、エンドポイントのインターフェースでのサービスのインスタンス化する前にアドレスが必要です。同様に、マッピングは一貫して異なる名前空間からのグループアドレス間の変換にゲートウェイで必要とされています。 2つの要件がマルチキャスト名前とアドレス間の変換マッピング機能によって満たされる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. For a given Group Name, identify an Address that is appropriate for a local distribution instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。与えられたグループ名のために、ローカル配信インスタンスに適したアドレスを識別する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. For a given Group Address, invert the mapping to recover the Group Name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。与えられたグループアドレスの場合は、グループ名を回復するために、マッピングを反転。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, mappings can be complex and do not need to be invertible. A mapping can be realized by embedding smaller namespaces into larger namespaces or selecting an arbitrary, unused ID in a smaller target namespace. For example, it is not obvious how to map a large identifier space (e.g., IPv6) to a smaller, collision-prone set like IPv4 (see [MCAST-v4v6-FRAMEWORK], [MCAST-v4v6], and [RFC6219]). Mapping functions can be stateless in some contexts but may require states in others. The application of such functions depends on the cardinality of the namespaces, the structure of address spaces, and possible address collisions. However, some namespaces facilitate a canonical, invertible transformation to default address spaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に、マッピングは、複雑にすることができ、可逆である必要はありません。マッピングは、より大きな名前空間に小さな名前空間を埋め込む以下ターゲット名前空間内の任意の未使用のIDを選択することによって実現することができます。例えば、IPv4のような小さい、衝突が発生しやすいセットに大きな識別子空間（例えば、IPv6）をマップする方法は明らかではない（参照[MCAST-v4v6-FRAMEWORK]、[MCAST-v4v6]、および[RFC6219]） 。マッピング機能は、一部のコンテキストでステートレスすることができますが、他に状態を必要とするかもしれません。このような機能のアプリケーションは、アドレス空間、および可能なアドレス衝突の構造、名前空間の基数に依存します。しかし、いくつかの名前空間は、アドレス空間をデフォルトに標準的な、可逆変換を促進します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1. Canonical Mapping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1。 Canonicalのマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some Multicast Namespaces defined in Section 3.4 can express a canonical default mapping. For example, ham:ip:224.1.2.3:5000 indicates the correspondence to 224.1.2.3 in the default IPv4 multicast address space at port 5000. This default mapping is bound to a technology and may not always be applicable, e.g., in the case of address collisions. Note that under canonical mapping, the multicast URI can be completely recovered from any data message received within this group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.4節で定義されたいくつかのマルチキャスト名前空間には、標準的なデフォルトのマッピングを表現することができます。たとえば、ハム：IPは：224.1.2.3：5000の場合には、例えば、ポート5000このデフォルトのマッピングは技術にバインドされている時にデフォルトのIPv4マルチキャストアドレス空間に224.1.2.3への対応を示し、常に適用されない場合がありますアドレス衝突の。正規マッピングの下で​​、マルチキャストURIが完全にこのグループ内で受信された任意のデータ・メッセージから回収することができることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2. Mapping at End Points
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2。エンドポイントでのマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast listeners or senders require a name-to-address conversion for all technologies they actively run in a group. Even though a mapping applies to the local Multicast Domain only, end points may need to learn a valid Group Address from neighboring nodes, e.g., from a gateway in the collision-prone IPv4 domain. Once set, an end point will always be aware of the name-to-address correspondence and thus can autonomously invert the mapping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストリスナまたは送信者は、彼らが積極的にグループ内で実行されるすべての技術の名前とアドレスの変換が必要になります。マッピングは、ローカルマルチキャストドメインに適用されるにもかかわらず、エンドポイントは、衝突が発生しやすいのIPv4ドメインのゲートウェイから、例えば、近隣ノードから有効なグループアドレスを学習する必要があるかもしれません。一度設定すると、エンドポイントは、常に自律的にマッピングを反転させることができるので、名前とアドレスの対応関係を認識することとなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.3. Mapping at Inter-Domain Multicast Gateways
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.3。ドメイン間のマルチキャストゲートウェイでのマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast data may arrive at an IMG via one technology and request that the gateway re-address packets for another distribution system. At initial arrival, the IMG may not have explicit knowledge of the corresponding Multicast Group Name. To perform a consistent mapping, the Group Name needs to be acquired. It may have been distributed at source registration or may have been learned from a neighboring node, the details of which are beyond the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストデータは、1つの技術を介してIMGに到着し、別の分配システムのためのゲートウェイ再アドレスパケットことを要求してもよいです。最初の到着時に、IMGは、対応するマルチキャストグループ名の明示的な知識を持っていないかもしれません。一貫性のあるマッピングを実行するには、グループ名を取得する必要があります。これは、ソース登録時に配布されているか、またはこの文書の範囲を超えてその詳細は、隣接ノードから学習されていてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. A Note on Explicit Multicast (Xcast)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6。明示的マルチキャスト上の注意（のXcast）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In Explicit Multicast (Xcast) [RFC5058], the multicast source explicitly predefines the receivers. From a conceptual perspective, Xcast is an additional distribution technology (i.e., a new technology-specific Interface) for this API. Xcast requires aggregated knowledge of receivers that is available at the origin of the distribution tree. The instantiation part of the Group Name may refer to such a management instance and tree root, which can be the source or some co-located processor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
明示的マルチキャスト（のXcast）[RFC5058]に、マルチキャストソースは、明示的に受信機が事前に定義され。概念的な観点から、のXcastは、このAPIのための追加の配信技術（すなわち、新しい技術固有インタフェース）です。 XCASTは、配信木の原点に利用可能である受信機の集合知識を必要とします。グループ名のインスタンスの一部は、ソースまたはいくつかの同一位置のプロセッサとすることができる、そのような管理インスタンスおよびツリーのルートを指すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An implementation of Xcast then requires a topology-dependent mapping of the Group Name to the set of subscribers. The defining details of this multi-destination mapping are out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Xcastの実装では、加入者のセットにグループ名のトポロジー依存のマッピングが必要です。このマルチ宛先マッピングの定義の詳細は、この文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. MTU Handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7。 MTUの取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This API considers a multi-technology scenario in which different technologies may have different Maximum Transmission Unit (MTU) sizes. Even if the MTU size between two hosts has been determined, it may change over time, as initiated by either the network (e.g., path changes) or end hosts (e.g., Interface changes due to mobility).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このAPIは、異なる技術が異なる最大伝送単位（MTU）サイズを有することができるマルチテクノロジーのシナリオを検討します。 2つのホスト間のMTUサイズが決定された場合でも、ネットワーク（例えば、パスの変更）、またはエンドホスト（例えば、インタフェースにより移動度に変化する）のいずれかによって開始されるように、それは、時間の経過と共に変化してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The design of this API is based on the objective of robust communication and easy application development. MTU handling and the implementation of fragmentation are thus guided by the following observations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このAPIの設計は、堅牢なコミュニケーションと容易なアプリケーション開発の目的に基づいています。 MTU処理およびフラグメンテーションの実装は、このように、以下の観察によって導かれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Application: Application programmers need a simple way to transmit packets in a technology-agnostic fashion. For this, it is convenient at the time of coding to rely on a transparent maximum amount of data that can be sent in one message from a socket. A regular program flow should not be distracted by querying and changing MTU sizes. Technically, the configuration of the maximum message size used by the application programmer may change and disrupt communication when (a) Interfaces are added or excluded or (b) the path MTU changes during transmission and thus disables the corresponding Interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション：アプリケーションプログラマは、技術にとらわれない形でパケットを送信するための簡単な方法が必要です。このため、それがソケットから一つのメッセージで送信できるデータの透明最大量に依存するコーディングの際に便利です。通常のプログラムの流れは、MTUサイズを照会し、変更することに気を取られてはいけません。 （A）インタフェースを追加または除外または（b）の経路はMTUが送信中に変化するので、対応するインタフェースを無効にしている場合、技術的に、アプリケーション・プログラマによって使用されるメッセージの最大サイズの設定は、通信を変更し、破壊してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Middleware: Middleware situated between application and technology Interfaces ensures a general packet-handling capability, which in turn prevents the application programmer from implementing fragmentation. A uniform maximum message size that cannot be changed during runtime shall be guaranteed by the group communication stack (e.g., middleware). Otherwise, this would conflict with a technology-agnostic application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ミドルウェア：アプリケーションと技術のインターフェイスとの間に位置するミドルウェアは、順番に断片化を実装するから、アプリケーションプログラマを防ぐ一般的なパケット処理機能を、保証します。実行時に変更することができない、均一なメッセージの最大サイズは、グループ通信スタック（例えば、ミドルウェア）によって保証されなければなりません。そうでなければ、これは技術に依存しないアプリケーションと競合します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Technology Interfaces: Fragmentation requirements depend on the technology in use. Hence, the (technology-bound) Interfaces need to cope with MTU sizes that may vary among Interfaces and along different paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
テクノロジーインターフェース：断片化要件使用中の技術に依存しています。したがって、（技術結合した）インターフェイスはインターフェイス間および異なる経路に沿って変化してもよいMTUサイズに対応する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The concept of this API also aims at guaranteeing a maximum message size for the application programmer, to thereby handle fragmentation at the Interface level, if needed. Nevertheless, the application programmer should be able to determine the technology-specific atomic message size to optimize data distribution, or for other reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このAPIの概念はまた、必要であれば、これにより、インターフェイスレベルでの断片化を処理するために、アプリケーションプログラマのための最大メッセージサイズを保証することを目指しています。それにもかかわらず、アプリケーション・プログラマは、データの分布を最適化する技術に固有の原子のメッセージサイズを決定することができる、または他の理由のためにすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The uniform maximum message size should take realistic values (e.g., following IP clients) to enable smooth and efficient services. A detailed selection scheme of MTU values is out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
均一なメッセージの最大サイズは、円滑かつ効率的なサービスを可能にするために（例えば、IPクライアント以下）現実的な値をとるべきです。 MTU値の詳細な選択スキームはこの文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Common Multicast API
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.一般的なマルチキャストAPI
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。表記法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following description of the common multicast API is expressed in pseudo-syntax. Variables that are passed to function calls are declared by &#34;in&#34;, and return values are declared by &#34;out&#34;. A list of elements is denoted by &#34;&lt;&gt;&#34;. The pseudo-syntax assumes that lists include an attribute that represents the number of elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
共通のマルチキャストAPIの以下の説明は、擬似構文で表現されます。関数呼び出しに渡された変数は「中」で宣言され、戻り値が「アウト」によって宣言されています。要素のリストは、「&lt;&gt;」で示されています。擬似構文は、リストは要素の数を表す属性を含むことを想定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The corresponding C signatures are defined in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
対応するC署名は、付録Aで定義されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. URI Scheme Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。 URIスキームの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast Names and Multicast Addresses used in this API are represented by a URI scheme that is specified in the following subsections. A corresponding ham-URI denotes a multicast channel and may be dereferenced to retrieve data published to that channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このAPIで使用されるマルチキャスト名前とマルチキャストアドレスは、以下のサブセクションで指定されたURIスキームで表されます。対応HAM-URIは、マルチキャストチャネルを表し、そのチャネルに公開されたデータを取得するために逆参照されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Syntax
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1。構文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The syntax of the multicast URI is specified using the Augmented Backus-Naur Form (ABNF) [RFC5234] and is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにマルチキャストURIの構文は、拡張バッカス・ナウアフォーム（ABNF）[RFC5234]を使用して指定されると定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ham-URI = ham-scheme &#34;:&#34; namespace &#34;:&#34; group [ &#34;@&#34; instantiation ] [ &#34;:&#34; port ] [ &#34;/&#34; sec-credentials ]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HAM-URI = HAM-方式 &#34;：&#34; 名前空間 &#34;：&#34; グループ[ &#34;@&#34; インスタンス] [ &#34;：&#34; ポート] [ &#34;/&#34; SEC-クレデンシャル]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ham-scheme = &#34;ham&#34; ; hybrid adaptive multicast namespace = ALPHA *( ALPHA / DIGIT / &#34;+&#34; / &#34;-&#34; / &#34;.&#34; ) group = &#34;*&#34; / 1*unreserved ; unreserved per [RFC3986] instantiation = 1*unreserved ; unreserved per [RFC3986] port = 1*DIGIT sec-credentials = alg &#34;;&#34; val alg = 1*unreserved ; unreserved per [RFC3986] val = 1*unreserved ; unreserved per [RFC3986]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハム・スキーム=「ハム」。ハイブリッド適応マルチキャスト名前空間= ALPHA×（ALPHA / DIGIT / &#34;+&#34; / &#34; - &#34; / &#34;&#34;）群= &#34;*&#34; / 1 *予約されていません。予約されていないあたり[RFC3986]インスタンス= 1 *予約されていません。予約されていないあたり[RFC3986]ポート= 1 * DIGIT秒-クレデンシャル= ALG &#34;;&#34;ヴァルALG = 1 *予約されていません。予約されていないあたり[RFC3986]のval = 1 *予約されていません。 [RFC3986]あたりの予約されていません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Percent-encoding is applied to distinguish between reserved and unreserved assignments of the same character in the same ham-URI component (cf. [RFC3986]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パーセント符号は同一HAM-URI成分（参照[RFC3986]）で同じ文字の予約と予約されていない割り当てを区別するために適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Semantic
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2。セマンティック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The semantic of the different parts of the URI is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにURIの異なる部分の意味が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ham-scheme: refers to the specification of the assigned identifier &#34;ham&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HAM-スキームは：割り当てられた識別子「ハム」の仕様を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
namespace: takes the role of the Multicast Namespace. It defines the syntax of the group and instantiation part of the ham-URI. A basic syntax for these elements is specified in Section 4.2.1. The namespace may further restrict the syntax of designators. Example namespaces are described in Sections 4.2.3 and 4.2.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前空間は：マルチキャスト名前空間の役割を果たしています。これは、ハム-URIのグループとインスタンス化部分の構文を定義します。これらの要素のための基本的な構文はセクション4.2.1で指定されています。名前空間は、さらに指定子の構文を制限することができます。例名前空間は、セクション4.2.3および4.2.4に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
group: uniquely identifies the group within the Multicast Namespace given in the namespace. The literal &#34;*&#34; represents all members of the Multicast Group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループは、一意の名前空間内の所与のマルチキャスト名前空間内のグループを識別する。 「*」リテラルは、マルチキャストグループのすべてのメンバーを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
instantiation: identifies the entity that generates the instance of the group (e.g., a SIP domain or a source in SSM, a dedicated routing entity, or a named processor that accounts for the group communication), using syntax and semantics as defined by the namespace. This parameter is optional. Note that ambiguities (e.g., identical node addresses in multiple overlay instances) can be distinguished by ports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インスタンス：名前空間によって定義されるような構文およびセマンティクスを使用して、基（例えば、SIPドメインまたはSSMソース、専用のルーティング・エンティティ、またはグループ通信を占める名付けプロセッサ）のインスタンスを生成するエンティティを識別する。このパラメータはオプションです。曖昧（複数オーバーレイインスタンスで、例えば、同一のノード・アドレス）が、ポートによって識別することができることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
port: identifies a specific application at an instance of a group. This parameter is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポートは：グループのインスタンスに特定のアプリケーションを識別する。このパラメータはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
sec-credentials: used to implement security mechanisms (e.g., to authorize Multicast Group access or authenticate multicast operations). This parameter is optional. &#34;alg&#34; represents the security algorithm in use. &#34;val&#34; represents the actual value for Authentication, Authorization, and Accounting (AAA). Note that security credentials may carry a distinct technical meaning w.r.t. AAA schemes and may differ between group members. Hence, the sec-credentials are not considered part of the Group Name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEC-クレデンシャル：（マルチキャストグループへのアクセスを許可またはマルチキャストオペレーションを認証するために、例えば）セキュリティメカニズムを実装するために使用されます。このパラメータはオプションです。 「ALGは、」使用中のセキュリティアルゴリズムを表します。 「valが」認証、許可、アカウンティング（AAA）の実際の値を表します。セキュリティ証明書は、個別の技術的な意味w.r.t.を運ぶことができることに注意してくださいAAAは、スキームおよびグループメンバー間で異なることができます。したがって、SEC-資格情報は、グループ名の一部とはみなされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. Generic Namespaces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3。一般的な名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IP: This namespace is comprised of regular IP node naming, i.e., DNS names and addresses taken from any version of the Internet Protocol. The syntax of the group and instantiation follows the &#34;host&#34; definition in [RFC3986], Section 3.2.2. A processor dealing with the IP namespace is required to determine the syntax (DNS name, IP address, version) of the group and instantiation expression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IP：この名前空間は、通常のIPノードの命名で構成されている、すなわち、インターネットプロトコルのいずれかのバージョンから取られたDNS名とアドレス。グループおよびインスタンス化の構文は、[RFC3986]で「ホスト」の定義は、セクション3.2.2に従っています。 IPの名前空間を扱うプロセッサは、グループおよびインスタンス化表現の構文（DNS名、IPアドレス、バージョン）を決定するために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-2: This namespace carries address strings compliant with SHA-2 hash digests. The syntax of the group and instantiation follows the &#34;val&#34; definition in [RFC6920], Section 3. A processor handling those strings is required to determine the length of the expressions and passes appropriate values directly to a corresponding overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-2：この名前空間は、SHA-2ハッシュダイジェストに準拠したアドレス文字列を運びます。グループの構文およびインスタンス[RFC6920]に「ヴァル」の定義を、以下、第3節は、これらの文字列を処理するプロセッサは、式の長さを決定するために必要とそれに対応するオーバーレイに直接適切な値を通過します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Opaque: This namespace transparently carries strings without further syntactical information, meanings, or associated resolution mechanisms. The corresponding syntax for the group and instantiation part of the ham-URI is defined in Section 4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明：この名前空間は透過さらに構文情報、意味、または関連する解決メカニズムなしで文字列を運びます。 HAM-URIのグループ及びインスタンス化部分に対応する構文は、セクション4.2.1で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4. Application-Centric Namespaces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4。アプリケーション中心の名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SIP: The SIP namespace is an example of an application-layer scheme that bears inherent group functions (conferencing). SIP conference URIs may be directly exchanged and interpreted at the application, and mapped to Group Addresses at the system level to generate a corresponding Multicast Group. The syntax of the group and instantiation is represented by the &#34;userinfo&#34; component [RFC3261], Section 25.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SIP：SIP名前空間固有のグループ機能（会議）を担持するアプリケーション層スキームの一例です。 SIP会議URIは直接交換し、アプリケーションで解釈され、対応するマルチキャストグループを生成するために、システム・レベルでグループアドレスにマッピングすることができます。グループ及びインスタンス化の構文は、「ユーザー情報」成分[RFC3261]、セクション25.1で表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RELOAD: This namespace covers address strings that are valid in a REsource LOcation And Discovery [RELOAD] overlay network. A processor handling those strings may pass these values directly to a corresponding overlay that may manage multicast distribution according to [RFC7019].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RELOAD：この名前空間は、リソースの場所と発見[RELOAD]オーバーレイ・ネットワークで有効なアドレス文字列をカバーしています。これらの文字列を処理するプロセッサは、[RFC7019]に記載のマルチキャスト配信を管理することができる、対応するオーバーレイに直接これらの値を渡すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.5. Future Namespaces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.5。今後の名前空間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The concept of the common multicast API allows for any namespace that complies with the superset syntax defined in Section 4.2.1. This document specifies a basic set of Multicast Namespaces in Sections 4.2.3 and 4.2.4. If additional namespaces are needed in the future, a registry for those namespaces should be created and should be defined in a future document. All namespaces defined in such a document should then also be assigned to the registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的なマルチキャストAPIの概念は、4.2.1項で定義されたスーパーセットの構文に準拠して任意の名前空間が可能になります。この文書は、セクション4.2.3と4.2.4でマルチキャスト名前空間の基本的なセットを指定します。追加の名前空間は、将来的に必要とされている場合は、これらの名前空間のレジストリを作成する必要がありますし、将来の文書で定義する必要があります。そのような文書で定義されたすべての名前空間は、その後も、レジストリに割り当てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Additional Abstract Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。追加の抽象データ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. Interface
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1。インタフェース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Interface denotes the layer and instance on which the corresponding call takes effect. In agreement with [RFC3493], we identify an Interface by an identifier, which is a positive integer starting at 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インタフェースは、対応するコールが有効になるた層及びインスタンスを表します。 [RFC3493]と一致して、我々は、1から始まる正の整数識別子によってインタフェースを識別する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Properties of an Interface are stored in the following data structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターフェイスのプロパティは、次のようなデータ構造に格納されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct ifProp {
         UnsignedInt if_index; /* 1, 2, ... */
         String        *ifName;  /* &#34;eth0&#34;, &#34;eth1:1&#34;, &#34;lo&#34;, ... */
         String        *ifAddr;  /* &#34;1.2.3.4&#34;, &#34;abc123&#34;, ... */
         String        *ifTech;  /* &#34;ip&#34;, &#34;overlay&#34;, ... */
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following function retrieves all available Interfaces from the system:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の関数は、システムから利用可能なすべてのインターフェースを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
getInterfaces(out Interface &lt;ifs&gt;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でgetInterfaces（アウト・インタフェース&lt;IFS&gt;）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It extends the functions for Interface identification as defined in [RFC3493], Section 4 and can be implemented by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは[RFC3493]で定義されるように、インタフェース識別するための機能を拡張部4によって実現することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct ifProp(out IfProp &lt;ifsProps&gt;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造体ifProp（アウトIfProp &lt;ifsProps&gt;）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. Membership Events
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2。会員イベント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A membership event is triggered by a multicast state change that is observed by the current node. It is related to a specific Group Name and may be receiver or source oriented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
会員イベントは、現在のノードによって観測されたマルチキャスト状態変化によってトリガされます。これは、特定のグループ名に関連していると受信機またはソース配向させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       eventType {
               joinEvent;
               leaveEvent;
               newSourceEvent;
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       event {
              EventType event;
              Uri groupName;
              Interface if;
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An event will be created by the group communication stack and passed to applications that have registered for events.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
イベントは、グループ通信スタックによって作成されたイベントのために登録されたアプリケーションに渡されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Group Management Calls
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4。グループ管理コール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. Create
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1。作ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The create call initiates a multicast socket and provides the application programmer with a corresponding handle. If no Interfaces will be assigned based on the call, the default Interface will be selected and associated with the socket. The call returns an error code in the case of failures, e.g., due to non-operational communication middleware.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
作成呼び出しはマルチキャストソケットを開始し、対応するハンドルをアプリケーションプログラマが用意されています。何のインターフェイスはコールに基づいて割り当てられません場合は、デフォルトのインタフェースが選択され、ソケットに関連付けられます。コールは、非動作通信ミドルウェアに、例えば故障の場合にエラーコードを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       createMSocket(in Interface &lt;ifs&gt;,
                     out Socket s);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ifs argument denotes a list of Interfaces (if_indexes) that will be associated with the multicast socket. This parameter is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IFS引数はマルチキャストソケットに関連するインターフェイス（if_indexes）のリストを示しています。このパラメータはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, a multicast socket identifier is returned; otherwise, it is NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功した場合、マルチキャストソケット識別子が返されます。それ以外の場合はNULLです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2. Delete
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2。削除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The delete call removes the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
削除コールは、マルチキャストソケットを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
deleteMSocket(in Socket s, out Int error);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
deleteMSocket（ソケットS、intエラーアウト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s argument identifies the multicast socket for destruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数sは破壊のためのマルチキャストソケットを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.3. Join
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.3。加わります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The join call initiates a subscription for the given Group Name. Depending on the Interfaces that are associated with the socket, this may result in an IGMP / Multicast Listener Discovery (MLD) report or overlay subscription, for example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参加の呼び出しは、与えられたグループ名のサブスクリプションを開始します。ソケットに関連付けられているインタフェースに応じて、これは例えば、IGMP /マルチキャストリスナ発見（MLD）レポートまたはオーバーレイサブスクリプションをもたらすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
join(in Socket s, in Uri groupName, out Int error);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参加（ウリグループ名には、ソケットの中に、intエラーアウト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s argument identifies the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数sは、マルチキャストソケットを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupName argument identifies the group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名の引数には、グループを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.4. Leave
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.4。去ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The leave call results in an unsubscription for the given Group Name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
与えられたグループ名のために退会で休暇通話結果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
leave(in Socket s, in Uri groupName, out Int error);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
残す（URIグループ名で、ソケットSに、intエラーアウト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s argument identifies the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数sは、マルチキャストソケットを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupName argument identifies the group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名の引数には、グループを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.5. Source Register
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.5。ソースの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The srcRegister call registers a source for a group on all active Interfaces of the socket s. This call may assist group distribution in some technologies -- for example, the creation of sub-overlays -- or may facilitate a name-to-address mapping. Likewise, it may remain without effect in some multicast technologies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
srcRegisterコールはソケットSのすべてのアクティブインターフェイスのグループのソースを登録します。この呼び出しは、いくつかの技術のグループの配布を支援すること - 例えば、サブオーバーレイの作成 - または名前とアドレスのマッピングを容易にすることができます。同様に、それはいくつかのマルチキャスト技術に影響を与えずに残ることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       srcRegister(in Socket s, in Uri groupName,
                   out Interface &lt;ifs&gt;, out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s argument identifies the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数sは、マルチキャストソケットを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupName argument identifies the Multicast Group to which a source intends to send data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名の引数は、ソースがデータを送信しようとどのマルチキャストグループを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ifs argument points to the list of Interface indexes for which the source registration failed. A NULL pointer is returned if the list is empty. This parameter is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースの登録が失敗したインターフェイスインデックスのリストにIFS引数ポイント。リストが空の場合はNULLポインタが返されます。このパラメータはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If source registration succeeded for all Interfaces associated with the socket, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースの登録がソケットに関連付けられているすべてのインターフェイスのために成功した場合は、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.6. Source Deregister
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.6。ソース登録解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The srcDeregister call indicates that a source no longer intends to send data to the Multicast Group. This call may remain without effect in some multicast technologies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
srcDeregisterコールは、ソースがもはやマルチキャストグループにデータを送信しようとしていることを示していません。この呼び出しは、いくつかのマルチキャスト技術に影響を与えずに残ることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       srcDeregister(in Socket s, in Uri groupName,
                     out Interface &lt;ifs&gt;, out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s argument identifies the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数sは、マルチキャストソケットを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupName argument identifies the Multicast Group to which a source has stopped sending multicast data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名の引数は、ソースがマルチキャストデータの送信を停止したマルチキャストグループを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ifs argument points to the list of Interfaces for which the source deregistration failed. A NULL pointer is returned if the list is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソース登録解除に失敗したインタフェースのリストにIFS引数ポイント。リストが空の場合はNULLポインタが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If source deregistration succeeded for all Interfaces associated with the socket, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソース登録解除はソケットに関連付けられているすべてのインターフェイスのために成功した場合は、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Send and Receive Calls
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5。通話を送受信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. Send
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1。送ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The send call passes multicast data destined for a Multicast Name from the application to the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信呼び出しは、マルチキャストソケットへのアプリケーションからマルチキャスト名前宛てのマルチキャストデータを渡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is worth noting that it is the choice of the programmer to send data via one socket per group or to use a single socket for multiple groups.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループごとに1つのソケットを介してデータを送信したり、複数のグループのための単一のソケットを使用するプログラマの選択であることは注目に値します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       send(in Socket s, in Uri groupName,
            in Size msgLen, in Msg msgBuf,
            out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s argument identifies the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数sは、マルチキャストソケットを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupName argument identifies the group to which data will be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名の引数は、データが送信されますするグループを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The msgLen argument holds the length of the message to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さmsglen引数は、送信するメッセージの長さを保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The msgBuf argument passes the multicast data to the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MSGBUF引数は、マルチキャストソケットへのマルチキャストデータを渡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned. A message that is too long is indicated by an implementation-specific error code (e.g., EMSGSIZE in C).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。長すぎるメッセージは、実装固有のエラーコード（Cで例えば、EMSGSIZE）で示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. Receive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2。受け取ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The receive call passes multicast data and the corresponding Group Name to the application. This may come in a blocking or non-blocking variant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信呼び出しは、マルチキャストデータやアプリケーションに対応するグループ名を渡します。これは、ブロッキングまたは非ブロッキングバリアントで来るかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is worth noting that it is the choice of the programmer to receive data via one socket per group or to use a single socket for multiple groups.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループごとに1つのソケットを介してデータを送受信したり、複数のグループのための単一のソケットを使用するプログラマの選択であることは注目に値します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       receive(in Socket s, out Uri groupName,
               out Size msgLen, out Msg msgBuf,
               out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s argument identifies the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数sは、マルチキャストソケットを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupName argument identifies the Multicast Group for which data was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名の引数は、データが受信されたマルチキャストグループを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The msgLen argument holds the length of the received message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さmsglen引数は、受信したメッセージの長さを保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The msgBuf argument points to the payload of the received multicast data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信したマルチキャストデータのペイロードにMSGBUF引数ポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned. A message that is too long is indicated by an implementation-specific error code (e.g., EMSGSIZE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。長すぎるメッセージは、実装固有のエラーコード（例えば、EMSGSIZE）で示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Socket Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6。ソケットオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following calls configure an existing multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の呼び出しは、既存のマルチキャストソケットを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. Get Interfaces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1。インタフェースを取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The getInterfaces call returns an array of all available multicast communication Interfaces associated with the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でgetInterfacesマルチキャストソケットに関連付けられたすべての利用可能なマルチキャスト通信インターフェースのアレイリターンを呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       getInterfaces(in Socket s,
                     out Interface &lt;ifs&gt;, out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s argument identifies the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数sは、マルチキャストソケットを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ifs argument points to an array of Interface index identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターフェイスインデックス識別子の配列にIFS引数ポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. Add Interface
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2。インタフェースを追加
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The addInterface call adds a distribution channel to the socket. This may be an overlay or underlay Interface, e.g., IPv6 or Distributed Hash Table (DHT). Multiple Interfaces of the same technology may be associated with the socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
addInterfaceコールは、ソケットに流通チャネルを追加します。これは、オーバーレイまたはアンダーレイ・インタフェース、例えば、IPv6の又は分散ハッシュテーブル（DHT）であってもよいです。同じ技術の複数のインタフェースはソケットに関連することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       addInterface(in Socket s, in Interface if,
                    out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s and if arguments identify a multicast socket and Interface, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
sおよび引数はそれぞれ、マルチキャストソケットおよびインターフェイスを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the value 0 is returned; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功した場合、値0が返されます。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. Delete Interface
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3。インターフェイスを削除します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The delInterface call removes the Interface from the multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
delInterfaceコールは、マルチキャストソケットからインターフェイスを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       delInterface(in Socket s, Interface if,
                    out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s and if arguments identify a multicast socket and Interface, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
sおよび引数はそれぞれ、マルチキャストソケットおよびインターフェイスを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4. Set TTL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4。 TTLを設定します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The setTTL call configures the maximum hop count for the socket that a multicast message is allowed to traverse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
setTTLコールは、マルチキャストメッセージが通過することを許可されているソケットの最大ホップカウントを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       setTTL(in Socket s, in Int h,
              in Interface &lt;ifs&gt;,
              out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s and h arguments identify a multicast socket and the maximum hop count, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
S及びH引数はそれぞれ、マルチキャストソケットと最大ホップカウントを識別する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ifs argument points to an array of Interface index identifiers. This parameter is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターフェイスインデックス識別子の配列にIFS引数ポイント。このパラメータはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.5. Get TTL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.5。 TTLを取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The getTTL call returns the maximum hop count that a multicast message is allowed to traverse for the interface bound to the socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
getTTLコールは、マルチキャストメッセージがソケットにバインドされたインターフェースのために通過することを許可される最大ホップ数を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       getTTL(in Socket s, in Interface if,
              out Int h, out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The s argument identifies a multicast socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数sは、マルチキャストソケットを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The if argument identifies an interface that is bound to socket s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし引数がsをソケットにバインドされたインターフェイスを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The h argument holds the maximum number of hops associated with the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
H引数は、インターフェイスに関連付けられたホップの最大数を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.6. Atomic Message Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.6。アトミックメッセージサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The getAtomicMsgSize function returns the maximum message size that an application is allowed to transmit per socket at once without fragmentation. This value depends on the Interfaces associated with the socket in use and thus may change during runtime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
getAtomicMsgSize関数は、アプリケーションが断片化することなく、一度にソケット当たりの送信を許可された最大メッセージサイズを返します。この値は、使用中のソケットに関連付けられたインタフェースに依存し、したがって、実行時に変更されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       getAtomicMsgSize(in Socket s,
                        out Int return);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the function returns a positive value of appropriate message size; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、関数は、適切なメッセージサイズの正の値を返します。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. Service Calls
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7。サービスコール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.1. Group Set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.1。グループセット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupSet call returns all Multicast Groups registered at a given Interface. This information can be provided by group management states or routing protocols. The return values distinguish between sender and listener states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループセットのコールは、指定されたインターフェイスで登録されているすべてのマルチキャストグループを返します。この情報は、グループ管理状態またはルーティングプロトコルによって提供することができます。戻り値は、送信者とリスナーの状態を区別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct GroupSet {
         Uri groupName; /* registered Multicast Group */
         Int type;       /* 0 = listener state, 1 = sender state,
                            2 = sender and listener state */
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
groupSet(in Interface if, out GroupSet &lt;groupSet&gt;, out Int error);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループセット（インターフェースであれば、グループセット&lt;グループセット&gt;アウト、intエラーアウト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The if argument identifies the Interface for which states are maintained.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし引数は、状態が維持されるためのインターフェイスを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupSet argument points to a list of group states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループセットの引数には、グループの状態のリストを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.2. Neighbor Set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.2。ネイバーセット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The neighborSet function returns the set of neighboring nodes for a given Interface as seen by the multicast routing protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
neighborSet機能は、マルチキャストルーティングプロトコルによって見られるように所定のインターフェイスのための隣接ノードのセットを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       neighborSet(in Interface if,
                   out Uri &lt;neighborsAddresses&gt;, out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The if argument identifies the Interface for which information regarding neighbors is requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし引数ネイバーに関する情報が要求されているインターフェイスを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The neighborsAddresses argument points to a list of neighboring nodes on a successful return.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功したリターンの隣接ノードのリストにneighborsAddresses引数ポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.3. Children Set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.3。子どもを設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The childrenSet function returns the set of child nodes that receive multicast data from a specified Interface for a given group. For a common multicast router, this call retrieves the multicast forwarding information base per Interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
childrenSet関数は、指定されたグループのために指定されたインタフェースからマルチキャストデータを受信する子ノードのセットを返します。共通のマルチキャストルータの場合、この呼び出しは、インタフェースごとのマルチキャスト転送情報ベースを検索します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       childrenSet(in Interface if, in Uri groupName,
                   out Uri &lt;childrenAddresses&gt;, out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The if argument identifies the Interface for which information regarding children is requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし引数は、子供に関する情報が要求されているインターフェイスを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupName argument defines the Multicast Group for which distribution is considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名の引数は、分布を考慮したマルチキャストグループを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The childrenAddresses argument points to a list of neighboring nodes on a successful return.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功リターンで、隣接ノードのリストにchildrenAddresses引数ポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.4. Parent Set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.4。母集団
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The parentSet function returns the set of neighbors from which the current node receives multicast data at a given Interface for the specified group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
parentSet関数は、現在のノードが指定されたグループの特定のインターフェイスにマルチキャストデータを受信し、そこから近隣のセットを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       parentSet(in Interface if, in Uri groupName,
                 out Uri &lt;parentsAddresses&gt;, out Int error);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The if argument identifies the Interface for which information regarding parents is requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし引数両親に関する情報が要求されているインターフェイスを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupName argument defines the Multicast Group for which distribution is considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名の引数は、分布を考慮したマルチキャストグループを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The parentsAddresses argument points to a list of neighboring nodes on a successful return.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功したリターンの隣接ノードのリストにparentsAddresses引数ポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the out parameter error is 0; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5. Designated Host
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5。指定されたホスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The designatedHost function inquires about whether this host has the role of a designated forwarder (or querier), or not. Such information is provided by almost all multicast protocols to prevent packet duplication, if multiple multicast instances provide service on the same subnet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
designatedHost機能は、このホストが指定フォワーダ（またはクエリア）の役割を持っているか、いないかどうかを問い合わせます。このような情報は、複数のマルチキャストのインスタンスが同じサブネット上のサービスを提供する場合、パケットの重複を防ぐために、ほとんどすべてのマルチキャストプロトコルによって提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       designatedHost(in Interface if, in Uri groupName
                      out Int return);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The if argument identifies the Interface for which information regarding designated forwarding is requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし引数が指定された転送に関する情報を要求されたインターフェイスを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The groupName argument specifies the group for which the host may attain the role of designated forwarder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ名の引数は、ホストが指定フォワーダの役割を達成する可能性があるためにグループを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The function returns 1 if the host is a designated forwarder or querier. The return value -1 indicates an error. Otherwise, 0 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストが指定フォワーダまたはクエリアである場合、関数は1を返します。戻り値が-1のエラーを示します。それ以外の場合は、0が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.6. Enable Membership Events
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.6。メンバーシップのイベントを有効にします
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The enableEvents function registers an application at the group communication stack to receive information about group changes. State changes are the result of new receiver subscriptions or leaves, as well as source changes. Upon receiving an event, the group service may obtain additional information from further service calls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enableEvents関数は、グループの変更に関する情報を受信するグループ通信スタックでアプリケーションを登録します。状態の変化は、新たな受信機のサブスクリプションまたは葉と同様に、ソースの変更の結果です。イベントを受信すると、グループサービスはさらに、サービス呼び出しから追加情報を得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enableEvents();
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enableEvents（）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Calling this function, the stack starts to pass membership events to the application. Each event includes an event type identifier and a Group Name (cf. Section 4.3.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この関数を呼び出すと、スタックは、アプリケーションへのメンバーシップのイベントを渡すように開始します。各イベントは、イベントタイプ識別子とグループ名（参照セクション4.3.2）を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The multicast protocol does not have to support membership tracking in order to enable this feature. This function can also be implemented at the middleware layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストプロトコルは、この機能を有効にするためには、会員の追跡をサポートする必要はありません。この機能は、ミドルウェア層で実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.7. Disable Membership Events
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.7。メンバーシップのイベントを無効にします
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The disableEvents function deactivates the information about group state changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
disableEvents機能は、グループの状態の変化に関する情報を無効にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
disableEvents();
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
disableEvents（）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the stack will not pass membership events to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功した場合、スタックは、アプリケーションへのメンバーシップのイベントを渡しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.8. Maximum Message Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.8。最大メッセージサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The getMaxMsgSize function returns the maximum message size that an application is allowed to transmit per socket at once. This value is statically guaranteed by the group communication stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
getMaxMsgSize関数は、アプリケーションが一度にソケット当たりの送信を許可された最大メッセージサイズを返します。この値は、静的グループ通信スタックによって保証されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
getMaxMsgSize(out Int return);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
getMaxMsgSize（のIntリターンアウト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On success, the function returns a positive value of allowed message size; otherwise, -1 is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成功すると、関数は、許可メッセージサイズの正の値を返します。それ以外の場合は、-1が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Implementation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A reference implementation of the Common API for Transparent Hybrid Multicast is available with the HAMcast stack [HAMcast-DEV] [GC2010] [LCN2012]. This open-source software supports the multicast API (C++ and Java library) for group application development, the middleware as a user space system service, and several multicast-technology modules. The middleware is implemented in C++.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
透明ハイブリッドマルチキャストのための共通APIのリファレンス実装は、[LCN2012] [GC2010] HAMcastスタック[HAMcast-DEV]で利用可能です。このオープンソースソフトウェアは、グループのアプリケーション開発のためのマルチキャストAPI（C ++およびJavaライブラリ）をサポートし、ユーザー空間のシステムサービス、およびいくつかのマルチキャスト技術モジュールとしてミドルウェア。ミドルウェアは、C ++で実装されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This API is verified and adjusted based on the real-world experiences gathered in the HAMcast project, and by additional users of the stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このAPIは、HAMcastプロジェクトでは、スタックの追加のユーザーによって収集された実世界の経験に基づいて検証し、調整されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies the &#34;ham&#34; URI scheme that has been registered by IANA as one of the &#34;Provisional URI Schemes&#34; according to [RFC4395].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、「ハム」[RFC4395]によれば、「仮URIスキーム」の一つとして、IANAによって登録されたURIスキームを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
URI scheme name ham
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIのスキーム名のハム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status provisional
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
仮ステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
URI scheme syntax See Section 4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIスキームの構文は、4.2.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
URI scheme semantics See Section 4.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIスキームのセマンティクスは、セクション4.2.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Encoding See Section 4.2.1 considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンコードを参照してくださいセクション4.2.1考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Applications/protocols The scheme is used by multicast applications that use this URI to access multicast content. scheme name
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション/スキームは、マルチキャストコンテンツにアクセスするには、このURIを使用して、マルチキャストアプリケーションで使用されるプロトコル。スキーム名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Interoperability None considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
相互運用性なし注意事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Security See Section 7. considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティを参照してくださいセクション7.注意事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Contact Matthias Waehlisch, mw@link-lab.net
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
連絡先マティアスWählisch、mw@link-lab.net
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Author/Change IRTF controller
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者/変更IRTFコントローラ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
References As specified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書で指定されているように参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document does not introduce additional messages or novel protocol operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、追加のメッセージまたは新しいプロトコルオペレーションを導入しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We would like to thank the HAMcast team at the HAW Hamburg -- Nora Berg, Gabriel Hege, Fabian Holler, Alexander Knauf, Sebastian Meiling, Sebastian Woelke, and Sebastian Zagaria -- for many fruitful discussions and for their continuous critical feedback while implementing the common multicast API and hybrid multicast middleware. Special thanks to Dominik Charousset of the HAMcast team for in-depth perspectives on the matter of code. We gratefully acknowledge WeeSan, Mario Kolberg, and John Buford for reviewing and their suggestions to improve the document. We would like to thank the Name-Based Socket BoF (in particular Dave Thaler) for clarifying insights into the question of meta-function calls. We thank Lisandro Zambenedetti Granville and Tony Li for very careful reviews of the pre-final versions of this document. Barry Leiba and Graham Klyne provided very constructive input to find a suitable URI scheme. They are gratefully acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ノラベルク、ガブリエルHEGE、ファビアン大声、アレクサンダークナウフ、セバスチャン美鈴、セバスチャンWoelke、とセバスチャンZagaria  -   - 私たちは、HAWハンブルクでHAMcastチームに感謝したい実装しながら、多くの実りある議論をし、その継続的な批判的なフィードバックのために一般的なマルチキャストAPIとハイブリッドマルチキャストミドルウェア。コードの問題に関する詳細な視点用HAMcastチームのドミニクCharoussetに感謝します。我々は感謝して、ドキュメントを改善するために検討し、その提案をWeeSan、マリオKOLBERG、そしてジョン・ビュフォードを認めます。私たちは、メタ関数呼び出しの問題に洞察を明確にするために（特にデーブターラーで）名前ベースソケットのBoFに感謝したいと思います。私たちは、この文書の前の最終バージョンの非常に慎重なレビューのためにリサンドロZambenedettiグランビルとトニー李に感謝します。バリー・レイバとグラハムKlyneは、適切なURIスキームを見つけることは非常に建設的な入力を提供します。彼らは深く感謝しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This work is partially supported by the German Federal Ministry of Education and Research within the HAMcast project (see &lt;http://hamcast.realmv6.org&gt;), which is part of G-Lab.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この作業は、部分的にG-ラボの一部であるHAMcastプロジェクト内の教育研究のドイツ連邦環境省（&lt;http://hamcast.realmv6.org&gt;参照）、によってサポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1075] Waitzman, D., Partridge, C., and S. Deering, &#34;Distance Vector Multicast Routing Protocol&#34;, RFC 1075, November 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1075] Waitzman、D.、ヤマウズラ、C.、およびS.デアリング、 &#34;距離ベクトルマルチキャストルーティングプロトコル&#34;、RFC 1075、1988年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2710] Deering, S., Fenner, W., and B. Haberman, &#34;Multicast Listener Discovery (MLD) for IPv6&#34;, RFC 2710, October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2710]デアリング、S.、フェナー、W.、およびB.ハーバーマン、 &#34;IPv6のためのマルチキャストリスナー発見（MLD）&#34;、RFC 2710、1999年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &#34;SIP: Session Initiation Protocol&#34;, RFC 3261, June 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 &#34;SIP：セッション開始プロトコル&#34; 、RFC 3261、2002年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3376] Cain, B., Deering, S., Kouvelas, I., Fenner, B., and A. Thyagarajan, &#34;Internet Group Management Protocol, Version 3&#34;, RFC 3376, October 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3376]カイン、B.、デアリング、S.、Kouvelas、I.、フェナー、B.、およびA. Thyagarajan、 &#34;インターネットグループ管理プロトコル、バージョン3&#34;、RFC 3376、2002年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &#34;Basic Socket Interface Extensions for IPv6&#34;, RFC 3493, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3493]ギリガン、R.、トムソン、S.、バウンド、J.、マッキャン、J.、およびW.スティーブンス、 &#34;IPv6の基本的なソケットインタフェース拡張&#34;、RFC 3493、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3678] Thaler, D., Fenner, B., and B. Quinn, &#34;Socket Interface Extensions for Multicast Source Filters&#34;, RFC 3678, January 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3678]ターラー、D.、フェナー、B.、およびB.クイン、RFC 3678 &#34;マルチキャストソースフィルタのためのソケットインタフェース拡張&#34;、2004年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3810] Vida, R. and L. Costa, &#34;Multicast Listener Discovery Version 2 (MLDv2) for IPv6&#34;, RFC 3810, June 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;IPv6のマルチキャストリスナ発見バージョン2（MLDv2の）&#34; [RFC3810]ヴィーダ、R.とL.コスタ、RFC 3810、2004年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, January 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 &#34;ユニフォームリソース識別子（URI）：汎用構文&#34;、STD 66、RFC 3986、2005年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4395] Hansen, T., Hardie, T., and L. Masinter, &#34;Guidelines and Registration Procedures for New URI Schemes&#34;, BCP 35, RFC 4395, February 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4395]ハンセン、T.、ハーディ、T.、およびL. Masinter、 &#34;新しいURIスキームのためのガイドラインと登録手順&#34;、BCP 35、RFC 4395、2006年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4601] Fenner, B., Handley, M., Holbrook, H., and I. Kouvelas, &#34;Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)&#34;, RFC 4601, August 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4601]フェナー、B.、ハンドリー、M.、ホルブルック、H.、およびI. Kouvelas、 &#34;プロトコル独立マルチキャスト - スパースモード（PIM-SM）：プロトコル仕様（改訂）&#34;、RFC 4601、2006年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4604] Holbrook, H., Cain, B., and B. Haberman, &#34;Using Internet Group Management Protocol Version 3 (IGMPv3) and Multicast Listener Discovery Protocol Version 2 (MLDv2) for Source-Specific Multicast&#34;, RFC 4604, August 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4604]ホルブルック、H.、カイン、B.、およびB.ハーバーマン、 &#34;ソース固有マルチキャストのためにインターネットグループ管理プロトコルバージョン3（IGMPv3の）およびマルチキャストリスナ発見プロトコルバージョン2（MLDv2の）の使用&#34;、RFC 4604、8月2006。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5015] Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, &#34;Bidirectional Protocol Independent Multicast (BIDIR-PIM)&#34;, RFC 5015, October 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5015]ハンドレー、M.、Kouvelas、I.、スピークマン、T.、およびL. Vicisano、 &#34;双方向プロトコル独立マルチキャスト（BIDIR-PIM）&#34;、RFC 5015、2007年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5058] Boivie, R., Feldman, N., Imai, Y., Livens, W., and D. Ooms, &#34;Explicit Multicast (Xcast) Concepts and Options&#34;, RFC 5058, November 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5058] Boivie、R.、フェルドマン、N.、今井、Y.、Livens、W.、およびD. Ooms、 &#34;明示的なマルチキャスト（のXcast）の概念とオプション&#34;、RFC 5058、2007年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5234] Crocker, D. and P. Overell, &#34;Augmented BNF for Syntax Specifications: ABNF&#34;, STD 68, RFC 5234, January 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5234]クロッカー、D.、およびP. Overell、 &#34;構文仕様のための増大しているBNF：ABNF&#34;、STD 68、RFC 5234、2008年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6920] Farrell, S., Kutscher, D., Dannewitz, C., Ohlman, B., Keranen, A., and P. Hallam-Baker, &#34;Naming Things with Hashes&#34;, RFC 6920, April 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6920]ファレル、S.、Kutscher、D.、Dannewitz、C.、Ohlman、B.、Keranen、A.、およびP.ハラム・ベーカー、 &#34;ハッシュで物事を命名&#34;、RFC 6920、2013年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AMT] Bumgardner, G., &#34;Automatic Multicast Tunneling&#34;, Work in Progress, October 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AMT] Bumgardner、G.、 &#34;自動マルチキャストトンネリング&#34;、進歩、2013年10月に作業します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[GC2010] Meiling, S., Charousset, D., Schmidt, T., and M. Waehlisch, &#34;System-assisted Service Evolution for a Future Internet - The HAMcast Approach to Pervasive Multicast&#34;, Proc. IEEE GLOBECOM 2010 Workshops, MCS 2010, pp. 913-917, Piscataway, NJ, USA, IEEE Press, December 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【GC2010]美鈴、S.、Charousset、D.、シュミット、T。、およびM. Waehlisch、「システム支援次世代のインターネットサービス進化 - パーベイシブマルチキャストにHAMcastアプローチ」、PROC。 IEEEのGLOBECOM 2010ワークショップ、MCS 2010、頁913から917、ピスカタウェイ、NJ、USA、IEEEプレス、2010年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HAMcast-DEV] &#34;HAMcast developers&#34;, &lt;http://hamcast.realmv6.org/developers&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HAMcast-DEV] &#34;HAMcastの開発&#34;、&lt;http://hamcast.realmv6.org/developers&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[LCN2012] Meiling, S., Schmidt, T., and M. Waehlisch, &#34;Large-Scale Measurement and Analysis of One-Way Delay in Hybrid Multicast Networks&#34;, Proc. 37th Annual IEEE Conference on Local Computer Networks (LCN 2012), Piscataway, NJ, USA, IEEE Press, October 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【LCN2012]美鈴、S.、シュミット、T。、およびM. Waehlisch、PROC「ハイブリッドマルチキャストネットワークにおける一方向遅延の大規模測定と分析」。第37回IEEEローカルコンピュータネットワーク上の会議（2012 LCN）、ピスカタウェイ、NJ、USA、IEEEプレス、2012年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MCAST-v4v6] Venaas, S., Asaeda, H., SUZUKI, S., and T. Fujisaki, &#34;An IPv4 - IPv6 multicast translator&#34;, Work in Progress, December 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MCAST-v4v6] Venaas、S.、Asaeda、H.、SUZUKI、S.、およびT.藤崎 &#34;のIPv4  -  IPv6マルチキャスト翻訳&#34;、進歩、2010年12月ワーク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MCAST-v4v6-FRAMEWORK] Venaas, S., Li, X., and C. Bao, &#34;Framework for IPv4/IPv6 Multicast Translation&#34;, Work in Progress, June 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MCAST-v4v6-FRAMEWORK] Venaas、S.、リチウム、X.、及びC.バオ、進歩、2011年6月仕事 &#34;のIPv4 / IPv6マルチキャスト翻訳のためのフレームワーク&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RELOAD] Jennings, C., Lowekamp, B., Ed., Rescorla, E., Baset, S., and H. Schulzrinne, &#34;REsource LOcation And Discovery (RELOAD) Base Protocol&#34;, Work in Progress, February 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[リロード]ジェニングス、C.、Lowekamp、B.、編。、レスコラ、E.、BASET、S.、およびH. Schulzrinneと、 &#34;リソースロケーションと発見（リロード）ベースプロトコル&#34;、進歩、2013年2月に働いています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5757] Schmidt, T., Waehlisch, M., and G. Fairhurst, &#34;Multicast Mobility in Mobile IP Version 6 (MIPv6): Problem Statement and Brief Survey&#34;, RFC 5757, February 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5757]シュミット、T.、Waehlisch、M.、およびG. Fairhurst、 &#34;モバイルIPバージョン6におけるマルチキャストモビリティ（MIPv6の）問題文と簡単な調査&#34;、RFC 5757、2010年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6219] Li, X., Bao, C., Chen, M., Zhang, H., and J. Wu, &#34;The China Education and Research Network (CERNET) IVI Translation Design and Deployment for the IPv4/IPv6 Coexistence and Transition&#34;, RFC 6219, May 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6219]のLi、X.、バオ、C.、チェン、M.、チャン、H.、及びJ.ウー、「中国教育研究ネットワーク（CERNET）のIPv4 / IPv6の共存のためのIVI翻訳設計および展開とトランジション」、RFC 6219、2011年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7019] Buford, J. and M. Kolberg, &#34;Application-Layer Multicast Extensions to REsource LOcation And Discovery (RELOAD)&#34;, RFC 7019, September 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7019]ビュ、J.とM. KOLBERG、 &#34;アプリケーションレイヤリソースロケーションとディスカバリー（リロード）にマルチキャスト拡張&#34;、RFC 7019、2013年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SIP-RELOAD] Jennings, C., Lowekamp, B., Rescorla, E., Baset, S., Schulzrinne, H., and T. Schmidt, Ed., &#34;A SIP Usage for RELOAD&#34;, Work in Progress, July 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SIPリロード]ジェニングス、C.、Lowekamp、B.、レスコラ、E.、BASET、S.、Schulzrinneと、H.、およびT.シュミット、エド。、 &#34;リロードのSIPの使用&#34;、進行中で働いて、 2013年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. C Signatures
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A. C署名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes the C signatures of the common multicast API (Section 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、共通のマルチキャストAPI（第4）のCシグネチャを記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       int createMSocket(int* result, size_t num_ifs,
                         const uint32_t* ifs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int deleteMSocket(int s);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型deleteMSocket（int型秒）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int join(int msock, const char* group_uri);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型（int型msock、CONSTのchar * group_uri）に参加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int leave(int msock, const char* group_uri);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型の休暇（int型msock、CONST文字* group_uri）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int srcRegister(int msock, const char* group_uri, size_t num_ifs, uint32_t* ifs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
INT srcRegister（INT msock、CONSTするchar * group_uri、size_tのnum_ifs、のuint32_t * IFS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int srcDeregister(int msock, const char* group_uri, size_t num_ifs, uint32_t* ifs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
INT srcDeregister（INT msock、CONSTするchar * group_uri、size_tのnum_ifs、のuint32_t * IFS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int send(int msock, const char* group_uri, size_t buf_len, const void* buf);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型の送信（int型msock、CONSTするchar * group_uri、size_tのはbuf_len、CONST void *型BUF）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int receive(int msock, const char* group_uri, size_t buf_len, void* buf);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型（int型msock、CONSTするchar * group_uri、size_tのはbuf_len、void *型BUF）を受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int getInterfaces(int msock, size_t* num_ifs, uint32_t** ifs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型でgetInterfaces（int型msock、size_t型* num_ifs、のuint32_t ** IFS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int addInterface(int msock, uint32_t iface);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型addInterface（int型msock、のuint32_tのiface）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int delInterface(int msock, uint32_t iface);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型delInterface（int型msock、のuint32_tのiface）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int setTTL(int msock, uint8_t value, size_t num_ifs, uint32_t* ifs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
INT setTTL（INT msock、uint8_t値、size_tのnum_ifs、のuint32_t * IFS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int getTTL(int msock, uint8_t* result);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型getTTL（int型msock、uint8_t *結果）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int getAtomicMsgSize(int msock);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型getAtomicMsgSize（int型msock）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       typedef struct {
           char* group_uri; /* registered mcast group */
           int type; /* 0: listener state
                        1: sender state
                        2: sender and listener state */
       }
       GroupSet;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int groupSet(uint32_t iface, size_t* num_groups, GroupSet** groups);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型グループセット（のuint32_tのifaceの、size_t型* num_groups、GROUPSET **グループ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int neighborSet(uint32_t iface, const char* group_name, size_t* num_neighbors, char** neighbor_uris);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型neighborSet（のuint32_tのiface、CONSTするchar * group_nameに、size_t型* num_neighbors、CHAR ** neighbor_uris）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int childrenSet(uint32_t iface, const char* group_name, size_t* num_children, char** children_uris);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型childrenSet（のuint32_tのiface、CONSTするchar * group_nameに、size_t型* num_children、CHAR ** children_uris）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int parentSet(uint32_t iface, const char* group_name, size_t* num_parents, char** parents_uris);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型parentSet（のuint32_tのiface、CONSTするchar * group_nameに、size_t型* num_parents、CHAR ** parents_uris）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int designatedHost(uint32_t iface, const char* group_name);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型designatedHost（のuint32_tのiface、constのchar型* GROUP_NAME）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          typedef void (*MembershipEventCallback)
                                     (int,          /* event type   */
                                      uint32_t,     /* Interface id */
                                      const char*); /* group uri    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int registerEventCallback(MembershipEventCallback callback);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型registerEventCallback（MembershipEventCallbackコールバック）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int enableEvents();
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enableEventsをint型（）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int disableEvents();
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
disableEventsをint型（）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int getMaxMsgSize();
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
int型getMaxMsgSize（）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B. Use Case for the API
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
API付録B.ユースケース
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the sake of readability, we demonstrate development of applications using the API based on a high-level Java-like syntax; we do not consider error handling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読みやすさのために、我々は、高レベルのJavaに似た構文に基づいたAPIを使用したアプリケーションの開発を発揮します。我々は、エラー処理を考慮していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
-- Application above middleware:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ミドルウェア上でアプリケーション：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     //Initialize multicast socket;
     //the middleware selects all available Interfaces
     MulticastSocket m = new MulticastSocket();
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     m.join(URI(&#34;ham:ip:224.1.2.3:5000&#34;));
     m.join(URI(&#34;ham:ip:[ff02:0:0:0:0:0:0:3]:6000&#34;));
     m.join(URI(&#34;ham:sip:news@cnn.com&#34;));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
-- Middleware:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ミドルウェア：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     join(URI mcAddress) {
       //Select Interfaces in use
       for all this.interfaces {
         switch (interface.type) {
           case &#34;ipv6&#34;:
             //... map logical ID to routing address
             Inet6Address rtAddressIPv6 = new Inet6Address();
             mapNametoAddress(mcAddress,rtAddressIPv6);
             interface.join(rtAddressIPv6);
           case &#34;ipv4&#34;:
             //... map logical ID to routing address
             Inet4Address rtAddressIPv4 = new Inet4Address();
             mapNametoAddress(mcAddress,rtAddressIPv4);
             interface.join(rtAddressIPv4);
           case &#34;sip-session&#34;:
             //... map logical ID to routing address
             SIPAddress rtAddressSIP = new SIPAddress();
             mapNametoAddress(mcAddress,rtAddressSIP);
             interface.join(rtAddressSIP);
           case &#34;dht&#34;:
             //... map logical ID to routing address
             DHTAddress rtAddressDHT = new DHTAddress();
             mapNametoAddress(mcAddress,rtAddressDHT);
             interface.join(rtAddressDHT);
            //...
         }
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix C. Deployment Use Cases for Hybrid Multicast
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハイブリッドマルチキャスト付録C.展開の使用事例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes the application of the defined API to implement an IMG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、IMGを実装するために定義されたAPIのアプリケーションを記述しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.1. DVMRP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.1。 DVMRP
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following procedure describes a transparent mapping of a DVMRP-based any-source multicast service to another many-to-many multicast technology, e.g., an overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の手順は、別の多対多マルチキャスト技術、例えば、オーバーレイにDVMRPベース任意ソースマルチキャストサービスの透明マッピングを記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An arbitrary Distance Vector Multicast Routing Protocol (DVMRP) [RFC1075] router will not be informed of new receivers but will learn about new sources immediately. The concept of DVMRP does not provide any central multicast instance. Thus, the IMG can be placed anywhere inside the multicast region, but the IMG requires a DVMRP neighbor connectivity. Thus, the group communication stack used by the IMG is enhanced by a DVMRP implementation. New sources in the underlay will be advertised based on the DVMRP flooding mechanism and received by the IMG. Based on this, the event &#34;new_source_event&#34; is created and passed to the application. The relay agent initiates a corresponding join in the native network and forwards the received source data towards the overlay routing protocol. Depending on the group states, the data will be distributed to overlay peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意の距離ベクトルマルチキャストルーティングプロトコル（DVMRP）[RFC1075]ルータは、新たな受信機が通知されることはありませんが、すぐに新しいソースについて学習します。 DVMRPの概念は、任意の中央マルチキャストインスタンスを提供していません。したがって、IMGは、マルチキャスト領域内の任意の場所に配置することができるが、IMGは、DVMRPネイバー接続を必要とします。したがって、IMGが使用するグループ通信スタックは、DVMRP実装によって増強されます。アンダーレイの新しいソースは、DVMRPの氾濫メカニズムに基づいており、IMGで受信したアドバタイズされます。これに基づき、イベント「new_source_event」が作成され、アプリケーションに渡されます。リレーエージェントは、対応するネイティブネットワークに参加を開始し、オーバーレイ・ルーティング・プロトコルに向かって受信したソースデータを転送します。グループの状態によっては、データがピアをオーバーレイするために配布されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DVMRP establishes source-specific multicast trees. Therefore, a graft message is only visible to DVMRP routers on the path from the new receiver subnet to the source, but in general not to an IMG. To overcome this problem, data of multicast senders in the overlay may become noticeable via the Source Register call, as well as by an IMG that initiates an all-group join in the overlay using the namespace extension of the API. Each IMG is initially required to forward the data received in the overlay to the underlay, independent of native multicast receivers. Subsequent prunes may limit unwanted data distribution thereafter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DVMRPは、ソース固有マルチキャストツリーを確立します。したがって、グラフトメッセージは、ソースへの新しい受信サブネットからの経路上のルータをDVMRPのみ可視であるが、一般的ではないIMGに。この問題を克服するために、オーバーレイマルチキャスト送信者のデータは、だけでなく、すべてのグループが、APIの名前空間拡張を使用してオーバーレイに参加開始IMGによってソース・レジスタの呼び出しを経由して顕著になることがあります。各IMGは、最初のネイティブマルチキャスト受信機とは独立して、アンダーレイにオーバーレイで受信したデータを転送する必要があります。後続のプルーンは、その後、不要なデータの配信を制限してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.2. PIM-SM
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.2。 DRINK-SM
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following procedure describes a transparent mapping of a PIM-SM-based any-source multicast service to another many-to-many multicast technology, e.g., an overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の手順は、別の多対多マルチキャスト技術、例えば、オーバーレイにPIM-SMベースの任意のソースマルチキャストサービスの透明マッピングを記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Protocol Independent Multicast - Sparse Mode (PIM-SM) [RFC4601] establishes rendezvous points (RPs). These entities receive listener subscriptions and source registering of a domain. For a continuous update, an IMG has to be co-located with an RP. Whenever PIM register messages are received, the IMG must signal internally a new multicast source using the event &#34;new_source_event&#34;. Subsequently, the IMG joins the group and a shared tree between the RP and the sources will be established; this shared tree may change to a source-specific tree after PIM switches to phase three. Source traffic will be forwarded to the RP based on the IMG join, even if there are no further receivers in the native Multicast Domain. Designated routers of a PIM domain send receiver subscriptions towards the PIM-SM RP. The reception of such messages initiates the event &#34;join_event&#34; at the IMG, which initiates a join towards the overlay routing protocol. Overlay multicast data arriving at the IMG will then be transparently forwarded in the underlay network and distributed through the RP instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコル独立マルチキャスト - スパースモード（PIM-SM）[RFC4601]は、ランデブーポイント（RPS）を確立します。これらのエンティティは、リスナーのサブスクリプションおよびドメインのソース登録を受けます。連続更新のために、IMGは、RP​​と同じ場所に配置する必要があります。 PIM登録メッセージを受信するたびに、IMGは内部イベント「new_source_event」を使用して、新しいマルチキャストソースを通知しなければなりません。その後、IMGは、グループに参加し、RPとソースとの間で共有ツリーが確立されます。 PIM三相に切り替えた後に、この共有ツリーは、ソース固有のツリーに変更することができます。元トラフィックは、ネイティブマルチキャストドメインには、さらに受信機が存在しない場合でも、参加IMGに基づいてRPに転送されます。 PIMドメインの指定ルータは、PIM-SM RPに向けレシーバサブスクリプションを送信します。そのようなメッセージの受信は、オーバーレイルーティングプロトコルに向かって参加開始IMG、でイベント「join_event」を開始します。 IMGに到着オーバレイマルチキャストデータは、透過アンダーレイネットワークで転送し、RPインスタンスを介して配布されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.3. PIM-SSM
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.3。 PIM-SSM
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following procedure describes a transparent mapping of a PIM-SSM-based source-specific multicast service to another one-to-many multicast technology, e.g., an overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の手順は、別の一対多マルチキャスト技術、例えば、オーバーレイにPIM-SSMベースのソース固有マルチキャストサービスの透明マッピングを記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIM Source-Specific Multicast (PIM-SSM) is defined as part of PIM-SM and admits source-specific joins (S,G) according to the source-specific host group model [RFC4604]. A multicast distribution tree can be established without the assistance of a rendezvous point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PIMソース固有マルチキャスト（PIM-SSM）は、PIM-SMの一部として定義され、ソース固有のを許可されたソース固有のホストグループモデル[RFC4604]に記載の（S、G）加入。マルチキャスト配信ツリーは、ランデブーポイントの援助なしに確立することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sources are not advertised within a PIM-SSM domain. Consequently, an IMG cannot anticipate the local join inside a sender domain and deliver a priori the multicast data to the overlay instance. If an IMG of a receiver domain initiates a group subscription via the overlay routing protocol, relaying multicast data fails, as data is not available at the overlay instance. The IMG instance of the receiver domain thus has to locate the IMG instance of the source domain to trigger the corresponding join. In agreement with the objectives of PIM-SSM, the signaling should not be flooded in the underlay and overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソースは、PIM-SSMのドメイン内に通知されていません。その結果、IMGは、ローカルの送信者ドメイン内の参加予測し、オーバーレイインスタンスに先験的マルチキャストデータを配信することはできません。レシーバドメインのIMGは、オーバーレイ・ルーティング・プロトコルを介して、グループ・サブスクリプションを開始する場合、データがオーバーレイ・インスタンスで利用できないように、マルチキャストデータを中継することは、失敗しました。レシーバドメインのIMGのインスタンスは、このように、対応する参加をトリガするために、ソースドメインのIMGインスタンスを見つけなければなりません。 PIM-SSMの目的と一致して、シグナリングは、アンダーレイとオーバーレイで浸水するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A solution can be to intercept the subscription at both source sites and receiver sites: To monitor multicast receiver subscriptions (&#34;join_event&#34; or &#34;leave_event&#34;) in the underlay, the IMG is placed on the path towards the source, e.g., at a domain border router. This router intercepts join messages and extracts the unicast source address S, initializing an IMG-specific join to S via regular unicast. Multicast data arriving at the IMG of the sender domain can be distributed via the overlay. Discovering the IMG of a multicast sender domain may be implemented analogously to Automatic Multicast Tunneling [AMT] by anycast. Consequently, the source address S of the group (S,G) should be built based on an anycast prefix. The corresponding IMG anycast address for a source domain is then derived from the prefix of S.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
溶液は、ソースサイトと受信サイトの両方でサブスクリプションを傍受することができる。下敷きにマルチキャスト受信サブスクリプション（「join_event」または「leave_event」）を監視するには、IMGは、ドメインに、例えば、ソースに向かって経路上に配置されます境界ルータ。このルータは、インターセプトは、メッセージを結合し、IMG-特定が通常のユニキャストを介してSに参加初期化、ユニキャスト送信元アドレスSを抽出します。送信者ドメインのIMGに到着するマルチキャストデータは、オーバーレイを介して配布することができます。マルチキャスト送信元ドメインのIMGを発見すると、エニーキャストによって自動マルチキャストトンネリング[AMT]と同様に実施することができます。したがって、グループ（S、G）のソースアドレスSは、エニーキャストプレフィックスに基づいて構築されなければなりません。ソースドメインの対応するIMGのエニーキャストアドレスは、Sのプレフィックスから導出され
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.4. BIDIR-PIM
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.4。 BIDIR-PIM
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following procedure describes a transparent mapping of a BIDIR-PIM-based any-source multicast service to another many-to-many multicast technology, e.g., an overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の手順は、別の多対多マルチキャスト技術、例えば、オーバーレイにBIDIR-PIMベースの任意のソースマルチキャストサービスの透明マッピングを記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bidirectional PIM [RFC5015] is a variant of PIM-SM. In contrast to PIM-SM, the protocol pre-establishes bidirectional shared trees per group, connecting multicast sources and receivers. The rendezvous points are virtualized in BIDIR-PIM as an address to identify on-tree directions (up and down). Routers with the best link towards the (virtualized) rendezvous point address are selected as designated forwarders for a link-local domain and represent the actual distribution tree. The IMG is to be placed at the RP link, where the rendezvous point address is located. As source data in either case will be transmitted to the RP link, the BIDIR-PIM instance of the IMG receives the data and can internally signal new senders towards the stack via the &#34;new_source_event&#34;. The first receiver subscription for a new group within a BIDIR-PIM domain needs to be transmitted to the RP to establish the first branching point. Using the &#34;join_event&#34;, an IMG will thereby be informed of group requests from its domain, which are then delegated to the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
双方向PIM [RFC5015]はPIM-SMの変異体です。 PIM-SMとは対照的に、プロトコルは、マルチキャスト送信元と受信機を接続し、グループごとに双方向共有ツリーを事前に確立します。ランデブーポイントは、オンツリー方向（上下）を識別するためのアドレスとしてBIDIR-PIMに仮想化されています。 （仮想）ランデブーポイントアドレスに向かって最高のリンクを持つルータはリンクローカルドメインの指定フォワーダとして選択され、実際の配信ツリーを表しています。 IMGは、ランデブーポイントのアドレスが配置されているRPリンク、に配置されます。いずれの場合も、ソースデータをRPリンクに送信されるように、IMGのBIDIR-PIMインスタンスは、データを受信し、内部「new_source_event」を介してスタックに向かって新しい送信者に信号を送ることができます。 BIDIR-PIMドメイン内の新しいグループの第1の受信機のサブスクリプションは、最初の分岐点を確立するために、RPに送信する必要があります。 「join_event」を使用して、IMGは、それによって、その後、オーバーレイに委任されているそのドメインからのグループ要求が通知されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Matthias Waehlisch link-lab &amp; FU Berlin Hoenower Str. 35 Berlin 10318 Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マティアスWählischリンク・ラボ＆FUベルリンHönowerのStr。35 10318ベルリンドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: mw@link-lab.net URI: http://www.inf.fu-berlin.de/~waehl
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電子メール：mw@link-lab.net URI：http://www.inf.fu-berlin.de/~waehl
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thomas C. Schmidt HAW Hamburg Berliner Tor 7 Hamburg 20099 Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トーマス・C.シュミットHAWハンブルクベルリナートア7 20099ハンブルクドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: schmidt@informatik.haw-hamburg.de URI: http://inet.cpt.haw-hamburg.de/members/schmidt
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電子メール：schmidt@informatik.haw-hamburg.de URI：http://inet.cpt.haw-hamburg.de/members/schmidt
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stig Venaas Cisco Systems Tasman Drive San Jose, CA 95134 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スティグVenaasシスコシステムズタスマン・ドライブサンノゼ、CA 95134 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: stig@cisco.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：stig@cisco.com
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
