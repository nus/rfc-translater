<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7413 - TCP Fast Open 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7413</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7413 - TCP Fast Open 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7413">
              https://tools.ietf.org/html/rfc7413
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7413 - TCP高速オープン</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                          Y. Cheng
Request for Comments: 7413                                        J. Chu
Category: Experimental                                  S. Radhakrishnan
ISSN: 2070-1721                                                  A. Jain
                                                                  Google
                                                           December 2014
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             TCP Fast Open
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes an experimental TCP mechanism called TCP Fast Open (TFO). TFO allows data to be carried in the SYN and SYN-ACK packets and consumed by the receiving end during the initial connection handshake, and saves up to one full round-trip time (RTT) compared to the standard TCP, which requires a three-way handshake (3WHS) to complete before data can be exchanged. However, TFO deviates from the standard TCP semantics, since the data in the SYN could be replayed to an application in some rare circumstances. Applications should not use TFO unless they can tolerate this issue, as detailed in the Applicability section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、TCP高速オープン（TFO）と呼ばれる実験的なTCPのメカニズムを説明しています。 TFOは、データがSYNおよびSYN-ACKパケットで運ばれ、最初の接続ハンドシェイク中に受信側によって消費されることを可能にし、三が必要標準TCP、と比較して1つの完全なラウンドトリップ時間（RTT）まで保存しデータが交換される前に完了するためのウェイハンドシェイク（3WHS）。 SYN内のデータは、いくつかのまれな状況でアプリケーションに再生される可能性があるのでしかし、TFOは、標準のTCPの意味から逸脱します。彼らはこの問題を許容することができない限り、適用性のセクションで説明するようにアプリケーションは、TFOを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7413.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7413で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................3
      1.1. Terminology ................................................4
   2. Data in SYN .....................................................4
      2.1. Relaxing TCP Semantics on Duplicated SYNs ..................4
      2.2. SYNs with Spoofed IP Addresses .............................5
   3. Protocol Overview ...............................................5
   4. Protocol Details ................................................7
      4.1. Fast Open Cookie ...........................................7
           4.1.1. Fast Open Option ....................................8
           4.1.2. Server Cookie Handling ..............................8
           4.1.3. Client Cookie Handling ..............................9
                  4.1.3.1. Client Caching Negative Responses .........10
      4.2. Fast Open Protocol ........................................11
           4.2.1. Fast Open Cookie Request ...........................11
           4.2.2. TCP Fast Open ......................................12
   5. Security Considerations ........................................14
      5.1. Resource Exhaustion Attack by SYN Flood with Valid
           Cookies ...................................................14
           5.1.1. Attacks from behind Shared Public IPs (NATs) .......15
      5.2. Amplified Reflection Attack to Random Host ................16
   6. TFO Applicability ..............................................17
      6.1. Duplicate Data in SYNs ....................................17
      6.2. Potential Performance Improvement .........................17
      6.3. Example: Web Clients and Servers ..........................18
           6.3.1. HTTP Request Replay ................................18
           6.3.2. HTTP over TLS (HTTPS) ..............................18
           6.3.3. Comparison with HTTP Persistent Connections ........18
           6.3.4. Load Balancers and Server Farms ....................19
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   7. Open Areas for Experimentation .................................19
      7.1. Performance Impact Due to Middleboxes and NAT .............19
      7.2. Impact on Congestion Control ..............................20
      7.3. Cookie-less Fast Open .....................................20
   8. Related Work ...................................................20
      8.1. T/TCP .....................................................20
      8.2. Common Defenses against SYN Flood Attacks .................21
      8.3. Speculative Connections by the Applications ...............21
      8.4. Fast Open Cookie-in-FIN ...................................21
      8.5. TCP Cookie Transaction (TCPCT) ............................21
   9. IANA Considerations ............................................22
   10. References ....................................................22
      10.1. Normative References .....................................22
      10.2. Informative References ...................................23
   Appendix A. Example Socket API Changes to Support TFO .............25
    A.1. Active Open .................................................25
    A.2. Passive Open ................................................25
   Acknowledgments ...................................................26
   Authors&#39; Addresses ................................................26
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP Fast Open (TFO) is an experimental update to TCP that enables data to be exchanged safely during TCP&#39;s connection handshake. This document describes a design that enables applications to save a round trip while avoiding severe security ramifications. At the core of TFO is a security cookie used by the server side to authenticate a client initiating a TFO connection. This document covers the details of exchanging data during TCP&#39;s initial handshake, the protocol for TFO cookies, potential new security vulnerabilities and their mitigation, and the new socket API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP高速オープン（TFO）は、TCPの接続ハンドシェイク中に安全にやり取りするデータを可能にTCPへの実験的なアップデートです。この文書では、深刻なセキュリティ上の悪影響を回避しながら往復を保存するためのアプリケーションを可能に設計について説明します。 TFOの中核は、TFO接続を開始するクライアントを認証するためにサーバ側で使用されるセキュリティクッキーです。このドキュメントでは、TCPの初期ハンドシェイク、TFOクッキー、潜在的な新しいセキュリティの脆弱性とその緩和のためのプロトコル、および新しいソケットAPIの間のデータ交換の詳細をカバーしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFO is motivated by the performance needs of today&#39;s Web applications. Current TCP only permits data exchange after the three-way handshake (3WHS) [RFC793], which adds one RTT to network latency. For short Web transfers this additional RTT is a significant portion of overall network latency, even when HTTP persistent connection is widely used. For example, the Chrome browser [Chrome] keeps TCP connections idle for up to 5 minutes, but 35% of HTTP requests are made on new TCP connections [RCCJR11]. For such Web and Web-like applications, placing data in the SYN can yield significant latency improvements. Next we describe how we resolve the challenges that arise upon doing so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOは、今日のWebアプリケーションのパフォーマンスのニーズによって動機付けられています。現在のTCPは、ネットワークの待ち時間に1 RTTを追加する3ウェイハンドシェイク（3WHS）[RFC793]、後にデータ交換を可能にします。短いウェブ転送のために、この追加のRTTは、HTTP永続的接続が広く使用されている場合でも、ネットワーク全体の待ち時間の重要な部分です。たとえば、Chromeブラウザ[クローム]は最大5分間アイドル状態のTCP接続を保持しますが、HTTP要求の35％は、新しいTCP接続の[RCCJR11]で作られています。そのようなウェブやWebのようなアプリケーションでは、大幅な遅延の改善をもたらすことができるSYNにデータを置きます。次に我々はそうする時に発生する課題を解決する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はRFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;TFO&#34; refers to TCP Fast Open. &#34;Client&#34; refers to TCP&#39;s active open side, and &#34;server&#34; refers to TCP&#39;s passive open side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「TFOは、」高速開いているTCPを指します。 「クライアントは、」TCPのアクティブオープン側を指し、「サーバ」TCPのパッシブオープン側を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Data in SYN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SYN 2.データ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standard TCP already allows data to be carried in SYN packets ([RFC793], Section 3.4) but forbids the receiver from delivering it to the application until the 3WHS is completed. This is because TCP&#39;s initial handshake serves to capture old or duplicate SYNs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準のTCPは既に（[RFC793]セクション3.4）データはSYNパケットで運ばれることを可能にするが、3WHSが完了するまでアプリケーションに配信からの受信を禁止します。 TCPの初期ハンドシェイクが古いまたは重複のSYNをキャプチャするのに役立つからです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To enable applications to exchange data in a TCP handshake, TFO removes the constraint and allows data in SYN packets to be delivered to the application. This change to TCP semantic raises two issues (discussed in the following subsections) that make TFO unsuitable for certain applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPハンドシェイクでデータを交換するアプリケーションを可能にするために、TFOは、制約を除去し、SYNパケット内のデータがアプリケーションに配信されることを可能にします。 TCPのセマンティックにこの変更は、特定のアプリケーションのためのTFOは適さない（以下のサブセクションで説明する）二つの問題を提起します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, TCP implementations MUST NOT use TFO by default, but only use TFO if requested explicitly by the application on a per-service-port basis. Applications need to evaluate TFO applicability as described in Section 6 before using TFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのため、TCPの実装は、デフォルトではTFOを使用してはならないが、サービスごとのポート単位でアプリケーションによって明示的に要求された場合のみ、TFOを使用しています。アプリケーションは、TFOを使用する前に、第6節で説明したようにTFOの適用性を評価する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Relaxing TCP Semantics on Duplicated SYNs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 重複したSYNにTCPセマンティクスをリラックス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFO allows data to be delivered to the application before the 3WHS is completed, thus opening itself to a data integrity issue in either of the two cases below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOは、このように、以下の2例のいずれかでデータの整合性の問題に自分自身を開いて、3WHSが完了する前に、データがアプリケーションに配信することができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a) the receiver host receives data in a duplicate SYN after it has forgotten it received the original SYN (e.g., due to a reboot);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは元のSYN（例えば、による再起動に）を受信し忘れた後にA）受信ホストが重複SYNでデータを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b) the duplicate is received after the connection created by the original SYN has been closed and the close was initiated by the sender (so the receiver will not be protected by the TIME-WAIT 2 MSL state).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B）重複は、元のSYNが閉じられたと近いが（したがって、受信機は、TIME-WAIT 2 MSL状態で保護されない）送信者によって開始されたことによって作成された接続の後に受信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The now obsoleted T/TCP [RFC1644] (obsoleted by [RFC6247]) attempted to address these issues. It was not successful and not deployed due to various vulnerabilities as described in Section 8, &#34;Related Work&#34;. Rather than trying to capture all dubious SYN packets to make TFO 100% compatible with TCP semantics, we made a design decision early on to accept old SYN packets with data, i.e., to restrict TFO use to a class of applications (Section 6) that are tolerant of duplicate SYN packets with data. We believe this is the right design trade-off: balancing complexity with usefulness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（[RFC6247]によって廃止）今は廃止T / TCP [RFC1644]は、これらの問題に対処しようとしました。それは成功しなかったと第8章、「関連作品」で説明したように起因するさまざまな脆弱性にデプロイされていません。むしろTCPのセマンティクスを持つTFOは100％の互換性を持たせるために、すべての怪しげなSYNパケットをキャプチャしようとするよりも、我々はTFOは、アプリケーション（第6節）のクラスに使用を制限するために、データ、すなわち古いSYNパケットを受け入れるように早い段階での設計上の決定をしたことデータと重複したSYNパケットの寛容です。有用性と複雑さのバランスを取る：私たちは、これは正しい設計上のトレードオフであると信じています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. SYNs with Spoofed IP Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. スプーフィングされたIPアドレスとのSYN
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standard TCP suffers from the SYN flood attack [RFC4987] because SYN packets with spoofed source IP addresses can easily fill up a listener&#39;s small queue, causing a service port to be blocked completely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
偽装された送信元のIPアドレスを持つSYNパケットが簡単にサービスポートが完全にブロックさせる、リスナーの小さなキューを埋めることができますので、標準のTCPは、SYNフラッド攻撃[RFC4987]に苦しんでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFO goes one step further to allow server-side TCP to send up data to the application layer before the 3WHS is completed. This opens up serious new vulnerabilities. Applications serving ports that have TFO enabled may waste lots of CPU and memory resources processing the requests and producing the responses. If the response is much larger than the request, the attacker can further mount an amplified reflection attack against victims of choice beyond the TFO server itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOは3WHSが完了する前に、サーバ側のTCPは、アプリケーション層にデータを送信できるようにするためにさらに一歩行きます。これは重大な新たな脆弱性を開きます。 TFOが有効になっているポートにサービスを提供するアプリケーションは、要求を処理し、応答を生成するCPUとメモリリソースの多くを無駄にします。応答が要求よりもはるかに大きい場合、攻撃者はさらにTFOサーバ自体を超えた選択肢の犠牲者に対する増幅反射攻撃を仕掛けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Numerous mitigation techniques against regular SYN flood attacks exist and have been well documented [RFC4987]. Unfortunately, none are applicable to TFO. We propose a server-supplied cookie to mitigate these new vulnerabilities in Section 3 and evaluate the effectiveness of the defense in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常のSYNフラッド攻撃に対する数多くの緩和技術は、[RFC4987]を存在し、十分に文書化されています。残念ながら、どれもTFOには適用されません。私たちは、第3節では、これらの新しい脆弱性を軽減し、第7節で防衛の有効性を評価するために、サーバーが提供するクッキーを提案します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key component of TFO is the Fast Open Cookie (cookie), a message authentication code (MAC) tag generated by the server. The client requests a cookie in one regular TCP connection, then uses it for future TCP connections to exchange data during the 3WHS:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOの主要コンポーネントは、高速オープンクッキー（クッキー）、メッセージ認証コード（MAC）サーバによって生成されたタグです。次に、クライアントは3WHS中にデータを交換するために、将来のTCP接続のためにそれを使用して、1つの通常のTCPコネクションでクッキーを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requesting a Fast Open Cookie:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速オープンクッキーを要求します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The client sends a SYN with a Fast Open option with an empty cookie field to request a cookie.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.クライアントは、クッキーを要求するために、空のクッキーフィールドを用いた高速オープンオプションを指定してSYNを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The server generates a cookie and sends it through the Fast Open option of a SYN-ACK packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.サーバーはクッキーを生成し、SYN-ACKパケットの高速オープンオプションを通してそれを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The client caches the cookie for future TCP Fast Open connections (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.クライアントは、将来のTCP高速オープン接続（下記参照）のためにクッキーをキャッシュします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Performing TCP Fast Open:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP高速オープンを実行します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The client sends a SYN with data and the cookie in the Fast Open option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.クライアントは、データを持つSYNおよびFastオープンオプションでクッキーを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. The server validates the cookie:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.サーバーはクッキーを検証します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
a. If the cookie is valid, the server sends a SYN-ACK acknowledging both the SYN and the data. The server then delivers the data to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A。クッキーが有効であれば、サーバがSYN-ACKはSYNとデータの両方を認めて送信します。次に、サーバは、アプリケーションにデータを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
b. Otherwise, the server drops the data and sends a SYN-ACK acknowledging only the SYN sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
B。そうしないと、サーバーはデータをドロップし、唯一のSYNのシーケンス番号を認めSYN-ACKを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the server accepts the data in the SYN packet, it may send the response data before the handshake finishes. The maximum amount is governed by TCP&#39;s congestion control [RFC5681].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.サーバーは、SYNパケット内のデータを受け入れる場合、それは握手が終了する前に応答データを送信することができます。最大量は、TCPの輻輳制御[RFC5681]によって支配されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The client sends an ACK acknowledging the SYN and the server data. If the client&#39;s data is not acknowledged, the client retransmits the data in the ACK packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.クライアントは、SYNと、サーバのデータを認めるACKを送信します。クライアントのデータが確認されていない場合、クライアントは、ACKパケット内のデータを再送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The rest of the connection proceeds like a normal TCP connection. The client can repeat many Fast Open operations once it acquires a cookie (until the cookie is expired by the server). Thus, TFO is useful for applications that have temporal locality on client and server connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5.接続の残りの部分は通常のTCP接続のように進行します。 （クッキーがサーバによって期限切れされるまで）、それはクッキーを取得した後、クライアントは、多くの高速オープンの操作を繰り返すことができます。したがって、TFOは、クライアントとサーバーの接続に時間的局所性を持っている用途に有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requesting Fast Open Cookie in connection 1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続1で、高速を開きクッキーを要求します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   TCP A (Client)                                      TCP B (Server)
   ______________                                      ______________
   CLOSED                                                      LISTEN
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #1 SYN-SENT       ----- &lt;SYN,CookieOpt=NIL&gt;  ----------&gt;  SYN-RCVD
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #2 ESTABLISHED    &lt;---- &lt;SYN,ACK,CookieOpt=C&gt; ----------  SYN-RCVD
   (caches cookie C)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Performing TCP Fast Open in connection 2:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続2での高速オープンTCPを実行します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   TCP A (Client)                                      TCP B (Server)
   ______________                                      ______________
   CLOSED                                                      LISTEN
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #1 SYN-SENT       ----- &lt;SYN=x,CookieOpt=C,DATA_A&gt; ----&gt;  SYN-RCVD
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #2 ESTABLISHED    &lt;---- &lt;SYN=y,ACK=x+len(DATA_A)+1&gt; ----  SYN-RCVD
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #3 ESTABLISHED    &lt;---- &lt;ACK=x+len(DATA_A)+1,DATA_B&gt;----  SYN-RCVD
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #4 ESTABLISHED    ----- &lt;ACK=y+1&gt;--------------------&gt; ESTABLISHED
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   #5 ESTABLISHED    --- &lt;ACK=y+len(DATA_B)+1&gt;----------&gt; ESTABLISHED
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Protocol Details
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.プロトコルの詳細
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Fast Open Cookie
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 高速オープンクッキー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Fast Open Cookie is designed to mitigate new security vulnerabilities in order to enable data exchange during a handshake. The cookie is a MAC tag generated by the server and is opaque to the client; the client simply caches the cookie and passes it back on subsequent SYN packets to open new connections. The server can expire the cookie at any time to enhance security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速オープンクッキーは、ハンドシェイク時のデータ交換を可能にするために、新たなセキュリティの脆弱性を軽減するように設計されています。クッキーは、サーバによって生成されたMACタグであり、クライアントに対して不透明です。クライアントは、単にクッキーをキャッシュし、新しい接続を開くために、後続のSYNパケットに戻ってそれを渡します。サーバーは、セキュリティを強化するために、いつでもクッキーを期限切れにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Fast Open Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 高速オープンオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                   |      Kind     |    Length     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                            Cookie                             ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kind 1 byte: value = 34 Length 1 byte: range 6 to 18 (bytes); limited by remaining space in the options field. The number MUST be even. Cookie 0, or 4 to 16 bytes (Length - 2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類1バイト：値= 34の​​長さ1バイト：18の範囲6（バイト）。オプションフィールドにスペースを残りによって制限されます。数は偶数でなければなりません。クッキー0、または4〜16バイト（長さ -  2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Fast Open option is used to request or to send a Fast Open Cookie. When a cookie is not present or is empty, the option is used by the client to request a cookie from the server. When the cookie is present, the option is used to pass the cookie from the server to the client or from the client back to the server (to perform a Fast Open).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速オープンオプションは、要求に使用されているか、高速オープンクッキーを送信します。クッキーが存在しないか、空の場合、オプションは、サーバからのクッキーを要求するためにクライアントによって使用されます。クッキーが存在する場合、オプションは、クライアントまたはクライアントからサーバーへのサーバーからクッキーを渡すために使用されます（高速オープンを実行します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The minimum cookie size is 4 bytes. Although the diagram shows a cookie aligned on 32-bit boundaries, alignment is not required. Options with invalid Length values or without the SYN flag set MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小クッキーのサイズは4バイトです。図は、32ビット境界で整列クッキーを示しているが、位置合わせは不要です。無効な長さの値を持つか、SYNフラグが設定されていないオプションを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Server Cookie Handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. サーバーのCookie処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server is in charge of cookie generation and authentication. The cookie SHOULD be a MAC tag with the following properties. We use &#34;SHOULD&#34; because, in some cases, the cookie may be trivially generated as discussed in Section 7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、クッキーの生成と認証を担当しています。クッキーは、次のプロパティを持つMACタグであるべきです。 7.3節で述べたように我々は、ので、いくつかのケースでは、クッキーは自明生成することができる「べきである」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The cookie authenticates the client&#39;s (source) IP address of the SYN packet. The IP address may be an IPv4 or IPv6 address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.クッキーは、SYNパケットのクライアント（ソース）IPアドレスを認証します。 IPアドレスはIPv4またはIPv6アドレスであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The cookie can only be generated by the server and cannot be fabricated by any other parties, including the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.クッキーはサーバによって生成することができ、クライアントを含む他の当事者によって製造することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The generation and verification are fast relative to the rest of SYN and SYN-ACK processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.生成および検証は、SYNおよびSYN-ACK処理の残りの部分への迅速な相対的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. A server may encode other information in the cookie and accept more than one valid cookie per client at any given time. But this is server-implementation dependent and transparent to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.サーバーは、クッキー内の他の情報をエンコードして、任意の時点で、クライアントごとに複数の有効なクッキーを受け入れることができます。しかし、これはクライアントにサーバの実装に依存して透明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The cookie expires after a certain amount of time. The reason for cookie expiration is detailed in the &#34;Security Considerations&#34; section (Section 5). This can be done by either periodically changing the server key used to generate cookies or including a timestamp when generating the cookie.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5.クッキーは、一定時間後に期限が切れます。 Cookieの有効期限の理由は、「セキュリティに関する考慮事項」のセクション（セクション5）に詳述されています。これは、定期的にクッキーを生成するために使用されるサーバキーを変更したり、クッキーを生成するときにタイムスタンプを含むいずれかの方法で行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
To gradually invalidate cookies over time, the server can implement key rotation to generate and verify cookies using multiple keys. This approach is useful for large-scale servers to retain Fast Open rolling key updates. We do not specify a particular mechanism because the implementation is server specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
徐々に時間をかけて、クッキーを無効にするには、サーバが生成し、複数のキーを使用してクッキーを確認するために、キーローテーションを実装することができます。大規模なサーバーでは、高速オープンローリングキーの更新を保持するために、このアプローチは便利です。実装は、サーバー固有のものですので、我々は特定の機構を指定しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server supports the cookie-generation and verification operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、クッキー生成と検証操作をサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- GetCookie(IP_Address): returns a (new) cookie.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  GetCookie（IP_Addressはは）：（新しい）クッキーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IsCookieValid(IP_Address, Cookie): checks if the cookie is valid, i.e., it has not expired and the cookie authenticates the client IP address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  IsCookieValid（IP_Addressは、クッキー）：クッキーが有効であるかどうかを確認する、すなわち、それが満了していないとクッキーは、クライアントのIPアドレスを認証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example Implementation: a simple implementation is to use AES_128 to encrypt the IPv4 (with padding) or IPv6 address and truncate to 64 bits. The server can periodically update the key to expire the cookies. AES encryption on recent processors is fast and takes only a few hundred nanoseconds [RCCJR11].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装例：単純な実装は、IPv4（パディング付き）またはIPv6アドレスを暗号化して64ビットに切り捨てるAES_128を使用することです。サーバーは定期的にクッキーを期限切れにキーを更新することができます。最近のプロセッサ上のAES暗号化は高速で、わずか数百ナノ秒[RCCJR11]をとります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If only one valid cookie is allowed per IP, and the server can regenerate the cookie independently, the best validation process is to simply regenerate a valid cookie and compare it against the incoming cookie. In that case, if the incoming cookie fails the check, a valid cookie is readily available to be sent to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
唯一の有効なクッキーがIPごとに許可され、サーバが独立してクッキーを再生することができる場合は、最高の検証プロセスは、単純に有効なクッキーを再生成し、着信クッキーに対してそれを比較することです。入ってくるクッキーチェックを失敗した場合、その場合には、有効なクッキーがクライアントに送信することが容易に利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. Client Cookie Handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. クライアントのCookie処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST cache cookies from servers for later Fast Open connections. For a multihomed client, the cookies are dependent on the client and server IP addresses. Hence, the client should cache at most one (most recently received) cookie per client and server IP address pair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、後で高速オープン接続のためのサーバーからのCookieをキャッシュしなければなりません。マルチホームクライアントの場合、クッキーはクライアントとサーバーのIPアドレスに依存しています。したがって、クライアントは、クライアントとサーバのIPアドレスのペアごとに最大1つの（最も最近受け取った）クッキーをキャッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When caching cookies, we recommend that the client also cache the Maximum Segment Size (MSS) advertised by the server. The client can cache the MSS advertised by the server in order to determine the maximum amount of data that the client can fit in the SYN packet in subsequent TFO connections. Caching the server MSS is useful because, with Fast Open, a client sends data in the SYN packet before the server announces its MSS in the SYN-ACK packet. If the client sends more data in the SYN packet than the server will accept, this will likely require the client to retransmit some or all of the data. Hence, caching the server MSS can enhance performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クッキーをキャッシュするとき、私たちは、クライアントが、サーバによってアドバタイズされた最大セグメントサイズ（MSS）をキャッシュすることをお勧めします。クライアントは、クライアントが、その後のTFO接続でSYNパケット内に収めることができるデータの最大量を決定するために、サーバーによってアドバタイズMSSをキャッシュすることができます。サーバーMSSをキャッシュすると、サーバーがSYN-ACKパケット内のMSSを発表する前に速いオープンで、クライアントは、SYNパケット内のデータを送信し、ために有用です。クライアントは、サーバが受け入れるよりも、SYNパケットでより多くのデータを送信した場合、これはおそらく、データの一部または全部を再送信するためにクライアントが必要になります。このため、サーバMSSをキャッシュすると、パフォーマンスを向上させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Without a cached server MSS, the amount of data in the SYN packet is limited to the default MSS of 536 bytes for IPv4 [RFC1122] and 1220 bytes for IPv6 [RFC2460]. Even if the client complies with this limit when sending the SYN, it is known that an IPv4 receiver advertising an MSS less than 536 bytes can receive a segment larger than it is expecting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュサーバMSSせず、SYNパケット内のデータの量は、IPv6 [RFC2460]のIPv4 [RFC1122] 1220のバイトを536バイトのデフォルトMSSに限定されます。 SYNを送信するとき、クライアントは、この制限に準拠していても、MSS未満536のバイトを広告のIPv4受信機は、それが期待されるより大きなセグメントを受信することができることが知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the cached MSS is larger than the typical size (1460 bytes for IPv4 or 1440 bytes for IPv6), then the excess data in the SYN packet may cause problems that offset the performance benefit of Fast Open. For example, the unusually large SYN may trigger IP fragmentation and may confuse firewalls or middleboxes, causing SYN retransmission and other side effects. Therefore, the client MAY limit the cached MSS to 1460 bytes for IPv4 or 1440 for IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュされたMSSは、典型的なサイズ（IPv4の1460バイトまたはIPv6 1440バイト）より大きい場合、SYNパケット内の過剰データは、高速オープンのパフォーマンス上の利点を相殺問題を引き起こす可能性があります。例えば、異常に大きなSYNは、IPフラグメンテーションをトリガすることができるとSYN再送および他の副作用を引き起こす、ファイアウォールまたは中間装置を混同することができます。そのため、クライアントはIPv6のIPv4または1440のための1460バイトにキャッシュされたMSSを制限する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3.1. Client Caching Negative Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3.1。クライアントキャッシュ否定応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST cache negative responses from the server in order to avoid potential connection failures. Negative responses include the server not acknowledging the data in the SYN, ICMP error messages, and (most importantly) no response (SYN-ACK) from the server at all, i.e., connection timeout. The last case is likely due to incompatible middleboxes or firewall blocking the connection completely after processing the SYN packet with data. If the client does not react to these negative responses and continues to retry Fast Open, the client may never be able to connect to the specific server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、潜在的な接続の失敗を避けるために、サーバーからの否定応答をキャッシュしなければなりません。否定応答は、サーバがSYN、ICMPエラーメッセージのデータを認め、そして（最も重要な）サーバから無応答（SYN-ACK）で全て、すなわち、接続タイムアウトではない含みます。最後のケースが原因のデータでSYNパケットを処理した後、完全に接続を遮断する互換性のない中間装置又はファイアウォールに可能性があります。クライアントは、これらの否定的な反応に反応し、高速のオープンを再試行し続けていない場合は、クライアントが特定のサーバーに接続できないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any negative responses, the client SHOULD disable Fast Open on the specific path (the source and destination IP addresses and ports) at least temporarily. Since TFO is enabled on a per-service-port basis, but cookies are independent of service ports, the client&#39;s cache should include remote port numbers, too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意の負の応答では、クライアントは、少なくとも一時的に特定のパス（送信元と送信先のIPアドレスとポート）のファースト開き無効にする必要があります。 TFOは、サービスごとのポート単位で有効になっていますが、クッキーは、サービスポートの独立しているため、クライアントのキャッシュは、あまりにも、リモートポート番号を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Fast Open Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 高速オープンプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One predominant requirement of TFO is to be fully compatible with existing TCP implementations, on both the client and server sides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOの一つの主要な要件は、クライアントとサーバの両方の側面に、既存のTCP実装と完全に互換性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server keeps two variables per listening socket (IP address and port):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ソケット（IPアドレスとポート）をリスニングごとに2つの変数を保持します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FastOpenEnabled: default is off. It MUST be turned on explicitly by the application. When this flag is off, the server does not perform any TFO-related operations and MUST ignore all cookie options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FastOpenEnabled：デフォルトはオフです。これは、アプリケーションによって明示的にオンにする必要があります。このフラグがオフの場合、サーバーは任意のTFO-関連の操作を実行しないと、すべてのクッキーのオプションを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PendingFastOpenRequests: tracks the number of TFO connections in SYN-RCVD state. If this variable goes over a preset system limit, the server MUST disable TFO for all new connection requests until PendingFastOpenRequests drops below the system limit. This variable is used for defending some vulnerabilities discussed in the &#34;Security Considerations&#34; section (Section 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PendingFastOpenRequests：SYN-RCVD状態のTFO接続の数を追跡します。この変数が設定システムの制限を超えていけばPendingFastOpenRequestsがシステムの上限を下回るまで、サーバーは、すべての新しい接続要求のTFOを無効にする必要があります。この変数は、「セキュリティの考慮事項」のセクション（セクション5）で述べたいくつかの脆弱性を防御するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server keeps a FastOpened flag per connection to mark if a connection has successfully performed a TFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、接続が正常にTFOを行った場合はマークする接続ごとFastOpenedフラグを保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Fast Open Cookie Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. 高速オープンCookieリクエスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any client attempting TFO MUST first request a cookie from the server with the following steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOを試みるすべてのクライアントは、最初に以下の手順でサーバからクッキーを要求しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The client sends a SYN packet with a Fast Open option with a Length field of 0 (empty cookie field).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.クライアントは、0の長さフィールド（空のクッキーフィールド）を用いた高速オープンオプションを指定してSYNパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The server responds with a SYN-ACK based on the procedures in the &#34;Server Cookie Handling&#34; section (Section 4.1.2). This SYN-ACK may contain a Fast Open option if the server currently supports TFO for this listener port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.サーバーは、「サーバーのCookie処理」セクション（4.1.2）の手順に基づいてSYN-ACKで応答します。サーバーは現在、このリスナーポートのTFOをサポートしている場合、このSYN-ACKは、高速オープンオプションが含まれていてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the SYN-ACK has a Fast Open option with a cookie, the client replaces the cookie and other information as described in the &#34;Client Cookie Handling&#34; section (Section 4.1.3). Otherwise, if the SYN-ACK is first seen and not a (spurious) retransmission, the client MAY remove the server information from the cookie cache. If the SYN-ACK is a spurious retransmission, the client does nothing to the cookie cache for the reasons below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. SYN-ACKがクッキーを用いた高速オープンオプションを持っている場合は、「クライアントのCookie処理」セクション（セクション4.1.3）で説明したように、クライアントは、クッキーやその他の情報を置き換えます。 SYN-ACKが最初（スプリアス）再送を見ておらず、それ以外の場合、クライアントは、クッキーキャッシュからサーバ情報を削除することができます。 SYN-ACKは、スプリアス再送がある場合、クライアントは以下の理由により、Cookieキャッシュに何もしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The network or servers may drop the SYN or SYN-ACK packets with the new cookie options, which will cause SYN or SYN-ACK timeouts. We RECOMMEND both the client and the server to retransmit SYN and SYN-ACK packets without the cookie options on timeouts. This ensures the connections of cookie requests will go through and lowers the latency penalty (of dropped SYN/SYN-ACK packets). The obvious downside for maximum compatibility is that any regular SYN drop will fail the cookie (although one can argue the delay in the data transmission until after the 3WHS is justified if the SYN drop is due to network congestion). The next section describes a heuristic to detect such drops when the client receives the SYN-ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークまたはサーバーは、SYNまたはSYN-ACKタイムアウトが発生します、新しいクッキーのオプションを付けて、SYNまたはSYN-ACKパケットをドロップすることがあります。私たちは、クライアントとタイムアウトにクッキーオプションなしでSYNとSYN-ACKパケットを再送するサーバーの両方をお勧めします。これは、クッキー要求の接続が通過すると（SYN / SYN-ACKパケットを落としたの）待ち時間のペナルティを低減することが保証されます。最大の互換性のための明白な欠点は、（SYN低下がネットワークの混雑によるものである場合に正当化される3WHS後まで1は、データ伝送の遅延を主張することができるが）任意の正規SYN降下がクッキーを失敗することです。次のセクションでは、クライアントは、SYN-ACKを受信したとき、このような低下を検出するためのヒューリスティックを記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We also RECOMMEND the client to record the set of servers that failed to respond to cookie requests and only attempt another cookie request after a certain period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、クッキーの要求に応答してのみ、一定期間後に別のクッキーの要求を試みに失敗したサーバーのセットを記録するためにクライアントをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. TCP Fast Open
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2.  TCP高速オープン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client obtains the cookie from the target server, it can perform subsequent TFO connections until the cookie is expired by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがターゲットサーバーからクッキーを取得すると、クッキーがサーバによって期限切れされるまで、それ以降のTFO接続を行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client: Sending SYN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント：SYNを送信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To open a TFO connection, the client MUST have obtained a cookie from the server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFO接続を開くには、クライアントはサーバからクッキーを取得している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Send a SYN packet.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. SYNパケットを送信します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
a. If the SYN packet does not have enough option space for the Fast Open option, abort TFO and fall back to the regular 3WHS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A。 SYNパケットは、高速オープンオプションのための十分なオプション空間を持っていない場合は、TFOを中止し、通常の3WHSにフォールバック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
b. Otherwise, include the Fast Open option with the cookie of the server. Include any data up to the cached server MSS or default 536 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
B。そうでない場合は、サーバーのクッキーを用いた高速オープンオプションが含まれています。キャッシュされたサーバーのMSSまたはデフォルト536バイトまでの任意のデータが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Advance to SYN-SENT state and update SND.NXT to include the data accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYN-SENT状態に2事前し、それに応じてデータを含めるようにSND.NXTを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To deal with network or servers dropping SYN packets with payload or unknown options, when the SYN timer fires, the client SHOULD retransmit a SYN packet without data and Fast Open options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ときSYNタイマー火災、ネットワークまたはペイロードまたは未知のオプションでSYNパケットをドロップするサーバに対処するために、クライアントは、データと高速オープンオプションなしでSYNパケットを再送すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server: Receiving SYN and responding with SYN-ACK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー：SYNを受信し、SYN-ACKで応答します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving the SYN packet with Fast Open option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速オープンオプションでSYNパケットを受信すると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Initialize and reset a local FastOpened flag. If FastOpenEnabled is false, go to step 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.初期化し、ローカルFastOpenedフラグをリセットします。 FastOpenEnabledがfalseの場合は、手順5に進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. If PendingFastOpenRequests is over the system limit, go to step 5.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. PendingFastOpenRequestsがシステムの上限を超えている場合は、手順5に進みます。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. If IsCookieValid() (in Section 4.1.2) returns false, go to step 5.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.（4.1.2節で）IsCookieValid（）の場合は、手順5に進み、falseを返します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Buffer the data and notify the application. Set the FastOpened flag and increment PendingFastOpenRequests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.データをバッファリングし、アプリケーションに通知します。 FastOpenedフラグと増分PendingFastOpenRequestsを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Send the SYN-ACK packet. The packet MAY include a Fast Open option. If the FastOpened flag is set, the packet acknowledges the SYN and data sequence. Otherwise, it acknowledges only the SYN sequence. The server MAY include data in the SYN-ACK packet if the response data is readily available. Some applications may favor delaying the SYN-ACK, allowing the application to process the request in order to produce a response, but this is left up to the implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. SYN-ACKパケットを送信します。パケットは、高速のオープンオプションを含むかもしれません。 FastOpenedフラグが設定されている場合、パケットは、SYNとデータシーケンスを認めます。そうでなければ、それだけでSYNシーケンスを認めています。応答データが容易に利用可能である場合、サーバーは、SYN-ACKパケット内のデータを含むことができます。いくつかのアプリケーションは、応答を生成するために要求を処理するアプリケーションを可能にする、SYN-ACKを遅らせる好むかもしれないが、これは実装に任されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Advance to the SYN-RCVD state. If the FastOpened flag is set, the server MUST follow [RFC5681] (based on [RFC3390]) to set the initial congestion window for sending more data packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYN-RCVD状態に6.アドバンス。 FastOpenedフラグが設定されている場合、サーバは、複数のデータパケットを送信するための初期の輻輳ウィンドウを設定する（[RFC3390]に基づく）[RFC5681]を従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the SYN-ACK timer fires, the server SHOULD retransmit a SYN-ACK segment with neither data nor Fast Open options for compatibility reasons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYN-ACKタイマーが起動した場合、サーバはどちらのデータも互換性の理由のための高速オープンオプションSYN-ACKセグメントを再送すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A special case is simultaneous open where the SYN receiver is a client in SYN-SENT state. The protocol remains the same because [RFC793] already supports both data in the SYN and simultaneous open. But the client&#39;s socket may have data available to read before it&#39;s connected. This document does not cover the corresponding API change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特殊なケースは、SYN受信機がSYN-SENT状態のクライアントで同時に開放されています。 [RFC793]既にSYNと同時オープンの両方のデータをサポートするためのプロトコルは同じままです。しかし、クライアントのソケットは、それが接続されています前に、読み取り可能なデータを有することができます。このドキュメントでは、対応するAPIの変更をカバーしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client: Receiving SYN-ACK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント：SYN-ACKを受信します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client SHOULD perform the following steps upon receiving the SYN-ACK:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、SYN-ACKを受信すると、次の手順を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the SYN-ACK has a Fast Open option, an MSS option, or both, update the corresponding cookie and MSS information in the cookie cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYN-ACKが高速オープンオプション、MSSオプション、またはその両方を持っている場合1.クッキーのキャッシュに対応するクッキーとMSSの情報を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Send an ACK packet. Set acknowledgment number to RCV.NXT and include the data after SND.UNA if data is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. ACKパケットを送信します。 RCV.NXTに確認応答番号を設定し、データが利用可能である場合SND.UNA後のデータが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Advance to the ESTABLISHED state.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ESTABLISHED状態へ3.アドバンス。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note there is no latency penalty if the server does not acknowledge the data in the original SYN packet. The client SHOULD retransmit any unacknowledged data in the first ACK packet in step 2. The data exchange will start after the handshake like a regular TCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、元のSYNパケット内のデータを認識しない場合は待ち時間ペナルティはありません注意してください。クライアントは、データ交換は、通常のTCPコネクションのようなハンドシェイクの後に開始しますステップ2で最初のACKパケット内の任意の未確認データを再送信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has timed out and retransmitted only regular SYN packets, it can heuristically detect paths that intentionally drop SYNs with the Fast Open option or data. If the SYN-ACK acknowledges only the initial sequence and does not carry a Fast Open cookie option, presumably it is triggered by a retransmitted (regular) SYN and the original SYN or the corresponding SYN-ACK was lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがタイムアウトとのみ、通常のSYNパケットを再送している場合、それは発見的に意図的に高速オープンオプションまたはデータでのSYNをドロップパスを検出することができます。 SYN-ACKのみ初期シーケンスを認識し、高速オープンクッキーのオプションを有していない場合は、おそらくそれが再送された（通常の）SYNと、元のSYNまたは失われた対応するSYN-ACKによってトリガーされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server: Receiving ACK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー：ACKを受け取ります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving an ACK acknowledging the SYN sequence, the server decrements PendingFastOpenRequests and advances to the ESTABLISHED state. No special handling is required further.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYN配列を承認ACKを受信すると、サーバはPendingFastOpenRequestsをデクリメントし、確立された状態に移行します。特別な処理がさらに必要とされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.セキュリティについての考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Fast Open Cookie stops an attacker from trivially flooding spoofed SYN packets with data to burn server resources or to mount an amplified reflection attack on random hosts. The server can defend against spoofed SYN floods with invalid cookies using existing techniques [RFC4987]. We note that although generating bogus cookies is cost free, the cost of validating the cookies, inherent to any authentication scheme, may be substantial compared to processing a regular SYN packet. We describe these new vulnerabilities of TFO and the countermeasures in detail below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速オープンクッキーは自明洪水からの攻撃者がサーバーのリソースを燃やすためにまたはランダムホスト上の増幅反射攻撃をマウントするためのデータでSYNパケットを偽装され停止します。サーバーは、既存の技術[RFC4987]を使用して、無効なクッキーと偽装したSYNフラッドから守ることができます。私たちは、偽のクッキーを生成することは、コストの無料ですが、任意の認証方式に固有のクッキーを、検証するコストは、通常のSYNパケットを処理に比べてかなりあってもよいことに注意してください。私たちは、TFO、以下に詳細に対策のこれらの新しい脆弱性について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Resource Exhaustion Attack by SYN Flood with Valid Cookies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 有効なクッキーとSYNフラッドによる資源枯渇の攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker may still obtain cookies from some compromised hosts, then flood spoofed SYN packets with data and &#34;valid&#34; cookies (from these hosts or other vantage points). Like regular TCP handshakes, TFO is vulnerable to such an attack. But the potential damage can be much more severe. Besides causing temporary disruption to service ports under attack, it may exhaust server CPU and memory resources. Such an attack will show up on application server logs as an application-level DoS from botnets, triggering other defenses and alerts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、まだその後、いくつかの妥協ホストからクッキーを取得したデータと（これらのホストまたは他の有利な点からの）「有効」クッキーとスプーフィングされたSYNパケットをフラッディングすることができます。通常のTCPハンドシェイクのように、TFOは、このような攻撃に対して脆弱です。しかし、潜在的な被害ははるかに厳しいことができます。攻撃を受けたサービスポートへの一時的な混乱を引き起こしほかに、それはサーバーのCPUとメモリリソースを使い果たすことがあります。このような攻撃は、他の防御とアラートをトリガー、ボットネットからのアプリケーションレベルのDoSなどのアプリケーション・サーバー・ログに表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To protect the server, it is important to limit the maximum number of total pending TFO connection requests, i.e., PendingFastOpenRequests (Section 4.2). When the limit is exceeded, the server temporarily disables TFO entirely as described in &#34;Server Cookie Handling&#34; (Section 4.1.2). Then, subsequent TFO requests will be downgraded to regular connection requests, i.e., with the data dropped and only SYNs acknowledged. This allows regular SYN flood defense techniques [RFC4987] like SYN cookies to kick in and prevent further service disruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバを保護するために、総ペンディングTFO接続要求、即ち、PendingFastOpenRequests（セクション4.2）の最大数を制限することが重要です。制限を超えた場合は、「サーバーのCookie処理」（4.1.2）で説明したように、サーバーが一時的に完全にTFOを無効にします。データが削除され、唯一のSYNを認めたとし、その後のTFO要求は、すなわち、通常の接続要求にダウングレードされます。これは、SYNクッキーのような定期的なSYN洪水防御技術[RFC4987]がでキックし、さらにサービスの中断を防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The main impact of SYN floods against the standard TCP stack is not directly from the floods themselves costing TCP processing overhead or host memory, but rather from the spoofed SYN packets filling up the often small listener&#39;s queue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準のTCPスタックに対するSYNフラッドの主な影響は、自身がTCP処理オーバーヘッドやホストメモリの原価計算洪水から直接ではなく、偽装されたSYNパケットから、多くの場合、小さなリスナーのキューを埋めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, TFO SYN floods can cause damage directly if admitted without limit into the stack. The reset (RST) packets from the spoofed host will fuel rather than defeat the SYN floods as compared to the non-TFO case, because the attacker can flood more SYNs with data and incur more cost in terms of data processing resources. For this reason, a TFO server needs to monitor the connections in SYN-RCVD being reset in addition to imposing a reasonable max queue length. Implementations may combine the two, e.g., by continuing to account for those connection requests that have just been reset against the listener&#39;s PendingFastOpenRequests until a timeout period has passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スタックに無制限に認め一方、TFO SYNフラッドは、直接被害を引き起こす可能性があります。スプーフィングされたホストからのリセット（RST）パケットは、燃料ではなく、攻撃者がデータを複数のSYN洪水及びデータ処理リソースの点でよりコストが発生することができるので、非TFOの場合に比べて、SYNフラッドを打ち負かします。このため、TFOサーバは、合理的な最大キュー長を課すことに加えて、リセットされてSYN-RCVD内の接続を監視する必要があります。実装はタイムアウト期間が経過するまでただのリスナーのPendingFastOpenRequestsに対してリセットされており、それらの接続要求を考慮して継続することにより、例えば、2を組み合わせてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Limiting the maximum number of pending TFO connection requests does make it easy for an attacker to overflow the queue, causing TFO to be disabled. We argue that causing TFO to be disabled is unlikely to be of interest to attackers because the service will remain intact without TFO; hence, there is hardly any real damage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留中のTFO接続要求の最大数を制限すると、TFOを無効にする原因となる、キューがオーバーフローする攻撃者にとって、それは簡単ありません。私たちは、TFOが無効にさせることは、サービスがTFOせずにそのまま残りますので、攻撃者が興味を持つことはほとんどありませんと主張しています。したがって、任意の実際の被害はほとんどありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. Attacks from behind Shared Public IPs (NATs)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. 共有の公共IPアドレスの後ろからの攻撃器（NAT）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker behind a NAT can easily obtain valid cookies to launch the above attack to hurt other clients that share the path. [BRISCOE12] suggested that the server can extend cookie generation to include the TCP timestamp -- GetCookie(IP_Address, Timestamp) -- and implement it by encrypting the concatenation of the two values to generate the cookie. The client stores both the cookie and its corresponding timestamp, and it echoes both in the SYN. The server then implements IsCookieValid(IP_Address, Timestamp, Cookie) by encrypting the IP and timestamp data and comparing it with the cookie value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NATの背後に、攻撃者は簡単にパスを共有する他のクライアントを傷つけるために上記の攻撃を開始するために有効なクッキーを取得することができます。 GetCookie（IP_Addressは、タイムスタンプ） -   - クッキーを生成するために、2つの値の連結を暗号化することによって、それを実現[BRISCOE12】サーバがTCPタイムスタンプを含むようにクッキーの生成を拡張することができることを示唆しました。クライアントストアの両方のクッキーとそれに対応するタイムスタンプが、それはSYNの両方に響きます。その後、サーバは、IPとタイムスタンプデータを暗号化し、クッキーの値と比較することにより、IsCookieValid（IP_Addressは、タイムスタンプ、クッキー）を実装しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This enables the server to issue different cookies to clients that share the same IP address; hence, it can selectively discard those misused cookies from the attacker. However, the attacker can simply repeat the attack with new cookies. The server would eventually need to throttle all requests from the IP address just like the current approach. Moreover, this approach requires modifying [RFC1323] (obsoleted by [RFC7323]) to send a non-zero Timestamp Echo Reply in the SYN, potentially causing firewall issues. Therefore, we believe the benefit does not outweigh the drawbacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、同じIPアドレスを共有して、クライアントに別のクッキーを発行するサーバーを可能にします。したがって、それは選択的に、攻撃者からのもの誤用クッキーを破棄することができます。しかし、攻撃者は単に新しいクッキーで攻撃を繰り返すことができます。サーバーは、最終的にはちょうど現在のアプローチのようなIPアドレスからのすべての要求を絞る必要があります。また、このアプローチは、潜在的にファイアウォールの問題を引き起こし、SYNにおける非ゼロタイムスタンプエコー応答を送信する（[RFC7323]によって時代遅れ）[RFC1323]を修正することが必要です。したがって、我々は利益が欠点を上回るしないと信じています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Amplified Reflection Attack to Random Host
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. ランダムホストに増幅リフレクション攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Limiting PendingFastOpenRequests with a system limit can be done without Fast Open cookies and would protect the server from resource exhaustion. It would also limit how much damage an attacker can cause through an amplified reflection attack from that server. However, it would still be vulnerable to an amplified reflection attack from a large number of servers. An attacker can easily cause damage by tricking many servers to respond with data packets at once to any spoofed victim IP address of choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
システムの制限と制限PendingFastOpenRequestsは、高速を開き、クッキーなしで行うことができ、資源の枯渇からサーバーを保護します。また、攻撃者がそのサーバーからの増幅された反射攻撃によって発生する可能性がありますどのくらいのダメージ制限します。しかし、それはまだ多数のサーバーからの増幅反射攻撃に対して脆弱であろう。攻撃者が簡単に選択した任意の偽装された被害者のIPアドレスに一度にデータパケットで応答する多くのサーバーをだましによって損傷を引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the use of Fast Open cookies, the attacker would first have to steal a valid cookie from its target victim. This likely requires the attacker to compromise the victim host or network first. But, in some cases, it may be relatively easy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速オープンクッキーを使用すると、攻撃者はまずそのターゲット犠牲者から有効なクッキーを盗むする必要があります。これは、おそらく最初の犠牲者のホストまたはネットワークを侵害するために、攻撃者が必要です。しかし、いくつかのケースでは、それは比較的簡単かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attacker here has little interest in mounting an attack on the victim host that has already been compromised. But it may be motivated to disrupt the victim&#39;s network. Since a stolen cookie is only valid for a single server, it has to steal valid cookies from a large number of servers and use them before they expire to cause sufficient damage without triggering the defense.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、すでにここに侵害された被害者のホストへの攻撃を取り付けるにはほとんど関心を持っています。しかし、被害者のネットワークを破壊する動機づけすることができます。盗まれたクッキーは、単一のサーバーでのみ有効ですので、それは多数のサーバーから有効なクッキーを盗み、彼らは守備をトリガすることなく、十分な損傷を引き起こすことが期限切れになる前にそれらを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One can argue that if the attacker has compromised the target network or hosts, it could perform a similar but simpler attack by injecting bits directly. The degree of damage will be identical, but a TFO-specific attack allows the attacker to remain anonymous and disguises the attack as from other servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つは、攻撃者がターゲットネットワークまたはホストを侵害した場合、それは直接ビットを注入することにより、類似しているが、単純な攻撃を実行することができると主張することができます。損傷の程度は同じになりますが、TFO-特定の攻撃は、攻撃者は匿名のまますることができますし、他のサーバーからのような攻撃を偽装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, with DHCP, an attacker can obtain cookies when he (or the host he has compromised) owns a particular IP address by performing regular Fast Open to servers supporting TFO and he can collect valid cookies. Then, the attacker actively or passively releases his IP address. When the IP address is reassigned to another host (victim) via DHCP, the attacker then floods spoofed Fast Open requests with valid cookies to the servers. Since the cookies are valid, these servers accept the requests and respond with a SYN-ACK plus data packets to the victim instead of the attacker. Thus, the attacker is able to launch amplified reflection attacks to other hosts that share IP addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、DHCPで、彼（または彼が侵害したホストが）TFOをサポートするサーバーに定期的に高速オープン実行することにより、特定のIPアドレスを所有しているとき、攻撃者はクッキーを取得することができ、彼は有効なクッキーを収集することができます。その後、攻撃者は、能動的又は受動的に彼のIPアドレスを解放します。 IPアドレスはDHCPを介して他のホスト（被害者）に再割り当てされた場合、攻撃者は、その後、サーバーへの有効なクッキーと偽装された高速オープン要求をフラッディングします。クッキーが有効であるので、これらのサーバーは要求を受け入れ、代わりに攻撃の犠牲者にSYN-ACKプラスデータパケットで応答します。したがって、攻撃者がIPアドレスを共有する他のホストに増幅反射攻撃を開始することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The best defense is for the server not to respond with data until the handshake finishes. In this case, the risk of an amplification reflection attack is completely eliminated. But the potential latency saving from TFO may diminish if the server application produces responses earlier before the handshake completes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最良の防御は、ハンドシェイクが完了するまで、データで応答しないサーバーのためです。この場合、増幅反射攻撃のリスクは完全に排除されます。サーバ・アプリケーションが以前のハンドシェイクが完了する前に応答を生成する場合でも、TFOから節約可能性待ち時間が減少することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. TFO Applicability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.適用性TFO
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is to help applications considering TFO to evaluate TFO&#39;s benefits and drawbacks using the Web client and server applications as an example throughout. Applications here refer specifically to the process that writes data into the socket -- for example, a JavaScript process that sends data to the server. A proposed socket API change is provided in the Appendix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、全体の例として、Webクライアントとサーバーアプリケーションを使用して、TFOの利点と欠点を評価するためにTFOを考慮したアプリケーションを支援することです。ここでのアプリケーションは、ソケットにデータを書き込みプロセスに特異的に参照してください - たとえば、サーバーにデータを送信するJavaScriptプロセス。提案されたソケットAPIの変更は、付録に記載されて。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Duplicate Data in SYNs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.  SYNで重複データ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that using TFO results in the first data written to a socket to be delivered more than once to the application on the remote host (Section 2.1). This replay potential only applies to data in the SYN but not subsequent data exchanges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リモート・ホスト（セクション2.1）上のアプリケーションに複数回配信するソケットに書き込まれた最初のデータでTFO結果を使用することが可能です。このリプレイ可能性はSYNのデータではなく、その後のデータ交換に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Empirically, [JIDKT07] showed the packet duplication on a Tier-1 network is rare. Since the replay only happens specifically when the SYN data packet is duplicated and also the duplicate arrives after the receiver has cleared the original SYN&#39;s connection state, the replay is thought to be uncommon in practice. Nevertheless, a client that cannot handle receiving the same SYN data more than once MUST NOT enable TFO to send data in a SYN. Similarly, a server that cannot accept receiving the same SYN data more than once MUST NOT enable TFO to receive data in a SYN. Further investigation is needed to judge the probability of receiving duplicated SYN or SYN-ACK packets with data in networks that are not Tier 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
経験的に、[JIDKT07]ティア1ネットワーク上でのパケット複製は稀でした。受信機は、元のSYNの接続状態をクリアした後にSYNデータパケットを複製しても、重複が到着したとき、再生のみ、具体的起こるので、再生が実際には珍しいと考えられています。それにも関わらず、何度も同じSYNデータがより多くの受信処理できないクライアントは、SYNにデータを送信するためにTFOをイネーブルにしてはなりません。同様に、何度も同じSYNデータがより多くを受信受け入れることができないサーバがSYNでデータを受信するTFOをイネーブルにしてはなりません。さらなる調査は、ティア1ないネットワークでのデータと重複SYNまたはSYN-ACKパケットを受信する確率を判断するために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Potential Performance Improvement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 潜在的なパフォーマンスの向上
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFO is designed for latency-conscious applications that are sensitive to TCP&#39;s initial connection setup delay. To benefit from TFO, the first application data unit (e.g., an HTTP request) needs to be no more than TCP&#39;s maximum segment size (minus options used in the SYN). Otherwise, the remote server can only process the client&#39;s application data unit once the rest of it is delivered after the initial handshake, diminishing TFO&#39;s benefit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOはTCPの初期接続設定遅延に敏感なのレイテンシ重視のアプリケーション用に設計されています。 TFOの恩恵を受けるために、第一のアプリケーションデータユニット（例えば、HTTPリクエスト）がないTCPの最大セグメントサイズよりも（マイナスSYNで使用されるオプション）しない必要があります。それの残りの部分はTFOの利益を減少させる、最初のハンドシェイクの後に配信されるとそうでない場合は、リモートサーバーは、クライアントのアプリケーション・データ・ユニットを処理することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To the extent possible, applications SHOULD reuse the connection to take advantage of TCP&#39;s built-in congestion control and reduce connection setup overhead. An application that employs too many short-lived connections will negatively impact network stability, as these connections often exit before TCP&#39;s congestion control algorithm takes effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な限り、アプリケーションは、TCPの組み込みの輻輳制御を利用して、接続セットアップのオーバーヘッドを減らすために、接続を再利用する必要があります。 TCPの輻輳制御アルゴリズムが有効になる前に、あまりにも多くの短命接続を採用したアプリケーションは、負しばしば出これらの接続など、ネットワークの安定性に影響を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Example: Web Clients and Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 例：Webクライアントとサーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. HTTP Request Replay
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.  HTTPリクエストのリプレイ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While TFO is motivated by Web applications, the browser should not use TFO to send requests in SYNs if those requests cannot tolerate replays. One example is POST requests without application-layer transaction protection (e.g., a unique identifier in the request header).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOは、Webアプリケーションによって動機づけされている間、ブラウザは、これらの要求は、リプレイを容認できない場合のSYNにリクエストを送信するためにTFOを使用しないでください。一例では、アプリケーション層のトランザクションを保護せずにPOSTリクエストである（例えば、要求ヘッダ内の一意の識別子）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, TFO is particularly useful for GET requests. GET request replay could happen across striped TCP connections: after a server receives an HTTP request but before the ACKs of the requests reach the browser, the browser may time out and retry the same request on another (possibly new) TCP connection. This differs from a TFO replay only in that the replay is initiated by the browser, not by the TCP stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、TFOは、GETリクエストのために特に有用です。サーバがHTTPリクエストを受信した後が、要求のACKがブラウザに到達する前に、ブラウザがタイムアウトして、別の（おそらく新しい）TCPコネクション上で同じ要求を再試行することがあります。GETリクエストのリプレイは、ストライプTCPコネクション間で発生する可能性があります。これがないTCPスタックによって、唯一のリプレイがブラウザによって開始されることにTFO再生とは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. HTTP over TLS (HTTPS)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.  TLS経由のHTTP（HTTPS）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Transport Layer Security (TLS) over TCP, it is safe and useful to include a TLS client_hello in the SYN packet to save one RTT in the TLS handshake. There is no concern about violating idempotency. In particular, it can be used alone with the speculative connection above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP上のトランスポート層セキュリティ（TLS）の場合は、TLSハンドシェイクで1 RTTを保存するためにSYNパケットでTLSのCLIENT_HELLOが含まれるように、安全かつ有用です。冪等に違反する心配はありません。特に、上記投機的接続に単独で使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3. Comparison with HTTP Persistent Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3.  HTTPの永続的接続との比較
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Is TFO useful given the wide deployment of HTTP persistent connections? The short answer is yes. Studies ([RCCJR11] [AERG11]) show that the average number of transactions per connection is between 2 and 4, based on large-scale measurements from both servers and clients. In these studies, the servers and clients both kept idle connections up to several minutes, well into &#34;human think&#34; time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOは、HTTP持続的接続の幅広い展開与え便利ですか？短い答えはイエスです。研究は、（[RCCJR11] [AERG11]）接続あたりのトランザクションの平均数は、サーバーとクライアントの両方から大規模の測定に基づいて、2と4の間であることを示しています。これらの研究では、サーバーとクライアントの両方がよく「人間は考える」時間に、数分までのアイドル状態の接続を保ちました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Keeping connections open and idle even longer risks a greater performance penalty. [HNESSK10] and [MQXMZ11] show that the majority of home routers and ISPs fail to meet the 124-minute idle timeout mandated in [RFC5382]. In [MQXMZ11], 35% of mobile ISPs silently time out idle connections within 30 minutes. End hosts, unaware of silent middlebox timeouts, suffer multi-minute TCP timeouts upon using those long-idle connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに長いオープンし、アイドル状態の接続を維持することは大きなパフォーマンスの低下をリスク。 [HNESSK10]と[MQXMZ11]ホームルータやISPの大半は[RFC5382]で義務付け124分のアイドルタイムアウトを満たしていないことを示しています。 【MQXMZ11]において、モバイルのISPの35％が静かに30分以内にアイドル接続をタイムアウト。サイレントミドルタイムアウトを知らないエンドホストは、それらの長いアイドル接続を使用すると、マルチ分のTCPタイムアウトを被ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To circumvent this problem, some applications send frequent TCP keep-alive probes. However, this technique drains power on mobile devices [MQXMZ11]. In fact, power has become such a prominent issue in modern Long Term Evolution (LTE) devices that mobile browsers close HTTP connections within seconds or even immediately [SOUDERS11].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題を回避するには、いくつかのアプリケーションは、頻繁にTCPキープアライブプローブを送信します。しかし、この技術は、[MQXMZ11】モバイルデバイスの電力を消耗します。実際には、電源がHTTP接続秒以内に、あるいはすぐに[SOUDERS11]モバイルブラウザ近い近代的なロング・ターム・エボリューション（LTE）デバイスでこのような顕著な問題となっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RCCJR11] studied the performance of the Chrome browser [Chrome] based on 28 days of global statistics. The Chrome browser keeps idle HTTP persistent connections for 5 to 10 minutes. However, the average number of the transactions per connection is only 3.3, and the TCP 3WHS accounts for up to 25% of the HTTP transaction network latency. The authors estimated that TFO improves page load time by 10% to 40% on selected popular Web sites.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RCCJR11]グローバル統計の28日間に基づいてChromeブラウザ[クローム]のパフォーマンスを研究。 Chromeブラウザは、5〜10分間アイドル状態のHTTPの持続的接続を保持します。しかし、接続あたりの平均トランザクション数はわずか3.3で、TCP 3WHSは、HTTPトランザクションのネットワーク遅延の最大25％を占めています。著者は、TFOが選択された人気のWebサイト上の10％〜40％でページの読み込み時間を改善していると推定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4. Load Balancers and Server Farms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4. バランサおよびサーバファームのロード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers behind load balancers that accept connection requests to the same server IP address should use the same key such that they generate identical Fast Open cookies for a particular client IP address. Otherwise, a client may get different cookies across connections; its Fast Open attempts would fall back to the regular 3WHS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じサーバのIPアドレスへの接続要求を受け入れるロードバランサの背後にあるサーバーは、特定のクライアントのIPアドレスに対して同一の高速オープンクッキーを生成するように、同じキーを使用する必要があります。そうでない場合、クライアントは接続にわたって異なるクッキーを得ることができます。その高速オープンの試みは、通常の3WHSに戻って下落するだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Open Areas for Experimentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.オープンエリア実験のために
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now outline some areas that need experimentation in the Internet and under different network scenarios. These experiments should help evaluate Fast Open benefits and risks and its related protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは今、インターネットで、異なるネットワークシナリオの下での実験を必要とするいくつかの領域を概説します。これらの実験では、Fastオープン利益とリスクとその関連プロトコルを評価するのに役立つはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Performance Impact Due to Middleboxes and NAT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.  MiddleboxesとNATのためにパフォーマンスへの影響
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MAF04] found that some middleboxes and end hosts may drop packets with unknown TCP options. Studies ([LANGLEY06] [HNRGHT11]) have found that 6% of the probed paths on the Internet drop SYN packets with data or with unknown TCP options. The TFO protocol deals with this problem by falling back to the regular TCP handshake and retransmitting the SYN without data or cookie options after the initial SYN timeout. Moreover, the implementation is recommended to negatively cache such incidents to avoid recurring timeouts. Further study is required to evaluate the performance impact of these drop behaviors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【MAF04】いくつかの中間装置とエンドホストが不明なTCPオプションを持つパケットをドロップすることができることを見出しました。研究（[LANGLEY06] [HNRGHT11]）がらは、SYNパケットデータに、または未知のTCPオプションを持つインターネット降下にプローブ経路の6％。最初のSYNタイムアウトの後にデータやクッキーのオプションを指定せずにSYNを通常のTCPハンドシェイクにフォールバックして再送信することによって、この問題を持つTFOプロトコルを扱っています。また、実装はマイナスタイムアウトを繰り返しを避けるためにこのような事件をキャッシュすることをお勧めします。さらなる研究は、これらのドロップ行動のパフォーマンスへの影響を評価するために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another interesting study is the loss of TFO performance benefit behind certain Carrier-Grade NAT (CGN). Typically, hosts behind a NAT sharing the same IP address will get the same cookie for the same server. This will not prevent TFO from working. But, on some CGN configurations where every new TCP connection from the same physical host uses a different public IP address, TFO does not provide latency benefits. However, there is no performance penalty either, as described in the &#34;Client: Receiving SYN-ACK&#34; text in Section 4.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう一つの興味深い研究では、特定のキャリアグレードNAT（CGN）の背後にTFO性能上の利益の損失です。一般的に、同じIPアドレスを共有するNATの背後にあるホストは、同じサーバーに同じクッキーを取得します。これは、作業からTFOを防ぐことはできません。しかし、同一の物理ホストからのすべての新しいTCP接続が異なるパブリックIPアドレスを使用して、いくつかのCGN構成で、TFOは、待ち時間の利点を提供していません。 4.2.2のテキスト：「受信SYN-ACKクライアント」で説明したようにしかし、パフォーマンスの低下は、どちらかが存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Impact on Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 輻輳制御への影響
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although TFO does not directly change TCP&#39;s congestion control, there are subtle cases where it could do so. When a SYN-ACK times out, regular TCP reduces the initial congestion window before sending any data [RFC5681]. However, in TFO, the server may have already sent up to an initial window of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFOは、直接TCPの輻輳制御を変更しませんが、それはそうすることができ、微妙な場合があります。ときにSYN-ACKがタイムアウトすると、通常のTCPは、任意のデータ[RFC5681]を送信する前に初期の輻輳ウィンドウを削減します。しかし、TFOに、サーバがすでにデータの初期画面にまで送られている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server serves mostly short connections, then the losses of SYN-ACKs are not as effective as regular TCP on reducing the congestion window. This could result in an unstable network condition. The connections that experience losses may attempt again and add more load under congestion. A potential solution is to temporarily disable Fast Open if the server observes many SYN-ACK or data losses during the handshake across connections. Further experimentation regarding the congestion control impact will be useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、主に短い接続を提供している場合は、SYN-ACKの損失は、輻輳ウィンドウを減らす上で、通常のTCPほど効果的ではありません。これは、不安定なネットワーク状態になる可能性があります。損失を経験する接続が再び試みて、混雑の下でより多くの負荷を追加することができます。潜在的な解決策は、サーバーが接続間のハンドシェイク中に多くのSYN-ACKまたはデータ損失を観測した場合、一時的に高速オープン無効にすることです。輻輳制御の影響に関するさらなる実験は有用であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Cookie-less Fast Open
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. クッキーレス高速オープン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookie mechanism mitigates resource exhaustion and amplification attacks. However, cookies are not necessary if the server has application-level protection or is immune to these attacks. For example, a Web server that only replies with a simple HTTP redirect response that fits in the SYN-ACK packet may not care about resource exhaustion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クッキーのメカニズムは、資源の枯渇と増幅攻撃を軽減します。サーバーがアプリケーションレベルの保護を持っているか、これらの攻撃に免疫がある場合は、クッキーは必要ありません。例えば、単純なHTTPで応答Webサーバーは、リソースの枯渇を気にしないかもしれないSYN-ACKパケットに収まる応答をリダイレクトします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For such applications the server may choose to generate a trivial or even a zero-length cookie to improve performance by avoiding the cookie generation and verification. If the server believes it&#39;s under a DoS attack through other defense mechanisms, it can switch to regular Fast Open for listener sockets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようなアプリケーションのためのサーバは、クッキーの生成と検証を回避することにより、パフォーマンスを向上させるために、些細な、あるいは長さがゼロのクッキーを生成することもできます。サーバは、それが他の防御機構によるDoS攻撃の下だと考えている場合は、それがリスナーソケットのための定期的な高速のオープンに切り替えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Related Work
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.関連研究
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. T/TCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.  T / TCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP Extensions for Transactions [RFC1644] attempted to bypass the 3WHS, among other things; hence, it shared the same goal but also the same set of issues as TFO. It focused most of its effort battling old or duplicate SYNs, but paid no attention to security vulnerabilities it introduced when bypassing the 3WHS [PHRACK98].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
取引[RFC1644]のためのTCP拡張機能は、とりわけ、3WHSを回避しようとしました。したがって、それは同じ目標だけでなく、TFOなどの問題の同じセットを共有しました。これは、古いまたは重複のSYNを戦っその努力のほとんどを集中しますが、3WHS [PHRACK98]をバイパスするとき、それが導入されたセキュリティ上の脆弱性に注意を払いませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated earlier, we take a practical approach to focus TFO on the security aspect, while allowing old, duplicate SYN packets with data after recognizing that 100% TCP semantics is likely infeasible. We believe this approach strikes the right trade-off and makes TFO much simpler and more appealing to TCP implementers and users.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先に述べたように、我々は古い可能にしながら、おそらく実行不可能である100％のTCPのセマンティクスことを認識した後のデータを持つSYNパケットを複製し、セキュリティ面にTFOを集中する実用的なアプローチを取ります。私たちは、このアプローチは、右のトレードオフを打つと、TCPの実装とユーザーに非常に簡単でより魅力的なTFOになると信じています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Common Defenses against SYN Flood Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.  SYNフラッド攻撃に対する一般的な防御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987] studies the mitigation of attacks from regular SYN floods, i.e., SYNs without data. But from the stateless SYN cookies to the stateful SYN Cache, none can preserve data sent with SYNs safely while still providing an effective defense.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987]はデータなしで正規SYNフラッド攻撃からの緩和、即ち、のSYNを研究します。しかし、ステートフルSYNキャッシュにステートレスSYNクッキーから、どれもまだ効果的な防御を提供しながら、安全のSYNで送信されたデータを保存することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The best defense may be simply to disable TFO when a host is suspected to be under a SYN flood attack, e.g., the SYN backlog is filled. Once TFO is disabled, normal SYN flood defenses can be applied. The &#34;Security Considerations&#34; section (Section 5) contains a thorough discussion on this topic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストがSYNフラッド攻撃を受けていると疑われる場合に最良の防御は、TFOを無効にするだけであってよく、例えば、SYNのバックログが満たされています。 TFOが無効になっていると、通常のSYNフラッド防御を適用することができます。 「セキュリティの考慮事項」のセクション（セクション5）は、このトピックに関する徹底的な議論が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Speculative Connections by the Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. アプリケーションによって投機的接続
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some Web browsers maintain a history of the domains for frequently visited Web pages. The browsers then speculatively pre-open TCP connections to these domains before the user initiates any requests for them [BELSHE11]. While this technique also saves the handshake latency, it wastes server and network resources by initiating and maintaining idle connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のWebブラウザは、頻繁に訪問したWebページのドメインの歴史を維持します。ブラウザは、投機的にプレオープン、これらのドメインへのTCP接続をユーザーが彼らのためにすべての要求[BELSHE11]を開始する前に。この技術はまた、ハンドシェイクの待ち時間を節約できますが、それはアイドル状態の接続を開始し、維持することにより、サーバやネットワークのリソースを無駄にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. Fast Open Cookie-in-FIN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. 高速オープンクッキー・イン・FIN
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternate proposal is to request a TFO cookie in the FIN instead, since FIN-drop by incompatible middleboxes does not affect latency. However, paths that block SYN cookies may be more likely to drop a later SYN packet with data, and many applications close a connection with RST instead anyway.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代替案は、互換性のないミドルボックスによってFIN-ドロップは、待ち時間に影響を与えていないので、代わりにFINでTFOクッキーを要求することです。しかし、SYNクッキーをブロックするパスは、データを後からSYNパケットをドロップする可能性が高いとすることができ、多くのアプリケーションではなく、とにかくRSTとの接続を閉じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although cookie-in-FIN may not improve robustness, it would give clients using a single connection a latency advantage over clients opening multiple parallel connections. If experiments with TFO find that it leads to increased connection-sharding, cookie-in-FIN may prove to be a useful alternative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クッキーにフィンロバスト性を改善しないかもしれないが、それは複数の並列接続を開くクライアント上の単一の接続待ち時間の利点を使用してクライアントを与えるだろう。 TFOでの実験は、それが増加し、接続-シャーディングにつながることが判明した場合は、クッキー・イン・FINは、有用な代替になるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. TCP Cookie Transaction (TCPCT)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5.  TCPクッキートランザクション（TCPCT）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPCT [RFC6013] eliminates server state during the initial handshake and defends spoofing DoS attacks. Like TFO, TCPCT allows SYN and SYN-ACK packets to carry data. But the server can only send up to MSS bytes of data during the handshake instead of the initial congestion window, unlike TFO. Therefore, the latency of applications (e.g., Web applications) may be worse than with TFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPCT [RFC6013]は、初期ハンドシェイク中にサーバの状態を解消し、DoS攻撃を偽装守ります。 TFOのように、TCPCTはSYNとSYN-ACKパケットはデータを運ぶことができます。しかし、サーバが唯一のTFOとは違って、握手の代わりに、初期の輻輳ウィンドウ中にデータのMSSのバイトまで送信することができます。したがって、アプリケーション（例えば、ウェブ・アプリケーション）の待ち時間は、TFOとより悪いかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has allocated one value, 34, in the &#34;TCP Option Kind Numbers&#34; registry. See Section 4.1.1. The length of this new TCP option is variable, and the Meaning as shown in the &#34;TCP Option Kind Numbers&#34; registry is set to &#34;TCP Fast Open Cookie&#34;. Current and new implementations SHOULD use option (34). Existing implementations that are using experimental option 254 per [RFC6994] with magic number 0xF989 (16 bits) as allocated in the IANA &#34;TCP Experimental Option Experiment Identifiers (TCP ExIDs)&#34; registry by this document, SHOULD migrate to use this new option (34) by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「TCPオプション種別番号」レジストリに、一つの値、34を割り当てています。 4.1.1項を参照してください。この新しいTCPオプションの長さは可変であり、かつ「TCPオプション種別番号」にレジストリを示すように、意味は「高速TCPオープンクッキー」に設定されています。現在、新たな実装はオプション（34）を使用してください。本文書によりIANA「TCP実験オプション実験識別子（TCP ExIDs）」レジストリに割り当てられたとして、この新しいオプションを使用するように移行する必要がありマジックナンバー0xF989（16ビット）と[RFC6994]あたりの実験オプション254を使用している既存の実装（34 ）デフォルトでは。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981, &lt;http://www.rfc-editor.org/info/rfc793&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、1981年9月、&lt;http://www.rfc-editor.org/info/rfc793&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., Ed., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, October 1989, &lt;http://www.rfc-editor.org/info/rfc1122&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122]ブレーデン、R.、エド、 &#34;インターネットホストのための要件 - 通信層&#34;。、STD 3、RFC 1122、1989年10月、&lt;http://www.rfc-editor.org/info/rfc1122&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月、&lt;http://www.rfc-editor.org/info/rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3390] Allman, M., Floyd, S., and C. Partridge, &#34;Increasing TCP&#39;s Initial Window&#34;, RFC 3390, October 2002, &lt;http://www.rfc-editor.org/info/rfc3390&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3390]オールマン、M.、フロイド、S.、およびC.ヤマウズラ、 &#34;TCPの初期ウィンドウを増やす&#34;、RFC 3390、2002年10月、&lt;http://www.rfc-editor.org/info/rfc3390&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5382] Guha, S., Ed., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, &#34;NAT Behavioral Requirements for TCP&#34;, BCP 142, RFC 5382, October 2008, &lt;http://www.rfc-editor.org/info/rfc5382&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5382]グハ、S.、エド。、ビスワス、K.、フォード、B.、シバクマー、S.、およびP. Srisuresh、 &#34;TCPのためのNATの行動の要件&#34;、BCP 142、RFC 5382、2008年10月、&lt;HTTP ：//www.rfc-editor.org/info/rfc5382&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, September 2009, &lt;http://www.rfc-editor.org/info/rfc5681&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 &#34;TCP輻輳制御&#34;、RFC 5681、2009年9月、&lt;http://www.rfc-editor.org/info/rfc5681&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6994] Touch, J., &#34;Shared Use of Experimental TCP Options&#34;, RFC 6994, August 2013, &lt;http://www.rfc-editor.org/info/rfc6994&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6994]タッチ、J.、 &#34;実験TCPオプションの共同利用&#34;、RFC 6994、2013年8月、&lt;http://www.rfc-editor.org/info/rfc6994&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AERG11] Al-Fares, M., Elmeleegy, K., Reed, B., and I. Gashinsky, &#34;Overclocking the Yahoo! CDN for Faster Web Page Loads&#34;, in Proceedings of Internet Measurement Conference, November 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AERG11]アル・運賃、M.、Elmeleegy、K.、リード、B.、およびI. Gashinsky、インターネット測定コンファレンス、2011年11月の議事録では、 &#34;より高速なWebページのロードのためのヤフーCDNをオーバークロック&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BELSHE11] Belshe, M., &#34;The Era of Browser Preconnect&#34;, February 2011, &lt;http://www.belshe.com/2011/02/10/ the-era-of-browser-preconnect/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BELSHE11] Belshe、M.、 &#34;ブラウザ事前接続の時代&#34;、2011年2月、&lt;http://www.belshe.com/2011/02/10/時代-のブラウザ-事前接続/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BRISCOE12] Briscoe, B., &#34;Some ideas building on draft-ietf-tcpm-fastopen-01&#34;, message to the tcpm mailing list, July 2012, &lt;http://www.ietf.org/mail-archive/ web/tcpm/current/msg07192.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BRISCOE12]ブリスコー、B.、 &#34;ドラフト-IETF-tcpm-FASTOPEN-01上で構築するいくつかのアイデア&#34;、tcpmメーリングリストへのメッセージ、2012年7月、&lt;http://www.ietf.org/mail-archive/ウェブ/tcpm/current/msg07192.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Chrome] Google Chrome, &lt;https://www.google.com/intl/en-US/chrome/browser/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[クローム] Google Chromeの、&lt;https://www.google.com/intl/en-US/chrome/browser/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HNESSK10] Haetoenen, S., Nyrhinen, A., Eggert, L., Strowes, S., Sarolahti, P., and M. Kojo, &#34;An Experimental Study of Home Gateway Characteristics&#34;, in Proceedings of Internet Measurement Conference, October 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HNESSK10] Haetoenen、S.、Nyrhinen、A.、エッゲルト、L.、Strowes、S.、Sarolahti、P.、およびM.古城、 &#34;ホームゲートウェイ特性の実験的研究&#34;、インターネット測定会議の議事録では、 2010年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HNRGHT11] Honda, M., Nishida, Y., Raiciu, C., Greenhalgh, A., Handley, M., and H. Tokuda, &#34;Is it Still Possible to Extend TCP?&#34;, in Proceedings of Internet Measurement Conference, November 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HNRGHT11]ホンダ、M.、西田、Y.、Raiciu、C.、グリーンハル、A.、ハンドリー、M.、およびH.徳田は、 &#34;TCPを拡張することは可能ですか？&#34;、インターネット測定会議の議事録で、2011年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[JIDKT07] Jaiswal, S., Iannaccone, G., Diot, C., Kurose, J., and D. Towsley, &#34;Measurement and Classification of Out-of-Sequence Packets in a Tier-1 IP Backbone&#34; IEEE/ACM Transactions on Networking (TON), Volume 15, Issue 1, pp 54-66.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【JIDKT07] Jaiswal、S.、Iannaccone、G.、Diot、C.、黒瀬、J.、およびD. Towsley、IEEE / ACM &#34;ティア1のIPバックボーンにおける測定とアウトオブシーケンスパケットの分類&#34;ネットワーク上の取引（TON）、15巻、1号、頁54-66。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LANGLEY06] Langley, A., &#34;Probing the viability of TCP extensions&#34;, &lt;http://www.imperialviolet.org/binary/ecntest.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LANGLEY06]ラングレー、A.は、 &#34;TCP拡張の実行可能性を探る&#34;、&lt;http://www.imperialviolet.org/binary/ecntest.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MAF04] Medina, A., Allman, M., and S. Floyd, &#34;Measuring Interactions Between Transport Protocols and Middleboxes&#34;, in Proceedings of Internet Measurement Conference, October 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MAF04]メディナ、A.、オールマン、M.、およびS.フロイド、インターネット測定コンファレンス、2004年10月の議事録では、「トランスポートプロトコルとのMiddleboxes間の相互作用を測定します」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MQXMZ11] Wang, Z., Qian, Z., Xu, Q., Mao, Z., and M. Zhang, &#34;An Untold Story of Middleboxes in Cellular Networks&#34;, in Proceedings of SIGCOMM, August 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SIGCOMM、2011年8月の議事録で[MQXMZ11]王、Z.、銭、Z.、徐、Q.、真央、Z.、およびM.張、 &#34;セルラーネットワーク内のMiddleboxesの秘話&#34;、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PHRACK98] &#34;T/TCP vulnerabilities&#34;, Phrack Magazine, Volume 8, Issue 53, Article 6, July 8, 1998, &lt;http://www.phrack.com/issues.html?issue=53&amp;id=6&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PHRACK98] &#34;T / TCPの脆弱性&#34;、Phrack誌、8巻、号53、第6条、1998年7月8日、&lt;http://www.phrack.com/issues.html?issue=53&amp;id=6&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RCCJR11] Radhakrishnan, S., Cheng, Y., Chu, J., Jain, A., and B. Raghavan, &#34;TCP Fast Open&#34;, in Proceedings of the 7th ACM CoNEXT Conference, December 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【RCCJR11]ラダクリシュナン、S.、チェン、Y.、チュー、J.、ジェイン、A.およびB.ラガバン、 &#34;TCP高速開く&#34;、第7回ACM CoNEXT会議、2011年12月の議事録です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1323] Jacobson, V., Braden, R., and D. Borman, &#34;TCP Extensions for High Performance&#34;, RFC 1323, May 1992, &lt;http://www.rfc-editor.org/info/rfc1323&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1323]ジェーコブソン、V.、ブレーデン、R.、およびD.ボーマン、 &#34;ハイパフォーマンスのためのTCP拡張&#34;、RFC 1323、1992年5月、&lt;http://www.rfc-editor.org/info/rfc1323&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1644] Braden, R., &#34;T/TCP -- TCP Extensions for Transactions Functional Specification&#34;, RFC 1644, July 1994, &lt;http://www.rfc-editor.org/info/rfc1644&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1644]ブレーデン、R.、 &#34;T / TCP  -  TCP拡張取引に関する機能仕様&#34;、RFC 1644、1994年7月、&lt;http://www.rfc-editor.org/info/rfc1644&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998, &lt;http://www.rfc-editor.org/info/rfc2460&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460]デアリング、S.とR. Hindenと、 &#34;インターネットプロトコルバージョン6（IPv6）の仕様&#34;、RFC 2460、1998年12月、&lt;http://www.rfc-editor.org/info/rfc2460&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987] Eddy, W., &#34;TCP SYN Flooding Attacks and Common Mitigations&#34;, RFC 4987, August 2007, &lt;http://www.rfc-editor.org/info/rfc4987&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987]エディ、W.、 &#34;TCPのSYNフラッド攻撃と共通の軽減策&#34;、RFC 4987、2007年8月、&lt;http://www.rfc-editor.org/info/rfc4987&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6013] Simpson, W., &#34;TCP Cookie Transactions (TCPCT)&#34;, RFC 6013, January 2011, &lt;http://www.rfc-editor.org/info/rfc6013&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6013]シンプソン、W.、 &#34;TCPクッキー取引（TCPCT）&#34;、RFC 6013、2011年1月、&lt;http://www.rfc-editor.org/info/rfc6013&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6247] Eggert, L., &#34;Moving the Undeployed TCP Extensions RFC 1072, RFC 1106, RFC 1110, RFC 1145, RFC 1146, RFC 1379, RFC 1644, and RFC 1693 to Historic Status&#34;, RFC 6247, May 2011, &lt;http://www.rfc-editor.org/info/rfc6247&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6247]エッゲルト、L.、 &#34;歴史的な状態へのアンデプロイTCP拡張機能RFC 1072、RFC 1106、RFC 1110、RFC 1145、RFC 1146、RFC 1379、RFC 1644、およびRFC 1693の移動&#34; RFC 6247、2011年5月、&lt; http://www.rfc-editor.org/info/rfc6247&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7323] Borman, D., Braden, B., Jacobson, V., and R. Scheffenegger, Ed., &#34;TCP Extensions for High Performance&#34;, RFC 7323, September 2014, &lt;http://www.rfc-editor.org/info/rfc7323&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7323]ボーマン、D.、ブレーデン、B.、ヤコブソン、V.、およびR. Scheffenegger、エド、 &#34;ハイパフォーマンスのためのTCP拡張&#34;、RFC 7323、2014年9月、&lt;のhttp：。//www.rfc-editor .ORG /情報/ rfc7323&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SOUDERS11] Souders, S., &#34;Making A Mobile Connection&#34;, &lt;http://www.stevesouders.com/blog/2011/09/21/ making-a-mobile-connection/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【SOUDERS11] Souders、S.、&lt;http://www.stevesouders.com/blog/2011/09/21/製造-移動接続/&gt; &#34;モバイル接続を行います&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Example Socket API Changes to Support TFO
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
TFOをサポートするには、付録A.例ソケットAPIの変更点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1. Active Open
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1。アクティブオープン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The active open side involves changing or replacing the connect() call, which does not take a user data buffer argument. We recommend replacing the connect() call to minimize API changes, and, hence, applications to reduce the deployment hurdle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
能動開放側は、ユーザデータバッファ引数を取らない、Connect（）の呼び出しを、変更または交換することを含みます。私たちは、APIの変更を最小限に抑えるために、Connect（）の呼び出しを交換をお勧めします、そして、したがって、アプリケーションは、展開のハードルを下げるために。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One solution implemented in Linux 3.7 is introducing a new flag, MSG_FASTOPEN, for sendto() or sendmsg(). MSG_FASTOPEN marks the attempt to send data in the SYN like a combination of connect() and sendto(), by performing an implicit connect() operation. It blocks until the handshake has completed and the data is buffered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Linuxの3.7で実装一つの解決策は、新しいフラグを導入し、MSG_FASTOPEN、のsendtoのための（）またはsendmsgの（）です。 MSG_FASTOPENは暗黙接続（）操作を行うことにより、接続（）とのsendto（）の組み合わせのようなSYNにデータを送信しようとする試みをマーク。このブロックは、ハンドシェイクが完了するまで、データがバッファリングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a non-blocking socket, it returns the number of bytes buffered and sent in the SYN packet. If the cookie is not available locally, it returns -1 with errno EINPROGRESS, and sends a SYN with a TFO cookie request automatically. The caller needs to write the data again when the socket is connected. On errors, it returns the same errno as connect() if the handshake fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非ブロッキングソケットの場合は、SYNパケットにバッファリングし、送信したバイト数を返します。クッキーはローカルで利用できない場合、この関数はerrno EINPROGRESSと-1を返し、自動的にTFOクッキー要求とSYNを送信します。呼び出し側は、ソケットが接続されたときに再びデータを書き込む必要があります。ハンドシェイクが失敗した場合、エラーには、それは）（接続と同じエラー番号を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation may prefer not to change the sendmsg() call because TFO is a TCP-specific feature. A solution is to add a new socket option, TCP_FASTOPEN, for TCP sockets. When the option is enabled before a connect() operation, sendmsg() or sendto() will perform a Fast Open operation similar to the MSG_FASTOPEN flag described above. This approach, however, requires an extra setsockopt() system call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装はTFOはTCP特有の機能であるためにsendmsg（）呼び出しを変更しないことを好むことがあります。ソリューションは、TCPソケットのために、新しいソケットオプション、TCP_FASTOPENを追加することです。オプション接続（）オペレーション、にsendmsg（）またはのsendto（前に有効になっている場合）上記MSG_FASTOPENフラグと同様の高速オープン操作を実行します。このアプローチは、しかし、余分のsetsockopt（）システムコールが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2. Passive Open
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2。パッシブオープン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The passive open side change is simpler compared to the active open side. The application only needs to enable the reception of Fast Open requests via a new TCP_FASTOPEN setsockopt() socket option before listen().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パッシブオープン側の変化は、活性開放側に比べて簡単です。アプリケーションのみ）（聞く前に、新しいTCP_FASTOPENのsetsockopt（）ソケットオプションを経由して高速のオープン要求の受信を有効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The option enables Fast Open on the listener socket. The option value specifies the PendingFastOpenRequests threshold, i.e., the maximum length of pending SYNs with data payload. Once enabled, the TCP implementation will respond with TFO cookies per request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションでは、リスナーソケットのファストオープンできます。オプション値はPendingFastOpenRequests閾値、データペイロードを持つ保留中のSYNの、すなわち、最大の長さを指定します。有効にすると、TCPの実装では、要求ごとTFOクッキーで応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Traditionally, accept() returns only after a socket is connected. But, for a Fast Open connection, accept() returns upon receiving a SYN with a valid Fast Open cookie and data, and the data is available to be read through, e.g., recvmsg(), read().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
伝統的に、）（受け入れるソケットが接続された後にのみ返します。しかし、高速オープン接続のために、（受け入れる））の有効な高速オープンクッキーとデータとSYNを受けて返し、データを介して読み出すことに利用可能であり、例えば、のrecvmsg（）、（読み出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We thank Bob Briscoe, Michael Scharf, Gorry Fairhurst, Rick Jones, Roberto Peon, William Chan, Adam Langley, Neal Cardwell, Eric Dumazet, and Matt Mathis for their feedback. We especially thank Barath Raghavan for his contribution on the security design of Fast Open and proofreading this document numerous times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、彼らのフィードバックのためにボブ・ブリスコー、マイケル・シャーフ、Gorry Fairhurst、リック・ジョーンズ、ロベルトペオン、ウィリアム・チャン、アダム・ラングレー、ニールカードウェル、エリックDumazet、そしてマット・マティスに感謝します。我々は、特に高速を開き、この文書の校正、多数回のセキュリティ設計上の彼の貢献のためにBarathラガバンに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yuchung Cheng Google, Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yuchungチェングーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: ycheng@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：ycheng@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jerry Chu Google, Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジェリー・チューグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: hkchu@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：hkchu@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sivasankar Radhakrishnan Department of Computer Science and Engineering University of California, San Diego 9500 Gilman Drive La Jolla, CA 92093-0404 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンピュータサイエンスとカリフォルニアのエンジニアリング大学のSivasankarラダクリシュナン科、サンディエゴ9500ギルマンドライブラ・ホーヤ、CA 92093から0404米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: sivasankar@cs.ucsd.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：sivasankar@cs.ucsd.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Arvind Jain Google, Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 United States
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アービンドジャイナグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: arvind@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：arvind@google.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
