<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 4086 - Randomness Requirements for Security 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 4086 - Randomness Requirements for Security 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc4086">
              https://tools.ietf.org/html/rfc4086
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 4086 - セキュリティのためのランダム性の要件</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                   D. Eastlake, 3rd
Request for Comments: 4086                         Motorola Laboratories
BCP: 106                                                     J. Schiller
Obsoletes: 1750                                                      MIT
Category: Best Current Practice                               S. Crocker
                                                               June 2005
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  Randomness Requirements for Security
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットコミュニティのためのインターネットBest Current Practicesを指定し、改善のための議論と提案を要求します。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2005）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts. However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities. The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティシステムは、パターン分析の試みをくじく強力な暗号化アルゴリズムに基づいて構築されています。しかし、これらのシステムのセキュリティは、パスワード、暗号化キー、および同様の量のために秘密量の生成に依存しています。秘密量を生成するための擬似ランダムプロセスの使用は、擬似セキュリティをもたらす可能性があります。洗練された攻撃者は、それが簡単に秘密量を生産し、潜在的な数のスペースの全体の数量を検索するには以下の可能性の結果の小さなセットを検索するための環境を再現するために見つけることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult. This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities. It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
機知とやる気の敵をくじくためにランダムな量を選択することは意外に難しいです。この文書は、乏しいエントロピー源またはそのような量を生成するための伝統的な疑似乱数生成技術を使用して多くの落とし穴を指摘します。これは、真にランダムなハードウェア技術の使用を推奨していますし、多くのシステム上の既存のハードウェアは、この目的のために使用することができることを示しています。これは、ハードウェアソリューションが利用できない場合、問題を改善するための提案を提供し、そしてそれは、そのような量は、いくつかのアプリケーションのためにする必要がどのように大型の例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction and Overview .......................................3
   2. General Requirements ............................................4
   3. Entropy Sources .................................................7
      3.1. Volume Required ............................................7
      3.2. Existing Hardware Can Be Used For Randomness ...............8
           3.2.1. Using Existing Sound/Video Input ....................8
           3.2.2. Using Existing Disk Drives ..........................8
      3.3. Ring Oscillator Sources ....................................9
      3.4. Problems with Clocks and Serial Numbers ...................10
      3.5. Timing and Value of External Events .......................11
      3.6. Non-hardware Sources of Randomness ........................12
   4. De-skewing .....................................................12
      4.1. Using Stream Parity to De-Skew ............................13
      4.2. Using Transition Mappings to De-Skew ......................14
      4.3. Using FFT to De-Skew ......................................15
      4.4. Using Compression to De-Skew ..............................15
   5. Mixing .........................................................16
      5.1. A Trivial Mixing Function .................................17
      5.2. Stronger Mixing Functions .................................18
      5.3. Using S-Boxes for Mixing ..................................19
      5.4. Diffie-Hellman as a Mixing Function .......................19
      5.5. Using a Mixing Function to Stretch Random Bits ............20
      5.6. Other Factors in Choosing a Mixing Function ...............20
   6. Pseudo-random Number Generators ................................21
      6.1. Some Bad Ideas ............................................21
           6.1.1. The Fallacy of Complex Manipulation ................21
           6.1.2. The Fallacy of Selection from a Large Database .....22
           6.1.3. Traditional Pseudo-random Sequences ................23
      6.2. Cryptographically Strong Sequences ........................24
           6.2.1. OFB and CTR Sequences ..............................25
           6.2.2. The Blum Blum Shub Sequence Generator ..............26
      6.3. Entropy Pool Techniques ...................................27
   7. Randomness Generation Examples and Standards ...................28
      7.1. Complete Randomness Generators ............................28
           7.1.1. US DoD Recommendations for Password Generation .....28
           7.1.2. The /dev/random Device .............................29
           7.1.3. Windows CryptGenRandom .............................30
      7.2. Generators Assuming a Source of Entropy ...................31
           7.2.1. X9.82 Pseudo-Random Number Generation ..............31
           7.2.2. X9.17 Key Generation ...............................33
           7.2.3. DSS Pseudo-random Number Generation ................34
   8. Examples of Randomness Required ................................34
      8.1. Password Generation .......................................35
      8.2. A Very High Security Cryptographic Key ....................36
   9. Conclusion .....................................................38
  10. Security Considerations ........................................38
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  11. Acknowledgments ................................................39
  Appendix A: Changes from RFC 1750 ..................................40
  Informative References .............................................41
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction and Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめにと概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Software cryptography is coming into wider use, although there is a long way to go until it becomes pervasive. Systems such as SSH, IPSEC, TLS, S/MIME, PGP, DNSSEC, and Kerberos are maturing and becoming a part of the network landscape [SSH] [IPSEC] [TLS] [S/MIME] [MAIL_PGP*] [DNSSEC*]. For comparison, when the previous version of this document [RFC1750] was issued in 1994, the only Internet cryptographic security specification in the IETF was the Privacy Enhanced Mail protocol [MAIL_PEM*].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが普及するまでには長い道のりがあるが、ソフトウェアの暗号は、より広く使用されつつあります。そのようなSSH、IPSEC、TLS、S / MIME、PGP、DNSSEC、およびKerberosのようなシステムでは、[SSH] [IPSEC] [TLS] [S / MIME] [MAIL_PGP *] [DNSSEC *成熟及びネットワーク風景の一部になってきています]。このドキュメント[RFC1750]の以前のバージョンが1994年に発行された比較については、IETFにおける唯一のインターネットの暗号化セキュリティ仕様は、プライバシー強化メールプロトコル[MAIL_PEM *]でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These systems provide substantial protection against snooping and spoofing. However, there is a potential flaw. At the heart of all cryptographic systems is the generation of secret, unguessable (i.e., random) numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのシステムは、スヌーピングおよびなりすましに対するかなりの保護を提供します。しかし、潜在的な欠陥があります。すべての暗号システムの心臓部には秘密、推測できない（すなわち、ランダムな）数字の世代です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The lack of generally available facilities for generating such random numbers (that is, the lack of general availability of truly unpredictable sources) forms an open wound in the design of cryptographic software. For the software developer who wants to build a key or password generation procedure that runs on a wide range of hardware, this is a very real problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのような乱数を生成するために一般に利用可能な施設の不足は（つまり、本当に予測不可能な源の一般的な利用可能性の欠如である）暗号化ソフトウェアの設計における開いた傷を形成しています。ハードウェアの広い範囲で実行されますキーまたはパスワード生成手順を構築したいソフトウェア開発者にとって、これは非常に現実的な問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the requirement is for data that an adversary has a very low probability of guessing or determining. This can easily fail if pseudo-random data is used that meets only traditional statistical tests for randomness, or that is based on limited-range sources such as clocks. Sometimes such pseudo-random quantities can be guessed by an adversary searching through an embarrassingly small space of possibilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要件は敵が推測又は決定の非常に低い確率を有するデータのためのものであることに留意されたいです。擬似ランダムデータがランダムのための唯一の伝統的な統計的試験を満たす、またはそれをクロックなどの限られた範囲のソースに基づいているが使用される場合、これは簡単に失敗することができます。時々、このような擬似ランダム量は、可能性のあきれるほど小さな空間を検索敵によって推測することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This Best Current Practice document describes techniques for producing random quantities that will be resistant to attack. It recommends that future systems include hardware random number generation or provide access to existing hardware that can be used for this purpose. It suggests methods for use if such hardware is not available, and it gives some estimates of the number of random bits required for sample applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この最も良い現在の練習のドキュメントは、攻撃に耐性になるランダムな量を生産するための技術を説明しています。これは、将来のシステムは、ハードウェア乱数生成を含めるか、この目的のために使用することができ、既存のハードウェアへのアクセスを提供することをお勧めします。そのようなハードウェアが利用できない場合には、使用のための方法を提案し、それがサンプルアプリケーションに必要なランダムビットの数のいくつかの見積もりを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. General Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.一般的な要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Today, a commonly encountered randomness requirement is to pick a user password, usually a simple character string. Obviously, a password that can be guessed does not provide security. For re-usable passwords, it is desirable that users be able to remember the password. This may make it advisable to use pronounceable character strings or phrases composed of ordinary words. But this affects only the format of the password information, not the requirement that the password be very hard to guess.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
今日では、一般的に遭遇するランダム性の要件は、ユーザーパスワード、通常は単純な文字列を選択することです。もちろん、推測できるパスワードは、セキュリティを提供しません。再利用可能なパスワードの場合、ユーザーがパスワードを覚えておくことが可能であることが望ましいです。これは普通の言葉で構成される発音可能な文字列やフレーズを使用することをお勧めかもしれません。しかし、これはパスワード情報の形式のみではなく、パスワードを推測するのは非常に困難であるという要件に影響を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many other requirements come from the cryptographic arena. Cryptographic techniques can be used to provide a variety of services, including confidentiality and authentication. Such services are based on quantities, traditionally called &#34;keys&#34;, that are unknown to and unguessable by an adversary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他の多くの要件は、暗号アリーナから来ます。暗号技術は、機密性と認証など様々なサービスを提供するために使用することができます。このようなサービスは、伝統的に敵によると、未知と推測できないある「キー」と呼ばれる、数量に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are even TCP/IP protocol uses for randomness in picking initial sequence numbers [RFC1948].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でも、TCP / IPプロトコルが初期シーケンス番号[RFC1948]を選んでランダム性のために使用されますがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Generally speaking, the above examples also illustrate two different types of random quantities that may be wanted. In the case of human-usable passwords, the only important characteristic is that they be unguessable. It is not important that they may be composed of ASCII characters, so the top bit of every byte is zero, for example. On the other hand, for fixed length keys and the like, one normally wants quantities that appear to be truly random, that is, quantities whose bits will pass statistical randomness tests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に言えば、上記の例はまた、指名手配され得るランダムな量の二つの異なるタイプを示しています。人間が使用可能なパスワードの場合は、唯一の重要な特徴は、彼らが推測できないことです。彼らがASCII文字で構成することができるということは重要ではないので、各バイトの最上位ビットは、例えば、ゼロです。一方、固定長キーなど、1つは、通常表示された量は、そのビット量が統計的乱数テストに合格する、すなわち、真にランダムであることを望んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In some cases, such as the use of symmetric encryption with the one-time pads or an algorithm like the US Advanced Encryption Standard [AES], the parties who wish to communicate confidentially and/or with authentication must all know the same secret key. In other cases, where asymmetric or &#34;public key&#34; cryptographic techniques are used, keys come in pairs. One key of the pair is private and must be kept secret by one party; the other is public and can be published to the world. It is computationally infeasible to determine the private key from the public key, and knowledge of the public key is of no help to an adversary [ASYMMETRIC]. See general references [SCHNEIER, FERGUSON, KAUFMAN].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
こうしたワンタイムパッドや米国のAdvanced Encryption Standard [AES]のようなアルゴリズムを用いて対称暗号化を使用するなど、いくつかのケースでは、および/または認証で内密に通信することを望む当事者は、すべて同じ秘密鍵を知っている必要があります。非対称または「公開鍵」暗号技術が使用されている他の例では、キーはペアで来ます。ペアの一つの鍵は、プライベートで、一方の当事者によって秘密にしなければなりません。他は公開され、世界に公開することができます。公開鍵から秘密鍵を決定するために計算上不可能である、と公開鍵の知識は敵[ASYMMETRIC]に役に立たないのです。一般的な参考文献[SCHNEIER、FERGUSON、KAUFMAN]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The frequency and volume of the requirement for random quantities differs greatly for different cryptographic systems. With pure RSA, random quantities are required only when a new key pair is generated; thereafter, any number of messages can be signed without a further need for randomness. The public key Digital Signature Algorithm devised by the US National Institute of Standards and Technology (NIST) requires good random numbers for each signature [DSS]. And
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ランダム量の要求の頻度と量は、異なる暗号化システムのために大きく異なります。純粋なRSAを使用すると、ランダムな量は、新たな鍵ペアが生成された場合にのみ必要とされています。その後、メッセージの任意の数はランダムのためのさらなる必要性なしに署名することができます。米国国立標準技術研究所（NIST）によって考案された公開鍵デジタル署名アルゴリズムは、各署名[DSS]のための良い乱数を必要とします。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
encrypting with a one-time pad (in principle the strongest possible encryption technique) requires randomness of equal volume to all the messages to be processed. See general references [SCHNEIER, FERGUSON, KAUFMAN].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（原則的に可能な限り強力な暗号化技術）ワンタイムパッドで暗号化する処理されるすべてのメッセージに等しい量のランダム性を必要とします。一般的な参考文献[SCHNEIER、FERGUSON、KAUFMAN]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In most of these cases, an adversary can try to determine the &#34;secret&#34; key by trial and error. This is possible as long as the key is enough smaller than the message that the correct key can be uniquely identified. The probability of an adversary succeeding at this must be made acceptably low, depending on the particular application. The size of the space the adversary must search is related to the amount of key &#34;information&#34; present, in an information-theoretic sense [SHANNON]. This depends on the number of different secret values possible and the probability of each value, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのケースのほとんどでは、敵は試行錯誤によって「秘密」キーを決定しようとすることができます。これは、長い鍵が正しい鍵を一意に識別することができるメッセージよりも十分に小さくなるように可能です。これに後続攻撃の確率は、特定の用途に応じて、許容可能な低されなければなりません。敵対者が検索しなければならないスペースのサイズは、情報理論的な意味[SHANNON]で、キー「情報」とは、本の量に関連しています。これは以下のように、可能な異なる秘密の値の数と、各値の確率に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              -----
                              \
        Bits of information =  \     - p   * log  ( p  )
                               /        i       2    i
                              /
                              -----
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where i counts from 1 to the number of possible secret values and p sub i is the probability of the value numbered i. (Because p sub i is less than one, the log will be negative, so each term in the sum will be non-negative.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私は可能な秘密の値とpサブの数に1から数えるところ私は、私の番値の確率です。 （Pサブiが1未満であるため、ログが負となるので、和の各項は非負であろう。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If there are 2^n different values of equal probability, then n bits of information are present and an adversary would have to try, on the average, half of the values, or 2^(n-1), before guessing the secret quantity. If the probability of different values is unequal, then there is less information present, and fewer guesses will, on average, be required by an adversary. In particular, any values that an adversary can know to be impossible or of low probability can be initially ignored by the adversary, who will search through the more probable values first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
等しい確率の2 ^ n個の異なる値がある場合は、Nの情報ビットが存在し、敵対者は、秘密量を推測する前に、平均して、値の半分を試してみて、または2 ^（N-1）になります。異なる値の確率が等しくない場合、以下の情報が存在し、そしてより少ない推測は、平均して、敵によって必要とされるであろう。特に、敵が不可能または低い確率であることを知ることができる任意の値は、最初はまず、より可能性の高い値を検索します敵によって無視することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, consider a cryptographic system that uses 128-bit keys. If these keys are derived using a fixed pseudo-random number generator that is seeded with an 8-bit seed, then an adversary needs to search through only 256 keys (by running the pseudo-random number generator with every possible seed), not 2^128 keys as may at first appear to be the case. Only 8 bits of &#34;information&#34; are in these 128-bit keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、128ビットの鍵を使用する暗号システムを考えます。これらのキーは、8ビットのシードを播種された固定擬似乱数生成器を用いて導出された場合、敵対者は、256キー（すべての可能なシードで擬似乱数生成器を実行して）を検索する必要はなく、2 ^として128個のキーは、最初のケースであるように見えることができます。 「情報」の8ビットのみでは、これらの128ビットのキーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the above analysis is correct on average, it can be misleading in some cases for cryptographic analysis where what is really important is the work factor for an adversary. For example, assume that there is a pseudo-random number generator generating 128-bit keys, as in the previous paragraph, but that it generates zero half of the time and a random selection from the remaining 2^128 - 1 values the rest of the time. The Shannon equation above says that there are 64 bits of information in one of these key values, but an adversary, simply by trying the value zero, can break the security of half of the uses, albeit a random half. Thus, for cryptographic purposes, it is also useful to look at other measures, such as min-entropy, defined as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の分析は、平均的に正しいですが、それは本当に重要なのは敵の作業因子である、暗号解析のためのいくつかのケースでは誤解を招くことができます。例えば、前の段落のように、128ビットの鍵を生成する擬似乱数生成器が存在すると仮定し、それはゼロ時間の半分と残りの2 ^ 128からランダムに選択生成する - 残りの1の値を時間。上記シャノン方程式は情報の64ビットはこれらのキーの値のいずれかであることを述べているが、敵、単に値ゼロを試みることによって、ランダム半分はいえ、用途の半分のセキュリティを破ることができます。このように、暗号化の目的のために、のように定義されるような最小エントロピーのような他の手段、を見ることも有用です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Min-entropy =  - log  ( maximum ( p  ) )
                                           i
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where i is as above. Using this equation, we get 1 bit of min-entropy for our new hypothetical distribution, as opposed to 64 bits of classical Shannon entropy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、iは、上記のようです。古典シャノンエントロピーの64ビットとは対照的に、この式を用いて、我々は、私たちの新しい仮想的な配布のための最小エントロピーの1ビットを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A continuous spectrum of entropies, sometimes called Renyi entropy, has been defined, specified by the parameter r. Here r = 1 is Shannon entropy and r = infinity is min-entropy. When r = zero, it is just log (n), where n is the number of non-zero probabilities. Renyi entropy is a non-increasing function of r, so min-entropy is always the most conservative measure of entropy and usually the best to use for cryptographic evaluation [LUBY].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時々レーニイエントロピーと呼ばれるエントロピーの連続スペクトルは、パラメータrで指定された、定義されています。ここで、R = 1は、シャノンエントロピー及びR =無限大は最小エントロピーです。 R =ゼロ、それだけ（n）がログインしたとき、nがゼロでない確率の数です。最小エントロピー通常最も保守的エントロピーの尺度とは常に暗号評価[ルビー]のために使用するのが最適であるようレーニイエントロピーは、Rの非増加関数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Statistically tested randomness in the traditional sense is NOT the same as the unpredictability required for security use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
伝統的な意味で統計的にテストしたランダム性は、セキュリティの使用に必要な予測不可能性と同じではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, the use of a widely available constant sequence, such as the random table from the CRC Standard Mathematical Tables, is very weak against an adversary. An adversary who learns of or guesses it can easily break all security, future and past, based on the sequence [CRC]. As another example, using AES with a constant key to encrypt successive integers such as 1, 2, 3, ... will produce output that also has excellent statistical randomness properties but is predictable. On the other hand, taking successive rolls of a six-sided die and encoding the resulting values in ASCII would produce statistically poor output with a substantial unpredictable component. So note that passing or failing statistical tests doesn&#39;t reveal whether something is unpredictable or predictable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、広く利用可能な定配列の使用は、CRC標準的な数学テーブルからランダムテーブルとして、敵に対して非常に弱いです。学習や推測敵は、それが簡単に[CRC]配列に基づいて、すべてのセキュリティ、未来と過去を破ることができます。別の例として、例えば1、2、3のような連続した整数を暗号化するために一定のキーでAESを使用して、...にも優れた統計的ランダム性を有するが、予測可能な出力を生成します。一方、六面ダイスの連続ロールを取り出し、ASCIIで得られた値を符号化することは実質的に予測不可能な成分で統計的に劣った出力を生成します。だから、統計的検定に合格か不合格は何かが予測できないか、予測可能であるかどうかを明らかにしないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Entropy Sources
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.エントロピー源
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Entropy sources tend to be very implementation dependent. Once one has gathered sufficient entropy, it can be used as the seed to produce the required amount of cryptographically strong pseudo-randomness, as described in Sections 6 and 7, after being de-skewed or mixed as necessary, as described in Sections 4 and 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エントロピー源は非常に実装に依存する傾向があります。一つは、十分なエントロピーを集めた後、セクション6および7に記載したように、セクション4で説明したように、必要に応じてまたは混合スキュー解除された後に、暗号的に強い疑似乱数の必要量を生成するためのシードとして用いることができると5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Is there any hope for true, strong, portable randomness in the future? There might be. All that&#39;s needed is a physical source of unpredictable numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
将来的には真、強い、ポータブルランダム性のための任意の希望はありますか？あるかもしれません。必要なのはすべてのことは、予測不可能な数字の物理的なソースです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thermal noise (sometimes called Johnson noise in integrated circuits) or a radioactive decay source and a fast, free-running oscillator would do the trick directly [GIFFORD]. This is a trivial amount of hardware, and it could easily be included as a standard part of a computer system&#39;s architecture. Most audio (or video) input devices are usable [TURBID]. Furthermore, any system with a spinning disk or ring oscillator and a stable (crystal) time source or the like has an adequate source of randomness ([DAVIS] and Section 3.3). All that&#39;s needed is the common perception among computer vendors that this small additional hardware and the software to access it is necessary and useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
熱雑音や放射性崩壊源（時々集積回路のジョンソン・ノイズと呼ばれる）と高速、自走発振器が直接トリックを行うだろう[GIFFORD]。これは、ハードウェアの些細な量であり、それは簡単に、コンピュータ・システムのアーキテクチャの標準一部として含めることができます。ほとんどのオーディオ（またはビデオ）入力デバイス[TURBID]使用可能です。また、回転ディスク又はリング発振器と安定した（結晶）時刻源等と任意のシステムは、ランダム（[DAVIS]とセクション3.3）の適切な供給源を有しています。必要なのはすべてのことは、この小さな追加のハードウェアおよびソフトウェアは、それが必要かつ有用であるアクセスするためのコンピュータ・ベンダーの間で共通の認識です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ANSI X9 is currently developing a standard that includes a part devoted to entropy sources. See Part 2 of [X9.82].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ANSIのX9は、現在のソースをエントロピーに専念一部を含む標準を開発しています。 [X9.82]のパート2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Volume Required
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。ボリュームは必須
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
How much unpredictability is needed? Is it possible to quantify the requirement in terms of, say, number of random bits per second?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どのくらいの予測不可能性を必要とされていますか？それは毎秒ランダムビット数、たとえば、の面で要件を定量化することは可能ですか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The answer is that not very much is needed. For AES, the key can be 128 bits, and, as we show in an example in Section 8, even the highest security system is unlikely to require strong keying material of much over 200 bits. If a series of keys is needed, they can be generated from a strong random seed (starting value) using a cryptographically strong sequence, as explained in Section 6.2. A few hundred random bits generated at start-up or once a day is enough if such techniques are used. Even if the random bits are generated as slowly as one per second and it is not possible to overlap the generation process, it should be tolerable in most high-security applications to wait 200 seconds occasionally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その答えは非常に必要とされないということです。 AESの場合、キーは128ビットであることができ、そして、私たちは第8節の例で示したように、でも最高のセキュリティシステムは、多くの200ビット以上の強力な鍵素材を必要とすることはほとんどありません。一連のキーが必要な場合は、セクション6.2で説明したように、それらは、暗号的に強いシーケンスを使用して、強力なランダムシード（初期値）から生成することができます。起動時またはこのような技術が使用されている場合、十分である一日一回発生した数百個のランダムビット。ランダムビットはゆっくりと毎秒1として生成され、生成プロセスをオーバーラップすることはできませんされている場合でも、それは時折、200秒を待つために最も高セキュリティアプリケーションに耐えなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These numbers are trivial to achieve. It could be achieved by a person repeatedly tossing a coin, and almost any hardware based process is likely to be much faster.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの数字は達成することは自明です。これは、繰り返しコインを投げる人によって達成することができ、ほぼすべてのハードウェアベースのプロセスは、はるかに高速である可能性が高いです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Existing Hardware Can Be Used For Randomness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。既存のハードウェアが乱雑に使用することができ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described below, many computers come with hardware that can, with care, be used to generate truly random quantities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
後述するように、多くのコンピュータは、注意して、真にランダムな量を生成するために使用することができるハードウェアが付属しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. Using Existing Sound/Video Input
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1。既存のサウンド/ビデオ入力を使用します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many computers are built with inputs that digitize some real-world analog source, such as sound from a microphone or video input from a camera. The &#34;input&#34; from a sound digitizer with no source plugged in or from a camera with the lens cap on is essentially thermal noise. If the system has enough gain to detect anything, such input can provide reasonably high quality random bits. This method is extremely dependent on the hardware implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くのコンピュータは、カメラからのマイクやビデオ入力からの音など、いくつかの実世界のアナログソースをデジタル化入力、で構築されています。または上のレンズキャップとカメラから差し込まない源と音響デジタイザからの「入力」とは、本質的に熱雑音です。システムが何を検出するのに十分な利得を有する場合には、そのような入力は、合理的に高い品質のランダムビットを提供することができます。この方法は、ハードウェア実装に非常に依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, on some UNIX-based systems, one can read from the /dev/audio device with nothing plugged into the microphone jack or with the microphone receiving only low level background noise. Such data is essentially random noise, although it should not be trusted without some checking, in case of hardware failure, and it will have to be de-skewed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、いくつかのUNIXベースのシステムでは、一つのマイクロホンジャックにのみ低レベルのバックグラウンドノイズを受信するマイクで栓何もの/ dev /オーディオデバイスから読み取ることができます。それは、ハードウェア障害の場合に、いくつかのチェックを行わずに信頼すべきではないが、そのようなデータは、本質的にランダムノイズであり、スキュー解除されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Combining this approach with compression to de-skew (see Section 4), one can generate a huge amount of medium-quality random data with the UNIX-style command line:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スキューを解除するために圧縮して、このアプローチを組み合わせること（セクション4を参照）、1はUNIXスタイルのコマンドラインで中質ランダムデータの膨大な量を生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cat /dev/audio | compress - &gt;random-bits-file
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
猫は/ dev /オーディオ|圧縮 - &gt;ランダムビットファイル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A detailed examination of this type of randomness source appears in [TURBID].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ランダムソースのこのタイプの詳細な検討は、[TURBID]に表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. Using Existing Disk Drives
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2。既存のディスクドライブを使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Disk drives have small random fluctuations in their rotational speed due to chaotic air turbulence [DAVIS, Jakobsson]. The addition of low-level disk seek-time instrumentation produces a series of measurements that contain this randomness. Such data is usually highly correlated, so significant processing is needed, as described in Section 5.2 below. Nevertheless, experimentation a decade ago showed that, with such processing, even slow disk drives on the slower computers of that day could easily produce 100 bits a minute or more of excellent random data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディスクドライブは、混沌とした空気の乱れ[DAVIS、Jakobsson]によるその回転速度の小さなランダムな変動を持っています。低レベルディスクの添加は、シーク時間を計測は、このランダム性を含む一連の測定値を生成します。以下のセクション5.2に記載されているようなデータは通常、非常ので、有意な処理が必要とされ、相関されます。それにもかかわらず、実験は十年前、このような処理では、その日の遅いコンピュータ上でも遅いディスクドライブは簡単に100ビットの優れたランダムデータの分以上を作り出すことができる、ことを示しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Every increase in processor speed, which increases the resolution with which disk motion can be timed or increases the rate of disk seeks, increases the rate of random bit generation possible with this technique. At the time of this paper and with modern hardware, a more typical rate of random bit production would be in excess of
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ディスクの動きの分解能を増加させるプロセッサ速度のすべての増加は、タイミングまたはディスクは、シークこの技術で可能なランダムビットの発生率を増加させる速度を増大させることができます。この論文の時点では、近代的なハードウェアと、ランダムビット生産の多くの典型的な割合は、を超えるだろう
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
10,000 bits a second. This technique is used in random number generators included in many operating system libraries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
万ビット秒。この技術は、多くのオペレーティングシステムライブラリに含まれる乱数生成器で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: the inclusion of cache memories in disk controllers has little effect on this technique if very short seek times, which represent cache hits, are simply ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：非常に短いキャッシュヒットを表す回、求める場合は、ディスク・コントローラにおけるキャッシュ・メモリを含めることは、この技術にはほとんど影響を持って、単に無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Ring Oscillator Sources
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。リングオシレータソース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an integrated circuit is being designed or field-programmed, an odd number of gates can be connected in series to produce a free-running ring oscillator. By sampling a point in the ring at a fixed frequency (for example, one determined by a stable crystal oscillator), some amount of entropy can be extracted due to variations in the free-running oscillator timing. It is possible to increase the rate of entropy by XOR&#39;ing sampled values from a few ring oscillators with relatively prime lengths. It is sometimes recommended that an odd number of rings be used so that, even if the rings somehow become synchronously locked to each other, there will still be sampled bit transitions. Another possible source to sample is the output of a noisy diode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
集積回路を設計またはフィールドプログラムされている場合、ゲートの奇数自走リングオシレータを生成するために直列に接続することができます。固定周波数でリング内の点をサンプリングすることによって（例えば、安定した水晶発振器によって決定されるもの）、エントロピーのいくつかの量が原因自走発振器のタイミングのばらつきを抽出することができます。互いに素長さを有するいくつかのリングオシレータからのサンプル値をXORしによりエントロピーの速度を増加させることができます。時々何とか互いに同期ロックなる環が、依然としてビット遷移がサンプリングされる場合であっても、リングの奇数となるように使用することが推奨されます。サンプルへのもう一つの可能​​なソースは、ノイズの多いダイオードの出力です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sampled bits from such sources will have to be heavily de-skewed, as disk rotation timings must be (see Section 4). An engineering study would be needed to determine the amount of entropy being produced depending on the particular design. In any case, these can be good sources whose cost is a trivial amount of hardware by modern standards.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのような供給源からサンプリングしたビットは、ディスク回転のタイミングが（セクション4を参照）でなければならないように、高濃度脱スキューでなければならないであろう。エンジニアリングの研究は、特定のデザインに応じて生成されたエントロピーの量を決定するために必要であろう。いずれにせよ、これらは、そのコスト現代の基準により、ハードウェアの些細な量で良い情報源することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As an example, IEEE 802.11i suggests the circuit below, with due attention in the design to isolation of the rings from each other and from clocked circuits to avoid undesired synchronization, etc., and with extensive post processing [IEEE_802.11i].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一例として、IEEE 802.11i規格は、[IEEE_802.11i]等の望ましくない同期を避けるために、互いからクロックド回路から環の単離、の設計に細心の注意と、広範な後処理で、以下の回路を示唆しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             |\     |\                |\
         +--&gt;| &gt;0--&gt;| &gt;0-- 19 total --| &gt;0--+-------+
         |   |/     |/                |/    |       |
         |                                  |       |
         +----------------------------------+       V
                                                 +-----+
             |\     |\                |\         |     | output
         +--&gt;| &gt;0--&gt;| &gt;0-- 23 total --| &gt;0--+---&gt;| XOR |------&gt;
         |   |/     |/                |/    |    |     |
         |                                  |    +-----+
         +----------------------------------+      ^ ^
                                                   | |
             |\     |\                |\           | |
         +--&gt;| &gt;0--&gt;| &gt;0-- 29 total --| &gt;0--+------+ |
         |   |/     |/                |/    |        |
         |                                  |        |
         +----------------------------------+        |
                                                     |
             Other randomness, if available ---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Problems with Clocks and Serial Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4。クロックおよびシリアル番号の問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Computer clocks and similar operating system or hardware values, provide significantly fewer real bits of unpredictability than might appear from their specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンピュータの時計と同様のオペレーティングシステムやハードウェアの値は、その仕様から表示される場合がありますよりも予測不可能性の有意に少ない本当のビットを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tests have been done on clocks on numerous systems, and it was found that their behavior can vary widely and in unexpected ways. One version of an operating system running on one set of hardware may actually provide, say, microsecond resolution in a clock, while a different configuration of the &#34;same&#34; system may always provide the same lower bits and only count in the upper bits at much lower resolution. This means that successive reads of the clock may produce identical values even if enough time has passed that the value &#34;should&#34; change based on the nominal clock resolution. There are also cases where frequently reading a clock can produce artificial sequential values, because of extra code that checks for the clock being unchanged between two reads and increases it by one! Designing portable application code to generate unpredictable numbers based on such system clocks is particularly challenging because the system designer does not always know the properties of the system clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
テストは、多数のシステム上のクロックで行われている、それは彼らの行動は大きく異なると予想外の方法で得ることが見出されました。 「同じ」システムの異なる構成が常に同じ下位ビットを提供するだけで多くの上位ビットのカウントかもしれないが、ハードウェアの一組上で動作しているオペレーティング・システムの1つのバージョンは、実際に、クロックで、たとえば、マイクロ秒の分解能を提供することができます低解像度。これは、連続したクロックの読み込みに十分な時間が値が公称クロックの分解能に基づいて変更する「必要がある」ことを経過しても同じ値を生成してもよいことを意味します。なぜならクロックは、2つの読み取りと1で、それを高めるの間変わらないことをチェックする余分なコードの頻繁に人工的な連続した値を生成することができますクロックを読んだ例もあります！システム設計者は、常にシステムクロックの性質を知らないので、このようなシステムクロックに基づいて予測不可能な数字を生成するために、ポータブルアプリケーションのコードを設計することは特に困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Use of a hardware serial number (such as an Ethernet MAC address) may also provide fewer bits of uniqueness than one would guess. Such quantities are usually heavily structured, and subfields may have only a limited range of possible values, or values may be easily guessable based on approximate date of manufacture or other data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（イーサネットMACアドレスなど）ハードウェアシリアル番号の使用はまた、一つの推測よりも一意性の少ないビットを提供することができます。そのような量は通常重く構造であり、サブフィールドは、可能な値の限られた範囲を有していてもよく、または値は、製造または他のデータのおおよその日付に基づいて容易に推測することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, it is likely that a company that manufactures both computers and Ethernet adapters will, at least internally, use its own adapters, which significantly limits the range of built-in addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、コンピュータとイーサネットアダプタの両方を製造している会社は、内部的に、少なくとも、大幅に内蔵されたアドレスの範囲を制限する、独自のアダプタを使用すること。そうです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Problems such as those described above make the production of code to generate unpredictable quantities difficult if the code is to be ported across a variety of computer platforms and systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上述したような問題は、コードがコンピュータプラットフォームと様々なシステムを横切って移植される場合、コードの製造が困難に予測不可能な量を生成することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Timing and Value of External Events
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5。外部イベントのタイミングと価値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is possible to measure the timing and content of mouse movement, key strokes, and similar user events. This is a reasonable source of unguessable data, with some qualifications. On some machines, input such as key strokes is buffered. Even though the user&#39;s inter-keystroke timing may have sufficient variation and unpredictability, there might not be an easy way to access that variation. Another problem is that no standard method exists for sampling timing details. This makes it hard to use this technique to build standard software intended for distribution to a large range of machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マウスの動き、キーストローク、および類似したユーザーイベントのタイミングと内容を測定することが可能です。これは、いくつかの資格で、推測できないデータの合理的なソースです。いくつかのマシンでは、そのようなキーストロークなどの入力がバッファリングされます。利用者の間のキーストロークのタイミングが十分な変動や予測不能性を持っている場合でも、その変化にアクセスするための簡単な方法がないかもしれません。もう一つの問題は、標準的な方法は、サンプリングタイミングの詳細については存在しないということです。これは、ハードマシンの大規模な範囲に分布することを目的標準のソフトウェアを構築するために、この技術を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The amount of mouse movement and the actual key strokes are usually easier to access than timings, but they may yield less unpredictability because the user may provide highly repetitive input.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マウスの移動量と実際のキーストロークは、通常タイミングよりアクセスが容易であるが、ユーザが高度に反復入力を提供することができるので、彼らはより少ない予測不可能性をもたらすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Other external events, such as network packet arrival times and lengths, can also be used, but only with great care. In particular, the possibility of manipulation of such network traffic measurements by an adversary and the lack of history at system start-up must be carefully considered. If this input is subject to manipulation, it must not be trusted as a source of entropy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのようなネットワークパケットの到着時間や長さなどの他の外部のイベントは、まただけ細心の注意と、使用することができます。具体的には、システム起動時に敵と歴史の欠如によって、このようなネットワーク・トラフィック測定の操作の可能性を慎重に検討する必要があります。この入力は、操作の対象となる場合、それはエントロピーの源として信頼してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In principle, almost any external sensor, such as raw radio reception or temperature sensing in appropriately equipped computers, can be used. But in each case, careful consideration must be given to how much this data is subject to adversarial manipulation and to how much entropy it can actually provide.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
原則的に、そのような適切装備したコンピュータで生無線受信または温度感知ほぼ任意の外部センサを使用することができます。しかし、それぞれの場合に、慎重な検討は、このデータが敵対操作にし、それが実際に提供することができますどのくらいのエントロピーの対象となるどのくらいに与えられなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The above techniques are quite powerful against attackers that have no access to the quantities being measured. For example, these techniques would be powerful against offline attackers who had no access to one&#39;s environment and who were trying to crack one&#39;s random seed after the fact. In all cases, the more accurately one can measure the timing or value of an external sensor, the more rapidly one can generate bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の技術は、測定される量にアクセス全くない攻撃者に対して非常に強力です。例えば、これらの技術は、1の環境へのアクセスがなかったし、事後1のランダムシードを解読しようとしていた人、オフライン攻撃者に対して強力になります。全ての場合において、より正確に一つより迅速つのビットを生成することができ、外部センサのタイミングまたは値を測定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Non-hardware Sources of Randomness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6。ランダム性の非ハードウェアソース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The best source of input entropy would be a hardware-based random source such as ring oscillators, disk drive timing, thermal noise, or radioactive decay. However, if none of these is available, there are other possibilities. These include system clocks, system or input/output buffers, user/system/hardware/network serial numbers or addresses and timing, and user input. Unfortunately, each of these sources can produce very limited or predictable values under some circumstances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力エントロピーの最良の供給源は、リング発振器、ディスクドライブタイミング、熱雑音、または放射性崩壊のようなハードウェアベースのランダムソースであろう。これらのどれもが利用できない場合は、他の可能性があります。これらは、システムクロック、システムまたは入力/出力バッファ、ユーザ/システム/ハードウェア/ネットワークシリアル番号またはアドレスとタイミング、およびユーザ入力を含みます。残念ながら、これらのソースのそれぞれは、いくつかの状況下では非常に限られた、または予測可能な値を生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some of the sources listed above would be quite strong on multi-user systems, where each user of the system is in essence a source of randomness. However, on a small single-user or embedded system, especially at start-up, it might be possible for an adversary to assemble a similar configuration. This could give the adversary inputs to the mixing process that were well-enough correlated to those used originally to make exhaustive search practical.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の源の一部は、システムの各ユーザは、本質的にランダム性の源であるマルチユーザーシステム上で非常に強くなるであろう。しかし、小さなシングルユーザーまたは組み込みシステム上で、特に起動時に、それは同様の構成を組み立てるために敵のためにできる場合があります。これは、徹底的な検索を実用的にするために最初に使用したものに相関よく十分だった混合プロセスに敵入力を与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The use of multiple random inputs with a strong mixing function is recommended and can overcome weakness in any particular input. The timing and content of requested &#34;random&#34; user keystrokes can yield hundreds of random bits, but conservative assumptions need to be made. For example, one reasonably conservative assumption would be that an inter-keystroke interval provides at most a few bits of randomness, but only when the interval is unique in the sequence of intervals up to that point. A similar assumption would be that a key code provides a few bits of randomness, but only when the code is unique in the sequence. Thus, an interval or key code that duplicated a previous value would be assumed to provide no additional randomness. The results of mixing these timings with typed characters could be further combined with clock values and other inputs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
強い混合機能を有する複数のランダム入力の使用が推奨され、いずれかの特定の入力における弱点を克服することができます。要求された「ランダム」は、ユーザのキーストロークのタイミングと内容はランダムビットの数百をもたらすことができますが、保守的な仮定がなされる必要があります。例えば、一つの合理的保守的な仮定は、インターキーストローク間隔がランダムの最も少ないビットで提供することであろうが、間隔は、その時点までの区間のシーケンスに固有のものである場合にのみ。同様の仮定は、キーコードがランダムの数ビットを提供することが、コードシーケンスに固有のものである場合にのみであろう。したがって、前の値を複製間隔またはキーコードが追加のランダム性を提供しないと想定されます。入力された文字と、これらのタイミングを混合した結果は、さらに、クロック値及び他の入力と組み合わせることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This strategy may make practical portable code for producing good random numbers for security, even if some of the inputs are very weak on some of the target systems. However, it may still fail against a high-grade attack on small, single-user, or embedded systems, especially if the adversary has ever been able to observe the generation process in the past. A hardware-based random source is still preferable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この戦略は、入力のいくつかは、ターゲットシステムのいくつかの非常に弱い場合であっても、セキュリティのための良好な乱数を生成するための実用的なポータブルなコードを作成することができます。しかし、それはまだ敵が過去に生成過程を観察することができた場合は特に、小型、シングルユーザー、または組み込みシステム上のハイグレードの攻撃に対して失敗することがあります。ハードウェアベースのランダムソースが依然として好ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. De-skewing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.デスキュー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Is there any specific requirement on the shape of the distribution of quantities gathered for the entropy to produce the random numbers? The good news is that the distribution need not be uniform. All that is needed to bound performance is a conservative estimate of how non-uniform it is. Simple techniques to de-skew a bit stream are given below, and stronger cryptographic techniques are described in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
乱数を生成するエントロピーのために集められた量の分布の形状上の任意の特定の要件はありますか？良いニュースは、分布が均一である必要はないということです。すべてのことがバインドされたパフォーマンスに必要とされるのは、それがどのように不均一の保守的な見積もりです。ビットストリームをデスキューするための簡単な技術は、以下に示される、より強い暗号化技術は、セクション5.2に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Using Stream Parity to De-Skew
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。デ・スキューに使用するストリームパリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a simple but not particularly practical example, consider taking a sufficiently long string of bits and mapping the string to &#34;zero&#34; or &#34;one&#34;. The mapping will not yield a perfectly uniform distribution, but it can be as close as desired. One mapping that serves the purpose is to take the parity of the string. This has the advantages that it is robust across all degrees of skew up to the estimated maximum skew and that it is trivial to implement in hardware.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単純ではないが、特に実用的な例として、ビットの十分に長い文字列を取って「ゼロ」又は「1」の文字列をマッピング考えます。マッピングは、完全に均一な分布が得られないであろうが、所望の限り近づけることができます。目的を果たす1つのマッピングは、文字列のパリティを取ることです。これは、推定最大スキューまで、ハードウェアで実装すること些細であることスキューのすべての度を越え堅牢であることの利点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following analysis gives the number of bits that must be sampled:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の分析は、サンプリングされなければならないビットの数を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suppose that the ratio of ones to zeros is ( 0.5 + E ) to ( 0.5 - E ), where E is between 0 and 0.5 and is a measure of the &#34;eccentricity&#34; of the distribution. Consider the distribution of the parity function of N bit samples. The respective probabilities that the parity will be one or zero will be the sum of the odd or even terms in the binomial expansion of (p + q)^N, where p = 0.5 + E, the probability of a one, and q = 0.5 - E, the probability of a zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、Eは0〜0.5であり、分布の「偏心」の尺度である - ゼロのものの比（E 0.5）と（0.5 + E）であると仮定する。 Nビットサンプルのパリティ機能の分布を考えてみましょう。パリティは、1またはゼロ（p + q）の二項膨張の奇数または偶数項の和であろうとなり、それぞれの確率^ N、P = 0.5 + E、一方の確率、及びq = 0.5  -  E、ゼロの確率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These sums can be computed easily as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの和は、として簡単に計算することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                         N            N
        1/2 * ( ( p + q )  + ( p - q )  )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
and N N 1/2 * ( ( p + q ) - ( p - q ) ).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そしてN N 1/2 *（（P + Q） - （P  -  Q））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(Which formula corresponds to the probability that the parity will be 1 depends on whether N is odd or even.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（パリティが1である確率に対応する式は、Nが奇数であるか偶数であるかに依存します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since p + q = 1 and p - q = 2E, these expressions reduce to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
p + q = 1であり、p以来 -  Q = 2E、これらの式は、に削減します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       N
        1/2 * [1 + (2E)  ]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
and N 1/2 * [1 - (2E) ].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そしてN 1/2 * [1  - （2E）]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Neither of these will ever be exactly 0.5 unless E is zero, but we can bring them arbitrarily close to 0.5. If we want the probabilities to be within some delta d of 0.5, e.g., then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Eがゼロでない限り、これらはいずれも、これまで正確に0.5になりますが、我々は、任意に0.5に近いそれらをもたらすことができます。私たちは、確率が0.5のいくつかのデルタD内になりたい場合は、例えば、その後、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            N
        ( 0.5 + ( 0.5 * (2E)  ) )  &lt;  0.5 + d.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Solving for N yields N &gt; log(2d)/log(2E). (Note that 2E is less than 1, so its log is negative. Division by a negative number reverses the sense of an inequality.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nについて解くと、N&gt;ログ（2D）/ログ（2E）が得られます。 （2Eは1未満であるので、そのログが負であることに留意されたい。負の数による除算は、不等式の意味を逆にします。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following table gives the length N of the string that must be sampled for various degrees of skew in order to come within 0.001 of a 50/50 distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の表は50/50分布の0.001以内に来るために、スキューの様々な程度のためにサンプリングされなければならない文字列の長さNを与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                +---------+--------+-------+
                | Prob(1) |    E   |    N  |
                +---------+--------+-------+
                |   0.5   |  0.00  |    1  |
                |   0.6   |  0.10  |    4  |
                |   0.7   |  0.20  |    7  |
                |   0.8   |  0.30  |   13  |
                |   0.9   |  0.40  |   28  |
                |   0.95  |  0.45  |   59  |
                |   0.99  |  0.49  |  308  |
                +---------+--------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The last entry shows that even if the distribution is skewed 99% in favor of ones, the parity of a string of 308 samples will be within 0.001 of a 50/50 distribution. But, as we shall see in section 5.2, there are much stronger techniques that extract more of the available entropy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後のエントリは、分布のものを支持して99％歪んでいる場合でも、308個のサンプルの列のパリティが50/50分布の0.001の範囲内であろうことを示しています。しかし、我々は5.2節で見るように、可能なエントロピーのより抽出はるかに強力なテクニックがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Using Transition Mappings to De-Skew
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。デ・スキューへの移行マッピングの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another technique, originally due to von Neumann [VON_NEUMANN], is to examine a bit stream as a sequence of non-overlapping pairs. One could then discard any 00 or 11 pairs found, interpret 01 as a 0 and 10 as a 1. Assume that the probability of a 1 is 0.5+E and that the probability of a 0 is 0.5-E, where E is the eccentricity of the source as described in the previous section. Then the probability of each pair is shown in the following table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の技術は、元々起因フォンノイマン[VON_NEUMANN]に、非重複対のシーケンスとしてビットストリームを調べることです。一つは、次いで、見つかった00または11の対を廃棄1と0と10のように01を解釈1の確率は、0.5 + Eであると仮定し、0の確率は、Eが偏心0.5-Eであることができ前のセクションで説明したようにソース。各ペアの確率を以下の表に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            +------+-----------------------------------------+
            | pair |            probability                  |
            +------+-----------------------------------------+
            |  00  | (0.5 - E)^2          =  0.25 - E + E^2  |
            |  01  | (0.5 - E)*(0.5 + E)  =  0.25     - E^2  |
            |  10  | (0.5 + E)*(0.5 - E)  =  0.25     - E^2  |
            |  11  | (0.5 + E)^2          =  0.25 + E + E^2  |
            +------+-----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This technique will completely eliminate any bias but requires an indeterminate number of input bits for any particular desired number of output bits. The probability of any particular pair being discarded is 0.5 + 2E^2, so the expected number of input bits to produce X output bits is X/(0.25 - E^2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この技術は、完全に任意のバイアスを排除するが、出力ビットのいずれかの特定の所望の数の入力ビットの不定数を必要とするであろう。廃棄される任意の特定のペアの確率は、0.5 + 2E ^ 2であるので、X出力ビットを生成するために入力ビットの期待数はX /（0.25  -  E ^ 2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This technique assumes that the bits are from a stream where each bit has the same probability of being a 0 or 1 as any other bit in the stream and that bits are uncorrelated, i.e., that the bits come from identical independent distributions. If alternate bits are from two correlated sources, for example, the above analysis breaks down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この技術は、ビットが同じ独立の分布から来ること、すなわち、ビットは、各ビットストリーム内の他のビットとして0または1であるのと同じ確率を有するストリームからのものであること、およびビットが無相関であると仮定しています。代替ビットは2つの相関のソースからのものである場合、例えば、上記の分析は、破壊します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The above technique also provides another illustration of how a simple statistical analysis can mislead if one is not always on the lookout for patterns that could be exploited by an adversary. If the algorithm were misread slightly so that overlapping successive bits pairs were used instead of non-overlapping pairs, the statistical analysis given would be the same. However, instead of providing an unbiased, uncorrelated series of random 1s and 0s, it would produce a totally predictable sequence of exactly alternating 1s and 0s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の技術はまた、一つは敵によって利用することができたパターンに目を光らせて、常にではない場合、単純な統計分析を誤解する方法の別の例を提供します。重複連続するビット対が非重複ペアの代わりに使用したように、アルゴリズムがわずかに読み違えた場合、所定の統計的分析は、同じです。しかし、代わりにランダム1と0の公平、無相関シリーズを提供するのではなく、正確に1と0を交互に完全に予測可能なシーケンスを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Using FFT to De-Skew
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。デ・スキューにFFTを使用して
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When real-world data consists of strongly correlated bits, it may still contain useful amounts of entropy. This entropy can be extracted through various transforms, the most powerful of which are described in section 5.2 below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実世界のデータは強く相関ビットで構成されている場合、それはまだエントロピーの有用な量が含まれていてもよいです。このエントロピーは以下のセクション5.2に記載されている最も強力なその種々の変換を介して抽出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using the Fourier transform of the data or its optimized variant, the FFT, is interesting primarily for theoretical reasons. It can be shown that this technique will discard strong correlations. If adequate data is processed and if remaining correlations decay, spectral lines that approach statistical independence and normally distributed randomness can be produced [BRILLINGER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フーリエ変換を使用して、データまたはその最適化された変異型の変換、FFT、主に理論的な理由のために興味深いものです。この技術は強い相関関係を破棄することを示すことができます。十分なデータが処理される場合、残りの相関の減衰は、統計的独立性および正規分布ランダムに近づくスペクトル線は、[BRILLINGER]を製造することができる場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Using Compression to De-Skew
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4。デ・スキューに圧縮の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Reversible compression techniques also provide a crude method of de-skewing a skewed bit stream. This follows directly from the definition of reversible compression and the formula in Section 2 for the amount of information in a sequence. Since the compression is reversible, the same amount of information must be present in the shorter output as was present in the longer input. By the Shannon information equation, this is only possible if, on average, the probabilities of the different shorter sequences are more uniformly distributed than were the probabilities of the longer sequences. Therefore, the shorter sequences must be de-skewed relative to the input.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
可逆圧縮技術はまた、スキュービットストリームをデスキューの粗方法を提供します。これは、可逆圧縮及び配列の情報量の第2節における式の定義から直接従います。圧縮は可逆的であるので、より長い入力に存在したように、同じ情報量をより短い出力に存在しなければなりません。平均して、異なる短い配列の確率がより均一に、より長い配列の確率であったよりも分布している、場合シャノン情報方程式によって、これは可能です。したがって、より短い配列は、脱スキューされなければならない入力に対して。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, many compression techniques add a somewhat predictable preface to their output stream and may insert a similar sequence periodically in their output or otherwise introduce subtle patterns of their own. They should be considered only rough techniques compared to those described in Section 5.2. At a minimum, the beginning of the compressed sequence should be skipped and only later bits should used for applications requiring roughly-random bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、多くの圧縮技術は、それらの出力ストリームに幾分予測可能な序文を追加し、それらの出力に周期的に類似の配列を挿入するか、そうでなければ、独自の微妙なパターンを導入することができます。彼らは、5.2節で説明したものに比べて唯一のラフな手法を検討すべきです。最小で、圧縮されたシーケンスの先頭をスキップしなければならないだけ後のビットは、概ねランダムビットを必要とする用途に使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Mixing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.ミキシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
What is the best overall strategy for obtaining unguessable random numbers in the absence of a strong, reliable hardware entropy source? It is to obtain input from a number of uncorrelated sources and to mix them with a strong mixing function. Such a function will preserve the entropy present in any of the sources, even if other quantities being combined happen to be fixed or easily guessable (low entropy). This approach may be advisable even with a good hardware source, as hardware can also fail. However, this should be weighed against a possible increase in the chance of overall failure due to added software complexity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
強力な、信頼性の高いハードウェアのエントロピー源が存在しない場合に推測できない乱数を取得するための最良の全体的な戦略とは何ですか？これは、相関のない多数の供給源から入力を得るために、強力な混合機能とそれらを混合することです。そのような機能は、他の量が固定されるように起こるか、（低いエントロピー）を容易に推測組み合わされても、ソースのいずれかに存在するエントロピーを保存します。ハードウェアでも失敗することとして、このアプローチは、でも良いハードウェアの源と賢明かもしれません。しかし、これは、追加ソフトウェアの複雑さのために全体的な障害が発生する可能性増加の可能性と比較検討されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once one has used good sources, such as some of those listed in Section 3, and mixed them as described in this section, one has a strong seed. This can then be used to produce large quantities of cryptographically strong material as described in Sections 6 and 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一つは、このような第3節に記載されたものの一部としての良い源を使用し、この節で説明するように、それらを混合した後、一方は強い種を有します。次いで、これをセクション6および7に記載したように暗号強い材料を大量に製造するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A strong mixing function is one that combines inputs and produces an output in which each output bit is a different complex non-linear function of all the input bits. On average, changing any input bit will change about half the output bits. But because the relationship is complex and non-linear, no particular output bit is guaranteed to change when any particular input bit is changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
強い混合機能は、入力を結合し、各出力ビットは、すべての入力ビットの異なる複雑な非線形関数である出力を生成するものです。平均して、任意の入力ビットを変更して約半分の出力ビットを変更します。関係が複雑で非線形であるので、しかし、何も特定の出力ビットは、いずれかの特定の入力ビットが変更されたときに変更することが保証されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the problem of converting a stream of bits that is skewed towards 0 or 1 or which has a somewhat predictable pattern to a shorter stream which is more random, as discussed in Section 4. This is simply another case where a strong mixing function is desired, to mix the input bits and produce a smaller number of output bits. The technique given in Section 4.1, using the parity of a number of bits, is simply the result of successively XORing them. This is examined as a trivial mixing function, immediately below. Use of stronger mixing functions to extract more of the randomness in a stream of skewed bits is examined in Section 5.2. See also [NASLUND].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション4で説明したように、これは単に強い混合機能が所望される他の場合であり、0又は1に偏っ以上ランダムで短いストリームに幾分予測可能なパターンを有しているビットストリームを変換する問題を考えます、入力ビットをミックスして出力少ないビット数を生成します。ビット数のパリティを用いて、セクション4.1で指定された技術は、単に連続それらをXOR演算した結果です。これは、すぐ下、些細な混合関数として検討されています。斜めビットストリームにランダム性の多くを抽出する強力な混合関数の使用は、セクション5.2で検討されています。 [NASLUND]も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. A Trivial Mixing Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。些細なミキシング機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For expository purposes we describe a trivial example for single bit inputs using the Exclusive Or (XOR) function. This function is equivalent to addition without carry, as show in the table below. This is a degenerate case in which the one output bit always changes for a change in either input bit. But, despite its simplicity, it provides a useful illustration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
解説の目的のために我々は排他的論理和（XOR）関数を使用して単一ビット入力のための簡単な例を説明します。この機能は、以下の表のショーとして、キャリーなしの追加に相当します。これは、1つの出力ビットは常にいずれかの入力ビットの変化のために変化する縮退ケースです。しかし、そのシンプルさにもかかわらず、それは有益なイラストを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                +-----------+-----------+----------+
                |  input 1  |  input 2  |  output  |
                +-----------+-----------+----------+
                |     0     |     0     |     0    |
                |     0     |     1     |     1    |
                |     1     |     0     |     1    |
                |     1     |     1     |     0    |
                +-----------+-----------+----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If inputs 1 and 2 are uncorrelated and combined in this fashion, then the output will be an even better (less skewed) random bit than the inputs are. If we assume an &#34;eccentricity&#34; E as defined in Section 4.1 above, then the output eccentricity relates to the input eccentricity as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力1と2が無相関とこのように組み合わされている場合、出力は入力があるよりも良い（以下スキュー）ランダムビットであろう。上記のセクション4.1で定義されている私たちは、「偏心」Eを想定した場合、次のように出力偏心が入力偏心に関する：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        E       = 2 * E        * E
         output        input 1    input 2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since E is never greater than 1/2, the eccentricity is always improved, except in the case in which at least one input is a totally skewed constant. This is illustrated in the following table, where the top and left side values are the two input eccentricities and the entries are the output eccentricity:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Eが1/2より大きくなることはないので、偏心は、常に少なくとも一つの入力が完全に傾い一定である場合を除いて、改善されています。これは、上部と左側値は、2つの入力偏心及びエントリは出力偏心されている次の表に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +--------+--------+--------+--------+--------+--------+--------+
     |    E   |  0.00  |  0.10  |  0.20  |  0.30  |  0.40  |  0.50  |
     +--------+--------+--------+--------+--------+--------+--------+
     |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |  0.00  |
     |  0.10  |  0.00  |  0.02  |  0.04  |  0.06  |  0.08  |  0.10  |
     |  0.20  |  0.00  |  0.04  |  0.08  |  0.12  |  0.16  |  0.20  |
     |  0.30  |  0.00  |  0.06  |  0.12  |  0.18  |  0.24  |  0.30  |
     |  0.40  |  0.00  |  0.08  |  0.16  |  0.24  |  0.32  |  0.40  |
     |  0.50  |  0.00  |  0.10  |  0.20  |  0.30  |  0.40  |  0.50  |
     +--------+--------+--------+--------+--------+--------+--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, note that the above calculations assume that the inputs are not correlated. If the inputs were, say, the parity of the number of minutes from midnight on two clocks accurate to a few seconds, then each might appear random if sampled at random intervals much longer than a minute. Yet if they were both sampled and combined with XOR, the result would be zero most of the time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、上記の計算は、入力が相関していないことを前提としています。入力があった場合ははるかに長い分よりランダムな間隔でサンプリングした場合、たとえば、数秒の精度両クロックの真夜中からの分数のパリティは、その後、それぞれがランダムに表示される場合があります。彼らは両方のサンプリングとXORと組み合わせた場合しかし、結果は時間のゼロほとんどだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Stronger Mixing Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。より強力なミキシング機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The US Government Advanced Encryption Standard [AES] is an example of a strong mixing function for multiple bit quantities. It takes up to 384 bits of input (128 bits of &#34;data&#34; and 256 bits of &#34;key&#34;) and produces 128 bits of output, each of which is dependent on a complex non-linear function of all input bits. Other encryption functions with this characteristic, such as [DES], can also be used by considering them to mix all of their key and data input bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
米国政府のAdvanced Encryption Standard [AES]は、複数のビット量のための強力な混合関数の一例です。これは、入力の384ビット（「データ」の128ビットと「キー」の256ビット）を占め、全入力ビットの複雑な非線形関数に依存してその各々の出力の128ビットを生成します。こうした[DES]としてこの特性を持つ他の暗号化機能は、また、そのキーとデータ入力ビットのすべてを混合するために、それらを考慮して使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another good family of mixing functions is the &#34;message digest&#34; or hashing functions such as the US Government Secure Hash Standards [SHA*] and the MD4, MD5 [MD4, MD5] series. These functions all take a practically unlimited amount of input and produce a relatively short fixed-length output mixing all the input bits. The MD* series produces 128 bits of output, SHA-1 produces 160 bits, and other SHA functions produce up to 512 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ミキシング機能のもう一つの良い家族は、「メッセージダイジェスト」であるか、米国政府などのハッシング機能は、ハッシュ標準[SHA *]とMD4、MD5 [MD4、MD5]シリーズを固定します。これらの機能はすべての入力の実質的に無制限の量を取り、すべての入力ビットを混合比較的短い固定長の出力を生成します。 MD *シリーズは、出力の128ビットを生成し、SHA-1は、160ビットを生成し、他のSHA関数は、512ビットまで生じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although the message digest functions are designed for variable amounts of input, AES and other encryption functions can also be used to combine any number of inputs. If 128 bits of output is adequate, the inputs can be packed into a 128-bit data quantity and successive AES &#34;keys&#34;, padding with zeros if needed; the quantity is then successively encrypted by the &#34;keys&#34; using AES in Electronic Codebook Mode. Alternatively, the input could be packed into one 128-bit key and multiple data blocks and a CBC-MAC could be calculated [MODES].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージダイジェスト関数は入力の可変量のために設計されていますが、AESや他の暗号化機能は、任意の数の入力を組み合わせるために使用することができます。出力の128ビットが適切であれば、必要に応じて、入力は、128ビットのデータ量と連続AES「キー」にゼロでパディングを充填することができます。量は、その後、順次、電子コードブックモードでAESを使用して「キー」によって暗号化されています。代替的に、入力は1つの128ビットの鍵と複数のデータブロックにパックすることができ、CBC-MACは[MODES]を算出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
More complex mixing should be used if more than 128 bits of output are needed and one wants to employ AES (but note that it is absolutely impossible to get more bits of &#34;randomness&#34; out than are put in). For example, suppose that inputs are packed into three quantities, A, B, and C. One may use AES to encrypt A with B and then with C as keys to produce the first part of the output, then encrypt B with C and then A for more output and, if necessary, encrypt C with A and then B for yet more output. Still more output can be produced by reversing the order of the keys given above. The same can be done with the hash functions, hashing various subsets of the input data or different copies of the input data with different prefixes and/or suffixes to produce multiple outputs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力の128個の以上のビットが必要な場合は、より複雑な混合を使用する必要があり、一つはAESを採用し（入れているよりも外に「ランダム」の多くのビットを取得することは絶対に不可能であることに注意してください）したいと考えています。例えば、キーは、出力の最初の部分を生成するようにBと、次いでCで暗号化するAESを使用することができる入力が3つの量、A、B、及びCの一つに詰め込まれていることを仮定し、次いでCとしてBを暗号化します複数の出力と、必要な場合のために、さらにより出力するため、次にAとBとCを暗号化します。さらにより出力は、上記のキーの順序を逆にすることにより製造することができます。同じことが、複数の出力を生成する入力データまたは異なる接頭辞および/または接尾辞を持つ入力データの異なるコピーの種々のサブセットをハッシュ、ハッシュ関数を用いて行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For an example of using a strong mixing function, reconsider the case of a string of 308 bits, each of which is biased 99% toward zero. The parity technique given in Section 4.1 reduces this to one bit, with only a 1/1000 deviance from being equally likely a zero or one. But, applying the equation for information given in Section 2, this
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
強い混合機能の使用例については、ゼロに向かって99％に付勢されているそれぞれが308ビットの文字列の場合を再考。セクション4.1で与えられたパリティ技術は、等しく可能性が0または1であるからのみ1/1000ずれと、1ビットにこれを減少させます。しかし、この、第2節で与えられた情報のための式を適用します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
308-bit skewed sequence contains over 5 bits of information. Thus, hashing it with SHA-1 and taking the bottom 5 bits of the result would yield 5 unbiased random bits and not the single bit given by calculating the parity of the string. Alternatively, for some applications, you could use the entire hash output to retain almost all of the 5+ bits of entropy in a 160-bit quantity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
308ビットのスキュー配列情報の5ビット以上を含んでいます。したがって、SHA-1とそれをハッシュし、その結果の下位5ビットは、文字列のパリティを計算することによって与えられる5公平ランダムビットとしない単一のビットを生じる取ります。あるいは、いくつかの用途では、160ビットの量のほぼ全てのエントロピーの5+ビットを保持するために全体のハッシュ出力を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Using S-Boxes for Mixing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。ミキシングのためのS-ボックスの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many modern block encryption functions, including DES and AES, incorporate modules known as S-Boxes (substitution boxes). These produce a smaller number of outputs from a larger number of inputs through a complex non-linear mixing function that has the effect of concentrating limited entropy from the inputs into the output.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DESやAESなど、現代の多くのブロック暗号化機能、S-ボックス（置換ボックス）として知られているモジュールを組み込みます。これらは、出力への入力から、限られたエントロピーを集中させる効果を有する複雑な非線形混合関数を通じて入力の多数の出力の小さい数を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
S-Boxes sometimes incorporate bent Boolean functions (functions of an even number of bits producing one output bit with maximum non-linearity). Looking at the output for all input pairs differing in any particular bit position, exactly half the outputs are different. An S-Box in which each output bit is produced by a bent function such that any linear combination of these functions is also a bent function is called a &#34;perfect S-Box&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sボックス時々屈曲ブール関数（ビットの偶数の機能は、最大の非線形性と一つの出力ビットを生成する）を組み込みます。任意の特定のビット位置が異なるすべての入力ペアの出力を見てみると、ちょうど半分の出力が異なっています。各出力ビットは、これらの機能の任意の線形結合も屈曲関数となるように屈曲関数によって生成されたS-boxが「完璧なSボックス」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
S-boxes and various repeated applications or cascades of such boxes can be used for mixing [SBOX1, SBOX2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sボックスと、箱の様々な繰り返し適用またはカスケードは[SBOX1、SBOX2]を混合するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Diffie-Hellman as a Mixing Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。ミキシング機能としてのDiffie-Hellmanの
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Diffie-Hellman exponential key exchange is a technique that yields a shared secret between two parties. It can be computationally infeasible for a third party to determine this secret even if they can observe all the messages between the two communicating parties. This shared secret is a mixture of initial quantities generated by each of the parties [D-H].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Diffie-Hellmanの鍵交換指数は、二者間の共有秘密を生成する技術です。第三者が、彼らは2つの通信当事者間のすべてのメッセージを観察することができても、この秘密を決定することは計算上実行不可能することができます。この共有秘密は、当事者[D-H]のそれぞれによって生成された初期量の混合物です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If these initial quantities are random and uncorrelated, then the shared secret combines their entropy but, of course, can not produce more randomness than the size of the shared secret generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの初期量はランダムと相関していない場合は、共有秘密は、そのエントロピーを兼ね備えたが、当然のことながら、生成された共有シークレットのサイズよりもランダム性を生成することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although this is true if the Diffie-Hellman computation is performed privately, an adversary who can observe either of the public keys and knows the modulus being used need only search through the space of the other secret key in order to be able to calculate the shared secret [D-H]. So, conservatively, it would be best to consider public Diffie-Hellman to produce a quantity whose guessability corresponds to the worse of the two inputs. Because of this and the fact that Diffie-Hellman is computationally intensive, its use as a mixing function is not recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Diffie-Hellman計算が、私的に行われる公開鍵のいずれかを観察し、モジュラスを知っていることができます敵が唯一の共有を計算することができるようにするために、他の秘密鍵の空間を探索する必要が使用されている場合、これは本当ですが、秘密[DH]。だから、控えめに、それは、その推測可能2つの入力の悪いことに対応して数量を生産するために、公共のDiffie-Hellmanのを検討するのがベストでしょう。このため、およびDiffie-Hellmanのは、計算集約的であるという事実を、混合機能としての使用が推奨されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Using a Mixing Function to Stretch Random Bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。ランダムビットをストレッチするミキシング機能を使います
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although it is not necessary for a mixing function to produce the same or fewer output bits than its inputs, mixing bits cannot &#34;stretch&#34; the amount of random unpredictability present in the inputs. Thus, four inputs of 32 bits each, in which there are 12 bits worth of unpredictability (such as 4,096 equally probable values) in each input, cannot produce more than 48 bits worth of unpredictable output. The output can be expanded to hundreds or thousands of bits by, for example, mixing with successive integers, but the clever adversary&#39;s search space is still 2^48 possibilities. Furthermore, mixing to fewer bits than are input will tend to strengthen the randomness of the output.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
混合機能は、混合ビットは「ストレッチ」入力に存在するランダムな予測不可能性の量ができず、その入力と同じまたはより少ない出力ビットを生成することは必要ではありません。このように、各入力における予測不可能分の12ビット（例えば、4096等しい確率値）が存在している32ビットずつ、4つの入力は、予測不可能な出力の価値以上の48ビットを生成することができません。出力は、連続した整数との混合、例えば、によるビットの数百または数千に拡張することができるが、巧妙な攻撃の探索空間は、依然として2 ^ 48の可能性です。さらに、より少ないビットをミキシング入力は出力のランダム性を強化する傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The last table in Section 5.1 shows that mixing a random bit with a constant bit with Exclusive Or will produce a random bit. While this is true, it does not provide a way to &#34;stretch&#34; one random bit into more than one. If, for example, a random bit is mixed with a 0 and then with a 1, this produces a two bit sequence but it will always be either 01 or 10. Since there are only two possible values, there is still only the one bit of original randomness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.1節の最後の表には、排他的論理和を一定のビットにランダムビットを混合すると、ランダムビットを生成することを示しています。これは事実ですが、それ以上のものに1つのランダムビットを「ストレッチ」する方法を提供していません。例えば、ランダムビットは1で、次いで0と混合した場合、これは、2つのビット列を生成するだけで2つの値があるので、それは常に01または10のいずれかになり、1ビットだけが依然として存在しますオリジナルのランダム性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. Other Factors in Choosing a Mixing Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6。ミキシング機能を選択におけるその他の要因
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For local use, AES has the advantages that it has been widely tested for flaws, is reasonably efficient in software, and is widely documented and implemented with hardware and software implementations available all over the world including open source code. The SHA* family have had a little less study and tend to require more CPU cycles than AES but there is no reason to believe they are flawed. Both SHA* and MD5 were derived from the earlier MD4 algorithm. They all have source code available [SHA*, MD4, MD5]. Some signs of weakness have been found in MD4 and MD5. In particular, MD4 has only three rounds and there are several independent breaks of the first two or last two rounds. And some collisions have been found in MD5 output.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ローカルで使用するために、AESは、それが広く欠陥のためにテストされている利点を持っているソフトウェアで合理的に効率的であり、かつ広く文書化され、すべてのオープンソースコードを含む世界各国の利用可能なハードウェアとソフトウェアの実装で実装されています。 SHA *家族は少し勉強していたし、AESよりも多くのCPUサイクルを必要とする傾向があるが、彼らは欠陥があると信じる理由はありませんしています。 SHA *とMD5の両方が以前のMD4アルゴリズムから得られました。彼らはすべての[SHA *、MD4、MD5]利用可能なソースコードを持っています。弱さのいくつかの兆候がMD4とMD5で発見されています。特に、MD4はわずか3ラウンドがあり、最初の2つまたは最後の2つのラウンドのいくつかの独立した休憩があります。そして、いくつかの衝突がMD5出力で発見されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AES was selected by a robust, public, and international process. It and SHA* have been vouched for by the US National Security Agency (NSA) on the basis of criteria that mostly remain secret, as was DES. While this has been the cause of much speculation and doubt, investigation of DES over the years has indicated that NSA involvement in modifications to its design, which originated with IBM, was primarily to strengthen it. There has been no announcement of a concealed or special weakness being found in DES. It is likely that the NSA modifications to MD4 to produce the SHA algorithms similarly strengthened these algorithms, possibly against threats not yet known in the public cryptographic community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AESは、堅牢公共、および国際法によって選ばれました。 DESがあったようにそれとSHA *は、主に秘密のままの基準に基づき、米国国家安全保障局（NSA）によるためvouchedされています。これは多くの推測と疑いの原因となっていますが、年間のDESの調査は、IBMが起源そのデザインへの変更でNSAの関与は、それを強化するために、主だったこと。示されましたDESで発見され隠されたり、特別な弱点のない発表がなかったです。 SHAアルゴリズムを生成するために、MD4へのNSAの変更は、同様に、おそらくまだ公開暗号コミュニティでは知られていない脅威に対して、これらのアルゴリズムを強化している可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where input lengths are unpredictable, hash algorithms are more convenient to use than block encryption algorithms since they are generally designed to accept variable length inputs. Block encryption algorithms generally require an additional padding algorithm to accommodate inputs that are not an even multiple of the block size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力の長さが予測できない場合、ハッシュアルゴリズムは、それらが一般に、可変長の入力を受け入れるように設計されているので、ブロック暗号化アルゴリズムを使用するより便利です。ブロック暗号化アルゴリズムは、一般に、ブロックサイズの偶数倍でない入力に対応するために追加のパディングアルゴリズムを必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As of the time of this document, the authors know of no patent claims to the basic AES, DES, SHA*, MD4, and MD5 algorithms other than patents for which an irrevocable royalty free license has been granted to the world. There may, of course, be essential patents of which the authors are unaware or patents on implementations or uses or other relevant patents issued or to be issued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書の時点では、著者は、取消不能のロイヤリティーフリーのライセンスを世界に付与されている特許以外の基本的なAES、DES、SHA *、MD4、およびMD5アルゴリズムをなし、特許請求の範囲を知っています。もちろん、著者が気づいていないか、実装または使用または発行または発行する他の関連特許に関する特許であるの必須特許があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Pseudo-random Number Generators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.疑似乱数ジェネレータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a seed has sufficient entropy, from input as described in Section 3 and possibly de-skewed and mixed as described in Sections 4 and 5, one can algorithmically extend that seed to produce a large number of cryptographically-strong random quantities. Such algorithms are platform independent and can operate in the same fashion on any computer. For the algorithms to be secure, their input and internal workings must be protected from adversarial observation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
種子が十分なエントロピーを有する場合セクション4および5に記載したように、セクション3で説明し、おそらく脱スキューと混合して、入力から、一つはアルゴリズム暗号強いランダム量の多数を生成するためにその種を拡張することができます。このようなアルゴリズムは、プラットフォームに依存しており、任意のコンピュータ上で同じように動作することができます。アルゴリズムは安全であるため、それらの入力と内部動作が敵対観察から保護されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The design of such pseudo-random number generation algorithms, like the design of symmetric encryption algorithms, is not a task for amateurs. Section 6.1 below lists a number of bad ideas that failed algorithms have used. To learn what works, skip Section 6.1 and just read the remainder of this section and Section 7, which describes and references some standard pseudo random number generation algorithms. See Section 7 and Part 3 of [X9.82].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような擬似乱数生成アルゴリズムの設計は、対称暗号化アルゴリズムの設計と同様に、アマチュアのための作業ではありません。 6.1節は、以下で使用しているアルゴリズムは失敗悪いアイデアの数を示しています。どのような作品については、6.1節をスキップして、ちょうどいくつかの標準的な擬似乱数生成アルゴリズムを説明し、参照このセクションとセクション7の残りの部分をお読みください。セクション7と[X9.82]のパート3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Some Bad Ideas
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。いくつかの悪いアイデア
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The subsections below describe a number of ideas that might seem reasonable but that lead to insecure pseudo-random number generation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のサブセクションでは、合理的に思えるかもしれないアイデアの数が、安全でない擬似乱数生成にそのリードを記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. The Fallacy of Complex Manipulation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1。複雑な操作の誤謬
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One approach that may give a misleading appearance of unpredictability is to take a very complex algorithm (or an excellent traditional pseudo-random number generator with good statistical properties) and to calculate a cryptographic key by starting with limited data such as the computer system clock value as the seed. Adversaries who knew roughly when the generator was started would have a relatively small number of seed values to test, as they would know likely values of the system clock. Large numbers of pseudo- random bits could be generated, but the search space that an adversary would need to check could be quite small.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
予測不可能性の紛らわしい外観を与えることができる一つの方法は、非常に複雑なアルゴリズム（又は良好な統計的特性と優れた伝統的な擬似乱数生成器）を取るために、そのようなコンピュータ・システム・クロック値など限定されたデータを用いて開始することによって、暗号鍵を計算することですシードとして。彼らは、システムクロックの可能性の高い値を知っているだろうと発電機が起動した時におおよそ知っていた敵対者は、テストするためにシード値の比較的小さな数を持っているでしょう。擬似ランダムビットの大規模な番号が生成される可能性がありますが、敵対者がチェックする必要があるだろう探索空間が非常に小さい可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thus, very strong or complex manipulation of data will not help if the adversary can learn what the manipulation is and if there is not enough entropy in the starting seed value. They can usually use the limited number of results stemming from a limited number of seed values to defeat security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
敵は操作があると、開始シード値に十分なエントロピーが存在しない場合は何を学ぶことができるならばこのように、データの非常に強力なまたは複雑な操作は助けにはなりません。彼らは通常、セキュリティを倒すためにシード値の限られた数から生じる結果の限られた数を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another serious strategic error is to assume that a very complex pseudo-random number generation algorithm will produce strong random numbers, when there has been no theory behind or analysis of the algorithm. There is a excellent example of this fallacy near the beginning of Chapter 3 in [KNUTH], where the author describes a complex algorithm. It was intended that the machine language program corresponding to the algorithm would be so complicated that a person trying to read the code without comments wouldn&#39;t know what the program was doing. Unfortunately, actual use of this algorithm showed that it almost immediately converged to a single repeated value in one case and a small cycle of values in another case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もう一つの重大な戦略的なエラーには背後にある理論やアルゴリズムの分析はなされていないときに、非常に複雑な擬似乱数生成アルゴリズムは、強力な乱数を生成すると仮定することです。著者は、複雑なアルゴリズムを記述する[クヌース]、第3章の冒頭に近いこの誤謬の優れた例があります。これは、アルゴリズムに対応した機械語プログラムはコメントせずにコードを読み取ろうとする者は、プログラムが何をしているのか分からないだろうと非常に複雑になることを意図していました。残念ながら、このアルゴリズムの実際の使用は、ほとんどすぐにある場合に単一繰り返し値と別の場合の値の小さなサイクルに収束することを示しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Not only does complex manipulation not help you if you have a limited range of seeds, but blindly-chosen complex manipulation can destroy the entropy in a good seed!
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
だけでなく、あなたが種子の限られた範囲を持っている場合は、複雑な操作はあなたを助けていませんが、盲目的に選択された複雑な操作は、良い種でエントロピーを破壊することができます！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. The Fallacy of Selection from a Large Database
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2。大規模データベースからの選択の誤謬
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another approach that can give a misleading appearance of unpredictability is to randomly select a quantity from a database and to assume that its strength is related to the total number of bits in the database. For example, typical USENET servers process many megabytes of information per day [USENET_1, USENET_2]. Assume that a random quantity was selected by fetching 32 bytes of data from a random starting point in this data. This does not yield 32*8 = 256 bits worth of unguessability. Even if much of the data is human language that contains no more than 2 or 3 bits of information per byte, it doesn&#39;t yield 32*2 = 64 bits of unguessability. For an adversary with access to the same Usenet database, the unguessability rests only on the starting point of the selection. That is perhaps a little over a couple of dozen bits of unguessability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
予測不可能性の紛らわしい外観を与えることができる別のアプローチは、ランダムにデータベースから数量を選択し、その強度は、データベース内のビットの総数に関係していると仮定することです。例えば、典型的なUSENETサーバは、一日あたりの情報の多くのメガバイト[USENET_1、USENET_2]を処理します。ランダムな量が、このデータのランダムな開始点から32バイトのデータをフェッチすることによって選択されたと仮定する。これはunguessabilityの価値は32×8 = 256ビットが得られません。データの多くは、バイト当たりの情報の2または3ビット以下を含有する人間の言語であっても、それはunguessabilityの32×2 = 64ビットが得られません。同じUsenetのデータベースへのアクセス権を持つ敵に対して、unguessabilityしか選択の出発点にかかっています。それはおそらく、unguessabilityのダース・ビットのカップル余りあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The same argument applies to selecting sequences from the data on a publicly available CD/DVD recording or any other large public database. If the adversary has access to the same database, this &#34;selection from a large volume of data&#34; step buys little. However, if a selection can be made from data to which the adversary has no access, such as system buffers on an active multi-user system, it may be of help.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じ議論は公開CD / DVDの記録やその他の大規模な公共のデータベース上のデータから配列を選択するに適用されます。敵が同じデータベースへのアクセス権を持っている場合は、この「大量のデータから選択が」ステップは少しを買います。選択がアクティブマルチユーザシステムで、システムバッファとして攻撃者がアクセスできないれたデータから作製することができる場合は、それが助けになることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3. Traditional Pseudo-random Sequences
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3。従来の擬似ランダムシーケンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section talks about traditional sources of deterministic or &#34;pseudo-random&#34; numbers. These typically start with a &#34;seed&#34; quantity and use simple numeric or logical operations to produce a sequence of values. Note that none of the techniques discussed in this section is suitable for cryptographic use. They are presented for general information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、決定論的または「擬似ランダム」の数字の伝統的なソースについて語っています。これらは、典型的には、「シード」量で開始し、値のシーケンスを生成するために、単純な数値または論理演算を使用します。このセクションで説明する技術のいずれも暗号化の使用に適していないことに留意されたいです。これらは一般的な情報のために提示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KNUTH] has a classic exposition on pseudo-random numbers. Applications he mentions are simulations of natural phenomena, sampling, numerical analysis, testing computer programs, decision making, and games. None of these have the same characteristics as the sorts of security uses we are talking about. Only in the last two could there be an adversary trying to find the random quantity. However, in these cases, the adversary normally has only a single chance to use a guessed value. In guessing passwords or attempting to break an encryption scheme, the adversary normally has many, perhaps unlimited, chances at guessing the correct value. Sometimes the adversary can store the message to be broken and repeatedly attack it. Adversaries are also be assumed to be aided by a computer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【KNUTH]は擬似乱数で古典的な博覧会を有しています。彼が言及したアプリケーションは、自然現象、サンプリング、数値解析、テスト用コンピュータプログラム、意思決定、およびゲームのシミュレーションです。セキュリティの種類は、私たちが話している使用していますように、これらはいずれも同じ特性を持っていません。最後の二つにランダムな量を見つけようと敵が存在する可能性があります。しかし、これらのケースでは、敵は通常推測値を使用する唯一の単一のチャンスを持っています。パスワードを推測または暗号化スキームを破るしようとするには、敵は通常、正しい値を推測する多くの、おそらく無制限、チャンスを持っています。時には敵は破られるために、メッセージを保存し、それを繰り返し攻撃することができます。敵は、コンピュータによって支援されると想定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For testing the &#34;randomness&#34; of numbers, Knuth suggests a variety of measures, including statistical and spectral. These tests check things like autocorrelation between different parts of a &#34;random&#34; sequence or distribution of its values. But these tests could be met by a constant stored random sequence, such as the &#34;random&#34; sequence printed in the CRC Standard Mathematical Tables [CRC]. Despite meeting all the tests suggested by Knuth, that sequence is unsuitable for cryptographic us, as adversaries must be assumed to have copies of all commonly published &#34;random&#34; sequences and to be able to spot the source and predict future values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
数字の「ランダム」をテストするために、クヌースは、統計やスペクトルなどの施策、さまざまなことを示唆しています。これらのテストは、その値の「ランダム」シーケンスまたは分布の異なる部分の間の自己相関のようなものを確認してください。しかし、これらのテストは、CRC標準的な数学表[CRC]に印刷された「ランダム」配列として、一定の保存されたランダムシーケンスによって満たされる可能性があります。敵はすべて一般公開し、「ランダム」配列のコピーを持つようにしてソースを発見し、将来の値を予測することができると仮定しなければならないようクヌースによって提案されたすべてのテストを満たすにもかかわらず、そのシーケンスは、私たちの暗号化には不向きです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A typical pseudo-random number generation technique is the linear congruence pseudo-random number generator. This technique uses modular arithmetic, where the value numbered N+1 is calculated from the value numbered N by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
典型的な疑似乱数生成技術は、線形合同擬似乱数発生器です。この技術は、値の番号N + 1によりN番号の値から算出される剰余演算を使用し
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        V    = ( V  * a + b )(Mod c)
         N+1      N
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The above technique has a strong relationship to linear shift register pseudo-random number generators, which are well understood cryptographically [SHIFT*]. In such generators, bits are introduced at one end of a shift register as the Exclusive Or (binary sum without carry) of bits from selected fixed taps into the register. For example, consider the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の技術はよく暗号[SHIFT *を】理解される線形シフトレジスタ擬似乱数発生器に強い関係を有します。このような発電機においては、ビットがレジスタに選択された固定タップからのビットの排他的論理和（キャリーなしのバイナリ和）としてシフトレジスタの一端に導入されます。たとえば、次の点を考慮します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +----+     +----+     +----+                      +----+
      | B  | &lt;-- | B  | &lt;-- | B  | &lt;--  . . . . . . &lt;-- | B  | &lt;-+
      |  0 |     |  1 |     |  2 |                      |  n |   |
      +----+     +----+     +----+                      +----+   |
        |                     |            |                     |
        |                     |            V                  +-----+
        |                     V            +----------------&gt; |     |
        V                     +-----------------------------&gt; | XOR |
        +---------------------------------------------------&gt; |     |
                                                              +-----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
V = ( ( V * 2 ) + B XOR B ... )(Mod 2^n) N+1 N 0 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
V =（（V * 2）+ B XOR B ...）（MOD 2 ^ n）がN + 1 N 0 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The quality of traditional pseudo-random number generator algorithms is measured by statistical tests on such sequences. Carefully-chosen values a, b, c, and initial V or carefully-chosen placement of the shift register tap in the above simple process can produce excellent statistics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従来の擬似乱数生成アルゴリズムの品質は、このような配列に統計的試験によって測定されます。注意深く選択された値、B、C、及び初期V以上の単純なプロセスのシフトレジスタタップの慎重に選択された配置は優れた統計を生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These sequences may be adequate in simulations (Monte Carlo experiments) as long as the sequence is orthogonal to the structure of the space being explored. Even there, subtle patterns may cause problems. However, such sequences are clearly bad for use in security applications. They are fully predictable if the initial state is known. Depending on the form of the pseudo-random number generator, the sequence may be determinable from observation of a short portion of the sequence [SCHNEIER, STERN]. For example, with the generators above, one can determine V(n+1) given knowledge of V(n). In fact, it has been shown that with these techniques, even if only one bit of the pseudo-random values are released, the seed can be determined from short sequences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの配列であれば配列が検討された空間の構造と直交するようにシミュレーション（モンテカルロ実験）で十分であってもよいです。でもそこに、微妙なパターンが問題を引き起こす可能性があります。しかし、このような配列は、セキュリティアプリケーションで使用するために、明らかに悪いです。彼らは、初期状態が既知であれば、完全に予測可能です。擬似乱数生成器の形態に応じて、シーケンスは[SCHNEIER、スターン]配列の短い部分の観察から決定することができます。例えば、上記発電機と、一方がV（N）の知識を与えられた（N + 1）Vを決定することができます。実際に、それは擬似ランダム値の1ビットだけが解放されている場合でも、これらの技術を有することが示されている、種は、短い配列から決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Not only have linear congruent generators been broken, but techniques are now known for breaking all polynomial congruent generators [KRAWCZYK].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
線形合同発生器が壊れてきたが、技術は今、すべての多項式合同ジェネレータ[KRAWCZYK]を壊すために知られているだけでなく。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Cryptographically Strong Sequences
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。暗号的に強いシーケンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In cases where a series of random quantities must be generated, an adversary may learn some values in the sequence. In general, adversaries should not be able to predict other values from the ones that they know.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ランダム量の系列が生成されなければならない場合には、敵は、シーケンス内のいくつかの値を学習することができます。一般的には、敵は、彼らが知っているものとは別の値を予測することはできないはず。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The correct technique is to start with a strong random seed, to take cryptographically strong steps from that seed [FERGUSON, SCHNEIER], and not to reveal the complete state of the generator in the sequence elements. If each value in the sequence can be calculated in a fixed way from the previous value, then when any value is compromised, all future values can be determined. This would be the case, for example, if each value were a constant function of the previously used values, even if the function were a very strong, non-invertible message digest function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
正しい技術は、その種子から暗号的に強い措置をとるための強力なランダムシード[ファーガソン、SCHNEIER]で開始し、シーケンス要素にジェネレータの完全な状態を明らかにすることはありません。シーケンス内の各値が以前の値から一定の方法で計算することができれば、任意の値が危険にさらされたとき、その後、すべての将来の値を決定することができます。各値は、関数が非常に強い、非可逆メッセージ機能を消化した場合でも、以前に使用した値の定数関数であった場合、これは、例えば、場合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(Note that if a technique for generating a sequence of key values is fast enough, it can trivially be used as the basis for a confidentiality system. If two parties use the same sequence generation technique and start with the same seed material, they will generate identical sequences. These could, for example, be XOR&#39;ed at one end with data being sent to encrypt it, and XOR&#39;ed with this data as received to decrypt it, due to the reversible properties of the XOR operation. This is commonly referred to as a simple stream cipher.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（キー値のシーケンスを生成するための技術が十分に速い場合、それは些細な機密性システムのための基礎として使用することができることに留意されたい。両当事者は、同じ系列生成技術を使用し、同じシード材料で開始した場合、それらが生成しますこのデータと同一の配列を含む。これらは、例えば、それを暗号化するために送信されるデータと一端でXOR演算することができ、XOR演算によるXOR演算の可逆的性質のために、それを解読するために受信した。これは、一般的ですシンプルなストリーム暗号と呼ばれます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. OFB and CTR Sequences
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1。 OFBとCTRシーケンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One way to produce a strong sequence is to take a seed value and hash the quantities produced by concatenating the seed with successive integers, or the like, and then to mask the values obtained so as to limit the amount of generator state available to the adversary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
強いシーケンスを生成する一つの方法は、敵対者が利用可能な発電状態の量を制限するようにシード値を取り、連続した整数との種子などを連結することによって生成量をハッシュし、次に得られた値をマスクすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It may also be possible to use an &#34;encryption&#34; algorithm with a random key and seed value to encrypt successive integers, as in counter (CTR) mode encryption. Alternatively, one can feedback all of the output value from encryption into the value to be encrypted for the next iteration. This is a particular example of output feedback mode (OFB) [MODES].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、（CTR）モード暗号化カウンタのように、連続した整数を暗号化するために、ランダム鍵およびシード値と「暗号化」アルゴリズムを使用することも可能です。暗号からの出力値のすべての次の反復のために暗号化される値に代わり、1缶のフィードバック。これは、出力フィードバックモード（OFB）[MODES]の特定の一例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example is shown below in which shifting and masking are used to combine part of the output feedback with part of the old input. This type of partial feedback should be avoided for reasons described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例を以下に示すシフトたマスキング古い入力の一部と出力フィードバックの一部を結合するために使用されます。部分的なフィードバックのこのタイプは、以下の理由のために避けるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            +---------------+
            |       V       |
            |  |     n      |--+
            +--+------------+  |
                  |            |     +---------+
             shift|            +---&gt; |         |      +-----+
               +--+                  | Encrypt | &lt;--- | Key |
               |           +-------- |         |      +-----+
               |           |         +---------+
               V           V
            +------------+--+
            |      V     |  |
            |       n+1     |
            +---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that if a shift of one is used, this is the same as the shift register technique described in Section 6.1.3, but with the all-important difference that the feedback is determined by a complex non-linear function of all bits rather than by a simple linear or polynomial combination of output from a few bit position taps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方のシフトが使用される場合、これはしかし、フィードバックがなく、全てのビットの複雑な非線形関数によって決定されたすべての重要な違いが、セクション6.1.3で説明したシフトレジスタの技術と同じであることに注意してくださいいくつかのビット位置のタップからの出力の単純な線形または多項式の組み合わせによる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Donald W. Davies showed that this sort of shifted partial output feedback significantly weakens an algorithm, compared to feeding all the output bits back as input. In particular, for DES, repeatedly encrypting a full 64-bit quantity will give an expected repeat in about 2^63 iterations. Feeding back anything less than 64 (and more than 0) bits will give an expected repeat in between 2^31 and 2^32 iterations!
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドナルドW. Daviesがずれ部分出力フィードバックのこの種が大幅バック入力と全ての出力ビットを供給するに比べて、アルゴリズムを弱めることが示されました。具体的には、DESのために、繰り返して完全な64ビット量を暗号化することは、約2 ^ 63回の反復で期待リピートを与えます。バック64未満のもの（以上0）ビットを供給すること2 ^ 31と2 ^ 32回の反復の間で期待されるの繰り返しを与えます！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To predict values of a sequence from others when the sequence was generated by these techniques is equivalent to breaking the cryptosystem or to inverting the &#34;non-invertible&#34; hashing with only partial information available. The less information revealed in each iteration, the harder it will be for an adversary to predict the sequence. Thus it is best to use only one bit from each value. It has been shown that in some cases this makes it impossible to break a system even when the cryptographic system is invertible and could be broken if all of each generated value were revealed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シーケンスは、これらの技術によって生成されたときに他の人からの配列の値を予測するには、暗号を破るまたは「非可逆」利用できる唯一の部分的な情報をハッシュ化反転に相当します。敵対者がシーケンスを予測するために、各反復で明らかに少ない情報は、難しくはなります。したがって、それぞれの値から1ビットだけを使用するのが最適です。いくつかのケースで、これは暗号システムは可逆であり、各生成された値のすべてが明らかにされた場合は分割することができても、それが不可能なシステムを破るために作ることが示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. The Blum Blum Shub Sequence Generator
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2。ブルムブルムシューブシーケンスジェネレータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Currently the generator which has the strongest public proof of strength is called the Blum Blum Shub generator, named after its inventors [BBS]. It is also very simple and is based on quadratic residues. Its only disadvantage is that it is computationally intensive compared to the traditional techniques given in Section 6.1.3. This is not a major drawback if it is used for moderately-infrequent purposes, such as generating session keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在、強度の最強のパブリック証明を持っている発電機は、その発明者[BBS]にちなんで名付けられ、ブルムブルムシューブジェネレータと呼ばれています。また、非常に簡単で、平方剰余に基づいています。その唯一の欠点は、6.1.3項で与えられた伝統的な技法に比べて計算量が多いということです。それは、このようなセッションキーを生成するように適度に-まれ目的に使用される場合、これは大きな欠点ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Simply choose two large prime numbers (say, p and q) that each gives a remainder of 3 when divided by 4. Let n = p * q. Then choose a random number, x, that is relatively prime to n. The initial seed for the generator and the method for calculating subsequent values are then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単に4.レッツN =のp * qで割ったときに、それぞれが3の残りの部分を与えること（たとえば、pとq）二つの大きな素数を選択してください。そして、nと互いに素である乱数、Xを、選択します。発生され、その後の値を計算するための方法のための初期シード：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    2
         s    =  ( x  )(Mod n)
          0
                    2
         s    = ( s   )(Mod n)
          i+1      i
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Be careful to use only a few bits from the bottom of each s. It is always safe to use only the lowest-order bit. If one uses no more than the:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各秒の底から数ビットだけを使用するように注意してください。常に唯一の最下位ビットを使用しても安全です。 1は、以下で使用していない場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         log  ( log  ( s  ) )
            2      2    i
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
low-order bits, then predicting any additional bits from a sequence generated in this manner is provably as hard as factoring n. As long as the initial x is secret, n can be made public if desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
下位ビットは、このようにして生成された配列からの任意の追加のビットを予測することのような硬質Nを因数分解として証明可能です。限り、初期xは秘密であり、nは、所望であれば公表することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An interesting characteristic of this generator is that any of the s values can be directly calculated. In particular,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この発電機の興味深い特性は、S値のいずれかを直接計算することができることです。特に、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 ( (2^i) (Mod ((p-1)*(q-1)) ) ) s = ( s )(Mod n) i 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（（2 ^ i）から（MOD（（P-1）*（Q-1））））S =（S）（MOD n）がI 0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This means that in applications where many keys are generated in this fashion, it is not necessary to save them all. Each key can be effectively indexed and recovered from that small index and the initial s and n.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、多くのキーは、この方法で生成されたアプリケーションでは、それらをすべて保存する必要がないことを意味します。各キーは、効果的に索引付けし、その小さなインデックスと初期SおよびNから回収することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Entropy Pool Techniques
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3。エントロピープールのテクニック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many modern pseudo-random number sources, such as those described in Sections 7.1.2 and 7.1.3 utilize the technique of maintaining a &#34;pool&#34; of bits and providing operations for strongly mixing input with some randomness into the pool and extracting pseudo-random bits from the pool. This is illustrated in the figure below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのようなセクション7.1.2および7.1.3に記載されるもののような多くの近代的な擬似乱数源は、ビットの「プール」を維持し、強くプールにいくつかのランダムで入力を混合し、擬似ランダム抽出するための操作を提供する技術を利用しますプールからのビット。これは、以下の図に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +--------+    +------+    +---------+
         ---&gt;| Mix In |---&gt;| POOL |---&gt;| Extract |---&gt;
             |  Bits  |    |      |    |   Bits  |
             +--------+    +------+    +---------+
                               ^           V
                               |           |
                               +-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bits to be fed into the pool can come from any of the various hardware, environmental, or user input sources discussed above. It is also common to save the state of the pool on system shutdown and to restore it on re-starting, when stable storage is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビットは、上述の様々なハードウェア、環境、またはユーザの入力ソースのいずれかから来ることができるプールに供給されます。システムのシャットダウン時にプールの状態を保存するために、安定したストレージが利用可能な場合、再起動時にそれを復元することも一般的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Care must be taken that enough entropy has been added to the pool to support particular output uses desired. See [RSA_BULL1] for similar suggestions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケアは十分なエントロピーが所望の特定の出力の用途をサポートするために、プールに追加されているように注意しなければなりません。同様の提案を[RSA_BULL1]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Randomness Generation Examples and Standards
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.ランダム性の生成例および規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Several public standards and widely deployed examples are now in place for the generation of keys or other cryptographically random quantities. Some, in section 7.1, include an entropy source. Others, described in section 7.2, provide the pseudo-random number strong-sequence generator but assume the input of a random seed or input from a source of entropy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの公共の標準と広く展開されている例は、キーまたは他の暗号的にランダムな量の世代のための場所になりました。いくつかは、7.1節では、エントロピー源を含みます。セクション7.2で説明した他は、擬似乱数強い系列発生器を提供するが、エントロピーのソースからランダムシードまたは入力の入力を想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Complete Randomness Generators
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。完全なランダム性ジェネレータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Three standards are described below. The two older standards use DES, with its 64-bit block and key size limit, but any equally strong or stronger mixing function could be substituted [DES]. The third is a more modern and stronger standard based on SHA-1 [SHA*]. Lastly, the widely deployed modern UNIX and Windows random number generators are described.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
三つの基準は以下のとおりです。 [DES 2つの古い規格は、64ビットのブロックと鍵サイズ制限と、DESを使用するが、任意の同等に強いまたはより強力な混合機能を置換することができます。第三は、SHA-1 [SHA *]に基づいて、より近代的で強力な標準です。最後に、広く展開されている近代的なUNIXとWindowsの乱数発生器が記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.1. US DoD Recommendations for Password Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.1。パスワード生成のための米国国防総省の提言
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The United States Department of Defense has specific recommendations for password generation [DoD]. It suggests using the US Data Encryption Standard [DES] in Output Feedback Mode [MODES] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
米国国防総省は、[国防総省]パスワード生成のための具体的な提言を持っています。これは、出力フィードバックモード[MODES]次のように米国データ暗号化規格[DES]を使用することを提案しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Use an initialization vector determined from
              the system clock,
              system ID,
              user ID, and
              date and time;
         use a key determined from
              system interrupt registers,
              system status registers, and
              system counters; and,
         as plain text, use an external randomly generated 64-bit
         quantity such as the ASCII bytes for 8 characters typed
         in by a system administrator.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The password can then be calculated from the 64 bit &#34;cipher text&#34; generated by DES in 64-bit Output Feedback Mode. As many bits as are needed can be taken from these 64 bits and expanded into a pronounceable word, phrase, or other format if a human being needs to remember the password.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パスワードは64ビット出力フィードバックモードでDESによって生成された64ビットの「暗号文」から計算することができます。必要とされているなど、多くのビットは、これらの64ビットから取られ、人間がパスワードを覚えておく必要がある場合、発音の単語、フレーズ、または他の形式に拡張することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.2. The /dev/random Device
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.2。 / dev / randomデバイス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Several versions of the UNIX operating system provide a kernel-resident random number generator. Some of these generators use events captured by the Kernel during normal system operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNIXオペレーティング・システムのいくつかのバージョンがカーネル常駐乱数ジェネレータを提供します。これらの発電機のうちのいくつかは、通常のシステム動作中のカーネルによって取得されたイベントを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, on some versions of Linux, the generator consists of a random pool of 512 bytes represented as 128 words of 4 bytes each. When an event occurs, such as a disk drive interrupt, the time of the event is XOR&#39;ed into the pool, and the pool is stirred via a primitive polynomial of degree 128. The pool itself is treated as a ring buffer, with new data being XOR&#39;ed (after stirring with the polynomial) across the entire pool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、Linuxの一部のバージョンでは、発電機は4バイト毎の128のワードとして表される512バイトのランダムプールから成ります。イベントは、ディスクドライブ割り込みとして、発生した場合、イベントの時間をプールにXOR演算され、プールは、プール自体度128の原始多項式を介して攪拌された新規で、リングバッファとして扱われますデータは、プール全体を横切って（多項式で攪拌した後）XOR演算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each call that adds entropy to the pool estimates the amount of likely true entropy the input contains. The pool itself contains a accumulator that estimates the total over all entropy of the pool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プールにエントロピーを追加する各呼び出しは、入力が含まれている可能性が真のエントロピーの量を推定します。プール自体は、プールの全てのエントロピー上の合計を推定するアキュムレータを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Input events come from several sources, as listed below. Unfortunately, for server machines without human operators, the first and third are not available, and entropy may be added slowly in that case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下に示すように、入力イベントは、いくつかのソースから来ます。残念ながら、人間のオペレータなしのサーバー・マシンのために、第一および第三は使用できません、とエントロピーは、その場合には、ゆっくりと添加してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Keyboard interrupts. The time of the interrupt and the scan code are added to the pool. This in effect adds entropy from the human operator by measuring inter-keystroke arrival times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.キーボード割り込み。割り込みとスキャンコードの時間がプールに追加されます。これは、実質的に相互キーストロークの到着時間を測定することにより、人間のオペレータからのエントロピーを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Disk completion and other interrupts. A system being used by a person will likely have a hard-to-predict pattern of disk accesses. (But not all disk drivers support capturing this timing information with sufficient accuracy to be useful.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.ディスクの完了およびその他の割り込み。人によって使用されているシステムは、おそらくディスクアクセスの困難な予測パターンを持つことになります。 （すべてではないディスクドライバが有用であることが十分な精度で、このタイミング情報を取得するサポートしています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Mouse motion. The timing and mouse position are added in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.マウスの動き。タイミングおよびマウス位置で添加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When random bytes are required, the pool is hashed with SHA-1 [SHA*] to yield the returned bytes of randomness. If more bytes are required than the output of SHA-1 (20 bytes), then the hashed output is stirred back into the pool and a new hash is performed to obtain the next 20 bytes. As bytes are removed from the pool, the estimate of entropy is correspondingly decremented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ランダムバイトが必要な場合、プールは、ランダム性の返されたバイトを生成するSHA-1 [SHA *]を用いてハッシュされます。複数バイトがSHA-1（20バイト）の出力よりも、必要な場合には、ハッシュ化された出力は、バックプールに攪拌され、新しいハッシュを次の20のバイトを得るために行われます。バイトがプールから除去されるように、エントロピーの推定値は、それに対応しデクリメントされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To ensure a reasonably random pool upon system startup, the standard startup and shutdown scripts save the pool to a disk file at shutdown and read this file at system startup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
システム起動時に合理的にランダムプールを確保するために、標準の起動およびシャットダウンスクリプトは、シャットダウン時にディスクファイルにプールを保存し、システムの起動時にこのファイルを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two user-exported interfaces. /dev/random returns bytes from the pool but blocks when the estimated entropy drops to zero. As entropy is added to the pool from events, more data becomes available via /dev/random. Random data obtained from such a /dev/random device is suitable for key generation for long term keys, if enough random bits are in the pool or are added in a reasonable amount of time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2つのユーザエクスポートのインターフェイスがあります。推定されたエントロピーがゼロに低下したときに/ dev /ランダム戻るプールが、ブロックからバイト。エントロピーがイベントからプールに追加されると、より多くのデータがランダムに/ dev /を介して利用可能になります。十分なランダムビットがプール内にあるか、または時間の合理的な量で添加される場合、このようなAの/ dev / randomデバイスから得られたランダムデータは、長期鍵の鍵生成に適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
/dev/urandom works like /dev/random; however, it provides data even when the entropy estimate for the random pool drops to zero. This may be adequate for session keys or for other key generation tasks for which blocking to await more random bits is not acceptable. The risk of continuing to take data even when the pool&#39;s entropy estimate is small in that past output may be computable from current output, provided that an attacker can reverse SHA-1. Given that SHA-1 is designed to be non-invertible, this is a reasonable risk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
/ dev / urandomのはは/ dev /ランダムのように動作します。しかし、ランダムプールのエントロピー推定値がゼロに低下した場合にもデータを提供します。これは、セッションキーの以上のランダムビットを待つブロッキング許容されるされていない他のキー生成作業に適してもよいです。プールのエントロピー推定値は、過去の出力は、電流出力から計算してもよいが小さい場合であってもデータを取得し続けるのリスクは、攻撃者はSHA-1を逆転させることができることを条件とします。 SHA-1は非可逆的であるように設計されていることを考えると、これは合理的なリスクです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To obtain random numbers under Linux, Solaris, or other UNIX systems equipped with code as described above, all an application has to do is open either /dev/random or /dev/urandom and read the desired number of bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上述としてLinux、Solarisの下乱数、又はコードを備えた他のUNIXシステムを得るために、すべてのアプリケーションが関係しているオープンのいずれかの/ dev /ランダムまたは/ dev / urandomのであり、バイトの所望の数を読み出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(The Linux Random device was written by Theodore Ts&#39;o. It was based loosely on the random number generator in PGP 2.X and PGP 3.0 (aka PGP 5.0).)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（Linuxのランダムデバイスは、セオドア・ツォーによって書かれました。これは、PGP 2.xとPGP 3.0（別名PGP 5.0）における乱数発生器に緩く基づいていました。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.3. Windows CryptGenRandom
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.3。 WindowsのCryptGenRandom
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Microsoft&#39;s recommendation to users of the widely deployed Windows operating system is generally to use the CryptGenRandom pseudo-random number generation call with the CryptAPI cryptographic service provider. This takes a handle to a cryptographic service provider library, a pointer to a buffer by which the caller can provide entropy and into which the generated pseudo-randomness is returned, and an indication of how many octets of randomness are desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
広く展開されているWindowsオペレーティングシステムのユーザーにMicrosoftの勧告はCryptAPI暗号化サービスプロバイダとのCryptGenRandom擬似乱数生成呼び出しを使用することが一般的です。これは、暗号化サービスプロバイダライブラリに発信者がエントロピー及びその中に生成された擬似乱数が返され、そして所望されるどのように多くの乱数のオクテットの指示を提供することが可能なバッファへのポインタをハンドルをとります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Windows CryptAPI cryptographic service provider stores a seed state variable with every user. When CryptGenRandom is called, this is combined with any randomness provided in the call and with various system and user data such as the process ID, thread ID, system clock, system time, system counter, memory status, free disk clusters, and hashed user environment block. This data is all fed to SHA-1, and the output is used to seed an RC4 key stream. That key stream is used to produce the pseudo-random data requested and to update the user&#39;s seed state variable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WindowsのCryptAPI暗号化サービスプロバイダは、すべてのユーザーとのシード状態変数を格納します。 CryptGenRandomが呼び出されると、これはコールで提供される任意のランダムとし、そのようなプロセスID、スレッドID、システムクロック、システム時刻、システム・カウンタ、メモリ状態、空きディスク・クラスタ、ハッシュユーザなどの様々なシステムとユーザデータと結合されます環境ブロック。このデータは、すべてのSHA-1に供給され、その出力はRC4鍵ストリームを播種するために使用されます。そのキーストリームは、要求された疑似ランダムデータを生成するために、ユーザのシード状態変数を更新するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Users of Windows &#34;.NET&#34; will probably find it easier to use the RNGCryptoServiceProvider.GetBytes method interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Windowsの「.NET」のユーザーは、おそらくそれが簡単にRNGCryptoServiceProvider.GetBytesメソッドインタフェースを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For further information, see [WSC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
詳細については、[WSC]参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Generators Assuming a Source of Entropy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。エントロピーのソースを仮定すると、発電機
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The pseudo-random number generators described in the following three sections all assume that a seed value with sufficient entropy is provided to them. They then generate a strong sequence (see Section 6.2) from that seed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の三つのセクション全てに記載の擬似乱数発生器は、十分なエントロピーを有するシード値をそれらに提供されると仮定する。そして、彼らはその種子から（6.2節を参照）、強力なシーケンスを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. X9.82 Pseudo-Random Number Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1。 X9.82疑似乱数の生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ANSI X9F1 committee is in the final stages of creating a standard for random number generation covering both true randomness generators and pseudo-random number generators. It includes a number of pseudo-random number generators based on hash functions, one of which will probably be based on HMAC SHA hash constructs [RFC2104]. The draft version of this generator is described below, omitting a number of optional features [X9.82].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ANSI X9F1委員会は、真の乱数発生器と、擬似乱数生成器の両方をカバーする乱数発生のための標準を作成するための最終段階にあります。これはおそらく、HMAC SHAハッシュ構築[RFC2104]に基づくであろう一つはハッシュ関数に基づいて、擬似乱数発生器の数を含みます。この発電機のドラフト版はオプション機能[X9.82]の数を省略し、以下に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the subsections below, the HMAC hash construct is simply referred to as HMAC but, of course, a particular standard SHA function must be selected in an particular use. Generally speaking, if the strength of the pseudo-random values to be generated is to be N bits, the SHA function chosen must generate N or more bits of output, and a source of at least N bits of input entropy will be required. The same hash function must be used throughout an instantiation of this generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のサブセクションでは、HMACのハッシュ構築物は、単に、もちろん、特定の標準SHA機能は、特定の用途に選択する必要があり、HMACと呼ばれるが。生成される擬似乱数値の強さがNビットであるとする場合、一般的に言えば、Nまたは出力の複数のビット、及び入力エントロピーの少なくともNビットのソースを生成しなければならない選択されたSHA機能が必要となります。同じハッシュ関数は、このジェネレータのインスタンス化全体で使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1.1. Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1.1。表記法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the following sections, the notation give below is used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のセクションでは、表記法が使用され、以下に与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
hash_length is the output size of the underlying hash function in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
hash_lengthは、使用中の基本となるハッシュ関数の出力サイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
input_entropy is the input bit string that provides entropy to the generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
input_entropyは、発生器にエントロピーを提供する入力ビット列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
K is a bit string of size hash_length that is part of the state of the generator and is updated at least once each time random bits are generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kは、発電機の状態の一部であり、少なくとも一回のランダムビットが生成されるたびに更新されるサイズhash_lengthのビット列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
V is a bit string of size hash_length and is part of the state of the generator. It is updated each time hash_length bits of output are generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Vは、サイズhash_lengthのビット列であり、発電機の状態の一部です。これは、出力のhash_lengthビットが生成されるたびに更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;|&#34; represents concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;|&#34;連結を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1.2. Initializing the Generator
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1.2。ジェネレータを初期化します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Set V to all zero bytes, except the low-order bit of each byte is set to one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各バイトの下位ビットが1に設定されている以外は、全てゼロバイトにVを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Set K to all zero bytes, then set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのゼロバイトにKを設定し、設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
K = HMAC ( K, V | 0x00 | input_entropy )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
K = HMAC（K、V | $ 00 | input_entropy）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
V = HMAC ( K, V )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
V = HMAC（K、V）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
K = HMAC ( K, V | 0x01 | input_entropy )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
K = HMAC（K、V |は0x01 | input_entropy）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
V = HMAC ( K, V )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
V = HMAC（K、V）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: All SHA algorithms produce an integral number of bytes, so the lengths of K and V will be integral numbers of bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：K及びVの長さがバイトの整数であろうように、すべてのSHAアルゴリズムは、バイトの整数を生じさせます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1.3. Generating Random Bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1.3。生成ランダムビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When output is called for, simply set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力が要求される場合には、単純に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
V = HMAC ( K, V )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
V = HMAC（K、V）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
and use the leading bits from V. If more bits are needed than the length of V, set &#34;temp&#34; to a null bit string and then repeatedly perform:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
より多くのビットが、Vの長さよりも必要な繰り返しヌルビット列に「TEMP」を設定している場合とVから先頭のビットを使用して実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         V = HMAC ( K, V )
         temp = temp | V
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
stopping as soon as temp is equal to or longer than the number of random bits requested. Use the requested number of leading bits from temp. The definition of the algorithm prohibits requesting more than 2^35 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一時とすぐに停止することに等しいか、または要求されたランダムなビット数よりも長いです。一時からの先行ビットの要求された数を使用してください。アルゴリズムの定義は、以上2 ^ 35ビットを要求禁止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After extracting and saving the pseudo-random output bits as described above, before returning you must also perform two more HMACs as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前述したように、擬似ランダム出力ビットを抽出して保存した後、次のようにも2つのHMACsを実行する必要があります返す前に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         K = HMAC ( K, V | 0x00 )
         V = HMAC ( K, V )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. X9.17 Key Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2。 X9.17鍵生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         The American National Standards Institute has specified the
         following method for generating a sequence of keys [X9.17]:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
s is the initial 64 bit seed. 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sは初期64ビットの種子です。 0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
g is the sequence of generated 64-bit key quantities n
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
gが生成された64ビットの鍵量nの配列であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
k is a random key reserved for generating this key sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
kがこのキーシーケンスを生成するために予約ランダムキーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
t is the time at which a key is generated, to as fine a resolution as is available (up to 64 bits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
tは（64ビットまで）利用可能である限り細かい解像度に、キーが生成された時間です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DES ( K, Q ) is the DES encryption of quantity Q with key K.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DES（K、Q）は、鍵Kを有する量QのDES暗号化です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その後：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         g    = DES ( k, DES ( k, t ) XOR s  )
          n                                n
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
s = DES ( k, DES ( k, t ) XOR g ) n+1 n
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
S = DES（K、DES（K、T）のXOR G）N + 1からn
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If g sub n is to be used as a DES key, then every eighth bit should be adjusted for parity for that use, but the entire 64 bit unmodified g should be used in calculating the next s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GサブnがDES鍵として使用される場合、すべての8番目のビットは、その使用のためのパリティのために調整されるべきであるが、全体の64ビット未修飾Gは次の計算に使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.3. DSS Pseudo-random Number Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.3。擬似乱数生成DSS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix 3 of the NIST Digital Signature Standard [DSS] provides a method of producing a sequence of pseudo-random 160 bit quantities for use as private keys or the like. This has been modified by Change Notice 1 [DSS_CN1] to produce the following algorithm for generating general-purpose pseudo-random numbers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NISTデジタル署名標準[DSS]の付録3は、秘密鍵等として使用するための擬似ランダム160ビット量のシーケンスを生成する方法を提供します。これは汎用の擬似乱数を生成するための以下のアルゴリズムを生成するために変更通知1 [DSS_CN1]によって改変されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
t = 0x 67452301 EFCDAB89 98BADCFE 10325476 C3D2E1F0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トン= 0X 67452301 EFCDAB89 98BADCFE 10325476 C3D2E1F0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
XKEY = initial seed 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
XKEY =初期シード0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For j = 0 to ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
J = 0のために...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             XVAL = ( XKEY  + optional user input ) (Mod 2^512)
                          j
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
X = G( t, XVAL ) j
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
X = G（T、XVAL）J
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
XKEY = ( 1 + XKEY + X ) (Mod 2^512) j+1 j j
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
XKEY =（1 + XKEY + X）（MOD 2 ^ 512）J + 1 j個のJ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The quantities X thus produced are the pseudo-random sequence of 160-bit values. Two functions can be used for &#34;G&#34; above. Each produces a 160-bit value and takes two arguments, a 160-bit value and a 512 bit value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このようにして製造数量Xは160ビット値の擬似ランダムシーケンスです。二つの機能は、上記の「G」のために使用することができます。各160ビット値を生成し、二つの引数、160ビットの値と512ビットの値をとります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first is based on SHA-1 and works by setting the 5 linking variables, denoted H with subscripts in the SHA-1 specification, to the first argument divided into fifths. Then steps (a) through (e) of section 7 of the NIST SHA-1 specification are run over the second argument as if it were a 512-bit data block. The values of the linking variable after those steps are then concatenated to produce the output of G [SHA*].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初は、SHA-1に基づいて5つの連結変数を設定することによって動作する、五分のに分割された第1引数には、SHA-1仕様における添字とHと表されます。それは512ビットのデータブロックであるかのようにNIST SHA-1仕様のセクション7の（e）は工程（a）は、第2引数の上で実行されています。連結変数の値は、これらのステップは、次にG [SHA *]の出力を生成するために連結された後。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As an alternative method, NIST also defined an alternate G function based on multiple applications of the DES encryption function [DSS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の方法として、NISTはまた、DES暗号化機能[DSS]の複数のアプリケーションに基づいて、代替のG機能を定義しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Examples of Randomness Required
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
乱雑必須の8例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Below are two examples showing rough calculations of randomness needed for security. The first is for moderate security passwords, while the second assumes a need for a very high-security cryptographic key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下は、セキュリティのために必要なランダム性の荒い計算を示す2つの例を示します。第二は、非常に高セキュリティの暗号化キーの必要性を前提としつつ、第1には、適度なセキュリティパスワードのです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, [ORMAN] and [RSA_BULL13] provide information on the public key lengths that should be used for exchanging symmetric keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、[オーマン]及び[RSA_BULL13]対称鍵を交換するために使用されるべき公開鍵の長さに関する情報を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Password Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。パスワード生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Assume that user passwords change once a year and that it is desired that the probability that an adversary could guess the password for a particular account be less than one in a thousand. Further assume that sending a password to the system is the only way to try a password. Then the crucial question is how often an adversary can try possibilities. Assume that delays have been introduced into a system so that an adversary can make at most one password try every six seconds. That&#39;s 600 per hour, or about 15,000 per day, or about 5,000,000 tries in a year. Assuming any sort of monitoring, it is unlikely that someone could actually try continuously for a year. Even if log files are only checked monthly, 500,000 tries is more plausible before the attack is noticed and steps are taken to change passwords and make it harder to try more passwords.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのユーザーのパスワードが年に一度変更すると、敵が特定のアカウントのパスワードを推測できた確率は千未満1であることが望まれていることを前提としています。さらに、システムにパスワードを送信すると、パスワードをしようとする唯一の方法であることを前提としています。そして、重要な疑問は、敵対者が可能性を試すことができますどのくらいの頻度です。敵が高々1つのパスワードは、6秒ごとに試すことができますように、遅延がシステムに導入されていることを前提としています。それは時間あたり600だ、または一日あたり約15,000、または年間で約5,000,000トライ。監視の任意の並べ替えを想定すると、誰かが実際に年連続試みることができるということはほとんどありません。ログファイルのみを毎月チェックされていても攻撃が注目されているとステップがパスワードを変更し、それが難しく、よりパスワードをしようとするために取られる前に、50万回の試行は、より説得力のあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To have a one-in-a-thousand chance of guessing the password in 500,000 tries implies a universe of at least 500,000,000 passwords, or about 2^29. Thus, 29 bits of randomness are needed. This can probably be achieved by using the US DoD-recommended inputs for password generation, as it has 8 inputs that probably average over 5 bits of randomness each (see section 7.1). Using a list of 1,000 words, the password could be expressed as a three-word phrase (1,000,000,000 possibilities). By using case-insensitive letters and digits, six characters would suffice ((26+10)^6 = 2,176,782,336 possibilities).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
50万試みでパスワードを推測の1・イン・ザ・千チャンスを持っていることは、少なくとも5億パスワード、または約2 ^ 29の宇宙を意味します。したがって、乱数の29ビットが必要とされています。それは（セクション7.1を参照）ランダムそれぞれの5ビットを超える、おそらく平均8つの入力を有し、これは、おそらく、パスワード生成のための米国国防総省推奨入力を使用することによって達成することができます。千個の単語のリストを使用して、パスワードは3ワードフレーズ（10億の可能性）のように表すことができます。大文字と小文字を区別しない文字と数字を使用して、6つの文字は、（（26 + 10）^ 6 = 2176782336可能性）で十分であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a higher-security password, the number of bits required goes up. To decrease the probability by 1,000 requires increasing the universe of passwords by the same factor, which adds about 10 bits. Thus, to have only a one in a million chance of a password being guessed under the above scenario would require 39 bits of randomness and a password that was a four-word phrase from a 1,000 word list, or eight letters/digits. To go to a one-in-10^9 chance, 49 bits of randomness are needed, implying a five-word phrase or a ten-letter/digit password.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
高セキュリティパスワードのために、必要なビット数が上がります。 1,000確率を減少させるためには、約10ビットを追加し、同じ因子によってパスワードの宇宙を増加させる必要があります。したがって、上記のシナリオの下で推測されているパスワードの百万のチャンスに一つだけを持っていることは39ランダムのビットと千単語リストから4ワードフレーズだったパスワード、または8文字/数字を必要とします。 1-で-10 ^ 9偶然に移動するには、乱数の49ビットは5ワードフレーズまたは10文字/桁のパスワードを暗示し、必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In a real system, of course, there are other factors. For example, the larger and harder to remember passwords are, the more likely users will bed to write them down, resulting in an additional risk of compromise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実際のシステムでは、当然のことながら、他の要因があります。例えば、より大きな及びパスワードを記憶しにくいが、より可能性の高いユーザーは妥協の追加的なリスクが生じ、それらを書き留めてベッドになるされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. A Very High Security Cryptographic Key
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。非常に高いセキュリティの暗号鍵
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Assume that a very high security key is needed for symmetric encryption/decryption between two parties. Assume also that an adversary can observe communications and knows the algorithm being used. Within the field of random possibilities, the adversary can try key values in hopes of finding the one in use. Assume further that brute force trial of keys is the best the adversary can do.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非常に高いセキュリティキーが2者間の対称暗号化/復号化のために必要であることを前提としています。敵がコミュニケーションを観察することができ、アルゴリズムが使用されて知っていることも前提としています。ランダムな可能性の分野の中で、敵は、使用中のものを見つけることを期待してキー値を試すことができます。鍵のブルートフォーストライアルは、敵ができる最善であると仮定する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1. Effort per Key Trial
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1。キー試用ごとの取り組み
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
How much effort will it take to try each key? For very high-security applications, it is best to assume a low value of effort. Even if it would clearly take tens of thousands of computer cycles or more to try a single key, there may be some pattern that enables huge blocks of key values to be tested with much less effort per key. Thus, it is probably best to assume no more than a couple of hundred cycles per key. (There is no clear lower bound on this, as computers operate in parallel on a number of bits and a poor encryption algorithm could allow many keys or even groups of keys to be tested in parallel. However, we need to assume some value and can hope that a reasonably strong algorithm has been chosen for our hypothetical high-security task.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どのように多くの努力、それは各キーを試してかかりますか？非常に高いセキュリティアプリケーションのために、それは努力の低い値を仮定するのが最善の方法です。それは明らかに単一のキーをしようとするコンピュータ・サイクル以上の数万を取る場合でも、キー値の巨大なブロックは、キーごとにはるかに少ない労力でテストすることを可能にするいくつかのパターンがあるかもしれません。したがって、キーごとに百サイクルのカップルよりも多くを負いませんし、おそらく最高です。コンピュータはビット数と多くのキーまたはキーのさえグループが並行してテストする可能性が悪い暗号化アルゴリズムに並列に動作するよう（、明確な下限この上ありません。しかし、我々はいくつかの値を取る必要があるとすることができます合理的に強いアルゴリズムは仮定の高度なセキュリティタスクのために選択されていることを願っています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the adversary can command a highly parallel processor or a large network of work stations, 10^11 cycles per second is probably a minimum assumption today. Looking forward a few years, there should be at least an order of magnitude improvement. Thus, it is reasonable to assume that 10^10 keys could be checked per second, or 3.6*10^12 per hour or 6*10^14 per week, or 2.4*10^15 per month. This implies a need for a minimum of 63 bits of randomness in keys, to be sure that they cannot be found in a month. Even then it is possible that, a few years from now, a highly determined and resourceful adversary could break the key in 2 weeks; on average, they need try only half the keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
敵が非常に並列プロセッサまたはワークステーションの大規模なネットワークを命令することができる場合は、毎秒10 ^ 11サイクルは、おそらく今日の最小仮定です。数年間楽しみにして、大きさの改善の少なくとも順序があるはずです。したがって、10 ^ 10のキーが毎秒確認、または月あたり1時間あたり3.6×10 ^ 12または週6 * 10 ^ 14、または2.4 * 10 ^ 15可能であることを前提とするのが妥当です。これは、彼らが月に見つからないことを確認するために、キーでランダムの63ビットの最小の必要性を意味します。でも非常に決定したと機知に敵が2週間で鍵を壊す可能性があり、今から数年後、ということも可能です。平均的に、彼らは半分だけ鍵を試す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These questions are considered in detail in &#34;Minimal Key Lengths for Symmetric Ciphers to Provide Adequate Commercial Security: A Report by an Ad Hoc Group of Cryptographers and Computer Scientists&#34; [KeyStudy] that was sponsored by the Business Software Alliance. It concluded that a reasonable key length in 1995 for very high security is in the range of 75 to 90 bits and, since the cost of cryptography does not vary much with the key size, it recommends 90 bits. To update these recommendations, just add 2/3 of a bit per year for Moore&#39;s law [MOORE]. This translates to a determination, in the year 2004, a reasonable key length is in the 81- to 96-bit range. In fact, today, it is increasingly common to use keys longer than 96 bits, such as 128-bit (or longer) keys with AES and keys with effective lengths of 112-bits with triple-DES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの質問は、「適切な商業セキュリティを提供するために、共通鍵暗号のための最小限のキーの長さ：暗号学者とコンピュータ科学者のアドホックグループによる報告書」に詳細に検討されているビジネスソフトウェアアライアンスが主催して、[KeyStudy]。暗号化のコストは、鍵のサイズとあまり変化しないので、それは、非常に高いセキュリティのために1995年に合理的なキーの長さは、75〜90ビットの範囲にあることを締結し、それは90ビットをお勧めします。これらの推奨事項を更新するには、単にムーアの法則[MOORE]のために、年間ビットの2/3を追加します。これは、2004年に、合理的なキーの長さは、81- 96ビットの範囲であり、決意に変換されます。実際には、今日、このようなAESやトリプルDESと112ビットの有効長さキーで128ビット（以上）のキーとして96ビット、より長いキーを使用することがますます一般的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2. Meet-in-the-Middle Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2。会う-in-the-middle攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If chosen or known plain text and the resulting encrypted text are available, a &#34;meet-in-the-middle&#34; attack is possible if the structure of the encryption algorithm allows it. (In a known plain text attack, the adversary knows all or part (possibly some standard header or trailer fields) of the messages being encrypted. In a chosen plain text attack, the adversary can force some chosen plain text to be encrypted, possibly by &#34;leaking&#34; an exciting text that is sent by the adversary over an encrypted channel because the text is so interesting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択したか知らプレーンテキスト、そして得られた暗号化されたテキストが利用可能な場合は、暗号化アルゴリズムの構造がそれを許可する場合、「会う-in-the-middle」攻撃が可能です。 （既知平文攻撃では、攻撃者は、暗号化されたメッセージのすべてまたは一部を（おそらくいくつかの標準ヘッダ又はトレーラフィールド）を知っている。選択平文攻撃では、攻撃者が可能性により、暗号化されるいくつかの選択されたプレーンテキストを強制することができテキストはとても興味深いものですので、暗号化されたチャネルを介して敵によって送信されたエキサイティングなテキストを「漏れました」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following is an oversimplified explanation of the meet-in-the-middle attack: the adversary can half-encrypt the known or chosen plain text with all possible first half-keys, sort the output, and then half-decrypt the encoded text with all the second half-keys. If a match is found, the full key can be assembled from the halves and used to decrypt other parts of the message or other messages. At its best, this type of attack can halve the exponent of the work required by the adversary while adding a very large but roughly constant factor of effort. Thus, if this attack can be mounted, a doubling of the amount of randomness in the very strong key to a minimum of 192 bits (96*2) is required for the year 2004, based on the [KeyStudy] analysis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単純化しすぎ説明がされ、次の中間一致攻撃：敵は、すべての可能な最初の半キーで知られている、または選択平文を半暗号化出力をソートし、その後でエンコードされたテキストを半復号化できます全ての第2のハーフのキー。一致が見つかった場合、完全なキーが半分から組み立てられ、メッセージまたは他のメッセージの他の部分を解読するために使用することができます。その最高の状態で、この種の攻撃は、努力の非常に大きいが、ほぼ一定の係数を添加しながら、敵によって必要な作業の指数を半減することができます。この攻撃を実装することができる場合したがって、192ビット（96 * 2）の最小値に非常に強いキーでランダムの量の倍増は、[KeyStudy]分析に基づいて、2004年に必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This amount of randomness is well beyond the limit of that in the inputs recommended by the US DoD for password generation and could require user-typing timing, hardware random number generation, or other sources of randomness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ランダム性のこの量は十分パスワード生成のために米国国防総省によって推奨入力でその限界を超えていると、ユーザ入力のタイミング、ハードウェア乱数生成、またはランダム性の他の情報源を必要とする可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The meet-in-the-middle attack assumes that the cryptographic algorithm can be decomposed in this way. Hopefully no modern algorithm has this weakness, but there may be cases where we are not sure of that or even of what algorithm a key will be used with. Even if a basic algorithm is not subject to a meet-in-the-middle attack, an attempt to produce a stronger algorithm by applying the basic algorithm twice (or two different algorithms sequentially) with different keys will gain less added security than would be expected. Such a composite algorithm would be subject to a meet-in-the-middle attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
中間一致攻撃は、暗号アルゴリズムは、このように分解できることを前提としています。うまくいけば、何の近代的なアルゴリズムは、この弱点を持っていませんが、我々はそれのかさえも一緒に使用されるキーを、アルゴリズム何がわからない場合があります。基本的なアルゴリズムは、中間一致攻撃を受けない場合であっても、異なるキーで（順次または2つの異なるアルゴリズム）を2回基本的なアルゴリズムを適用することによって、より強力なアルゴリズムを製造する試みがされるよりも少ない追加のセキュリティを得ることが予想。このような複合アルゴリズムは、中間一致攻撃を受けることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Enormous resources may be required to mount a meet-in-the-middle attack, but they are probably within the range of the national security services of a major nation. Essentially all nations spy on other nations&#39; traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
膨大なリソースは、中間一致攻撃をマウントするのに必要なことかもしれないが、彼らは主要国の国家安全保障サービスの範囲内で、おそらくです。基本的にすべての国が他の国のトラフィックをスパイ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.3. Other Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.3。その他の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KeyStudy] also considers the possibilities of special-purpose code-breaking hardware and having an adequate safety margin.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【KeyStudy】また特殊目的コード破断ハードウェア及び適切な安全マージンを有する可能性を考慮する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that key length calculations such as those above are controversial and depend on various assumptions about the cryptographic algorithms in use. In some cases, a professional with a deep knowledge of algorithm-breaking techniques and of the strength of the algorithm in use could be satisfied with less than half of the 192 bit key size derived above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのようなもののようなキーの長さの計算は、上記の論争であり、使用中の暗号アルゴリズムに関する様々な仮定に依存することに留意されたいです。いくつかのケースでは、アルゴリズム破りの技術の深い知識を持つと、使用中のアルゴリズムの強度のプロは、上記の派生192ビットの鍵サイズの半分以下で満足することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For further examples of conservative design principles, see [FERGUSON].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
保守的な設計原理のさらなる例については、[FERGUSON]を参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Conclusion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.おわり
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Generation of unguessable &#34;random&#34; secret quantities for security use is an essential but difficult task.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティの使用のために推測できない「ランダム」秘密量の生成が不可欠ではなく、困難な作業です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hardware techniques for producing the needed entropy would be relatively simple. In particular, the volume and quality would not need to be high, and existing computer hardware, such as audio input or disk drives, can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必要なエントロピーを生成するためのハードウェア技術は、比較的簡単になります。具体的には、容積及び品質が高いことが必要ではないであろう、そして、音声入力やディスクドライブなどのコンピュータハードウェアを、既存の、使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Widely-available computational techniques can process low-quality random quantities from multiple sources, or a larger quantity of such low-quality input from one source, to produce a smaller quantity of higher-quality keying material. In the absence of hardware sources of randomness, a variety of user and software sources can frequently, with care, be used instead. However, most modern systems already have hardware, such as disk drives or audio input, that could be used to produce high-quality randomness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
広く利用可能な計算技術は、高品質の鍵材料の少ない量を産生するために、一つのソースからの低品質、複数のソースからランダムな量、またはそのような低品質の入力のより大きな量を処理することができます。ランダムのハードウェア源の非存在下で、ユーザとソフトウェアの種々の供給源は、しばしば、注意して、代わりに使用することができます。しかし、最も近代的なシステムでは、すでに高品質のランダム性を生成するために使用することができ、このようなディスクドライブまたはオーディオ入力などのハードウェアを、持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once a sufficient quantity of high-quality seed key material (a couple of hundred bits) is available, computational techniques are available to produce cryptographically-strong sequences of computationally-unpredictable quantities from this seed material.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
高品質シード鍵材料（数百ビットのカップル）の十分な量が利用可能になると、計算技術は、この種の材料から計算上予測不可能な量の暗号強いシーケンスを生成するために利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The entirety of this document concerns techniques and recommendations for generating unguessable &#34;random&#34; quantities for use as passwords, cryptographic keys, initialization vectors, sequence numbers, and similar security applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書の全体は、パスワード、暗号鍵、初期化ベクトル、シーケンス番号、及び同様のセキュリティアプリケーションとして使用するために推測できない「ランダム」な量を生成するための技術と勧告に関する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Special thanks to Paul Hoffman and John Kelsey for their extensive comments and to Peter Gutmann, who has permitted the incorporation of material from his paper &#34;Software Generation of Practically Strong Random Numbers&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らの大規模なコメントと彼の論文「実際に強力な乱数のソフトウェア・ジェネレーション」からの材料の取り込みを許可しているピーター・ガットマン、ポール・ホフマン、ジョンケルシーに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following people (in alphabetic order) have contributed substantially to this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（アルファベット順）次の人は、このドキュメントに、実質的に貢献しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Steve Bellovin, Daniel Brown, Don Davis, Peter Gutmann, Tony Hansen, Sandy Harris, Paul Hoffman, Scott Hollenback, Russ Housley, Christian Huitema, John Kelsey, Mats Naslund, and Damir Rajnovic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スティーブBellovin氏、ダニエル・ブラウン、ドン・デイビス、ピーター・ガットマン、トニー・ハンセン、サンディ・ハリス、ポール・ホフマン、スコットHollenback、ラスHousley、クリスチャンのHuitema、ジョン・ケルシー、マッツ・ナズランド、およびダミールRajnovic。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following people (in alphabetic order) contributed to RFC 1750, the predecessor of this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の人（アルファベット順）は、RFC 1750に、このドキュメントの前任者の貢献しました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David M. Balenson, Don T. Davis, Carl Ellison, Marc Horowitz, Christian Huitema, Charlie Kaufman, Steve Kent, Hal Murray, Neil Haller, Richard Pitkin, Tim Redmond, and Doug Tygar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デイビッドM. Balenson、ドン・T.デイヴィス、カール・エリソン、マーク・ホロウィッツ、クリスチャンのHuitema、チャーリー・カウフマン、スティーブ・ケント、ハル・マレー、ニール・ハラー、リチャードピトキン、ティム・レドモンド、そしてダグTygar。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A: Changes from RFC 1750
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A：RFC 1750からの変更点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Additional acknowledgements have been added.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.追加の承認が追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Insertion of section 5.3 on mixing with S-boxes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sボックスとの混合のセクション5.3の2挿入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Addition of section 3.3 on Ring Oscillator randomness sources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リングオシレータランダム源のセクション3.3の3添加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Addition of AES and the members of the SHA series producing more than 160 bits. Use of AES has been emphasized and the use of DES de-emphasized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. AESの添加及び160個の以上のビットを生成するSHAシリーズのメンバー。 AESの使用が強調されているとDESの使用は、デ強調しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. Addition of section 6.3 on entropy pool techniques.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エントロピープールの技術のセクション6.3の5添加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. Addition of section 7.2.3 on the pseudo-random number generation techniques given in FIPS 186-2 (with Change Notice 1), 7.2.1 on those given in X9.82, section 7.1.2 on the random number generation techniques of the /dev/random device in Linux and other UNIX systems, and section 7.1.3 on random number generation techniques in the Windows operating system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
擬似乱数生成（変更通知1）FIPS 186-2に与えられる技術、X9.82に与えられたもので7.2.1、乱数生成技術のセクション7.1.2のセクション7.2.3の6添加Linuxの場合は/ dev / randomデバイスや他のUNIXシステム、およびWindowsオペレーティングシステムでの乱数生成技術上のセクション7.1.3の。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. Addition of references to the &#34;Minimal Key Lengths for Symmetric Ciphers to Provide Adequate Commercial Security&#34; study published in January 1996 [KeyStudy] and to [RFC1948].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そして、[RFC1948]に[KeyStudy] 1996年1月に発表された研究「適切な商業セキュリティを提供するために、共通鍵暗号のための最小限のキーの長さ」への言及7.追加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
8. Added caveats to using Diffie-Hellman as a mixing function and, because of those caveats and its computationally intensive nature, recommend against its use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
なぜなら、これらの警告およびその計算集約性質のため、混合関数としてディフィー - ヘルマンを使用して8.追加された警告は、その使用に対してお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
9. Addition of references to the X9.82 effort and the [TURBID] and [NASLUND] papers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
X9.82の努力と[TURBID]と[NASLUND]論文への参照の9追加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
10. Addition of discussion of min-entropy and Renyi entropy and references to the [LUBY] book.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ルビー]ブックに最小エントロピーとレーニイエントロピー及び参考文献の議論の10追加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
11. Major restructuring, minor wording changes, and a variety of reference updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
11.大規模なリストラ、軽微な文言の変更、および参照の更新の様々な。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Informative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AES] &#34;Specification of the Advanced Encryption Standard (AES)&#34;, United States of America, US National Institute of Standards and Technology, FIPS 197, November 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、アメリカ合衆国、米国国立標準技術研究所、FIPS 197、2001年11月[AES] &#34;のAdvanced Encryption Standard（AES）の仕様&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ASYMMETRIC] Simmons, G., Ed., &#34;Secure Communications and Asymmetric Cryptosystems&#34;, AAAS Selected Symposium 69, ISBN 0-86531-338-5, Westview Press, 1982.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ASYMMETRIC]シモンズ、G.編、 &#34;セキュアな通信と非対称暗号&#34;、AAASシンポジウム69、ISBN 0-86531-338-5、ウェストビュープレス、1982を選択しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BBS] Blum, L., Blum, M., and M. Shub, &#34;A Simple Unpredictable Pseudo-Random Number Generator&#34;, SIAM Journal on Computing, v. 15, n. 2, 1986.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BBS]ブルーム、L.、ブラム、M.、およびM.シューブ、 &#34;簡単な予測不能擬似乱数発生器&#34;、SIAMジャーナルコンピューティング、V。15、N。 2、1986。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BRILLINGER] Brillinger, D., &#34;Time Series: Data Analysis and Theory&#34;, Holden-Day, 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BRILLINGER] BRILLINGER、D.、 &#34;時系列：データ解析と理論&#34;、ホールデン-日、1981。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CRC] &#34;C.R.C. Standard Mathematical Tables&#34;, Chemical Rubber Publishing Company.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CRC「C.R.C.標準的な数学テーブル」、ケミカル・ラバー・パブリッシング・カンパニー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DAVIS] Davis, D., Ihaka, R., and P. Fenstermacher, &#34;Cryptographic Randomness from Air Turbulence in Disk Drives&#34;, Advances in Cryptology - Crypto &#39;94, Springer-Verlag Lecture Notes in Computer Science #839, 1984.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;ディスク・ドライブで乱気流から暗号ランダム性&#34; [DAVIS]デイビス、D.、Ihaka、R.、およびP. Fenstermacherは、暗号学における進歩 - 暗号&#39;94、コンピュータサイエンスの＃839、1984年にシュプリンガー・フェアラーク講義ノート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DES] &#34;Data Encryption Standard&#34;, US National Institute of Standards and Technology, FIPS 46-3, October 1999. Also, &#34;Data Encryption Algorithm&#34;, American National Standards Institute, ANSI X3.92-1981. See also FIPS 112, &#34;Password Usage&#34;, which includes FORTRAN code for performing DES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DES]「データ暗号化規格」、米国立標準技術研究所は、1999年10月また、「データ暗号化アルゴリズム」、米国規格協会、ANSI X3.92-1981、46-3をFIPS。参照112は、DESを実行するためのFORTRANコードを含む「パスワードの使用」を、FIPS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[D-H] Rescorla, E., &#34;Diffie-Hellman Key Agreement Method&#34;, RFC 2631, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[D-H]レスコラ、E.、 &#34;ディフィー・ヘルマン鍵共有方法&#34;、RFC 2631、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DNSSEC1] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &#34;DNS Security Introduction and Requirements&#34;, RFC 4033, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DNSSEC1]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 &#34;DNSセキュリティ序論と要件&#34;、RFC 4033、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DNSSEC2] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &#34;Resource Records for the DNS Security Extensions&#34;, RFC 4034, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DNSSEC2]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 &#34;DNSセキュリティ拡張機能のためのリソースレコード&#34;、RFC 4034、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DNSSEC3] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &#34;Protocol Modifications for the DNS Security Extensions&#34;, RFC 4035, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DNSSEC3]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 &#34;DNSセキュリティ拡張のためのプロトコル変更&#34;、RFC 4035、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DoD] &#34;Password Management Guideline&#34;, United States of America, Department of Defense, Computer Security Center, CSC-STD-002-85, April 1885.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[国防総省]「パスワード管理ガイドライン」、アメリカ合衆国、国防総省、コンピュータセキュリティセンター、CSC-STD-002から85、1885年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   (See also &#34;Password Usage&#34;, FIPS 112, which
                   incorporates CSC-STD-002-85 as one of its appendices.
                   FIPS 112 is currently available at:
                   http://www.idl.nist.gov/fipspubs/fip112.htm.)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS] &#34;Digital Signature Standard (DSS)&#34;, US National Institute of Standards and Technology, FIPS 186-2, January 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS] &#34;デジタル署名標準（DSS）&#34;、米国国立標準技術研究所は、2000年1月、186-2をFIPS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS_CN1] &#34;Digital Signature Standard Change Notice 1&#34;, US National Institute of Standards and Technology, FIPS 186-2 Change Notice 1, 5, October 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS_CN1]「デジタル署名標準変更通知1」、米国立標準技術研究所、FIPS 186-2変更通知1、5、2001年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FERGUSON] Ferguson, N. and B. Schneier, &#34;Practical Cryptography&#34;, Wiley Publishing Inc., ISBN 047122894X, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FERGUSON]ファーガソン、N.およびB.シュナイアー、 &#34;実用的な暗号化&#34;、ワイリー出版社、ISBN 047122894X、2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[GIFFORD] Gifford, D., &#34;Natural Random Number&#34;, MIT/LCS/TM-371, September 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[GIFFORD]ギフォード、D.、 &#34;自然乱数&#34;、MIT / LCS / TM-371、1988年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEE_802.11i] &#34;Amendment to Standard for Telecommunications and Information Exchange Between Systems - LAN/MAN Specific Requirements - Part 11: Wireless Medium Access Control (MAC) and physical layer (PHY) specifications: Medium Access Control (MAC) Security Enhancements&#34;, IEEE, January 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEE_802.11i]「電気通信及びシステム間情報交換のための標準の改正 -  LAN / MAN具体的な要件 - パート11：無線媒体アクセス制御（MAC）および物理層（PHY）仕様：媒体アクセス制御（MAC）セキュリティの強化」 、IEEE、2004年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IPSEC] Kent, S. and R. Atkinson, &#34;Security Architecture for the Internet Protocol&#34;, RFC 2401, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IPSEC]ケント、S.とR.アトキンソン、 &#34;インターネットプロトコルのためのセキュリティー体系&#34;、RFC 2401、1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Jakobsson] Jakobsson, M., Shriver, E., Hillyer, B., and A. Juels, &#34;A practical secure random bit generator&#34;, Proceedings of the Fifth ACM Conference on Computer and Communications Security, 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【Jakobsson] Jakobsson、M.、シュライバー、E.、Hillyer、B.、およびA. Juels、 &#34;実用的な安全なランダムビット発生器&#34;、コンピュータおよび通信セキュリティ、1998年第五ACM会議の議事録。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KAUFMAN] Kaufman, C., Perlman, R., and M. Speciner, &#34;Network Security: Private Communication in a Public World&#34;, Prentis Hall PTR, ISBN 0-13-046019-2, 2nd Edition 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KAUFMAN]カウフマン、C.、パールマン、R.、およびM. Speciner、 &#34;ネットワークセキュリティ：公共世界のプライベートコミュニケーション&#34;、PrentisホールPTR、ISBN 0-13-046019-2、第2版2002。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KeyStudy] Blaze, M., Diffie, W., Riverst, R., Schneier, B. Shimomura, T., Thompson, E., and M. Weiner, &#34;Minimal Key Lengths for Symmetric Ciphers to Provide Adequate Commercial Security: A Report by an Ad Hoc Group of Cryptographers and Computer Scientists&#34;, January 1996. Currently available at: http://www.crypto.com/papers/keylength.txt and http://www.securitydocs.com/library/441.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
適切な商業セキュリティを提供するために、[KeyStudy]ブレイズ、M.、ディフィー、W.、Riverst、R.、シュナイアー、B.下村、T.、トンプソン、E.、およびM.ワイナー、」共通鍵暗号のための最小限のキーの長さ： http://www.crypto.com/papers/keylength.txtとhttp://www.securitydocs.com/library/441：で、1996年1月は、現在利用可能な暗号学者とコンピュータ科学者のアドホックグループによる報告書」 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KNUTH] Knuth, D., &#34;The Art of Computer Programming&#34;, Volume 2: Seminumerical Algorithms, Chapter 3: Random Numbers, Addison-Wesley Publishing Company, 3rd Edition, November 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[クヌース]クヌース、D.、「コンピュータプログラミングの芸術」、第2巻：Seminumericalアルゴリズム、第3章：乱数、アディソン・ウェズリー出版社、第3版、1997年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KRAWCZYK] Krawczyk, H., &#34;How to Predict Congruential Generators&#34;, Journal of Algorithms, V. 13, N. 4, December 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;合同ジェネレータを予測する方法&#34; [KRAWCZYK] Krawczyk、H.、アルゴリズム、V. 13誌、N. 4、1992年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[LUBY] Luby, M., &#34;Pseudorandomness and Cryptographic Applications&#34;, Princeton University Press, ISBN 0691025460, 8 January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ルビー]ルビー、M.、 &#34;Pseudorandomnessおよび暗号アプリケーション&#34;、プリンストン大学プレス、ISBN 0691025460、1996年1月8日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PEM1] Linn, J., &#34;Privacy Enhancement for Internet Electronic Mail: Part I: Message Encryption and Authentication Procedures&#34;, RFC 1421, February 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PEM1]リン、J.、 &#34;インターネット電子メールのためのプライバシー増進：パートI：メッセージの暗号化と認証手順&#34;、RFC 1421、1993年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PEM2] Kent, S., &#34;Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management&#34;, RFC 1422, February 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PEM2]ケント、S.、 &#34;インターネット電子メールのためのプライバシー増進：パートII：証明書ベースのキー管理&#34;、RFC 1422、1993年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PEM3] Balenson, D., &#34;Privacy Enhancement for Internet Electronic Mail: Part III: Algorithms, Modes, and Identifiers&#34;, RFC 1423, February 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PEM3] Balenson、D.、 &#34;インターネット電子メールのためのプライバシー増進：パートIII：アルゴリズム、モード、および識別子&#34;、RFC 1423、1993年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PEM4] Kaliski, B., &#34;Privacy Enhancement for Internet Electronic Mail: Part IV: Key Certification and Related Services&#34;, RFC 1424, February 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PEM4] Kaliski、B.、 &#34;インターネット電子メールのためのプライバシー増進：パートIV：キー認証と関連サービス&#34;、RFC 1424、1993年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PGP1] Callas, J., Donnerhacke, L., Finney, H., and R. Thayer, &#34;OpenPGP Message Format&#34;, RFC 2440, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【MAIL_PGP1]カラス、J.、Donnerhacke、L.、フィニー、H.、およびR.セイヤー、 &#34;OpenPGPのメッセージフォーマット&#34;、RFC 2440、1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PGP2] Elkins, M., Del Torto, D., Levien, R., and T. Roessler, &#34;MIME Security with OpenPGP&#34;, RFC 3156, August 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MAIL_PGP2]エルキンズ、M.、デルTorto、D.、Levien、R.、およびT.レスラー、 &#34;OpenPGPの持つMIMEセキュリティ&#34;、RFC 3156、2001年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[S/MIME] RFCs 2632 through 2634:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[S / MIME]のRFC 2634を介して2632：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   Ramsdell, B., &#34;S/MIME Version 3 Certificate
                   Handling&#34;, RFC 2632, June 1999.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ramsdell, B., &#34;S/MIME Version 3 Message Specification&#34;, RFC 2633, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ramsdell、B.、 &#34;S / MIMEバージョン3メッセージ仕様&#34;、RFC 2633、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hoffman, P., &#34;Enhanced Security Services for S/MIME&#34;, RFC 2634, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホフマン、P.、 &#34;S / MIMEのためのセキュリティサービスの強化&#34;、RFC 2634、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MD4] Rivest, R., &#34;The MD4 Message-Digest Algorithm&#34;, RFC 1320, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MD4]リベスト、R.、 &#34;MD4メッセージダイジェストアルゴリズム&#34;、RFC 1320、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MD5] Rivest, R., &#34;The MD5 Message-Digest Algorithm &#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MD5] Rivest氏、R.、 &#34;MD5メッセージダイジェストアルゴリズム&#34;、RFC 1321、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MODES] &#34;DES Modes of Operation&#34;, US National Institute of Standards and Technology, FIPS 81, December 1980. Also: &#34;Data Encryption Algorithm - Modes of Operation&#34;, American National Standards Institute, ANSI X3.106-1983.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MODES]「動作のDESモード」、米国立標準技術研究所、また12月1980年、81 FIPS：「データ暗号化アルゴリズム - 動作種別」、米国規格協会、ANSI X3.106-1983。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MOORE] Moore&#39;s Law: the exponential increase in the logic density of silicon circuits. Originally formulated by Gordon Moore in 1964 as a doubling every year starting in 1962, in the late 1970s the rate fell to a doubling every 18 months and has remained there through the date of this document. See &#34;The New Hacker&#39;s Dictionary&#34;, Third Edition, MIT Press, ISBN 0-262-18178-9, Eric S. Raymond, 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MOORE]ムーアの法則：シリコン回路のロジック密度が指数関数的に増加します。 1962年から毎年倍増としてもともと1964年にゴードン・ムーアによって策定、1970年代後半に率は18カ月ごとに倍増に落ちたし、この文書の日付、そこを通って推移しています。 MITプレス、ISBN 0-262-18178-9、エリック・レイモンド、1996年、第3版、「新しいハッカーの辞書」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[NASLUND] Naslund, M. and A. Russell, &#34;Extraction of Optimally Unbiased Bits from a Biased Source&#34;, IEEE Transactions on Information Theory. 46(3), May 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【NASLUND] Naslund、M.及びA.ラッセルは、「偏ったソースから最適不偏ビットの抽出」、情報理論に関するIEEEトランザクション。 46（3）、2000年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ORMAN] Orman, H. and P. Hoffman, &#34;Determining Strengths For Public Keys Used For Exchanging Symmetric Keys&#34;, BCP 86, RFC 3766, April 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[オーマン]オーマン、H.、およびP.ホフマンは、BCP 86、RFC 3766、2004年4月「対称鍵を交換するために使用公開鍵の強さを測定します」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1750] Eastlake 3rd, D., Crocker, S., and J. Schiller, &#34;Randomness Recommendations for Security&#34;, RFC 1750, December 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1750]イーストレーク第3、D.、クロッカー、S.、およびJ.シラー、 &#34;セキュリティのためのランダム性に関する推奨事項&#34;、RFC 1750、1994年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1948] Bellovin, S., &#34;Defending Against Sequence Number Attacks&#34;, RFC 1948, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1948] Bellovin氏、S.、 &#34;シーケンス番号攻撃からの保護&#34;、RFC 1948、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 &#34;HMAC：メッセージ認証のための鍵付きハッシュ化&#34;、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RSA_BULL1] &#34;Suggestions for Random Number Generation in Software&#34;, RSA Laboratories Bulletin #1, January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RSA_BULL1]「ソフトウェアにおける乱数発生のための提案」、RSA研究所会報第1位、1996年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RSA_BULL13] Silverman, R., &#34;A Cost-Based Security Analysis of Symmetric and Asymmetric Key Lengths&#34;, RSA Laboratories Bulletin #13, April 2000 (revised November 2001).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RSA_BULL13]シルバーマン、R.、「対称および非対称キーの長さのコストベースのセキュリティ分析」、RSA研究所速報＃13、2000年4月（2001年11月改訂します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SBOX1] Mister, S. and C. Adams, &#34;Practical S-box Design&#34;, Selected Areas in Cryptography, 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SBOX1]ミスター、S.とC.アダムス、 &#34;実用的なS-ボックスのデザインは&#34;、暗号化、1996年に地域を選択しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SBOX2] Nyberg, K., &#34;Perfect Non-linear S-boxes&#34;, Advances in Cryptography, Eurocrypt &#39;91 Proceedings, Springer-Verland, 1991.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SBOX2]ニベルグ、K.、 &#34;パーフェクトノンリニアSボックス&#34; には、暗号化、EUROCRYPT &#39;91会報、スプリンガー・Verland、1991年に進めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SCHNEIER] Schneier, B., &#34;Applied Cryptography: Protocols, Algorithms, and Source Code in C&#34;, 2nd Edition, John Wiley &amp; Sons, 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SCHNEIER]シュナイアー、B.、 &#34;応用暗号：Cでのプロトコル、アルゴリズム、およびソースコード&#34;、第2版、John Wiley＆Sons、1996。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHANNON] Shannon, C., &#34;The Mathematical Theory of Communication&#34;, University of Illinois Press, 1963. Originally from: Bell System Technical Journal, July and October, 1948.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHANNON]シャノン、C.、「通信の数学的理論」、イリノイプレス、1963年の大学もともとから：ベルシステムテクニカルジャーナル、7月と10月、1948。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHIFT1] Golub, S., &#34;Shift Register Sequences&#34;, Aegean Park Press, Revised Edition, 1982.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHIFT1]ゴラブ、S.、エーゲ海公園プレス、改訂版、1982年を &#34;登録シーケンスをシフト&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHIFT2] Barker, W., &#34;Cryptanalysis of Shift-Register Generated Stream Cypher Systems&#34;, Aegean Park Press, 1984.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHIFT2]バーカー、W.、エーゲ海公園プレス、1984年「シフトレジスタの解読は、ストリームサイファーシステムの生成しました」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHA] &#34;Secure Hash Standard&#34;, US National Institute of Science and Technology, FIPS 180-2, 1 August 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHA]、科学技術の米国国立研究所、FIPS 180-2、2002年8月1日「ハッシュ標準セキュア」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHA_RFC] Eastlake 3rd, D. and P. Jones, &#34;US Secure Hash Algorithm 1 (SHA1)&#34;, RFC 3174, September 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHA_RFC]イーストレーク第3、D.とP.ジョーンズは、 &#34;米国は、ハッシュアルゴリズム1（SHA1）を確保&#34;、RFC 3174、2001年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SSH] Products of the SECSH Working Group, Works in Progress, 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SSH] SECSHワーキンググループの製品、進歩、2005年に動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[STERN] Stern, J., &#34;Secret Linear Congruential Generators are not Cryptographically Secure&#34;, Proc. IEEE STOC, 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【STERN]スターン、J.、PROC「秘密線形合同発生器は、暗号的に安全ではありません」。 IEEE STOC、1987。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLS] Dierks, T. and C. Allen, &#34;The TLS Protocol Version 1.0&#34;, RFC 2246, January 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLS]ダークス、T.とC.アレン、 &#34;TLSプロトコルバージョン1.0&#34;、RFC 2246、1999年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TURBID] Denker, J., &#34;High Entropy Symbol Generator&#34;, &lt;http://www.av8n.com/turbid/paper/turbid.htm&gt;, 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【TURBID] Denker、J.、 &#34;高エントロピーシンボルジェネレータ&#34;、&lt;http://www.av8n.com/turbid/paper/turbid.htm&gt;、2003年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[USENET_1] Kantor, B. and P. Lapsley, &#34;Network News Transfer Protocol&#34;, RFC 977, February 1986.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[USENET_1]カンター、B.およびP.ラプスリー、 &#34;ネットワークニュース転送プロトコル&#34;、RFC 977、1986年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[USENET_2] Barber, S., &#34;Common NNTP Extensions&#34;, RFC 2980, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[USENET_2]バーバー、S.、 &#34;共通NNTP拡張機能&#34;、RFC 2980、2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[VON_NEUMANN] Von Nuemann, J., &#34;Various techniques used in connection with random digits&#34;, Von Neumann&#39;s Collected Works, Vol. 5, Pergamon Press, 1963.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【ノイマン]フォンノイマン、J.、「ランダムな数字に関連して使用される様々な技術」、フォンノイマンの収集作品集。 5、ペルガモンプレス、1963。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[WSC] Howard, M. and D. LeBlanc, &#34;Writing Secure Code, Second Edition&#34;, Microsoft Press, ISBN 0735617228, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[WSC]ハワード、M.とD.ルブラン、 &#34;セキュアなコードの記述、第2版&#34;、マイクロソフトプレス、ISBN 0735617228、2002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X9.17] &#34;American National Standard for Financial Institution Key Management (Wholesale)&#34;, American Bankers Association, 1985.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X9.17]「金融機関キー管理のための米国標準規格（卸売）」、アメリカの銀行協会、1985。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X9.82] &#34;Random Number Generation&#34;, American National Standards Institute, ANSI X9F1, Work in Progress. Part 1 - Overview and General Principles. Part 2 - Non-Deterministic Random Bit Generators Part 3 - Deterministic Random Bit Generators
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X9.82]「乱数発生」、米国規格協会、ANSI X9F1、進行中の作業。パート1  - 概要と一般原則。パート2  - 非決定性ランダムビットジェネレータパート3  - 決定論的ランダムビットジェネレータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Donald E. Eastlake 3rd Motorola Laboratories 155 Beaver Street Milford, MA 01757 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドナルドE.イーストレーク第3モトローラ研究所155ビーバー通りミルフォード、MA 01757 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 508-786-7554 (w) +1 508-634-2066 (h) EMail: Donald.Eastlake@motorola.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 508-786-7554（W）+1 508-634-2066（H）メール：Donald.Eastlake@motorola.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jeffrey I. Schiller MIT, Room E40-311 77 Massachusetts Avenue Cambridge, MA 02139-4307 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジェフリーI.シラーMIT、ルームE40-311 77マサチューセッツアベニューケンブリッジ、MA 02139から4307 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 617-253-0161 EMail: jis@mit.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 617-253-0161電子メール：jis@mit.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Steve Crocker
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スティーブクロッカー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: steve@stevecrocker.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：steve@stevecrocker.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2005）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
