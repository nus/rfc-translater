<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 2490 - A Simulation Model for IP Multicast with RSVP 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 2490 - A Simulation Model for IP Multicast with RSVP 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc2490">
              https://tools.ietf.org/html/rfc2490
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 2490 - RSVPとIPマルチキャストのためのシミュレーションモデル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                         M. Pullen
Request for Comments: 2490                      George Mason University
Category: Informational                                      R. Malghan
                                                   Hitachi Data Systems
                                                                L. Lavu
                                                           Bay Networks
                                                                G. Duan
                                                                 Oracle
                                                                  J. Ma
                                                              NewBridge
                                                                 H. Nah
                                                George Mason University
                                                           January 1999
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             A Simulation Model for IP Multicast with RSVP
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（1999）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes a detailed model of IPv4 multicast with RSVP that has been developed using the OPNET simulation package [4], with protocol procedures defined in the C language. The model was developed to allow investigation of performance constraints on routing but should have wide applicability in the Internet multicast/resource reservation community. We are making this model publicly available with the intention that it can be used to provide expanded studies of resource-reserved multicasting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、C言語で定義されたプロトコル手順と、[4] OPNETシミュレーションパッケージを使用して開発されたRSVPとのIPv4マルチキャストの詳細なモデルを記載しています。このモデルは、ルーティングの性能制約の調査を可能にするために開発されたが、インターネットマルチキャスト/リソース予約コミュニティの幅広い適用性を持っている必要があります。我々は、資源予約マルチキャストの拡大研究を提供するために使用することができることを意図して、このモデルは一般に入手可能な作っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Background 2 2. The OPNET Simulation Environment 3 3. IP Multicast Model 3 3.1 Address Format 3 3.2 Network Layer 4 3.3 Node layer 5 4. RSVP Model 13 4.1 RSVP Application 13
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.背景2 2. OPNETシミュレーション環境3 3. IPマルチキャストモデル3つの3.1アドレス形式3 3.2ネットワーク層4 3.3ノード層5 4 RSVPモデル13 4.1 RSVPアプリケーション13
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 4.2 RSVP on Routers 14 4.3 RSVP on Hosts 17 5. Multicast Routing Model Interface 19 5.1 Creation of multicast routing processor node 19 5.2 Interfacing processor nodes 19 5.3 Interrupt Generation 21 5.4 Modifications of modules in the process model 22 6. OSPF and MOSPF Models 23 6.1 Init 23 6.2 Idle 23 6.3 BCOspfLsa 23 6.4 BCMospfLsa 23 6.5 Arr 23 6.6 Hello_pks 24 6.7 Mospfspfcalc 24 6.8 Ospfspfcalc 25 6.9 UpstrNode 25 6.10 DABRA 25 7. DVMRP Model 26 7.1 Init 26 7.2 Idle 26 7.3 Probe_Send State 26 7.4 Report_Send 26 7.5 Prune _Send 26 7.6 Graft_send 27 7.7 Arr_Pkt 27 7.8 Route_Calc 28 7.9 Timer 28 8. Simulation performance 28 9. Future Work 29 10. Security Considerations 29 11. References 29 Authors&#39; Addresses 30 Full Copyright Statement 31
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホスト上のルータ14 4.3 RSVP 4.2 RSVP 17 5マルチキャストルーティングモデルインターフェイス19マルチキャストルーティング・プロセッサ・ノードプロセスモデルのモジュールの19の5.2インタフェースのプロセッサノード19 5.3割り込み生成21の5.4変形例22 6 OSPFとMOSPFモデル23を5.1作成6.1初期23 6.2アイドル23 6.3 BCOspfLsa 23 6.4 BCMospfLsa 23 6.5 6.10 UpstrNode 25 6.9 Ospfspfcalc 25 6.8 Mospfspfcalc 24 6.6 Hello_pks 24 6.7 23編曲DABRA 25 7 DVMRPモデル26 7.1初期26 7.2アイドル26 7.3 Probe_Send状態26 7.4 26 7.5プルーンをReport_Send _Send 26 7.6 Graft_send 27 7.7 Arr_Pkt 27 7.8 Route_Calc 28 7.9タイマー28 8.シミュレーション性能28 9.今後の課題29の10.セキュリティの考慮事項29 11.参考文献29本の著者のアドレス30完全な著作権声明31
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.背景
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The successful deployment of IP multicasting [1] and its availability in the Mbone has led to continuing increase in real-time multimedia Internet applications. Because the Internet has traditionally supported only a best-effort quality of service, there is considerable interest to create mechanisms that will allow adequate resources to be reserved in networks using the Internet protocol suite, such that the quality of real-time traffic such as video, voice, and distributed simulation can be sustained at specified levels. The RSVP protocol [2] has been developed for this purpose and is the subject of ongoing implementation efforts. Although the developers of RSVP have used simulation in their design process, no simulation of IPmc with RSVP has been generally available for analysis of the performance and prediction of the behavior of these protocols. The simulation model described here was developed to fill this gap, and is explicitly intended to be made available to the IETF community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPマルチキャスト[1]とMBONEでその可用性の展開を成功は、リアルタイムのマルチメディア・インターネットアプリケーションの増加を継続的につながっています。インターネットは、伝統的にサービスの唯一のベストエフォート品質を支えてきたので、十分な資源が、インターネットプロトコルスイートを使用してネットワーク内に確保することを可能にする仕組みを作成するには、かなりの関心が寄せられているようなビデオなどのリアルタイムトラフィックの品質、音声、および分散シミュレーションは、指定されたレベルで維持することができます。 RSVPプロトコル[2]は、この目的のために開発され、継続的な実装努力の主題であるれています。 RSVPの開発者は、設計プロセスにシミュレーションを使用しているが、RSVPとIPマルチキャストのないシミュレーションは、これらのプロトコルの動作のパフォーマンスと予測分析のために一般的に利用されていません。ここで説明するシミュレーションモデルは、このギャップを埋めるために開発された、と明示的にIETFコミュニティに利用可能となることを意図しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. The OPNET Simulation Environment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. OPNETシミュレーション環境
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Optimized Network Engineering Tools (OPNET) is a commercial simulation product of the MIL3 company of Arlington, VA. It employs a Discrete Event Simulation approach that allows large numbers of closely-spaced events in a sizable network to be represented accurately and efficiently. OPNET uses a modeling approach where networks are built of components interconnected by perfect links that can be degraded at will. Each component&#39;s behavior is modeled as a state-transition diagram. The process that takes place in each state is described by a program in the C language. We believe this makes the OPNET-based models relatively easy to port to other modeling environments. This family of models is compatible with OPNET 3.5. The following sections describe the state-transition models and process code for the IPmc and RSVP models we have created using OPNET. Please note that an OPNET layer is not necessarily equivalent to a layer in a network stack, but shares with a stack layer the property that it is a highly modular software element with well defined interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最適化されたネットワークエンジニアリングツール（OPNET）アーリントン、バージニア州のMIL3会社の商用シミュレーション製品です。これは、かなりのネットワーク内の密集した事象の多数が正確かつ効率的に表現することを可能にする離散事象シミュレーションアプローチを採用しています。 OPNETは、ネットワークが意のままに分解することができる完璧なリンクによって相互接続コンポーネントで構築されているモデリング手法を使用しています。各コンポーネントの動作は状態遷移図としてモデル化されます。各状態で行われる処理は、C言語のプログラムで記述されます。これは、他のモデリング環境へのポートへのOPNETベースのモデルは、比較的容易になりますと信じています。モデルのこのファミリーは、OPNET 3.5と互換性があります。次のセクションでは、我々はOPNETを使用して作成したIPマルチキャストおよびRSVPモデルのための状態遷移モデルとプロセスのコードを記述します。 OPNET層は、必ずしもネットワークスタックにおける層と同等ではなく、スタックと共有は、それが明確に定義されたインタフェースを持つ高度にモジュールソフトウェア要素であるプロパティを階層ことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IP Multicast Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IPマルチキャストモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following processing takes place in the indicated modules. Each subsection below describes in detail a layer in the host and the router that can be simulated with the help of the corresponding OPNET network layer or node layer or the process layer, starting from physical layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の処理が示されたモジュールで行われます。以下の各節では、具体的に宿主中層と物理層から出発し、対応するOPNETネットワーク層またはノード層又は処理層の助けを借りてシミュレートすることができるルータを記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 Address format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1アドレスフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OPNET IP model has only one type of addressing denoted by &#34;X.Y&#34; where X is 24 bits long and Y is 8 bits long, corresponding to an IPv4 Class C network. The X indicates the destination or the source network number and Y indicates the destination or the source node number. In our model X = 500 is reserved for multicast traffic. For multicast traffic the value of Y indicates the group to which the packet belongs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPNET IPモデルは、Xは24ビット長であり、Yは、IPv4のクラスCのネットワークに対応する、8ビット長である「X.Y」で示されるアドレッシングの一種類のみを有しています。 Xは、宛先または送信元ネットワーク番号を示し、Yは、宛先または送信元ノード番号を示します。我々のモデルではX = 500、マルチキャストトラフィック用に予約されています。マルチキャストトラフィックのYの値は、パケットが属するグループを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Network Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2ネットワーク層
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1 describes an example network topology built using the OPNET network editor. This network consists of two backbone routers BBR1, BBR2, three area border routers ABR1, ABR2, ABR3 and six subnets F1, through F6. As OPNET has no full duplex link model, each connecting link is modeled as two simplex links enabling bidirectional traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1は、OPNETネットワークエディタを使用して構築されたネットワークトポロジの例を示します。このネットワークは、F6を介して2つのバックボーンルータBBR1、BBR2、3つのエリア境界ルータABR1、ABR2、ABR3と6つのサブネットF1、から構成されています。 OPNETは何の全二重リンクモデルを持っていないように、各接続リンクは双方向のトラフィックを有効にするシンプレックスリンクとしてモデル化されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 1: Network Layer of Debug Model]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[図1：デバッグモデルのネットワーク層]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1 Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The attributes of the elements of the network layer are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワーク層の要素の属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. Area Border Routers and Backbone Routers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。エリア境界ルータとバックボーンルータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. IP address of each active interface of each router (network_id.node_id) 2. Service rate of the IP layer (packets/sec) 3. Transmission speeds of each active interface (bits/sec)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ルータの各アクティブインタフェースの1 IPアドレス（network_id.node_id）IP層（パケット/秒）の2サービスレート各アクティブインタフェース（ビット/秒）の3伝送速度
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. Subnets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。サブネット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. IP address of each active interface of the router in the subnet 2. IP address of the hosts in each of the subnet. 3. Service rate of the IP layer in the subnet router and the hosts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サブネットの各々におけるホストのサブネット2 IPアドレスでルータの各アクティブインタフェースの1 IPアドレス。 3.サービスサブネットのルータのIP層の割合とホスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. Simplex links
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。シンプレクスリンク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Propagation delay in the links 2. The process model to be used for simulating the simplex links (this means whether animation is included or not).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シンプレックスリンクをシミュレートするために使用されるプロセス・モデル2リンク1.伝搬遅延（これはアニメーションが含まれているか否かを意味します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2 LAN Subnets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2 LANサブネット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 2 shows the FDDI ring as used in a subnet. The subnet will have one router and one or more hosts. The router in the subnet is included to route the traffic between the FDDI ring or Ethernet in the corresponding subnet and the external network. The subnet router is connected on one end to Ethernet or FDDI ring and normally also is connected to an area border router on another interface (the area border routers may be connected to more than one backbone router). In the Ethernet all the hosts are connected to the bus, while in FDDI the hosts are interconnected in a ring as illustrated in Figure 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図2は、サブネットで使用されるFDDIリングを示しています。サブネットは1つのルータと1台のまたは複数のホストを持つことになります。サブネット内のルータは、ルートにFDDIリングまたはイーサネット対応するサブネット内と外部ネットワークの間のトラフィックが含まれています。サブネット・ルータは、イーサネット又はFDDIリングの一端に接続され、通常、別のインターフェース（エリア境界ルータは複数のバックボーンルータに接続されていてもよい）上のエリア境界ルータに接続されています。図2に示すように、FDDIにホストがリングに相互接続されている間、イーサネット内のすべてのホストは、バスに接続されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 2: FDDI Ring Subnet Layer]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[図2：FDDIリングサブネット層]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
FDDI provides general purpose networking at 100 Mb/sec transmission rates for large numbers of communicating stations configured in a ring topology. Use of ring bandwidth is controlled through a timed token rotation protocol, wherein stations must receive a token and meet with a set of timing and priority criteria before transmitting frames. In order to accommodate network applications in which response times are critical, FDDI provides for deterministic availability of ring bandwidth by defining a synchronous transmission service. Asynchronous frame transmission requests dynamically share the remaining ring bandwidth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FDDIは、リングトポロジで構成された局を通信の多数のために100メガビット/秒の伝送速度で汎用ネットワークを提供します。リング帯域幅の使用は、ステーションはトークンを受信し、フレームを送信する前に、タイミング及び優先基準のセットに満たさなければならない、請求タイミングトークン回転プロトコルを介して制御されます。応答時間が重要である、ネットワークアプリケーションに対応するために、FDDIは同期伝送サービスを定義することによって、リング帯域幅の決定論的可用性を提供します。非同期フレーム送信要求が動的に残りの環帯域幅を共有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ethernet is a bus-based local area network (LAN) technology. The operation of the LAN is managed by a media access protocol (MAC) following the IEEE 802.3 standard, providing Carrier Sense Multiple Access with Collision Detection (CSMA/CD) for the LAN channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
イーサネットはバスベースのローカルエリアネットワーク（LAN）の技術です。 LANの操作は、LANチャネルの衝突検出（CSMA / CD）との搬送波感知多重アクセスを提供し、IEEE 802.3標準以下のメディアアクセスプロトコル（MAC）によって管理されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 Node layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3ノード膜
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section discusses the internal structure of hosts and routers with the help of node level illustrations built using the Node editor of OPNET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、OPNETのノードエディタを使用して構築されたノードレベルイラストの助けを借りて、ホストとルータの内部構造について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1 Basic OPNET elements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1基本的な要素OPNET
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The basic elements of a node level illustration are
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ノード・レベルの図の基本的な要素であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. Processor nodes: Processor nodes are used for processing incoming packets and generating packets with a specified packet format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。プロセッサノード：プロセッサノードは、着信パケットを処理し、指定されたパケットフォーマットのパケットを生成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. Queue node: Queue nodes are a superset of processor nodes. In addition to the capabilities of processor nodes, queue nodes also have capability to store packets in one or more queues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。キューノード：キューノードはプロセッサノードの上位集合です。プロセッサノードの機能に加えて、キュー・ノードは、1つ以上のキューにパケットを格納する機能を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. Transmitter and Receiver nodes: Transmitters simulate the link behavior effect of packet transmission and Receivers simulate the receiving effects of packet reception. The transmission rate is an attribute of the transmitter and receiving rate is an attribute of the receiver. These values together decide the transmission delay of a packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。送信機と受信機ノード：トランスミッタは、パケット伝送のリンクの挙動効果をシミュレートし、受信機は、パケット受信の受信効果をシミュレートします。伝送速度は、送信機の属性であり、速度を受信する受信装置の属性です。これらの値は、一緒に、パケットの伝送遅延を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. Packet streams: Packet streams are used to interconnect the above described nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。パケットストリーム：パケットストリームは、上述したノードを相互接続するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
e. Statistic streams: Statistic streams are used to convey information between the different nodes: Processor, Queue, Transmitters and Receivers nodes respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電子。統計ストリーム：統計ストリームは、異なるノード間で情報を伝達するために使用されている：プロセッサ、キュー、トランスミッタとレシーバは、それぞれノード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2 Host description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2ホストの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The host model built using OPNET has a layered structure. Different from the OPNET layers (Network, Node and Process layer) that describe the network at different levels, protocol stack elements are implemented at OPNET nodes. Figure 3 shows the node level structure of a FDDI host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPNETを使用して構築されたホストモデルは、層状構造を有しています。異なるレベルでネットワークを記述するOPNET層（ネットワーク、ノード、およびプロセス層）とは異なる、プロトコルスタック要素はOPNETノードにおいて実施されます。図3は、FDDIホストのノードレベルの構造を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 3: Node Level of Host]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[図3：ホストのノードレベル]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. MAC queue node: The MAC interfaces on one side to the physical layer through the transmitter (phy_tx) and receiver (phy_rx) and also provides services to the IP layer. Use of ring bandwidth is controlled through a timed token rotation protocol, wherein hosts must receive a token and meet with a set of timing and priority criteria before transmitting frames. When a frame arrives at the MAC node, the node performs one of the following actions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 MACキューノード送信機（phy_tx）と受信機（phy_rx）を介して物理層に片側のMACインターフェースとは、IP層にサービスを提供します。リング帯域幅の使用は、ホストは、トークンを受信して​​フレームを送信する前に、タイミング及び優先基準のセットに満たさなければならない、請求タイミングトークン回転プロトコルを介して制御されます。フレームは、MACノードに到着すると、ノードは、次のいずれかのアクションを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. If the owner of the frame is this MAC, the MAC layer destroys the frame since the frame has finished circulating through the FDDI ring. 2. if the frame is destined for this host, the MAC layer makes a copy of the frame, decapsulates the frame and sends the descapsulated frame (packet) to the IP layer. The original frame is transmitted to the next host in the FDDI ring 3. if the owner of the frame is any other host and the frame is not destined for this host, the frame is forwarded to the adjacent host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1フレームの所有者は、このMACフレームの場合は、FDDIリングを循環終了したため、MAC層は、フレームを破壊します。 2.フレームは、このホスト宛てされている場合、MAC層は、フレームのコピーを作成し、フレームのカプセル化を解除し、IP層にdescapsulatedフレーム（パケット）を送信します。フレームの所有者が他のホストであり、フレームがこのホスト宛てされていない場合、元のフレームは、FDDIリング3内の次のホストに送信され、フレームは、隣接するホストに転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. ADDR_TRANS processor node: The next layer above the MAC layer is the addr_trans processor node. This layer provides service to the IP layer by carrying out the function of translating the IP address to physical interface address. This layer accepts packets from the IP layer with the next node information, maps the next node information to a physical address and forwards the packet for transmission. This service is required only in one direction from the IP layer to the MAC layer. Since queuing is not done at this level, a processor node is used to accomplish the address translation function, from IP to MAC address (ARP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。 ADDR_TRANSプロセッサ・ノード：MAC層の上次の層はaddr_transプロセッサ・ノードです。この層は、物理インタフェースアドレスにIPアドレスを変換する機能を実行することにより、IP層にサービスを提供します。この層は、次のノード情報をIPレイヤからパケットを受け入れ、物理アドレスに次のノード情報をマッピングして、送信用のパケットを転送します。このサービスは、IP層からMAC層に一方向のみに必要とされます。キューイングは、このレベルで行われていないので、プロセッサ・ノードは、IPからMACアドレス（ARP）に、アドレス変換機能を達成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. IP queue node: Network routing/forwarding in the hierarchy is implemented here. IP layer provides service for the layers above which are the different higher level protocols by utilizing the services provided by the MAC layer. For packets arriving from the MAC layer, the IP layer decapsulates the packet and forwards the information to an upper layer protocol based upon the value of the protocol ID in the IP header. For packets arriving from upper layer protocols, the IP layer obtains the destination address, calculates the next node address from the routing table, encapsulates it with a IP header and forwards the packet to the addr_trans node with the next node information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。 IPキューノード：階層内のネットワークルーティング/転送がここに実装されています。 IP層は、MAC層が提供するサービスを利用することによって、異なる、より高いレベルのプロトコルである上記の層のためのサービスを提供します。 MACレイヤから到着するパケットについては、IPレイヤは、パケットをデカプセル化し、IPヘッダのプロトコルIDの値に基づいて、上位レイヤプロトコルに情報を転送します。上位層プロトコルから到着するパケットについては、IPレイヤは、宛先アドレスを取得するルーティングテーブルから次のノードのアドレスを計算し、IPヘッダとそれをカプセル化し、次のノード情報をaddr_transノードにパケットを転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IP node is a queue node. It is in this layer that packets incur delay which simulates the processing capability of a host and queueing for use of the outgoing link. A packet arrival to the IP layer will be queued and experience delay when it finds another packet already being transmitted, plus possibly other packets queued for transmission. The packets arriving at the IP layer are queued and operate with a first-in first-out (FIFO) discipline. The queue size, service rate of the IP layer are both promoted attributes, specified at the simulation run level by the environment file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPノードは、キューノードです。これは、パケットがホストの処理能力をシミュレート遅延と発信リンクの使用のためにキューイングを負うこの層です。 IP層へのパケットの到着は、キューに入れられ、経験の遅延、それは別のパケットが既に送信されて発見したとき、プラスおそらく他のパケットを送信するためにキューに入れられます。 IPレイヤに到着するパケットはキューに入れられ、先入れ先出し（FIFO）規律で動作しています。キューサイズ、IPレイヤのサービス率は、両方の環境ファイルで、シミュレーションの実行レベルで指定された属性を、推進しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. IGMP processor node: The models described above are standard components available in OPNET libraries. We have added to these the host multicast protocol model IGMP_host, the router multicast model IGMP_gwy, and the unicast best-effort protocol model UBE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。 IGMPプロセッサ・ノード：上述のモデルは、OPNETライブラリで利用可能な標準的な構成要素です。我々は、これらのホストのマルチキャストプロトコルモデルIGMP_host、ルータのマルチキャストモデルIGMP_gwy、およびユニキャストのベストエフォート型プロトコルモデルUBEに追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IGMP_host node (Figure 4) is a process node. Packets are not queued in this layer. IGMP_host provides unique group management services for the multicast applications utilizing the services provided by the IP layer. IGMP_host maintains a single table which consists of group membership information of the application above the IGMP layer. The function performed by the IGMP_host layer depends upon the type of the packet received and the source of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IGMP_hostノード（図4）は、プロセス・ノードです。パケットは、この層にキューイングされていません。 IGMP_hostは、IP層が提供するサービスを利用したマルチキャストアプリケーションのためのユニークなグループ管理サービスを提供しています。 IGMP_hostはIGMP層の上のアプリケーションのグループ・メンバーシップ情報から成る単一のテーブルを維持します。 IGMP_host層によって実行される機能は、受信したパケットの種類とパケットの送信元に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 4: IGMP process on hosts]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[図4：ホスト上でIGMP処理]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IGMP_host layer expects certain type of packets from the application layer and from the network:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IGMP_host層は、アプリケーション層から、ネットワークからのパケットの特定のタイプを期待します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Accept join group requests from the application layer (which can be one or more applications): IGMP_host maintains a table which consists of the membership information for each group. When a application sends a join request, it requests to join a specific group N. The membership information is updated. This new group membership information has to be conveyed to the nearest router and to the MAC layer. If the IGMP_host is already a member ofthis group (i.e. if another application above the IGMP_host is a member of the group N), the IGMP_host does not have to send a message to the router or indicate to the MAC layer. If the IGMP_host is not a member currently, the IGMP_host generates a join request for the group N (this is called a &#34;response&#34; in RFC 1112) and forwards it to the IP layer to be sent to the nearest router. In addition the IGMP_host also conveys this membership information to the MAC layer interfacing to the physical layer through the OPNET &#34;statistic wire&#34; connected from the IGMP_host to the MAC layer, so that the MAC layer knows the membership information immediately and begins to accept the frames destined for the group N. (An OPNET statistic wire is a virtual path to send information between OPNET models.) 2. Accept queries arriving from the nearest router and send responses based on the membership information in the multicast table at the IGMP_host layer: A query is a message from a router inquiring each host on the router&#39;s interface about group membership information. When the IGMP_host receives a query, it looks up the multicast group membership table, to determine if any of the host&#39;s applications are registered for any group. If any registration exists, the IGMP_host schedules an event to generate a response after a random amount of time corresponding to each active group. The Ethernet example in Figure 5 and the description in the following section describes the scenario.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.（1つまたは複数のアプリケーションとすることができる）は、アプリケーション層からのグループ参加要求を受け入れる：IGMP_hostは、各グループのメンバーシップ情報で構成テーブルを維持します。アプリケーションは、参加要求を送信すると、それはメンバーシップ情報が更新された特定のグループN.への参加を要請します。この新しいグループメンバーシップ情報は、最寄りのルータおよびMAC層に伝達する必要があります。 IGMP_hostは既にグループofthisメンバである場合（IGMP_host上記他のアプリケーションがグループNのメンバーである場合、すなわち）、IGMP_hostルータにメッセージを送信したり、MAC層に指示する必要がありません。 IGMP_hostは現在メンバーでない場合、IGMP_hostは、グループNのための参加要求を生成する（これは、RFC 1112で「応答」と呼ぶ）と最も近いルータに送信するIP層に転送します。 MAC層は、直ちに会員情報を知っていて、フレームを受け入れ始めるように加えIGMP_hostはまた、MAC層にIGMP_hostから接続OPNET「統計線」を介して物理層インターフェースMAC層にこのメンバーシップ情報を伝えますグループN.宛て（OPNET統計ワイヤはOPNETモデルとの間で情報を送信するための仮想パスである。）2.最も近いルータから到着するクエリを受け入れIGMP_host層におけるマルチキャストテーブル内の会員情報に基づいて、応答を送信する：Aクエリは、グループメンバーシップ情報についてルータのインターフェイス上の各ホストを問い合わせるルータからのメッセージです。 IGMP_hostがクエリを受信すると、ホストのアプリケーションのいずれかが任意のグループのために登録されているかどうかを判断するために、マルチキャストグループメンバーシップテーブルを検索します。任意の登録が存在する場合、IGMP_hostスケジュールイベントは、アクティブな各グループに対応するランダムな時間後に応答を生成します。図5および以下のセクションの説明ではイーサネット（登録商標）の例では、シナリオを記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   ---------------------------------------
                        |        |         |         |
                        |        |         |         |
                      +---+    +---+     +---+     +---+
                      | H1|    | H2|     | H3|     | R |
                      +---+    +---+     +---+     +---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 5: An Ethernet example of IGMP response schedule
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図5：IGMP応答スケジュールのイーサネット例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The router R interfaces with the subnet on one interface I1 and to reach the hosts. To illustrate this let us assume that hosts H1 and H3 are members of group N1 and H2 is a member of group N2. When the router sends a query, all the hosts receive the query at the same time t0. IGMP_host in H1 schedules an event to generate a response at a randomly generated time t1 (t1 &gt;= t0) which will indicate the host H1 is a member of group N1. Similarly H2 will schedule an event to generate a response at t2 (t2 &gt;= t0)to indicate membership in group N2 and H3 at t3 (t3 &gt;= t0) to indicate membership in group N3. When the responses are generated, the responses are sent with destination address set to the multicast group address. Thus all member hosts of a group will receive the responses sent by the other hosts in the subnet who are members of the same group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1つのインターフェースI1およびホストに到達するために、サブネットとルータRインターフェイス。これは私たちがH1とH3は、グループN1とH2のメンバーであるホストと仮定する説明するためにグループN2のメンバーです。ルータがクエリーを送信すると、すべてのホストが同じ時刻t0に問い合わせを受けます。 H1スケジュールでIGMP_hostホストH1は、グループN1のメンバーであることを示すであろうランダムに生成された時間T1（T1&gt; = T0）での応答を生成するイベント。同様H2は、グループN3のメンバーシップを示すために、T3（T3&gt; = T0）にグループN2およびH3におけるメンバーシップを示すために、T2（T2&gt; = T0）で応答を生成するためにイベントをスケジュールします。応答が生成されると、応答は、マルチキャストグループアドレスに設定された宛先アドレスに送信されます。したがって、グループのすべてのメンバーのホストは、同じグループのメンバーであるサブネット内の他のホストによって送信された応答を受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 In the above example if t1 &lt; t3, IGMP_host in H1 will generate a response to update the membership in group N1 before H3 does and H3 will also receive this response in addition to the router. When IGMP_host in H3 receives the response sent by H1, IGMP_host in H3 cancels the event scheduled at time t3, since a response for that group has been sent to the router. To make this work, the events to generate response to queries are scheduled randomly, and the interval for scheduling the above described event is forced to be less than the interval at which router sends the queries. 3. Accept responses sent by the other hosts in the subnet if any application layer is a member of the group to which the packet is destined. 4. Accept terminate group requests from the Application layer. These requests are generated by application layer when a application decides to leave a group. The IGMP_host updates the group information table and subsequently will not send any response corresponding to this group (unless another application is a member of this group). When a router does not receive any response for a group in certain amount of time on a specific interface, membership of that interface is canceled in that group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T1 &lt;T3の場合は、上記の例では、H1でIGMP_hostはH3が行う前に、グループN1におけるメンバーシップを更新するとH3は、ルータに加えて、この応答を受信する応答を生成します。 H3でIGMP_hostはH1によって送信された応答を受信すると、そのグループの応答がルータに送信されてきたことから、H3でIGMP_hostは、時刻t3でスケジュールされたイベントをキャンセルします。この作業を行うには、クエリへの応答を生成するためのイベントがランダムに予定されている、上述したイベントをスケジュールするための間隔は、ルータがクエリーを送信する間隔よりも小さいことを余儀なくされます。任意のアプリケーション層パケットが宛てられたグループのメンバーである場合3サブネット内の他のホストによって送信された応答を受け入れます。 4.アプリケーション層からのグループ要求を終了受け入れます。これらの要求は、アプリケーションがグループから脱退することを決定したときに、アプリケーション層によって生成されています。 IGMP_hostは、グループ情報テーブルを更新し、続いて（他のアプリケーションがこのグループのメンバでない限り）、このグループに対応する任意の応答を送信しません。ルータが特定のインターフェイス上の特定の時間にグループのいずれかの応答を受信しない場合には、そのインターフェイスのメンバーシップは、そのグループにキャンセルされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
e. Unicast best-effort (UBE) processor node: This node is used to generate a best effort traffic in the Internet based on the User Datagram Protocol (UDP). The objective of this node is to model the background traffic in a network. This traffic does not use the services provided by RSVP. UBE node aims to create the behaviors observed in a network which has one type of application using the services provided by RSVP to achieve specific levels of QoS and the best effort traffic which uses the services provided by only the underlying IP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電子。ユニキャストベストエフォート（UBE）のプロセッサ・ノード：このノードはユーザーデータグラムプロトコル（UDP）に基づいて、インターネットでのベストエフォートトラフィックを生成するために使用されます。このノードの目的は、ネットワーク内のバックグラウンドトラフィックをモデル化することです。このトラフィックは、RSVPによって提供されるサービスを使用していません。 UBEノードは、1つのQoSの特定のレベルを達成するためにRSVPが提供するサービスを使用するアプリケーションの種類とだけ基本的なIPが提供するサービスを利用するベストエフォートトラフィックを持つネットワークで観測さ振る舞いを作成することを目指しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The UBE node generates traffic to a randomly generated IP address so as to model competing traffic in the network from applications such as FTP. The packets generated are sent to the IP layer which routes the packet based upon the information in the routing table. The attributes of the UBE node are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FTPなどのアプリケーションからネットワークで競合トラフィックをモデル化するようにUBEノードは、ランダムに生成されたIPアドレスへのトラフィックを生成します。生成されたパケットは、パケットがルーティングテーブル内の情報に基づいてルートIPレイヤに送信されます。 UBEノードの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Session InterArrival Time (IAT): is the variable used to schedule an event to begin a session. The UBE node generates an exponentially distributed random variable with mean Session IAT and begins to generate data traffic at that time. 2. Data IAT: When the UBE generates data traffic, the interarrival times between data packets is Data IAT. A decrease in the value of Data IAT increases the severity of congestion in the network. 3. Session-min and Session-max: When the UBE node starts generating data traffic it remains in that session for a random period which is uniformly distributed between Session-min and Session-max.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.セッション間時間（IAT）は：セッションを開始するイベントをスケジュールするために使用される変数です。 UBEノードは、平均セッションIATに対して指数関数的に分布する確率変数を生成し、その時点でデータ・トラフィックを生成し始めます。 2.データIAT：UBEは、データトラフィックを生成すると、データパケット間のinterarrival回データIATです。データIATの値の減少は、ネットワークの輻輳の重大度を増加させます。 3.セッション分とセッション-MAX：UBEノードは、データ・トラフィックの生成を開始するとき、それは均一セッション分とセッション-maxの間で分散されるランダムな期間、そのセッションに留まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
f. Multicast Application processor node: The application layer consists of one or more application nodes which are process nodes. These nodes use the services provided by lower layer protocols IGMP, RSVP and IP. The Application layer models the requests and traffic generated by Application layer programs. Attributes of the application layer are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F。マルチキャストアプリケーションプロセッサノード：アプリケーション層は、プロセス・ノードである1つ以上のアプリケーションノードから成ります。これらのノードは、下位層のプロトコルのIGMP、RSVPとIPが提供するサービスを使用しています。アプリケーション層モデルのアプリケーション層プログラムによって生成された要求とトラフィック。アプリケーション層の属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Session IAT: is the variable used to schedule an event to begin a session. The Application node generates an exponentially distributed random variable with mean Session IAT and begins to generate information for a specific group at that time and also accept packets belonging to that group. 2. Data IAT: When Application node generates data traffic, the inter arrival time between the packets uses Data IAT variable as the argument. The distribution can be any of the available distribution functions in OPNET. 3. Session-min and Session-max: When an application joins a session the duration for which the application stays in that session is bounded by Session-min and Session-max. A uniformly distributed random variable between Session-min and Session-max is generated for this purpose. At any given time each node will have zero or one flow(s) of data. 4. NGRPS: This variable is used by the application generating multicast traffic to bound the value of the group to which an application requests the IGMP to join. The group is selected at random from the range [0,NGRPS-1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.セッションIAT：セッションを開始するイベントをスケジュールするために使用される変数です。アプリケーションノードは、平均セッションIATに対して指数関数的に分布する確率変数を生成し、その時点で特定のグループのための情報を生成しても、そのグループに属するパケットを受け入れ始めます。 2.データIAT：アプリケーションノードは、データ・トラフィックを生成する場合、パケット間の相互到着時間を引数としてデータIAT変数を使用します。分布はOPNETで利用可能な分布関数のいずれかとすることができます。 3.セッション分とセッション-MAX：アプリケーションがセッションに参加すると、アプリケーションがそのセッションにとどまるする期間は、セッション分とセッション-MAXによって制限されます。セッション分とセッション-maxの間に均一に分布したランダム変数は、この目的のために生成されます。任意の時点で各ノードは、データの0または1の流れ（S）を有するであろう。 4. NGRPS：この変数は、アプリケーションが参加するIGMPを要求するグループのバインド値にマルチキャストトラフィックを生成するアプリケーションで使用されます。グループは、範囲[0、NGRPS-1]からランダムに選択されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 6: Node Level of Gateway]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[図6：ゲートウェイのノードレベル]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.3 Router description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.3ルーターの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      There are two types of routers in the model, a router serving a
      subnet and a backbone router.  A subnet router has all the
      functions of a backbone router and in addition also has a
      interface to the underlying subnet which can be either a FDDI
      network or a Ethernet subnet. In the following section the subnet
      router will be discussed in detail.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 6 shows the node level model of a subnet router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図6は、サブネット・ルータのノード・レベル・モデルを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. The queueing technique implemented in the router is a combination of input and output queueing. The nodes rx1 to rx10 are the receivers connected to incoming links. The router in Figure 6 has a physical interface to the FDDI ring or Ethernet, which consists of the queue node MAC, transmitter phy_tx, and the receiver phy_rx. The backbone routers will not have a MAC layer. The services provided and the functions of the MAC layer are the same as the MAC layer in the host discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。ルータに実装キューイング技術は、入力及び出力待ち行列の組み合わせです。 RX10のノードRX1は、着信リンクに接続された受信機です。図6のルータは、キューノードMAC、送信phy_tx、および受信phy_rxから成るFDDIリングまたはイーサネットへの物理インタフェースを有しています。バックボーンルータは、MAC層を有しています。提供されるサービスとMAC層の機能は、上述したホストにおけるMAC層と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is one major difference between the MAC node in a subnet router and that in a host. The MAC node in a subnet router accepts all arriving multicast packets unlike the MAC in a host which accepts only the multicast packets for groups of which the host is a member. For this reason the statistic wire from the IGMP to MAC layer does not exist in a router (also because a subnet router does not have an application layer).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストでのサブネットルータのMACノードとの間に、その一つの大きな違いがあります。サブネット・ルータのMACノードは、ホストがメンバーであるグループのためにのみマルチキャストパケットを受け入れホストにMACとは異なり、すべての到来マルチキャストパケットを受け付けます。 MAC層へIGMPから統計ワイヤがルータに存在しないこのような理由から（また、サブネット・ルータは、アプリケーション層を有していないため）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. Addr_trans: The link layer in the router hierarchy is the addr_trans processor node which provides the service of translating the IP address to a physical address. The addr_trans node was described above under the host model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。 Addr_trans：ルータの階層におけるリンク層は物理アドレスにIPアドレスを変換するサービスを提供addr_transプロセッサ・ノードです。 addr_transノードがホスト・モデルの下で上述しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. IP layer: The router IP layer which provides services to the upper layer transport protocols and also performs routing based upon the information in the routing table. The IP layer maintains two routing tables and one group membership table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。 IP層：上位層トランスポートプロトコルにサービスを提供し、また、ルーティングテーブル内の情報に基づいてルーティングを実行するルータのIP層。 IP層は、2つのルーティングテーブルと1つのグループメンバーシップのテーブルを維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The tables used by the router model are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルータのモデルで使用されるテーブルは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 1. Unicast routing table: This table is an single array of one dimension, which is used to route packets generated by the UDP process node in the hosts. If no route is known to a particular IP address, the corresponding entry is set to a default route. 2. Multicast routing table: This table is a N by I array where N is the maximum number of multicast groups in the model and I is the number of interfaces in the router. This table is used to route multicast packets. The routing table in a router is set by an upper layer routing protocol (see section 4 below). When the IP layer receives a multicast packet with a session_id corresponding to a session which is utilizing the MOSFP, it looks up the multicast routing table to obtain the next hop. 3. Group membership table: This table is used to maintain group membership information of all the interfaces of the router. This table which is also an N by I array is set by the IGMP layer protocol. The routing protocols use this information in the group membership table to calculate and set the routes in the Multicast routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.ユニキャストルーティングテーブル：このテーブルは、ホストにUDP処理ノードによって生成されたパケットをルーティングするために使用される一次元の単一のアレイです。何の経路が特定のIPアドレスに知られていない場合、対応するエントリはデフォルトルートに設定されています。 2.マルチキャストルーティングテーブル：このテーブルは、Nは、モデル内のマルチキャストグループの最大数であり、Iは、ルータのインターフェイスの数であり、I配列によってNです。このテーブルは、ルートマルチキャストパケットに使用されています。ルータのルーティングテーブルは、上位レイヤのルーティングプロトコル（以下のセクション4を参照）によって設定されます。 IP層は、SESSION_IDはMOSFPを利用しているセッションに対応するマルチキャストパケットを受信すると、次のホップを取得するマルチキャストルーティングテーブルを検索します。 3.グループ・メンバーシップ・テーブル：このテーブルには、ルータのすべてのインターフェイスのグループメンバーシップ情報を維持するために使用されます。 IアレイによってもNであり、このテーブルは、IGMP層プロトコルによって設定されます。ルーティングプロトコルは、マルチキャストルーティングテーブル内のルートを計算し、設定するためにグループ・メンバーシップ・テーブルにこの情報を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sub-queues: The IP node has three subqueues, which implement queuing based upon the priority of arriving packets from the neighboring routers or the underlying subnet. The queue with index 0 has the highest priority. When a packet arrives at the IP node, the packets are inserted into the appropriate sub-queue based on the priority of their traffic category: control traffic, resource- reserved traffic, or best effort traffic. A non-preemptive priority is used in servicing the packets. After the servicing, packets are sent to the one of the output queues or the MAC. The packets progress through these queues until the transmitter becomes available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サブキュー：IPノードは、実装が隣接ルータまたは基礎サブネットからのパケットの到着の優先度に基づいてキューイング3つのサブキューを有しています。インデックス0のキューは最も高い優先度を持っています。パケットがIPノードに到着すると、パケットはそのトラフィックカテゴリの優先順位に基づいて適切なサブキューに挿入されている：制御トラフィック、トラフィック、またはベストエフォートトラフィックを予約資源。ノンプリエンプティブ優先順位は、パケットをサービスに使用されます。修理後、パケットが出力キューまたはMACのいずれかに送信されます。トランスミッタが利用可能になるまでのパケットは、これらのキューを進めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Attributes of the IP node are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPノードの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Unique IP address for each interface (a set of transmitter and receiver constitute an interface). 2. Service rate: the rate with which packets are serviced at the router. 3. Queue size: size of each of the sub queues used to store incoming packets based on the priority can be specified individually
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インターフェイスごとに1一意のIPアドレス（送信機と受信機のセットは、インターフェイスを構成します）。 2.サービス・レート：パケットがルータでサービスされる割合。 3.キューサイズ：優先順位に基づいて、着信パケットを格納するために使用されるサブ・キューのそれぞれの大きさを個別に指定することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. Output queues: The output queues perform the function of queueing the packets received by the IP layer when the transmitter is busy. A significant amount of queuing takes place in the output queues only if the throughput of the IP node approaches the transmission capacity of the links. The only attribute of the queue node is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。出力キュー：出力キューは、送信機がビジー状態であるとき、IP層で受信したパケットをキューイングの機能を実行します。 IPノードのスループットは、リンクの伝送容量に近づいた場合にのみ、キューイング、かなりの量は、出力キューで行われます。キューノードの唯一の属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Queue size: size of the queue in each queue node. If the queue is full when a packet is received, that packet is dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キューのサイズ：各キューノードにおけるキューのサイズ。パケットを受信したときにキューがいっぱいの場合、そのパケットはドロップされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
e. IGMP Node: Also modeled in the router is the IGMP for implementing multicasting, the routing protocol, and RSVP for providing specific QoS setup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電子。 IGMPノード：また、ルータでモデル化は、特定のQoS設定を提供するためのマルチキャスト、ルーティングプロトコル、およびRSVPを実装するためのIGMPです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IGMP node implements the IGMP protocol as defined in RFC 1112. The IGMP node at a router (Figure 7) is different from the one at a host. The functions of the IGMP node at a router are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルータ（図7）におけるIGMPノードは、ホストのものとは異なるRFC 1112で定義されるようにIGMPノードは、IGMPプロトコルを実装します。ルータのIGMPノードの機能は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. IGMP node at a router sends queries at regular intervals on all its interfaces. 2. When IGMP receives a response to the queries sent, IGMP updates the multicast Group membership table in the IP node and triggers on MOSPF LSA update. 3. Every time the IGMP sends a query, it also updates the multicast group membership table in the IP node if no response has been received on for the group on any interface, indicating that a interface is no longer a member of that group. This update is done only on entries which indicate an active membership for a group on a interface where the router has not received a response for the last query sent. 4. The routing protocol (see ection 4 below) uses the information in the group membership table to calculate the routes and update the multicast routing table. 5. When the IGMP receives a query (an IGMP at router can receive a query from a directly connected neighboring router), the IGMP node creates a response for each of the groups it is a member of on all the interfaces except the one through which the query was received. 6. The IGMP node on a backbone router is disabled, because IGMP is only used when a router has hosts on its subnet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルータの1 IGMPノードは、そのすべてのインターフェイス上で定期的にクエリを送信します。 IGMPが送信されたクエリに対する応答を受信した場合2.、IGMPは、IPノードにマルチキャストグループメンバーシップのテーブルを更新し、MOSPF LSAの更新にトリガします。応答は、任意のインターフェイスのグループのために受信されていない場合3. IGMPクエリを送信するたびに、それはまた、インタフェースは、もは​​やそのグループのメンバーであることを示していない、IPノードにおいてマルチキャストグループメンバーシップテーブルを更新します。このアップデートは、ルータのみが送信された最後のクエリに対する応答を受信して​​いないインターフェイス上のグループのアクティブメンバーシップを示すエントリに行われます。前記ルーティングプロトコル（以下ection 4参照）がルートを計算し、マルチキャストルーティングテーブルを更新するために、グループメンバシップテーブル内の情報を使用します。 IGMPは、クエリ（ルータにIGMPが直接接続された隣接ルータからクエリーを受信することができる）を受信すると、IGMPノードはグループのそれぞれに対する応答を作成5.これは、1つを除くすべてのインターフェイス上のメンバーであるスルークエリが受信されました。ルータはそのサブネット上のホストがある場合、IGMPのみが使用されているので、6バックボーンルータ上のIGMPノードは、無効になっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 7: IGMP process on routers]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[図7：ルータにIGMP処理]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. RSVP model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. RSVPモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current version of the RSVP model supports only fixed-filter reservation style. The following processing takes place in the indicated modules. The model is current with [2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSVPモデルの現在のバージョンでは、唯一、固定フィルタ予約スタイルをサポートしています。次の処理が示されたモジュールで行われます。モデル[2]を有する電流です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 RSVP APPLICATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 RSVPアプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1 Init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1初期化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Initializes all variables and loads the distribution functions for Multicast Group IDs, Data, termination of the session. Transit to Idle state after completing all the initializations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての変数を初期化し、マルチキャストグループID、データ、セッション終了の分布関数をロードします。すべての初期化を完了した後にアイドル状態に遷移します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2 Idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2アイドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state has transitions to two states, Join and Data_Send. It transit to Join state at the time that the application is scheduled to join a session or terminate the current session, transit to Data_Send state when the application is going to send data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態は、二つの状態への遷移を持ち、参加してDATA_SEND。それはトランジットアプリケーションがデータを送信しようとしたときに、アプリケーションがセッションに参加したり、現在のセッションを終了、DATA_SEND状態に遷移するようにスケジュールされた時点での状態に参加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3 Join
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3参加
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Application will send a session call to local RSVP daemon. In response it receives the session Id from the Local daemon. This makes a sender or receiver call. The multicast group id is selected randomly from a uniform distribution. While doing a sender call the application will write all its sender information in a global session directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは、ローカルのRSVPデーモンにセッションコールを送信します。応答では、ローカルデーモンからセッションIDを受け取ります。これは、送信者または受信者の呼び出しを行います。マルチキャストグループIDは、一様分布からランダムに選択されます。送信者の呼び出しをしながらアプリケーションは、グローバルセッションディレクトリ内のすべての送信者情報を書き込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the application is acting as a receiver it will check for the sender information in the session directory for the multicast group that it wants to join to and make a receive call to the local RSVP daemon. Along with the session and receive calls, it makes an IGMP join call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは受信機として動作している場合、それはに参加し、地元のRSVPデーモンへの呼び出しを受けるにしたいマルチキャストグループのセッションディレクトリ内の送信者情報を確認します。電話を受けるセッションに加えて、それはIGMPが通話に参加できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the application chooses to terminate the session to which it was registered, it will send a release call to the local RSVP daemon and a terminate call to IGMP daemon. After completing these functions it will return to the idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションは、それが登録されたためにセッションを終了することを選択した場合、それはローカルRSVPデーモンに解放呼び出しを送信し、IGMPデーモンへの通話を終了します。これらの機能を完了した後にそれがアイドル状態に戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 8: RSVP process on routers]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[図8：ルータにRSVPプロセス]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.4 Data_Send
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.4 DATA_SEND
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Creates a data packet and sends it to a multicast destination that it selects. It update a counter to keep track of how many packets that it has sent. This state on default returns to Idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データパケットを作成し、それを選択したマルチキャストの宛先に送信します。それが送信したパケット数を追跡​​するためにカウンタを更新します。デフォルトでこの状態がアイドル状態に戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 RSVP on Routers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ルータの4.2 RSVP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 8 shows the process model of RSVP on routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図8は、ルータにRSVPのプロセスモデルを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1 Init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1初期化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state calls a function called RouterInitialize which will initialize all the router variables. This state will go to Idle state after completing these functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態は、すべてのルータの変数を初期化しますRouterInitializeという関数を呼び出します。この状態は、これらの機能を完了した後にアイドル状態になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2 Idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2アイドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Idle state transit to Arr state upon receiving a packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットを受信すると、状態をARRするアイドル状態に遷移。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3 Arr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3編曲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state checks for the type of the packet arrived and calls the appropriate function depending on the type of message received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットのタイプについて、この状態チェックが到着し、受信したメッセージの種類に応じて適切な関数を呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. PathMsgPro: This function was invoked by the Arr state when a path message is received. Before it was called, OSPF routing had been recomputed to get the latest routing table for forwarding the Path Message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 PathMsgPro：パスメッセージを受信したとき、この機能は、編曲状態によって呼び出されました。それが呼び出される前に、OSPFルーティングは、Pathメッセージを転送するための最新のルーティングテーブルを取得するために再計算されていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. It first checks for a Path state block which has a matching destination address and if the sender port or sender address or destination port does not match the values of the Session object of the Path state block, it sends an path error message and returns. (At present the application does not send any error messages, we print this error message on the console.) 2. If a PSB is found whose Session Object and Sender Template Object matches with that of the path message received, the current PSB becomes the forwarding PSB. 3. Search for the PSB whose session and sender template matches the corresponding objects in the path message and whose incoming interface matches the IncInterface. If such a PSB is found and the if the Previous Hop Address, Next Hop Address, and SenderTspec Object doesn&#39;t match that of path message then the values of path message is copied into the path state block and Path Refresh Needed flag is turned on. If the Previous Hop Address, Next Hop
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.一致する宛先アドレスを有し、送信元ポートまたは送信元アドレス、または宛先ポートがパス状態ブロックのセッションオブジェクトの値と一致しない場合、それは経路エラーメッセージを返すを送信パス状態ブロックの最初のチェック。 （現時点でアプリケーションにエラー・メッセージを送信しません、私たちは、コンソール上でこのエラーメッセージを出力します。）2. PSBが発見され、そのセッションオブジェクトとSenderテンプレートオブジェクトが受信したパスメッセージのそれと一致した場合、現在のPSBになりますPSBを転送します。セッションおよび送信者テンプレートパスメッセージに対応するオブジェクトと一致し、その着信インターフェイスIncInterfaceと一致PSB 3.検索。そのようなPSBが見出され、前ホップアドレス、次ホップアドレス、およびSenderTspecオブジェクトはPathメッセージのそれと一致しない場合、パス・メッセージの値は、パス状態ブロックとのパスにコピーされる更新必要フラグがオンになっている場合。前のホップアドレスの場合、ネクストホップ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 Address of PSB differs from the path message then the Resv Refresh Needed flag is also turned on, and the Current PSB is made equal to this PSB. 4. If a matching PSB is not found then a new PSB is created and and Path Refresh Needed Flag is turned on, and the Current PSB is made equal to this PSB. 5. If Path Refresh Needed Flag is on, Current PSB is copied into forwarding PSB and Path Refresh Sequence is executed. To execute this function called PathRefresh is used. Path Refresh is sent to every interface that is in the outgoing interfaces list of forwarding path state block. 6. Search for a Reservation State Block whose filter spec object matches with the Sender Template Object of the forwarding PSB and whose Outgoing Interface matches one of the entry in the forwarding PSB&#39;s outgoing interface list. If found then a Resv Refresh message to the Previous Hop Address in the forwarding PSB and execute the Update Traffic Control sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSBのアドレスは、Pathメッセージとは異なるその後のResvリフレッシュ必要なフラグもオンし、現在のPSBは、このPSBに等しくされます。マッチングPSBが、その後見つからない場合4.新しいPSBが作成され、およびパスの更新必要フラグがオンになり、現在のPSBは、このPSBに等しくされます。 5.旗を必要なパスの更新が上にある場合は、現在のPSBは、PSBを転送にコピーされ、パスのリフレッシュシーケンスが実行されます。 PathRefreshと呼ばれるこの機能を実行するために使用されます。パス更新を転送パス状態ブロックの発信インターフェイスリストにあるすべてのインターフェイスに送信されます。フィルタスペックオブジェクトは、発信インターフェイス転送PSBの発信インターフェイスリスト内のエントリのいずれかと一致転送PSBとのセンダテンプレートオブジェクトと一致する予約状態ブロック6.検索。転送PSBに前のホップアドレスに、その後のResvリフレッシュメッセージを発見し、更新トラフィック制御シーケンスを実行した場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. PathRefresh: This function is called from PathMsgPro. It creates the Path message sends the message through the outgoing interface that is specified by the PathMsgPro.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。 PathRefresh：この関数はPathMsgProから呼び出されます。これは、PathメッセージがPathMsgProによって指定された発信インターフェイスを介してメッセージを送信しますが作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. ResvMsgPro: This function was invoked by the Arr state when a Resv message is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。 ResvMsgPro：Resvメッセージが受信されると、この関数は、編曲状態によって呼び出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Determine the outgoing interface and check for the PSB whose Source Address and Session Objects match the ones in the Resv message. 2. If such a PSB is not found then send a ResvErr message saying that No Path Information is available. (We have not implemented this message, we only print an error message on the console.) 3. Check for incompatible styles and process the flow descriptor list to make reservations, checking the PSB list for the sender information. If no sender information is available through the PSB list then send an Error message saying that No Sender information. For all the matching PSBs found, if the Refresh PHOP list doesn&#39;t have the Previous Hop Address of the PSB then add the Previous Hop Address to the Refresh PHOP list. 4. Check for matching Reservation State Block (RSB) whose Session and Filter Spec Object matches that of Resv message. If no such RSB is found then create a new RSB from the Resv Message and set the NeworMod flag On. Call this RSB as activeRSB. Turn on the Resv Refresh Needed Flag. 5. If a matching RSB is found, call this as activeRSB and if the FlowSpec and Scope objects of this RSB differ from that of Resv Message copy the Resv message Flowspec and Scope objects to the ActiveRSB and set the NeworMod flag On.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.発信インターフェイスを決定し、その送信元アドレスとセッションオブジェクトResvメッセージでのものと一致PSBをチェック。 2.そのようPSBは、その後見つからない場合はいいえパス情報が利用できないことを言ってResvErrメッセージを送信します。 （私たちは、このメッセージを実装していない、我々は唯一のコンソールにエラーメッセージが出力されます。）互換性のないスタイル3.チェックや予約を行うために、フロー記述子のリストを処理し、送信者情報のためのPSBのリストをチェック。何の送信者情報は、PSBのリストを使用できない場合は、ありません送信者情報というエラーメッセージを送信します。一致するすべてのPSBが見つかるのリフレッシュPHOPリストは、PSBの前のホップアドレスを持っていない場合は、[更新PHOPリストに前のホップアドレスを追加します。 4.一致する予約状態ブロック（RSB）セッションのチェックやフィルタスペックオブジェクトは、Resvメッセージのそれと一致しました。そのようなRSB見つからなかった場合、その後のResvメッセージからRSB新しいを作成し、上NeworModフラグを設定します。 activeRSBとしてRSBこれを呼び出します。 Resv更新必要フラグをオンにします。 5.マッチングがRSB見つかった場合、activeRSBとしてこれを呼び出し、このたFlowSpecとスコープオブジェクトがRSBのResvメッセージのものと異なる場合ActiveRSBにフロースペック及び範囲は、オブジェクトResvメッセージをコピーし、上NeworModフラグを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. Call the Update Traffic Control Sequence. This is done by calling the function UpdateTrafficControl 7. If Resv Refresh Needed Flag is On then send a ResvRefresh message for each Previous Hop in the Refresh PHOP List. This is done by calling the ResvRefresh function for every Previous Hop in the Refresh PHOP List.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6.アップデートトラフィック制御シーケンスを呼び出します。これは、[更新PHOPリスト内のそれぞれの前のホップのためにResvRefreshメッセージを送る上でのResv更新必要フラグがある場合は、関数UpdateTrafficControl 7を呼び出すことによって行われます。これは、最新の情報に更新PHOPリスト内のすべての前のホップのためのResvRefresh関数を呼び出すことによって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. ResvRefresh: this function is called by both PathMsgPro and ResvMsgPro with RSB and Previous Hop as input. The function constructs the Resv Message from the RSB and sends the message to the Previous Hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。 ResvRefresh：この関数は、入力としてPathMsgProとResvMsgPro RSBとし、前のホップの両方によって呼び出されます。関数は、RSBからのResvメッセージを構築し、前のホップにメッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
e. PathTearPro: This function is invoked by the Arr state when a PathTear message is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電子。 PathTearPro：PathTearメッセージを受信したとき、この機能は、編曲状態によって呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Search for PSB whose Session Object and Sender Template Object matches that of the arrived PathTear message. 2. If such a PSB is not found do nothing and return. 3. If a matching PSB is found, a PathTear message is sent to all the outgoing interfaces that are listed in the Outgoing Interface list of the PSB. 4. Search for all the RSB whose Filter Spec Object matches the Sender Template Object of the PSB and if the Outgoing Interface of this RSB is listed in the PSB&#39;s Outgoing interface list delete the RSB. 5. Delete the PSB and return.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セッションオブジェクトとSenderテンプレートオブジェクトが到着したPathTearメッセージのそれと一致したPSB 1.検索。 2.このようPSBが見つからない場合は何もしてリターンを行いません。 3.一致PSBが見つかった場合、PathTearメッセージがPSBの発信インターフェイスリストに記載されているすべての発信インターフェイスに送信されます。 4.検索すべてRSBそのフィルター仕様オブジェクトPSBの送信者テンプレートオブジェクトと一致し、この発信インターフェイスがRSB PSBの発信インターフェイスリストに表示されている場合RSB削除します。 5. PSBとリターンを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
f. ResvTearPro: This function is invoked by the Arr state when a ResvTear message is received. 1. Determine the Outgoing Interface. 2. Process the flow descriptor list of the arrived ResvTear message. 3. Check for the RSB whose Session Object, Filter Spec Object matches that of ResvTear message and if there is no such RSB return. 4. If such an RSB is found and Resv Refresh Needed Flag is on send ResvTear message to all the Previous Hops that are in Refresh PHOP List. 5. Finally delete the RSB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
F。 ResvTearPro：たResvTearメッセージを受信したとき、この機能は、編曲状態によって呼び出されます。 1.発信インターフェイスを決定します。 2.プロセスに到着したResvTearメッセージの流れ記述子リスト。 3.チェックRSBそのセッションオブジェクト、フィルター仕様オブジェクトたResvTearメッセージのものと一致し、そのようなRSBリターンが存在しない場合。 4. RSBなどが発見されたとのResv更新必要フラグが更新PHOPリストにあるすべての前のホップへのセンドたResvTearメッセージ上にある場合。 5.最後にRSBを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
g. ResvConfPro: This function is invoked by the Arr state when a ResvConf message is received. The Resv Confirm is forwarded to the IP address that was in the Resv Confirm Object of the received ResvConf message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グラム。 ResvConfPro：ResvConfメッセージを受信したとき、この機能は、編曲状態によって呼び出されます。たResv確認が受信されたResvConfメッセージのオブジェクトを確認したResvであったIPアドレスに転送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
h. UpdateTrafficControl: This function is called by PathMsgPro and ResvMsgPro and input to this function is RSB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時間。 UpdateTrafficControl：この機能は、PathMsgProとResvMsgProによって呼び出され、この関数への入力は、RSBです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. The RSB list is searched for a matching RSB that matches the Session Object, and Filter Spec Object with the input RSB. 2. Effective Kernel TC_Flowspec are computed for all these RSB&#39;s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. RSBリストはRSBセッションオブジェクトに一致マッチングRSBを検索し、そして入力と仕様オブジェクトをフィルタです。 2.効果的なカーネルTC_Flowspecは、これらすべてのRSBのために計算されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. If the Filter Spec Object of the RSB doesn&#39;t match the one of the Filter Spec Object in the TC Filter Spec List then add the Filter Spec Object to the TC Filter Spec List. 4. If the FlowSpec Object of the input RSB is greater than the TC_Flowspec then turn on the Is_Biggest flag. 5. Search for the matching Traffic Control State Block(TCSB) whose Session Object, Outgoing Interface, and Filter Spec Object matches with those of the Input RSB. 6. If such a TCSB is not found create a new TCSB. 7. If matching TCSB is found modify the reservations. 8. If Is_Biggest flag is on turn on the Resv Refresh Needed Flag flag, else send a ResvConf Message to the IP address in the ResvConfirm Object of the input RSB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3のフィルタ・スペックオブジェクトは、RSB、その後TCフィルタースペック一覧にフィルター仕様オブジェクトを追加TCフィルタースペック一覧でフィルター仕様オブジェクトのいずれかと一致しない場合。 4.入力たFlowSpecオブジェクトがRSB TC_Flowspec次いでIs_Biggestフラグをオンよりも大きい場合。セッションオブジェクト、発信インターフェイス、および入力のものとスペックオブジェクトの一致をフィルタRSB一致するトラフィック制御状態ブロック（TCSB）5.検索。 6.このようTCSBが新しいTCSBを作成見つからない場合。 7.一致TCSBは予約を変更する発見された場合。 8.もしIs_Biggestフラグは、他の入力のResvConfirmオブジェクトRSBにIPアドレスにResvConfメッセージを送ったResv更新必要フラグフラグのターンです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.4 pathmsg: The functions to be done by this state are done through the function call PathMsgPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.4 pathmsg：この状態により行われるべき機能がPathMsgProは、上述した関数呼び出しを介して行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.5 resvmsg: The functions that would be done by this state are done through the function call ResvMsgPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.5 resvmsg：この状態により行われるであろう機能はResvMsgProは、上述した関数呼び出しを介して行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.6 ptearmsg: The functions that would be done by this state are done through the function call PathTearPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.6 ptearmsg：この状態により行われるであろう機能はPathTearProは、上述した関数呼び出しを介して行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.7 rtearmsg: The functions that would be done by this state are done through the function call ResvTearPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.7 rtearmsg：この状態により行われるであろう機能はResvTearProは、上述した関数呼び出しを介して行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.8 rconfmsg: The functions that would be done by this state are done through the function call ResvConfPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.2.8 rconfmsg：この状態により行われるであろう機能はResvConfProは、上述した関数呼び出しを介して行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 RSVP on Hosts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ホスト上の4.3 RSVP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 9 shows the process of RSVP on hosts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図9は、ホスト上のRSVPの処理を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1 Init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1初期化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Initializes all the variables. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての変数を初期化します。デフォルトのトランジションは、アイドル状態に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 9: RSVP process on hosts]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[図9：ホスト上のRSVPプロセス]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2 idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2アイドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state transit to the Arr state on packet arrival.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケット到着時に編曲状態にこの状態に遷移します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3 Arr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3編曲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state calls the appropriate functions depending on the type of message received. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態は、受信したメッセージの種類に応じて適切な関数を呼び出します。デフォルトのトランジションは、アイドル状態に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. MakeSessionCall: This function is called from the Arr state whenever a Session call is received from the local application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 MakeSessionCall：セッションコールがローカルアプリケーションから受信されるたびに、この関数は、編曲の状態から呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Search for the Session Information. 2. If one is found return the corresponding Session Id. 3. If the session information is not found assign a new session Id to the session to the corresponding session. 4. Make an UpCall to the local application with this Session Id.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セッション情報1.検索。 2. 1は、対応するセッションIDを返す発見された場合。 3.セッション情報は、対応するセッションにセッションに新しいセッションIDを割り当てる見つからない場合。 4.このセッションIDを持つローカルアプリケーションにアップコールを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. MakeSenderCall: This function is called from the Arr state whenever a Sender call is received from the local application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。 MakeSenderCall：送信者の呼び出しがローカルアプリケーションから受信されるたびに、この関数は、編曲の状態から呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Get the information corresponding to the Session Id and create a Path message corresponding to this session. 2. A copy of the packet is buffered and used by the host to send the PATH message periodically. 3. This packet is sent to the IP layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.セッションIDに対応する情報を取得し、このセッションに対応するPathメッセージを作成します。 2.パケットのコピーがバッファリングされ、定期的にPATHメッセージを送信するためにホストによって使用されます。 3.このパケットは、IP層に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. MakeReserveCall: This function is called from the Arr state whenever a Reserve call is received from the local application. This function will create and send a Resv message. Also, the packet is buffered for later use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。 MakeReserveCall：予約コールがローカルアプリケーションから受信されるたびに、この関数は、編曲の状態から呼び出されます。この機能は、作成およびResvメッセージを送信します。また、パケットは、後で使用するためにバッファリングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. MakeReleaseCall: This function is called from the Arr state whenever a Release call is received from the local application. This function will generate a PathTear message if the local application is sender or generates a ResvTear message if the local application is receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。 MakeReleaseCall：リリースコールがローカルアプリケーションから受信されるたびに、この関数は、編曲の状態から呼び出されます。ローカルアプリケーションは、送信者であるか、またはローカルアプリケーションは、受信機であればたResvTearメッセージを生成する場合、この関数はPathTearメッセージを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.3.4 Session This state&#39;s function is performed by the MakeSessionCall function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.3.4セッションこの状態の関数はMakeSessionCall機能によって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.5 Sender
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.5トランスミッタ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state&#39;s function is han by the MakeSenderCall function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態の機能はMakeSenderCall機能によって漢です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.3.6 Reserve This state&#39;s function is performed by the MakeReserveCall function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.3.6準備この状態の関数はMakeReserveCall機能によって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.7 Release
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.7リリース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state&#39;s function is performed by the MakeReleaseCall function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態の関数はMakeReleaseCall機能によって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Multicast Routing Model Interface
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.マルチキャストルーティングモデルインターフェイス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because this set of models was intended particularly to enable evaluation by simulation of various multicast routing protocols, we give particular attention in this section to the steps necessary to interface a routing protocol model to the other models. We have available implementations of DVMRP and OSPF, which we will describe below. Instructions for invoking these models are contained in a separate User&#39;s Guide for the models.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モデルのこのセットは、様々なマルチキャストルーティングプロトコルのシミュレーションによる評価を可能にするために特に意図されていたので、我々は、他のモデルへのルーティングプロトコルモデルをインターフェースするために必要な手順には、このセクションに特に注意を与えます。我々は以下について説明しますDVMRPとOSPFの利用可能な実装を持っています。これらのモデルを呼び出すための手順は、モデルのために別々のユーザーガイドに記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 Creation of multicast routing processor node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
マルチキャストルーティング・プロセッサ・ノードの5.1作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Interfacing a multicast routing protocol using the OPNET Simulation package requires the creation of a new routing processor node in the node editor and linking it via packet streams. Packet streams are unidirectional links used to interconnect processor nodes, queue nodes, transmitters and receiver nodes. A duplex connection between two nodes is represented by using two unidirectional links to connect the two nodes to and from each other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPNETシミュレーションパッケージを使用してマルチキャストルーティングプロトコルをインタフェースするノードエディタで新しいルーティングプロセッサノードの作成を必要とし、パケットストリームを介して連結します。パケットストリームはプロセッサノード、キューノード、送信機と受信機ノードを相互接続するために使用される単方向リンクです。 2つのノード間の二重接続は、互いにからつのノードを接続する2つの単方向リンクを使用して表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A multicast routing processor node is created in the node editor and links are created to and from the processors(duplex connection) that interact with this module, the IGMP processor node and the IP processor node. Within the node editor, a new processor node can be created by selecting the button for processor creation (plain gray node on the node editor control panel) and by clicking on the desired location in the node editor to place the node. Upon creation of the processor node, the name of the processor can be specified by right clicking on the mouse button and entering the name value on the attribute box presented. Links to and from this node are generated by selecting the packet stream button (represented by two gray nodes connected with a solid green arrow on the node editor control panel), left clicking on the mouse button to specify the source of the link and right clicking on the mouse button to mark the destination of the link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストルーティングのプロセッサノードは、ノードエディタで作成され、リンクは、このモジュールと相互作用するプロセッサ（二重接続）へとから作成され、IGMPのプロセッサノードとIPプロセッサ・ノード。ノードエディタ内で、新しいプロセッサノードはプロセッサ作成（ノードエディタコントロールパネルの無地の灰色ノード）のためのボタンを選択することによって、ノードを配置するノードエディタ内の所望の位置をクリックすることによって作成することができます。プロセッサノードの作成時に、プロセッサの名前をマウスの右ボタンをクリックし、提示属性ボックスの名前の値を入力することで指定することができます。このノードからのリンクは、リンクと右クリックのソースを指定するためにマウスボタンのパケットストリーム（ノードエディタコントロールパネルの緑色の矢印で接続された2つのグレーのノードによって表される）ボタン、左クリックを選択することによって生成されますマウスボタンのリンク先をマークします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Interfacing processor nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2プロセッサノードのインタフェース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The multicast routing processor node is linked to the IP processor node and the IGMP processor node each with a duplex connection. A duplex connection between two nodes is represented by two uni-directional links interconnecting them providing a bidirectional flow of information or interrupts, as shown in Figure 6. The IP processor node (in the subnet router) interfaces with the multicast routing processor node, the unicast routing processor node, the Resource Reservation processor node(RSVP), the ARP processor node( only on subnet routers and hosts), the IGMP processor node, and finally the MAC processor node (only on subnet routers and hosts) each with a duplex connection with exceptions for ARP and MAC nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストルーティングプロセッサノードは二重接続でIPプロセッサ・ノードとIGMPプロセッサノード各々に連結されています。 2つのノード間の二重接続は、IPのプロセッサノードは、図6に示すように、（サブネット・ルータで）、マルチキャストルーティング・プロセッサ・ノードとのインターフェースを情報や割り込みの双方向の流れを提供それらを相互接続する2一方向リンクで表されます。 （のみサブネットルータとホスト上の）ユニキャストルーティングプロセッサノード、リソース予約処理ノード（RSVP）、（のみサブネットルータとホスト上の）ARPプロセッサ・ノード、IGMPプロセッサ・ノード、および最終的にはMACプロセッサ・ノードデュプレックス各ARPおよびMACノード用の例外を除いて接続。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1 Interfacing ARP and MAC processor nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1のインタフェースARPおよびMACプロセッサノード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The service of the ARP node is required only in the direction from the IP layer to the MAC layer(requiring only a unidirectional link from IP processor node to ARP processor node). The MAC processor node on the subnet router receives multicast packets destined for all multicast groups in the subnet, in contrast to the MAC node on subnet hosts which only receives multicast packets destined specifically for its multicast group. The MAC node connects to the IP processor node with a single uni-directional link from it to the IP node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ARPノードのサービスのみ（IPプロセッサ・ノードからのARPプロセッサノードにのみ単方向リンクを必要とする）MACレイヤにIP層からの方向で必要とされます。サブネット・ルータのMACプロセッサ・ノードは、具体的には、そのマルチキャストグループ宛のマルチキャストパケットを受信し、サブネット上のホストMACノードとは対照的に、サブネット内のすべてのマルチキャストグループ宛てのマルチキャストパケットを受信します。 MACノードはIPノードにそれから単一方向リンクを有するIPプロセッサ・ノードに接続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2 Interfacing IGMP, IP, and multicast routing processor nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2のインタフェースIGMP、IP、およびマルチキャストルーティングプロセッサノード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IGMP processor node interacts with the multicast routing processor node, unicast routing processor node, and the IP processor node. Because the IGMP node is linked to the IP node, it is thus able to update the group membership table(in this model, the group membership table is represented by the local interface(interface 0) of the multicast routing table data structure) within the IP node. This update triggers a signal to the multicast routing processor node from the IGMP node causing it to reassess the multicast routing table within the IP node. If the change in the group membership table warrants a modification of the multicast routing table, the multicast routing processor node interacts with the IP node to modify the current multicast routing table according to the new group membership information updated by IGMP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IGMPのプロセッサノードは、マルチキャストルーティング・プロセッサ・ノード、ユニキャストルーティング・プロセッサ・ノード、及びIPプロセッサ・ノードと相互作用します。 IGMPノードはIPノードにリンクされているので、このようにグループメンバシップテーブルを更新することが可能である（このモデルでは、グループメンバシップテーブルはマルチキャストルーティングテーブルのデータ構造のローカルインタフェース（インタフェース0）で表される）内IPノード。この更新は、IPノード内マルチキャストルーティングテーブルを再評価させるIGMPノードからマルチキャストルーティング処理ノードに信号をトリガします。グループメンバシップテーブルの変化はマルチキャストルーティングテーブルの変更が保証されている場合、マルチキャストルーティングのプロセッサノードは、IGMPにより更新された新たなグループメンバーシップ情報に従って現在のマルチキャストルーティングテーブルを変更するためにIPノードと相互作用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.1 Modification of group membership table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
グループメンバーシップテーブルの5.2.2.1変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The change in the group membership occurs with the decision at a host to leave or join a particular multicast group. The IGMP process on the gateway periodically sends out queries to the IGMP processes on hosts within the subnet in an attempt to determine which hosts currently are receiving packets from particular groups. Not receiving a response for a pending IGMP host query specific to a group indicates to the gateway IGMP that no host belonging to the particular group exists in the subnet. This occurs when the last remaining member of a multicast group in the subnet leaves. In this case the IGMP processor node updates the group membership able and triggers a modification of the multicast routing table by alerting the multicast routing processor node. A prune message specific to the group is initiated and propagated upward establishing a prune state for the interface leading to the present subnet, effectively removing this subnet from the group-specific multicast spanning tree and potentially leading to additional pruning of spanning tree edges as the prune message travels higher up the tree. Joining a multicast group is also managed by the IGMP process which updates the group membership table leading to a possible modification of the multicast routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループメンバーシップの変更は残したり、特定のマルチキャストグループに加入するホストの判断で発生します。ゲートウェイ上のIGMPプロセスは、定期的に、現在、特定のグループからのパケットを受信して​​いるホストを決定する試みにおいて、サブネット内のホスト上でIGMPプロセスにクエリを送出します。グループに固有ペンディングIGMPホストクエリに対する応答を受信しないと、特定のグループに属しないホストがサブネット内に存在しないゲートウェイIGMPに示します。サブネット内のマルチキャストグループの最後の残りのメンバーが離れたときに発生します。この場合、IGMPのプロセッサノードはできるグループメンバーシップを更新し、マルチキャストルーティング・プロセッサ・ノードに警告することにより、マルチキャストルーティングテーブルの変更をトリガーします。グループに固有プルーンメッセージを効果的にスパニングツリーグループ固有のマルチキャストからこのサブネットを除去し、潜在的にプルーンとしてツリーエッジをまたがる追加の剪定につながる、上方本サブネットにつながるインタフェース用プルーン状態を確立する開始と伝播されますメッセージは、ツリーまで高い移動します。マルチキャストグループに参加することも、マルチキャストルーティングテーブルの可能な変更につながるグループメンバシップテーブルを更新IGMPプロセスによって管理されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.2 Dependency on unicast routing protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ユニキャストルーティングプロトコルに依存5.2.2.2
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The multicast routing protocol is dependent on a unicast routing protocol (RIP or OSPF) to handle multicast routing. The next hop interface to the source of the packet received, or the upstream interface, is determined using the unicast routing protocol to trace the reverse path back to the source of the packet. If the packet received arrived on this upstream interface, then the packet can be propagated downstream through its downstream interfaces (excluding the interface in which the packet was received). Otherwise, the packet is deemed to be a duplicate and dropped, halting the propagation of the packet downstream. This repeated reverse path checking and broadcasting eventually generates the spanning tree for multicast routing of packets. To determine the reverse path forward interface of a received multicast packet propagated up from the IP layer, the multicast routing processor node retrieves a copy of the unicast routing table from the IP processor node and uses it to recalculate the multicast routing table in the IP processor node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストルーティングプロトコルは、マルチキャストルーティングを処理するために、ユニキャストルーティングプロトコル（RIPまたはOSPF）に依存しています。受信パケットの送信元のネクストホップインターフェイス、またはアップストリームインタフェースは、バックパケットのソースと逆の経路をトレースするユニキャストルーティングプロトコルを使用して決定されます。パケットがこのアップストリームインタフェースに到着し、受信した場合、パケットは、（パケットを受信したインターフェイスを除く）その下流インタフェースを介して下流に伝播させることができます。そうでない場合、パケットは重複であるとみなされると下りパケットの伝搬を停止、低下しました。この繰り返し反転経路は、検査や放送は、最終的にパケットのマルチキャストルーティングのためのスパニングツリーを生成します。 IP層から最大伝播受信したマルチキャストパケットのリバースパス前方インタフェースを決定するために、マルチキャストルーティングのプロセッサノードは、IPプロセッサ・ノードからユニキャストルーティングテーブルのコピーを取得したIPプロセッサにマルチキャストルーティングテーブルを再計算するためにそれを使用してノード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 Interrupt Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3割り込み発生
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using the OPNET tools, interrupts to the multicast routing processor node are generated in several ways. One is the arrival of a multicast packet along a packet stream (at the multicast routing processor node) when the packet is received by the MAC node and propagated up the IP node where upon discarding the IP header determination is made as to which upper layer protocol to send the packet. A second type of interrupt generation occurs by remote interrupts from the IGMP process alerting the multicast routing process of an update in the group membership table. A third occurs when the specific source/group (S,G) entry for a multicast packet received at the IP node does not exist in the current multicast routing table and a new entry needs to be created. The IP node generates an interrupt to the multicast routing processor node informing it to create a new source/group entry on the multicast routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPNETツールを使用して、いくつかの方法で生成されたマルチキャストルーティング処理ノードに遮断します。一つは、パケットがMACノードによって受信され、IPヘッダ決意を捨てる際にその上位プロトコルとして作られているIPノードに伝播される（マルチキャストルーティング処理ノードの）パケット・ストリームに沿ってマルチキャストパケットの到着でありますパケットを送信します。割り込み発生の第二のタイプは、グループ・メンバーシップ・テーブル内の更新のマルチキャストルーティングプロセスを警告IGMPプロセスから遠隔割り込みによって起こります。特定の送信元/グループ（S、G）マルチキャストパケットのエントリが現在のマルチキャストルーティングテーブルに存在しないIPノードで受信され、新しいエントリを作成する必要があるときに第が生じます。 IPノードは、マルチキャストルーティングテーブルに新しいソース/グループエントリを作成するためにそれを知らせるマルチキャストルーティング・プロセッサ・ノードへの割り込みを発生させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1 Types of interrupts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
割り込みの5.3.1タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The process interrupts generated within the OPNET model can be handled by specifying the types of interrupts and the conditions for the interrupts using the interrupt code, integer number representing the condition for a specific interrupt. The conditions for interrupts are specified on the interrupt stream linking the interrupt generating state and the state resulting from the interrupt. For self-interrupts (interrupts occurring among states within the same process), interrupts of type OPC_INTRPT_SELF are used. For remote interrupts (interprocess interrupts), the conditions for specific interrupts are specified from the idle state to the state resulting from the interrupt within the remote process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロセスはOPNETモデル内で発生した割り込みが割り込みの種類と、割り込みコードを使用して割り込み条件を指定することによって処理することができ、特定の割り込みのための条件を表す整数。割り込み条件は、割り込み発生状態と割り込みからの結果の状態をリンク割り込みストリームに指定されています。自己割り込み（同じプロセス内の状態の間で発生する割り込み）のために、型OPC_INTRPT_SELFの割り込みが使用されます。遠隔割り込み（プロセス間割り込み）のために、特定の割り込みのための条件は、リモートプロセス内の割り込みに起因する状態をアイドル状態から特定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The remote interrupts are of type, OPC_INTRPT_REMOTE. A third type of interrupt is the OPC_INTRPT_STRM, which is triggered when packets arrive via a packet stream, indicating its arrival. The condition of this interrupt is also specified from the idle state to the resultant state by the interrupt condition stream defined by a unique interrupt code. For all of these interrupts, the interrupt code is provided within the header block (written in C language) of the interrupted process. When the condition for the interrupt becomes true, a transition is made to the resultant state specified by the interrupt stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
遠隔割り込みは、タイプのOPC_INTRPT_REMOTEです。割り込みの第三のタイプは、パケットがその到着を示す、パケットストリームを介して到着したときにトリガされるOPC_INTRPT_STRM、です。この割り込みの状態は、固有の割り込みコードで定義された割り込み条件の流れによって、アイドル状態から生じた状態に指定されています。これらの割り込みの全てのために、割り込みコードは、割り込まれたプロセスの（C言語で書かれた）ヘッダブロック内に設けられています。割り込みの条件が真となった場合、移行は、割り込みストリームによって指定された結果の状態になっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2 Conditions for interrupts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
割り込みの5.3.2条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Several interrupt connections exist to interface the IGMP processor node, IP processor node , and the multicast routing processor node with each other in the present OPNET Simulation Model. Also, the IP processor node interfaces with the unicast routing protocol which interfaces with the IGMP processor node. An OPC_INTRPT_STRM interrupt is generated when a multicast packet arrives via a packet stream from the IP processor node to the multicast routing processor node. A remote interrupt of type, OPC_INTRPT_REMOTE, is generated from the IGMP process to the IP process when a member of a group relinquishes membership from a particular group or a new member is added to a group. This new membership is updated in the group membership table located in the IP node by the IGMP process which also generates a remote interrupt to the multicast routing protocol process, causing a recalculation of the multicast routing table in the IP module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの割込み接続がIGMPプロセッサ・ノード、IPプロセッサ・ノード、及び本OPNETシミュレーションモデルにおいて互いにマルチキャストルーティング・プロセッサ・ノードのインタフェースに存在します。また、IGMPプロセッサ・ノードとインターフェースユニキャストルーティングプロトコルとIPプロセッサ・ノードインターフェース。マルチキャストパケットがマルチキャストルーティング処理ノードにIPプロセッサ・ノードからパケットストリームを介して到着したときOPC_INTRPT_STRM割り込みが生成されます。グループのメンバーは、特定のグループからメンバシップを放棄するか、新しいメンバーがグループに追加されたときにタイプ、OPC_INTRPT_REMOTEの遠隔割り込みは、IP処理にIGMPプロセスから生成されます。この新しいメンバーシップは、IPモジュールでマルチキャストルーティングテーブルの再計算を引き起こし、また、マルチキャストルーティングプロトコルプロセスにリモート割り込みを発生IGMPプロセスによってIPノードに位置するグループメンバシップテーブル内で更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4 Modifications of modules in the process model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4プロセスモデルのモジュールの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Modifications of routing protocol modules (in fact all of the modules in the process model) are made transparently throughout the network using the OPNET Simulation tools. An addition or modification of a routing module in any subnet will reflect on all the subnets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（実際には、プロセスモデルのモジュールの全て）ルーティングプロトコルモジュールの修飾は、OPNETシミュレーションツールを使用して、ネットワーク全体で透過的に行われています。任意のサブネットにおけるルーティングモジュールの追加または変更は、すべてのサブネット上に反映されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. OSPF and MOSPF Models
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. OSPFとMOSPFモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OSPF and MOSPF models [5] are implemented in the OSPF model containing fourteen states. They only exist on routers. Figure 10 shows the process model. The following processing takes place in the indicated modules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OSPFとMOSPFモデル[5]は14の状態を含むOSPFモデルで実装されています。彼らは、ルータだけに存在します。図10は、プロセスモデルを示しています。次の処理が示されたモジュールで行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1のinit
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state initializes all the router variables. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態は、すべてのルータの変数を初期化します。デフォルトのトランジションは、アイドル状態に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2アイドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state has several transitions. If a packet arrives it transits to arr state. Depending on interrupts received it will transit to BCOspfLsa, BCMospfLsa, hello_pks state. In future versions, links coming up or down will also cause a transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態は、いくつかの遷移を持っています。パケットが到着した場合には、状態をARRに遷移します。割り込みに応じてBCOspfLsa、BCMospfLsa、hello_pks状態にそれが意志トランジット受けました。将来のバージョンでは、リンクも移行の原因となりますダウン来ますか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 BCOspfLsa
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 BCOspfLsa
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transition to this state from idle state is executed whenever the condition send_ospf_lsa is true, which happens when the network is being initialized, and when ospf_lsa_refresh_timout occurs. This state will create Router, Network, Summary Link State Advertisements and pack all of them into an Link State Update packet. The Link State Update Packet is sent to the IP layer with a destination address of AllSPFRouters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
条件send_ospf_lsaが真であるときはいつでも、アイドル状態からこの状態への遷移は、ネットワークが初期化されているとき、及びospf_lsa_refresh_timoutが発生したときに発生した、実行されます。この状態は、ルータ、ネットワーク、概要リンクステートアドバタイズメントを作成して、リンクステートアップデートパケットにそれらのすべてをパックします。リンクステートアップデートパケットがAllSPFRoutersの宛先アドレスとIP層に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 10: OSPF and MOSPF process model on routers]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[図10：ルータ上のOSPFとMOSPFプロセスモデル]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4 BCMospfLsa
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4 BCMospfLsa
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transition to this state from idle state is executed whenever the condition send_mospf_lsa is true. This state will create Group Membership Link State Advertisement and pack them into Mospf Link State Update Packet. This Mospf Link State Update Packet is sent to IP layer with a destination address of AllSPFRouters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
条件send_mospf_lsaが真である時はいつでもアイドル状態からこの状態への移行が実行されます。この状態は、グループメンバーシップのリンク状態アドバタイズメントを作成し、MOSPFリンクステートアップデートパケットにパックします。このMOSPFリンクステートアップデートパケットがAllSPFRoutersの宛先アドレスとIP層に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5 arr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5 ARR
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The arr state checks the type of packet that is received upon a packet arrival. It calls the following functions depending on the protocol Id of the packet received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ARRの状態は、パケット到着時に受信されるパケットの種類を確認します。これは、パケットのIDを受信したプロトコルに応じて、次の関数を呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. OspfPkPro: Depending on the type of OSPF/MOSPF packet received the function calls the following functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 OspfPkProは：OSPF / MOSPFパケットの種類に応じて関数は次の関数を呼び出しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. HelloPk_pro: This function is called whenever a hello packet is received. This function updates the router&#39;s neighbor information, which is later used while sending the different LSAs. 2. OspfLsUpdatePk_pro: This function is called when an OSPF LSA update packet is received (router LSA, network LSA, or summary LSA). If the Router is an Area Border Router or if the LSA belongs to the Area whose Area Id is the Routers Area Id, then it is searched to determine whether this LSA already exists in the Link State database. If it exists and if the existing LSA&#39;s LS Sequence Number is less than the received LSA&#39;s LS Sequence Number the existing LSA was replaced with the received one. The function processes the Network LSA only if it is a designated router or Area Border Router. It processes the Summary LSA only if the router is a Area Border Router. The function also turns on the trigger ospfspfcalc which is the condition for the transition from arr state to ospfspfcalc. 3. MospfLsUpdatePk_pro: This function is called when a MOSPF LSA update packet is received. It updates the group membership link state database of the router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. HelloPk_proは：helloパケットを受信するたびに、この関数が呼び出されます。この機能は、異なるLSAを送信しているときに、後に使用されているルータのネイバー情報を、更新します。 2. OspfLsUpdatePk_pro：OSPF LSA更新パケットを受信したとき、この関数は、（ルータLSA、ネットワークLSA、または要約LSA）と呼ばれます。ルータはエリア境界ルータであるか、LSAがそのエリア同上ルーターエリア同上あるエリアに属している場合、このLSAは、すでにリンクステートデータベースに存在するかどうかを決定するために検索された場合。それが存在する場合は、既存のLSAのLSシーケンス番号は、受信したLSAのLSシーケンス番号よりも小さい場合、既存のLSAを受信した1つで置換しました。関数は、指定ルータまたはエリア境界ルータである場合にのみ、ネットワークLSAを処理します。これは、ルータがエリア境界ルータである場合にのみ、サマリLSAを処理します。機能はまたospfspfcalcにARR状態から遷移するための条件であるトリガospfspfcalcをオンにします。 3. MospfLsUpdatePk_proは：MOSPF LSA更新パケットを受信したとき、この関数が呼び出されます。これは、ルータのグループメンバーシップリンク状態データベースを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6 hello_pks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6 hello_pks
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hello packets are created and sent with destination address of AllSPFRouters. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
helloパケットが作成され、AllSPFRoutersの宛先アドレスに送信されます。デフォルトのトランジションは、アイドル状態に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7 mospfspfcalc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7 mospfspfcalc
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following functions are used to calculate the shortest path tree and routing table. This state transit to upstr_node upon detupstrnode condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の機能は、最短経路ツリーおよびルーティングテーブルを計算するために使用されます。 detupstrnode条件に応じupstr_nodeするために、この状態遷移します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. CandListInit: Depending upon the SourceNet of the datagram, the candidate lists are initialized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 CandListInit：データグラムのSourceNetに応じて、候補リストが初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. MospfCandAddPro: The vertex link is examined and if the other end of the link is not a stub network and is not already in the candidate list it is added to the candidate list after calculating the cost to that vertex. If this other end of the link is already on the shortest path tree and the calculated cost is less than the one that shows in the shortest path tree entry update the shortest path tree to show the calculated cost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。 MospfCandAddPro：頂点リンクが検討され、リンクのもう一方の端は、スタブネットワークではなく、候補リストにない場合には、その頂点にコストを計算した後、候補リストに追加されます。リンクのこの他端は最短経路木の上にすでに存在すると計算コストが最短パスツリーエントリで示したものよりも小さい場合、計算コストを示すために、最短パスツリーを更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. MospfSPFTreeCalc: The vertex that is closest to the root that is in the candidate list is added to the shortest path tree and its link is considered for possible inclusions in the candidate list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。 MospfSPFTreeCalc：頂点候補リストにあるルートに最も近い最短パスツリーに追加され、そのリンクが候補リストにある可能性介在物のために考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. MCRoutetableCalc: Multicast routing table is calculated using the information of the MOSPF shortest Path tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。 MCRoutetableCalc：マルチキャストルーティングテーブルは、MOSPF最短経路ツリーの情報を使用して計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.8 ospfspfcalc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.8 ospfspfcalc
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following functions are used in this state to calculate the shortest path tree and using this information the routing table. Transition to ospfspfcalc state on ospfcalc condition. This is set to one after processing all functions in the state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の機能は、最短経路ツリーを計算するために、この状態で使用し、この情報をルーティングテーブルを使用しています。 ospfcalc条件に状態をospfspfcalcへの移行。これは、状態のすべての機能を処理した後に1に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. OspfCandidateAddPro: This function initializes the candidate list by examining the link state advertisement of the Router. For each link in this advertisement, if the other end of the link is a router or transit network and if it is not already in the shortest-path tree then calculate the distance between these vertices. If the other end of this link is not already on the candidate list or if the distance calculated is less than the value that appears for this other end add the other end of the link to candidate list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 OspfCandidateAddPro：この機能は、ルータのリンクステートアドバタイズメントを調べることにより、候補リストを初期化します。この広告の各リンクについて、リンクのもう一方の端は、ルータまたはトランジットネットワークであり、それは最短パス木になっていない場合、これらの頂点間の距離を計算する場合。このリンクのもう一方の端は、候補リストの上または算出した距離は、候補リストへのリンクのもう一方の端を追加し、このもう一方の端のために表示される値未満の場合になっていない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. OspfSPTreeBuild: This function pulls each vertex from the candidate list that is closest to the root and adds it to the shortest path tree. In doing so it deletes the vertex from the candidate list. This function continues to do this until the candidate list is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。 OspfSPTreeBuild：この機能は、ルートに最も近いと最短パスツリーに追加候補リストから各頂点を引っ張ります。そうすることで、それは候補リストから頂点を削除します。この関数は、候補リストが空になるまで、これを行うために続けています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. OspfStubLinkPro: In this procedure the stub networks are added to shortest path tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。 OspfStubLinkPro：この手順では、スタブネットワークは、最短経路ツリーに追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. OspfSummaryLinkPro: If the router is an Area Border Router the summary links that it has received is examined. The route to the Area border router advertising this summary LSA is examined in the routing table. If one is found a routing table update is done by adding the route to the network specified in the summary LSA and the cost to this route is sum of the cost to area border router advertising this and the cost to reach this network from that area border router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。 OspfSummaryLinkPro：ルータがエリア境界ルータ、それが検討されて受信したサマリリンクである場合。このサマリーLSAを広告するエリア境界ルータへのルートがルーティングテーブルに検討されています。 1が発見された場合、ルーティングテーブルの更新は要約LSAで指定されたネットワークへのルートを追加することによって行われ、このルートへのコストは、エリア境界ルータ広告に費用やこれや地域の国境からこのネットワークに到達するためのコストの合計ですルータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
e. RoutingTableCalc: This function updates the routing table by examining the shortest path tree data structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電子。 RoutingTableCalc：この関数は、最短経路ツリーデータ構造を調べることによって、ルーティングテーブルを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.9 upstr_node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.9 upstr_node
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state does not do anything in the present model. It transitions to DABRA state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態は、現在のモデルでは何もしません。それはDABRA状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.10 DABRA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.10 DABRA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the router is an Area Border Router and the area is the source area then a DABRA message is constructed and send to all the downstream areas. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルータがエリア境界ルータで、面積はソース領域であれば、DABRAメッセージを構築し、すべての下流域に送信されます。デフォルトのトランジションは、アイドル状態に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. DVMRP Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. DVMRPモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The DVMRP model is implemented based on reference [6], DVMRP version 3. There are nine states. The DVMRP process only exists on Routers. Figure 11 shows the states of the DVMRP process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DVMRPモデルは、基準に基づいて実装されている[6]、DVMRPバージョン3 9州があります。 DVMRPのプロセスは、ルータ上に存在します。図11は、DVMRPプロセスの状態を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 Init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1初期化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Initialize all variables, routing table and forwarding table and load the simulation parameters. It will transit to the Idle state after completing all the initializations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての変数、ルーティングテーブルおよび転送テーブルを初期化し、シミュレーションパラメータをロードします。これは、すべての初期化を完了した後にアイドル状態に遷移するだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 Idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2アイドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The simulation waits for the next scheduled event or remotely invoked event in the Idle State and transit to the state accordingly. In the DVMRP model, Idle State has transitions to Probe_Send, Report_Send, Prune_Send, Graft_Send, Arr_Pkt, Route_Calc and Timer states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シミュレーションは、それに応じて状態に次の予定イベントまたはアイドル状態及び輸送中の遠隔起動イベントを待ちます。 DVMRPモデルでは、アイドル状態はProbe_Send、Report_Send、Prune_Send、Graft_Send、Arr_Pkt、Route_Calcとタイマーの状態への遷移を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Figure 11. DVMRP process on routers]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ルータの図11 DVMRPプロセス]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3 Probe_Send State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3 Probe_Send州
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A DVMRP router sends Probe messages periodically to inform other DVMRP routers that it is operational. A DVMRP router lists all its known neighbors&#39; addresses in the Probe message and sends it to All-DVMRP-Routers address. The routers will not process any message that comes from an unknown neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DVMRPルータは、それが動作している他のDVMRPルータに通知するために定期的にプローブメッセージを送信します。 DVMRPルータは、Probeメッセージ内のすべての既知の隣人のアドレスをリストし、すべての-DVMRP-ルータアドレスに送信します。ルータは、未知の隣人から来ているすべてのメッセージを処理しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4 Report_Send
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4 Report_Send
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To avoid sending Report at the same time for all DVMRP routers, the interval between two Report messages is uniformly distributed with average 60 seconds. The router lists source router&#39;s address, upstream router&#39;s address and metric of all sources into the Report message and sends it to All-DVMRP-Routers address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのDVMRPルータに対して同時にレポートの送信を回避するために、2つのレポートメッセージの間隔を均一に平均60秒で配布されています。ルータは、レポートメッセージにすべてのソースの上流のルータのアドレスとメトリック、ソースルータのアドレスをリストし、すべての-DVMRP-ルーターのアドレスに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5 Prune_Send
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5 Prune_Send
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The transition to this state is triggered by the local IGMP process. When a host on the subnetwork drops from a group, the IGMP process asks DVMRP to see if the branch should be pruned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態への遷移は、ローカルIGMPプロセスによってトリガされます。サブネットワーク上のホストがグループから低下すると、IGMPプロセスは、枝が剪定する必要があるかどうかを確認するためにDVMRPを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The router obtains the group number from IGMP and checks the IP Multicast membership table to find out if there is any group member that is still in the group. If the router determines that the last host has resigned, it goes through the entire forwarding table to locate all sources for that group. The router sends Prune message, containing source address, group address and prune lifetime, separately for each (source, group) pair and records the row as pruned in the forwarding table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルータはIGMPからグループ番号を取得し、グループにまだある任意のグループのメンバーが存在するかどうかを確認するためにIPマルチキャスト・メンバーシップ・テーブルをチェックします。ルータが最後のホストが辞任したと判断した場合、それはそのグループのすべてのソースを見つけるために全体の転送テーブルを通過します。ルータは別々に各（ソース、グループ）ペアについて、送信元アドレス、グループアドレス及びプルーン寿命を含む、プルーンメッセージを送信し、転送テーブルに剪定として行を記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6 Graft_Send
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6 Graft_Send
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The transition to this state is triggered by the local IGMP process. Once a multicast delivery has been pruned, Graft messages are necessary when a host in the local subnetwork joins into the group. A Graft message sent to the upstream router should be acknowledged hop by hop to the root of the tree guaranteeing end-to-end delivery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態への遷移は、ローカルIGMPプロセスによってトリガされます。マルチキャスト配信が剪定された後ローカルサブネットワーク内のホストがグループに参加すると、移植片のメッセージが必要です。上流のルータに送信グラフトメッセージは、ツリー保証エンド・ツー・エンド配信のルートにホップによるホップを認識すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The router obtains the group number from IGMP and go through the forwarding table to locate all traffic sources for that group. A Graft message will be sent to the upstream router with the source address and group address for each (source, group) pair. The router also setups a timer for each Graft message waiting for an acknowledgement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルータはIGMPからグループ番号を取得し、そのグループのすべてのトラフィックソースを見つけるために、転送テーブルを通過します。グラフトメッセージは各（ソース、グループ）ペアのソース・アドレスとグループアドレスと上流のルータに送信します。また、ルータは、確認応答を待っている各グラフトメッセージのタイマーをセットアップ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7 Arr_Pkt
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7 Arr_Pkt
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All DVMRP control messages will be sent up to DVMRP layer by IP. The function performed by the DVMRP layer depends upon the type of the message received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのDVMRP制御メッセージは、IPによってDVMRP層まで送信されます。 DVMRP層によって実行される機能は、受信したメッセージの種類に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. Probe message: The router checks the neighbors&#39; list in Probe message, update its their status to indicate the availability of its neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 Probeメッセージ：ルータは隣人の利用可能性を示すために、その自分のステータスを更新、プローブメッセージで隣人のリストをチェック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. Report message: Based on exchanging report messages, the routers can build the Multicast delivery tree rooted at each source. A function called ReportPkPro will be called to handle all possible situations when receiving a report message. If the message is a poison reverse report and not coming from one of the dependent downstreams, the incoming interface should be added to the router&#39;s downstream list. If the message is not a poison reverse report but it came from one of the downstreams, this interface should be deleted from the downstreams list. And then, the router compared the metric got from the message with the metric of the current upstream, if the new metric is less than the older one, the router&#39;s upstream interface should be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。 Reportメッセージ：レポートメッセージを交換するに基づいて、ルータが各ソースをルートとするマルチキャスト配信ツリーを構築することができます。 ReportPkPro呼び出された関数は、レポートメッセージを受信したときに、すべての可能な状況を処理するために呼び出されます。メッセージはポイズンリバースレポートと従属ダウンストリームの1から来ていない場合は、着信インターフェイスは、ルータの下流のリストに追加する必要があります。メッセージはポイズンリバースレポートではありませんが、それはダウンストリームの1から来た場合は、このインタフェースは、ダウンストリームのリストから削除する必要があります。そして、ルータは新しいメトリックが、ルータのアップストリームインターフェイスが1古い更新する必要があるよりも小さい場合メトリックは、現在の上流のメトリックを持つメッセージから得た比較しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. Prune message: The router extracts the source address, group address and prune lifetime, marks the incoming interface as pruned in the dependent downstream list of the (source, group) pair. If all downstream interfaces have been pruned, the router will send a prune message to its upstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。プルーンメッセージ：ルータは、送信元アドレス、グループアドレス及びプルーン寿命を抽出する（ソース、グループ）ペアの依存下流リストにプルーニングとして着信インターフェイスをマーク。すべてのダウンストリームインターフェイスが剪定されている場合、ルータはその上流にプルーンメッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. Graft message: The router extracts the source and group address, active the incoming interface in the dependent downstream list of the (source, group) pair. If the (source, group) pair has been pruned, the router will reconnect the branch by sending a graft message to its upstream interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。グラフトメッセージ：ルータは、ソースおよびグループアドレスを抽出し、アクティブ（ソース、グループ）ペアの依存下流リストに着信インターフェイス。 （ソース、グループ）ペアがプルーニングされている場合、ルータはアップストリームインタフェースにグラフトメッセージを送信することによって、分岐を再接続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
e. Graft Acknowledge message: The router extracts the source and group address, clear the graft message timer of the (source, group) pair in the forwarding table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電子。移植片は、メッセージ肯定応答：ルータは、ソースとグループアドレスを抽出し、転送テーブルに（ソース、グループ）対のグラフトメッセージタイマをクリア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8 Route_Calc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8 Route_Calc
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The transition to this state is triggered by the local IP process. Once the IP receives a packet, it will fire a remote interrupt to the DVMRP and ask the DVMRP to prepare the outgoing interfaces for the packet. The DVMRP process obtains the packet&#39;s source address and group address from the IP and checks the (source, group) pairs in the forwarding table to decide the branches that have the group members on the Multicast delivery tree. The Group Membership Table on IP will be updated based on this knowledge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態への遷移は、ローカルIPプロセスによってトリガされます。 IPパケットを受信すると、それは、DVMRPへのリモート割り込みを発射し、パケットのために発信インターフェイスを準備するためにDVMRPをお願いします。 DVMRPプロセスは、IPからのパケットの送信元アドレスとグループアドレスを取得し、マルチキャスト配信ツリー上のグループのメンバーを持っている枝を決定する転送テーブルに（ソース、グループ）のペアをチェックします。 IP上のグループメンバーシップ表には、この知見に基づいて更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.9 Timer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.9時間
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This state is activated once every second. It checks the forwarding table, if the Graft message acknowledgment timer is expired, The router will retransmit the Graft message to the upstream. If the prune state lifetime timer is expired, the router will graft this interface so that the downstream router can receive the packets to the group again. The router also checks if the (source, group) pair is pruned by the upstream router, if so, it will send a graft message to the upstream interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この状態が1秒に1回起動されます。これは、転送テーブルをチェックし、グラフトメッセージの確認応答タイマが満了している場合、ルータは上流にグラフトメッセージを再送します。プルーン状態の寿命タイマーが満了している場合は、下流ルータが再びグループにパケットを受信できるように、ルータは、このインターフェイスをグラフトします。したがって、それは上流のインタフェースにグラフトメッセージを送信する場合（ソース、グループ）ペアが、上流のルータによって剪定された場合に、ルータにもチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Simulation performance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.シミュレーション性能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Our simulations of three network models with MOSPF routing have showed good Scalability of the protocol. The running platform we used is a SGI Octane Station with 512 MB main memory and MIPS R10000 CPU, Rev 2.7. Here we list the real running time of each model along with its major elements and the packet inter-arrival times for the streams generated in the hosts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MOSPFルーティングと3つのネットワークモデルの私たちのシミュレーションは、プロトコルの優れたスケーラビリティを示しています。私たちが使用し実行しているプラ​​ットフォームは、512メガバイトのメインメモリとMIPS R10000 CPU、改訂2.7とSGIのOctane駅です。ここでは、その主要な要素とホストで生成されたストリームのパケット間到着時間とともに各モデルの実際の実行時間を一覧表示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Simulated Debug Model Intermediate Model Large Model time 11 Routers 42 routers 86 routers 12 Hosts 48 hosts 96 hosts
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シミュレートされたデバッグモデル中間モデルラージモデル時間11台のルータ42台のルータ86台のルータ12台のホスト48台のホスト96台のホスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Reserve Data         Reserve Data         Reserve Data
                 0.01s                0.02s                 0.02s
           Best-effort Data      Best-effort Data      Best-effort Data
                 0.01s                0.025s               0.025s
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
100 s 3 hours 14 hours 30 hours 200 s 7 hours 30 hours - - -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
100秒、3時間14時間30時間200秒、7時間30時間 -   -   - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Future work
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.今後の課題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We hope to receive assistance from the IPmc/RSVP development community within the IETF in validating and refining this model. We believe it will be a useful tool for predicting the behavior of RSVP-capable systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは、このモデルを検証し、洗練にIETF内IPマルチキャスト/ RSVP開発コミュニティからの支援を受けることを願っています。私たちは、それがRSVP対応システムの挙動を予測するための有用なツールになると考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This RFC raises no security considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このRFCには、セキュリティの考慮事項を提起しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1] Deering, S., &#34;Host Requirements for IP Multicasting&#34;, STD 5, RFC 1112, August 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1]デアリング、S.、 &#34;IPマルチキャスティングのためのホストの要件&#34;、STD 5、RFC 1112、1989年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2] Braden, R., Zhang, L., Berson, S., Herzog, S. and S. Jamin, &#34;Resource Reservation Protocol (RSVP) -- Version 1 Functional Specification&#34;, RFC 2205, September 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2]ブレーデン、R.、チャン、L.、Berson氏、S.、ハーツォグ、S.、およびS.ヤミン、 &#34;リソース予約プロトコル（RSVP） - バージョン1機能仕様&#34;、RFC 2205、1997年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3] Wroclawski, J., &#34;The Use of RSVP with IETF Integrated Services&#34;, RFC 2210, September 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3] Wroclawski、J.、RFC 2210、1997年9月 &#34;IETF統合サービスとRSVPの使用&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4] MIL3 Inc., &#34;OPNET Modeler Tutorial Version 3&#34;, Washington, DC, 1997
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4]、 &#34;OPNET Modelerのチュートリアルバージョン3&#34;、ワシントンD.C.、1997 MIL3株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5] Moy, J., &#34;Multicast Extensions to OSPF&#34;, RFC 1584, March 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5]モイ、J.、 &#34;OSPFへのマルチキャスト拡張機能&#34;、RFC 1584、1994年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[6] Pusateri, T., &#34;Distance Vector Multicast Routing Protocol&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[6] Pusateri、T.、 &#34;距離ベクトルマルチキャストルーティングプロトコル&#34; は進行中で働いています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
J. Mark Pullen C3I Center/Computer Science Mail Stop 4A5 George Mason University Fairfax, VA 22032
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
J.マーク・プーレンC3Iセンター/コンピュータサイエンスのメールストップ4A5ジョージ・メイソン大学フェアファックス、VA 22032
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: mpullen@gmu.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：mpullen@gmu.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ravi Malghan 3141 Fairview Park Drive, Suite 700 Falls Church VA 22042
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ラヴィMalghan 3141フェアビューパークドライブ、スイート700フォールズチャーチVA 22042
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: rmalghan@bacon.gmu.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：rmalghan@bacon.gmu.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Lava K. Lavu Bay Networks 600 Technology Park Dr. Billerica, MA 01821
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
溶岩。二つのネットワーク600 tacanolojiパーク率を持参してください。 Billerike、01821で
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: llavu@bacon.gmu.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：llavu@bacon.gmu.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Gang Duan Oracle Co. Redwood Shores, CA 94065
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ギャングドゥアンオラクル株式会社レッドウッドショア、CA 94065
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: gduan@us.oracle.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：gduan@us.oracle.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jiemei Ma Newbridge Networks Inc. 593 Herndon Parkway Herndon, VA 20170
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jiemei馬ニューブリッジネットワークス株式会社593ハーンドンパークウェイハーンドン、VA 20170
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: jma@newbridge.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：jma@newbridge.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hoon Nah C3I Center Mail Stop 4B5 George Mason University Fairfax, VA 22030
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フンナC3Iセンターメールストップ4B5ジョージ・メイソン大学フェアファックス、VA 22030
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: hnah@bacon.gmu.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：hnah@bacon.gmu.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（1999）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
