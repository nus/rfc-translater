<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 3530 - Network File System (NFS) version 4 Protocol 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3530</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 3530 - Network File System (NFS) version 4 Protocol 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc3530">
              https://tools.ietf.org/html/rfc3530
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 3530 - ネットワークファイルシステム（NFS）バージョン4プロトコル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                         S. Shepler
Request for Comments: 3530                                  B. Callaghan
Obsoletes: 3010                                              D. Robinson
Category: Standards Track                                     R. Thurlow
                                                  Sun Microsystems, Inc.
                                                                C. Beame
                                                        Hummingbird Ltd.
                                                               M. Eisler
                                                               D. Noveck
                                                 Network Appliance, Inc.
                                                              April 2003
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Network File System (NFS) version 4 Protocol
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Network File System (NFS) version 4 is a distributed filesystem protocol which owes heritage to NFS protocol version 2, RFC 1094, and version 3, RFC 1813. Unlike earlier versions, the NFS version 4 protocol supports traditional file access while integrating support for file locking and the mount protocol. In addition, support for strong security (and its negotiation), compound operations, client caching, and internationalization have been added. Of course, attention has been applied to making NFS version 4 operate well in an Internet environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークファイルシステム（NFS）バージョン4分散ファイルシステムNFSプロトコルバージョン2に遺産を負っているプロトコル、RFC 1094、およびバージョン3、以前のバージョンとは異なり、RFC 1813でのサポートを統合しながら、NFSバージョン4プロトコルは、従来のファイルアクセスをサポートファイルのロックとマウントプロトコル。また、強力なセキュリティ（およびその交渉）、化合物の操作、クライアントのキャッシュ、および国際化のためのサポートが追加されました。もちろん、注意はNFSバージョン4は、インターネット環境でも動作させるに適用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document replaces RFC 3010 as the definition of the NFS version 4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、NFSバージョン4プロトコルの定義としてRFC 3010に置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Key Words
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
キーワード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります[RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.   Introduction . . . . . . . . . . . . . . . . . . . . . . .    8
        1.1.  Changes since RFC 3010 . . . . . . . . . . . . . . .    8
        1.2.  NFS version 4 Goals. . . . . . . . . . . . . . . . .    9
        1.3.  Inconsistencies of this Document with Section 18 . .    9
        1.4.  Overview of NFS version 4 Features . . . . . . . . .   10
              1.4.1.  RPC and Security . . . . . . . . . . . . . .   10
              1.4.2.  Procedure and Operation Structure. . . . . .   10
              1.4.3.  Filesystem Mode. . . . . . . . . . . . . . .   11
                      1.4.3.1.  Filehandle Types . . . . . . . . .   11
                      1.4.3.2.  Attribute Types. . . . . . . . . .   12
                      1.4.3.3.  Filesystem Replication and
                                Migration. . . . . . . . . . . . .   13
              1.4.4.  OPEN and CLOSE . . . . . . . . . . . . . . .   13
              1.4.5.  File locking . . . . . . . . . . . . . . . .   13
              1.4.6.  Client Caching and Delegation. . . . . . . .   13
        1.5.  General Definitions. . . . . . . . . . . . . . . . .   14
   2.   Protocol Data Types. . . . . . . . . . . . . . . . . . . .   16
        2.1.  Basic Data Types . . . . . . . . . . . . . . . . . .   16
        2.2.  Structured Data Types. . . . . . . . . . . . . . . .   18
   3.   RPC and Security Flavor. . . . . . . . . . . . . . . . . .   23
        3.1.  Ports and Transports . . . . . . . . . . . . . . . .   23
              3.1.1.  Client Retransmission Behavior . . . . . . .   24
        3.2.  Security Flavors . . . . . . . . . . . . . . . . . .   25
              3.2.1.  Security mechanisms for NFS version 4. . . .   25
                      3.2.1.1.  Kerberos V5 as a security triple .   25
                      3.2.1.2.  LIPKEY as a security triple. . . .   26
                      3.2.1.3.  SPKM-3 as a security triple. . . .   27
        3.3.  Security Negotiation . . . . . . . . . . . . . . . .   27
              3.3.1.  SECINFO. . . . . . . . . . . . . . . . . . .   28
              3.3.2.  Security Error . . . . . . . . . . . . . . .   28
        3.4.  Callback RPC Authentication. . . . . . . . . . . . .   28
   4.  Filehandles . . . . . . . . . . . . . . . . . . . . . . . .   30
        4.1.  Obtaining the First Filehandle . . . . . . . . . . .   30
              4.1.1.  Root Filehandle. . . . . . . . . . . . . . .   31
              4.1.2.  Public Filehandle. . . . . . . . . . . . . .   31
        4.2.  Filehandle Types . . . . . . . . . . . . . . . . . .   31
              4.2.1.  General Properties of a Filehandle . . . . .   32
              4.2.2.  Persistent Filehandle. . . . . . . . . . . .   32
              4.2.3.  Volatile Filehandle. . . . . . . . . . . . .   33
              4.2.4.  One Method of Constructing a
                      Volatile Filehandle. . . . . . . . . . . . .   34
        4.3.  Client Recovery from Filehandle Expiration . . . . .   35
   5.   File Attributes. . . . . . . . . . . . . . . . . . . . . .   35
        5.1.  Mandatory Attributes . . . . . . . . . . . . . . . .   37
        5.2.  Recommended Attributes . . . . . . . . . . . . . . .   37
        5.3.  Named Attributes . . . . . . . . . . . . . . . . . .   37
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        5.4.  Classification of Attributes . . . . . . . . . . . .   38
        5.5.  Mandatory Attributes - Definitions . . . . . . . . .   39
        5.6.  Recommended Attributes - Definitions . . . . . . . .   41
        5.7.  Time Access. . . . . . . . . . . . . . . . . . . . .   46
        5.8.  Interpreting owner and owner_group . . . . . . . . .   47
        5.9.  Character Case Attributes. . . . . . . . . . . . . .   49
        5.10. Quota Attributes . . . . . . . . . . . . . . . . . .   49
        5.11. Access Control Lists . . . . . . . . . . . . . . . .   50
               5.11.1.  ACE type . . . . . . . . . . . . . . . . .   51
               5.11.2.  ACE Access Mask. . . . . . . . . . . . . .   52
               5.11.3.  ACE flag . . . . . . . . . . . . . . . . .   54
               5.11.4.  ACE who  . . . . . . . . . . . . . . . . .   55
               5.11.5.  Mode Attribute . . . . . . . . . . . . . .   56
               5.11.6.  Mode and ACL Attribute . . . . . . . . . .   57
               5.11.7.  mounted_on_fileid. . . . . . . . . . . . .   57
   6.  Filesystem Migration and Replication  . . . . . . . . . . .   58
        6.1.  Replication. . . . . . . . . . . . . . . . . . . . .   58
        6.2.  Migration. . . . . . . . . . . . . . . . . . . . . .   59
        6.3.  Interpretation of the fs_locations Attribute . . . .   60
        6.4.  Filehandle Recovery for Migration or Replication . .   61
   7.  NFS Server Name Space . . . . . . . . . . . . . . . . . . .   61
        7.1.  Server Exports . . . . . . . . . . . . . . . . . . .   61
        7.2.  Browsing Exports . . . . . . . . . . . . . . . . . .   62
        7.3.  Server Pseudo Filesystem . . . . . . . . . . . . . .   62
        7.4.  Multiple Roots . . . . . . . . . . . . . . . . . . .   63
        7.5.  Filehandle Volatility. . . . . . . . . . . . . . . .   63
        7.6.  Exported Root. . . . . . . . . . . . . . . . . . . .   63
        7.7.  Mount Point Crossing . . . . . . . . . . . . . . . .   63
        7.8.  Security Policy and Name Space Presentation. . . . .   64
   8.   File Locking and Share Reservations. . . . . . . . . . . .   65
        8.1.  Locking. . . . . . . . . . . . . . . . . . . . . . .   65
              8.1.1.    Client ID. . . . . . . . . . . . . . . . .   66
              8.1.2.    Server Release of Clientid . . . . . . . .   69
              8.1.3.    lock_owner and stateid Definition. . . . .   69
              8.1.4.    Use of the stateid and Locking . . . . . .   71
              8.1.5.    Sequencing of Lock Requests. . . . . . . .   73
              8.1.6.    Recovery from Replayed Requests. . . . . .   74
              8.1.7.    Releasing lock_owner State . . . . . . . .   74
              8.1.8.    Use of Open Confirmation . . . . . . . . .   75
        8.2.  Lock Ranges. . . . . . . . . . . . . . . . . . . . .   76
        8.3.  Upgrading and Downgrading Locks. . . . . . . . . . .   76
        8.4.  Blocking Locks . . . . . . . . . . . . . . . . . . .   77
        8.5.  Lease Renewal. . . . . . . . . . . . . . . . . . . .   77
        8.6.  Crash Recovery . . . . . . . . . . . . . . . . . . .   78
               8.6.1.   Client Failure and Recovery. . . . . . . .   79
               8.6.2.   Server Failure and Recovery. . . . . . . .   79
               8.6.3.   Network Partitions and Recovery. . . . . .   81
        8.7.   Recovery from a Lock Request Timeout or Abort . . .   85
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        8.8.   Server Revocation of Locks. . . . . . . . . . . . .   85
        8.9.   Share Reservations. . . . . . . . . . . . . . . . .   86
        8.10.  OPEN/CLOSE Operations . . . . . . . . . . . . . . .   87
               8.10.1.  Close and Retention of State
                        Information. . . . . . . . . . . . . . . .   88
        8.11.  Open Upgrade and Downgrade. . . . . . . . . . . . .   88
        8.12.  Short and Long Leases . . . . . . . . . . . . . . .   89
        8.13.  Clocks, Propagation Delay, and Calculating Lease
               Expiration. . . . . . . . . . . . . . . . . . . . .   89
        8.14.  Migration, Replication and State. . . . . . . . . .   90
               8.14.1.  Migration and State. . . . . . . . . . . .   90
               8.14.2.  Replication and State. . . . . . . . . . .   91
               8.14.3.  Notification of Migrated Lease . . . . . .   92
               8.14.4.  Migration and the Lease_time Attribute . .   92
   9.  Client-Side Caching . . . . . . . . . . . . . . . . . . . .   93
        9.1.   Performance Challenges for Client-Side Caching. . .   93
        9.2.   Delegation and Callbacks. . . . . . . . . . . . . .   94
               9.2.1.  Delegation Recovery . . . . . . . . . . . .   96
        9.3.   Data Caching. . . . . . . . . . . . . . . . . . . .   98
               9.3.1.   Data Caching and OPENs . . . . . . . . . .   98
               9.3.2.   Data Caching and File Locking. . . . . . .   99
               9.3.3.   Data Caching and Mandatory File Locking. .  101
               9.3.4.   Data Caching and File Identity . . . . . .  101
        9.4.   Open Delegation . . . . . . . . . . . . . . . . . .  102
               9.4.1.   Open Delegation and Data Caching . . . . .  104
               9.4.2.   Open Delegation and File Locks . . . . . .  106
               9.4.3.   Handling of CB_GETATTR . . . . . . . . . .  106
               9.4.4.   Recall of Open Delegation. . . . . . . . .  109
               9.4.5.   Clients that Fail to Honor
                        Delegation Recalls . . . . . . . . . . . .  111
               9.4.6.   Delegation Revocation. . . . . . . . . . .  112
        9.5.   Data Caching and Revocation . . . . . . . . . . . .  112
               9.5.1.   Revocation Recovery for Write Open
                        Delegation . . . . . . . . . . . . . . . .  113
        9.6.   Attribute Caching . . . . . . . . . . . . . . . . .  113
        9.7.   Data and Metadata Caching and Memory Mapped Files .  115
        9.8.   Name Caching  . . . . . . . . . . . . . . . . . . .  118
        9.9.   Directory Caching . . . . . . . . . . . . . . . . .  119
   10.  Minor Versioning . . . . . . . . . . . . . . . . . . . . .  120
   11.  Internationalization . . . . . . . . . . . . . . . . . . .  122
        11.1.  Stringprep profile for the utf8str_cs type. . . . .  123
               11.1.1.  Intended applicability of the
                        nfs4_cs_prep profile . . . . . . . . . . .  123
               11.1.2.  Character repertoire of nfs4_cs_prep . . .  124
               11.1.3.  Mapping used by nfs4_cs_prep . . . . . . .  124
               11.1.4.  Normalization used by nfs4_cs_prep . . . .  124
               11.1.5.  Prohibited output for nfs4_cs_prep . . . .  125
               11.1.6.  Bidirectional output for nfs4_cs_prep. . .  125
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        11.2.  Stringprep profile for the utf8str_cis type . . . .  125
               11.2.1.  Intended applicability of the
                        nfs4_cis_prep profile. . . . . . . . . . .  125
               11.2.2.  Character repertoire of nfs4_cis_prep  . .  125
               11.2.3.  Mapping used by nfs4_cis_prep  . . . . . .  125
               11.2.4.  Normalization used by nfs4_cis_prep  . . .  125
               11.2.5.  Prohibited output for nfs4_cis_prep  . . .  126
               11.2.6.  Bidirectional output for nfs4_cis_prep . .  126
        11.3.  Stringprep profile for the utf8str_mixed type . . .  126
               11.3.1.  Intended applicability of the
                        nfs4_mixed_prep profile. . . . . . . . . .  126
               11.3.2.  Character repertoire of nfs4_mixed_prep  .  126
               11.3.3.  Mapping used by nfs4_cis_prep  . . . . . .  126
               11.3.4.  Normalization used by nfs4_mixed_prep  . .  127
               11.3.5.  Prohibited output for nfs4_mixed_prep  . .  127
               11.3.6.  Bidirectional output for nfs4_mixed_prep .  127
        11.4.  UTF-8 Related Errors. . . . . . . . . . . . . . . .  127
   12.  Error Definitions  . . . . . . . . . . . . . . . . . . . .  128
   13.  NFS version 4 Requests . . . . . . . . . . . . . . . . . .  134
        13.1.  Compound Procedure. . . . . . . . . . . . . . . . .  134
        13.2.  Evaluation of a Compound Request. . . . . . . . . .  135
        13.3.  Synchronous Modifying Operations. . . . . . . . . .  136
        13.4.  Operation Values. . . . . . . . . . . . . . . . . .  136
   14.  NFS version 4 Procedures . . . . . . . . . . . . . . . . .  136
        14.1.  Procedure 0: NULL - No Operation. . . . . . . . . .  136
        14.2.  Procedure 1: COMPOUND - Compound Operations . . . .  137
               14.2.1.   Operation 3: ACCESS - Check Access
                         Rights. . . . . . . . . . . . . . . . . .  140
               14.2.2.   Operation 4: CLOSE - Close File . . . . .  142
               14.2.3.   Operation 5: COMMIT - Commit
                         Cached Data . . . . . . . . . . . . . . .  144
               14.2.4.   Operation 6: CREATE - Create a
                         Non-Regular File Object . . . . . . . . .  147
               14.2.5.   Operation 7: DELEGPURGE -
                         Purge Delegations Awaiting Recovery . . .  150
               14.2.6.   Operation 8: DELEGRETURN - Return
                         Delegation. . . . . . . . . . . . . . . .  151
               14.2.7.   Operation 9: GETATTR - Get Attributes . .  152
               14.2.8.   Operation 10: GETFH - Get Current
                         Filehandle. . . . . . . . . . . . . . . .  153
               14.2.9.   Operation 11: LINK - Create Link to a
                         File. . . . . . . . . . . . . . . . . . .  154
               14.2.10.  Operation 12: LOCK - Create Lock  . . . .  156
               14.2.11.  Operation 13: LOCKT - Test For Lock . . .  160
               14.2.12.  Operation 14: LOCKU - Unlock File . . . .  162
               14.2.13.  Operation 15: LOOKUP - Lookup Filename. .  163
               14.2.14.  Operation 16: LOOKUPP - Lookup
                         Parent Directory. . . . . . . . . . . . .  165
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               14.2.15.  Operation 17: NVERIFY - Verify
                         Difference in Attributes  . . . . . . . .  166
               14.2.16.  Operation 18: OPEN - Open a Regular
                         File. . . . . . . . . . . . . . . . . . .  168
               14.2.17.  Operation 19: OPENATTR - Open Named
                         Attribute Directory . . . . . . . . . . .  178
               14.2.18.  Operation 20: OPEN_CONFIRM -
                         Confirm Open . . . . . . . . . . . . . .   180
               14.2.19.  Operation 21: OPEN_DOWNGRADE -
                         Reduce Open File Access . . . . . . . . .  182
               14.2.20.  Operation 22: PUTFH - Set
                         Current Filehandle. . . . . . . . . . . .  184
               14.2.21.  Operation 23: PUTPUBFH -
                         Set Public Filehandle . . . . . . . . . .  185
               14.2.22.  Operation 24: PUTROOTFH -
                         Set Root Filehandle . . . . . . . . . . .  186
               14.2.23.  Operation 25: READ - Read from File . . .  187
               14.2.24.  Operation 26: READDIR -
                         Read Directory. . . . . . . . . . . . . .  190
               14.2.25.  Operation 27: READLINK -
                         Read Symbolic Link. . . . . . . . . . . .  193
               14.2.26.  Operation 28: REMOVE -
                         Remove Filesystem Object. . . . . . . . .  195
               14.2.27.  Operation 29: RENAME -
                         Rename Directory Entry. . . . . . . . . .  197
               14.2.28.  Operation 30: RENEW - Renew a Lease . . .  200
               14.2.29.  Operation 31: RESTOREFH -
                         Restore Saved Filehandle. . . . . . . . .  201
               14.2.30.  Operation 32: SAVEFH - Save
                         Current Filehandle. . . . . . . . . . . .  202
               14.2.31.  Operation 33: SECINFO - Obtain
                         Available Security. . . . . . . . . . . .  203
               14.2.32.  Operation 34: SETATTR - Set Attributes. .  206
               14.2.33.  Operation 35: SETCLIENTID -
                         Negotiate Clientid. . . . . . . . . . . .  209
               14.2.34.  Operation 36: SETCLIENTID_CONFIRM -
                         Confirm Clientid. . . . . . . . . . . . .  213
               14.2.35.  Operation 37: VERIFY -
                         Verify Same Attributes. . . . . . . . . .  217
               14.2.36.  Operation 38: WRITE - Write to File . . .  218
               14.2.37.  Operation 39: RELEASE_LOCKOWNER -
                         Release Lockowner State . . . . . . . . .  223
               14.2.38.  Operation 10044: ILLEGAL -
                         Illegal operation . . . . . . . . . . . .  224
   15.  NFS version 4 Callback Procedures  . . . . . . . . . . . .  225
        15.1.  Procedure 0: CB_NULL - No Operation . . . . . . . .  225
        15.2.  Procedure 1: CB_COMPOUND - Compound
               Operations. . . . . . . . . . . . . . . . . . . . .  226
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               15.2.1.  Operation 3: CB_GETATTR - Get
                        Attributes . . . . . . . . . . . . . . . .  228
               15.2.2.  Operation 4: CB_RECALL -
                        Recall an Open Delegation. . . . . . . . .  229
               15.2.3.  Operation 10044: CB_ILLEGAL -
                        Illegal Callback Operation . . . . . . . .  230
   16.  Security Considerations  . . . . . . . . . . . . . . . . .  231
   17.  IANA Considerations  . . . . . . . . . . . . . . . . . . .  232
        17.1.  Named Attribute Definition. . . . . . . . . . . . .  232
        17.2.  ONC RPC Network Identifiers (netids). . . . . . . .  232
   18.  RPC definition file  . . . . . . . . . . . . . . . . . . .  234
   19.  Acknowledgements . . . . . . . . . . . . . . . . . . . . .  268
   20.  Normative References . . . . . . . . . . . . . . . . . . .  268
   21.  Informative References . . . . . . . . . . . . . . . . . .  270
   22.  Authors&#39; Information . . . . . . . . . . . . . . . . . . .  273
        22.1.  Editor&#39;s Address. . . . . . . . . . . . . . . . . .  273
        22.2.  Authors&#39; Addresses. . . . . . . . . . . . . . . . .  274
   23.  Full Copyright Statement . . . . . . . . . . . . . . . . .  275
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Changes since 
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。以下からの変更点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This definition of the NFS version 4 protocol replaces or obsoletes the definition present in [RFC3010]. While portions of the two documents have remained the same, there have been substantive changes in others. The changes made between [RFC3010] and this document represent implementation experience and further review of the protocol. While some modifications were made for ease of implementation or clarification, most updates represent errors or situations where the [RFC3010] definition were untenable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルのこの定義は、[RFC3010]に存在する定義に取って代わるか、時代遅れ。二つの文書の部分は同じままであるが、他の人では実質的な変更がありました。 [RFC3010]の間で行われた変更と、この文書は、実装経験とプロトコルのさらなる見直しを表します。いくつかの変更を実装または説明を容易にするためになされたが、ほとんどの更新は、[RFC3010]の定義は理不尽たエラーまたは状況を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following list is not all inclusive of all changes but presents some of the most notable changes or additions made:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のリストは、すべての変更の全てを含んでいませんが、作られた最も顕著な変更または追加のいくつかを提示します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state model has added an open_owner4 identifier. This was done to accommodate Posix based clients and the model they use for file locking. For Posix clients, an open_owner4 would correspond to a file descriptor potentially shared amongst a set of processes and the lock_owner4 identifier would correspond to a process that is locking a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O状態モデルはopen_owner4識別子を追加しました。これは、POSIXのベースのクライアントと、彼らはファイルのロックに使用するモデルに対応するために行われました。 Posixクライアントの場合、open_owner4は、潜在的に一連のプロセス間で共有ファイル記述子に対応するであろうとlock_owner4識別子は、ファイルをロックしているプロセスに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clarifications and error conditions were added for the handling of the owner and group attributes. Since these attributes are string based (as opposed to the numeric uid/gid of previous versions of NFS), translations may not be available and hence the changes made.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O明確化及びエラー状態が所有者とグループの属性の処理のために添加しました。これらの属性は、文字列ベース（NFSの以前のバージョンの数値のUID / GIDとは対照的に）であるので、翻訳が利用できない場合があり、したがって、変更が行わ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clarifications for the ACL and mode attributes to address evaluation and partial support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O ACLおよびモードのための明確化は、評価や部分的なサポートに対処するための属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For identifiers that are defined as XDR opaque, limits were set on their size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XDR不透明、制限は、その大きさに設定されたように定義される識別子のO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Added the mounted_on_filed attribute to allow Posix clients to correctly construct local mounts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのPosixクライアントが正しくローカルマウントを構築できるようにするためにmounted_on_filed属性が追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Modified the SETCLIENTID/SETCLIENTID_CONFIRM operations to deal correctly with confirmation details along with adding the ability to specify new client callback information. Also added clarification of the callback information itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O新しいクライアントコールバックの情報を指定する機能を追加するとともに、確認の詳細を正しく対処するSETCLIENTID / SETCLIENTID_CONFIRM操作を修正。また、コールバック情報自体の明確化を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Added a new operation LOCKOWNER_RELEASE to enable notifying the server that a lock_owner4 will no longer be used by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O lock_owner4は、もはやクライアントによって使用されることはありませんサーバーに通知有効にするために、新たな操作LOCKOWNER_RELEASEを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENEW operation changes to identify the client correctly and allow for additional error returns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O正しくクライアントを識別し、追加のエラーリターンを可能にするための動作の変更を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Verify error return possibilities for all operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oすべての操作のエラーリターンの可能性を確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Remove use of the pathname4 data type from LOOKUP and OPEN in favor of having the client construct a sequence of LOOKUP operations to achieive the same effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントが同じ効果をachieiveするLOOKUP動作のシーケンスを構築したの賛成でLOOKUPとOPENからpathname4データ型の使用を削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clarification of the internationalization issues and adoption of the new stringprep profile framework.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O国際問題の明確化と新しい文字列準備プロフィールフレームワークの採用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. NFS Version 4 Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。 NFSバージョン4つの目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol is a further revision of the NFS protocol defined already by versions 2 [RFC1094] and 3 [RFC1813]. It retains the essential characteristics of previous versions: design for easy recovery, independent of transport protocols, operating systems and filesystems, simplicity, and good performance. The NFS version 4 revision has the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコル、バージョン2 [RFC1094]及び3 [RFC1813]で既に定義されたNFSプロトコルのさらなるリビジョンです。簡単に回復のための設計、トランスポートプロトコル、オペレーティングシステムとファイルシステムの独立した、シンプルさ、および良好なパフォーマンス：これは、以前のバージョンの本質的な特徴を保持します。 NFSバージョン4改訂は、次の目標を持っています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Improved access and good performance on the Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O、インターネット上のアクセスと優れたパフォーマンスを改善しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol is designed to transit firewalls easily, perform well where latency is high and bandwidth is low, and scale to very large numbers of clients per server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プロトコルは、レイテンシが高く、帯域幅が低い場合も実行し、簡単にトランジットのファイアウォールに設計されており、サーバーあたりのクライアントの規模に非常に大きな数字です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Strong security with negotiation built into the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O交渉を持つ強力なセキュリティプロトコルに組み込まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol builds on the work of the ONCRPC working group in supporting the RPCSEC_GSS protocol. Additionally, the NFS version 4 protocol provides a mechanism to allow clients and servers the ability to negotiate security and require clients and servers to support a minimal set of security schemes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プロトコルは、RPCSEC_GSSプロトコルをサポートするONCRPCワーキンググループの作業に基づいています。また、NFSバージョン4プロトコルは、クライアントとサーバにセキュリティをネゴシエートし、セキュリティ方式の最小セットをサポートするために、クライアントとサーバーを必要とする機能を許可するためのメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Good cross-platform interoperability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oグッドクロスプラットフォームの相互運用性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol features a filesystem model that provides a useful, common set of features that does not unduly favor one filesystem or operating system over another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プロトコルは不当に別の上で1つのファイルシステムまたはオペレーティングシステムを支持していない機能の便利な、共通セットを提供し、ファイルシステムのモデルを提供しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Designed for protocol extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oプロトコルの拡張のために設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The protocol is designed to accept standard extensions that do not compromise backward compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プロトコルは、下位互換性を損なわない標準の拡張を受け入れるように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Inconsistencies of this Document with 
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3。このドキュメントとの不整合
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 18, RPC Definition File, contains the definitions in XDR description language of the constructs used by the protocol. Prior to Section 18, several of the constructs are reproduced for purposes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第18条、RPC定義ファイルは、プロトコルが使用する構文のXDR記述言語で定義が含まれています。第18条に先立ち、コンストラクトのいくつかは、目的のために再現されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
of explanation. The reader is warned of the possibility of errors in the reproduced constructs outside of Section 18. For any part of the document that is inconsistent with Section 18, Section 18 is to be considered authoritative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
説明の。読者は、セクション18、セクション18と一致しない文書の任意の部分については、セクション18の外側再生構築物におけるエラーの可能性を警告されている権威あるとみなされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Overview of NFS version 4 Features
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4。 NFSバージョン4の機能の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide a reasonable context for the reader, the major features of NFS version 4 protocol will be reviewed in brief. This will be done to provide an appropriate context for both the reader who is familiar with the previous versions of the NFS protocol and the reader that is new to the NFS protocols. For the reader new to the NFS protocols, there is still a fundamental knowledge that is expected. The reader should be familiar with the XDR and RPC protocols as described in [RFC1831] and [RFC1832]. A basic knowledge of filesystems and distributed filesystems is expected as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読者のための合理的なコンテキストを提供するために、NFSバージョン4プロトコルの主な機能は、簡単に審査されます。これは、NFSプロトコルとNFSプロトコルに新しく追加され、リーダの以前のバージョンに精通している読者の両方のために適切なコンテキストを提供するために行われます。 NFSプロトコルへの新しい読者のために、期待されている基本的な知識がまだあります。 [RFC1831]及び[RFC1832]に記載されているように、リーダはXDRとRPCプロトコルに精通しなければなりません。ファイルシステムと分散ファイルシステムの基本的な知識も同様に期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1. RPC and Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.1。 RPCとセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with previous versions of NFS, the External Data Representation (XDR) and Remote Procedure Call (RPC) mechanisms used for the NFS version 4 protocol are those defined in [RFC1831] and [RFC1832]. To meet end to end security requirements, the RPCSEC_GSS framework [RFC2203] will be used to extend the basic RPC security. With the use of RPCSEC_GSS, various mechanisms can be provided to offer authentication, integrity, and privacy to the NFS version 4 protocol. Kerberos V5 will be used as described in [RFC1964] to provide one security framework. The LIPKEY GSS-API mechanism described in [RFC2847] will be used to provide for the use of user password and server public key by the NFS version 4 protocol. With the use of RPCSEC_GSS, other mechanisms may also be specified and used for NFS version 4 security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSの以前のバージョンと同様に、NFSバージョン4プロトコルのために使用される外部データ表現（XDR）とリモートプロシージャコール（RPC）メカニズムは、[RFC1831]及び[RFC1832]で定義されたものです。セキュリティ要件をエンドツーエンドを満たすために、RPCSEC_GSSフレームワーク[RFC2203]は、基本的なRPCセキュリティを拡張するために使用されます。 RPCSEC_GSSを使用すると、さまざまなメカニズムはNFSバージョン4プロトコルに認証、整合性、およびプライバシーを提供するために提供することができます。 [RFC1964]に記載されているようにケルベロスV5は、一つのセキュリティフレームワークを提供するために使用されます。 [RFC2847]に記載LIPKEY GSS-API機構は、NFSバージョン4プロトコルによってユーザパスワード及びサーバ公開鍵の使用を提供するために使用されるであろう。 RPCSEC_GSSを使用して、他のメカニズムも指定することができ、NFSバージョン4セキュリティのために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To enable in-band security negotiation, the NFS version 4 protocol has added a new operation which provides the client a method of querying the server about its policies regarding which security mechanisms must be used for access to the server&#39;s filesystem resources. With this, the client can securely match the security mechanism that meets the policies specified at both the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インバンドセキュリティネゴシエーションを有効にするには、NFSバージョン4プロトコルは、クライアントにセキュリティメカニズムは、サーバのファイルシステムリソースへのアクセスに使用する必要がありますについての方針についてのサーバーを照会する方法を提供し、新しい操作を追加しました。これにより、クライアントが安全に、クライアントとサーバの両方で指定したポリシーを満たしているセキュリティ・メカニズムを一致させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2. Procedure and Operation Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.2。手順や運用体制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A significant departure from the previous versions of the NFS protocol is the introduction of the COMPOUND procedure. For the NFS version 4 protocol, there are two RPC procedures, NULL and COMPOUND. The COMPOUND procedure is defined in terms of operations and these operations correspond more closely to the traditional NFS procedures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの旧バージョンからの有意な逸脱は、化合物処置の導入です。 NFSバージョン4プロトコル、二つRPC手順、NULLおよび化合物があります。 COMPOUND手順は動作の観点から定義され、これらの動作は、従来のNFSの手順をより密接に対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the use of the COMPOUND procedure, the client is able to build simple or complex requests. These COMPOUND requests allow for a reduction in the number of RPCs needed for logical filesystem operations. For example, without previous contact with a server a client will be able to read data from a file in one request by combining LOOKUP, OPEN, and READ operations in a single COMPOUND RPC. With previous versions of the NFS protocol, this type of single request was not possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順を使用すると、クライアントは、単純または複雑な要求を構築することができます。これらの化合物の要求は、論理ファイルシステム操作のために必要なRPCの数の減少を可能とします。たとえば、サーバーとの以前の接触せずに、クライアントは、単一の化合物のRPCでLOOKUP、OPEN、およびREAD操作を組み合わせることにより、一つのリクエストでファイルからデータを読み取ることができるようになります。 NFSプロトコルの以前のバージョンでは、単一の要求のこのタイプは不可能でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model used for COMPOUND is very simple. There is no logical OR or ANDing of operations. The operations combined within a COMPOUND request are evaluated in order by the server. Once an operation returns a failing result, the evaluation ends and the results of all evaluated operations are returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
化合物に対して使用されるモデルは非常に単純です。操作の論理的ORまたはAND演算はありません。複合要求内で組み合わせる操作はサーバ順に評価されます。操作が失敗し、結果を返した後、評価が終了し、全ての評価の操作の結果がクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol continues to have the client refer to a file or directory at the server by a &#34;filehandle&#34;. The COMPOUND procedure has a method of passing a filehandle from one operation to another within the sequence of operations. There is a concept of a &#34;current filehandle&#34; and &#34;saved filehandle&#34;. Most operations use the &#34;current filehandle&#34; as the filesystem object to operate upon. The &#34;saved filehandle&#34; is used as temporary filehandle storage within a COMPOUND procedure as well as an additional operand for certain operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、クライアントが「ファイルハンドル」により、サーバーにあるファイルまたはディレクトリを参照する必要があり続けています。 COMPOUND手順は動作のシーケンス内の別の操作からファイルハンドルを渡す方法を有します。 「現在のファイルハンドル」と「保存されたファイルハンドル」の概念があります。ほとんどの操作は、時に動作するファイルシステムオブジェクトとして「現在のファイルハンドル」を使用します。 「保存されたファイルハンドルは、」COMPOUND手順内の一時ファイルハンドルの保存だけでなく、特定の操作のための追加のオペランドとして使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3. Filesystem Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3。ファイルシステムモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general filesystem model used for the NFS version 4 protocol is the same as previous versions. The server filesystem is hierarchical with the regular files contained within being treated as opaque byte streams. In a slight departure, file and directory names are encoded with UTF-8 to deal with the basics of internationalization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルに使用される一般的なファイルシステム・モデルは、以前のバージョンと同じです。サーバーのファイルシステムは、不透明なバイトストリームとして処理されている内に含まれ、通常のファイルと階層的です。若干の出発では、ファイル名やディレクトリ名は、国際化の基礎に対処するためにUTF-8でエンコードされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol does not require a separate protocol to provide for the initial mapping between path name and filehandle. Instead of using the older MOUNT protocol for this mapping, the server provides a ROOT filehandle that represents the logical root or top of the filesystem tree provided by the server. The server provides multiple filesystems by gluing them together with pseudo filesystems. These pseudo filesystems provide for potential gaps in the path names between real filesystems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、パス名とファイルハンドルとの間の最初のマッピングを提供するために、別のプロトコルを必要としません。代わりに、このマッピングの古いMOUNTプロトコルを使用する、サーバは、サーバが提供するファイルシステムのツリーの論理ルート又はトップを表すROOTファイルハンドルを提供します。サーバーは、擬似ファイルシステムでそれらを一緒に接着することによって、複数のファイルシステムを提供します。これらの疑似ファイルシステムは、実際のファイルシステム間のパス名の潜在的なギャップを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.1. Filehandle Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.1。ファイルハンドルタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In previous versions of the NFS protocol, the filehandle provided by the server was guaranteed to be valid or persistent for the lifetime of the filesystem object to which it referred. For some server implementations, this persistence requirement has been difficult to meet. For the NFS version 4 protocol, this requirement has been relaxed by introducing another type of filehandle, volatile. With persistent and volatile filehandle types, the server implementation can match the abilities of the filesystem at the server along with the operating environment. The client will have knowledge of the type of filehandle being provided by the server and can be prepared to deal with the semantics of each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの旧バージョンでは、サーバによって提供されるファイルハンドルは、それが呼ばれるファイルシステム・オブジェクトの寿命のために有効または永続的であることが保証されました。いくつかのサーバ実装では、この永続性要件は満たすことが困難でした。 NFSバージョン4プロトコルのために、この要求はファイルハンドル、揮発性の他の種類を導入することによって緩和されています。持続的かつ揮発性ファイルハンドルタイプでは、サーバの実装は、動作環境と一緒にサーバーでのファイルシステムの能力を一致させることができます。クライアントは、サーバによって提供されているファイルハンドルのタイプについての知識を持つことになりますし、それぞれのセマンティクスを扱うように調製することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.2. Attribute Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.2。属性タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol introduces three classes of filesystem or file attributes. Like the additional filehandle type, the classification of file attributes has been done to ease server implementations along with extending the overall functionality of the NFS protocol. This attribute model is structured to be extensible such that new attributes can be introduced in minor revisions of the protocol without requiring significant rework.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、ファイルシステムやファイル属性の3つのクラスが導入されました。追加のファイルハンドルタイプと同様に、ファイル属性の分類は、NFSプロトコルの全体的な機能を拡張するとともに、サーバの実装を容易にするために行われてきました。この属性モデルは、新たな属性が大幅に手直しを必要とせずに、プロトコルのマイナーリビジョンで導入することができるように拡張できるように構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The three classifications are: mandatory, recommended and named attributes. This is a significant departure from the previous attribute model used in the NFS protocol. Previously, the attributes for the filesystem and file objects were a fixed set of mainly UNIX attributes. If the server or client did not support a particular attribute, it would have to simulate the attribute the best it could.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つの分類があります：必須、推奨と命名された属性。これは、NFSプロトコルで使用される前の属性モデルから大幅に逸脱しています。以前は、ファイルシステムとファイルオブジェクトの属性は、主にUNIX属性の固定セットでした。サーバーまたはクライアントが特定の属性をサポートしていなかった場合、それは属性にそれはできる最善をシミュレートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mandatory attributes are the minimal set of file or filesystem attributes that must be provided by the server and must be properly represented by the server. Recommended attributes represent different filesystem types and operating environments. The recommended attributes will allow for better interoperability and the inclusion of more operating environments. The mandatory and recommended attribute sets are traditional file or filesystem attributes. The third type of attribute is the named attribute. A named attribute is an opaque byte stream that is associated with a directory or file and referred to by a string name. Named attributes are meant to be used by client applications as a method to associate application specific data with a regular file or directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須の属性は、サーバによって提供されなければならないと、正しくサーバーで表現しなければならないファイルやファイルシステム属性の最小セットです。推奨属性は異なるファイルシステムタイプと動作環境を表しています。お勧めの属性は、より良い相互運用性とより多くの動作環境を含めることができるようになります。必須および推奨される属性セットは、従来のファイルやファイルシステム属性です。属性の第三のタイプは、名前付き属性です。名前の属性は、ディレクトリやファイルに関連付けられており、文字列名で呼ばれる不透明なバイトストリームです。名前付き属性は、通常のファイルまたはディレクトリとアプリケーション固有のデータを関連付けるための方法として、クライアントアプリケーションによって使用されることを意味しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One significant addition to the recommended set of file attributes is the Access Control List (ACL) attribute. This attribute provides for directory and file access control beyond the model used in previous versions of the NFS protocol. The ACL definition allows for specification of user and group level access control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル属性の推奨設定する1つの重要な追加は、アクセス制御リスト（ACL）の属性です。この属性は、NFSプロトコルの以前のバージョンで使用されたモデルを越えたディレクトリとファイルのアクセス制御を提供します。 ACL定義は、ユーザおよびグループレベルのアクセス制御の仕様を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.3. Filesystem Replication and Migration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.3.3。ファイルシステムレプリケーションおよび移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the use of a special file attribute, the ability to migrate or replicate server filesystems is enabled within the protocol. The filesystem locations attribute provides a method for the client to probe the server about the location of a filesystem. In the event of a migration of a filesystem, the client will receive an error when operating on the filesystem and it can then query as to the new file system location. Similar steps are used for replication, the client is able to query the server for the multiple available locations of a particular filesystem. From this information, the client can use its own policies to access the appropriate filesystem location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特殊なファイル属性を使用すると、サーバーのファイルシステムを移行または複製する能力は、プロトコル内で有効になっています。場所は属性ファイルシステムは、クライアントがファイルシステムの場所についてのサーバーをプローブにするための方法を提供します。ファイルシステムの移行が発生した場合、クライアントは、ファイルシステム上で動作し、エラーを受け取ることになりますし、それは、新しいファイルシステムの場所へと問い合わせることができます。同様の手順は、レプリケーションに使用され、クライアントは、特定のファイルシステムの複数の利用可能な場所については、サーバに照会することができます。この情報から、クライアントは、適切なファイルシステムの場所にアクセスするために、独自のポリシーを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4. OPEN and CLOSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.4。開閉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol introduces OPEN and CLOSE operations. The OPEN operation provides a single point where file lookup, creation, and share semantics can be combined. The CLOSE operation also provides for the release of state accumulated by OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、開閉操作を導入します。 OPEN操作は、ファイルの検索、作成、および共有のセマンティクスを組み合わせることができ、単一のポイントを提供します。 CLOSE動作もOPENによって蓄積された状態の放出を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5. File locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.5。ファイルのロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the NFS version 4 protocol, the support for byte range file locking is part of the NFS protocol. The file locking support is structured so that an RPC callback mechanism is not required. This is a departure from the previous versions of the NFS file locking protocol, Network Lock Manager (NLM). The state associated with file locks is maintained at the server under a lease-based model. The server defines a single lease period for all state held by a NFS client. If the client does not renew its lease within the defined period, all state associated with the client&#39;s lease may be released by the server. The client may renew its lease with use of the RENEW operation or implicitly by use of other operations (primarily READ).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルと、バイト範囲ファイルのロックのためのサポートは、NFSプロトコルの一部です。 RPCコールバック機構が必要とされないようにファイルロックのサポートが構成されています。これは、NFSファイルロックプロトコル、ネットワークロックマネージャ（NLM）の以前のバージョンからの脱却です。ファイルロックに関連付けられた状態は、リースベースのモデルの下でサーバに維持されます。サーバーは、NFSクライアントによって保持されているすべての状態のための単一のリース期間を定義します。クライアントが定義された期間内にそのリースを更新しない場合は、クライアントのリースに関連するすべての状態がサーバーによって解放されてもよいです。クライアントは、（主にREAD）RENEW操作を使用してまたは暗黙的に他の操作を使用することにより、そのリースを更新することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6. Client Caching and Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4.6。クライアントキャッシングと委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file, attribute, and directory caching for the NFS version 4 protocol is similar to previous versions. Attributes and directory information are cached for a duration determined by the client. At the end of a predefined timeout, the client will query the server to see if the related filesystem object has been updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコル用のファイル、属性、およびディレクトリのキャッシングは、以前のバージョンと同様です。属性と、ディレクトリ情報は、クライアントによって決定期間中にキャッシュされます。事前に定義されたタイムアウトの終わりには、クライアントは、関連するファイルシステムオブジェクトが更新されているかどうかを確認するためにサーバーを照会します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For file data, the client checks its cache validity when the file is opened. A query is sent to the server to determine if the file has been changed. Based on this information, the client determines if the data cache for the file should kept or released. Also, when the file is closed, any modified data is written to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルを開いたときに、ファイルデータの場合、クライアントは、そのキャッシュの有効性をチェックします。クエリは、ファイルが変更されているかどうかを判断するためにサーバーに送信されます。ファイルのためのデータ・キャッシュを保持または解放する必要がある場合、この情報に基づいて、クライアントが決定します。ファイルを閉じたときにも、任意の変更されたデータがサーバーに書き込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application wants to serialize access to file data, file locking of the file data ranges in question should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションがファイルデータへのアクセスをシリアル化したい場合は、問題のファイルのデータ範囲のファイルのロックを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The major addition to NFS version 4 in the area of caching is the ability of the server to delegate certain responsibilities to the client. When the server grants a delegation for a file to a client, the client is guaranteed certain semantics with respect to the sharing of that file with other clients. At OPEN, the server may provide the client either a read or write delegation for the file. If the client is granted a read delegation, it is assured that no other client has the ability to write to the file for the duration of the delegation. If the client is granted a write delegation, the client is assured that no other client has read or write access to the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシングの領域でのNFSバージョン4への主要な追加は、クライアントに一定の責任を委譲するには、サーバーの能力です。サーバーがクライアントへのファイルの委任を許可した場合、クライアントは他のクライアントとそのファイルの共有に対して一定のセマンティクスを保証されています。 OPENで、サーバはクライアントのいずれかの読み取りを提供することができるか、ファイルのための委任を書きます。クライアントが読み委任を許可された場合は、他のクライアントが委任期間中のファイルへの書き込み機能を持っていないことが保証されます。クライアントが書き込みの委任を許可された場合、クライアントは、他のクライアントは読まないか、ファイルへの書き込みアクセスをしていることが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations can be recalled by the server. If another client requests access to the file in such a way that the access conflicts with the granted delegation, the server is able to notify the initial client and recall the delegation. This requires that a callback path exist between the server and client. If this callback path does not exist, then delegations can not be granted. The essence of a delegation is that it allows the client to locally service operations such as OPEN, CLOSE, LOCK, LOCKU, READ, WRITE without immediate interaction with the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代表団は、サーバによって呼び出すことができます。別のクライアント要求が許可された代表団とのアクセスが競合するような方法でファイルにアクセスした場合、サーバーは最初のクライアントに通知し、委任をリコールすることができます。これは、コールバックパスは、サーバとクライアントの間に存在することが必要です。このコールバックパスが存在しない場合は、代表団は付与されません。代表団の本質は、それは、そのようなOPEN、CLOSE、LOCK、LOCKU、READ、などローカルサービス操作にクライアントがサーバーとの直接の相互作用なしWRITE可能とすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. General Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5。一般的な定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following definitions are provided for the purpose of providing an appropriate context for the reader.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の定義は、読者のために適切なコンテキストを提供する目的のために提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client The &#34;client&#34; is the entity that accesses the NFS server&#39;s resources. The client may be an application which contains the logic to access the NFS server directly. The client may also be the traditional operating system client remote filesystem services for a set of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「クライアント」クライアントがNFSサーバーのリソースにアクセスするエンティティです。クライアントは直接NFSサーバーにアクセスするためのロジックが含まれているアプリケーションであってもよいです。また、クライアントはアプリケーションのセットのための伝統的なオペレーティングシステムクライアントリモートファイルシステムサービスであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             In the case of file locking the client is the entity that
             maintains a set of locks on behalf of one or more
             applications.  This client is responsible for crash or
             failure recovery for those locks it manages.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Note that multiple clients may share the same transport and multiple clients may exist on the same network node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
複数のクライアントが同一のトランスポートを共有してもよいし、複数のクライアントが同一のネットワーク・ノードに存在してもよいことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clientid A 64-bit quantity used as a unique, short-hand reference to a client supplied Verifier and ID. The server is responsible for supplying the Clientid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
検証およびIDを供給し、クライアントに固有の、ショートハンド基準として使用される64ビット量をCLIENTID。サーバーは、CLIENTIDを供給するための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lease An interval of time defined by the server for which the client is irrevocably granted a lock. At the end of a lease period the lock may be revoked if the lease has not been extended. The lock must be revoked if a conflicting lock has been granted after the lease interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、取消不能の形でロックを許可されているサーバーで定義された時間の間隔をリース。リースが拡張されていない場合は、リース期間の終了時にロックが取り消すことができます。競合ロックがリース期間の後に付与されている場合はロックが取り消されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             All leases granted by a server have the same fixed
             interval.  Note that the fixed interval was chosen to
             alleviate the expense a server would have in maintaining
             state about variable length leases across server failures.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lock The term &#34;lock&#34; is used to refer to both record (byte-range) locks as well as share reservations unless specifically stated otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック用語「ロック」は、特に明記しない限り、両方のレコード（バイト範囲）ロックならびに共有の予約を指すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server The &#34;Server&#34; is the entity responsible for coordinating client access to a set of filesystems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー「サーバー」とは、ファイルシステムのセットへのクライアントアクセスの調整を担当するエンティティです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stable Storage NFS version 4 servers must be able to recover without data loss from multiple power failures (including cascading power failures, that is, several power failures in quick succession), operating system failures, and hardware failure of components other than the storage medium itself (for example, disk, nonvolatile RAM).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定記憶NFSバージョン4台のサーバは、複数の電源障害からデータを損失することなく回復することができなければならない（カスケード停電を含む、すなわち、いくつかの立て続けに電源障害）、オペレーティング・システムの障害、及び記憶媒体自体以外の成分のハードウェア障害（例えば、ディスク、不揮発性RAM）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             Some examples of stable storage that are allowable for an
             NFS server include:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
1. Media commit of data, that is, the modified data has been successfully written to the disk media, for example, the disk platter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
1.メディアはつまり、データのコミット、変更されたデータが正常に、例えば、ディスクメディアにディスクプラッタを書かされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
2. An immediate reply disk drive with battery-backed on-drive intermediate storage or uninterruptible power system (UPS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
2.バッテリバックアップオン駆動中間貯蔵または無停電電源装置（UPS）との即時応答ディスクドライブ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
3. Server commit of data with battery-backed intermediate storage and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
3.サーバーは、バッテリバックアップ中間貯蔵及び回復ソフトウェアとデータのコミット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
4. Cache commit with uninterruptible power system (UPS) and recovery software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
4.キャッシュは、無停電電源装置（UPS）と回復ソフトウェアをコミットします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateid A 128-bit quantity returned by a server that uniquely defines the open and locking state provided by the server for a specific open or lock owner for a specific file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一意に特定ファイルの特定のオープンまたはロック所有者のサーバによって提供されるオープンとロック状態を定義するサーバによって返された128ビット量のstateid。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             Stateids composed of all bits 0 or all bits 1 have special
             meaning and are reserved values.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Verifier A 64-bit quantity generated by the client that the server can use to determine if the client has restarted and lost all previous lock state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、クライアントが再起動し、すべての以前のロック状態を喪失したかどうかを判定するために使用できるクライアントによって生成された検証者Aの64ビット量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Protocol Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.プロトコル・データ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The syntax and semantics to describe the data types of the NFS version 4 protocol are defined in the XDR [RFC1832] and RPC [RFC1831] documents. The next sections build upon the XDR data types to define types and structures specific to this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルのデータ・タイプを記述するための構文およびセマンティクスはXDR [RFC1832]及びRPC [RFC1831]ドキュメントで定義されています。次のセクションでは、このプロトコルに特定の種類や構造を定義するにはXDRのデータ型に基づいて構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Basic Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。基本データ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Data Type       Definition
   ____________________________________________________________________
   int32_t         typedef int             int32_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint32_t typedef unsigned int uint32_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsigned int型のuint32_tのtypedefのuint32_t。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int64_t typedef hyper int64_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int64_tのハイパーint64_tのtypedefは、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint64_t typedef unsigned hyper uint64_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
符号なしのハイパーuint64_tをのtypedef uint64_tを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
attrlist4 typedef opaque attrlist4&lt;&gt;; Used for file/directory attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明attrlist4のtypedef attrlist4 &lt;&gt;。ファイル/ディレクトリの属性に使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bitmap4 typedef uint32_t bitmap4&lt;&gt;; Used in attribute array encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bitmap4のtypedefのuint32_t bitmap4 &lt;&gt;。属性配列のエンコードに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
changeid4 typedef uint64_t changeid4; Used in definition of change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
changeid4のtypedef uint64_tをchangeid4。 change_infoの定義で使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid4 typedef uint64_t clientid4; Shorthand reference to client identification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientid4のtypedef uint64_tをclientid4。クライアント識別に速記参照
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
component4 typedef utf8str_cs component4; Represents path name components
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
component4のtypedef utf8str_cs component4。パス名の構成要素を表します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
count4 typedef uint32_t count4; Various count parameters (READ, WRITE, COMMIT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
count4のtypedefのuint32_t count4。様々なカウントパラメータ（COMMIT、WRITE、READ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length4 typedef uint64_t length4; Describes LOCK lengths
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LENGTH4のtypedef uint64_tをLENGTH4。 LOCKの長さを記述します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
linktext4 typedef utf8str_cs linktext4; Symbolic link contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
linktext4のtypedef utf8str_cs linktext4。シンボリックリンクの内容
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode4 typedef uint32_t mode4; Mode attribute data type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MODE4のtypedefのuint32_t MODE4。モード属性データ型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_cookie4 typedef uint64_t nfs_cookie4; Opaque cookie value for READDIR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_cookie4のtypedef uint64_tをnfs_cookie4。 READDIRのための不透明なクッキーの値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_fh4 typedef opaque nfs_fh4&lt;NFS4_FHSIZE&gt;; Filehandle definition; NFS4_FHSIZE is defined as 128
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_fh4不透明nfs_fh4のtypedef &lt;NFS4_FHSIZE&gt;。ファイルハンドルの定義; NFS4_FHSIZEは、128のように定義されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_ftype4 enum nfs_ftype4; Various defined file types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_ftype4列挙型nfs_ftype4。様々な定義されているファイルの種類
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfsstat4 enum nfsstat4; Return value for operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfsstat4列挙型nfsstat4。操作の戻り値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
offset4 typedef uint64_t offset4; Various offset designations (READ, WRITE, LOCK, COMMIT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OFFSET4のtypedef uint64_tをOFFSET4。種々の（READ、WRITE、LOCK、COMMIT）指定オフセット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pathname4 typedef component4 pathname4&lt;&gt;; Represents path name for LOOKUP, OPEN and others
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pathname4のtypedef component4 pathname4 &lt;&gt;。 LOOKUP、OPEN、その他のパス名を表します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qop4 typedef uint32_t qop4; Quality of protection designation in SECINFO
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qop4のtypedefのuint32_t qop4。 SECINFOで保護指定の品質
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sec_oid4 typedef opaque sec_oid4&lt;&gt;; Security Object Identifier The sec_oid4 data type is not really opaque. Instead contains an ASN.1 OBJECT IDENTIFIER as used by GSS-API in the mech_type argument to GSS_Init_sec_context. See [RFC2743] for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明sec_oid4のtypedef sec_oid4 &lt;&gt;。セキュリティオブジェクト識別子はsec_oid4データ型は本当に不透明ではありません。もしGSS_Init_sec_contextへたmech_type引数にGSS-APIで使用されるようにする代わりにASN.1オブジェクト識別子が含まれています。詳細については、[RFC2743]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seqid4 typedef uint32_t seqid4; Sequence identifier used for file locking
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seqid4のtypedefのuint32_t seqid4。ファイルのロックに使用するシーケンス識別子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8string typedef opaque utf8string&lt;&gt;; UTF-8 encoding for strings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedefの不透明UTF8STRINGをUTF8STRING &lt;&gt;。文字列のUTF-8エンコーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cis typedef opaque utf8str_cis; Case-insensitive UTF-8 string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明utf8str_cisのtypedef utf8str_cis。大文字と小文字を区別しないUTF-8文字列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cs typedef opaque utf8str_cs; Case-sensitive UTF-8 string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明utf8str_csのtypedef utf8str_cs。大文字と小文字を区別UTF-8文字列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixed typedef opaque utf8str_mixed; UTF-8 strings with a case sensitive prefix and a case insensitive suffix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明utf8str_mixedのtypedef utf8str_mixed。 UTF-8大文字と小文字を区別プレフィックスと大文字小文字を区別しないサフィックスを持つ文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
verifier4 typedef opaque verifier4[NFS4_VERIFIER_SIZE]; Verifier used for various operations (COMMIT, CREATE, OPEN, READDIR, SETCLIENTID, SETCLIENTID_CONFIRM, WRITE) NFS4_VERIFIER_SIZE is defined as 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
verifier4 [NFS4_VERIFIER_SIZE] verifier4のtypedef不透明。検証者はNFS4_VERIFIER_SIZEが8のように定義される様々な操作に使用される（CREATE、COMMIT、OPEN、READDIR、SETCLIENTID、SETCLIENTID_CONFIRM、WRITE）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Structured Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2。構造化データ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   nfstime4
                  struct nfstime4 {
                          int64_t seconds;
                          uint32_t nseconds;
                  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfstime4 structure gives the number of seconds and nanoseconds since midnight or 0 hour January 1, 1970 Coordinated Universal Time (UTC). Values greater than zero for the seconds field denote dates after the 0 hour January 1, 1970. Values less than zero for the seconds field denote dates before the 0 hour January 1, 1970. In both cases, the nseconds field is to be added to the seconds field for the final time representation. For example, if the time to be represented is one-half second before 0 hour January 1, 1970, the seconds field would have a value of negative one (-1) and the nseconds fields would have a value of one-half second (500000000). Values greater than 999,999,999 for nseconds are considered invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfstime4構造は深夜または0時間1970年1月1日協定世界時（UTC）からの秒とナノ秒数を示します。秒フィールドにゼロ以上の値が0時間の1月1日以降の日付を表し、秒フィールドのためのゼロ未満1970の値は両方のケースで0時間1970年1月1日より前の日付を表し、nsecondsフィールドが追加されます最終時間表現のための秒フィールド。例えば、表現される時間は、半分が第二0時間1970年1月1日前に、秒フィールドが負の1（-1）の値を有するであろうとnsecondsフィールドが（第2の半分の値を有するであろうあれば5億）。 nseconds用999999999より大きい値は無効とみなされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type is used to pass time and date information. A server converts to and from its local representation of time when processing time values, preserving as much accuracy as possible. If the precision of timestamps stored for a filesystem object is less than defined, loss of precision can occur. An adjunct time maintenance protocol is recommended to reduce client and server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、日付と時刻の情報を渡すために使用されます。時間値を処理するとき、サーバはできるだけ正確さを維持し、時間のローカル表現へと変換します。ファイルシステム・オブジェクトの記憶されたタイムスタンプの精度が規定未満であれば、精度の損失が発生する可能性があります。補助時間のメンテナンスプロトコルは、クライアントとサーバーの時間のずれを低減することを推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_how4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_how4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  enum time_how4 {
                          SET_TO_SERVER_TIME4 = 0,
                          SET_TO_CLIENT_TIME4 = 1
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settime4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
settime4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  union settime4 switch (time_how4 set_it) {
                   case SET_TO_CLIENT_TIME4:
                           nfstime4       time;
                   default:
                           void;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above definitions are used as the attribute definitions to set time values. If set_it is SET_TO_SERVER_TIME4, then the server uses its local representation of time for the time value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の定義は、時間の値を設定する属性の定義として使用されています。 set_itがSET_TO_SERVER_TIME4ある場合、サーバーは、時間値のための時間のローカルな表現を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
specdata4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
specdata4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct specdata4 {
                          uint32_t specdata1; /* major device number */
                          uint32_t specdata2; /* minor device number */
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data type represents additional information for the device file types NF4CHR and NF4BLK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータ型は、デバイスファイルの種類NF4CHRとNF4BLKの追加情報を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct fsid4 {
                    uint64_t        major;
                    uint64_t        minor;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This type is the filesystem identifier that is used as a mandatory attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このタイプは、必須の属性として使用されているファイルシステム識別子です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct fs_location4 {
                          utf8str_cis    server&lt;&gt;;
                          pathname4     rootpath;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct fs_locations4 {
                          pathname4     fs_root;
                          fs_location4  locations&lt;&gt;;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_location4 and fs_locations4 data types are used for the fs_locations recommended attribute which is used for migration and replication support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location4とfs_locations4データ型は、移行およびレプリケーション・サポートのために使用されているfs_位置推奨属性のために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fattr4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fattr4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct fattr4 {
                          bitmap4       attrmask;
                          attrlist4     attr_vals;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fattr4 structure is used to represent file and directory attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fattr4構造は、ファイルやディレクトリの属性を表すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmap is a counted array of 32 bit integers used to contain bit values. The position of the integer in the array that contains bit n can be computed from the expression (n / 32) and its bit within that integer is (n mod 32).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットマップは、ビット値を含むために使用される32ビット整数のカウント配列です。ビットnを含む配列の整数の位置は、式（N / 32）から計算することができ、その整数の中のビットは（N MOD 32）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                           0            1
         +-----------+-----------+-----------+--
         |  count    | 31  ..  0 | 63  .. 32 |
         +-----------+-----------+-----------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change_info4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変化_info4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct change_info4 {
                          bool          atomic;
                          changeid4     before;
                          changeid4     after;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used with the CREATE, LINK, REMOVE, RENAME operations to let the client know the value of the change attribute for the directory in which the target filesystem object resides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、REMOVEクライアントは、ターゲットファイルシステムオブジェクトが存在するディレクトリの変更属性の値を知っているように操作の名前を変更し、CREATE LINKで使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientaddr4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientaddr4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct clientaddr4 {
                          /* see struct rpcb in RFC 1833 */
                          string r_netid&lt;&gt;;    /* network id */
                          string r_addr&lt;&gt;;     /* universal address */
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The clientaddr4 structure is used as part of the SETCLIENTID operation to either specify the address of the client that is using a clientid or as part of the callback registration. The r_netid and r_addr fields are specified in [RFC1833], but they are underspecified in [RFC1833] as far as what they should look like for specific protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clientaddr4構造のClientIDまたはコールバック登録の一部としてを使用しているクライアントのアドレスを指定するかSETCLIENTID操作の一部として使用されます。 r_netidとR_ADDRフィールドは、[RFC1833]で指定されていますが、限り、彼らは特定のプロトコルのためにどのように見えるかのように[RFC1833]でunderspecifiedされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TCP over IPv4 and for UDP over IPv4, the format of r_addr is the US-ASCII string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4のオーバーとIPv4上のUDPのためのTCPの場合は、R_ADDRのフォーマットは、US-ASCII文字列は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
h1.h2.h3.h4.p1.p2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
h1.h2.h3.h4.p1.p2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prefix, &#34;h1.h2.h3.h4&#34;, is the standard textual form for representing an IPv4 address, which is always four octets long. Assuming big-endian ordering, h1, h2, h3, and h4, are respectively, the first through fourth octets each converted to ASCII-decimal. Assuming big-endian ordering, p1 and p2 are, respectively, the first and second octets each converted to ASCII-decimal. For example, if a host, in big-endian order, has an address of 0x0A010307 and there is a service listening on, in big endian order, port 0x020F (decimal 527), then the complete universal address is &#34;10.1.3.7.2.15&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接頭辞、「h1.h2.h3.h4は」、常に4つのオクテット長であるIPv4アドレスを表現するための標準的なテキスト形式、です。ビッグエンディアン順序、H1、H2、H3、およびH4と仮定すると、それぞれ、各第四オクテット〜第はASCII-小数に変換されます。それぞれ、ビッグエンディアン順序、P1とP2をしていると仮定すると、第一及び第二のオクテットはそれぞれ、ASCII-10進数に変換しました。例えば、ホストは、ビッグエンディアン順に、0x0A010307のアドレスを持ち、上のリスニングサービスがある場合には、ビッグエンディアン順、ポート0x020F（527 10進数）で、その後、完全な汎用アドレスは「10.1.3.7.2.15です」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TCP over IPv4 the value of r_netid is the string &#34;tcp&#34;. For UDP over IPv4 the value of r_netid is the string &#34;udp&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4の上のTCPについてr_netidの値は、文字列「TCP」です。 IPv4の上のUDPについてr_netidの値は、文字列「UDP」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TCP over IPv6 and for UDP over IPv6, the format of r_addr is the US-ASCII string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6経由のIPv6経由とUDPのためのTCPの場合は、R_ADDRのフォーマットは、US-ASCII文字列です：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
x1:x2:x3:x4:x5:x6:x7:x8.p1.p2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
X1：X2：X3：X4：X5：X6：X7：x8.p1.p2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The suffix &#34;p1.p2&#34; is the service port, and is computed the same way as with universal addresses for TCP and UDP over IPv4. The prefix, &#34;x1:x2:x3:x4:x5:x6:x7:x8&#34;, is the standard textual form for representing an IPv6 address as defined in Section 2.2 of [RFC2373]. Additionally, the two alternative forms specified in Section 2.2 of [RFC2373] are also acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接尾辞「p1.p2は、」サービスポートで、とIPv4上のTCPとUDPのための普遍的なアドレスと同じ方法で計算されます。接頭辞 &#34;X1：X2：X3：X4：X5：X6：X7：X8&#34; は、[RFC2373]のセクション2.2で定義されたIPv6アドレスを表すための標準的なテキスト形式です。また、[RFC2373]のセクション2.2で指定された2つの代替形態も許容されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TCP over IPv6 the value of r_netid is the string &#34;tcp6&#34;. For UDP over IPv6 the value of r_netid is the string &#34;udp6&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6の上のTCPについてr_netidの値は、文字列「にtcp6」です。 IPv6の上のUDPについてr_netidの値は、文字列「UDP6」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cb_client4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cb_client4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct cb_client4 {
                          unsigned int  cb_program;
                          clientaddr4   cb_location;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used by the client to inform the server of its call back address; includes the program number and client address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、そのコールバックアドレスのサーバーに通知するために、クライアントにより使用されます。プログラム番号とクライアントのアドレスが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_client_id4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs_client_id4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct nfs_client_id4 {
                          verifier4     verifier;
                          opaque        id&lt;NFS4_OPAQUE_LIMIT&gt;;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is part of the arguments to the SETCLIENTID operation. NFS4_OPAQUE_LIMIT is defined as 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造はSETCLIENTID操作の引数の一部です。 NFS4_OPAQUE_LIMITは、1024年のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
open_owner4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
open_owner4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct open_owner4 {
                          clientid4     clientid;
                          opaque        owner&lt;NFS4_OPAQUE_LIMIT&gt;;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used to identify the owner of open state. NFS4_OPAQUE_LIMIT is defined as 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、開いた状態の所有者を識別するために使用されます。 NFS4_OPAQUE_LIMITは、1024年のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lock_owner4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lock_owner4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct lock_owner4 {
                          clientid4     clientid;
                          opaque        owner&lt;NFS4_OPAQUE_LIMIT&gt;;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used to identify the owner of file locking state. NFS4_OPAQUE_LIMIT is defined as 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、ファイルのロック状態の所有者を識別するために使用されます。 NFS4_OPAQUE_LIMITは、1024年のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
open_to_lock_owner4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
open_to_lock_owner4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct open_to_lock_owner4 {
                          seqid4          open_seqid;
                          stateid4        open_stateid;
                          seqid4          lock_seqid;
                          lock_owner4     lock_owner;
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used for the first LOCK operation done for an open_owner4. It provides both the open_stateid and lock_owner such that the transition is made from a valid open_stateid sequence to that of the new lock_stateid sequence. Using this mechanism avoids the confirmation of the lock_owner/lock_seqid pair since it is tied to established state in the form of the open_stateid/open_seqid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造はopen_owner4に対して行う第1のロック操作のために使用されます。それはopen_stateidと遷移が新しいlock_stateid系列のそれに有効なopen_stateid配列から作られるようにlock_ownerの両方を提供します。それはopen_stateid / open_seqidの形で確立された状態に関連付けられているので、この機構を使用することlock_owner / lock_seqidペアの確認を回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  struct stateid4 {
                    uint32_t        seqid;
                    opaque          other[12];
                  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This structure is used for the various state sharing mechanisms between the client and server. For the client, this data structure is read-only. The starting value of the seqid field is undefined. The server is required to increment the seqid field monotonically at each transition of the stateid. This is important since the client will inspect the seqid in OPEN stateids to determine the order of OPEN processing done by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造は、クライアントとサーバの間のさまざまな状態を共有するメカニズムのために使用されています。クライアントの場合、このデータ構造は読み取り専用です。 SEQIDフィールドの開始値は未定義です。サーバはのstateidの各遷移において単調SEQIDフィールドをインクリメントする必要があります。クライアントがサーバによって行わOPEN処理の順序を決定するためにOPENのstateidsにSEQIDを検査しますので、これは重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RPC and Security Flavor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RPCとセキュリティフレーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol is a Remote Procedure Call (RPC) application that uses RPC version 2 and the corresponding eXternal Data Representation (XDR) as defined in [RFC1831] and [RFC1832]. The RPCSEC_GSS security flavor as defined in [RFC2203] MUST be used as the mechanism to deliver stronger security for the NFS version 4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1831]及び[RFC1832]で定義されるようにNFSバージョン4プロトコルはリモート・プロシージャ・コールRPCバージョン2を使用して（RPC）アプリケーションと対応する外部データ表現（XDR）です。 [RFC2203]で定義されるようにRPCSEC_GSSセキュリティ風味は、NFSバージョン4プロトコルのための強力なセキュリティを提供するためのメカニズムとして使用されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Ports and Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。ポートおよびトランスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Historically, NFS version 2 and version 3 servers have resided on port 2049. The registered port 2049 [RFC3232] for the NFS protocol should be the default configuration. Using the registered port for NFS services means the NFS client will not need to use the RPC binding protocols as described in [RFC1833]; this will allow NFS to transit firewalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
歴史的に、NFSバージョン2とバージョン3のサーバーは、NFSプロトコルの登録ポート2049 [RFC3232]はデフォルトの設定である必要があり、ポート2049上に置かれています。 NFSサービスのために登録されているポートを使用すると、NFSクライアントは[RFC1833]で説明したようにプロトコルをバインドRPCを使用する必要がないことを意味します。これはトランジットファイアウォールにNFSをできるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where an NFS version 4 implementation supports operation over the IP network protocol, the supported transports between NFS and IP MUST be among the IETF-approved congestion control transport protocols, which include TCP and SCTP. To enhance the possibilities for interoperability, an NFS version 4 implementation MUST support operation over the TCP transport protocol, at least until such time as a standards track RFC revises this requirement to use a different IETF-approved congestion control transport protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4の実装は、IPネットワークプロトコルを介して動作をサポートする場合、NFSとIPとの間のサポートされているトランスポートはTCPとSCTPを含むIETF承認輻輳制御トランスポートプロトコルの中でなければなりません。標準トラックRFCは異なるIETF承認の輻輳制御トランスポートプロトコルを使用するには、この要件を改訂として、相互運用性の可能性を高めるため、NFSバージョン4の実装は、少なくとも、そのような時間までは、TCPトランスポートプロトコル上での動作をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If TCP is used as the transport, the client and server SHOULD use persistent connections. This will prevent the weakening of TCP&#39;s congestion control via short lived connections and will improve performance for the WAN environment by eliminating the need for SYN handshakes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPはトランスポートとして使用されている場合は、クライアントとサーバは、持続的な接続を使用すべきです。これは短命接続を介してTCPの輻輳制御の弱体化を防ぐことができますし、SYNハンドシェイクの必要性を排除することにより、WAN環境のパフォーマンスが向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in the Security Considerations section, the authentication model for NFS version 4 has moved from machine-based to principal-based. However, this modification of the authentication model does not imply a technical requirement to move the TCP connection management model from whole machine-based to one based on a per user model. In particular, NFS over TCP client implementations have traditionally multiplexed traffic for multiple users over a common TCP connection between an NFS client and server. This has been true, regardless whether the NFS client is using AUTH_SYS, AUTH_DH, RPCSEC_GSS or any other flavor. Similarly, NFS over TCP server implementations have assumed such a model and thus scale the implementation of TCP connection management in proportion to the number of expected client machines. It is intended that NFS version 4 will not modify this connection management model. NFS version 4 clients that violate this assumption can expect scaling issues on the server and hence reduced service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティの考慮事項のセクションで述べたように、NFSバージョン4の認証モデルは、主ベースに機械ベースから移動しました。しかし、認証モデルのこの変更は、ユーザーごとのモデルに基づいたものに全マシンベースからTCP接続管理モデルを移動するための技術的要件を意味するものではありません。具体的には、NFS over TCPをクライアントの実装は、伝統的にNFSクライアントとサーバの間の共通のTCP接続を介して複数のユーザーのトラフィックを多重化しています。これは、NFSクライアントはAUTH_SYS、AUTH_DH、RPCSEC_GSSまたはその他のフレーバーを使用しているかどうかにかかわらず、真となっています。同様に、NFS TCPを介してサーバの実装は、そのようなモデルを想定しているので、予想されるクライアントマシンの数に比例してTCP接続管理の実装を拡張します。 NFSバージョン4は、この接続管理モデルを変更しないであろうことが意図されています。この仮定に違反するNFSバージョン4つのクライアントは、サーバー上のスケーリングの問題を期待し、したがって、サービスを削減することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for various timers, the client and server should avoid inadvertent synchronization of those timers. For further discussion of the general issue refer to [Floyd].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各種タイマのために、クライアントとサーバは、これらのタイマの不注意な同期を避ける必要があることに注意してください。一般的な問題のさらなる議論について[フロイド]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Client Retransmission Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1。クライアントの再送信の動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When processing a request received over a reliable transport such as TCP, the NFS version 4 server MUST NOT silently drop the request, except if the transport connection has been broken. Given such a contract between NFS version 4 clients and servers, clients MUST NOT retry a request unless one or both of the following are true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求を処理するときにはTCPのような信頼性の高いトランスポートを介して受信し、NFSバージョン4サーバは静かに転送接続が切断されている場合を除いて、要求をドロップしてはいけません。次のいずれかまたは両方に該当する場合を除き、NFSバージョン4つのクライアントとサーバーの間で、このような契約を考えると、クライアントが要求を再試行してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The transport connection has been broken
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oトランスポート接続が切断されました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The procedure being retried is the NULL procedure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O再試行される手順は、NULL手順であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since reliable transports, such as TCP, do not always synchronously inform a peer when the other peer has broken the connection (for example, when an NFS server reboots), the NFS version 4 client may want to actively &#34;probe&#34; the connection to see if has been broken. Use of the NULL procedure is one recommended way to do so. So, when a client experiences a remote procedure call timeout (of some arbitrary implementation specific amount), rather than retrying the remote procedure call, it could instead issue a NULL procedure call to the server. If the server has died, the transport connection break will eventually be indicated to the NFS version 4 client. The client can then reconnect, and then retry the original request. If the NULL procedure call gets a response, the connection has not broken. The client can decide to wait longer for the original request&#39;s response, or it can break the transport connection and reconnect before re-sending the original request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPのような信頼性の高いトランスポート、以来、常に同期他のピアが接続（例えば、時にNFSサーバのリブート）が壊れたとき、NFSバージョン4クライアントが接続を参照してくださいに積極的に「プローブ」場合がありますピアに通知しません。場合は、破損しています。 NULL手続きの使用がそうする1つの推奨される方法です。クライアントがリモートプロシージャコールリモート・プロシージャ・コール（いくつかの任意の実装の特定の量の）タイムアウトではなく、再試行を経験するときに、それは代わりに、サーバーへのNULLプロシージャ・コールを発行することができます。サーバーが死亡した場合は、トランスポート接続の中断は、最終的にはNFSバージョン4のクライアントに表示されます。クライアントが再接続した後、元の要求を再試行することができます。 NULLプロシージャ・コールは、応答を取得した場合、接続が切断されていません。クライアントは、元の要求の応答のために長く待つことを決定することができ、またはそれは、トランスポート接続を解除し、元の要求を再送信する前に再接続することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For callbacks from the server to the client, the same rules apply, but the server doing the callback becomes the client, and the client receiving the callback becomes the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーからクライアントへのコールバックの場合、同じ規則が適用されますが、コールバックを行うサーバがクライアントになり、コールバックを受信するクライアントがサーバーになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Security Flavors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。セキュリティフレーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Traditional RPC implementations have included AUTH_NONE, AUTH_SYS, AUTH_DH, and AUTH_KRB4 as security flavors. With [RFC2203] an additional security flavor of RPCSEC_GSS has been introduced which uses the functionality of GSS-API [RFC2743]. This allows for the use of various security mechanisms by the RPC layer without the additional implementation overhead of adding RPC security flavors. For NFS version 4, the RPCSEC_GSS security flavor MUST be used to enable the mandatory security mechanism. Other flavors, such as, AUTH_NONE, AUTH_SYS, and AUTH_DH MAY be implemented as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従来のRPCの実装は、セキュリティのフレーバーとしてAUTH_NONE、AUTH_SYS、AUTH_DH、およびAUTH_KRB4が含まれています。 [RFC2203]でRPCSEC_GSSの追加のセキュリティ風味はGSS-API [RFC2743]の機能を使用していますが導入されました。これは、RPCセキュリティ風味を加える追加の実施オーバーヘッドなしRPC層によって様々なセキュリティメカニズムの使用を可能にします。 NFSバージョン4は、RPCSEC_GSSセキュリティ風味が必須のセキュリティ・メカニズムを有効にするために使用されなければなりません。このようAUTH_NONE、AUTH_SYS、AUTH_DHと、などの他のフレーバーは、同様に実施することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. Security mechanisms for NFS version 4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1。 NFSバージョン4のセキュリティ・メカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of RPCSEC_GSS requires selection of: mechanism, quality of protection, and service (authentication, integrity, privacy). The remainder of this document will refer to these three parameters of the RPCSEC_GSS security as the security triple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メカニズム、保護の品質、及びサービス（認証、完全性、プライバシー）：RPCSEC_GSSを使用すると、選択が必要です。このドキュメントの残りの部分はトリプルセキュリティなどRPCSEC_GSSセキュリティのこれらの三つのパラメータを参照します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.1. Kerberos V5 as a security triple
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.1。セキュリティなどのKerberos V5トリプル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Kerberos V5 GSS-API mechanism as described in [RFC1964] MUST be implemented and provide the following security triples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1964]に記載されているようにケルベロスV5 GSS-API機構が実装され、以下のセキュリティトリプルを提供しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
column descriptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列の説明：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1 == number of pseudo flavor 2 == name of pseudo flavor 3 == mechanism&#39;s OID 4 == mechanism&#39;s algorithm(s) 5 == RPCSEC_GSS service
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疑似風味3 ==機構のOID 4 ==機構のアルゴリズム（複数可）5 == RPCSEC_GSSサービスの疑似風味2 ==名前の1つの==数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1      2     3                    4             5
   --------------------------------------------------------------------
   390003 krb5  1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_none
   390004 krb5i 1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_integrity
   390005 krb5p 1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_privacy
                                     for integrity,
                                     and 56 bit DES
                                     for privacy.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the pseudo flavor is presented here as a mapping aid to the implementor. Because this NFS protocol includes a method to negotiate security and it understands the GSS-API mechanism, the pseudo flavor is not needed. The pseudo flavor is needed for NFS version 3 since the security negotiation is done via the MOUNT protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疑似風味が実装へのマッピングの補助として、ここで提示されることに注意してください。このNFSプロトコルはセキュリティを交渉する方法を含み、それはGSS-APIメカニズムを理解しているので、疑似風味は必要ありません。セキュリティネゴシエーションがMOUNTプロトコルを介して行われるので、疑似風味は、NFSバージョン3のために必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a discussion of NFS&#39; use of RPCSEC_GSS and Kerberos V5, please see [RFC2623].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPCSEC_GSSとKerberos V5のNFS」使用の議論に関しては、[RFC2623]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Users and implementors are warned that 56 bit DES is no longer considered state of the art in terms of resistance to brute force attacks. Once a revision to [RFC1964] is available that adds support for AES, implementors are urged to incorporate AES into their NFSv4 over Kerberos V5 protocol stacks, and users are similarly urged to migrate to the use of AES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザと実装者は、56ビットDESはもはやブルートフォース攻撃に対する耐性の面で技術の状況を考えられていることが警告されていません。 [RFC1964]に改訂後AESのサポートを追加することに使用可能であり、実装は、Kerberos V5プロトコルスタックの上にそれらのNFSv4にAESを組み込むように付勢され、そしてユーザは、同様に、AESの使用に移行するように付勢されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.2. LIPKEY as a security triple
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.2。トリプルセキュリティなどLIPKEY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LIPKEY GSS-API mechanism as described in [RFC2847] MUST be implemented and provide the following security triples. The definition of the columns matches the previous subsection &#34;Kerberos V5 as security triple&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2847]に記載されているようにLIPKEY GSS-API機構が実装され、以下のセキュリティトリプルを提供しなければなりません。列の定義は、「セキュリティのトリプルとしてKerberos V5」前節と一致します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1      2        3                   4              5
   --------------------------------------------------------------------
   390006 lipkey   1.3.6.1.5.5.9       negotiated  rpc_gss_svc_none
   390007 lipkey-i 1.3.6.1.5.5.9       negotiated  rpc_gss_svc_integrity
   390008 lipkey-p 1.3.6.1.5.5.9       negotiated  rpc_gss_svc_privacy
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanism algorithm is listed as &#34;negotiated&#34;. This is because LIPKEY is layered on SPKM-3 and in SPKM-3 [RFC2847] the confidentiality and integrity algorithms are negotiated. Since SPKM-3 specifies HMAC-MD5 for integrity as MANDATORY, 128 bit cast5CBC for confidentiality for privacy as MANDATORY, and further specifies that HMAC-MD5 and cast5CBC MUST be listed first before weaker algorithms, specifying &#34;negotiated&#34; in column 4 does not impair interoperability. In the event an SPKM-3 peer does not support the mandatory algorithms, the other peer is free to accept or reject the GSS-API context creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機構アルゴリズムは「交渉さ」と表示されています。 LIPKEYがSPKM-3に積層され、SPKM-3 [RFC2847]に機密性と完全性アルゴリズムがネゴシエートされるためです。 SPKM-3は、必須として、プライバシーのために機密性のために必須、128ビットcast5CBCとして整合性のためにHMAC-MD5を指定し、HMAC-MD5とcast5CBCが弱くアルゴリズムの前に最初にリストされなければならないことをさらに指定し、第4欄の「ネゴシエート」を指定すると損なわないため相互運用性。イベントではSPKM-3ピアが必須のアルゴリズムをサポートしていない、他のピアは、GSS-APIのコンテキストの作成を受け入れるか拒否して自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because SPKM-3 negotiates the algorithms, subsequent calls to LIPKEY&#39;s GSS_Wrap() and GSS_GetMIC() by RPCSEC_GSS will use a quality of protection value of 0 (zero). See section 5.2 of [RFC2025] for an explanation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SPKM-3アルゴリズム、0（ゼロ）の保護値の品質を使用するRPCSEC_GSSによってLIPKEY者にGSS_Wrap（）とGSS_GetMIC（）への後続の呼び出しをネゴシエートするからです。説明については、[RFC2025]のセクション5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEY uses SPKM-3 to create a secure channel in which to pass a user name and password from the client to the server. Once the user name and password have been accepted by the server, calls to the LIPKEY context are redirected to the SPKM-3 context. See [RFC2847] for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYは、クライアントからサーバにユーザ名とパスワードを渡すためにした安全なチャネルを作成するために、SPKM-3を使用しています。ユーザー名とパスワードがサーバーによって承認された後、SPKM-3のコンテキストにリダイレクトされLIPKEYコンテキストに呼び出します。詳細については、[RFC2847]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.3. SPKM-3 as a security triple
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.3。 SPKM-3トリプルセキュリティなど
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SPKM-3 GSS-API mechanism as described in [RFC2847] MUST be implemented and provide the following security triples. The definition of the columns matches the previous subsection &#34;Kerberos V5 as security triple&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2847]に記載されているようにSPKM-3 GSS-API機構が実装され、以下のセキュリティトリプルを提供しなければなりません。列の定義は、「セキュリティのトリプルとしてKerberos V5」前節と一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1      2        3                   4              5
   --------------------------------------------------------------------
   390009 spkm3    1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_none
   390010 spkm3i   1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_integrity
   390011 spkm3p   1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_privacy
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a discussion as to why the mechanism algorithm is listed as &#34;negotiated&#34;, see the previous section &#34;LIPKEY as a security triple.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
機構アルゴリズムは「交渉さ」と表示されている理由として議論については、「トリプルセキュリティとしてLIPKEY。」前のセクションを参照してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because SPKM-3 negotiates the algorithms, subsequent calls to SPKM-3&#39;s GSS_Wrap() and GSS_GetMIC() by RPCSEC_GSS will use a quality of protection value of 0 (zero). See section 5.2 of [RFC2025] for an explanation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SPKM-3は、アルゴリズムをネゴシエートするので、後続の呼び出しは、0（ゼロ）の保護値の品質を使用するRPCSEC_GSSによって者にGSS_Wrap（）とGSS_GetMIC（）-3をSPKMします。説明については、[RFC2025]のセクション5.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though LIPKEY is layered over SPKM-3, SPKM-3 is specified as a mandatory set of triples to handle the situations where the initiator (the client) is anonymous or where the initiator has its own certificate. If the initiator is anonymous, there will not be a user name and password to send to the target (the server). If the initiator has its own certificate, then using passwords is superfluous.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYがSPKM-3上に積層されていても、SPKM-3は、イニシエータ（クライアント）が匿名であるか、またはイニシエータは、自身の証明書を有する場合の状況を処理するためにトリプルの必須のセットとして指定されています。イニシエータが匿名である場合は、ユーザー名とパスワードがターゲット（サーバー）に送信することができません。イニシエータは、独自の証明書を持っている場合は、パスワードを使用することは不必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Security Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。セキュリティネゴシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the NFS version 4 server potentially offering multiple security mechanisms, the client needs a method to determine or negotiate which mechanism is to be used for its communication with the server. The NFS server may have multiple points within its filesystem name space that are available for use by NFS clients. In turn the NFS server may be configured such that each of these entry points may have different or multiple security mechanisms in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4サーバは、潜在的に複数のセキュリティメカニズムを提供して、クライアントは、サーバとの通信に使用すべきメカニズム決定または交渉する方法を必要とします。 NFSサーバは、NFSクライアントで使用するために用意されていて、ファイルシステム名前空間内の複数のポイントを有することができます。次に、NFSサーバは、これらのエントリ・ポイントの各々が使用中で異なる又は複数のセキュリティメカニズムを有することができるように構成されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security negotiation between client and server must be done with a secure channel to eliminate the possibility of a third party intercepting the negotiation sequence and forcing the client and server to choose a lower level of security than required or desired. See the section &#34;Security Considerations&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバ間のセキュリティネゴシエーションは、交渉のシーケンスを傍受し、必要または所望されるよりもセキュリティの低いレベルを選択し、クライアントとサーバーを強制的に第三者の可能性を排除するために安全なチャネルで行う必要があります。さらなる議論については、「セキュリティの考慮事項」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. SECINFO
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1。 SECINFO
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The new SECINFO operation will allow the client to determine, on a per filehandle basis, what security triple is to be used for server access. In general, the client will not have to use the SECINFO operation except during initial communication with the server or when the client crosses policy boundaries at the server. It is possible that the server&#39;s policies change during the client&#39;s interaction therefore forcing the client to negotiate a new security triple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいSECINFO操作はトリプルサーバーへのアクセスに使用するどのようなセキュリティ、ファイルハンドルごとに、クライアントが決定することができます。一般的には、クライアントは、サーバーまたはクライアントがサーバにポリシーの境界を越えるときとの最初の通信中以外SECINFO操作を使用する必要はありません。サーバーのポリシーがゆえトリプル新しいセキュリティを交渉するクライアントを強制的に、クライアントの相互作用の中に変化している可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. Security Error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2。セキュリティエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the assumption that each NFS version 4 client and server must support a minimum set of security (i.e., LIPKEY, SPKM-3, and Kerberos-V5 all under RPCSEC_GSS), the NFS client will start its communication with the server with one of the minimal security triples. During communication with the server, the client may receive an NFS error of NFS4ERR_WRONGSEC. This error allows the server to notify the client that the security triple currently being used is not appropriate for access to the server&#39;s filesystem resources. The client is then responsible for determining what security triples are available at the server and choose one which is appropriate for the client. See the section for the &#34;SECINFO&#34; operation for further discussion of how the client will respond to the NFS4ERR_WRONGSEC error and use SECINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各NFSバージョン4クライアントとサーバが、セキュリティの最小セット（すなわち、LIPKEY、SPKM-3、およびすべてのRPCSEC_GSSの下でのKerberos-V5）をサポートしなければならないという仮定に基づいて、NFSクライアントは、のいずれかでサーバーとの通信を開始します最低限のセキュリティトリプル。サーバーとの通信中に、クライアントはNFS4ERR_WRONGSECのNFSエラーが発生することがあります。このエラーは、サーバーがトリプル現在使用しているセキュリティがサーバのファイルシステムリソースへのアクセスのために適切ではないことをクライアントに通知することができます。クライアントは、セキュリティトリプルはサーバーで利用可能であり、クライアントに適切なものを選ぶかを決定する責任があります。クライアントがNFS4ERR_WRONGSECエラーに対応し、SECINFOを使用する方法のさらなる議論については、「SECINFO」操作のためのセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Callback RPC Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4。コールバックRPC認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except as noted elsewhere in this section, the callback RPC (described later) MUST mutually authenticate the NFS server to the principal that acquired the clientid (also described later), using the security flavor the original SETCLIENTID operation used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの他の場所で述べたように除き、（後述する）コールバックRPCは、互いにセキュリティ風味を使用した元のSETCLIENTID操作を使用して、（これも後述）のClientIDを取得主にNFSサーバを認証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AUTH_NONE, there are no principals, so this is a non-issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_NONEのために、そこにはプリンシパルではないので、これは非問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_SYS has no notions of mutual authentication or a server principal, so the callback from the server simply uses the AUTH_SYS credential that the user used when he set up the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_SYSは、相互認証やサーバープリンシパルのない概念を持っていないので、サーバからのコールバックは、単に彼が委任を設定するとき、ユーザーが使用AUTH_SYS資格情報を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AUTH_DH, one commonly used convention is that the server uses the credential corresponding to this AUTH_DH principal:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUTH_DHについて、1つの一般的に使用される規則は、サーバがこのAUTH_DHプリンシパルに対応する資格情報を使用していることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
unix.host@domain
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
うにｘ。ほｓｔ＠どまいん
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where host and domain are variables corresponding to the name of server host and directory services domain in which it lives such as a Network Information System domain or a DNS domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこのホストとドメインには、それは、そのようなネットワーク情報システムのドメインまたはDNSドメインとして住んでいるサーバーのホストとディレクトリサービスのドメイン名に対応する変数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because LIPKEY is layered over SPKM-3, it is permissible for the server to use SPKM-3 and not LIPKEY for the callback even if the client used LIPKEY for SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYがSPKM-3の上に積層されているので、サーバは、クライアントがSETCLIENTIDためLIPKEYを使用しても、コールバックのSPKM-3及びませんLIPKEYを使用することが許されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of what security mechanism under RPCSEC_GSS is being used, the NFS server, MUST identify itself in GSS-API via a GSS_C_NT_HOSTBASED_SERVICE name type. GSS_C_NT_HOSTBASED_SERVICE names are of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
かかわらずRPCSEC_GSSの下のセキュリティメカニズムが使用されているものの、NFSサーバは、GSS_C_NT_HOSTBASED_SERVICE名のタイプを経由してGSS-API自体を特定しなければなりません。 GSS_C_NT_HOSTBASED_SERVICE名の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
service@hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サービス@ホスト名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For NFS, the &#34;service&#34; element is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSの場合は、「サービス」の要素があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
同じ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations of security mechanisms will convert nfs@hostname to various different forms. For Kerberos V5 and LIPKEY, the following form is RECOMMENDED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ・メカニズムの実装は、種々の異なる形態にホスト名@ NFSを変換します。ケルベロスV5とLIPKEYに関しては、以下のフォームをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
nfs/hostname
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
NFS /ホスト名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Kerberos V5, nfs/hostname would be a server principal in the Kerberos Key Distribution Center database. This is the same principal the client acquired a GSS-API context for when it issued the SETCLIENTID operation, therefore, the realm name for the server principal must be the same for the callback as it was for the SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ケルベロスV5の場合は、NFS /ホスト名は、Kerberosキー配布センター・データベースのサーバープリンシパルになります。これにより、クライアントは、それがSETCLIENTIDのためにあったように、したがって、サーバー・プリンシパルのレルム名は、コールバックで同じにする必要があり、SETCLIENTID操作を発行したときのためのGSS-APIコンテキストを取得し同じ主体です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For LIPKEY, this would be the username passed to the target (the NFS version 4 client that receives the callback).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYに関しては、これはターゲット（コールバックを受けるNFSバージョン4クライアント）に渡されたユーザー名になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that LIPKEY may not work for callbacks, since the LIPKEY client uses a user id/password. If the NFS client receiving the callback can authenticate the NFS server&#39;s user name/password pair, and if the user that the NFS server is authenticating to has a public key certificate, then it works.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LIPKEYクライアントは、ユーザーID /パスワードを使用しているのでLIPKEYは、コールバックのために動作しないことに留意すべきです。コールバックを受けるNFSクライアントは、NFSサーバーのユーザー名/パスワードのペアを認証することができ、およびNFSサーバはに認証されたユーザーは、公開鍵証明書を持っている場合、それが動作するかどうか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In situations where the NFS client uses LIPKEY and uses a per-host principal for the SETCLIENTID operation, instead of using LIPKEY for SETCLIENTID, it is RECOMMENDED that SPKM-3 with mutual authentication be used. This effectively means that the client will use a certificate to authenticate and identify the initiator to the target on the NFS server. Using SPKM-3 and not LIPKEY has the following advantages:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSクライアントはLIPKEYを使用し、代わりSETCLIENTIDためLIPKEYを使用する、SETCLIENTID操作ごとのホストプリンシパルを使用する状況では、SPKM-3相互認証を使用することを推奨されています。これは事実上、クライアントがNFSサーバー上のターゲットにイニシエータを認証し、識別するために証明書を使用することを意味します。 SPKM-3及びませんLIPKEYを使用すると、次のような利点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the server does a callback, it must authenticate to the principal used in the SETCLIENTID. Even if LIPKEY is used, because LIPKEY is layered over SPKM-3, the NFS client will need to have a certificate that corresponds to the principal used in the SETCLIENTID operation. From an administrative perspective, having a user name, password, and certificate for both the client and server is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがコールバックを行う場合には、O、それがSETCLIENTIDに使用される主に認証する必要があります。 LIPKEYを用いてもLIPKEYがSPKM-3上に積層されているため、NFSクライアントはSETCLIENTID操作に使用される主に対応する証明書を持っている必要があります。管理上の観点からは、クライアントとサーバの両方のユーザー名、パスワード、および証明書を持つことは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LIPKEY was intended to minimize additional infrastructure requirements beyond a certificate for the target, and the expectation is that existing password infrastructure can be leveraged for the initiator. In some environments, a per-host password does not exist yet. If certificates are used for any per-host principals, then additional password infrastructure is not needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのLIPKEYは、ターゲットのための証明書以外の追加のインフラストラクチャ要件を最小限にするためのもの、と期待が既存のパスワードインフラストラクチャは、イニシエータのために活用することができるということであるました。一部の環境では、ホストごとのパスワードがまだ存在していません。証明書は任意のホストごとのプリンシパルのために使用されている場合は、追加のパスワードインフラストラクチャは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In cases when a host is both an NFS client and server, it can share the same per-host certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストは、NFSクライアントとサーバーの両方があるときOのケースでは、それは同じホストごとの証明書を共有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Filehandles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle in the NFS protocol is a per server unique identifier for a filesystem object. The contents of the filehandle are opaque to the client. Therefore, the server is responsible for translating the filehandle to an internal representation of the filesystem object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルにおけるファイルハンドルは、ファイルシステムオブジェクトのサーバごとに一意の識別子です。ファイルハンドルの内容は、クライアントに不透明です。したがって、サーバは、ファイルシステムオブジェクトの内部表現にファイルハンドルを変換する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Obtaining the First Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。まず、ファイルハンドルの取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operations of the NFS protocol are defined in terms of one or more filehandles. Therefore, the client needs a filehandle to initiate communication with the server. With the NFS version 2 protocol [RFC1094] and the NFS version 3 protocol [RFC1813], there exists an ancillary protocol to obtain this first filehandle. The MOUNT protocol, RPC program number 100005, provides the mechanism of translating a string based filesystem path name to a filehandle which can then be used by the NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの動作は、一つ以上のファイルハンドルで定義されています。そのため、クライアントは、サーバとの通信を開始するためにファイルハンドルを必要とします。 NFSバージョン2プロトコル[RFC1094]とNFSバージョン3プロトコル[RFC1813]と、この第一のファイルハンドルを取得するために補助的なプロトコルが存在します。 MOUNTプロトコル、RPCプログラム番号100005は、次いで、NFSプロトコルによって使用することができるファイルハンドルに文字列ベースのファイルシステムのパス名を変換する機構を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MOUNT protocol has deficiencies in the area of security and use via firewalls. This is one reason that the use of the public filehandle was introduced in [RFC2054] and [RFC2055]. With the use of the public filehandle in combination with the LOOKUP operation in the NFS version 2 and 3 protocols, it has been demonstrated that the MOUNT protocol is unnecessary for viable interaction between NFS client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MOUNTプロトコルがファイアウォールを経由して、セキュリティと使用領域の欠陥を持っています。これは、1つの公共ファイルハンドルの使用は[RFC2054]で導入されたことを理由と[RFC2055]です。 NFSバージョン2と3のプロトコルにおけるLOOKUP操作との組み合わせで、公共ファイルハンドルを使用すると、MOUNTプロトコルはNFSクライアントとサーバの間で実行可能な相互作用のために不必要であることが証明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the NFS version 4 protocol will not use an ancillary protocol for translation from string based path names to a filehandle. Two special filehandles will be used as starting points for the NFS client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、NFSバージョン4プロトコルは、ファイルハンドルに文字列ベースのパス名からの翻訳のための補助的なプロトコルを使用しません。二つの特別なファイルハンドルはNFSクライアントのための出発点として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1。ルートファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first of the special filehandles is the ROOT filehandle. The ROOT filehandle is the &#34;conceptual&#34; root of the filesystem name space at the NFS server. The client uses or starts with the ROOT filehandle by employing the PUTROOTFH operation. The PUTROOTFH operation instructs the server to set the &#34;current&#34; filehandle to the ROOT of the server&#39;s file tree. Once this PUTROOTFH operation is used, the client can then traverse the entirety of the server&#39;s file tree with the LOOKUP operation. A complete discussion of the server name space is in the section &#34;NFS Server Name Space&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別なファイルハンドルの最初は、ROOTファイルハンドルです。 ROOTファイルハンドルは、NFSサーバーでのファイルシステムの名前空間の「概念」ルートです。クライアントが使用していますかPUTROOTFH操作を採用することにより、ROOTファイルハンドルから始まります。 PUTROOTFH操作は、サーバーのファイルツリーのルートに「現在の」ファイルハンドルを設定するために、サーバーに指示します。このPUTROOTFH操作が使用されると、次にクライアントはLOOKUP操作でサーバーのファイルツリーの全体を横切ることができます。サーバーの名前空間の完全な議論は、セクション「NFSサーバーの名前空間」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2。公開ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second special filehandle is the PUBLIC filehandle. Unlike the ROOT filehandle, the PUBLIC filehandle may be bound or represent an arbitrary filesystem object at the server. The server is responsible for this binding. It may be that the PUBLIC filehandle and the ROOT filehandle refer to the same filesystem object. However, it is up to the administrative software at the server and the policies of the server administrator to define the binding of the PUBLIC filehandle and server filesystem object. The client may not make any assumptions about this binding. The client uses the PUBLIC filehandle via the PUTPUBFH operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第2の特殊ファイルハンドルは、PUBLICファイルハンドルです。 ROOTファイルハンドルとは異なり、PUBLICファイルハンドルは結合またはサーバで任意のファイルシステムのオブジェクトを表すことができます。サーバーは、この結合の原因です。これは、PUBLICファイルハンドルとROOTファイルハンドルは同じファイルシステムオブジェクトを参照している可能性があります。しかし、それはPUBLICファイルハンドルの結合およびサーバーのファイルシステムオブジェクトを定義するには、サーバーの管理ソフトウェア、およびサーバ管理者の方針次第です。クライアントは、このバインディングについての仮定をしない場合があります。クライアントはPUTPUBFH操作によってPUBLICファイルハンドルを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Filehandle Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。ファイルハンドルタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFS version 2 and 3 protocols, there was one type of filehandle with a single set of semantics. This type of filehandle is termed &#34;persistent&#34; in NFS Version 4. The semantics of a persistent filehandle remain the same as before. A new type of filehandle introduced in NFS Version 4 is the &#34;volatile&#34; filehandle, which attempts to accommodate certain server environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン2および3のプロトコルで、意味論の単一のセットを持つファイルハンドルの一つのタイプがありました。ファイルハンドルのこのタイプは、永続的なファイルハンドルの意味は前と同じままNFSバージョン4で「持続的」と呼ばれています。 NFSバージョン4で導入されたファイルハンドルの新しいタイプは、特定のサーバ環境に適応しようとする「揮発性」ファイルハンドルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The volatile filehandle type was introduced to address server functionality or implementation issues which make correct implementation of a persistent filehandle infeasible. Some server environments do not provide a filesystem level invariant that can be used to construct a persistent filehandle. The underlying server filesystem may not provide the invariant or the server&#39;s filesystem programming interfaces may not provide access to the needed invariant. Volatile filehandles may ease the implementation of server functionality such as hierarchical storage management or filesystem reorganization or migration. However, the volatile filehandle increases the implementation burden for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルタイプは、実行不可能な永続的なファイルハンドルの正しい実装を行うサーバー機能や実装の問題に対処するために導入されました。一部のサーバー環境では、永続的なファイルハンドルを構築するために使用することができ、ファイルシステムレベルの不変を提供していません。基盤となるサーバーのファイルシステムが必要な不変へのアクセスを提供することはできません不変またはサーバのファイルシステム・プログラミング・インタフェースを提供することはできません。揮発性ファイルハンドルは、階層型ストレージ管理やファイルシステムの再編成または移行などのサーバ機能の実装を容易にすることができます。ただし、揮発性ファイルハンドルは、クライアントの実装の負担が増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the client will need to handle persistent and volatile filehandles differently, a file attribute is defined which may be used by the client to determine the filehandle types being returned by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは異なり、永続的かつ揮発性ファイルハンドルを処理する必要がありますので、ファイルの属性は、サーバーによって返されるファイルハンドルのタイプを決定するために、クライアントが使用することができるが定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. General Properties of a Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1。ファイルハンドルの一般プロパティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filehandle contains all the information the server needs to distinguish an individual file. To the client, the filehandle is opaque. The client stores filehandles for use in a later request and can compare two filehandles from the same server for equality by doing a byte-by-byte comparison. However, the client MUST NOT otherwise interpret the contents of filehandles. If two filehandles from the same server are equal, they MUST refer to the same file. Servers SHOULD try to maintain a one-to-one correspondence between filehandles and files but this is not required. Clients MUST use filehandle comparisons only to improve performance, not for correct behavior. All clients need to be prepared for situations in which it cannot be determined whether two filehandles denote the same object and in such cases, avoid making invalid assumptions which might cause incorrect behavior. Further discussion of filehandle and attribute comparison in the context of data caching is presented in the section &#34;Data Caching and File Identity&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルは、サーバーは、個々のファイルを区別するために必要なすべての情報が含まれています。クライアントに、ファイルハンドルは不透明です。クライアント店後の要求で使用するためにファイルハンドルとバイト単位の比較を行うことによって平等に同じサーバーから二つのファイルハンドルを比較することができます。ただし、クライアントは、そうでない場合はファイルハンドルの内容を解釈してはいけません。同じサーバからの2つのファイルハンドルが等しい場合、それらは同じファイルを参照する必要があります。サーバーは、ファイルハンドルとファイルとの間の1対1の対応を維持しようとする必要がありますが、これは必須ではありません。クライアントは、だけでなく、正しい動作のために、パフォーマンスを向上させるためにファイルハンドルの比較を使用しなければなりません。すべてのクライアントは、2つのファイルハンドルが同じオブジェクトを表すかどうかを判断し、そのような場合には、不正な動作を引き起こす可能性がある無効な仮定を避けることができない状況のために準備する必要があります。また、ファイルハンドルの議論とデータキャッシュの内容を比較した属性は、「データキャッシュとファイルのアイデンティティ」に提示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, in the case that two different path names when traversed at the server terminate at the same filesystem object, the server SHOULD return the same filehandle for each path. This can occur if a hard link is used to create two file names which refer to the same underlying file object and associated data. For example, if paths /a/b/c and /a/d/c refer to the same file, the server SHOULD return the same filehandle for both path names traversals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一例として、サーバで横断つの異なるパス名が同じファイルシステムオブジェクトで終端している場合に、サーバは、パス毎に同じファイルハンドルを返すべきです。ハードリンクは、同じ基本的なファイルオブジェクトと関連付けられたデータを参照する2人のファイル名を作成するために使用されている場合に発生する可能性があります。および/ A / D /同一のファイルを参照cはパス/ A / B / Cの場合、例えば、サーバは、両方のパス名のトラバーサルのために同じファイルハンドルを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Persistent Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2。永続的なファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A persistent filehandle is defined as having a fixed value for the lifetime of the filesystem object to which it refers. Once the server creates the filehandle for a filesystem object, the server MUST accept the same filehandle for the object for the lifetime of the object. If the server restarts or reboots the NFS server must honor the same filehandle value as it did in the server&#39;s previous instantiation. Similarly, if the filesystem is migrated, the new NFS server must honor the same filehandle as the old NFS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
永続ファイルハンドルは、それが参照するファイルシステム・オブジェクトの寿命のために固定値を有するものとして定義されます。サーバーは、ファイルシステムオブジェクトのファイルハンドルを作成すると、サーバーは、オブジェクトの寿命のためのオブジェクトの同じファイルハンドルを受け入れなければなりません。サーバーが再起動または再起動すると、それは、サーバーの以前のインスタンスで行ったようにNFSサーバは、同じファイルハンドル値を尊重しなければなりません。ファイルシステムを移行する場合は同様に、新しいNFSサーバは、古いNFSサーバと同じファイルハンドルを尊重しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The persistent filehandle will be become stale or invalid when the filesystem object is removed. When the server is presented with a persistent filehandle that refers to a deleted object, it MUST return an error of NFS4ERR_STALE. A filehandle may become stale when the filesystem containing the object is no longer available. The file system may become unavailable if it exists on removable media and the media is no longer available at the server or the filesystem in whole has been destroyed or the filesystem has simply been removed from the server&#39;s name space (i.e., unmounted in a UNIX environment).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムオブジェクトが削除されたときに永続的なファイルハンドルが古い、または無効になってされます。サーバーが削除されたオブジェクトを参照する永続的なファイルハンドルが提示されている場合、それはNFS4ERR_STALEのエラーを返さなければなりません。オブジェクトを含むファイルシステムが使用できなくなったとき、ファイルハンドルが古くなっていないことがあります。それは、リムーバブルメディア上に存在しないと、UNIX環境では（すなわち、アンマウントメディアはサーバーで使用できなくなったか、全体でファイルシステムが破壊されているか、ファイルシステムは、単にサーバーの名前空間から削除されている場合は、ファイルシステムが使用できなくなることがあり）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3。揮発性ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A volatile filehandle does not share the same longevity characteristics of a persistent filehandle. The server may determine that a volatile filehandle is no longer valid at many different points in time. If the server can definitively determine that a volatile filehandle refers to an object that has been removed, the server should return NFS4ERR_STALE to the client (as is the case for persistent filehandles). In all other cases where the server determines that a volatile filehandle can no longer be used, it should return an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルは、持続的なファイルハンドルの同じ寿命特性を共有しません。サーバーは、揮発性ファイルハンドルが時間内に多くの異なる時点でもはや有効であることを決定しないことがあります。サーバは決定的揮発性ファイルハンドルが削除されたオブジェクトを参照することを決定することができる場合（永続ファイルハンドルの場合のように）、サーバは、クライアントにNFS4ERR_STALEを返すべきです。サーバーが揮発性ファイルハンドルが使用できなくなると判断した他のすべてのケースでは、それはNFS4ERR_FHEXPIREDのエラーを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mandatory attribute &#34;fh_expire_type&#34; is used by the client to determine what type of filehandle the server is providing for a particular filesystem. This attribute is a bitmask with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須属性「fh_expire_type」は、特定のファイルシステムのために提供しているファイルハンドルのサーバーの種類を決定するために、クライアントによって使用されます。この属性は、次の値を持つビットマスクです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_PERSISTENT The value of FH4_PERSISTENT is used to indicate a persistent filehandle, which is valid until the object is removed from the filesystem. The server will not return NFS4ERR_FHEXPIRED for this filehandle. FH4_PERSISTENT is defined as a value in which none of the bits specified below are set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_PERSISTENTはFH4_PERSISTENTの値は、オブジェクトがファイルシステムから削除されるまで有効で永続的なファイルハンドルを示すために使用されます。サーバーは、このファイルハンドルのためNFS4ERR_FHEXPIREDを返しません。 FH4_PERSISTENTは、以下の指定されたビットのどれも設定されていないれた値として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOLATILE_ANY The filehandle may expire at any time, except as specifically excluded (i.e., FH4_NO_EXPIRE_WITH_OPEN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOLATILE_ANYは、ファイルハンドルは、具体的に（即ち、FH4_NO_EXPIRE_WITH_OPEN）除外を除き、任意の時点で有効期限が切れることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_NOEXPIRE_WITH_OPEN May only be set when FH4_VOLATILE_ANY is set. If this bit is set, then the meaning of FH4_VOLATILE_ANY is qualified to exclude any expiration of the filehandle when it is open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOLATILE_ANYが設定されている場合FH4_NOEXPIRE_WITH_OPENにのみ設定することができます。このビットがセットされている場合は、FH4_VOLATILE_ANYの意味は、それが開いているときにファイルハンドルのいずれかの有効期限を除外する資格があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATION The filehandle will expire as a result of migration. If FH4_VOL_ANY is set, FH4_VOL_MIGRATION is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_MIGRATIONファイルハンドルは、移行の結果として、期限切れになります。 FH4_VOL_ANYが設定されている場合、FH4_VOL_MIGRATIONは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_RENAME The filehandle will expire during rename. This includes a rename by the requesting client or a rename by any other client. If FH4_VOL_ANY is set, FH4_VOL_RENAME is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH4_VOL_RENAMEは、ファイルハンドルは、名前の変更時に期限切れになります。これは、要求元のクライアントによる名前変更またはその他のクライアントによる名前の変更が含まれています。 FH4_VOL_ANYが設定されている場合、FH4_VOL_RENAMEは冗長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers which provide volatile filehandles that may expire while open (i.e., if FH4_VOL_MIGRATION or FH4_VOL_RENAME is set or if FH4_VOLATILE_ANY is set and FH4_NOEXPIRE_WITH_OPEN not set), should deny a RENAME or REMOVE that would affect an OPEN file of any of the components leading to the OPEN file. In addition, the server should deny all RENAME or REMOVE requests during the grace period upon server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、有効期限が切れて揮発性ファイルハンドルを提供するサーバのオープン（すなわち、FH4_VOL_MIGRATIONまたはFH4_VOL_RENAMEが設定されているか、またはFH4_VOLATILE_ANYが設定されているとFH4_NOEXPIRE_WITH_OPENが設定されていない場合場合）、RENAMEを否定するかにつながるのコンポーネントのいずれかのOPENのファイルに影響を与えることを削除する必要がありますOPENファイル。また、サーバはすべてのRENAMEを否定すべきか、サーバの再起動時に猶予期間中の要求を削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the bits FH4_VOL_MIGRATION and FH4_VOL_RENAME allow the client to determine that expiration has occurred whenever a specific event occurs, without an explicit filehandle expiration error from the server. FH4_VOL_ANY does not provide this form of information. In situations where the server will expire many, but not all filehandles upon migration (e.g., all but those that are open), FH4_VOLATILE_ANY (in this case with FH4_NOEXPIRE_WITH_OPEN) is a better choice since the client may not assume that all filehandles will expire when migration occurs, and it is likely that additional expirations will occur (as a result of file CLOSE) that are separated in time from the migration event itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットFH4_VOL_MIGRATIONとFH4_VOL_RENAMEは、特定のイベントが発生するたびにその有効期限を決定するために、クライアントがサーバからの明示的なファイルハンドル満了エラーなしで、発生している可能にすることに注意してください。 FH4_VOL_ANYはこの情報の形式を提供していません。サーバは、多くの期限切れとなる状況が、移行時ではないすべてのファイルハンドル（例えば、すべてが、オープンされているもの）では、（FH4_NOEXPIRE_WITH_OPENこの場合）FH4_VOLATILE_ANYは、クライアントは、すべてのファイルハンドルがときに期限切れになることを前提としない場合がありますので、より良い選択でありますマイグレーションが発生し、移行イベント自体から時間的に分離されている（ファイルCLOSEの結果として）追加の有効期限が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4. One Method of Constructing a Volatile Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4。揮発性ファイルハンドルを構築する一つの方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A volatile filehandle, while opaque to the client could contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドル、クライアントへの不透明が含まれている可能性がありながら：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[volatile bit = 1 | server boot time | slot | generation number]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[揮発性ビット= 1 |サーバーの起動時間|スロット|世代番号]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o slot is an index in the server volatile filehandle table
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oスロットは、サーバ揮発性ファイルハンドルテーブルのインデックスであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o generation number is the generation number for the table entry/slot
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O世代番号は、テーブルエントリ/スロットの世代番号であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client presents a volatile filehandle, the server makes the following checks, which assume that the check for the volatile bit has passed. If the server boot time is less than the current server boot time, return NFS4ERR_FHEXPIRED. If slot is out of range, return NFS4ERR_BADHANDLE. If the generation number does not match, return NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、揮発性ファイルハンドルを提示すると、サーバーは、揮発性ビットのチェックが合格したことを前提とし、以下のチェックを、作ります。サーバーの起動時間は、現在のサーバーの起動時間よりも小さい場合、NFS4ERR_FHEXPIREDを返します。スロットが範囲外の場合は、NFS4ERR_BADHANDLEを返します。世代番号が一致しない場合は、NFS4ERR_FHEXPIREDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server reboots, the table is gone (it is volatile).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーを再起動すると、テーブルには消えている（それは揮発性です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If volatile bit is 0, then it is a persistent filehandle with a different structure following it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性のビットが0であれば、それはそれ以下の異なる構造を持つ永続的なファイルハンドルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Client Recovery from Filehandle Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。ファイルハンドルの有効期限からクライアント回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If possible, the client SHOULD recover from the receipt of an NFS4ERR_FHEXPIRED error. The client must take on additional responsibility so that it may prepare itself to recover from the expiration of a volatile filehandle. If the server returns persistent filehandles, the client does not need these additional steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能な場合、クライアントはNFS4ERR_FHEXPIREDエラーの受領から回復する必要があります。それは揮発性ファイルハンドルの満了から回復するために自分自身を準備することができるように、クライアントは、追加の責任を取る必要があります。サーバーは、永続的なファイルハンドルを返した場合、クライアントは、これらの追加の手順は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For volatile filehandles, most commonly the client will need to store the component names leading up to and including the filesystem object in question. With these names, the client should be able to recover by finding a filehandle in the name space that is still available or by starting at the root of the server&#39;s filesystem name space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルのために、最も一般的なクライアントは、コンポーネント名に至るまで、問題のファイルシステムオブジェクトを含むを保存する必要があります。これらの名前を使用すると、クライアントはまだ利用できたり、サーバのファイルシステム名前空間のルートから始まることである名前空間にファイルハンドルを見つけることによって回復することができるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the expired filehandle refers to an object that has been removed from the filesystem, obviously the client will not be able to recover from the expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
期限切れのファイルハンドルは、ファイルシステムから削除されたオブジェクトを参照する場合は、明らかにクライアントが期限切れのファイルハンドルから回復することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also possible that the expired filehandle refers to a file that has been renamed. If the file was renamed by another client, again it is possible that the original client will not be able to recover. However, in the case that the client itself is renaming the file and the file is open, it is possible that the client may be able to recover. The client can determine the new path name based on the processing of the rename request. The client can then regenerate the new filehandle based on the new path name. The client could also use the compound operation mechanism to construct a set of operations like: RENAME A B LOOKUP B GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
期限切れのファイルハンドルの名前が変更されたファイルを参照することも可能です。ファイルが別のクライアントによって名前が変更された場合は、再度、元のクライアントが回復することができない可能性があります。しかし、クライアント自身がファイルの名前を変更され、ファイルが開いている場合には、クライアントが回復することができる可能性があります。クライアントは、名前変更要求の処理に基づいて、新しいパス名を決定することができます。クライアントは、新しいパス名に基づいて新しいファイルハンドルを再生成することができます。 B LOOKUP B GETFHの名前を変更しますように、クライアントはまた、操作のセットを構築する複合操作機構を使用することができ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the COMPOUND procedure does not provide atomicity. This example only reduces the overhead of recovering from an expired filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順は原子性を提供していないことに注意してください。この例では、唯一の有効期限が切れたファイルハンドルからの回復のオーバーヘッドを軽減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. File Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.ファイル属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To meet the requirements of extensibility and increased interoperability with non-UNIX platforms, attributes must be handled in a flexible manner. The NFS version 3 fattr3 structure contains a fixed list of attributes that not all clients and servers are able to support or care about. The fattr3 structure can not be extended as new needs arise and it provides no way to indicate non-support. With the NFS version 4 protocol, the client is able query what attributes the server supports and construct requests with only those supported attributes (or a subset thereof).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非UNIXプラットフォームと拡張性と相互運用性が向上の要件を満たすために、属性は、柔軟な方法で処理しなければなりません。 NFSバージョン3 fattr3構造がない、すべてのクライアントとサーバーがサポートするかを気にすることができます属性の固定されたリストが含まれています。新たなニーズが発生し、それが非サポートを示す方法を提供していませんようfattr3構造を拡張することはできません。 NFSバージョン4プロトコルでは、クライアントは、サーバーがサポートする属性とのみサポートされる属性（またはそのサブセット）でリクエストを構築するものができたクエリです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To this end, attributes are divided into three groups: mandatory, recommended, and named. Both mandatory and recommended attributes are supported in the NFS version 4 protocol by a specific and well-defined encoding and are identified by number. They are requested by setting a bit in the bit vector sent in the GETATTR request; the server response includes a bit vector to list what attributes were returned in the response. New mandatory or recommended attributes may be added to the NFS protocol between major revisions by publishing a standards-track RFC which allocates a new attribute number value and defines the encoding for the attribute. See the section &#34;Minor Versioning&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、必須、推奨、およびという名前のこの目的を達成するために、属性は、3つのグループに分けています。必須および推奨両方の属性を特定し、明確に定義されたエンコーディングによってNFSバージョン4プロトコルでサポートされており、番号で識別されます。それらはGETATTR要求で送信されたビット・ベクトル内のビットを設定することによって要求されています。サーバーの応答は、属性が応答で返されたものをリストするビットベクトルを含んでいます。新しい必須または推奨の属性は新しい属性数値を割り当て、属性のエンコーディングを定義する標準トラックRFCを公開することによって、主要なリビジョン間のNFSプロトコルに加えてもよいです。さらなる議論については、「マイナーバージョン」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes are accessed by the new OPENATTR operation, which accesses a hidden directory of attributes associated with a file system object. OPENATTR takes a filehandle for the object and returns the filehandle for the attribute hierarchy. The filehandle for the named attributes is a directory object accessible by LOOKUP or READDIR and contains files whose names represent the named attributes and whose data bytes are the value of the attribute. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、ファイル・システム・オブジェクトに関連付けられた属性の隠しディレクトリにアクセスし、新たなOPENATTR操作によってアクセスされています。 OPENATTRは、オブジェクトのファイルハンドルを取り、属性階層のためのファイルハンドルを返します。名前の属性のファイルハンドルは、LOOKUPまたはREADDIRからアクセス可能なディレクトリオブジェクトで、名前が命名された属性とデータバイト属性の値ですが表すファイルが含まれています。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
LOOKUP &#34;foo&#34; ; look up file GETATTR attrbits OPENATTR ; access foo&#39;s named attributes LOOKUP &#34;x11icon&#34; ; look up specific attribute READ 0,4096 ; read stream of bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
LOOKUP &#34;foo&#34; という。ファイルGETATTRのattrbitsのOPENATTRを見上げます。アクセス、fooの名前の属性LOOKUP「x11icon」。 READ 0,4096特定の属性を調べます。バイトのストリームを読みます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Named attributes are intended for data needed by applications rather than by an NFS client implementation. NFS implementors are strongly encouraged to define their new attributes as recommended attributes by bringing them to the IETF standards-track process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前付き属性は、アプリケーションではなく、NFSクライアントの実装が必要とするデータのために意図されています。 NFSの実装が強くIETF標準トラックプロセスにそれらをもたらすことによって推奨属性とその新しい属性を定義することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of attributes which are classified as mandatory is deliberately small since servers must do whatever it takes to support them. A server should support as many of the recommended attributes as possible but by their definition, the server is not required to support all of them. Attributes are deemed mandatory if the data is both needed by a large number of clients and is not otherwise reasonably computable by the client when support is not provided on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはそれがそれらをサポートするために取るものは何でもしなければならないので、必須として分類されている属性のセットは、意図的に小さいです。サーバーは、可能な限り推奨属性の多くが、その定義により、サーバはそれらのすべてをサポートする必要はありませんをサポートする必要があります。データは両方の多数のクライアントが必要とするとサポートがサーバー上で提供されていない場合、クライアントでそれ以外の場合は、合理的に計算可能でない場合、属性は必須と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the hidden directory returned by OPENATTR is a convenience for protocol processing. The client should not make any assumptions about the server&#39;s implementation of named attributes and whether the underlying filesystem at the server has a named attribute directory or not. Therefore, operations such as SETATTR and GETATTR on the named attribute directory are undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENATTRによって返された隠しディレクトリは、プロトコル処理のための便利であることに注意してください。クライアントは、指定された属性のサーバの実装について、サーバーの基本となるファイルシステムが名前の属性ディレクトリがあるかどうかを任意の仮定を行うべきではありません。したがって、このような名前の属性ディレクトリにSETATTRやGETATTRなどの操作が定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Mandatory Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。必須属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These MUST be supported by every NFS version 4 client and server in order to ensure a minimum level of interoperability. The server must store and return these attributes and the client must be able to function with an attribute set limited to these attributes. With just the mandatory attributes some client functionality may be impaired or limited in some ways. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request and the server must return their value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらは、相互運用性の最小レベルを確保するために、すべてのNFSバージョン4のクライアントとサーバーがサポートしなければなりません。サーバに格納され、これらの属性を返し、クライアントがこれらの属性に制限された属性セットで機能することができなければならない必要があります。ただ、必須属性を持ついくつかのクライアント機能が損なわれる可能性があるか、いくつかの方法で制限されています。これらの属性のいずれかを求めることができるクライアントがGETATTR要求でビットを設定することによって返されると、サーバはその値を返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Recommended Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。推奨属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These attributes are understood well enough to warrant support in the NFS version 4 protocol. However, they may not be supported on all clients and servers. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request but must handle the case where the server does not return them. A client may ask for the set of attributes the server supports and should not request attributes the server does not support. A server should be tolerant of requests for unsupported attributes and simply not return them rather than considering the request an error. It is expected that servers will support all attributes they comfortably can and only fail to support attributes which are difficult to support in their operating environments. A server should provide attributes whenever they don&#39;t have to &#34;tell lies&#34; to the client. For example, a file modification time should be either an accurate time or should not be supported by the server. This will not always be comfortable to clients but the client is better positioned decide whether and how to fabricate or construct an attribute or whether to do without the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの属性は、NFSバージョン4プロトコルでのサポートを保証する十分に理解されています。しかし、彼らはすべてのクライアントとサーバーではサポートされない場合があります。クライアントは、GETATTR要求にビットをセットすることによって返されるこれらの属性のいずれかを求めることができるが、サーバーがそれらを返さない場合を処理する必要があります。クライアントは、サーバーがサポートする属性の集合を求めることができるとすべきではない要求はサポートしていないサーバを属性。サーバがサポートされていない属性に対する要求の耐性があると単純にかなり要求エラーを考慮よりもそれらを返すべきではありません。サーバは、彼らが快適にできるすべての属性をサポートするだけで自分の操作環境でサポートすることが困難な属性をサポートするために失敗することが期待されます。彼らは、クライアントに「嘘をつく」する必要はありませんいつでもサーバーは、属性を提供する必要があります。例えば、ファイルの修正時刻が正確な時間のいずれかでなければなりませんまたはサーバーでサポートされていないはずです。これは、常にクライアントに快適ではありませんが、クライアントは、より良い製造または属性を構築または属性なしで行うかどうかをするかどうか、およびその方法を決定配置されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Named Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。指定された属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These attributes are not supported by direct encoding in the NFS Version 4 protocol but are accessed by string names rather than numbers and correspond to an uninterpreted stream of bytes which are stored with the filesystem object. The name space for these attributes may be accessed by using the OPENATTR operation. The OPENATTR operation returns a filehandle for a virtual &#34;attribute directory&#34; and further perusal of the name space may be done using READDIR and LOOKUP operations on this filehandle. Named attributes may then be examined or changed by normal READ and WRITE and CREATE operations on the filehandles returned from READDIR and LOOKUP. Named attributes may have attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの属性は、NFSバージョン4プロトコルで直接符号化することによってサポートされていないが、文字列の名前ではなく番号でアクセスされ、ファイルシステムオブジェクトに格納されたバイトの未解釈のストリームに対応します。これらの属性の名前空間はOPENATTR操作を使用してアクセスすることができます。 OPENATTR操作は、仮想的な「属性ディレクトリ」と、このファイルハンドルに対してREADDIRとLOOKUP操作を用いて行うことができるネームスペースのさらなる閲覧のためのファイルハンドルを返します。命名された属性は、次いで、検査又は正常READによって変更およびファイルハンドルに書き込み、CREATE操作はREADDIRとLOOKUPから返されてもよいです。名前付き属性は、属性を有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is recommended that servers support arbitrary named attributes. A client should not depend on the ability to store any named attributes in the server&#39;s filesystem. If a server does support named attributes, a client which is also able to handle them should be able to copy a file&#39;s data and meta-data with complete transparency from one location to another; this would imply that names allowed for regular directory entries are valid for named attribute names as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、任意の名前の属性をサポートすることをお勧めします。クライアントは、サーバのファイルシステム内の任意の名前の属性を格納する能力に依存すべきではありません。サーバがサポートという名前の属性がない場合、またそれらを扱うことができるクライアントは、ある場所から別の場所への完全な透明性を持つファイルのデータとメタデータをコピーすることができるはずです。これは、通常のディレクトリエントリには使用でき名称は、同様の名前の属性名のために有効であることを含意するでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Names of attributes will not be controlled by this document or other IETF standards track documents. See the section &#34;IANA Considerations&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性の名前は、この文書または他のIETFの標準トラック文書によって制御されることはありません。さらなる議論については、「IANAの考慮事項」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Classification of Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。属性の分類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the Mandatory and Recommended attributes can be classified in one of three categories: per server, per filesystem, or per filesystem object. Note that it is possible that some per filesystem attributes may vary within the filesystem. See the &#34;homogeneous&#34; attribute for its definition. Note that the attributes time_access_set and time_modify_set are not listed in this section because they are write-only attributes corresponding to time_access and time_modify, and are used in a special instance of SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーごと、ファイルシステムごと、またはファイルシステムオブジェクトごと：必須および推奨の属性は、次の3つのカテゴリのいずれかに分類することができ、それぞれ。ファイルシステムの属性ごとのいくつかは、ファイルシステム内で変動する可能性があることに注意してください。その定義について「均質」属性を参照してください。属性time_access_setとtime_modify_setは、それらが書き込み専用のtime_accessとtime_modifyに対応する属性であるため、このセクションに記載されていない、とSETATTRの特殊なインスタンスで使用されることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per server attribute is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバーあたりの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
lease_time
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
リース時間
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per filesystem attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oファイルシステムの属性ごとに、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
supp_attr, fh_expire_type, link_support, symlink_support, unique_handles, aclsupport, cansettime, case_insensitive, case_preserving, chown_restricted, files_avail, files_free, files_total, fs_locations, homogeneous, maxfilesize, maxname, maxread, maxwrite, no_trunc, space_avail, space_free, space_total, time_delta
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
supp_attr、fh_expire_type、link_support、symlink_support、unique_handles、aclsupport、cansettime、CASE_INSENSITIVE、case_preserving、chown_restricted、files_avail、files_free、files_total、fs_位置、均質、MAXFILESIZE、MAXNAME、maxread、maxwrite、no_trunc、space_avail、space_free、space_total、TIME_DELTA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The per filesystem object attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oをファイルシステムごとにオブジェクトの属性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
type, change, size, named_attr, fsid, rdattr_error, filehandle, ACL, archive, fileid, hidden, maxlink, mimetype, mode, numlinks, owner, owner_group, rawdev, space_used, system, time_access, time_backup, time_create, time_metadata, time_modify, mounted_on_fileid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
タイプ、変更、サイズ、named_attr、FSID、rdattr_error、ファイルハンドル、ACL、アーカイブ、FILEID、隠された、maxlink、MIMEタイプ、モード、numlinks、所有者、owner_group、rawdev、space_used、システム、time_access、time_backup、time_create、time_metadata、time_modify、 mounted_on_fileid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For quota_avail_hard, quota_avail_soft, and quota_used see their definitions below for the appropriate classification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hardについては、quota_avail_soft、および適切な分類については、以下のそれらの定義を参照してくださいQUOTA_USED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Mandatory Attributes - Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。必須属性 - 定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Name              #    DataType     Access   Description
   ___________________________________________________________________
   supp_attr         0    bitmap       READ     The bit vector which
                                                would retrieve all
                                                mandatory and
                                                recommended attributes
                                                that are supported for
                                                this object.  The
                                                scope of this
                                                attribute applies to
                                                all objects with a
                                                matching fsid.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type 1 nfs4_ftype READ The type of the object (file, directory, symlink, etc.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ1は、オブジェクト（などのファイル、ディレクトリ、シンボリックリンク）のタイプを読み取るnfs4_ftype
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fh_expire_type 2 uint32 READ Server uses this to specify filehandle expiration behavior to the client. See the section &#34;Filehandles&#34; for additional description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fh_expire_type 2 UINT32 READサーバーは、クライアントにファイルハンドルの有効期限の動作を指定するために、これを使用しています。追加の説明については、「ファイルハンドル」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change 3 uint64 READ A value created by the server that the client can use to determine if file data, directory contents or attributes of the object have been modified. The server may return the object&#39;s time_metadata attribute for this attribute&#39;s value but only if the filesystem object can not be updated more frequently than the resolution of time_metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更3は、クライアントがファイルデータ、ディレクトリの内容またはオブジェクトの属性が変更されているかどうかを判断するために使用することができ、サーバによって作成された値を読み取るUINT64。サーバーは、この属性の値のオブジェクトのtime_metadata属性を返すかもしれませんが、ファイルシステムオブジェクトがtime_metadataの解像度よりも頻繁に更新することができない場合にのみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
size 4 uint64 R/W The size of the object in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サイズ4 UINT64のR /バイト単位でオブジェクトのサイズW。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
link_support 5 bool READ True, if the object&#39;s filesystem supports hard links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対象のファイルシステムはハードリンクをサポートしている場合link_support 5は、真のREAD BOOL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
symlink_support 6 bool READ True, if the object&#39;s filesystem supports symbolic links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのファイルシステムがシンボリックリンクをサポートしている場合symlink_support 6は、真READ BOOL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
named_attr 7 bool READ True, if this object has named attributes. In other words, object has a non-empty named attribute directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトが属性を指名した場合named_attr 7は、真のREAD BOOL。つまり、オブジェクトが空でない名前の属性ディレクトリを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsid 8 fsid4 READ Unique filesystem identifier for the filesystem holding this object. fsid contains major and minor components each of which are uint64.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSID 8 fsid4は、このオブジェクトを保持しているファイルシステムのためのユニークなファイルシステム識別子をお読みください。 FSIDはuint64型ですそれぞれのメジャーとマイナーのコンポーネントが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unique_handles 9 bool READ True, if two distinct filehandles guaranteed to refer to two different filesystem objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
二つの異なるファイルハンドルが2つの異なるファイルシステムのオブジェクトを参照することが保証場合unique_handles 9は、真のREAD BOOL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lease_time 10 nfs_lease4 READ Duration of leases at server in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
秒で、サーバーのリースのlease_time 10 nfs_lease4 READ期間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rdattr_error 11 enum READ Error returned from getattr during readdir.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rdattr_error 11列挙型読み取りエラーがreaddirの中にGETATTRから返されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
filehandle 19 nfs_fh4 READ The filehandle of this object (primarily for readdir requests).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（主のreaddir要求のための）このオブジェクトのファイルハンドルをREAD nfs_fh4 19ファイルハンドル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. Recommended Attributes - Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6。推奨属性 - 定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Name                #    Data Type      Access   Description
   _____________________________________________________________________
   ACL                 12   nfsace4&lt;&gt;      R/W      The access control
                                                    list for the object.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aclsupport 13 uint32 READ Indicates what types of ACLs are supported on the current filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aclsupport 13 UINT32 READでは、ACLの種類は、現在のファイルシステムでサポートされていることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
archive 14 bool R/W True, if this file has been archived since the time of last modification (deprecated in favor of time_backup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アーカイブ14ブールR / Wこのファイルが最後に変更された時以来、アーカイブされている場合はTrue、（time_backupの非推奨）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cansettime 15 bool READ True, if the server is able to change the times for a filesystem object as specified in a SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作に指定されているサーバーは、ファイルシステムオブジェクトの時間を変更することができる場合cansettime 15は、真のREAD BOOL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_insensitive 16 bool READ True, if filename comparisons on this filesystem are case insensitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルシステム上のファイル名の比較は大文字小文字を区別しない場合CASE_INSENSITIVE 16は、真のREAD BOOL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_preserving 17 bool READ True, if filename case on this filesystem are preserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このファイルシステム上のファイル名のケースが保存されている場合は17をcase_preservingすることは、真のREAD BOOL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chown_restricted 18 bool READ If TRUE, the server will reject any request to change either the owner or the group associated with a file if the caller is not a privileged user (for example, &#34;root&#34; in UNIX operating environments or in Windows 2000 the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXオペレーティング環境またはWindows 2000でTRUEの場合は、発信者が特権ユーザーでない場合、サーバは所有者またはファイルに関連付けられたグループのいずれかを変更するには、すべての要求を拒否します18ブールREAD（例えば、「ルート」をchown_restricted
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                                    &#34;Take Ownership&#34;
                                                    privilege).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fileid 20 uint64 READ A number uniquely identifying the file within the filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
20一意のファイルシステム内のファイルを識別する番号を読み取るUINT64 FILEID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_avail 21 uint64 READ File slots available to this user on the filesystem containing this object - this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
21 files_availこのオブジェクトを含むファイルシステム上でこのユーザに利用可能なUINT64 READファイルスロット - これは最小の関連限界であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_free 22 uint64 READ Free file slots on the filesystem containing this object - this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_free 22は、このオブジェクトを含むファイルシステム上の無料のファイルスロットをREAD UINT64  - これは、最小の関連する制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_total 23 uint64 READ Total file slots on the filesystem containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
files_total 23のuint64型は、このオブジェクトを含むファイルシステム上のファイルの総スロットをお読みください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_locations 24 fs_locations READ Locations where this filesystem may be found. If the server returns NFS4ERR_MOVED as an error, this attribute MUST be supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_位置24のfs_位置は、このファイルシステムが見つけることができる場所をお読みください。サーバがエラーとしてNFS4ERR_MOVEDを返す場合、この属性をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hidden 25 bool R/W True, if the file is considered hidden with respect to the Windows API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルは、WindowsのAPIに関して隠されたと見なされた場合、25ブールR / W真に隠されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
homogeneous 26 bool READ True, if this object&#39;s filesystem is homogeneous, i.e., are per filesystem attributes the same for all filesystem&#39;s objects?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムは、すべてのファイルシステムのオブジェクトに対して同じ属性ごとに26このオブジェクトのファイルシステムが均質である場合、真READブール均質な、すなわち、ありますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxfilesize 27 uint64 READ Maximum supported file size for the filesystem of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAXFILESIZE 27 uint64型READ最大は、このオブジェクトのファイルシステムのファイル・サイズをサポートしていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxlink 28 uint32 READ Maximum number of links for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxlink 28は、このオブジェクトのリンクの最大数をREAD UINT32。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxname 29 uint32 READ Maximum filename size supported for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
29 UINT32は、このオブジェクトに対してサポートされる最大ファイル名のサイズをREAD MAXNAME。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxread 30 uint64 READ Maximum read size supported for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxread 30 uint64型READ最大は、このオブジェクトに対してサポートされているサイズをお読みください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxwrite 31 uint64 READ Maximum write size supported for this object. This attribute SHOULD be supported if the file is writable. Lack of this attribute can lead to the client either wasting bandwidth or not receiving the best performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
maxwrite 31のuint64型が、このオブジェクトに対してサポートされている最大書き込みサイズをお読みください。ファイルが書き込み可能である場合、この属性はサポートされる必要があります。この属性の欠如は、いずれかの帯域幅を浪費や最高のパフォーマンスを受けていないクライアントにつながることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mimetype 32 utf8&lt;&gt; R/W MIME body type/subtype of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MIMEタイプ32 UTF8 &lt;オブジェクトの&gt; R / W MIMEボディタイプ/サブタイプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode 33 mode4 R/W UNIX-style mode and permission bits for this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトのモード33 MODE4 R / W UNIXスタイルのモードとパーミッションビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_trunc 34 bool READ True, if a name longer than name_max is used, an error be returned and name is not truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
真READ BOOL 34 no_trunc長いNAME_MAXよりも名前が使用されている場合は、エラーが返され、名前が切り捨てられていないこと。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
numlinks 35 uint32 READ Number of hard links to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトへのハードリンクのnumlinks 35 UINT32 READ番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
owner 36 utf8&lt;&gt; R/W The string name of the owner of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者36 UTF8 &lt;&gt; R /このオブジェクトの所有者の文字列名W。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
owner_group 37 utf8&lt;&gt; R/W The string name of the group ownership of this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
owner_group 37 UTF8 &lt;&gt; R /このオブジェクトのグループ所有権の文字列名W。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hard 38 uint64 READ For definition see &#34;Quota Attributes&#34; section below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hard 38は、以下の「クォータの属性」を参照してください。定義についてのセクションを読んUINT64。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_soft 39 uint64 READ For definition see &#34;Quota Attributes&#34; section below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照定義についてquota_avail_soft 39 UINT64 READ以下の「クォータ属性」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_used 40 uint64 READ For definition see &#34;Quota Attributes&#34; section below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のセクションを「クォータの属性」を参照してください定義については40 UINT64 READをQUOTA_USED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rawdev 41 specdata4 READ Raw device identifier. UNIX device major/minor node information. If the value of type is not NF4BLK or NF4CHR, the value return SHOULD NOT be considered useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
41 specdata4 READ生のデバイス識別子をrawdev。 UNIXデバイスメジャー/マイナーノード情報。タイプの値がNF4BLKかNF4CHRでない場合は、値のリターンが有用であるとみなされるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_avail 42 uint64 READ Disk space in bytes available to this user on the filesystem containing this object - this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
42 space_availこのオブジェクトを含むファイルシステム上でこのユーザに利用可能なバイトにUINT64 READディスク領域 - これは最小の関連限界であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_free 43 uint64 READ Free disk space in bytes on the filesystem containing this object - this should be the smallest relevant limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_free 43は、このオブジェクトを含むファイルシステム上のバイト単位で空きディスク容量をREAD UINT64  - これは、最小の関連する制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_total 44 uint64 READ Total disk space in bytes on the filesystem containing this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_total 44のuint64型は、このオブジェクトを含むファイルシステム上のバイト単位での総ディスク容量をお読みください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
space_used 45 uint64 READ Number of filesystem bytes allocated to this object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトに割り当てられたファイルシステムのバイトの45 UINT64 READ番号space_used。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
system 46 bool R/W True, if this file is a &#34;system&#34; file with respect to the Windows API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
システム46ブールR / W真、このファイルは、WindowsのAPIに関しては、「システム」ファイルがある場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_access 47 nfstime4 READ The time of last access to the object by a read that was satisfied by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって満たされた読み取りによりオブジェクトへの最後のアクセスの時間をREAD nfstime4 time_access 47。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_access_set 48 settime4 WRITE Set the time of last access to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_access_set 48 settime4が書くには、オブジェクトへの最後のアクセスの時間を設定します。 SETATTRにのみ使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_backup 49 nfstime4 R/W The time of last backup of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R /オブジェクトの最後のバックアップの時W nfstime4 49 time_backup。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_create 50 nfstime4 R/W The time of creation of the object. This attribute does not have any relation to the traditional UNIX file attribute &#34;ctime&#34; or &#34;change time&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_create 50 nfstime4 R /オブジェクトの作成の時間W。この属性は、伝統的なUNIXファイル属性「CTIME」または「変更時間」とは関係ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_delta 51 nfstime4 READ Smallest useful server time granularity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小の便利なサーバーの時間精度をREAD nfstime4 TIME_DELTA 51。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_metadata 52 nfstime4 READ The time of last meta-data modification of the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトの最後のメタデータ変更の時間をREAD nfstime4 time_metadata 52。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_modify 53 nfstime4 READ The time of last modification to the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトへの最後の変更の時間をREAD nfstime4 53 time_modify。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_modify_set 54 settime4 WRITE Set the time of last modification to the object. SETATTR use only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time_modify_set 54 settime4は、オブジェクトの最終更新時刻を設定書きます。 SETATTRにのみ使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mounted_on_fileid 55 uint64 READ Like fileid, but if the target filehandle is the root of a filesystem return the fileid of the underlying directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FILEIDように読めるUINT64 55をmounted_on_fileidが、ターゲットのファイルハンドルがある場合は、ファイルシステムのルートは、基礎となるディレクトリのFILEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. Time Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7。時間のアクセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As defined above, the time_access attribute represents the time of last access to the object by a read that was satisfied by the server. The notion of what is an &#34;access&#34; depends on server&#39;s operating environment and/or the server&#39;s filesystem semantics. For example, for servers obeying POSIX semantics, time_access would be updated only by the READLINK, READ, and READDIR operations and not any of the operations that modify the content of the object. Of course, setting the corresponding time_access_set attribute is another way to modify the time_access attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記に定義したように、time_access属性は、サーバーによって満たされた読み取りによって、オブジェクトへの最後のアクセスの時間を表しています。 「アクセス」であるものの概念は、サーバの動作環境および/またはサーバのファイルシステムのセマンティクスに依存します。例えば、POSIXのセマンティクスに従うサーバに対して、time_accessはREADLINK、READ、およびREADDIR操作ではなく、オブジェクトの内容を変更する操作のいずれかによって更新されます。もちろん、対応するtime_access_set属性を設定することtime_access属性を変更する別の方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever the file object resides on a writable filesystem, the server should make best efforts to record time_access into stable storage. However, to mitigate the performance effects of doing so, and most especially whenever the server is satisfying the read of the object&#39;s content from its cache, the server MAY cache access time updates and lazily write them to stable storage. It is also acceptable to give administrators of the server the option to disable time_access updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルオブジェクトが、書き込み可能なファイルシステム上に存在するたびに、サーバーは安定したストレージにtime_accessを記録するために最善の努力をする必要があります。しかし、そうすることのパフォーマンスへの影響を軽減するために、最も特に、サーバーがそのキャッシュからオブジェクトの内容の読み取りを満足されるたびに、サーバーは、アクセス時間の更新をキャッシュして、怠惰安定したストレージにそれらを書き込むことができます。サーバーの管理者はtime_access更新を無効にするオプションを与えることも可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. Interpreting owner and owner_group
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8。解釈の所有者とowner_group
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The recommended attributes &#34;owner&#34; and &#34;owner_group&#34; (and also users and groups within the &#34;acl&#34; attribute) are represented in terms of a UTF-8 string. To avoid a representation that is tied to a particular underlying implementation at the client or server, the use of the UTF-8 string has been chosen. Note that section 6.1 of [RFC2624] provides additional rationale. It is expected that the client and server will have their own local representation of owner and owner_group that is used for local storage or presentation to the end user. Therefore, it is expected that when these attributes are transferred between the client and server that the local representation is translated to a syntax of the form &#34;user@dns_domain&#34;. This will allow for a client and server that do not use the same local representation the ability to translate to a common syntax that can be interpreted by both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨属性の「所有者」と「owner_group」（とも「ACL」属性内のユーザーとグループ）はUTF-8文字列で表現されています。クライアントまたはサーバーで特定の基本的な実装に結び付けられている表現を避けるために、UTF-8文字列の使用が選択されています。 [RFC2624]のセクション6.1に注意してください追加の理論的根拠を提供します。クライアントとサーバは、エンドユーザーにローカルストレージやプレゼンテーションのために使用されている所有者とowner_groupの独自のローカルな表現を持っていることが期待されます。したがって、それは期待されているこれらの属性は、ローカル表現がフォーム「のuser @ dns_domain」の構文に変換され、クライアントとサーバーの間で転送されたとき。これは、同じローカルな表現を両方によって解釈することができ、共通の構文に変換する機能を使用していないクライアントとサーバが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, security principals may be represented in different ways by different security mechanisms. Servers normally translate these representations into a common format, generally that used by local storage, to serve as a means of identifying the users corresponding to these security principals. When these local identifiers are translated to the form of the owner attribute, associated with files created by such principals they identify, in a common format, the users associated with each corresponding set of security principals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、セキュリティプリンシパルは、異なるセキュリティメカニズムにより異なる方法で表すことができます。サーバは、通常、これらのセキュリティプリンシパルに対応するユーザを識別する手段として機能するように、ローカル記憶装置によって使用される一般的こと、共通の形式にこれらの表現を翻訳します。これらのローカル識別子は、彼らが特定なプリンシパルで作成されたファイルに関連付けられている所有者属性の形式に変換されている場合、共通のフォーマットでは、ユーザーがセキュリティプリンシパルの各対応するセットに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The translation used to interpret owner and group strings is not specified as part of the protocol. This allows various solutions to be employed. For example, a local translation table may be consulted that maps between a numeric id to the user@dns_domain syntax. A name service may also be used to accomplish the translation. A server may provide a more general service, not limited by any particular translation (which would only translate a limited set of possible strings) by storing the owner and owner_group attributes in local storage without any translation or it may augment a translation method by storing the entire string for attributes for which no translation is available while using the local representation for those cases in which a translation is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者とグループの文字列を解釈するために使用される変換は、プロトコルの一部として指定されていません。これは、様々なソリューションを採用することができるようになります。たとえば、ローカルの変換テーブルは、ユーザーの@ dns_domain構文の数値IDの間のマッピングし、その参考にすることができます。ネームサービスは、翻訳を達成するために使用することができます。サーバは、所有者を格納することによって（唯一の可能な文字列の限られたセットを翻訳するであろう）は、任意の特定の翻訳によって限定されるものではなく、より一般的なサービスを提供することができるとowner_groupは、変換されずに、ローカルストレージの属性またはそれが格納することにより、翻訳方法を増強することができます翻訳が利用可能であるこれらの例のためのローカルな表現を使用しながら、何の翻訳が利用できないために属性の文字列全体。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that do not provide support for all possible values of the owner and owner_group attributes, should return an error (NFS4ERR_BADOWNER) when a string is presented that has no translation, as the value to be set for a SETATTR of the owner, owner_group, or acl attributes. When a server does accept an owner or owner_group value as valid on a SETATTR (and similarly for the owner and group strings in an acl), it is promising to return that same string when a corresponding GETATTR is done. Configuration changes and ill-constructed name translations (those that contain aliasing) may make that promise impossible to honor. Servers should make appropriate efforts to avoid a situation in which these attributes have their values changed when no real change to ownership has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文字列が提示されたときowner_group、値は所有者のSETATTRに設定すると、何の翻訳を持っていないというエラー（NFS4ERR_BADOWNER）を返す、または必要があり、所有者とowner_group属性のすべての可能な値のためのサポートを提供していないサーバーACL属性。サーバはSETATTRに有効な（および同様にACLの所有者とグループ文字列の）所有者またはowner_group値を受け入れない場合、対応するGETATTRが行われたときに同じ文字列を返すために有望です。設定の変更と悪い構築名翻訳（エイリアシングを含むもの）が称えるためにその約束を不可能にすることがあります。サーバは、これらの属性は、所有権への本当の変化が発生していないとき、その値が変更されていた状況を回避するための適切な努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;dns_domain&#34; portion of the owner string is meant to be a DNS domain name. For example, user@ietf.org. Servers should accept as valid a set of users for at least one domain. A server may treat other domains as having no valid translations. A more general service is provided when a server is capable of accepting users for multiple domains, or for all domains, subject to security constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者文字列の「dns_domain」の部分は、DNSドメイン名であることを意味しています。例えば、user@ietf.org。サーバーは、少なくとも1つのドメインに対するユーザーの有効なセットを受け入れる必要があります。サーバーは、有効な翻訳を持っていないとして、他のドメインを扱うことがあります。サーバが複数のドメインのために、またはセキュリティ制約の対象となるすべてのドメインのユーザを受け入れることができる場合に、より一般的なサービスが提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case where there is no translation available to the client or server, the attribute value must be constructed without the &#34;@&#34;. Therefore, the absence of the @ from the owner or owner_group attribute signifies that no translation was available at the sender and that the receiver of the attribute should not use that string as a basis for translation into its own internal format. Even though the attribute value can not be translated, it may still be useful. In the case of a client, the attribute string may be used for local display of ownership.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントまたはサーバに利用可能な翻訳が存在しない場合には、属性値は「@」なしで構築されなければなりません。したがって、所有者またはowner_group属性から@の不在には翻訳が送信側で属性の受信機は、独自の内部形式に変換するための基礎として、その文字列を使用してはならないことを利用できなかったことを意味します。属性値が変換できないにもかかわらず、それはまだ有用である可能性があります。クライアントの場合、属性文字列は、所有権のローカル・ディスプレイのために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide a greater degree of compatibility with previous versions of NFS (i.e., v2 and v3), which identified users and groups by 32-bit unsigned uid&#39;s and gid&#39;s, owner and group strings that consist of decimal numeric values with no leading zeros can be given a special interpretation by clients and servers which choose to provide such support. The receiver may treat such a user or group string as representing the same user as would be represented by a v2/v3 uid or gid having the corresponding numeric value. A server is not obligated to accept such a string, but may return an NFS4ERR_BADOWNER instead. To avoid this mechanism being used to subvert user and group translation, so that a client might pass all of the owners and groups in numeric form, a server SHOULD return an NFS4ERR_BADOWNER error when there is a valid translation for the user or owner designated in this way. In that case, the client must use the appropriate name@domain string and not the special form for compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ない先行ゼロの10進数値で構成所有者とグループの文字列があることができ、32ビット符号なしUIDとGIDを用いてユーザとグループを識別されたNFSの以前のバージョン（すなわち、V2およびV3）との互換性のより大きな程度を提供しますそのようなサポートを提供することを選択したクライアントとサーバで特別な解釈を与えられました。受信機は、対応する数値を有するV2 / V3のUIDまたはGIDによって表されるであろうと同じユーザを表すようなユーザまたはグループ列を扱うことができます。サーバーは、このような文字列を受け入れる義務はないが、代わりにNFS4ERR_BADOWNERを返すことがあります。この中で指定されたユーザーまたは所有者の有効な翻訳がある場合に、クライアントは数値形式で所有者とグループのすべてを渡すかもしれないように、ユーザーやグループの翻訳を破壊するために使用されているこのメカニズムを回避するために、サーバーはNFS4ERR_BADOWNERエラーを返すべきです仕方。その場合、クライアントは適切な名前@ドメイン文字列ではなく、互換性のための特別なフォームを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The owner string &#34;nobody&#34; may be used to designate an anonymous user, which will be associated with a file created by a security principal that cannot be mapped through normal means to the owner attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者列「誰が」所有者属性に通常の手段を介してマッピングすることができないセキュリティプリンシパルによって作成されたファイルに関連付けられる匿名ユーザを指定するために使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9. Character Case Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.9。キャラクターケースの属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With respect to the case_insensitive and case_preserving attributes, each UCS-4 character (which UTF-8 encodes) has a &#34;long descriptive name&#34; [RFC1345] which may or may not included the word &#34;CAPITAL&#34; or &#34;SMALL&#34;. The presence of SMALL or CAPITAL allows an NFS server to implement unambiguous and efficient table driven mappings for case insensitive comparisons, and non-case-preserving storage. For general character handling and internationalization issues, see the section &#34;Internationalization&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CASE_INSENSITIVEとcase_preserving属性に関して、各UCS-4文字（UTF-8符号化）「は、長い記述名」または単語「CAPITAL」または「SMALL」に含まれていてもいなくてもよい[RFC1345]を有します。 SMALL又は資本の存在は、NFSサーバが大文字と小文字を区別しない比較に明白かつ効率的なテーブルドリブンマッピングを実装することができ、ストレージ非ケース保存します。一般的な文字の取り扱いと国際化の問題については、「国際化」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.10. Quota Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.10。クォータの属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the attributes related to filesystem quotas, the following definitions apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムのクォータに関連する属性の場合は、以下の定義が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_soft The value in bytes which represents the amount of additional disk space that can be allocated to this file or directory before the user may reasonably be warned. It is understood that this space may be consumed by allocations to other files or directories though there is a rule as to which other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーが合理的に警告される前に、このファイルまたはディレクトリに割り当てることができ、追加のディスク・スペースの量を表し、値をバイト単位でquota_avail_soft。他のどのファイルやディレクトリのようルールがあるが、このスペースは、他のファイルやディレクトリへの割り当てによって消費されてもよいことが理解されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_avail_hard The value in bytes which represent the amount of additional disk space beyond the current allocation that can be allocated to this file or directory before further allocations will be refused. It is understood that this space may be consumed by allocations to other files or directories.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに割り当てが拒否される前に、このファイルまたはディレクトリに割り当てることができる現在の割り当てを超えて追加のディスクスペースの量を表すバイトの値をquota_avail_hard。このスペースは、他のファイルまたはディレクトリへの割り当てによって消費されてもよいことが理解されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
quota_used The value in bytes which represent the amount of disc space used by this file or directory and possibly a number of other similar files or directories, where the set of &#34;similar&#34; meets at least the criterion that allocating space to any file or directory in the set will reduce the &#34;quota_avail_hard&#34; of every other file or directory in the set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「類似」のセットは、少なくとも基準を満たす可能性がこのファイルまたはディレクトリおよび他の類似のファイルまたはディレクトリの数によって使用されるディスク・スペースの量を表すバイトの値をQUOTA_USEDそのファイルまたはディレクトリ内にスペースを割り当てますセットは、セット内の他のすべてのファイルやディレクトリの「quota_avail_hard」を削減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Note that there may be a number of distinct but overlapping
         sets of files or directories for which a quota_used value is
         maintained (e.g., &#34;all files with a given owner&#34;, &#34;all files
         with a given group owner&#34;, etc.).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The server is at liberty to choose any of those sets but should do so in a repeatable way. The rule may be configured per-filesystem or may be &#34;choose the set with the smallest quota&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
サーバーは、これらのセットのいずれかを選択する自由であるが、再現可能な方法で行う必要があります。ルールごとのファイルシステムに構成してもよいし、「最小クォータとセットを選択」であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11. Access Control Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11。アクセス制御リスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 ACL attribute is an array of access control entries (ACE). Although, the client can read and write the ACL attribute, the NFSv4 model is the server does all access control based on the server&#39;s interpretation of the ACL. If at any point the client wants to check access without issuing an operation that modifies or reads data or metadata, the client can use the OPEN and ACCESS operations to do so. There are various access control entry types, as defined in the Section &#34;ACE type&#34;. The server is able to communicate which ACE types are supported by returning the appropriate value within the aclsupport attribute. Each ACE covers one or more operations on a file or directory as described in the Section &#34;ACE Access Mask&#34;. It may also contain one or more flags that modify the semantics of the ACE as defined in the Section &#34;ACE flag&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4 ACL属性は、アクセス制御エントリ（ACE）の配列です。クライアントは、ACL属性を読み書きすることができ、が、NFSv4のモデルでは、サーバはACLのサーバーの解釈に基づいて、すべてのアクセス制御を行います。いずれかの時点で、クライアントが変更されたり、データやメタデータを読み込む操作を発行せずにアクセスをチェックしたい場合、クライアントはこれを行うにOPENし、アクセスする操作を使用することができます。セクション「ACEタイプ」で定義されているさまざまなアクセス制御エントリの種類があります。サーバはaclsupport属性内の適切な値を返すことによってサポートされているACEタイプ通信することができます。各ACEは、セクション「ACEアクセスマスク」で説明したように、ファイルやディレクトリ上の1つ以上の操作をカバーしています。また、セクション「ACEフラグ」で定義されたACEのセマンティクスを変更する1つの以上のフラグが含まれていてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS ACE attribute is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにNFS ACE属性が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         typedef uint32_t        acetype4;
         typedef uint32_t        aceflag4;
         typedef uint32_t        acemask4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct nfsace4 {
                 acetype4        type;
                 aceflag4        flag;
                 acemask4        access_mask;
                 utf8str_mixed   who;
         };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine if a request succeeds, each nfsace4 entry is processed in order by the server. Only ACEs which have a &#34;who&#34; that matches the requester are considered. Each ACE is processed until all of the bits of the requester&#39;s access have been ALLOWED. Once a bit (see below) has been ALLOWED by an ACCESS_ALLOWED_ACE, it is no longer considered in the processing of later ACEs. If an ACCESS_DENIED_ACE is encountered where the requester&#39;s access still has unALLOWED bits in common with the &#34;access_mask&#34; of the ACE, the request is denied. However, unlike the ALLOWED and DENIED ACE types, the ALARM and AUDIT ACE types do not affect a requester&#39;s access, and instead are for triggering events as a result of a requester&#39;s access attempt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストが成功したかどうかを決定するために、各nfsace4エントリは、サーバによって順に処理されます。依頼者と一致した「」持っている唯一のACEが考慮されます。依頼者のアクセスのビットのすべてが許可されるまで、各ACEが処理されます。ビットが（下記参照）ACCESS_ALLOWED_ACEによって許可された後、それはもはや後のACEの処理において考慮されません。 ACCESS_DENIED_ACEが発生した場合は、要求者のアクセスはまだACEの「access_mask」と共通の許可されていないビットを有する場合、要求は拒否されます。しかし、許可され、DENIED ACEタイプとは異なり、ALARMおよびAUDIT ACEタイプは、要求者のアクセスには影響しませんし、代わりに、要求者のアクセス試行の結果としてイベントをトリガするためのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, all AUDIT and ALARM ACEs are processed until end of the ACL. When the ACL is fully processed, if there are bits in requester&#39;s mask that have not been considered whether the server allows or denies the access is undefined. If there is a mode attribute on the file, then this cannot happen, since the mode&#39;s MODE4_*OTH bits will map to EVERYONE@ ACEs that unambiguously specify the requester&#39;s access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、すべてのAUDITとALARM ACEはACLの最後まで処理されます。サーバはアクセスが定義されていないことができますまたは拒否するかどうかを考慮されていない依頼者のマスクのビットがある場合は場合はACLは完全に処理されます。ファイルのmode属性がある場合、これはモードのMODE4_ * OTHビットが明確に要求者のアクセスを指定するACE @ EVERYONEにマップされているため、発生することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 ACL model is quite rich. Some server platforms may provide access control functionality that goes beyond the UNIX-style mode attribute, but which is not as rich as the NFS ACL model. So that users can take advantage of this more limited functionality, the server may indicate that it supports ACLs as long as it follows the guidelines for mapping between its ACL model and the NFS version 4 ACL model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4 ACLモデルは非常に豊富です。一部のサーバー・プラットフォームは、UNIXスタイルのmode属性を超えたアクセス制御機能を提供することができるが、これはNFS ACLモデルほど豊富ではありません。ユーザーはこのより限定された機能を利用することができるように、サーバーは、それがあれば、そのACLモデルとNFSバージョン4 ACLモデルとの間のマッピングのためのガイドラインを以下のようにACLをサポートしていることを示すかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The situation is complicated by the fact that a server may have multiple modules that enforce ACLs. For example, the enforcement for NFS version 4 access may be different from the enforcement for local access, and both may be different from the enforcement for access through other protocols such as SMB. So it may be useful for a server to accept an ACL even if not all of its modules are able to support it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状況は、サーバーがACLを強制する複数のモジュールを持っているかもしれないという事実によって複雑になります。例えば、NFSバージョン4アクセスするための施行は、ローカルアクセスのための施行と異なっていてもよい、との両方は、SMBのような他のプロトコルを介してアクセスするための施行と異なっていてもよいです。そのモジュールのすべてではないが、それをサポートすることができている場合でも、サーバーがACLを受け入れるするので、有用である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The guiding principle in all cases is that the server must not accept ACLs that appear to make the file more secure than it really is.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのケースで指導原理は、サーバは、それが実際よりもファイルをより安全にするために表示されるACLを受け入れてはならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.1. ACE type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.1。 ACEの種類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Type         Description
   _____________________________________________________
   ALLOW        Explicitly grants the access defined in
                acemask4 to the file or directory.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DENY Explicitly denies the access defined in acemask4 to the file or directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明示的にDENYは、ファイルまたはディレクトリへのacemask4で定義されたアクセスを拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AUDIT LOG (system dependent) any access attempt to a file or directory which uses any of the access methods specified in acemask4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
監査ログ（システムに依存）acemask4で指定したアクセス方法のいずれかを使用して、ファイルまたはディレクトリへのアクセスの試み。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ALARM Generate a system ALARM (system dependent) when any access attempt is made to a file or directory for the access methods specified in acemask4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのアクセスの試みがacemask4に指定されたアクセス方法のためのファイルまたはディレクトリに対して行われたときにアラームが（システムに依存）システムアラームを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server need not support all of the above ACE types. The bitmask constants used to represent the above definitions within the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、上記のACEタイプのすべてをサポートしている必要はありません。内の上記の定義を表すために使用されるビットマスク定数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aclsupport attribute are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにaclsupport属性は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
      const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
      const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
      const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The semantics of the &#34;type&#34; field follow the descriptions provided above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「タイプ」フィールドのセマンティクスは、上記の説明に従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constants used for the type field (acetype4) are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにタイプフィールド（acetype4）に使用される定数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
      const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
      const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
      const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients should not attempt to set an ACE unless the server claims support for that ACE type. If the server receives a request to set an ACE that it cannot store, it MUST reject the request with NFS4ERR_ATTRNOTSUPP. If the server receives a request to set an ACE that it can store but cannot enforce, the server SHOULD reject the request with NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーのクレームがそのACEの種類をサポートしない限り、ACEを設定しようとするべきではありません。サーバが格納できないというACEを設定するための要求を受信した場合、それはNFS4ERR_ATTRNOTSUPPで要求を拒絶しなければなりません。サーバーが保存することができますが、強制することはできませんACEを設定するための要求を受信した場合、サーバはNFS4ERR_ATTRNOTSUPPとのリクエストを拒否すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example: suppose a server can enforce NFS ACLs for NFS access but cannot enforce ACLs for local access. If arbitrary processes can run on the server, then the server SHOULD NOT indicate ACL support. On the other hand, if only trusted administrative programs run locally, then the server may indicate ACL support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例：サーバーは、NFSアクセスのためのNFSのACLを強制することができたとしますが、ローカルアクセス用のACLを強制することはできません。任意のプロセスがサーバー上で実行できる場合、サーバはACLのサポートを示すべきではありません。一方、唯一の信頼できる管理プログラムをローカルで実行する場合、サーバはACLのサポートを示すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.2. ACE Access Mask
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.2。 ACEアクセスマスク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The access_mask field contains values based on the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
access_maskフィールドには、次のように基づく値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Access                 Description
   _______________________________________________________________
   READ_DATA              Permission to read the data of the file
   LIST_DIRECTORY         Permission to list the contents of a
                          directory
   WRITE_DATA             Permission to modify the file&#39;s data
   ADD_FILE               Permission to add a new file to a
                          directory
   APPEND_DATA            Permission to append data to a file
   ADD_SUBDIRECTORY       Permission to create a subdirectory to a
                          directory
   READ_NAMED_ATTRS       Permission to read the named attributes
                          of a file
   WRITE_NAMED_ATTRS      Permission to write the named attributes
                          of a file
   EXECUTE                Permission to execute a file
   DELETE_CHILD           Permission to delete a file or directory
                          within a directory
   READ_ATTRIBUTES        The ability to read basic attributes
                          (non-acls) of a file
   WRITE_ATTRIBUTES       Permission to change basic attributes
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 (non-acls) of a file DELETE Permission to Delete the file READ_ACL Permission to Read the ACL WRITE_ACL Permission to Write the ACL WRITE_OWNER Permission to change the owner SYNCHRONIZE Permission to access file locally at the server with synchronous reads and writes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルの（ACL以外）の同期とサーバーでローカルファイルにアクセスするには、所有者のSYNCHRONIZEアクセス権を変更するには、ACLのWRITE_OWNER許可を書くACLのWRITE_ACL許可を読み取るために、ファイルREAD_ACL許可を削除する権限をDELETEは、読み込みと書き込み
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmask constants used for the access mask field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにアクセスマスクフィールドに使用されるビットマスク定数は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Server implementations need not provide the granularity of control that is implied by this list of masks. For example, POSIX-based systems might not distinguish APPEND_DATA (the ability to append to a file) from WRITE_DATA (the ability to modify existing contents); both masks would be tied to a single &#34;write&#34; permission. When such a server returns attributes to the client, it would show both APPEND_DATA and WRITE_DATA if and only if the write permission is enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバ実装は、マスクのこのリストによって暗示される制御の粒度を提供する必要はありません。例えば、POSIXベースのシステムは、WRITE_DATA（既存の内容を変更する能力）からAPPEND_DATA（ファイルに追加する能力）を区別しないかもしれません。両方のマスクは、単一の「書き込み」権限に縛られることになります。そのようなサーバがクライアントに属性を返すとき、それがあればAPPEND_DATAとWRITE_DATAの両方を示すであろうし、書き込み許可が有効な場合のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a server receives a SETATTR request that it cannot accurately implement, it should error in the direction of more restricted access. For example, suppose a server cannot distinguish overwriting data from appending new data, as described in the previous paragraph. If a client submits an ACE where APPEND_DATA is set but WRITE_DATA is not (or vice versa), the server should reject the request with NFS4ERR_ATTRNOTSUPP. Nonetheless, if the ACE has type DENY, the server may silently turn on the other bit, so that both APPEND_DATA and WRITE_DATA are denied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはそれが正確に実装することはできませんSETATTR要求を受信した場合、それはより多くのアクセス制限の方向の誤差なければなりません。例えば、前の段落で説明したように、サーバは、新しいデータを追加するからデータを上書き区別できないと仮定します。クライアントはAPPEND_DATAが設定されているACEを提出するが、WRITE_DATA（またはその逆）でない場合、サーバはNFS4ERR_ATTRNOTSUPPで要求を拒否しなければなりません。 ACEはDENY型を持つ場合APPEND_DATAとWRITE_DATAの両方が拒否されるようにそれにもかかわらず、サーバは静かに、他のビットをオンにすることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.3. ACE flag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.3。 ACEフラグ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;flag&#34; field contains values based on the following descriptions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「フラグ」フィールドには、以下の説明に基づいて値を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FILE_INHERIT_ACE Can be placed on a directory and indicates that this ACE should be added to each new non-directory file created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_FILE_INHERIT_ACEは、ディレクトリ上に配置され、このACEが作成したそれぞれの新しい非ディレクトリファイルに追加する必要があることを示していることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DIRECTORY_INHERIT_ACE Can be placed on a directory and indicates that this ACE should be added to each new directory created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_DIRECTORY_INHERIT_ACEは、ディレクトリ上に配置され、このACEが作成したそれぞれの新しいディレクトリに追加されなければならないことを示していることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERIT_ONLY_ACE Can be placed on a directory but does not apply to the directory, only to newly created files/directories as specified by the above two flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_INHERIT_ONLY_ACEはディレクトリに配置することができますが、上記の二つのフラグで指定されたのみで、新しく作成されたファイル/ディレクトリに、ディレクトリには適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_NO_PROPAGATE_INHERIT_ACE Can be placed on a directory. Normally when a new directory is created and an ACE exists on the parent directory which is marked ACL4_DIRECTORY_INHERIT_ACE, two ACEs are placed on the new directory. One for the directory itself and one which is an inheritable ACE for newly created directories. This flag tells the server to not place an ACE on the newly created directory which is inheritable by subdirectories of the created directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_NO_PROPAGATE_INHERIT_ACEはディレクトリに配置することができます。新しいディレクトリが作成され、ACEがACL4_DIRECTORY_INHERIT_ACEマークされている親ディレクトリに存在しているとき、通常、2つのACEを新しいディレクトリに配置されます。ディレクトリ自体の一つと新しく作成されたディレクトリの継承ACEである1。このフラグは、作成したディレクトリのサブディレクトリによって継承され、新しく作成したディレクトリにACEを置かないようにサーバに指示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_SUCCESSFUL_ACCESS_ACE_FLAG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACL4_FAILED_ACCESS_ACE_FLAG The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS) and ACE4_FAILED_ACCESS_ACE_FLAG (FAILED) flag bits relate only to ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and ACE4_SYSTEM_ALARM_ACE_TYPE (ALARM) ACE types. If during the processing of the file&#39;s ACL, the server encounters an AUDIT or ALARM ACE that matches the principal attempting the OPEN, the server notes that fact, and the presence, if any, of the SUCCESS and FAILED flags encountered in the AUDIT or ALARM ACE. Once the server completes the ACL processing, and the share reservation processing, and the OPEN call, it then notes if the OPEN succeeded or failed. If the OPEN succeeded, and if the SUCCESS flag was set for a matching AUDIT or ALARM, then the appropriate AUDIT or ALARM event occurs. If the OPEN failed, and if the FAILED flag was set for the matching AUDIT or ALARM, then the appropriate AUDIT or ALARM event occurs. Clearly either or both of the SUCCESS or FAILED can be set, but if neither is set, the AUDIT or ALARM ACE is not useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACL4_FAILED_ACCESS_ACE_FLAGザACE4_SUCCESSFUL_ACCESS_ACE_FLAG（成功）とACE4_FAILED_ACCESS_ACE_FLAGフラグビットはACE4_SYSTEM_AUDIT_ACE_TYPE（AUDIT）とACE4_SYSTEM_ALARM_ACE_TYPE（ALARM）ACEタイプにのみ関係（FAILED）。ファイルのACLの処理中に、サーバーがOPENをしようと元本と一致したAUDITかALARM ACEを検出した場合、サーバーはその事実を指摘し、AUDITまたはALARMに遭遇成功と失敗のフラグの存在、もしあれば、エース。サーバはACL処理、および共有予約処理、およびOPENコールを完了すると、それは、OPENが成功したか失敗した場合は指摘しています。 OPENが成功した場合、および成功フラグが整合AUDITまたはアラームに設定された場合には、適切な監査またはアラームイベントが発生します。 OPENが失敗した場合、およびFAILEDフラグが一致するAUDITまたはアラームに設定された場合には、適切な監査またはアラームイベントが発生します。明らかにいずれかまたは両方SUCCESSまたはFAILEDを設定することができますが、どちらも設定されていない場合、AUDITまたはALARM ACEは有用ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The previously described processing applies to that of the ACCESS operation as well. The difference being that &#34;success&#34; or &#34;failure&#34; does not mean whether ACCESS returns NFS4_OK or not. Success means whether ACCESS returns all requested and supported bits. Failure means whether ACCESS failed to return a bit that was requested and supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
前述の処理は、同様のアクセス動作のものに適用されます。違いは、「成功」か「失敗」は、ACCESSのNFS4_OKを返すかどうかを意味しないということで。成功は、アクセスリターンは、すべての要求されたとのビットをサポートするかどうかを意味します。失敗は、ACCESSが要求され、サポートされたビットを返すために失敗したかどうかを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_IDENTIFIER_GROUP Indicates that the &#34;who&#34; refers to a GROUP as defined under UNIX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACE4_IDENTIFIER_GROUPは、UNIXの下で定義される「誰が」基を意味することを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bitmask constants used for the flag field are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにフラグフィールドに使用されるビットマスク定数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;
   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server need not support any of these flags. If the server supports flags that are similar to, but not exactly the same as, these flags, the implementation may define a mapping between the protocol-defined flags and the implementation-defined flags. Again, the guiding principle is that the file not appear to be more secure than it really is.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、これらのフラグのいずれかをサポートする必要はありません。サーバは同様に、これらのフラグは、全く同じではないフラグをサポートしている場合、実装は、プロトコル定義のフラグおよび実装定義フラグとの間のマッピングを定義することができます。ここでも、基本理念は、ファイルは、それが実際よりもより安全であることが表示されませということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, suppose a client tries to set an ACE with ACE4_FILE_INHERIT_ACE set but not ACE4_DIRECTORY_INHERIT_ACE. If the server does not support any form of ACL inheritance, the server should reject the request with NFS4ERR_ATTRNOTSUPP. If the server supports a single &#34;inherit ACE&#34; flag that applies to both files and directories, the server may reject the request (i.e., requiring the client to set both the file and directory inheritance flags). The server may also accept the request and silently turn on the ACE4_DIRECTORY_INHERIT_ACE flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、クライアントはACE4_FILE_INHERIT_ACEセットではなくACE4_DIRECTORY_INHERIT_ACEでACEを設定しようとします。サーバーは、ACLの継承のいずれかの形式をサポートしていない場合、サーバはNFS4ERR_ATTRNOTSUPPで要求を拒否しなければなりません。サーバがファイルとディレクトリの両方に適用されるシングル「継承ACE」フラグをサポートしている場合、サーバーが要求を拒否することができる（すなわち、ファイルやディレクトリの継承の両方のフラグを設定するためのクライアントを必要とします）。また、サーバは要求を受け入れ、静かACE4_DIRECTORY_INHERIT_ACEフラグをオンにすることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.4. ACE who
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.4。 ACE人
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several special identifiers (&#34;who&#34;) which need to be understood universally, rather than in the context of a particular DNS domain. Some of these identifiers cannot be understood when an NFS client accesses the server, but have meaning when a local process accesses the file. The ability to display and modify these permissions is permitted over NFS, even if none of the access methods on the server understands the identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
むしろ、特定のDNSドメインの文脈におけるよりも、普遍的に理解する必要があります（「」）、いくつかの特別な識別子があります。これらの識別子の一部は、NFSクライアントがサーバにアクセスするときに理解することはできませんが、ローカルプロセスがファイルにアクセスしたときに意味しています。表示し、これらの権限を変更する機能は、サーバ上のアクセス方法のどれもが識別子を理解していない場合でも、NFS上で許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Who                    Description
   _______________________________________________________________
   &#34;OWNER&#34;                The owner of the file.
   &#34;GROUP&#34;                The group associated with the file.
   &#34;EVERYONE&#34;             The world.
   &#34;INTERACTIVE&#34;          Accessed from an interactive terminal.
   &#34;NETWORK&#34;              Accessed via the network.
   &#34;DIALUP&#34;               Accessed as a dialup user to the server.
   &#34;BATCH&#34;                Accessed from a batch job.
   &#34;ANONYMOUS&#34;            Accessed without any authentication.
   &#34;AUTHENTICATED&#34;        Any authenticated user (opposite of
                          ANONYMOUS)
   &#34;SERVICE&#34;              Access from a system service.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid conflict, these special identifiers are distinguish by an appended &#34;@&#34; and should appear in the form &#34;xxxx@&#34; (note: no domain name after the &#34;@&#34;). For example: ANONYMOUS@.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
競合を避けるために、これらの特別な識別子は、「@」追加によって区別され、フォーム「XXXXの@」（注：ドメイン名「@」の後）に表示されます。例：ANONYMOUS @。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.5. Mode Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.5。モード属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 mode attribute is based on the UNIX mode bits. The following bits are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4モード属性は、UNIXモード・ビットに基づいています。次のビットが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      const MODE4_SUID = 0x800;  /* set user id on execution */
      const MODE4_SGID = 0x400;  /* set group id on execution */
      const MODE4_SVTX = 0x200;  /* save text even after use */
      const MODE4_RUSR = 0x100;  /* read permission: owner */
      const MODE4_WUSR = 0x080;  /* write permission: owner */
      const MODE4_XUSR = 0x040;  /* execute permission: owner */
      const MODE4_RGRP = 0x020;  /* read permission: group */
      const MODE4_WGRP = 0x010;  /* write permission: group */
      const MODE4_XGRP = 0x008;  /* execute permission: group */
      const MODE4_ROTH = 0x004;  /* read permission: other */
      const MODE4_WOTH = 0x002;  /* write permission: other */
      const MODE4_XOTH = 0x001;  /* execute permission: other */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the principal identified in the owner attribute. Bits MODE4_RGRP, MODE4_WGRP, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットMODE4_RUSR、MODE4_WUSR、及びMODE4_XUSRは、所有者の属性で識別されたプリンシパルに適用されます。ビットMODE4_RGRP、MODE4_WGRP、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MODE4_XGRP apply to the principals identified in the owner_group attribute. Bits MODE4_ROTH, MODE4_WOTH, MODE4_XOTH apply to any principal that does not match that in the owner group, and does not have a group matching that of the owner_group attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MODE4_XGRPはowner_group属性で識別プリンシパルに適用されます。ビットMODE4_ROTH、MODE4_WOTH、MODE4_XOTHは、所有者のグループに一致しない、とowner_group属性に一致する基を有さない任意のプリンシパルに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining bits are not defined by this protocol and MUST NOT be used. The minor version mechanism must be used to define further bit usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りのビットは、このプロトコルによって定義されておらず、使用してはいけません。マイナーバージョンメカニズムは、さらにビット使用量を定義するために使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in UNIX, if a file has the MODE4_SGID bit set and no MODE4_XGRP bit set, then READ and WRITE must use mandatory file locking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがMODE4_SGIDビット設定されていないと何もMODE4_XGRPビットがセットされている場合はUNIXで、その後、READとWRITEは必須ファイルのロックを使用しなければならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.6. Mode and ACL Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.6。モードとACL属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server that supports both mode and ACL must take care to synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH bits with the ACEs which have respective who fields of &#34;OWNER@&#34;, &#34;GROUP@&#34;, and &#34;EVERYONE@&#34; so that the client can see semantically equivalent access permissions exist whether the client asks for owner, owner_group and mode attributes, or for just the ACL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モードとACLの両方をサポートするサーバーは、「OWNER @」、「グループ@」の分野人それぞれ、および「EVERYONEを持っているのACEとMODE4_ * USR、MODE4_ * GRP、およびMODE4_ * OTHビットを同期させるために注意しなければなりません@ &#34;ように、クライアントは、意味的に同等のアクセス許可がowner_group、クライアントが所有者を要求するかどうかが存在するとモード属性、または単にACLのために見ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the mode attribute includes bits (e.g., MODE4_SVTX) that have nothing to do with ACL semantics, it is permitted for clients to specify both the ACL attribute and mode in the same SETATTR operation. However, because there is no prescribed order for processing the attributes in a SETATTR, the client must ensure that ACL attribute, if specified without mode, would produce the desired mode bits, and conversely, the mode attribute if specified without ACL, would produce the desired &#34;OWNER@&#34;, &#34;GROUP@&#34;, and &#34;EVERYONE@&#34; ACEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モード属性は、ビットを含んでいるので（例えば、MODE4_SVTX）ACLの意味とは何の関係もない、同じSETATTR操作でACL属性とモードの両方を指定するには、クライアントのために許可されています。 SETATTRの属性を処理するための所定の順序がないためしかし、クライアントは、ACL属性は、モードなしで指定されている場合、所望のモードビットを生成することを確認する必要があり、逆に、モード属性はACLなしで指定された場合、生成するであろう所望の &#34;OWNER @&#34;、 &#34;グループ@&#34;、およびACEの &#34;@ EVERYONE&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.7. mounted_on_fileid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.11.7。 mounted_on_fileid
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIX-based operating environments connect a filesystem into the namespace by connecting (mounting) the filesystem onto the existing file object (the mount point, usually a directory) of an existing filesystem. When the mount point&#39;s parent directory is read via an API like readdir(), the return results are directory entries, each with a component name and a fileid. The fileid of the mount point&#39;s directory entry will be different from the fileid that the stat() system call returns. The stat() system call is returning the fileid of the root of the mounted filesystem, whereas readdir() is returning the fileid stat() would have returned before any filesystems were mounted on the mount point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXベースのオペレーティング環境は、既存のファイルシステムの既存のファイル・オブジェクト（マウントポイント、通常ディレクトリ）上（取付）ファイルシステムを接続することにより、名前空間にファイルシステムを接続します。マウントポイントの親ディレクトリがreaddirのように（）APIを介して読み出された場合、戻り結果がディレクトリエントリ、コンポーネント名とFILEIDとそれぞれ。マウントポイントのディレクトリエントリのFILEIDはFILEIDのstat（）システムコールが戻るとは異なります。 READDIR（）は、任意のファイルシステムがマウントポイント上に実装される前に戻ってきたであろうFILEIDスタット（）を返しているのに対し、STAT（）システムコールは、マウントされたファイルシステムのルートのFILEIDを返しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike NFS version 3, NFS version 4 allows a client&#39;s LOOKUP request to cross other filesystems. The client detects the filesystem crossing whenever the filehandle argument of LOOKUP has an fsid attribute different from that of the filehandle returned by LOOKUP. A UNIX-based client will consider this a &#34;mount point crossing&#34;. UNIX has a legacy scheme for allowing a process to determine its current working directory. This relies on readdir() of a mount point&#39;s parent and stat() of the mount point returning fileids as previously described. The mounted_on_fileid attribute corresponds to the fileid that readdir() would have returned as described previously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン3とは異なり、NFSバージョン4は、クライアントのLOOKUP要求は他のファイルシステムを横断することができます。 LOOKUPのファイルハンドル引数はFSIDを持っている時はいつでも、クライアントは、ファイルシステムの交差を検出しLOOKUPで返されるファイルハンドルとは異なる属性。 UNIXベースのクライアントは、この「マウントポイントの交差点」を検討します。 UNIXは、現在の作業ディレクトリを決定するためのプロセスを可能にするための従来の方式を採用しています。先に述べたように、これはfileidsを返すマウントポイントのマウントポイントの親とのstat（）ののreaddir（）に依存しています。 mounted_on_fileid属性は、前述のように（）を返すはずREADDIR FILEIDに相当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the NFS version 4 client could simply fabricate a fileid corresponding to what mounted_on_fileid provides (and if the server does not support mounted_on_fileid, the client has no choice), there is a risk that the client will generate a fileid that conflicts with one that is already assigned to another object in the filesystem. Instead, if the server can provide the mounted_on_fileid, the potential for client operational problems in this area is eliminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4クライアントは単に提供するものmounted_on_fileidに対応FILEIDを作ることもできますが（と、サーバがmounted_on_fileidをサポートしていない場合、クライアントは選択の余地がありません）、クライアントである1と競合FILEIDを発生するおそれがありますすでにファイルシステム内の別のオブジェクトに割り当てられています。サーバがmounted_on_fileidを提供できるかどう代わりに、この分野でのクライアントの動作上の問題の可能性が排除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server detects that there is no mounted point at the target file object, then the value for mounted_on_fileid that it returns is the same as that of the fileid attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、対象ファイルオブジェクトで何のマウントポイントが存在しないことを検出した場合、それが返すことmounted_on_fileidの値がFILEID属性と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mounted_on_fileid attribute is RECOMMENDED, so the server SHOULD provide it if possible, and for a UNIX-based server, this is straightforward. Usually, mounted_on_fileid will be requested during a READDIR operation, in which case it is trivial (at least for UNIX-based servers) to return mounted_on_fileid since it is equal to the fileid of a directory entry returned by readdir(). If mounted_on_fileid is requested in a GETATTR operation, the server should obey an invariant that has it returning a value that is equal to the file object&#39;s entry in the object&#39;s parent directory, i.e., what readdir() would have returned. Some operating environments allow a series of two or more filesystems to be mounted onto a single mount point. In this case, for the server to obey the aforementioned invariant, it will need to find the base mount point, and not the intermediate mount points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mounted_on_fileid属性が推奨されているので、可能な場合、サーバはそれを提供すべきである、とUNIXベースのサーバーのために、これは簡単です。それがREADDIR（で返されるディレクトリエントリのFILEIDに等しいので、通常、mounted_on_fileid）がmounted_on_fileidを返すために（少なくともUNIXベースのサーバーのために）それは簡単です、その場合には、READDIR操作中に要求されます。 mounted_on_fileidがGETATTR操作で要求された場合、サーバはそれがすなわち、何のreaddir（）戻っているだろう、オブジェクトの親ディレクトリ内のファイルオブジェクトのエントリに等しい値を返す持つ不変に従わなければなりません。いくつかの動作環境は、二つ以上のファイルシステムのシリーズは、単一のマウントポイントにマウントすることができます。この場合は、サーバーのための前述の不変に従うように、それがベースマウントポイントを見つける必要があるでしょうし、中間ではないマウントポイントを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Filesystem Migration and Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.ファイルシステムの移行とレプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the use of the recommended attribute &#34;fs_locations&#34;, the NFS version 4 server has a method of providing filesystem migration or replication services. For the purposes of migration and replication, a filesystem will be defined as all files that share a given fsid (both major and minor values are the same).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨属性「fs_位置」を使用すると、NFSバージョン4サーバーは、ファイルシステムの移行やレプリケーションサービスを提供する方法があります。移行と複製の目的のために、ファイルシステムは与えられたfsidを共有するすべてのファイルが（メジャーとマイナーの両方の値が同じである）として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations attribute provides a list of filesystem locations. These locations are specified by providing the server name (either DNS domain or IP address) and the path name representing the root of the filesystem. Depending on the type of service being provided, the list will provide a new location or a set of alternate locations for the filesystem. The client will use this information to redirect its requests to the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_位置の属性は、ファイルシステムの場所のリストを提供します。これらの場所は、サーバー名（DNSドメインやIPアドレスのいずれか）と、ファイルシステムのルートを表すパス名を提供することにより、指定されています。提供されるサービスのタイプに応じて、リストは、新しい場所やファイルシステムの代替ロケーションのセットを提供します。クライアントは、新しいサーバーにその要求をリダイレクトするために、この情報を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。レプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is expected that filesystem replication will be used in the case of read-only data. Typically, the filesystem will be replicated on two or more servers. The fs_locations attribute will provide the list of these locations to the client. On first access of the filesystem, the client should obtain the value of the fs_locations attribute. If, in the future, the client finds the server unresponsive, the client may attempt to use another server specified by fs_locations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの複製は、読み取り専用データの場合に使用されることが期待されます。通常、ファイルシステムは、二つ以上のサーバーに複製されます。 fs_位置は、クライアントにこれらの場所のリストを提供します属性。ファイルシステムの最初のアクセスでは、クライアントはfs_位置の属性の値を取得する必要があります。 、将来的には、クライアントはサーバーが応答しない見つけた場合、クライアントはfs_位置で指定された別のサーバーを使用するように試みることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If applicable, the client must take the appropriate steps to recover valid filehandles from the new server. This is described in more detail in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
該当する場合、クライアントは新しいサーバから有効なファイルハンドルを回復するために適切な措置を講じなければなりません。これは、次のセクションで詳細に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Migration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。移動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Filesystem migration is used to move a filesystem from one server to another. Migration is typically used for a filesystem that is writable and has a single copy. The expected use of migration is for load balancing or general resource reallocation. The protocol does not specify how the filesystem will be moved between servers. This server-to-server transfer mechanism is left to the server implementor. However, the method used to communicate the migration event between client and server is specified here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムの移行は、あるサーバーから別のサーバーへのファイルシステムを移動するために使用されます。移行は、一般的に書き込み可能であり、単一のコピーを持っているファイルシステムに使用されます。移行の予想される使用は、負荷分散や、一般的なリソースの再配分のためです。プロトコルは、ファイルシステムがサーバ間で移動する方法を指定しません。このサーバー間の転送メカニズムは、サーバーの実装者に任されています。ただし、クライアントとサーバ間の移行イベントを通信するために使用される方法は、ここで指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the servers participating in the migration have completed the move of the filesystem, the error NFS4ERR_MOVED will be returned for subsequent requests received by the original server. The NFS4ERR_MOVED error is returned for all operations except PUTFH and GETATTR. Upon receiving the NFS4ERR_MOVED error, the client will obtain the value of the fs_locations attribute. The client will then use the contents of the attribute to redirect its requests to the specified server. To facilitate the use of GETATTR, operations such as PUTFH must also be accepted by the server for the migrated file system&#39;s filehandles. Note that if the server returns NFS4ERR_MOVED, the server MUST support the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行に参加するサーバーは、ファイルシステムの移動が完了したら、エラーNFS4ERR_MOVEDは、元のサーバーが受信した後続の要求のために返されます。 NFS4ERR_MOVEDエラーがPUTFHとGETATTR以外のすべての操作に対して返されます。 NFS4ERR_MOVEDエラーを受信すると、クライアントはfs_位置の属性の値を取得します。次に、クライアントは、指定されたサーバーへの要求をリダイレクトするために、属性の内容を使用します。 GETATTRの使用を容易にするために、このようPUTFHなどの操作も移行ファイルシステムのファイルハンドル用にサーバーによって受け入れられなければなりません。サーバがNFS4ERR_MOVEDを返した場合、サーバはfs_位置の属性をサポートしなければならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client requests more attributes than just fs_locations, the server may return fs_locations only. This is to be expected since the server has migrated the filesystem and may not have a method of obtaining additional attribute data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはただfs_位置よりも多くの属性を要求した場合、サーバはfs_位置を返すことがあります。これは、サーバーがファイルシステムを移行しており、追加の属性データを取得する方法を持っていない可能性があるため予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server implementor needs to be careful in developing a migration solution. The server must consider all of the state information clients may have outstanding at the server. This includes but is not limited to locking/share state, delegation state, and asynchronous file writes which are represented by WRITE and COMMIT verifiers. The server should strive to minimize the impact on its clients during and after the migration process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの実装者は、移行ソリューションの開発に注意する必要があります。サーバは、サーバで優れていて、状態情報クライアントのすべてを考慮しなければなりません。これには含まれますが、ロック/共有状態、委任状態、およびWRITEによって表されると検証をCOMMITされている非同期のファイルへの書き込みに限定されるものではありません。サーバーは、移行プロセス中および後にそのクライアントへの影響を最小限に抑えるために努力すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Interpretation of the fs_locations Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3。 fs_位置の属性の解釈
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_location attribute is structured in the following way:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location属性は次のように構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_location {
           utf8str_cis     server&lt;&gt;;
           pathname4       rootpath;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_locations {
           pathname4       fs_root;
           fs_location     locations&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_location struct is used to represent the location of a filesystem by providing a server name and the path to the root of the filesystem. For a multi-homed server or a set of servers that use the same rootpath, an array of server names may be provided. An entry in the server array is an UTF8 string and represents one of a traditional DNS host name, IPv4 address, or IPv6 address. It is not a requirement that all servers that share the same rootpath be listed in one fs_location struct. The array of server names is provided for convenience. Servers that share the same rootpath may also be listed in separate fs_location entries in the fs_locations attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_location構造体は、サーバ名とファイルシステムのルートへのパスを提供することによって、ファイルシステムの位置を表すために使用されます。マルチホームサーバーまたは同じROOTPATHを使用するサーバのセットについて、サーバ名の配列を提供することができます。サーバーアレイ内のエントリは、UTF8の文字列であり、伝統的なDNSホスト名、IPv4アドレス、またはIPv6アドレスのいずれかを表しています。これは、同じROOTPATHを共有するすべてのサーバーが1つのfs_location構造体に記載されていることは必須ではありません。サーバー名の配列は、便宜のために提供されます。同じROOTPATHを共有するサーバもfs_位置の属性で別のfs_locationエントリに表示されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fs_locations struct and attribute then contains an array of locations. Since the name space of each server may be constructed differently, the &#34;fs_root&#34; field is provided. The path represented by fs_root represents the location of the filesystem in the server&#39;s name space. Therefore, the fs_root path is only associated with the server from which the fs_locations attribute was obtained. The fs_root path is meant to aid the client in locating the filesystem at the various servers listed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fs_位置のstructと属性は、場所の配列が含まれています。各サーバーの名前空間が異なって構成することができるので、「fs_root」欄が設けられています。 fs_rootによって表されるパスは、サーバーの名前空間のファイルシステムの場所を表します。したがって、fs_rootパスのみfs_位置の属性が取得されたサーバに関連付けられています。 fs_rootパスが記載されている各種サーバのファイルシステムを検索するには、クライアントを支援するためのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, there is a replicated filesystem located at two servers (servA and servB). At servA the filesystem is located at path &#34;/a/b/c&#34;. At servB the filesystem is located at path &#34;/x/y/z&#34;. In this example the client accesses the filesystem first at servA with a multi-component lookup path of &#34;/a/b/c/d&#34;. Since the client used a multi-component lookup to obtain the filehandle at &#34;/a/b/c/d&#34;, it is unaware that the filesystem&#39;s root is located in servA&#39;s name space at &#34;/a/b/c&#34;. When the client switches to servB, it will need to determine that the directory it first referenced at servA is now represented by the path &#34;/x/y/z/d&#34; on servB. To facilitate this, the fs_locations attribute provided by servA would have a fs_root value of &#34;/a/b/c&#34; and two entries in fs_location. One entry in fs_location will be for itself (servA) and the other will be for servB with a path of &#34;/x/y/z&#34;. With this information, the client is able to substitute &#34;/x/y/z&#34; for the &#34;/a/b/c&#34; at the beginning of its access path and construct &#34;/x/y/z/d&#34; to use for the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一例として、2台のサーバ（SERVAとservB）に位置する複製ファイルシステムがあります。 SERVAでファイルシステムは、パス &#34;/ A / B / C&#34; に位置しています。 servBにファイルシステムは &#34;/ X / Y / Z&#34; 経路に配置されています。この例では、クライアントは、「/ A / B / C / D」のマルチコンポーネントルックアップ経路とSERVAで第1のファイルシステムにアクセスします。クライアントは「/ A / B / C / D」のファイルハンドルを得るために、多成分のルックアップを使用しているので、ファイルシステムのルートは「/ A / B / C」でSERVAの名前空間に配置されていることを認識しません。クライアントはservBに切り替わるときに、それは最初SERVAで参照されるディレクトリは現在servBのパス「/ X / Y / Z / D」で表されることを決定する必要があります。これを容易にするために、セルバが提供する属性fs_位置は、「/ A / B / C」とfs_locationにおける2つのエントリのfs_root値を持っているでしょう。 fs_locationにおける1つのエントリがそれ自身のために（SERVA）になり、他方は「/ X / Y / Z」のパスとservBためであろう。この情報により、クライアントは、「/ X / Y / Z / D」に使用するとそのアクセスパスの先頭に「/ A / B / C」は、「/ X / Y / Z」を代入し、構築することが可能です新しいサーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the section &#34;Security Considerations&#34; for a discussion on the recommendations for the security flavor to be used by any GETATTR operation that requests the &#34;fs_locations&#34; attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「fs_位置」属性を要求した任意のGETATTR操作で使用するセキュリティ風味のための勧告に関する議論については、「セキュリティの考慮事項」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Filehandle Recovery for Migration or Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4。マイグレーションまたはレプリケーション用のファイルハンドルの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Filehandles for filesystems that are replicated or migrated generally have the same semantics as for filesystems that are not replicated or migrated. For example, if a filesystem has persistent filehandles and it is migrated to another server, the filehandle values for the filesystem will be valid at the new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複製されたか、移行されたファイルシステムのためのファイルハンドルは、一般的に、複製または移行されていないファイルシステムの場合と同じ意味を持っています。ファイルシステムが永続的なファイルハンドルを持っており、それが別のサーバに移行されている場合、ファイルシステムのファイルハンドルの値は、新しいサーバーで有効になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For volatile filehandles, the servers involved likely do not have a mechanism to transfer filehandle format and content between themselves. Therefore, a server may have difficulty in determining if a volatile filehandle from an old server should return an error of NFS4ERR_FHEXPIRED. Therefore, the client is informed, with the use of the fh_expire_type attribute, whether volatile filehandles will expire at the migration or replication event. If the bit FH4_VOL_MIGRATION is set in the fh_expire_type attribute, the client must treat the volatile filehandle as if the server had returned the NFS4ERR_FHEXPIRED error. At the migration or replication event in the presence of the FH4_VOL_MIGRATION bit, the client will not present the original or old volatile filehandle to the new server. The client will start its communication with the new server by recovering its filehandles using the saved file names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
揮発性ファイルハンドルの場合は、おそらく関係するサーバーは、自分たちの間でファイルハンドル形式と内容を転送するためのメカニズムを持っていません。そのため、サーバは、古いサーバからの揮発性ファイルハンドルがNFS4ERR_FHEXPIREDのエラーを返すべきかどうかを判断することが困難であってもよいです。そのため、クライアントは、揮発性ファイルハンドルが移動または複製イベントで期限切れとなるかどうか、fh_expire_type属性を使用して、通知されます。ビットFH4_VOL_MIGRATIONがfh_expire_type属性に設定されている場合は、サーバーがNFS4ERR_FHEXPIREDエラーを返したかのように、クライアントは、揮発性ファイルハンドルを扱う必要があります。 FH4_VOL_MIGRATIONビットの存在下での移動または複製イベントでは、クライアントは、新しいサーバーに、元または古い揮発性ファイルハンドルを提示しません。クライアントは、保存されたファイル名を使用して、そのファイルハンドルを回収することによって、新しいサーバとの通信を開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. NFS Server Name Space
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. NFSサーバー名スペース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Server Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。サーバーの輸出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a UNIX server the name space describes all the files reachable by pathnames under the root directory or &#34;/&#34;. On a Windows NT server the name space constitutes all the files on disks named by mapped disk letters. NFS server administrators rarely make the entire server&#39;s filesystem name space available to NFS clients. More often portions of the name space are made available via an &#34;export&#34; feature. In previous versions of the NFS protocol, the root filehandle for each export is obtained through the MOUNT protocol; the client sends a string that identifies the export of name space and the server returns the root filehandle for it. The MOUNT protocol supports an EXPORTS procedure that will enumerate the server&#39;s exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIXサーバーで名前空間は、ルートディレクトリの下にパス名で到達可能なすべてのファイルを記述したり、「/」。 Windows NTサーバーで名前空間がマッピングされたディスクの文字で指定されたディスク上のすべてのファイルを構成しています。 NFSサーバーの管理者は、めったにNFSクライアントにサーバ全体のファイルシステムの名前空間を利用可能にしません。多くの場合、名前空間の部分は、「エクスポート」機能を経由して利用できるようになります。 NFSプロトコルの旧バージョンでは、各エクスポートのルートファイルハンドルは、MOUNTプロトコルを介して得られます。クライアントは、名前空間の輸出を識別する文字列を送信し、サーバーはそれのためのルートファイルハンドルを返します。 MOUNTプロトコルは、サーバの輸出を列挙しますEXPORTS手順をサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Browsing Exports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。ブラウズ輸出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol provides a root filehandle that clients can use to obtain filehandles for these exports via a multi-component LOOKUP. A common user experience is to use a graphical user interface (perhaps a file &#34;Open&#34; dialog window) to find a file via progressive browsing through a directory tree. The client must be able to move from one export to another export via single-component, progressive LOOKUP operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、クライアントが多成分LOOKUPを介してこれらの輸出のためにファイルハンドルを取得するために使用することができ、ルートファイルハンドルを提供します。一般的なユーザーエクスペリエンスは、ディレクトリツリーをプログレッシブブラウジング経由でファイルを見つけるために、グラフィカル・ユーザー・インターフェース（おそらくファイル「開く」ダイアログ・ウィンドウ）を使用することです。クライアントは、単一成分、プログレッシブLOOKUP操作を介して別の輸出に1つのエクスポートから動くことができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This style of browsing is not well supported by the NFS version 2 and 3 protocols. The client expects all LOOKUP operations to remain within a single server filesystem. For example, the device attribute will not change. This prevents a client from taking name space paths that span exports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブラウジングのこのスタイルはよくNFSバージョン2と3のプロトコルによってサポートされていません。クライアントは、すべてのLOOKUP操作は、単一のサーバのファイルシステム内にとどまると予想しています。例えば、デバイスの属性が変更されません。これは、輸出にまたがる名前空間のパスを取ってからクライアントを防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An automounter on the client can obtain a snapshot of the server&#39;s name space using the EXPORTS procedure of the MOUNT protocol. If it understands the server&#39;s pathname syntax, it can create an image of the server&#39;s name space on the client. The parts of the name space that are not exported by the server are filled in with a &#34;pseudo filesystem&#34; that allows the user to browse from one mounted filesystem to another. There is a drawback to this representation of the server&#39;s name space on the client: it is static. If the server administrator adds a new export the client will be unaware of it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント上のオートマウンタは、MOUNTプロトコルのEXPORTS手順を使用して、サーバーの名前空間のスナップショットを取得することができます。それは、サーバのパス名の構文を理解している場合、それは、クライアント上のサーバーの名前空間の画像を作成することができます。サーバによってエクスポートされていない名前空間の部分は、ユーザが別のマウントされたファイルシステムから閲覧することを可能にする「擬似ファイルシステム」で充填されます。クライアント上のサーバーの名前空間のこの表現への欠点があります：それは静的です。サーバ管理者が新たな輸出を追加した場合、クライアントはそれに気づいていないだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Server Pseudo Filesystem
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。サーバーの疑似ファイルシステム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS version 4 servers avoid this name space inconsistency by presenting all the exports within the framework of a single server name space. An NFS version 4 client uses LOOKUP and READDIR operations to browse seamlessly from one export to another. Portions of the server name space that are not exported are bridged via a &#34;pseudo filesystem&#34; that provides a view of exported directories only. A pseudo filesystem has a unique fsid and behaves like a normal, read only filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4サーバーは、単一のサーバーの名前空間の枠組みの中で、すべての輸出を提示することによって、この名前空間の矛盾を避けます。 NFSバージョン4クライアントは、別のエクスポートからシームレスに閲覧することLOOKUPとREADDIR操作を使用しています。エクスポートされていないサーバーの名前空間の一部のみがエクスポートされたディレクトリのビューを提供する「擬似ファイルシステム」を介してブリッジされます。疑似ファイルシステムは、ユニークなFSIDを持っており、専用のファイルシステムを読んで、通常のように振る舞います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the construction of the server&#39;s name space, it is possible that multiple pseudo filesystems may exist. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの名前空間の構築に基づいて、複数の擬似ファイルシステムが存在する可能性があります。例えば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/a pseudo filesystem /a/b real filesystem /a/b/c pseudo filesystem /a/b/c/d real filesystem
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/疑似ファイルシステム/ A / Bの実ファイルシステム/ A / B / C疑似ファイルシステム/ A / B / C / Dの実ファイルシステム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the pseudo filesystems are considered separate entities and therefore will have a unique fsid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
疑似ファイルシステムは、それぞれ別個のものと考えられているため、ユニークなFSIDを持つことになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Multiple Roots
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4。複数のルーツ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DOS and Windows operating environments are sometimes described as having &#34;multiple roots&#34;. Filesystems are commonly represented as disk letters. MacOS represents filesystems as top level names. NFS version 4 servers for these platforms can construct a pseudo file system above these root names so that disk letters or volume names are simply directory names in the pseudo root.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DOSとWindowsのオペレーティング環境は、時々「重根」を有すると記載されています。ファイルシステムは、一般的にディスクの文字として表されます。 MacOSのは、トップレベルの名前としてファイルシステムを表します。ディスクの文字またはボリューム名は、単に疑似ルートにディレクトリ名になるように、NFSバージョンこれらのプラットフォーム用の4台のサーバーは、これらのルート名の上の擬似ファイルシステムを構築することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. Filehandle Volatility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5。ファイルハンドルボラティリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nature of the server&#39;s pseudo filesystem is that it is a logical representation of filesystem(s) available from the server. Therefore, the pseudo filesystem is most likely constructed dynamically when the server is first instantiated. It is expected that the pseudo filesystem may not have an on disk counterpart from which persistent filehandles could be constructed. Even though it is preferable that the server provide persistent filehandles for the pseudo filesystem, the NFS client should expect that pseudo file system filehandles are volatile. This can be confirmed by checking the associated &#34;fh_expire_type&#34; attribute for those filehandles in question. If the filehandles are volatile, the NFS client must be prepared to recover a filehandle value (e.g., with a multi-component LOOKUP) when receiving an error of NFS4ERR_FHEXPIRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバの疑似ファイルシステムの性質は、それがサーバから利用可能なファイルシステム（S）の論理的な表現であるということです。そのため、擬似ファイルシステムは、最も可能性の高いサーバが最初にインスタンス化されるときに動的に構築されています。擬似ファイルシステムが永続的なファイルハンドルを構築することができたから、ディスク上の対応するものがないことが予想されます。それは、サーバが疑似ファイルシステムの永続的なファイルハンドルを提供することが好ましいですが、NFSクライアントは、擬似ファイルシステムのファイルハンドルが揮発性であることを期待してください。これが問題になっているこれらのファイルハンドルに関連付けられた「fh_expire_type」属性をチェックすることで確認することができます。ファイルハンドルが揮発性である場合NFS4ERR_FHEXPIREDのエラーを受信した場合、NFSクライアントは、（多成分LOOKUPと例えば、）ファイルハンドル値を回復するために用意されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. Exported Root
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6。エクスポートされたルート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server&#39;s root filesystem is exported, one might conclude that a pseudo-filesystem is not needed. This would be wrong. Assume the following filesystems on a server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバのルートファイルシステムがエクスポートされている場合は、一つは疑似ファイルシステムが必要とされていないと結論することがあります。これは間違っているだろう。サーバー上で次のファイルシステムを想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /       disk1  (exported)
         /a      disk2  (not exported)
         /a/b    disk3  (exported)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because disk2 is not exported, disk3 cannot be reached with simple LOOKUPs. The server must bridge the gap with a pseudo-filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DISK2はエクスポートされていないので、DISK3は簡単な検索で到達することはできません。サーバは、擬似ファイルシステムとのギャップを埋める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7. Mount Point Crossing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7。マウントポイントクロッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server filesystem environment may be constructed in such a way that one filesystem contains a directory which is &#39;covered&#39; or mounted upon by a second filesystem. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのファイルシステム環境は、1つのファイルシステムが「カバー」や第二のファイルシステムによって時にマウントされたディレクトリを含むように構成してもよいです。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /a/b            (filesystem 1)
         /a/b/c/d        (filesystem 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pseudo filesystem for this server may be constructed to look like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このサーバーの疑似ファイルシステムが見えるように構築することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /               (place holder/not exported)
         /a/b            (filesystem 1)
         /a/b/c/d        (filesystem 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is the server&#39;s responsibility to present the pseudo filesystem that is complete to the client. If the client sends a lookup request for the path &#34;/a/b/c/d&#34;, the server&#39;s response is the filehandle of the filesystem &#34;/a/b/c/d&#34;. In previous versions of the NFS protocol, the server would respond with the filehandle of directory &#34;/a/b/c/d&#34; within the filesystem &#34;/a/b&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントへの完全な擬似ファイルシステムを提示するサーバーの責任です。クライアントは、パス「/ A / B / C / D」の検索要求を送信すると、サーバーの応答はファイルシステム「/ A / B / C / D」のファイルハンドルです。 NFSプロトコルの旧バージョンでは、サーバは、ディレクトリ、ファイルシステム内の「/ A / B / C / D」「/ A / B」のファイルハンドルを用いて応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS client will be able to determine if it crosses a server mount point by a change in the value of the &#34;fsid&#34; attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSクライアントは、サーバが「FSID」属性の値の変化により、マウントポイントを横断するかどうかを判断することができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8. Security Policy and Name Space Presentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8。セキュリティポリシーと名前空間プレゼンテーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application of the server&#39;s security policy needs to be carefully considered by the implementor. One may choose to limit the viewability of portions of the pseudo filesystem based on the server&#39;s perception of the client&#39;s ability to authenticate itself properly. However, with the support of multiple security mechanisms and the ability to negotiate the appropriate use of these mechanisms, the server is unable to properly determine if a client will be able to authenticate itself. If, based on its policies, the server chooses to limit the contents of the pseudo filesystem, the server may effectively hide filesystems from a client that may otherwise have legitimate access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのセキュリティポリシーの適用は慎重に実装者が検討する必要があります。一つは、適切に自身を認証するためのクライアントの能力のサーバーの認識に基づいて疑似ファイルシステムの部分の視認性を制限することもできます。しかし、複数のセキュリティ・メカニズムのサポートとこれらのメカニズムの適切な使用を交渉する能力を持つ、サーバーは、クライアントが自身を認証することができるようになります場合は、適切に決定することができません。 、そのポリシーに基づいて、サーバは疑似ファイルシステムの内容を制限することを選択した場合、サーバーは効果的にそれ以外の場合は、正当なアクセス権を持っていることがあり、クライアントからのファイルシステムを隠すことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As suggested practice, the server should apply the security policy of a shared resource in the server&#39;s namespace to the components of the resource&#39;s ancestors. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
提案プラクティスとして、サーバーはリソースの祖先のコンポーネントに、サーバーの名前空間内の共有リソースのセキュリティポリシーを適用する必要があります。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /
         /a/b
         /a/b/c
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The /a/b/c directory is a real filesystem and is the shared resource. The security policy for /a/b/c is Kerberos with integrity. The server should apply the same security policy to /, /a, and /a/b. This allows for the extension of the protection of the server&#39;s namespace to the ancestors of the real shared resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
/ A / B / Cディレクトリ本当のファイルシステムで、共有リソースです。 / A / B / Cのためのセキュリティポリシーは、整合性とKerberosのです。サーバーは、/、/ A、および/ A / Bに同じセキュリティポリシーを適用する必要があります。これは、実際の共有リソースの祖先に、サーバーの名前空間の保護を拡張することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the case of the use of multiple, disjoint security mechanisms in the server&#39;s resources, the security for a particular object in the server&#39;s namespace should be the union of all security mechanisms of all direct descendants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのリソースで複数の、ばらばらのセキュリティメカニズムの使用の場合には、サーバーの名前空間内の特定のオブジェクトのセキュリティは、すべての直接の子孫のすべてのセキュリティ・メカニズムの労働組合でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. File Locking and Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.ファイルロックと共有予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Integrating locking into the NFS protocol necessarily causes it to be stateful. With the inclusion of share reservations the protocol becomes substantially more dependent on state than the traditional combination of NFS and NLM [XNFS]. There are three components to making this state manageable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルにロック統合必ずしもステートフルさせます。共有の予約を含めてプロトコルはNFSとNLM [XNFS】従来の組合せよりも状態に実質的に依存するようになります。この状態は管理しやすい作りには3つのコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clear division between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバの間に明確な区分O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Ability to reliably detect inconsistency in state between client and server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O能力は確実にクライアントとサーバの間の状態に矛盾を検出します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Simple and robust recovery mechanisms
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oシンプルで堅牢な回復メカニズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this model, the server owns the state information. The client communicates its view of this state to the server as needed. The client is also able to detect inconsistent state before modifying a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このモデルでは、サーバーは、状態情報を所有しています。必要に応じてクライアントがサーバにこの状態のビューを伝えます。また、クライアントは、ファイルを変更する前に、矛盾した状態を検出することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support Win32 share reservations it is necessary to atomically OPEN or CREATE files. Having a separate share/unshare operation would not allow correct implementation of the Win32 OpenFile API. In order to correctly implement share semantics, the previous NFS protocol mechanisms used when a file is opened or created (LOOKUP, CREATE, ACCESS) need to be replaced. The NFS version 4 protocol has an OPEN operation that subsumes the NFS version 3 methodology of LOOKUP, CREATE, and ACCESS. However, because many operations require a filehandle, the traditional LOOKUP is preserved to map a file name to filehandle without establishing state on the server. The policy of granting access or modifying files is managed by the server based on the client&#39;s state. These mechanisms can implement policy ranging from advisory only locking to full mandatory locking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Win32のシェアの予約をサポートするために、それはアトミックOPENまたはファイルを作成する必要があります。別のシェア/共有解除操作を持つことのWin32のOpenFileのAPIの正しい実装を許可しないでしょう。正しく共有セマンティクスを実現するために、ファイルを開くまたは作成されたときに使用される従来のNFSプロトコルメカニズム（LOOKUPは、CREATE、ACCESS）に交換する必要があります。 NFSバージョン4プロトコルは、LOOKUP、CREATE、およびACCESSのNFSバージョン3の方法を包含するOPEN操作を有します。多くの操作は、ファイルハンドルを必要とするためしかし、伝統的なLOOKUPは、サーバー上の状態を確立することなくファイルハンドルにファイル名をマップするために保存されています。アクセスを許可またはファイルを変更するポリシーは、クライアントの状態に基づいてサーバによって管理されています。これらのメカニズムは、完全な強制ロックにロックする諮問に至るまでポリシーを実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。ロッキング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that manipulating a lock is rare when compared to READ and WRITE operations. It is also assumed that crashes and network partitions are relatively rare. Therefore it is important that the READ and WRITE operations have a lightweight mechanism to indicate if they possess a held lock. A lock request contains the heavyweight information required to establish a lock and uniquely define the lock owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読み出し動作と書き込み動作と比較した場合、ロックを操作することはまれであると仮定されます。また、クラッシュやネットワークパーティションは比較的まれであると仮定する。したがって、READとWRITE操作は、彼らが保持されたロックを所有どうかを示すための軽量なメカニズムを持っていることが重要です。ロック要求がロックを確立し、一意のロック所有者を定義するために必要なヘビーな情報を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe the transition from the heavy weight information to the eventual stateid used for most client and server locking and lease interactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のセクションでは、ほとんどのクライアントとサーバーのロックとリースの相互作用のために使用される最終的なのstateidに重い重み情報からの遷移を記述しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. Client ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1。クライアントID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each LOCK request, the client must identify itself to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各LOCK要求の場合、クライアントはサーバーに自分自身を識別しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is done in such a way as to allow for correct lock identification and crash recovery. A sequence of a SETCLIENTID operation followed by a SETCLIENTID_CONFIRM operation is required to establish the identification onto the server. Establishment of identification by a new incarnation of the client also has the effect of immediately breaking any leased state that a previous incarnation of the client might have had on the server, as opposed to forcing the new client incarnation to wait for the leases to expire. Breaking the lease state amounts to the server removing all lock, share reservation, and, where the server is not supporting the CLAIM_DELEGATE_PREV claim type, all delegation state associated with same client with the same identity. For discussion of delegation state recovery, see the section &#34;Delegation Recovery&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、正しいロック識別とクラッシュリカバリを可能にするような方法で行われます。 SETCLIENTID_CONFIRM操作続いSETCLIENTID操作のシーケンスは、サーバに識別を確立するために必要とされます。クライアントの新しいインカネーションによる識別の確立もすぐにリースの期限が切れるのを待つために新しいクライアント化身を強制的に対立するものとして、クライアントの前身は、サーバー上で持っていたかもしれない任意のリースを破らせる効果を有します。サーバがCLAIM_DELEGATE_PREV請求タイプ、同じIDで同じクライアントに関連付けられているすべての委任状態をサポートしていないすべてのロック、共有の予約などを除去サーバにリース状態量を破ります。委任状態の回復の議論については、セクション「委任回復」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client identification is encapsulated in the following structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント識別は、以下の構造の中にカプセル化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct nfs_client_id4 {
                 verifier4     verifier;
                 opaque        id&lt;NFS4_OPAQUE_LIMIT&gt;;
         };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first field, verifier is a client incarnation verifier that is used to detect client reboots. Only if the verifier is different from that which the server has previously recorded the client (as identified by the second field of the structure, id) does the server start the process of canceling the client&#39;s leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のフィールドは、検証者は、クライアントの再起動を検出するために使用されるクライアント・インカネーションの検証です。検証者は、（構造体の第2のフィールド、IDによって識別されるように）サーバが以前にクライアントを記録したものと異なる場合にのみ、サーバはクライアントのリース状態を解除するプロセスを開始しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second field, id is a variable length string that uniquely defines the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第2のフィールドは、IDは、クライアントを一意に定義する可変長の文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several considerations for how the client generates the id string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがID文字列を生成する方法にはいくつかの考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be unique so that multiple clients do not present the same string. The consequences of two clients presenting the same string range from one client getting an error to one client having its leased state abruptly and unexpectedly canceled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のクライアントが同じ文字列を提示しないように、文字列が一意である必要がありますoを。 1つのクライアントにエラーを取得して1つのクライアントから同じ文字列の範囲を提示する2つのクライアントの結果は、そのリース状態が突然と予期せずにキャンセルされました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be selected so the subsequent incarnations (e.g., reboots) of the same client cause the client to present the same string. The implementor is cautioned against an approach that requires the string to be recorded in a local file because this precludes the use of the implementation in an environment where there is no local disk and all file access is from an NFS version 4 server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O文字列は、同じ文字列を提示するようにクライアントを引き起こす同じクライアントの後続の化身（例えば、リブート）ように選択されるべきです。実装者は、これはローカルディスクがない環境での実装の使用を排除し、すべてのファイルアクセスは、NFSバージョン4サーバーからあるので、ローカルファイルに記録される文字列を必要としたアプローチに警告を発しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The string should be different for each server network address that the client accesses, rather than common to all server network addresses. The reason is that it may not be possible for the client to tell if the same server is listening on multiple network addresses. If the client issues SETCLIENTID with the same id string to each network address of such a server, the server will think it is the same client, and each successive SETCLIENTID will cause the server to begin the process of removing the client&#39;s previous leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの文字列は、すべてのサーバのネットワークアドレスにクライアントがアクセスする各サーバーネットワークアドレスの異なる、というより一般的でなければなりません。その理由は、クライアントが同じサーバーに複数のネットワーク・アドレスでリッスンされているかどうかをすることは可能ではないかもしれないということです。クライアントの問題は、サーバの各ネットワークアドレスに同じID文字列でSETCLIENTID場合、サーバは同じクライアントだと思いますし、それぞれの連続したSETCLIENTIDは、サーバーがクライアントの以前のリースの状態を除去するプロセスを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The algorithm for generating the string should not assume that the client&#39;s network address won&#39;t change. This includes changes between client incarnations and even changes while the client is stilling running in its current incarnation. This means that if the client includes just the client&#39;s and server&#39;s network address in the id string, there is a real risk, after the client gives up the network address, that another client, using a similar algorithm for generating the id string, will generate a conflicting id string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの文字列を生成するためのアルゴリズムは、クライアントのネットワークアドレスが変更されないことを仮定するべきではありません。クライアントが現在の化身で実行して減勢されている間これは、クライアントの化身とでも変化と変更が含まれています。これは、クライアントがネットワークアドレスを放棄した後、クライアントはクライアントだけのとid文字列にサーバのネットワークアドレスが含まれている場合、現実的なリスクがあることを意味し、id文字列を生成するための同様のアルゴリズムを使用して別のクライアントが、生成すること競合id文字列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above considerations, an example of a well generated id string is one that includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の考察を考慮すると、十分に生成されたID列の例を含むものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server&#39;s network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバのネットワークアドレスO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s network address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのネットワークアドレスO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For a user level NFS version 4 client, it should contain additional information to distinguish the client from other user level clients running on the same host, such as a process id or other unique sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OユーザレベルNFSバージョン4クライアントの場合、このようなプロセスIDまたは他のユニーク配列と同じホスト上で動作している他のユーザーレベルのクライアントからクライアントを区別するために付加的な情報を含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Additional information that tends to be unique, such as one or more of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようの一つ以上のように、ユニークになりがちO追加情報：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The client machine&#39;s serial number (for privacy reasons, it is best to perform some one way function on the serial number).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - クライアントマシンのシリアル番号（プライバシー上の理由から、それはシリアル番号にいくつかのいずれかの方法の機能を実行するのが最善です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- A MAC address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  A MACアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The timestamp of when the NFS version 4 software was first installed on the client (though this is subject to the previously mentioned caution about using information that is stored in a file, because the file might only be accessible over NFS version 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - （ファイルのみNFSバージョン4を介してアクセス可能性があるため、これは、ファイルに格納されている情報の使用に関する前述の注意の対象となるが）NFSバージョン4のソフトウェアは、最初のクライアントにインストールしたときのタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- A true random number. However since this number ought to be the same between client incarnations, this shares the same problem as that of the using the timestamp of the software installation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - 真の乱数。しかし、この数は、クライアント・インカネーションの間で同じであるべきことから、これは、ソフトウェアのインストールのタイムスタンプを使用してのものと同じ問題を共有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a security measure, the server MUST NOT cancel a client&#39;s leased state if the principal established the state for a given id string is not the same as the principal issuing the SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プリンシパルが与えられたid文字列の状態を確立した場合のセキュリティ対策として、サーバーはクライアントのリース状態を解除してはならないSETCLIENTIDを発行する元本と同じではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that SETCLIENTID and SETCLIENTID_CONFIRM has a secondary purpose of establishing the information the server needs to make callbacks to the client for purpose of supporting delegations. It is permitted to change this information via SETCLIENTID and SETCLIENTID_CONFIRM within the same incarnation of the client without removing the client&#39;s leased state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDとSETCLIENTID_CONFIRMサーバが代表団を支援する目的で、クライアントへのコールバックを行うために必要な情報を確立する二次的な目的を持っていることに注意してください。クライアントのリースの状態を削除せずに、クライアントの同じ化身内SETCLIENTIDとSETCLIENTID_CONFIRMを経由してこの情報を変更することが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a SETCLIENTID and SETCLIENTID_CONFIRM sequence has successfully completed, the client uses the shorthand client identifier, of type clientid4, instead of the longer and less compact nfs_client_id4 structure. This shorthand client identifier (a clientid) is assigned by the server and should be chosen so that it will not conflict with a clientid previously assigned by the server. This applies across server restarts or reboots. When a clientid is presented to a server and that clientid is not recognized, as would happen after a server reboot, the server will reject the request with the error NFS4ERR_STALE_CLIENTID. When this happens, the client must obtain a new clientid by use of the SETCLIENTID operation and then proceed to any other necessary recovery for the server reboot case (See the section &#34;Server Failure and Recovery&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDとSETCLIENTID_CONFIRMシーケンスが正常に完了すると、クライアントはタイプclientid4の代わりに、より長く、より少ないコンパクトなnfs_client_id4構造のため、速記クライアント識別子を使用しています。この速記クライアント識別子（clientidのは）サーバーによって割り当てられ、それが以前にサーバによって割り当てられたClientIDと競合しないように選択する必要があります。これは、サーバの再起動または再起動しても適用されます。 ClientIDがサーバーに提示され、それにClientIDは、サーバの再起動後に起こるように、認識されない場合は、サーバがエラーNFS4ERR_STALE_CLIENTIDで要求を拒否します。このような場合、クライアントはSETCLIENTID操作の使用によって、新しいのClientIDを取得し、サーバーの再起動の場合のために、他の必要な回復（「サーバの障害と復旧」を参照してください）を行っている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client must also employ the SETCLIENTID operation when it receives a NFS4ERR_STALE_STATEID error using a stateid derived from its current clientid, since this also indicates a server reboot which has invalidated the existing clientid (see the next section &#34;lock_owner and stateid Definition&#34; for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが現在のclientidに由来したstateidを使用してNFS4ERR_STALE_STATEIDエラーを受信したとき、これはまた、既存のclientidを無効にしているサーバーの再起動を示しているため、クライアントはまた、SETCLIENTID操作を採用する必要があります（詳細については、次のセクション「lock_ownerとのstateidの定義」を参照してください） 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the detailed descriptions of SETCLIENTID and SETCLIENTID_CONFIRM for a complete specification of the operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の完全な仕様についてはSETCLIENTIDとSETCLIENTID_CONFIRMの詳細な説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. Server Release of Clientid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2。 CLIENTIDのServerリリース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server determines that the client holds no associated state for its clientid, the server may choose to release the clientid. The server may make this choice for an inactive client so that resources are not consumed by those intermittently active clients. If the client contacts the server after this release, the server must ensure the client receives the appropriate error so that it will use the SETCLIENTID/SETCLIENTID_CONFIRM sequence to establish a new identity. It should be clear that the server must be very hesitant to release a clientid since the resulting work on the client to recover from such an event will be the same burden as if the server had failed and restarted. Typically a server would not release a clientid unless there had been no activity from that client for many minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、クライアントがそのclientidのための関連した状態を保持していないと判断した場合、サーバーはそのclientidをリリースすることもできます。リソースは、これらの断続的にアクティブなクライアントによって消費されないように、サーバーは非アクティブクライアントのためにこの選択を行うことができます。クライアントは、このリリースの後にサーバー場合は、サーバーは、それが新しいアイデンティティを確立するためにSETCLIENTID / SETCLIENTID_CONFIRMシーケンスを使用するようにクライアントに適切なエラーを受け取るようにする必要があります。サーバーが失敗し、再起動したかのようなイベントから回復するには、クライアント上の結果の作業は同じ負担になりますので、サーバがのclientidをリリースするのは非常に躊躇しなければならないことは明らかです。多く分間そのクライアントからの活動がなかった場合を除き、通常のサーバーはのclientidをリリースしないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the id string in a SETCLIENTID request is properly constructed, and if the client takes care to use the same principal for each successive use of SETCLIENTID, then, barring an active denial of service attack, NFS4ERR_CLID_INUSE should never be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID要求のid列が適切に構築されている場合、クライアントはSETCLIENTIDの各連続使用のために同じプリンシパルを使用するように世話をしている場合、および、その後、サービス攻撃のアクティブな拒否がなければ、NFS4ERR_CLID_INUSEが返されることはありませんように注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, client bugs, server bugs, or perhaps a deliberate change of the principal owner of the id string (such as the case of a client that changes security flavors, and under the new flavor, there is no mapping to the previous owner) will in rare cases result in NFS4ERR_CLID_INUSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、おそらく、クライアントのバグ、サーバーのバグ、またはID列の主な所有者の意図的な変化（そのようなセキュリティ風味を変更するクライアントの場合のように、新しい味の下で、以前の所有者へのマッピングはありません）しますまれにNFS4ERR_CLID_INUSEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In that event, when the server gets a SETCLIENTID for a client id that currently has no state, or it has state, but the lease has expired, rather than returning NFS4ERR_CLID_INUSE, the server MUST allow the SETCLIENTID, and confirm the new clientid if followed by the appropriate SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その場合、サーバーには現在の状態を持っていないクライアントIDのためのSETCLIENTIDを取得し、またはそれは状態を持っていますが、リースが期限切れになった、というNFS4ERR_CLID_INUSEを返すよりも、とき、サーバはSETCLIENTIDを許容しなければなりませんし、続いて新しいのClientIDを確認します適切なSETCLIENTID_CONFIRMによります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.3. lock_owner and stateid Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.3。 lock_ownerとのstateidの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When requesting a lock, the client must present to the server the clientid and an identifier for the owner of the requested lock. These two fields are referred to as the lock_owner and the definition of those fields are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックを要求すると、クライアントはサーバーにClientIDをし、要求されたロックの所有者のための識別子を提示する必要があります。これらの2つのフィールドはlock_ownerと呼ばれ、それらのフィールドの定義がされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A clientid returned by the server as part of the client&#39;s use of the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのClientIDはSETCLIENTID操作のクライアントの使用の一環として、サーバから返されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A variable length opaque array used to uniquely define the owner of a lock managed by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O可変長の不透明な配列は、一意のクライアントが管理するロックの所有者を定義するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This may be a thread id, process id, or other unique value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは、スレッドID、プロセスID、または他のユニークな値であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server grants the lock, it responds with a unique stateid. The stateid is used as a shorthand reference to the lock_owner, since the server will be maintaining the correspondence between them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがロックを許可した場合、それはユニークなstateidで応答します。サーバはそれらの間の対応を維持するためのstateidは、lock_ownerに速記参照として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server is free to form the stateid in any manner that it chooses as long as it is able to recognize invalid and out-of-date stateids. This requirement includes those stateids generated by earlier instances of the server. From this, the client can be properly notified of a server restart. This notification will occur when the client presents a stateid to the server from a previous instantiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、それがある限り、無効と外の日付のstateidsを認識することが可能であるとして選択したことをどのようにしたstateidを形成して自由です。この要件は、サーバーの以前のインスタンスによって生成されたもののstateidsが含まれています。このことから、クライアントは適切にサーバの再起動を通知することができます。クライアントは、前のインスタンスからサーバーへのstateidを提示したときに、この通知は発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server must be able to distinguish the following situations and return the error as specified:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、次のような状況を区別し、指定されたエラーを返すことができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The stateid was generated by an earlier server instance (i.e., before a server reboot). The error NFS4ERR_STALE_STATEID should be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid O（すなわち、サーバの再起動前に）以前のサーバインスタンスによって生成されました。エラーNFS4ERR_STALE_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The stateid was generated by the current server instance but the stateid no longer designates the current locking state for the lockowner-file pair in question (i.e., one or more locking operations has occurred). The error NFS4ERR_OLD_STATEID should be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid oを現在のサーバインスタンスによって生成されなかったが、のstateidはもはや（即ち、一つ以上のロック操作が発生した）当該lockownerファイルペアの現在のロック状態を示しています。エラーNFS4ERR_OLD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This error condition will only occur when the client issues a locking request which changes a stateid while an I/O request that uses that stateid is outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントはのstateidが未解決であることを利用したI / O要求ながらのstateidを変えるロック要求を発行したときに、このエラー条件にのみ発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The stateid was generated by the current server instance but the stateid does not designate a locking state for any active lockowner-file pair. The error NFS4ERR_BAD_STATEID should be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateid oを現在のサーバインスタンスによって生成されたが、のstateidは、任意のアクティブlockownerファイルペアのロック状態を指定しません。エラーNFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This error condition will occur when there has been a logic error on the part of the client or server. This should not happen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントまたはサーバーの一部の論理エラーがあった場合に、このエラー条件が発生します。これは起こるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One mechanism that may be used to satisfy these requirements is for the server to,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの要件を満たすために使用することができる1つの機構は、サーバーへのためであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o divide the &#34;other&#34; field of each stateid into two fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 2つのフィールドにそれぞれのstateidの「その他」フィールドを分割します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- A server verifier which uniquely designates a particular server instantiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - ユニークに特定のサーバインスタンスを指定するサーバ検証。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- An index into a table of locking-state structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - ロック状態構造のテーブルへのインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o utilize the &#34;seqid&#34; field of each stateid, such that seqid is monotonically incremented for each stateid that is associated with the same index into the locking-state table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SEQIDが単調ロック状態テーブルに同じインデックスに関連付けられているそれぞれのstateidのために増加されるように、それぞれのstateidの「SEQID」フィールドを利用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By matching the incoming stateid and its field values with the state held at the server, the server is able to easily determine if a stateid is valid for its current instantiation and state. If the stateid is not valid, the appropriate error can be supplied to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバに保持された状態に入ってくるのstateid、そのフィールドの値を照合することによって、サーバは容易のstateidが現在のインスタンスと状態のために有効であるかどうかを決定することができます。 stateidが有効でない場合、適切なエラーがクライアントに供給することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.4. Use of the stateid and Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.4。 stateidとロックの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All READ, WRITE and SETATTR operations contain a stateid. For the purposes of this section, SETATTR operations which change the size attribute of a file are treated as if they are writing the area between the old and new size (i.e., the range truncated or added to the file by means of the SETATTR), even where SETATTR is not explicitly mentioned in the text.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのREAD、WRITEとSETATTR操作のstateidを含んでいます。彼らは（つまり、範囲が切り捨てられるかSETATTRによってファイルに追加）古いものと新しいサイズとの間の領域を書いているかのように、このセクションの目的のために、ファイルのサイズ属性を変更するSETATTR操作は、処理されますSETATTRは、明示的にテキストで言及されていない場合でも。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the lock_owner performs a READ or WRITE in a situation in which it has established a lock or share reservation on the server (any OPEN constitutes a share reservation) the stateid (previously returned by the server) must be used to indicate what locks, including both record locks and share reservations, are held by the lockowner. If no state is established by the client, either record lock or share reservation, a stateid of all bits 0 is used. Regardless whether a stateid of all bits 0, or a stateid returned by the server is used, if there is a conflicting share reservation or mandatory record lock held on the file, the server MUST refuse to service the READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lock_ownerは、（任意のOPENがシェア予約を構成している）、それは、サーバー上のロックまたは共有の予約を確立している状況でREADまたはWRITEを実行した場合は（以前にサーバーから返される）のstateidは含めてどのようなロック、指示するために使用されなければなりません両方のレコードロックとシェア予約は、lockownerによって保持されています。何の状態がクライアントによって確立されていない場合は、レコードロックまたは共有の予約のいずれかは、すべてのビット0ののstateidが使用されています。競合シェア予約やファイルに開催された必須レコードロックがある場合にかかわらず、すべてのビット0ののstateidか、またはサーバから返されたstateidを使用すると、サーバーは、READを修理または書き込み操作することを拒否しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Share reservations are established by OPEN operations and by their nature are mandatory in that when the OPEN denies READ or WRITE operations, that denial results in such operations being rejected with error NFS4ERR_LOCKED. Record locks may be implemented by the server as either mandatory or advisory, or the choice of mandatory or advisory behavior may be determined by the server on the basis of the file being accessed (for example, some UNIX-based servers support a &#34;mandatory lock bit&#34; on the mode attribute such that if set, record locks are required on the file before I/O is possible). When record locks are advisory, they only prevent the granting of conflicting lock requests and have no effect on READs or WRITEs. Mandatory record locks, however, prevent conflicting I/O operations. When they are attempted, they are rejected with NFS4ERR_LOCKED. When the client gets NFS4ERR_LOCKED on a file it knows it has the proper share reservation for, it will need to issue a LOCK request on the region of the file that includes the region the I/O was to be performed on, with an appropriate locktype (i.e., READ*_LT for a READ operation, WRITE*_LT for a WRITE operation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENは、READまたはWRITE操作を拒否したとき、共有予約がOPEN操作によって、その性質上、確立されているという点で必須で、このような操作でその否定結果がエラーNFS4ERR_LOCKEDで拒否されています。レコードロックは必須または顧問のいずれかのように、サーバーによって実現することができる、または必須か助言行動の選択肢がアクセスされているファイルに基づいて、サーバによって決定することができる（例えば、いくつかのUNIXベースのサーバーは、「強制ロックをサポートモードのビット」）が設定されている場合、I / Oが可能である前に、レコードロックがファイル上で必要とされるような属性。レコードロックが助言しているとき、彼らは唯一の競合ロック要求の付与を防止し、読み出しまたは書き込みには影響しません。必須レコードロックは、しかし、I / O操作の競合防ぎます。それらが試みられている場合、それらはNFS4ERR_LOCKEDで拒否されています。クライアントは、それがために、適切な共有の予約を持って知っているファイルにNFS4ERR_LOCKEDを取得すると、それはI / Oは、適切な種類のLockTypeで、上に実行されることになっていた領域を含むファイル領域上のロック要求を発行する必要があります。 （すなわち、READ操作用のREAD * _LT、WRITE動作のための* _LTをWRITE）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With NFS version 3, there was no notion of a stateid so there was no way to tell if the application process of the client sending the READ or WRITE operation had also acquired the appropriate record lock on the file. Thus there was no way to implement mandatory locking. With the stateid construct, this barrier has been removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READまたはWRITE操作を送信するクライアントのアプリケーション・プロセスは、ファイルに適切なレコードロックを獲得していた場合は指示する方法はありませんでしたので、NFSバージョン3では、のstateidの概念がなかったです。このように強制ロックを実装する方法はありませんでした。 stateid構築物で、この障壁は削除されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for UNIX environments that support mandatory file locking, the distinction between advisory and mandatory locking is subtle. In fact, advisory and mandatory record locks are exactly the same in so far as the APIs and requirements on implementation. If the mandatory lock attribute is set on the file, the server checks to see if the lockowner has an appropriate shared (read) or exclusive (write) record lock on the region it wishes to read or write to. If there is no appropriate lock, the server checks if there is a conflicting lock (which can be done by attempting to acquire the conflicting lock on the behalf of the lockowner, and if successful, release the lock after the READ or WRITE is done), and if there is, the server returns NFS4ERR_LOCKED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須ファイルのロックをサポートするUNIX環境では、顧問と強制ロックの区別は微妙であることに注意してください。実際には、顧問と必須レコードロックは、これまでのところ、実装上のAPIや要件などでまったく同じです。強制ロック属性がファイルに設定されている場合はlockownerは、それが読み取りまたは書き込みをしたい領域上の共有の適切な（読み取り）または排他（書き込み）レコードロックを持っている場合、サーバーかどうかを確認します。何の適切なロックが存在しない場合は、競合ロックサーバのチェックがある場合（lockownerに代わって競合ロックを取得しようとすることによって行うことができ、成功した場合、READまたはWRITEが行われた後、ロックを解除）あれば、そして、サーバはNFS4ERR_LOCKEDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Windows environments, there are no advisory record locks, so the server always checks for record locks during I/O requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Windows環境の場合は、何の助言レコードロックが存在しないので、サーバは常にI / O要求時にレコードロックをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the NFS version 4 LOCK operation does not need to distinguish between advisory and mandatory record locks. It is the NFS version 4 server&#39;s processing of the READ and WRITE operations that introduces the distinction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、NFSバージョン4 LOCK操作が顧問と必須レコードロックを区別する必要はありません。それは区別を紹介読み取りおよび書き込み操作のNFSバージョン4サーバーの処理です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every stateid other than the special stateid values noted in this section, whether returned by an OPEN-type operation (i.e., OPEN, OPEN_DOWNGRADE), or by a LOCK-type operation (i.e., LOCK or LOCKU), defines an access mode for the file (i.e., READ, WRITE, or READ-WRITE) as established by the original OPEN which began the stateid sequence, and as modified by subsequent OPENs and OPEN_DOWNGRADEs within that stateid sequence. When a READ, WRITE, or SETATTR which specifies the size attribute, is done, the operation is subject to checking against the access mode to verify that the operation is appropriate given the OPEN with which the operation is associated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのこのセクションでは、開放型の操作（すなわち、OPEN、OPEN_DOWNGRADE）によって返されたかどうか、またはロック型の操作（すなわち、LOCKまたはLOCKU）によって示さ特別なstateid値以外のstateid、のアクセスモードを定義stateidシーケンスを開始した元のOPENによって確立され、そののstateidシーケンス内の後続開き、OPEN_DOWNGRADEsによって修正され（すなわち、READ、WRITE、または読み書き可能）ファイル。読み取り、書き込み、またはサイズ属性を指定SETATTRが行われる場合、動作は、動作は動作が関連付けられているOPENを与え適切であることを確認するために、アクセスモードに対してチェックを受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of WRITE-type operations (i.e., WRITEs and SETATTRs which set size), the server must verify that the access mode allows writing and return an NFS4ERR_OPENMODE error if it does not. In the case, of READ, the server may perform the corresponding check on the access mode, or it may choose to allow READ on opens for WRITE only, to accommodate clients whose write implementation may unavoidably do reads (e.g., due to buffer cache constraints). However, even if READs are allowed in these circumstances, the server MUST still check for locks that conflict with the READ (e.g., another open specify denial of READs). Note that a server which does enforce the access mode check on READs need not explicitly check for conflicting share reservations since the existence of OPEN for read access guarantees that no conflicting share reservation can exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込みタイプの操作（すなわち、書き込みとサイズを設定SETATTRs）の場合には、サーバは、アクセスモードが書き込みを許可することを確認し、そうでない場合NFS4ERR_OPENMODEエラーを返さなければなりません。場合は、READの、サーバがアクセスモードに対応するチェックを行うことができる、またはそれだけでWRITEのために開いた上で、READを許可するように選択することができ、その書き込みの実装を行う避けられないかもしれ読み込み、クライアントに対応するために（例えば、キャッシュ制約をバッファリングによる）。しかしながら、このような状況で許可されている読んでも、サーバーはREADと競合する（例えば、別のREADが拒否を指定開く）ロックをチェックしなければなりません。アクセス・モードがオンのチェック施行し、サーバーが明示的に競合する株式の予約が存在しないことを読み取りアクセス保証のためのOPENの存在以来、シェアの予約の競合をチェックする必要はありません読み取るように注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A stateid of all bits 1 (one) MAY allow READ operations to bypass locking checks at the server. However, WRITE operations with a stateid with bits all 1 (one) MUST NOT bypass locking checks and are treated exactly the same as if a stateid of all bits 0 were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのビット1（1）ののstateidは、READ操作はサーバにロックチェックをバイパスすることを可能にし得ます。しかしながら、全て1（1）は、バイパスチェックをロックしてはいけませんと全ビット0のstateidが使用された場合と全く同様に処理されたビットとのstateidと動作を記述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A lock may not be granted while a READ or WRITE operation using one of the special stateids is being performed and the range of the lock request conflicts with the range of the READ or WRITE operation. For the purposes of this paragraph, a conflict occurs when a shared lock is requested and a WRITE operation is being performed, or an exclusive lock is requested and either a READ or a WRITE operation is being performed. A SETATTR that sets size is treated similarly to a WRITE as discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別のstateidsのいずれかを使用してREADまたはWRITE動作が行われ、READまたはWRITE動作の範囲とロック要求の競合の範囲されている間、ロックが付与されなくてもよいです。共有ロックが要求され、書き込み動作が行われている、または排他ロックが要求され、READまたはWRITE動作のいずれかが行われているとき、この項の目的のために、競合が発生します。上述のように大きさを設定するSETATTRは、書き込みと同様に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.5. Sequencing of Lock Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.5。ロック要求のシーケンシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Locking is different than most NFS operations as it requires &#34;at-most-one&#34; semantics that are not provided by ONCRPC. ONCRPC over a reliable transport is not sufficient because a sequence of locking requests may span multiple TCP connections. In the face of retransmission or reordering, lock or unlock requests must have a well defined and consistent behavior. To accomplish this, each lock request contains a sequence number that is a consecutively increasing integer. Different lock_owners have different sequences. The server maintains the last sequence number (L) received and the response that was returned. The first request issued for any given lock_owner is issued with a sequence number of zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが「で最も-1」ONCRPCによって提供されていないセマンティクスを必要とするロックは、ほとんどのNFS操作とは異なります。ロック要求のシーケンスは、複数のTCP接続にまたがる可能性があるため、信頼性の高いトランスポート上でONCRPCは十分ではありません。再送信または並べ替えの顔には、ロックまたはロック解除要求が明確に定義されたと一貫性のある動作を持っている必要があります。これを達成するために、各ロック要求が連続して増加する整数であり、シーケンス番号を含みます。異なるlock_ownersは異なる配列を有します。サーバーは、最後のシーケンス番号（L）を受信し、返された応答を維持します。任意の所与のlock_ownerに対して発行された最初の要求は、ゼロのシーケンス番号が発行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for requests that contain a sequence number, for each lock_owner, there should be no more than one outstanding request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号を含む要求に対して、各lock_ownerのために、1つ以下の未処理の要求があってはならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a request (r) with a previous sequence number (r &lt; L) is received, it is rejected with the return of error NFS4ERR_BAD_SEQID. Given a properly-functioning client, the response to (r) must have been received before the last request (L) was sent. If a duplicate of last request (r == L) is received, the stored response is returned. If a request beyond the next sequence (r == L + 2) is received, it is rejected with the return of error NFS4ERR_BAD_SEQID. Sequence history is reinitialized whenever the SETCLIENTID/SETCLIENTID_CONFIRM sequence changes the client verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前回のシーケンス番号（R &lt;L）と要求（R）が受信される場合には、エラーNFS4ERR_BAD_SEQIDの復帰で拒絶されます。最後の要求（L）が送信される前に、適切に機能するクライアントを考えると、（R）への応答が受信されている必要があります。最後の要求（R == L）の複製を受信した場合、保存された応答が返されます。次のシーケンス（R == L + 2）を越えた要求を受信した場合、それはエラーNFS4ERR_BAD_SEQIDの復帰で拒絶されます。 SETCLIENTID / SETCLIENTID_CONFIRMシーケンスは、クライアント検証を変更するたびに、シーケンス履歴が再初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the sequence number is represented with an unsigned 32-bit integer, the arithmetic involved with the sequence number is mod 2^32. For an example of modulo arithmetic involving sequence numbers see [RFC793].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号は32ビットの符号なし整数で表現されているので、シーケンス番号に関わる演算は、2 ^ 32のMODです。シーケンス番号を含むモジュロ演算の例については、[RFC793]参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is critical the server maintain the last response sent to the client to provide a more reliable cache of duplicate non-idempotent requests than that of the traditional cache described in [Juszczak]. The traditional duplicate request cache uses a least recently used algorithm for removing unneeded requests. However, the last lock request and response on a given lock_owner must be cached as long as the lock state exists on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが[Juszczak]で説明従来のキャッシュよりも、重複非べき等の要求より信頼性の高いキャッシュを提供するために、クライアントに送信された最後の応答を維持する重要です。伝統的な重複要求キャッシュは不要な要求を除去するために最も最近使用されたアルゴリズムを使用しています。しかし、与えられたlock_ownerの最後のロック要求と応答がある限り、ロック状態がサーバー上に存在するとしてキャッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST monotonically increment the sequence number for the CLOSE, LOCK, LOCKU, OPEN, OPEN_CONFIRM, and OPEN_DOWNGRADE operations. This is true even in the event that the previous operation that used the sequence number received an error. The only exception to this rule is if the previous operation received one of the following errors: NFS4ERR_STALE_CLIENTID, NFS4ERR_STALE_STATEID, NFS4ERR_BAD_STATEID, NFS4ERR_BAD_SEQID, NFS4ERR_BADXDR, NFS4ERR_RESOURCE, NFS4ERR_NOFILEHANDLE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは単調CLOSE、LOCK、LOCKU、OPEN、オープン_CONFIRM、およびOPEN_DOWNGRADE操作のためのシーケンス番号を増加しなければなりません。これは、偶数シーケンス番号を使用する前の操作がエラーを受信した場合に真です。 NFS4ERR_STALE_CLIENTID、NFS4ERR_STALE_STATEID、NFS4ERR_BAD_STATEID、NFS4ERR_BAD_SEQID、NFS4ERR_BADXDR、NFS4ERR_RESOURCE、NFS4ERR_NOFILEHANDLE：前の操作には、以下のいずれかのエラーを受け取った場合は、この規則の唯一の例外はあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.6. Recovery from Replayed Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.6。リプレイリクエストからの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described above, the sequence number is per lock_owner. As long as the server maintains the last sequence number received and follows the methods described above, there are no risks of a Byzantine router re-sending old requests. The server need only maintain the (lock_owner, sequence number) state as long as there are open files or closed files with locks outstanding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述したように、シーケンス番号はlock_ownerごとあります。限り、サーバーが受信した最後のシーケンス番号を維持し、上記の方法を以下のように、古い要求を再送信するビザンチンルータの一切のリスクはありません。サーバは限り優れたロックと開いているファイルまたは閉じたファイルがあるので（lock_owner、シーケンス番号）状態を維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK, LOCKU, OPEN, OPEN_DOWNGRADE, and CLOSE each contain a sequence number and therefore the risk of the replay of these operations resulting in undesired effects is non-existent while the server maintains the lock_owner state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK、LOCKU、OPEN、OPEN_DOWNGRADE、各サーバがlock_owner状態を維持しながら、非存在である配列番号したがって望ましくない影響をもたらすこれらの操作の再生のリスクを含むCLOSE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.7. Releasing lock_owner State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.7。 lock_owner状態を解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a particular lock_owner no longer holds open or file locking state at the server, the server may choose to release the sequence number state associated with the lock_owner. The server may make this choice based on lease expiration, for the reclamation of server memory, or other implementation specific details. In any event, the server is able to do this safely only when the lock_owner no longer is being utilized by the client. The server may choose to hold the lock_owner state in the event that retransmitted requests are received. However, the period to hold this state is implementation specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のlock_ownerは、もはやサーバーで開いたり、ファイルロック状態を保持している場合は、サーバーはlock_ownerに関連付けられたシーケンス番号を解除することを選択しないことがあります。サーバーは、サーバーのメモリ、または他の実装固有の詳細の再生のために、リース満了に基づいてこの選択を行うことができます。いずれにせよ、サーバは安全にlock_ownerがもはやクライアントによって利用されていない場合にのみ、これを実行することができます。サーバは、再送要求が受信された場合にlock_owner状態を保持することもできます。しかし、この状態を保持する期間は、実装固有のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a LOCK, LOCKU, OPEN_DOWNGRADE, or CLOSE is retransmitted after the server has previously released the lock_owner state, the server will find that the lock_owner has no files open and an error will be returned to the client. If the lock_owner does have a file open, the stateid will not match and again an error is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが以前lock_owner状態をリリースした後にLOCK、LOCKU、OPEN_DOWNGRADE、またはCLOSEが再送される場合には、サーバはlock_ownerが開いているファイルがありませんし、エラーがクライアントに返されることがわかります。 lock_ownerが開いているファイルを持っている場合は、のstateidは一致しませんし、再びエラーがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.8. Use of Open Confirmation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.8。オープン確認の使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that an OPEN is retransmitted and the lock_owner is being used for the first time or the lock_owner state has been previously released by the server, the use of the OPEN_CONFIRM operation will prevent incorrect behavior. When the server observes the use of the lock_owner for the first time, it will direct the client to perform the OPEN_CONFIRM for the corresponding OPEN. This sequence establishes the use of an lock_owner and associated sequence number. Since the OPEN_CONFIRM sequence connects a new open_owner on the server with an existing open_owner on a client, the sequence number may have any value. The OPEN_CONFIRM step assures the server that the value received is the correct one. See the section &#34;OPEN_CONFIRM - Confirm Open&#34; for further details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが再送され、サーバによってlock_ownerが初めて使用されているかlock_owner状態が以前にリリースされた場合には、オープン_CONFIRM操作を使用すると、不正な動作を防止します。サーバが初めてlock_ownerの使用を観察すると、対応するOPENのためのオープン_CONFIRMを実行するために、クライアントに指示します。この配列はlock_ownerと関連するシーケンス番号の使用を確立します。オープン_CONFIRMシーケンスは、クライアント上の既存のopen_ownerでサーバー上に新しいopen_ownerを接続しているので、シーケンス番号は、任意の値を有することができます。オープン_CONFIRMステップは、受信された値が正しいものであるサーバを保証します。詳細について - セクション「オープンを確認してオープン_CONFIRM」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of situations in which the requirement to confirm an OPEN would pose difficulties for the client and server, in that they would be prevented from acting in a timely fashion on information received, because that information would be provisional, subject to deletion upon non-confirmation. Fortunately, these are situations in which the server can avoid the need for confirmation when responding to open requests. The two constraints are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時に削除の対象その情報は暫定的になるので、彼らは、受信した情報にタイムリーに行動することを防止することがあろうとしてOPENを確認するための要件は、クライアントとサーバーのために困難をもたらすことになる状況の数がありますが、非確認。幸いなことに、これらの要求を開くに応答するときに、サーバーが確認の必要性を回避することができている状況です。 2つの制約があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server must not bestow a delegation for any open which would require confirmation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバーには確認が必要と思われる任意のオープンのための委任を授けるてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server MUST NOT require confirmation on a reclaim-type open (i.e., one specifying claim type CLAIM_PREVIOUS or CLAIM_DELEGATE_PREV).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは再利用型オープン（すなわち、ある特定のクレームの種類CLAIM_PREVIOUSまたはCLAIM_DELEGATE_PREV）に確認を要求してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These constraints are related in that reclaim-type opens are the only ones in which the server may be required to send a delegation. For CLAIM_NULL, sending the delegation is optional while for CLAIM_DELEGATE_CUR, no delegation is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの制約は、その再利用型で開きます関連しているサーバーが委任を送信するために必要とすることのできる唯一のものです。 CLAIM_DELEGATE_CURのために、何の代表団が送信されない一方でCLAIM_NULLについて、代表団を送ることはオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations being sent with an open requiring confirmation are troublesome because recovering from non-confirmation adds undue complexity to the protocol while requiring confirmation on reclaim-type opens poses difficulties in that the inability to resolve the status of the reclaim until lease expiration may make it difficult to have timely determination of the set of locks being reclaimed (since the grace period may expire).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再利用型に確認を必要としながら、非確認から回復するプロトコルに過度の複雑さを追加するためのオープンが必要な確認を送られている代表団は厄介であるリース満了するまで、再利用の状況を解決できないことは、それが困難になることが困難にでポーズ開きます（猶予期間の期限が切れる可能性があるため）再利用されているロックのセットのタイムリーな決意を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requiring open confirmation on reclaim-type opens is avoidable because of the nature of the environments in which such opens are done. For CLAIM_PREVIOUS opens, this is immediately after server reboot, so there should be no time for lockowners to be created, found to be unused, and recycled. For CLAIM_DELEGATE_PREV opens, we are dealing with a client reboot situation. A server which supports delegation can be sure that no lockowners for that client have been recycled since client initialization and thus can ensure that confirmation will not be required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再利用型に開いて確認を開き要求することはあるため、このような開きが行われている環境の性質の回避です。 CLAIM_PREVIOUSが開くために、これはサーバーの再起動直後であるので、lockownersは、作成した未使用であることが判明し、リサイクルするための時間があってはなりません。 CLAIM_DELEGATE_PREVが開くために、私たちはクライアントの再起動状況を扱っています。委任をサポートするサーバは、そのクライアントのためのlockownersがクライアントの初期化以来、リサイクルされていないので、その確認が必要とされないことを確認することができますことを確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Lock Ranges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。ロック範囲
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol allows a lock owner to request a lock with a byte range and then either upgrade or unlock a sub-range of the initial lock. It is expected that this will be an uncommon type of request. In any case, servers or server filesystems may not be able to support sub-range lock semantics. In the event that a server receives a locking request that represents a sub-range of current locking state for the lock owner, the server is allowed to return the error NFS4ERR_LOCK_RANGE to signify that it does not support sub-range lock operations. Therefore, the client should be prepared to receive this error and, if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルは、ロック所有者は、バイト範囲のロックを要求した後、初期ロックのサブ範囲をアップグレードするか、アンロックのいずれかを可能にします。要求の珍しいタイプであることが期待されます。いずれの場合も、サーバーまたはサーバーのファイルシステムは、サブ範囲ロックのセマンティクスをサポートすることができない場合があります。サーバがロック所有者の現在のロック状態のサブ範囲を表すロック要求を受信した場合に、サーバは、それがサブ範囲ロック操作をサポートしていないことを示すためにエラーNFS4ERR_LOCK_RANGEを返すことが許可されています。そのため、クライアントは、適切な場合には、要求元のアプリケーションにエラーを報告し、このエラーを受け取るために準備してする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client is discouraged from combining multiple independent locking ranges that happen to be adjacent into a single request since the server may not support sub-range requests and for reasons related to the recovery of file locking state in the event of server failure. As discussed in the section &#34;Server Failure and Recovery&#34; below, the server may employ certain optimizations during recovery that work effectively only when the client&#39;s behavior during lock recovery is similar to the client&#39;s locking behavior prior to server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバが、サブ範囲要求をサポートしないかもしれないので、単一の要求に隣接するように起こる複数の独立したロック範囲を組み合わせることから、サーバに障害が発生した場合の状態をロックファイルの回復に関連する理由のために推奨されています。以下の「サーバーの障害および回復」で説明したように、サーバはロックリカバリ時のクライアントの動作は、以前のサーバーの障害へのクライアントのロック動作に似ている場合にのみ、効果的に機能回復中の特定の最適化を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Upgrading and Downgrading Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3。ロックのアップグレードとダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client has a write lock on a record, it can request an atomic downgrade of the lock to a read lock via the LOCK request, by setting the type to READ_LT. If the server supports atomic downgrade, the request will succeed. If not, it will return NFS4ERR_LOCK_NOTSUPP. The client should be prepared to receive this error, and if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがレコードの書き込みロックを持っている場合、それはREAD_LTにタイプを設定することにより、LOCK要求によって読み取りロックにロックの原子格下げを要求することができます。サーバは、原子ダウングレードをサポートしている場合、要求は成功します。そうでない場合、それはNFS4ERR_LOCK_NOTSUPPを返します。クライアントは、このエラーを受け取るために準備し、適切な場合には、要求元のアプリケーションにエラーを報告しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client has a read lock on a record, it can request an atomic upgrade of the lock to a write lock via the LOCK request by setting the type to WRITE_LT or WRITEW_LT. If the server does not support atomic upgrade, it will return NFS4ERR_LOCK_NOTSUPP. If the upgrade can be achieved without an existing conflict, the request will succeed. Otherwise, the server will return either NFS4ERR_DENIED or NFS4ERR_DEADLOCK. The error NFS4ERR_DEADLOCK is returned if the client issued the LOCK request with the type set to WRITEW_LT and the server has detected a deadlock. The client should be prepared to receive such errors and if appropriate, report the error to the requesting application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがレコードの読み取りロックを持っている場合、それはWRITE_LTまたはWRITEW_LTするタイプを設定することにより、LOCK要求を経由して書き込みロックへのロックの原子アップグレードを要求することができます。サーバは、原子のアップグレードをサポートしていない場合、それはNFS4ERR_LOCK_NOTSUPPを返します。アップグレードは、既存の競合することなく達成することができた場合、要求は成功します。そうしないと、サーバはNFS4ERR_DENIEDまたはNFS4ERR_DEADLOCKのいずれかを返します。クライアントがWRITEW_LTに設定するタイプでLOCK要求を発行し、サーバーがデッドロックを検出した場合、エラーNFS4ERR_DEADLOCKが返されます。クライアントは、このようなエラーを受け取るために準備し、適切な場合には、要求元のアプリケーションにエラーを報告しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. Blocking Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4。ブロッキング・ロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some clients require the support of blocking locks. The NFS version 4 protocol must not rely on a callback mechanism and therefore is unable to notify a client when a previously denied lock has been granted. Clients have no choice but to continually poll for the lock. This presents a fairness problem. Two new lock types are added, READW and WRITEW, and are used to indicate to the server that the client is requesting a blocking lock. The server should maintain an ordered list of pending blocking locks. When the conflicting lock is released, the server may wait the lease period for the first waiting client to re-request the lock. After the lease period expires the next waiting client request is allowed the lock. Clients are required to poll at an interval sufficiently small that it is likely to acquire the lock in a timely manner. The server is not required to maintain a list of pending blocked locks as it is used to increase fairness and not correct operation. Because of the unordered nature of crash recovery, storing of lock state to stable storage would be required to guarantee ordered granting of blocking locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のクライアントには、ロックをブロックのサポートを必要とします。 NFSバージョン4プロトコルは、コールバックメカニズムに依存しているため、以前に拒否されたロックが許可されたときにクライアントに通知することができないではない必要があります。クライアントが継続的にロックをポーリングするしかありません。これは、公平性の問題を提示します。二つの新しいロックタイプは、READWとWRITEWを追加され、クライアントがブロッキングロックを要求しているサーバーに示すために使用されています。サーバーは、保留中のブロッキング・ロックの順序付きリストを維持する必要があります。矛盾するロックが解除されると、サーバーは再要求するロックへの最初の待機しているクライアントのリース期間を待つことがあります。リース期間が満了した後、次の待機中のクライアント要求は、ロックを許可されています。クライアントは、タイムリーにロックを取得する可能性があることを十分に小さい間隔でポーリングするように要求されています。サーバーは、正しい動作を公平性を高めるために使用されていないようブロックされたロックを保留中のリストを維持するために必要とされていません。そのためクラッシュ回復の順不同の性質上、安定したストレージにロック状態の記憶がロックをブロックする命じ付与を保証するために必要とされるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may also note the lock types and delay returning denial of the request to allow extra time for a conflicting lock to be released, allowing a successful return. In this way, clients can avoid the burden of needlessly frequent polling for blocking locks. The server should take care in the length of delay in the event the client retransmits the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはまた、ロックの種類に注意し、成功したリターンをできるように、リリースされる競合ロックのための余分な時間を与えるために、要求の拒否を返す遅れることがあります。このように、クライアントがロックを阻止するための不頻繁にポーリングの負担を回避することができます。サーバは、クライアントが要求を再送信する場合に、遅延の長さに世話をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. Lease Renewal
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5。リースの更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of a lease is to allow a server to remove stale locks that are held by a client that has crashed or is otherwise unreachable. It is not a mechanism for cache consistency and lease renewals may not be denied if the lease interval has not expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リースの目的は、サーバがクラッシュしたか、そうでなければ到達できないいるクライアントによって保持されている古いロックを削除できるようにすることです。リース期間が満了していない場合は拒否されないことがキャッシュの一貫性とリース更新のためのメカニズムではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following events cause implicit renewal of all of the leases for a given client (i.e., all those sharing a given clientid). Each of these is a positive indication that the client is still active and that the associated state held at the server, for the client, is still valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のイベントは、指定されたクライアントのリースのすべての暗黙の更新を引き起こす（すなわち、与えられたclientidを共有するすべてのものを）。これらのそれぞれは、クライアントがまだアクティブであると、サーバで開催された関連する状態は、クライアントのために、まだ有効であることを陽性表示です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An OPEN with a valid clientid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有効なのclientIdを持つOPEN O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any operation made with a valid stateid (CLOSE, DELEGPURGE, DELEGRETURN, LOCK, LOCKU, OPEN, OPEN_CONFIRM, OPEN_DOWNGRADE, READ, RENEW, SETATTR, WRITE). This does not include the special stateids of all bits 0 or all bits 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O任意の操作が有効のstateid（CLOSE、DELEGPURGE、DELEGRETURN、LOCK、LOCKU、OPEN、オープン_CONFIRM、OPEN_DOWNGRADE、READ、RENEW、SETATTR、WRITE）で作られました。これは、すべてのビット0または全てのビット1の特別のstateidsが含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that if the client had restarted or rebooted, the client would not be making these requests without issuing the SETCLIENTID/SETCLIENTID_CONFIRM sequence. The use of the SETCLIENTID/SETCLIENTID_CONFIRM sequence (one that changes the client verifier) notifies the server to drop the locking state associated with the client. SETCLIENTID/SETCLIENTID_CONFIRM never renews a lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントを再起動または再起動した場合、クライアントはSETCLIENTID / SETCLIENTID_CONFIRMシーケンスを発行することなく、これらの要求を行うことはないことに注意してください。 SETCLIENTID / SETCLIENTID_CONFIRM配列（クライアント検証を変更するもの）の使用は、クライアントに関連付けられたロック状態をドロップするサーバに通知します。 SETCLIENTID / SETCLIENTID_CONFIRMは、リースを更新することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the server has rebooted, the stateids (NFS4ERR_STALE_STATEID error) or the clientid (NFS4ERR_STALE_CLIENTID error) will not be valid hence preventing spurious renewals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーを再起動している場合、のstateids（NFS4ERR_STALE_STATEIDエラー）またはのclientid（NFS4ERR_STALE_CLIENTIDエラー）スプリアス更新を妨げるので、有効になりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This approach allows for low overhead lease renewal which scales well. In the typical case no extra RPC calls are required for lease renewal and in the worst case one RPC is required every lease period (i.e., a RENEW operation). The number of locks held by the client is not a factor since all state for the client is involved with the lease renewal action.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアプローチはうまくスケールの低オーバーヘッドのリース更新が可能になります。典型的な場合には余分なRPCコールはリース更新のために必要とされず、最悪の場合の1つのRPC毎リース期間（すなわち、動作をRENEW）が必要です。クライアントの状態はすべてのリース更新アクションに関与しているため、クライアントが保持しているロックの数倍ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since all operations that create a new lease also renew existing leases, the server must maintain a common lease expiration time for all valid leases for a given client. This lease time can then be easily updated upon implicit lease renewal actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、新しいリースを作成するすべての操作は、既存のリースを更新するので、サーバが特定のクライアントのための有効なすべてのリースのための共通のリース満了時間を維持しなければなりません。このリース時間は、簡単に暗黙のリース更新アクション時に更新することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. Crash Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6。クラッシュ回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The important requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts or reboots. All READ and WRITE operations that may have been queued within the client or network buffers must wait until the client has successfully recovered the locks protecting the READ and WRITE operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラッシュリカバリでの重要な要件は、他に障害が発生したときにクライアントとサーバーの両方が知っていることです。さらに、クライアントがサーバの再起動または再起動してもデータの一貫性のあるビューを見ることが必要です。クライアントが正常に読み取りおよび書き込み操作を保護するロックを回復するまで、クライアントまたはネットワークバッファ内キューに登録されている可能性があり、すべての読み取りおよび書き込み操作が待機する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.1. Client Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.1。クライアントの障害と復旧
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that a client fails, the server may recover the client&#39;s locks when the associated leases have expired. Conflicting locks from another client may only be granted after this lease expiration. If the client is able to restart or reinitialize within the lease period the client may be forced to wait the remainder of the lease period before obtaining new locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連するリースが期限切れになったときに、クライアントに障害が発生した場合には、サーバはクライアントのロックを回復することができます。別のクライアントから競合するロックにのみ、このリース満了後に付与することができます。クライアントは、リース期間内に再起動するか、再初期化することが可能である場合、クライアントは新しいロックを取得する前に、リース期間の残りを待つことを余儀なくされることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To minimize client delay upon restart, lock requests are associated with an instance of the client by a client supplied verifier. This verifier is part of the initial SETCLIENTID call made by the client. The server returns a clientid as a result of the SETCLIENTID operation. The client then confirms the use of the clientid with SETCLIENTID_CONFIRM. The clientid in combination with an opaque owner field is then used by the client to identify the lock owner for OPEN. This chain of associations is then used to identify all locks for a particular client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再起動時にクライアントの遅延を最小限に抑えるために、ロック要求は、クライアント供給検証することにより、クライアントのインスタンスに関連付けられています。この検証では、クライアントによって行われた最初のSETCLIENTID呼び出しの一部です。サーバーは、SETCLIENTID操作の結果としてのClientIDを返します。次に、クライアントは、SETCLIENTID_CONFIRMとのClientIDを使用することを確認しました。不透明な所有者フィールドとの組み合わせでのClientIDは、OPENのためのロック所有者を識別するために、クライアントによって使用されます。団体のこのチェーンは、特定のクライアントのすべてのロックを識別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the verifier will be changed by the client upon each initialization, the server can compare a new verifier to the verifier associated with currently held locks and determine that they do not match. This signifies the client&#39;s new instantiation and subsequent loss of locking state. As a result, the server is free to release all locks held which are associated with the old clientid which was derived from the old verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
検証は、各初期化時にクライアントによって変更されますので、サーバーは現在保持しているロックに関連した検証者に新しい検証を比較し、一致していないと判断することができます。これは、クライアントの新しいインスタンス化し、ロック状態のその後の損失を意味します。その結果、サーバは古い検証から得られた古いのClientIDに関連付けられて保持されているすべてのロックを解放して自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the verifier must have the same uniqueness properties of the verifier for the COMMIT operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
検証は、COMMIT操作のための検証の同じ一意性の性質を持っている必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.2. Server Failure and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.2。サーバーの障害と復旧
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server loses locking state (usually as a result of a restart or reboot), it must allow clients time to discover this fact and re-establish the lost locking state. The client must be able to re-establish the locking state without having the server deny valid requests because the server has granted conflicting access to another client. Likewise, if there is the possibility that clients have not yet re-established their locking state for a file, the server must disallow READ and WRITE operations for that file. The duration of this recovery period is equal to the duration of the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが（通常は再起動または再起動の結果として）状態をロック失った場合、それはクライアントの時間がこの事実を発見し、失われたロック状態を再確立することを許可する必要があります。クライアントは、サーバーが他のクライアントへのアクセスが競合付与しているため、サーバーは有効な要求を拒否せずにロック状態を再確立することができなければなりません。クライアントがまだファイルのために彼らのロック状態を再確立していない可能性がある場合同様に、サーバはREADを禁止し、そのファイルの操作を記述する必要があります。この回復期間の長さは、リース期間の長さに等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client can determine that server failure (and thus loss of locking state) has occurred, when it receives one of two errors. The NFS4ERR_STALE_STATEID error indicates a stateid invalidated by a reboot or restart. The NFS4ERR_STALE_CLIENTID error indicates a clientid invalidated by reboot or restart. When either of these are received, the client must establish a new clientid (See the section &#34;Client ID&#34;) and re-establish the locking state as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、それが2つのエラーのいずれかを受信した場合、そのサーバの障害（及び状態をロックする、したがって損失）が発生したかを決定することができます。 NFS4ERR_STALE_STATEIDエラーがリブートまたは再起動によって無効たstateidを示しています。 NFS4ERR_STALE_CLIENTIDエラーがリブートまたは再起動によって無効化のClientIDを示しています。これらのいずれかを受信したときに以下に説明するように、クライアントは新しいのclientid（セクション「クライアントID」を参照してください）と再確立ロック状態を確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The period of special handling of locking and READs and WRITEs, equal in duration to the lease period, is referred to as the &#34;grace period&#34;. During the grace period, clients recover locks and the associated state by reclaim-type locking requests (i.e., LOCK requests with reclaim set to true and OPEN operations with a claim type of CLAIM_PREVIOUS). During the grace period, the server must reject READ and WRITE operations and non-reclaim locking requests (i.e., other LOCK and OPEN operations) with an error of NFS4ERR_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リース期間の持続時間が等しいロックおよび読み取りおよび書き込みの特別な処理の期間は、「猶予期間」と呼びます。猶予期間中、クライアントは再利用型のロック要求によってロックと関連した状態を回復（すなわち、CLAIM_PREVIOUSのクレームタイプで真とOPEN操作に設定され再利用とロック要求）。猶予期間中、サーバはNFS4ERR_GRACEのエラーで読み取りおよび書き込み操作と非再利用ロック要求（すなわち、他のLOCKとOPEN操作）を拒否しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server can reliably determine that granting a non-reclaim request will not conflict with reclamation of locks by other clients, the NFS4ERR_GRACE error does not have to be returned and the non-reclaim client request can be serviced. For the server to be able to service READ and WRITE operations during the grace period, it must again be able to guarantee that no possible conflict could arise between an impending reclaim locking request and the READ or WRITE operation. If the server is unable to offer that guarantee, the NFS4ERR_GRACE error must be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが確実に非再利用要求を許可すると、他のクライアントによるロックの再生と競合しないだろうと判断できる場合は、NFS4ERR_GRACEエラーが返されると、非再利用のクライアント要求をサービスすることができていません。サーバが猶予期間中に読み取りおよび書き込み操作にサービスを提供できるようにするには、再び何の可能性競合が要求およびREADまたはWRITE操作をロックする差し迫った再利用の間で発生することができなかったことを保証することができなければなりません。サーバがその保証を提供することができない場合は、NFS4ERR_GRACEエラーがクライアントに返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a server to provide simple, valid handling during the grace period, the easiest method is to simply reject all non-reclaim locking requests and READ and WRITE operations by returning the NFS4ERR_GRACE error. However, a server may keep information about granted locks in stable storage. With this information, the server could determine if a regular lock or READ or WRITE operation can be safely processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが猶予期間中に、単純な、有効な処理を提供するために、最も簡単な方法は、単純にNFS4ERR_GRACEエラーを返すことによって、要求とREADとWRITE操作をロックするすべての非再利用を拒否することです。ただし、サーバーは安定したストレージに付与されたロックに関する情報を保持することができます。通常のロックまたはREADまたはWRITE操作を安全に処理できる場合は、この情報を使用して、サーバが決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if a count of locks on a given file is available in stable storage, the server can track reclaimed locks for the file and when all reclaims have been processed, non-reclaim locking requests may be processed. This way the server can ensure that non-reclaim locking requests will not conflict with potential reclaim requests. With respect to I/O requests, if the server is able to determine that there are no outstanding reclaim requests for a file by information from stable storage or another similar mechanism, the processing of I/O requests could proceed normally for the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、指定したファイルのロックのカウントが安定したストレージに利用可能な場合、サーバーは、ファイルのロックを埋め立て追跡することができ、すべてを再要求が処理されたとき、非再利用ロック要求を処理することができます。この方法では、サーバーは、非再利用ロック要求は、潜在的な再利用の要求と競合しないことを確実にすることができます。 I / O要求に対して、サーバが安定したストレージまたは他の同様の機構からの情報により、ファイルに対する未処理の再利用の要求が存在しないことを決定することができるならば、I / O要求の処理は、ファイルを正常に進行できました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To reiterate, for a server that allows non-reclaim lock and I/O requests to be processed during the grace period, it MUST determine that no lock subsequently reclaimed will be rejected and that no lock subsequently reclaimed would have prevented any I/O operation processed during the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
猶予期間中に処理するために、非再利用ロックおよびI / O要求を可能にするサーバに対して、繰り返しに、それはその後埋め立て何のロックが拒否されないことを決定する必要があり、その後、埋め立て何のロックは任意のI / O操作を妨げないだろうということ猶予期間中に処理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients should be prepared for the return of NFS4ERR_GRACE errors for non-reclaim lock and I/O requests. In this case the client should employ a retry mechanism for the request. A delay (on the order of several seconds) between retries should be used to avoid overwhelming the server. Further discussion of the general issue is included in [Floyd]. The client must account for the server that is able to perform I/O and non-reclaim locking requests within the grace period as well as those that can not do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、非再利用のためのロックNFS4ERR_GRACEエラーのリターンのために準備し、I ​​/ O要求されなければなりません。この場合、クライアントは、要求の再試行メカニズムを採用する必要があります。再試行の間（数秒程度）の遅延は、サーバーを圧倒回避するために使用する必要があります。一般的な問題のさらなる議論は[フロイド]に含まれています。クライアントがそうすることができないものだけでなく、猶予期間内にI / Oと非再利用ロック要求を行うことが可能であるサーバーを考慮に入れなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reclaim-type locking request outside the server&#39;s grace period can only succeed if the server can guarantee that no conflicting lock or I/O request has been granted since reboot or restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが競合するロックまたはI / O要求を再起動や再起動してから付与されていないことを保証することができた場合、サーバーの猶予期間外の再利用型のロック要求にのみ成功することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server may, upon restart, establish a new value for the lease period. Therefore, clients should, once a new clientid is established, refetch the lease_time attribute and use it as the basis for lease renewal for the lease associated with that server. However, the server must establish, for this restart event, a grace period at least as long as the lease period for the previous server instantiation. This allows the client state obtained during the previous server instance to be reliably re-established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、再起動時に、リース期間のための新しい値を確立することができます。新しいのClientIDが確立されるため、クライアントは、lease_time属性を再フェッチし、そのサーバーに関連付けられているリースのリース更新のための基礎としてそれを使用する必要があります。ただし、サーバはこの再起動イベント、猶予期間、少なくとも限り、以前のサーバインスタンス化のためのリース期間のために、確立する必要があります。これは、以前のサーバインスタンスの間に取得したクライアントの状態が確実に再確立することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.3. Network Partitions and Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6.3。ネットワークパーティションと回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the duration of a network partition is greater than the lease period provided by the server, the server will have not received a lease renewal from the client. If this occurs, the server may free all locks held for the client. As a result, all stateids held by the client will become invalid or stale. Once the client is able to reach the server after such a network partition, all I/O submitted by the client with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once this error is received, the client will suitably notify the application that held the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションの期間は、サーバーが提供するリース期間よりも大きい場合、サーバはクライアントからのリースの更新を受け取っていないだろう。この問題が発生した場合、サーバはクライアントのために開催されたすべてのロックを解放することがあります。その結果、クライアントが保持しているすべてのstateidsが無効または古くなります。クライアントは、そのようなネットワークパーティションの後にサーバーにアクセスできるようになると、すべてのIエラーNFS4ERR_EXPIREDを返すサーバーで失敗します今無効のstateidsでクライアントによって提出/ O。このエラーが受信されると、クライアントは、適切にロックを保持するアプリケーションに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a courtesy to the client or as an optimization, the server may continue to hold locks on behalf of a client for which recent communication has extended beyond the lease period. If the server receives a lock or I/O request that conflicts with one of these courtesy locks, the server must free the courtesy lock and grant the new request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントへの礼儀として、または最適化として、サーバは、最近の通信は、リース期間を超えて延長していたために、クライアントに代わってロックを保持し続けることができます。サーバはこれらの礼儀ロックの一つと競合するロックまたはI / O要求を受信した場合、サーバは礼儀ロックを解放し、新しい要求を付与する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition is combined with a server reboot, there are edge conditions that place requirements on the server in order to avoid silent data corruption following the server reboot. Two of these edge conditions are known, and are discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションがサーバの再起動と組み合わせると、サーバーの再起動、次のサイレントデータ破損を避けるために、場所、サーバー上の要件をエッジ条件があります。これらのエッジ条件の二つが知られており、以下に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first edge condition has the following scenario:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のエッジ条件は、次のシナリオがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Client A acquires a lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1.クライアントAは、ロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Client A and server experience mutual network partition, such that client A is unable to renew its lease.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2.クライアントAとサーバの経験の相互ネットワークパーティション、クライアントAは、そのリースを更新することができないようになっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. Client A&#39;s lease expires, so server releases lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3.クライアントAのリースが期限切れになるので、サーバのリリースがロックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. Client B acquires a lock that would have conflicted with that of Client A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4.クライアントBは、クライアントAのそれと競合しているだろうロックを取得します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5. Client B releases the lock
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5.クライアントBは、ロックを解除します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
6. Server reboots
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
6.サーバーのリブート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
7. Network partition between client A and server heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントAとサーバ間の治癒7.ネットワークパーティション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
8. Client A issues a RENEW operation, and gets back a NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
8.クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
9. Client A reclaims its lock within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
9.クライアントAは、サーバーの猶予期間内にそのロックを再利用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, at the final step, the server has erroneously granted client A&#39;s lock reclaim. If client B modified the object the lock was protecting, client A will experience object corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このように、最後のステップでは、サーバが誤ってクライアントAのロック再利用を許可されています。クライアントBは、ロックが保護されたオブジェクトを変更した場合、クライアントAは、オブジェクトの破損が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second known edge condition follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第2の既知のエッジ条件は次のとおり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Client A acquires a lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1.クライアントAは、ロックを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2.サーバーが再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. Client A and server experience mutual network partition, such that client A is unable to reclaim its lock within the grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3.クライアントAとサーバの経験の相互ネットワークパーティション、クライアントAは、猶予期間内にそのロックを再利用することができないようになっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. Server&#39;s reclaim grace period ends. Client A has no locks recorded on server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4.サーバーの再利用の猶予期間が終了します。クライアントAは、サーバに記録されて何のロックを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5. Client B acquires a lock that would have conflicted with that of Client A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
5.クライアントBは、クライアントAのそれと競合しているだろうロックを取得します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
6. Client B releases the lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
6.クライアントBは、ロックを解除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
7. Server reboots a second time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
7.サーバーを2回再起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
8. Network partition between client A and server heals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントAとサーバ間の治癒8.ネットワークパーティション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
9. Client A issues a RENEW operation, and gets back a NFS4ERR_STALE_CLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
9.クライアントAはRENEW操作を発行し、NFS4ERR_STALE_CLIENTIDを取り戻します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
10. Client A reclaims its lock within the server&#39;s grace period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
10.クライアントAは、サーバーの猶予期間内にそのロックを再利用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with the first edge condition, the final step of the scenario of the second edge condition has the server erroneously granting client A&#39;s lock reclaim.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のエッジ条件と同様に、第2のエッジ条件のシナリオの最終ステップは、誤ってクライアントAのロックの再利用を許可するサーバを有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Solving the first and second edge conditions requires that the server either assume after it reboots that edge condition occurs, and thus return NFS4ERR_NO_GRACE for all reclaim attempts, or that the server record some information stable storage. The amount of information the server records in stable storage is in inverse proportion to how harsh the server wants to be whenever the edge conditions occur. The server that is completely tolerant of all edge conditions will record in stable storage every lock that is acquired, removing the lock record from stable storage only when the lock is unlocked by the client and the lock&#39;s lockowner advances the sequence number such that the lock release is not the last stateful event for the lockowner&#39;s sequence. For the two aforementioned edge conditions, the harshest a server can be, and still support a grace period for reclaims, requires that the server record in stable storage information some minimal information. For example, a server implementation could, for each client, save in stable storage a record containing:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第一と第二のエッジ条件を解決するサーバがエッジ状態が発生するリブート後に想定し、したがってすべての試みを再利用するためのNFS4ERR_NO_GRACEを返す、またはサーバレコードそのいくつかの情報安定貯蔵のいずれかことを必要とします。安定したストレージの情報量サーバーレコードは、サーバーは、エッジ状態が発生するたびになりたいどのように厳しいに反比例します。すべてのエッジ条件の完全耐性のあるサーバーは、ロックがクライアントによってロックが解除され、ロックのlockownerは、このようなロック解除そのシーケンス番号を進める場合にのみ、安定したストレージからロック・レコードを削除し、安定したストレージに取得されたすべてのロックを記録しますlockownerのシーケンスのための最後のステートフルなイベントではありません。前述の2つのエッジ条件について、最も厳しいサーバがあること、そしてまだ再要求のための猶予期間をサポートすることができ、安定したストレージ情報いくつかの最小限の情報では、そのサーバレコードが必要です。例えば、サーバの実装は、各クライアントのために、安定したストレージに含むレコードを保存できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the client&#39;s id string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのID文字列O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a boolean that indicates if the client&#39;s lease expired or if there was administrative intervention (see the section, Server Revocation of Locks) to revoke a record lock, share reservation, or delegation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントのリース期限が切れたり、管理者の介入があった場合（ロックのセクション、サーバーの失効を参照）かどうかを示すブール値は、レコードロック、共有予約、または委任を取り消します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a timestamp that is updated the first time after a server boot or reboot the client acquires record locking, share reservation, or delegation state on the server. The timestamp need not be updated on subsequent lock requests until the server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバーの起動後、初めての更新またはクライアントを再起動されるタイムスタンプは、サーバ上のレコードロック、共有予約、または委任状態を取得します。タイムスタンプは、サーバーが再起動するまで、後続のロック要求で更新する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server implementation would also record in the stable storage the timestamps from the two most recent server reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの実装も安定したストレージに最新の2回のサーバーが再起動からのタイムスタンプを記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the above record keeping, for the first edge condition, after the server reboots, the record that client A&#39;s lease expired means that another client could have acquired a conflicting record lock, share reservation, or delegation. Hence the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のエッジ条件のために、上記の記録保持を仮定すると、サーバーの再起動後、クライアントAのリースが期限切れという記録は、別のクライアントが競合レコードロック、共有予約、または委任を取得していることを意味します。したがって、サーバがエラーNFS4ERR_NO_GRACEとクライアントAからの再利用を拒否しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the second edge condition, after the server reboots for a second time, the record that the client had an unexpired record lock, share reservation, or delegation established before the server&#39;s previous incarnation means that the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第2のエッジ状態の場合、二回目のためにサーバの再起動後、クライアントは、期限が切れていないレコードロック、共有予約、または委任を持っていたという記録は、サーバーの前の化身はサーバーのクライアントAからの再利用を拒否しなければならないことを意味する前に設立しますエラーNFS4ERR_NO_GRACE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the level and approach to record keeping, the server MUST implement one of the following strategies (which apply to reclaims of share reservations, record locks, and delegations):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
かかわらず、記録保持のレベルやアプローチの、サーバは、（株予約、レコードロック、および代表団の再利用に適用されます）次のいずれかを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Reject all reclaims with NFS4ERR_NO_GRACE. This is superharsh, but necessary if the server does not want to record lock state in stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. NFS4ERR_NO_GRACEですべてを再要求を拒否します。サーバが安定したストレージにロック状態を記録したくない場合、これはsuperharshが、必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Record sufficient state in stable storage such that all known edge conditions involving server reboot, including the two noted in this section, are detected. False positives are acceptable. Note that at this time, it is not known if there are other edge conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このセクションで述べた2を含むサーバの再起動を伴うすべての既知のエッジ条件が検出されるような安定したストレージに前記記録十分な状態。偽陽性が許容されています。他のエッジ条件がある場合は、この時点で、それは知られていないことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
In the event, after a server reboot, the server determines that there is unrecoverable damage or corruption to the the stable storage, then for all clients and/or locks affected, the server MUST return NFS4ERR_NO_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
イベントでは、サーバーの再起動後に、サーバーが安定したストレージに回復不能な損傷や破損があると判断し、その後、すべてのクライアントおよび/またはロックの影響を受けたため、サーバーはNFS4ERR_NO_GRACEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A mandate for the client&#39;s handling of the NFS4ERR_NO_GRACE error is outside the scope of this specification, since the strategies for such handling are very dependent on the client&#39;s operating environment. However, one potential approach is described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのような取扱いのための戦略は、クライアントの動作環境に非常に依存しているため、NFS4ERR_NO_GRACEエラーのクライアントの処理のための任務は、この仕様の範囲外です。しかしながら、潜在的なアプローチは、以下に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client receives NFS4ERR_NO_GRACE, it could examine the change attribute of the objects the client is trying to reclaim state for, and use that to determine whether to re-establish the state via normal OPEN or LOCK requests. This is acceptable provided the client&#39;s operating environment allows it. In otherwords, the client implementor is advised to document for his users the behavior. The client could also inform the application that its record lock or share reservations (whether they were delegated or not) have been lost, such as via a UNIX signal, a GUI pop-up window, etc. See the section, &#34;Data Caching and Revocation&#34; for a discussion of what the client should do for dealing with unreclaimed delegations on client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_NO_GRACEを受信すると、それは、クライアントがために状態を再利用しようとしているオブジェクトの変化属性を調べ、通常のOPENまたはLOCKリクエストを経由して状態を再確立するかどうかを決定するためにそれを使用することができます。これは、クライアントの動作環境がそれを可能に提供可能です。換言すれば、クライアントの実装者は、彼のユーザーのための行動を文書化することをお勧めします。クライアントはまた、セクション、「データキャッシングを参照してくださいそのレコードロックまたは共有の予約が（彼らは委任されたかどうか）などUNIX信号、GUIポップアップウィンドウを介して、失われたアプリケーションを通知する可能性があり、クライアントは、クライアントの状態にunreclaimed代表団に対処するために何をすべきかの議論のための失効」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For further discussion of revocation of locks see the section &#34;Server Revocation of Locks&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックの取消しのさらなる議論については、「ロックのサーバーの失効」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. Recovery from a Lock Request Timeout or Abort
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7。ロック要求のタイムアウトや中止からの回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event a lock request times out, a client may decide to not retry the request. The client may also abort the request when the process for which it was issued is terminated (e.g., in UNIX due to a signal). It is possible though that the server received the request and acted upon it. This would change the state on the server without the client being aware of the change. It is paramount that the client re-synchronize state with server before it attempts any other operation that takes a seqid and/or a stateid with the same lock_owner. This is straightforward to do without a special re-synchronize operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック要求がタイムアウトする場合には、クライアントが要求を再試行しないことを決定することができます。それが発行されたプロセスが終了すると、クライアントは、（原因信号にUNIXで、例えば）要求を中止することができます。サーバーが要求を受信し、それに作用かかわらことも可能です。これは、クライアントが変更を意識することなく、サーバー上の状態を変更することになります。 SEQIDおよび/または同じlock_ownerとのstateidをとり、他の操作を試みる前に、クライアントがサーバーとの状態を再同期させることを最優先事項です。これは、特別な再同期操作なしで行うことは簡単です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the server maintains the last lock request and response received on the lock_owner, for each lock_owner, the client should cache the last lock request it sent such that the lock request did not receive a response. From this, the next time the client does a lock operation for the lock_owner, it can send the cached request, if there is one, and if the request was one that established state (e.g., a LOCK or OPEN operation), the server will return the cached result or if never saw the request, perform it. The client can follow up with a request to remove the state (e.g., a LOCKU or CLOSE operation). With this approach, the sequencing and stateid information on the client and server for the given lock_owner will re-synchronize and in turn the lock state will re-synchronize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバがlock_ownerで受信した最後のロック要求と応答を維持するので、各lock_ownerのために、クライアントは、それがロック要求が応答を受信しないように送られた最後のロック要求をキャッシュする必要があります。このことから1が存在する場合、クライアントはlock_ownerのためのロック操作を行い、次回は、それは、キャッシュされたリクエストを送信することができ、かつ要求が状態を確立1（例えば、LOCKまたはOPEN操作）した場合、サーバは意志キャッシュされた結果を返すか、リクエストを見たことがない場合は、それを実行します。クライアントが状態を削除するための要求（例えば、LOCKUまたはCLOSE操作）をフォローアップすることができます。このアプローチでは、与えられたlock_ownerため、クライアントとサーバー上のシーケンシングとのstateid情報は再同期と順番になりますロック状態は、同期を再します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. Server Revocation of Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8。ロックのサーバーの失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At any point, the server can revoke locks held by a client and the client must be prepared for this event. When the client detects that its locks have been or may have been revoked, the client is responsible for validating the state information between itself and the server. Validating locking state for the client means that it must verify or reclaim state for each lock currently held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意の時点で、サーバは、クライアントが保持しているロックを取り消すことができますし、クライアントは、このイベントのために準備しなければなりません。クライアントは、そのロックがされているか、取り消されたことを検出すると、クライアントは、それ自体とサーバの間で状態情報を検証する責任があります。クライアントのロック状態を検証することは、現在開催され、各ロックの状態を確認したり、再利用しなければならないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first instance of lock revocation is upon server reboot or re-initialization. In this instance the client will receive an error (NFS4ERR_STALE_STATEID or NFS4ERR_STALE_CLIENTID) and the client will proceed with normal crash recovery as described in the previous section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック失効の最初のインスタンスは、サーバの再起動または再初期化時です。この場合、クライアントは、エラー（NFS4ERR_STALE_STATEID又はNFS4ERR_STALE_CLIENTID）を受信すると、前のセクションで説明したように、クライアントは、通常のクラッシュ・リカバリを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second lock revocation event is the inability to renew the lease before expiration. While this is considered a rare or unusual event, the client must be prepared to recover. Both the server and client will be able to detect the failure to renew the lease and are capable of recovering without data corruption. For the server, it tracks the last renewal event serviced for the client and knows when the lease will expire. Similarly, the client must track operations which will renew the lease period. Using the time that each such request was sent and the time that the corresponding reply was received, the client should bound the time that the corresponding renewal could have occurred on the server and thus determine if it is possible that a lease period expiration could have occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第2ロック失効イベントが満了前にリースを更新することができないことです。これは稀なまたは異常なイベントと見なされますが、クライアントが回復する準備をしなければなりません。サーバとクライアントの両方がリースを更新し、データの破損せずに回復することができるに失敗したことを検出することができます。サーバーの場合は、クライアントのためにサービスを最後に更新イベントを追跡し、リースが期限切れになる知っています。同様に、クライアントは、リース期間を更新されます操作を追跡する必要があります。それぞれのそのようなリクエストが送信された時刻と対応する応答が受信された時刻を使用して、クライアントは、対応する更新がサーバー上で発生したので、リース期間の満了が発生している可能性があるかどうかを判断していることができると時間をバインドする必要があり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third lock revocation event can occur as a result of administrative intervention within the lease period. While this is considered a rare event, it is possible that the server&#39;s administrator has decided to release or revoke a particular lock held by the client. As a result of revocation, the client will receive an error of NFS4ERR_ADMIN_REVOKED. In this instance the client may assume that only the lock_owner&#39;s locks have been lost. The client notifies the lock holder appropriately. The client may not assume the lease period has been renewed as a result of failed operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第三のロック失効イベントがリース期間内に管理者の介入の結果として起こり得ます。これはまれなイベントと見なされているが、サーバーの管理者がクライアントによって保持された特定のロックを解除するか、取り消すことを決めている可能性があります。取り消しの結果、クライアントはNFS4ERR_ADMIN_REVOKEDのエラーを受け取ることになります。この例では、クライアントはlock_ownerのロックが失われていると仮定してよいです。クライアントは、適切にロックホルダを通知します。リース期間を想定していないことがあり、クライアントは、失敗した操作の結果としてリニューアルしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client determines the lease period may have expired, the client must mark all locks held for the associated lease as &#34;unvalidated&#34;. This means the client has been unable to re-establish or confirm the appropriate lock state with the server. As described in the previous section on crash recovery, there are scenarios in which the server may grant conflicting locks after the lease period has expired for a client. When it is possible that the lease period has expired, the client must validate each lock currently held to ensure that a conflicting lock has not been granted. The client may accomplish this task by issuing an I/O request, either a pending I/O or a zero-length read, specifying the stateid associated with the lock in question. If the response to the request is success, the client has validated all of the locks governed by that stateid and re-established the appropriate state between itself and the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、リース期間が満了したかもしれないと判断した場合、クライアントは「未検証」として関連付けられたリースのために開催されたすべてのロックをマークする必要があります。これは、クライアントがサーバーとの適切なロック状態を再確立または確認することができなかったことを意味します。クラッシュリカバリの前のセクションで説明したように、リース期間は、クライアントのために有効期限が切れた後に、サーバーが競合するロックを与える可能性のあるシナリオがあります。それは、リース期間が終了している可能性がある場合は、クライアントは各ロックを検証する必要があり、現在、競合するロックが付与されていないことを確認するために開催されました。クライアントは、当該ロックに関連付けられているのstateidを指定し、I / O要求、保留中のI / Oのいずれか、または長さゼロのリードを発行することにより、このタスクを達成することができます。要求に対する応答が成功の場合、クライアントはそののstateidに支配し、自分自身とサーバの間の適切な状態を再確立ロックのすべてを検証しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the I/O request is not successful, then one or more of the locks associated with the stateid was revoked by the server and the client must notify the owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I / O要求が成功しなかった場合、その後のstateidに関連付けられているロックの一つ以上は、サーバとクライアントによって取り消された所有者に通知しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.9. Share Reservations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.9。シェア予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A share reservation is a mechanism to control access to a file. It is a separate and independent mechanism from record locking. When a client opens a file, it issues an OPEN operation to the server specifying the type of access required (READ, WRITE, or BOTH) and the type of access to deny others (deny NONE, READ, WRITE, or BOTH). If the OPEN fails the client will fail the application&#39;s open request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シェア予約は、ファイルへのアクセスを制御するメカニズムです。これは、レコードロックとは別の独立した機構です。クライアントがファイルを開くと、それは（NONEは、読み取り、書き込みしない、拒否、またはBOTH）他者を否定するために必要なアクセスの種類（読み取り、書き込み、またはその両方）とアクセスの種類を指定してサーバにOPEN操作を発行します。 OPENが失敗した場合、クライアントは、アプリケーションのオープン要求を失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pseudo-code definition of the semantics:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セマンティクスの擬似コードの定義：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
if (request.access == 0) return (NFS4ERR_INVAL)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もし（request.access == 0）リターン（NFS4ERR_INVAL）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
else if ((request.access &amp; file_state.deny)) || (request.deny &amp; file_state.access)) return (NFS4ERR_DENIED)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外の場合（（request.access＆file_state.deny））|| （request.deny＆file_state.access））リターン（NFS4ERR_DENIED）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This checking of share reservations on OPEN is done with no exception for an existing OPEN for the same open_owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN上の共有の予約のこのチェックは、同じopen_ownerのために既存のOPENのために例外なく行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constants used for the OPEN and OPEN_DOWNGRADE operations for the access and deny fields are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにアクセスするためにOPENとOPEN_DOWNGRADE操作に使用してフィールドを否定する定数は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10. OPEN/CLOSE Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10。 OPEN / CLOSE操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide correct share semantics, a client MUST use the OPEN operation to obtain the initial filehandle and indicate the desired access and what if any access to deny. Even if the client intends to use a stateid of all 0&#39;s or all 1&#39;s, it must still obtain the filehandle for the regular file with the OPEN operation so the appropriate share semantics can be applied. For clients that do not have a deny mode built into their open programming interfaces, deny equal to NONE should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正しい共有セマンティクスを提供するために、クライアントは、最初のファイルハンドルを取得するためにOPEN操作を使用し、すべてのアクセスを拒否するならば所望のアクセスと何を示さなければなりません。クライアントがすべて0またはすべて1つのののstateidを使用しようとする場合であっても、適切な共有のセマンティクスを適用することができますので、それはまだOPEN操作で通常のファイルのためのファイルハンドルを取得する必要があります。彼らのオープンプログラミングインターフェースに組み込まれて拒否モードを持っていないクライアントの場合、使用されるべきであるNONEに等しい拒否。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation with the CREATE flag, also subsumes the CREATE operation for regular files as used in previous versions of the NFS protocol. This allows a create with a share to be done atomically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATEフラグをOPEN操作は、また、NFSプロトコルの旧バージョンで使用される通常のファイルのCREATE操作を包含する。これはアトミックに行われるシェアで作成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLOSE operation removes all share reservations held by the lock_owner on that file. If record locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE but some servers may not support the CLOSE of a file that still has record locks held. The server MUST return failure, NFS4ERR_LOCKS_HELD, if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作は、そのファイル上のlock_ownerが保有する全ての株式の予約を削除します。レコードロックが保持されている場合、クライアントはCLOSEを発行する前に、すべてのロックを解除しなければなりません。サーバーは、CLOSE上のすべての未解決のロックを解放するかもしれませんが、いくつかのサーバは、まだ開催されたレコードロックを持っているファイルのCLOSEをサポートしていないかもしれません。すべてのロックは、CLOSEの後に存在するならば、サーバーは、障害が発生、NFS4ERR_LOCKS_HELDを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOOKUP operation will return a filehandle without establishing any lock state on the server. Without a valid stateid, the server will assume the client has the least access. For example, a file opened with deny READ/WRITE cannot be accessed using a filehandle obtained through LOOKUP because it would not have a valid stateid (i.e., using a stateid of all bits 0 or all bits 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUP操作は、サーバー上の任意のロック状態を確立することなくファイルハンドルを返します。有効なstateidがなければ、サーバーは、クライアントが少なくともアクセス権を持っていると仮定します。例えば、ファイルは、それが有効なのstateidを持たないため（すなわち、すべてのビット0または全ビット1のstateidを使用して）LOOKUPにより得られたファイルハンドルを使用してアクセスすることができない拒否READ / WRITEで開きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10.1. Close and Retention of State Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10.1。閉じると状態情報の保持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since a CLOSE operation requests deallocation of a stateid, dealing with retransmission of the CLOSE, may pose special difficulties, since the state information, which normally would be used to determine the state of the open file being designated, might be deallocated, resulting in an NFS4ERR_BAD_STATEID error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSE操作はCLOSEの再送を扱うのstateidの割当て解除を要求するので、その結果、割り当て解除されるかもしれない、通常開いているファイルの状態を決定するために使用される状態情報は、指定されるので、特別な問題を提起することができますNFS4ERR_BAD_STATEIDエラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may deal with this problem in a number of ways. To provide the greatest degree assurance that the protocol is being used properly, a server should, rather than deallocate the stateid, mark it as close-pending, and retain the stateid with this status, until later deallocation. In this way, a retransmitted CLOSE can be recognized since the stateid points to state information with this distinctive status, so that it can be handled without error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、いくつかの方法でこの問題に対処することがあります。プロトコルが適切に使用されていることを最大の程度の保証を提供するために、サーバは、のstateidの割り当てを解除するのではなく、それは近く係属マークする必要があり、その後解放されるまで、この状態でのstateidを保持します。このように、再送CLOSEは、それがエラーなしで取り扱うことができるように、この独特の状態との間で情報を述べるのstateidポイント以降に認識することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When adopting this strategy, a server should retain the state information until the earliest of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この戦略を採用する場合、サーバは最古までの状態情報を保持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Another validly sequenced request for the same lockowner, that is not a retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じlockownerためのもう一つの有効にシーケンスされた要求O、それは再送信ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The time that a lockowner is freed by the server due to period with no activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lockownerが原因アクティビティがないとの期間に、サーバによって解放される時、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All locks for the client are freed as a result of a SETCLIENTID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントのためのすべてのロックは、SETCLIENTIDの結果として解放されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers may avoid this complexity, at the cost of less complete protocol error checking, by simply responding NFS4_OK in the event of a CLOSE for a deallocated stateid, on the assumption that this case must be caused by a retransmitted close. When adopting this approach, it is desirable to at least log an error when returning a no-error indication in this situation. If the server maintains a reply-cache mechanism, it can verify the CLOSE is indeed a retransmission and avoid error logging in most cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、単にこのような場合は、再送近いによって引き起こされなければならないことを前提に、割り当て解除のstateidのためのCLOSEの際にNFS4_OKを応答することにより、より少ない完全なプロトコルエラーチェックのコストで、この複雑さを回避することができます。このアプローチを採用する場合には、この状況で無エラー表示を返すときに、少なくともエラーを記録することが望ましいです。サーバーが応答キャッシュ・メカニズムを維持した場合、それはCLOSEが実際に再送信であることを確認し、ほとんどの場合、エラーログを避けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.11. Open Upgrade and Downgrade
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.11。オープンアップグレードおよびダウングレード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an OPEN is done for a file and the lockowner for which the open is being done already has the file open, the result is to upgrade the open file status maintained on the server to include the access and deny bits specified by the new OPEN as well as those for the existing OPEN. The result is that there is one open file, as far as the protocol is concerned, and it includes the union of the access and deny bits for all of the OPEN requests completed. Only a single CLOSE will be done to reset the effects of both OPENs. Note that the client, when issuing the OPEN, may not know that the same file is in fact being opened. The above only applies if both OPENs result in the OPENed object being designated by the same filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENは、ファイルのオープンはまだ行ってファイルを開いているされているためlockownerのために行われた場合、その結果は、新しいOPENで指定されたビットへのアクセスを含めると拒否するようにサーバー上に保持開いているファイルのステータスをアップグレードすることですうまく既存のOPENのものとして。結果は限りプロトコルに関しては、1つの開いているファイルがあることであり、それはアクセスの組合を含んでおり、完成OPENすべての要求のためのビットを否定します。つだけCLOSEが開き、両方の効果をリセットするために行われます。 OPENを発行するとき、クライアントは、同じファイルが実際に開かれていることを知らないかもしれないことに注意してください。両方が同じファイルハンドルによって指定されるオープンされたオブジェクトをもたらす開いた場合、上記にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server chooses to export multiple filehandles corresponding to the same file object and returns different filehandles on two different OPENs of the same file object, the server MUST NOT &#34;OR&#34; together the access and deny bits and coalesce the two open files. Instead the server must maintain separate OPENs with separate stateids and will require separate CLOSEs to free them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、同じファイルオブジェクトに対応する複数のファイルハンドルをエクスポートすることを選択したと同じファイルオブジェクトの二つの異なるのOPENs上の異なるファイルハンドルを返し、サーバーはMUST NOT「OR」一緒にアクセスをしてビットを否定し、2つの開いているファイルを結合する場合。代わりに、サーバは別ののstateidsで別々のOPENsを維持しなければならないし、それらを解放するために別の閉じが必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple open files on the client are merged into a single open file object on the server, the close of one of the open files (on the client) may necessitate change of the access and deny status of the open file on the server. This is because the union of the access and deny bits for the remaining opens may be smaller (i.e., a proper subset) than previously. The OPEN_DOWNGRADE operation is used to make the necessary change and the client should use it to update the server so that share reservation requests by other clients are handled properly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント上の複数の開いているファイルを、サーバー上の単一のオープンファイルオブジェクトにマージされている場合、（クライアント上）開いているファイルの一つの近くには、アクセスの変更を必要とし、サーバー上の開いているファイルの状態を拒否することができます。アクセスの和集合と残りのためのビットを否定するが、以前よりも（すなわち、適切なサブセット）も小さくてもよい開くからです。 OPEN_DOWNGRADE操作が必要な変更を行うために使用され、他のクライアントがその共有の予約要求が適切に処理されているように、クライアントはサーバーを更新するためにそれを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.12. Short and Long Leases
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.12。ショートとロングリース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When determining the time period for the server lease, the usual lease tradeoffs apply. Short leases are good for fast server recovery at a cost of increased RENEW or READ (with zero length) requests. Longer leases are certainly kinder and gentler to servers trying to handle very large numbers of clients. The number of RENEW requests drop in proportion to the lease time. The disadvantages of long leases are slower recovery after server failure (the server must wait for the leases to expire and the grace period to elapse before granting new lock requests) and increased file contention (if client fails to transmit an unlock request then server must wait for lease expiration before granting new locks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのリース期間を決定する際に、通常の賃貸借トレードオフが適用されます。短いリースは（ゼロ長さ）RENEW増加またはREAD要求のコストで高速なサーバー回復のために良いです。長いリースは、クライアントの非常に大きな数字を扱うしようとしているサーバへの確かに親切と穏やかなです。 RENEW要求の数は、リース時間に比例してドロップします。長いリースの欠点は、（有効期限が切れるように、サーバがリースを待たなければなりませんし、新しいロック要求を許可する前に経過する猶予期間）サーバ障害の後に遅い回復と増加したファイルの競合（クライアントがアンロック要求を送信するために失敗した場合、サーバは待機しなければならないですリース満了のために）新しいロックを許可する前に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Long leases are usable if the server is able to store lease state in non-volatile memory. Upon recovery, the server can reconstruct the lease state from its non-volatile memory and continue operation with its clients and therefore long leases would not be an issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、不揮発性メモリにリース状態を記憶することが可能であるならばロングリースが使用可能です。回復時に、サーバーは、その不揮発性メモリからのリース状態を再構築し、問題ではないであろう、そのクライアントので、長いリースでの動作を継続することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.13. Clocks, Propagation Delay, and Calculating Lease Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.13。時計、伝播遅延、および計算リースの有効期限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid the need for synchronized clocks, lease times are granted by the server as a time delta. However, there is a requirement that the client and server clocks do not drift excessively over the duration of the lock. There is also the issue of propagation delay across the network which could easily be several hundred milliseconds as well as the possibility that requests will be lost and need to be retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同期クロックの必要性を回避するには、リース時間は時間デルタとしてサーバによって付与されます。ただし、クライアントとサーバーのクロックがロックの期間にわたって過度にドリフトしていない要件があります。簡単に数百ミリ秒だけでなく、要求が失われ、再送信する必要があります可能性可能性があり、ネットワーク全体の伝播遅延の問題もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To take propagation delay into account, the client should subtract it from lease times (e.g., if the client estimates the one-way propagation delay as 200 msec, then it can assume that the lease is already 200 msec old when it gets it). In addition, it will take another 200 msec to get a response back to the server. So the client must send a lock renewal or write data back to the server 400 msec before the lease would expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アカウントに伝播遅延を取るために、クライアントはリース時間からそれを引く必要があります（それはそれを取得する場合、クライアントは200ミリ秒として一方向の伝搬遅延を推定した場合、例えば、それはリースがすでに200ミリ秒古いであると仮定することができます）。また、それは戻って、サーバへの応答を取得するには、別の200ミリ秒かかります。リースが期限切れになるでしょう前に400ミリ秒だから、クライアントは、ロックの更新を送信しなければならないか、サーバーに戻ってデータを書き込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server&#39;s lease period configuration should take into account the network distance of the clients that will be accessing the server&#39;s resources. It is expected that the lease period will take into account the network propagation delays and other network delay factors for the client population. Since the protocol does not allow for an automatic method to determine an appropriate lease period, the server&#39;s administrator may have to tune the lease period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバのリース期間の設定は、アカウントに、サーバーのリソースにアクセスするクライアントのネットワーク距離を取る必要があります。リース期間は、アカウントにクライアント人口のネットワーク伝播遅延およびその他のネットワーク遅延の要因を取ることが期待されます。プロトコルは、適切なリース期間を決定するための自動方法を許可しないので、サーバーの管理者が同調するように、リース期間を有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14. Migration, Replication and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14。移行、レプリケーションと国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When responsibility for handling a given file system is transferred to a new server (migration) or the client chooses to use an alternate server (e.g., in response to server unresponsiveness) in the context of file system replication, the appropriate handling of state shared between the client and server (i.e., locks, leases, stateids, and clientids) is as described below. The handling differs between migration and replication. For related discussion of file server state and recover of such see the sections under &#34;File Locking and Share Reservations&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のファイルシステムを処理するための責任は、新しいサーバー（マイグレーション）に転送されるか、クライアントは、ファイルシステムレプリケーションのコンテキストで（サーバ不応答に応じて、例えば）代替サーバーを使用することを選択した場合、状態の適切な取り扱いは間で共有しましたクライアントとサーバ（すなわち、ロック、リース、のstateids、とのClientID）は以下のように記述されています。取り扱いは、移行と複製の間で異なっています。ファイルサーバの状態の関連議論について及び「ロックファイルや予約の共有」の下のセクションを参照してくださいなどの回復。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If server replica or a server immigrating a filesystem agrees to, or is expected to, accept opaque values from the client that originated from another server, then it is a wise implementation practice for the servers to encode the &#34;opaque&#34; values in network byte order. This way, servers acting as replicas or immigrating filesystems will be able to parse values like stateids, directory cookies, filehandles, etc. even if their native byte order is different from other servers cooperating in the replication and migration of the filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのレプリカやファイルシステムを移住サーバーがすることに同意し、または、別のサーバーから発信クライアントからの不透明な値を受け入れることが予想される場合、それはサーバがネットワークバイト順で「不透明」の値を符号化するための賢明な実装の練習です。このように、レプリカや移住のファイルシステムとして動作するサーバーは、ネイティブのバイト順序は、ファイルシステムの複製や移行に協力他のサーバーと異なっている場合でもなどのstateids、ディレクトリクッキー、ファイルハンドル、のような値を解析することができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.1. Migration and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.1。移行と国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of migration, the servers involved in the migration of a filesystem SHOULD transfer all server state from the original to the new server. This must be done in a way that is transparent to the client. This state transfer will ease the client&#39;s transition when a filesystem migration occurs. If the servers are successful in transferring all state, the client will continue to use stateids assigned by the original server. Therefore the new server must recognize these stateids as valid. This holds true for the clientid as well. Since responsibility for an entire filesystem is transferred with a migration event, there is no possibility that conflicts will arise on the new server as a result of the transfer of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行の場合には、ファイルシステムの移行に関係するサーバーを新しいサーバーに元からすべてのサーバーの状態を転送する必要があります。これは、クライアントに透過的な方法で行う必要があります。ファイルシステムの移行が発生したときに、この状態転送は、クライアントの移行を容易にします。サーバはすべての状態を転送することに成功している場合、クライアントは元のサーバーによって割り当てられたのstateidsを使用し続けます。したがって、新しいサーバーは有効なものとしてこれらのstateidsを認識しなければなりません。これは、同様のclientidにも当てはまります。ファイルシステム全体に対する責任が移行イベントで転送されているので、競合はロックの転送の結果として、新しいサーバ上で生じてしまうおそれはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As part of the transfer of information between servers, leases would be transferred as well. The leases being transferred to the new server will typically have a different expiration time from those for the same client, previously on the old server. To maintain the property that all leases on a given server for a given client expire at the same time, the server should advance the expiration time to the later of the leases being transferred or the leases already present. This allows the client to maintain lease renewal of both classes without special effort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバ間の情報の転送の一部として、リースは同様に転送されます。新しいサーバーに転送されているリースは、通常、以前に古いサーバーで、同じクライアントのためのものとは異なる有効期限を持っています。与えられたクライアントのために特定のサーバー上のすべてのリースが同時に期限切れに財産を維持するために、サーバーが転送されているリース、または既に存在リースの後のに有効期限を進める必要があります。これにより、クライアントは、特別な努力なしで両方のクラスのリース更新を維持することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The servers may choose not to transfer the state information upon migration. However, this choice is discouraged. In this case, when the client presents state information from the original server, the client must be prepared to receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server. The client should then recover its state information as it normally would in response to a server failure. The new server must take care to allow for the recovery of state information as it would in the event of server restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、移行時に状態情報を転送しないこともできます。しかし、この選択はお勧めしません。クライアントは、元のサーバーからの状態情報を提示すると、この場合、クライアントは、新しいサーバーからNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_STALE_STATEIDのいずれかを受け取ることを準備する必要があります。それは通常、サーバーの障害に応じて同じように、クライアントは、その状態情報を復元する必要があります。新しいサーバーは、サーバーの再起動のイベントと同じように状態情報の復旧を可能にするように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.2. Replication and State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.2。レプリケーションと国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since client switch-over in the case of replication is not under server control, the handling of state is different. In this case, leases, stateids and clientids do not have validity across a transition from one server to another. The client must re-establish its locks on the new server. This can be compared to the re-establishment of locks by means of reclaim-type requests after a server reboot. The difference is that the server has no provision to distinguish requests reclaiming locks from those obtaining new locks or to defer the latter. Thus, a client re-establishing a lock on the new server (by means of a LOCK or OPEN request), may have the requests denied due to a conflicting lock. Since replication is intended for read-only use of filesystems, such denial of locks should not pose large difficulties in practice. When an attempt to re-establish a lock on a new server is denied, the client should treat the situation as if his original lock had been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複製の場合のクライアントスイッチオーバーは、サーバーの管理下にはないので、状態の取り扱いが異なっています。この場合、リース、のstateidsとのClientID 1つのサーバーから別への移行全体の妥当性を持っていません。クライアントは、新しいサーバー上のロックを再確立する必要があります。これは、サーバの再起動後に再利用型リクエストによってロックの再確立と比較することができます。違いは、サーバーがそれらの取得新しいロックからロックを再利用要求を区別するか、後者を延期することを想定していませんということです。このように、クライアントの再確立新しいサーバーのロックを（LOCKまたはOPENのリクエストによる）は、競合ロックが原因で拒否されたリクエストを有することができます。レプリケーションがファイルシステムの読み取り専用の使用を意図しているので、ロックのように否定は実際には大きな困難をもたらすべきではありません。新しいサーバーにロックを再確立しようとする試みが拒否された場合には、彼のオリジナルロックが取り消されたかのように、クライアントは状況を扱うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.3. Notification of Migrated Lease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.3。移行したリースの通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of lease renewal, the client may not be submitting requests for a filesystem that has been migrated to another server. This can occur because of the implicit lease renewal mechanism. The client renews leases for all filesystems when submitting a request to any one filesystem at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リース更新の場合、クライアントは別のサーバに移行されたファイルシステムに対する要求を提出することはできません。これは、暗黙のリース更新機構から発生する可能性があります。サーバーのいずれかのファイルシステムに要求を提出するとき、クライアントは、すべてのファイルシステムのためのリースを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order for the client to schedule renewal of leases that may have been relocated to the new server, the client must find out about lease relocation before those leases expire. To accomplish this, all operations which implicitly renew leases for a client (i.e., OPEN, CLOSE, READ, WRITE, RENEW, LOCK, LOCKT, LOCKU), will return the error NFS4ERR_LEASE_MOVED if responsibility for any of the leases to be renewed has been transferred to a new server. This condition will continue until the client receives an NFS4ERR_MOVED error and the server receives the subsequent GETATTR(fs_locations) for an access to each filesystem for which a lease has been moved to a new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのリース期限が切れる前に新しいサーバーに移転されている可能性がリースの更新をスケジュールするクライアントのために、クライアントは、リースの再配置を知る必要があります。更新するリースのいずれかの責任がされている場合は、これを達成するために、暗黙的にクライアントのリースを更新するすべての操作（すなわち、OPEN、CLOSE、READ、RENEW、書き込みロック、LOCKT、LOCKU）は、エラーにNFS4ERR_LEASE_MOVEDを返します。新しいサーバーに転送。クライアントがNFS4ERR_MOVEDエラーを受信して​​、サーバがリースを新しいサーバーに移動された各ファイルシステムにアクセスするために、その後のGETATTR（fs_位置）を受信するまで、この状態が継続されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives an NFS4ERR_LEASE_MOVED error, it should perform an operation on each filesystem associated with the server in question. When the client receives an NFS4ERR_MOVED error, the client can follow the normal process to obtain the new server information (through the fs_locations attribute) and perform renewal of those leases on the new server. If the server has not had state transferred to it transparently, the client will receive either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server, as described above, and the client can then recover state information as it does in the event of server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがNFS4ERR_LEASE_MOVEDエラーを受信した場合、それは問題のサーバーに関連付けられている各ファイルシステム上の操作を実行する必要があります。クライアントがNFS4ERR_MOVEDエラーを受信した場合、クライアントは、（fs_位置の属性で）新しいサーバーの情報を取得するために、通常のプロセスに従うと、新しいサーバー上のリースの更新を行うことができます。サーバは状態が透過的に転送されなかった場合は、上記のように、クライアントは、新しいサーバーからNFS4ERR_STALE_CLIENTIDまたはNFS4ERR_STALE_STATEIDのいずれかを受け取ることになります、そしてそれは、サーバーに障害が発生した場合に行うように、クライアントは、状態情報を復元することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.4. Migration and the Lease_time Attribute
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.14.4。移行とLease_time属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order that the client may appropriately manage its leases in the case of migration, the destination server must establish proper values for the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが適切に移行した場合にそのリースを管理できるように、送信先サーバーはlease_time属性の適切な値を確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When state is transferred transparently, that state should include the correct value of the lease_time attribute. The lease_time attribute on the destination server must never be less than that on the source since this would result in premature expiration of leases granted by the source server. Upon migration in which state is transferred transparently, the client is under no obligation to re-fetch the lease_time attribute and may continue to use the value previously fetched (on the source server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態が透過的に転送されると、その状態はlease_time属性の正しい値を含むべきです。これは、ソースサーバによって付与されたリースの早期満了ことになるので、先サーバー上のlease_time属性は、ソース上のそれよりも少ないにすることはできません。透過的に転送される状態に移行すると、クライアントは、再フェッチlease_time属性する義務の下で、（ソースサーバ上の）以前にフェッチされた値を使用し続けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If state has not been transferred transparently (i.e., the client sees a real or simulated server reboot), the client should fetch the value of lease_time on the new (i.e., destination) server, and use it for subsequent locking requests. However the server must respect a grace period at least as long as the lease_time on the source server, in order to ensure that clients have ample time to reclaim their locks before potentially conflicting non-reclaimed locks are granted. The means by which the new server obtains the value of lease_time on the old server is left to the server implementations. It is not specified by the NFS version 4 protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態は（つまり、クライアントが本物か、シミュレートされたサーバーの再起動を見て）透過的に転送されていない場合、クライアントは、新しい（すなわち、宛先）サーバー上lease_timeの値を取得し、その後のロック要求のためにそれを使用する必要があります。ただし、サーバーは、潜在的に競合非埋立ロックが付与される前に、クライアントがロックを取り戻すために十分な時間を持っていることを確実にするためには、少なくとも限り、ソースサーバー上のlease_timeとして、猶予期間を尊重しなければなりません。新しいサーバーは、古いサーバー上lease_timeの値を取得する手段は、サーバの実装に任されています。これは、NFSバージョン4プロトコルによって指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.クライアントサイドキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client-side caching of data, of file attributes, and of file names is essential to providing good performance with the NFS protocol. Providing distributed cache coherence is a difficult problem and previous versions of the NFS protocol have not attempted it. Instead, several NFS client implementation techniques have been used to reduce the problems that a lack of coherence poses for users. These techniques have not been clearly defined by earlier protocol specifications and it is often unclear what is valid or invalid client behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル属性の、およびファイル名のデータのクライアント側のキャッシュは、NFSプロトコルとの良好なパフォーマンスを提供するために不可欠です。分散キャッシュの一貫性を提供することは難しい問題であり、NFSプロトコルの以前のバージョンではそれをしようとしていません。代わりに、いくつかのNFSクライアントの実装技術は、一貫性の欠如は、ユーザーのためのポーズの問題を軽減するために使用されています。これらの技術は明らかに以前のプロトコル仕様で定義されていない、有効か無効クライアントの動作が何であるかを、多くの場合不明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol uses many techniques similar to those that have been used in previous protocol versions. The NFS version 4 protocol does not provide distributed cache coherence. However, it defines a more limited set of caching guarantees to allow locks and share reservations to be used without destructive interference from client side caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、以前のプロトコル・バージョンで使用されたものと同様の多くの技術を使用します。 NFSバージョン4プロトコルは、分散キャッシュの一貫性を提供していません。しかし、ロックと共有の予約がクライアント側のキャッシュからの破壊的干渉なしに使用することができるようにキャッシング保証のより限定されたセットを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the NFS version 4 protocol introduces a delegation mechanism which allows many decisions normally made by the server to be made locally by clients. This mechanism provides efficient support of the common cases where sharing is infrequent or where sharing is read-only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、NFSバージョン4プロトコルは、通常はサーバーによって行われた多くの決定は、クライアントによってローカルで行うことを可能にする委譲メカニズムを導入しています。この機構は、共有がまれであるか、または共有が読み取り専用である場合に一般的なケースの効率的なサポートを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Performance Challenges for Client-Side Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。クライアント側のキャッシュのパフォーマンスの課題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Caching techniques used in previous versions of the NFS protocol have been successful in providing good performance. However, several scalability challenges can arise when those techniques are used with very large numbers of clients. This is particularly true when clients are geographically distributed which classically increases the latency for cache revalidation requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの以前のバージョンで使用されるキャッシュ技術は、優れた性能を提供することに成功しています。これらの技術は、クライアントの非常に大きな数字で使用されている場合しかし、いくつかのスケーラビリティの問題が発生する可能性があります。これは、クライアントが地理的に古典的にキャッシュ再検証要求のための待ち時間を増加させる分散している場合は特にそうです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The previous versions of the NFS protocol repeat their file data cache validation requests at the time the file is opened. This behavior can have serious performance drawbacks. A common case is one in which a file is only accessed by a single client. Therefore, sharing is infrequent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSプロトコルの以前のバージョンでは、ファイルが開かれた時にそのファイルのデータ・キャッシュの検証要求を繰り返します。この動作は、パフォーマンスに重大な欠点を持つことができます。一般的なケースでは、ファイルは、単一のクライアントがアクセスしたものです。そのため、共有はまれです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, repeated reference to the server to find that no conflicts exist is expensive. A better option with regards to performance is to allow a client that repeatedly opens a file to do so without reference to the server. This is done until potentially conflicting operations from another client actually occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、競合が存在しないことを見つけるために、サーバへの反復参照は高価です。パフォーマンスに関してとのより良いオプションは、繰り返し、サーバーを参照することなくこれを行うには、ファイルを開くクライアントをできるようにすることです。別のクライアントからの潜在的な競合の操作が実際に発生するまで、これが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A similar situation arises in connection with file locking. Sending file lock and unlock requests to the server as well as the read and write requests necessary to make data caching consistent with the locking semantics (see the section &#34;Data Caching and File Locking&#34;) can severely limit performance. When locking is used to provide protection against infrequent conflicts, a large penalty is incurred. This penalty may discourage the use of file locking by applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様の状況は、ファイルのロックに関連して発生します。ファイルロックを送信すると、パフォーマンスが大幅に制限することができ、サーバーへの要求だけでなく、読み取りロックを解除し、データがロックセマンティクス（節参照「データキャッシングとロックファイル」）と一致キャッシングさせるために必要な要求を記述します。ロックがまれ衝突に対する保護を提供するために使用される場合、大きなペナルティが発生しています。このペナルティはアプリケーションによるファイルロックの使用を阻止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol provides more aggressive caching strategies with the following design goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、次の設計目標をより積極的なキャッシング戦略を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Compatibility with a large range of server semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーのセマンティクスの大規模な範囲でのOの互換性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Provide the same caching benefits as previous versions of the NFS protocol when unable to provide the more aggressive model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oより積極的なモデルを提供することができませんでしNFSプロトコルの以前のバージョンと同じキャッシングの利点を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Requirements for aggressive caching are organized so that a large portion of the benefit can be obtained even when not all of the requirements can be met.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
利益の大部分は、要件のすべてを満たすことができない場合でも得られるように、積極的なキャッシュ用のO要件が整理されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The appropriate requirements for the server are discussed in later sections in which specific forms of caching are covered. (see the section &#34;Open Delegation&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバのための適切な要件は、キャッシュの特定の形態は、被覆された後のセクションに記載されています。 （セクション「オープン委譲」を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Delegation and Callbacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。委任とコールバック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recallable delegation of server responsibilities for a file to a client improves performance by avoiding repeated requests to the server in the absence of inter-client conflict. With the use of a &#34;callback&#34; RPC from server to client, a server recalls delegated responsibilities when another client engages in sharing of a delegated file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントへのファイルのサーバー責任のリコール代表団は、クライアント間の競合が存在しない場合に、サーバーへの再三の要求を回避することによって、パフォーマンスが向上します。別のクライアントが委任ファイルの共有に従事したときに、サーバーからクライアントへの「コールバック」RPCを使用すると、サーバーは、委任の責任を思い出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A delegation is passed from the server to the client, specifying the object of the delegation and the type of delegation. There are different types of delegations but each type contains a stateid to be used to represent the delegation when performing operations that depend on the delegation. This stateid is similar to those associated with locks and share reservations but differs in that the stateid for a delegation is associated with a clientid and may be used on behalf of all the open_owners for the given client. A delegation is made to the client as a whole and not to any specific process or thread of control within it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任は、委任の対象と委任の種類を指定して、サーバからクライアントに渡されます。そこ代表団の異なるタイプがあるが、それぞれのタイプには、代表団に依存する操作を実行する場合、委任を表すために使用されるのstateidが含まれています。これのstateidはロックとシェアの予約に関連したものと同様であるが、代表団のためのstateidはClientIDが関連付けられ、特定のクライアントのためのすべてのopen_ownersに代わって使用することができるという点で異なります。代表団は、全体としてではなく、特定のプロセスやその内のコントロールのスレッドに、クライアントに行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because callback RPCs may not work in all environments (due to firewalls, for example), correct protocol operation does not depend on them. Preliminary testing of callback functionality by means of a CB_NULL procedure determines whether callbacks can be supported. The CB_NULL procedure checks the continuity of the callback path. A server makes a preliminary assessment of callback availability to a given client and avoids delegating responsibilities until it has determined that callbacks are supported. Because the granting of a delegation is always conditional upon the absence of conflicting access, clients must not assume that a delegation will be granted and they must always be prepared for OPENs to be processed without any delegations being granted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックRPCが（例えば、原因ファイアウォールに）すべての環境で動作しない場合がありますので、正しいプロトコル動作は、それらに依存しません。 CB_NULL手順によって、コールバック機能の予備試験は、コールバックをサポートできるかどうかを決定します。 CB_NULL手順は、コールバック・パスの連続性をチェックします。サーバーは、特定のクライアントへのコールバックの可用性の予備的な評価を行い、それがコールバックがサポートされていると判断するまで、責任を委譲することを回避します。代表団の付与は、常に競合アクセスの不在時に条件付きであるため、クライアントは、代表団が付与されると、彼らは常に許可されている任意の代表団ずに処理されるために開くために準備しなければならないと仮定してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once granted, a delegation behaves in most ways like a lock. There is an associated lease that is subject to renewal together with all of the other leases held by that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付与された後は、代表団は、ロックのように、ほとんどの方法で動作します。そのクライアントが保有する他のリースのすべてと一緒に更新の対象となる関連したリースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike locks, an operation by a second client to a delegated file will cause the server to recall a delegation through a callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックとは異なり、委任ファイルへの2番目のクライアントによる操作は、サーバーがコールバックを通じて委任をリコールするようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On recall, the client holding the delegation must flush modified state (such as modified data) to the server and return the delegation. The conflicting request will not receive a response until the recall is complete. The recall is considered complete when the client returns the delegation or the server times out on the recall and revokes the delegation as a result of the timeout. Following the resolution of the recall, the server has the information necessary to grant or deny the second client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リコールでは、委任を保持しているクライアントは、サーバに（例えば修正されたデータなど）変更された状態をフラッシュし、委任を返す必要があります。リコールが完了するまで、相反する要求が応答を受信しません。クライアントがリコールに委任またはサーバーがタイムアウトを返し、タイムアウトの結果として委任を取り消したときにリコールが完了したと見なされます。リコールの解決に続いて、サーバーは、第二のクライアントの要求を許可または拒否するために必要な情報を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the time the client receives a delegation recall, it may have substantial state that needs to be flushed to the server. Therefore, the server should allow sufficient time for the delegation to be returned since it may involve numerous RPCs to the server. If the server is able to determine that the client is diligently flushing state to the server as a result of the recall, the server may extend the usual time allowed for a recall. However, the time allowed for recall completion should not be unbounded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが委譲リコールを受ける時には、それがサーバーにフラッシュする必要がかなりの状態を有することができます。そのため、サーバーは、サーバーに多数のRPCを含むことができるので、返される委譲のための十分な時間を許可する必要があります。サーバは、クライアントが熱心にリコールの結果としてサーバーに状態をフラッシュしていることを決定することができる場合は、サーバーはリコールのために許可される通常の時間を延長することができます。しかし、リコール完了に許される時間は無制限ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example of this is when responsibility to mediate opens on a given file is delegated to a client (see the section &#34;Open Delegation&#34;). The server will not know what opens are in effect on the client. Without this knowledge the server will be unable to determine if the access and deny state for the file allows any particular open until the delegation for the file has been returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仲介する責任が与えられたファイルに開いたときに、この例では（セクション「オープン委譲」を参照）、クライアントに委譲されています。開いたのか分からなくなり、サーバーは、クライアントに適用されています。この知識がないと、サーバーは、ファイルの委譲が返されるまでの任意の特定のオープンできるアクセスかどうかを判断し、ファイルの状態を否定することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client failure or a network partition can result in failure to respond to a recall callback. In this case, the server will revoke the delegation which in turn will render useless any modified state still on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント障害またはネットワークパーティションは、リコールコールバックに応答する障害が発生することができます。この場合、サーバは、順番に、クライアント上ではまだ役に立たない任意の変更された状態をレンダリングする委任を取り消します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1. Delegation Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2.1。委任回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three situations that delegation recovery must deal with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代表団の回復が対処しなければならないことの3つの状況があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Client reboot or restart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oクライアントの再起動または再起動
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Server reboot or restart
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバの再起動や再起動
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Network partition (full or callback-only)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oネットワークパーティション（フルまたはコールバックのみ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event the client reboots or restarts, the failure to renew leases will result in the revocation of record locks and share reservations. Delegations, however, may be treated a bit differently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イベントでは、クライアントの再起動や再起動、リースの更新に失敗するとレコードロックと共有の予約の取り消しになります。代表団は、しかし、異なるビットを処理することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There will be situations in which delegations will need to be reestablished after a client reboots or restarts. The reason for this is the client may have file data stored locally and this data was associated with the previously held delegations. The client will need to reestablish the appropriate file state on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代表団は、クライアントの再起動や再起動後に再確立する必要がある状況があります。この理由は、クライアントがローカルに保存されたファイルデータを持っていることであり、このデータは、以前開催された代表団と関連していました。クライアントは、サーバ上の適切なファイルの状態を再確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To allow for this type of client recovery, the server MAY extend the period for delegation recovery beyond the typical lease expiration period. This implies that requests from other clients that conflict with these delegations will need to wait. Because the normal recall process may require significant time for the client to flush changed state to the server, other clients need be prepared for delays that occur because of a conflicting delegation. This longer interval would increase the window for clients to reboot and consult stable storage so that the delegations can be reclaimed. For open delegations, such delegations are reclaimed using OPEN with a claim type of CLAIM_DELEGATE_PREV. (See the sections on &#34;Data Caching and Revocation&#34; and &#34;Operation 18: OPEN&#34; for discussion of open delegation and the details of OPEN respectively).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの回復のこのタイプを可能にするため、サーバーは、一般的なリースの有効期限を越えた委任回復のための期間を延長することができます。これは、他のクライアントからの要求は、これらの代表団と競合を待つ必要があることを意味します。クライアントがサーバに変更された状態をフラッシュするために、通常のリコール処理はかなりの時間が必要な場合がありますので、他のクライアントがあるため、競合する代表団の発生の遅れのために準備される必要があります。この長い間隔は代表団を再利用できるように、安定した記憶装置を再起動して相談するクライアントのためのウィンドウを増加させることになります。オープン委譲のために、そのような委任はCLAIM_DELEGATE_PREVのクレームタイプOPEN用いて再生されます。 （：それぞれ開いている委譲とOPENの詳細については、「データキャッシングと失効」と「OPENオペレーション18」のセクションを参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY support a claim type of CLAIM_DELEGATE_PREV, but if it does, it MUST NOT remove delegations upon SETCLIENTID_CONFIRM, and instead MUST, for a period of time no less than that of the value of the lease_time attribute, maintain the client&#39;s delegations to allow time for the client to issue CLAIM_DELEGATE_PREV requests. The server that supports CLAIM_DELEGATE_PREV MUST support the DELEGPURGE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはCLAIM_DELEGATE_PREVの請求タイプをサポートするかもしれないが、それがない場合は、SETCLIENTID_CONFIRM時に代表団を削除し、代わりにしなければならず、lease_time属性の値よりも小さくない一定の期間のため、許可するクライアントの代表団を維持してはなりませんCLAIM_DELEGATE_PREV要求を発行するクライアントのための時間。 CLAIM_DELEGATE_PREVをサポートするサーバーは、DELEGPURGE操作をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server reboots or restarts, delegations are reclaimed (using the OPEN operation with CLAIM_PREVIOUS) in a similar fashion to record locks and share reservations. However, there is a slight semantic difference. In the normal case if the server decides that a delegation should not be granted, it performs the requested action (e.g., OPEN) without granting any delegation. For reclaim, the server grants the delegation but a special designation is applied so that the client treats the delegation as having been granted but recalled by the server. Because of this, the client has the duty to write all modified state to the server and then return the delegation. This process of handling delegation reclaim reconciles three principles of the NFS version 4 protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが再起動または再起動したときに、委任がロックと共有の予約を記録するために同様の方法で（CLAIM_PREVIOUSで開く操作を使用して）再利用されます。しかし、わずかなセマンティック違いがあります。サーバは委任が許可されるべきではないと判断した場合、通常のケースでは、任意の委任を許可することなく、要求されたアクション（例えば、OPEN）を行います。再利用のために、サーバが委任を許可しますが、クライアントがサーバによって付与されたが、リコールされたものとして委任を扱うように、特別な指定が適用されます。このため、クライアントは、サーバーへのすべての変更された状態を書き込み、委任を返す義務があります。委任再利用を扱うこのプロセスは、NFSバージョン4プロトコルの3つの原則を調和させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Upon reclaim, a client reporting resources assigned to it by an earlier server instance must be granted those resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O再利用時には、以前のサーバインスタンスによってそれに割り当てられたリソースを報告するクライアントは、それらのリソースを付与する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has unquestionable authority to determine whether delegations are to be granted and, once granted, whether they are to be continued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは、代表団は、かつて彼らが継続するかどうか、付与された、許可されたとされるようにしているかどうかを判断するために疑う余地のない権限を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of callbacks is not to be depended upon until the client has proven its ability to receive them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがそれらを受信する能力を証明しているまで、Oコールバックの使用はないに依存することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition occurs, delegations are subject to freeing by the server when the lease renewal period expires. This is similar to the behavior for locks and share reservations. For delegations, however, the server may extend the period in which conflicting requests are held off. Eventually the occurrence of a conflicting request from another client will cause revocation of the delegation. A loss of the callback path (e.g., by later network configuration change) will have the same effect. A recall request will fail and revocation of the delegation will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションが発生した場合、代表団はリース更新期間が満了したときに、サーバによって解放の対象となっています。これは、ロックとシェアの予約のための動作に似ています。委譲のために、しかし、サーバは、競合する要求がオフに保持される期間を延長することができます。結局、別のクライアントから競合の要求の発生は委任の取消しの原因となります。コールバックパス（例えば、後のネットワーク設定変更による）の損失は、同じ効果を有するであろう。リコール要求は失敗し、代表団の失効が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client normally finds out about revocation of a delegation when it uses a stateid associated with a delegation and receives the error NFS4ERR_EXPIRED. It also may find out about delegation revocation after a client reboot when it attempts to reclaim a delegation and receives that same error. Note that in the case of a revoked write open delegation, there are issues because data may have been modified by the client whose delegation is revoked and separately by other clients. See the section &#34;Revocation Recovery for Write Open Delegation&#34; for a discussion of such issues. Note also that when delegations are revoked, information about the revoked delegation will be written by the server to stable storage (as described in the section &#34;Crash Recovery&#34;). This is done to deal with the case in which a server reboots after revoking a delegation but before the client holding the revoked delegation is notified about the revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは代表団に関連付けられたstateidを使用すると、エラーNFS4ERR_EXPIREDを受信したときに、クライアントは通常、委任の取消しについて見つけ出します。それは代表団を再利用しようとすると、同じエラーを受信した場合も、クライアントの再起動後に委任失効について調べることがあります。データはその代表団、他のクライアントによって個別に無効化され、クライアントによって変更された可能性があるため、失効書き込みオープン委譲の場合には、問題があることに注意してください。そのような問題の議論については、「書き込みオープン委譲のための失効リカバリ」を参照してください。代表団が取り消されたときに（セクション「クラッシュリカバリ」で説明したように）、取り消された代表団についての情報が安定したストレージにサーバーによって書き込まれることにも注意してください。これは、サーバが委任を取り消した後が、取り消された代表団を保持しているクライアントが失効について通知される前に再起動した場合に対処するために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3。データキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When applications share access to a set of files, they need to be implemented so as to take account of the possibility of conflicting access by another application. This is true whether the applications in question execute on different clients or reside on the same client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルのセットにアプリケーション共有アクセス、彼らは他のアプリケーションによるアクセスの競合の可能性を考慮するように実装する必要があります。これは、問題のアプリケーションは、異なるクライアント上で実行するか、同じクライアント上に存在するかどうか本当です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Share reservations and record locks are the facilities the NFS version 4 protocol provides to allow applications to coordinate access by providing mutual exclusion facilities. The NFS version 4 protocol&#39;s data caching must be implemented such that it does not invalidate the assumptions that those using these facilities depend upon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有の予約とレコードロックは、NFSバージョン4プロトコルは、アプリケーションが相互排他設備を提供することによって、アクセスを調整できるようにするために提供する機能です。 NFSバージョン4プロトコルのデータのキャッシングは、これらの施設を利用したものが依存することを仮定を無効にしないように実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.1. Data Caching and OPENs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.1。データキャッシング、開きました
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid invalidating the sharing assumptions that applications rely on, NFS version 4 clients should not provide cached data to applications or modify it on behalf of an application when it would not be valid to obtain or modify that same data via a READ or WRITE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、アプリケーションが依存する共有の仮定を無効避けるためにNFSバージョン4つのクライアントは、アプリケーションにキャッシュされたデータを提供してはならないか、入手またはREADを経由して、同じデータを変更したり、書き込むには有効ではないだろうというとき、アプリケーションに代わって、それを修正します操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, in the absence of open delegation (see the section &#34;Open Delegation&#34;) two additional rules apply. Note that these rules are obeyed in practice by many NFS version 2 and version 3 clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、開いている委譲が存在しない場合に二つの追加の規則が適用されます（セクション「オープン委譲」を参照してください）。これらのルールは、多くのNFSバージョン2とバージョン3つのクライアントが実際に守られることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, cached data present on a client must be revalidated after doing an OPEN. Revalidating means that the client fetches the change attribute from the server, compares it with the cached change attribute, and if different, declares the cached data (as well as the cached attributes) as invalid. This is to ensure that the data for the OPENed file is still correctly reflected in the client&#39;s cache. This validation must be done at least when the client&#39;s OPEN operation includes DENY=WRITE or BOTH thus terminating a period in which other clients may have had the opportunity to open the file with WRITE access. Clients may choose to do the revalidation more often (i.e., at OPENs specifying DENY=NONE) to parallel the NFS version 3 protocol&#39;s practice for the benefit of users assuming this degree of cache revalidation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oまず、クライアント上に存在し、キャッシュされたデータは、OPENをやった後、再検証する必要があります。再検証は、クライアントが、サーバからの変化属性を取得し、キャッシュされた変化属性と比較し、異なる場合は、無効としてキャッシュされたデータ（同様にキャッシュされた属性）を宣言していることを意味します。これは、開いたファイルのデータがまだ正しくクライアントのキャッシュに反映されていることを確認することです。この検証は、クライアントのOPEN操作は、このように他のクライアントが書き込みアクセスでファイルを開くための機会を持っていた可能性のある期間を終了= WRITEまたはBOTHをDENY、少なくとも時に行われなければなりません。クライアントは、キャッシュ再検証のこの程度を想定し、ユーザーの利益のためにNFSバージョン3プロトコルの練習を並行して（= NONEを否定できない指定すなわち開きで）より頻繁に再検証を行うことを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Since the change attribute is updated for data and metadata modifications, some client implementors may be tempted to use the time_modify attribute and not change to validate cached data, so that metadata changes do not spuriously invalidate clean data. The implementor is cautioned in this approach. The change attribute is guaranteed to change for each update to the file, whereas time_modify is guaranteed to change only at the granularity of the time_delta attribute. Use by the client&#39;s data cache validation logic of time_modify and not change runs the risk of the client incorrectly marking stale data as valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
変化属性は、データとメタデータの変更のために更新されるので、メタデータの変更が誤ってクリーンなデータを無効にしないように、いくつかのクライアントの実装は、time_modify属性を使用して、キャッシュされたデータを検証するために変更しないように誘惑することができます。実装者は、このアプローチに警告されています。 time_modifyがTIME_DELTA属性の粒度でのみ変更することが保証されているのに対し、変化属性は、ファイルへの更新ごとに変更することが保証されています。変更time_modifyのクライアントのデータ・キャッシュの検証ロジックで使用していないと、クライアントが誤って有効として古いデータをマーキングするリスクを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second, modified data must be flushed to the server before closing a file OPENed for write. This is complementary to the first rule. If the data is not flushed at CLOSE, the revalidation done after client OPENs as file is unable to achieve its purpose. The other aspect to flushing the data before close is that the data must be committed to stable storage, at the server, before the CLOSE operation is requested by the client. In the case of a server reboot or restart and a CLOSEd file, it may not be possible to retransmit the data to be written to the file. Hence, this requirement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O第二に、変更されたデータは、書き込みのために開いたファイルを閉じる前に、サーバーにフラッシュする必要があります。これは最初のルールに相補的です。データはCLOSEでフラッシュされていない場合は、クライアントがファイルとして開いた後に行う再検証は、その目的を達成することができません。クローズする前にデータをフラッシュする他の側面は、CLOSE操作がクライアントによって要求される前のデータは、サーバーで、安定したストレージにコミットしなければならないということです。サーバーの再起動または再起動し、閉じられたファイルの場合は、ファイルに書き込まれるデータを再送することはできないかもしれません。したがって、この要件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.2. Data Caching and File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.2。データ・キャッシングとファイルロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For those applications that choose to use file locking instead of share reservations to exclude inconsistent file access, there is an analogous set of constraints that apply to client side data caching. These rules are effective only if the file locking is used in a way that matches in an equivalent way the actual READ and WRITE operations executed. This is as opposed to file locking that is based on pure convention. For example, it is possible to manipulate a two-megabyte file by dividing the file into two one-megabyte regions and protecting access to the two regions by file locks on bytes zero and one. A lock for write on byte zero of the file would represent the right to do READ and WRITE operations on the first region. A lock for write on byte one of the file would represent the right to do READ and WRITE operations on the second region. As long as all applications manipulating the file obey this convention, they will work on a local filesystem. However, they may not work with the NFS version 4 protocol unless clients refrain from data caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一貫性のないファイルへのアクセスを除外するために、代わりに株式の予約のファイルロックを使用することを選択し、それらのアプリケーションでは、クライアント側のデータキャッシュに適用される制約の類似したセットがあります。これらのルールは、ファイルのロックが実際の読み出しおよび書き込み動作が実行される同等の方法で一致するように使用されている場合にのみ有効です。純粋な慣例に基づいて、ロックファイルとは対照的にこれがあります。例えば、2つの1メガバイトの領域にファイルを分割し、バイト0と1上のファイルロックによって二つの領域へのアクセスを保護することにより、二メガバイトのファイルを操作することが可能です。ファイルのバイトゼロの書き込みのためのロックは、第1の領域に読み取りおよび書き込み操作を行う権利を表します。ファイルのバイト1の書き込みのためのロックは第二の領域に読み取りおよび書き込み操作を行う権利を表します。限り、ファイルを操作するすべてのアプリケーションがこの規則に従うように、彼らはローカルファイルシステム上で動作します。クライアントがデータ・キャッシングを控える場合を除きしかし、彼らは、NFSバージョン4プロトコルでは動作しない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules for data caching in the file locking environment are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルロック環境でのデータのキャッシュのためのルールは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o First, when a client obtains a file lock for a particular region, the data cache corresponding to that region (if any cached data exists) must be revalidated. If the change attribute indicates that the file may have been updated since the cached data was obtained, the client must flush or invalidate the cached data for the newly locked region. A client might choose to invalidate all of non-modified cached data that it has for the file but the only requirement for correct operation is to invalidate all of the data in the newly locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、特定の地域のためのファイルロックを取得した場合、Oまず、その領域に対応するデータキャッシュは（キャッシュされたデータが存在する場合）、再検証する必要があります。変化属性がキャッシュされたデータが得られたので、ファイルが更新された可能性があることを示している場合、クライアントは、新たにロックされた領域のためにキャッシュされたデータをフラッシュしたり無効化しなければなりません。クライアントは、ファイルのために持っていますが、正しく動作するための唯一の要件は、新たにロックされた領域内のすべてのデータを無効化するためにある非改変キャッシュされたデータのすべてを無効にすることを選択するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second, before releasing a write lock for a region, all modified data for that region must be flushed to the server. The modified data must also be written to stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O第二に、地域のために書き込みロックを解除する前に、その地域のすべての変更されたデータをサーバーにフラッシュする必要があります。変更されたデータはまた、安定したストレージに書き込む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that flushing data to the server and the invalidation of cached data must reflect the actual byte ranges locked or unlocked. Rounding these up or down to reflect client cache block boundaries will cause problems if not carefully done. For example, writing a modified block when only half of that block is within an area being unlocked may cause invalid modification to the region outside the unlocked area. This, in turn, may be part of a region locked by another client. Clients can avoid this situation by synchronously performing portions of write operations that overlap that portion (initial or final) that is not a full block. Similarly, invalidating a locked area which is not an integral number of full buffer blocks would require the client to read one or two partial blocks from the server if the revalidation procedure shows that the data which the client possesses may not be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバとキャッシュされたデータの無効化へデータをフラッシュすると、実際のバイト範囲ロックまたはロック解除を反映しなければならないことに注意してください。注意深く行われていない場合は、クライアントのキャッシュ・ブロックの境界を反映するためにダウンこれらを丸めたりすると、問題が発生します。例えば、修飾されたブロックを書き込むと、そのブロックの半分だけがロック解除された領域の外側の領域に、無効な変更を引き起こすことがアンロックされている領域内にある場合。これは、順番に、別のクライアントによってロックされた領域の一部であってもよいです。クライアントは同期満杯ブロックでない部分（初期または最終）を重複書き込み操作の一部を実行することによってこの状況を回避することができます。同様に、サーバーから一つまたは二つの部分ブロックを読み取るためにクライアントを必要とする完全なバッファブロックの整数倍ではないロックされた領域を無効にする再検証手順は、クライアントが保有するデータが有効ではないかもしれないことを示している場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data that is written to the server as a prerequisite to the unlocking of a region must be written, at the server, to stable storage. The client may accomplish this either with synchronous writes or by following asynchronous writes with a COMMIT operation. This is required because retransmission of the modified data after a server reboot might conflict with a lock held by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
領域のロック解除の前提条件としてサーバに書き込まれたデータは、安定したストレージに、サーバに書き込まれなければなりません。クライアントは同期書き込みまたはCOMMIT操作で非同期書き込みを、次のいずれかによって、これを達成することができます。サーバーの再起動後に変更されたデータの再送信は、別のクライアントによって保持されたロックと競合する可能性がありますので、これが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client implementation may choose to accommodate applications which use record locking in non-standard ways (e.g., using a record lock as a global semaphore) by flushing to the server more data upon an LOCKU than is covered by the locked range. This may include modified data within files other than the one for which the unlocks are being done. In such cases, the client must not interfere with applications whose READs and WRITEs are being done only within the bounds of record locks which the application holds. For example, an application locks a single byte of a file and proceeds to write that single byte. A client that chose to handle a LOCKU by flushing all modified data to the server could validly write that single byte in response to an unrelated unlock. However, it would not be valid to write the entire block in which that single written byte was located since it includes an area that is not locked and might be locked by another client. Client implementations can avoid this problem by dividing files with modified data into those for which all modifications are done to areas covered by an appropriate record lock and those for which there are modifications not covered by a record lock. Any writes done for the former class of files must not include areas not locked and thus not modified on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの実装では、サーバにロックされた範囲によってカバーされるよりもLOCKU際に多くのデータをフラッシュすることにより、非標準的な方法（例えば、グローバルセマフォとしてレコードロックを使用して）にレコードロックを使用するアプリケーションに対応することを選択することができます。これは、アンロックが行われているために1以外のファイル内で変更されたデータを含むことができます。このような場合には、クライアントは、その読み込みと書き込みのみアプリケーションが保持しているレコードロックの範囲内で行われているアプリケーションを妨害してはなりません。例えば、アプリケーションは、ファイルの単一のバイトをロックし、その単一バイトの書き込みに進みます。サーバーへのすべての変更されたデータをフラッシュしてLOCKUを処理するために選択したクライアントが有効に無関係なロック解除に応じて、その1バイトを書くことができます。しかし、ロックされていないと別のクライアントによってロックされるかもしれない領域を含むので、その単一書かれたバイトが配置されたブロック全体を書き込むことが有効ではありません。クライアントの実装は、すべての変更が適切なレコードロックとレコードロックでカバーされていない変更がありますそのため、それらによってカバーされる領域に行われているため、それらに変更されたデータを含むファイルを分割することによって、この問題を回避することができます。ファイルの元のクラスに行って、任意の書き込みは、領域がロックされていないため、クライアント上で変更されていない含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.3. Data Caching and Mandatory File Locking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.3。データ・キャッシングと強制ファイルロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client side data caching needs to respect mandatory file locking when it is in effect. The presence of mandatory file locking for a given file is indicated when the client gets back NFS4ERR_LOCKED from a READ or WRITE on a file it has an appropriate share reservation for. When mandatory locking is in effect for a file, the client must check for an appropriate file lock for data being read or written. If a lock exists for the range being read or written, the client may satisfy the request using the client&#39;s validated cache. If an appropriate file lock is not held for the range of the read or write, the read or write request must not be satisfied by the client&#39;s cache and the request must be sent to the server for processing. When a read or write request partially overlaps a locked region, the request should be subdivided into multiple pieces with each region (locked or not) treated appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント側のデータキャッシュは、それが有効になっている場合は必須ファイルロックを尊重する必要があります。クライアントはREADからNFS4ERR_LOCKEDを取り戻すか、のために適切な共有の予約を持つファイルに書き込むと、所与のファイルのロック必須ファイルの存在が示されています。強制ロックは、ファイルのために有効である場合には、クライアントが読み取りまたは書き込まれるデータのための適切なファイルロックを確認する必要があります。ロックが読み取りまたは書き込まれている範囲に存在する場合、クライアントは、クライアントの検証キャッシュを使用して要求を満たすようにしてもよいです。適切なファイルロックは、読み取りの範囲で保有または書き込み、読み取りまたは書き込み要求されていない場合は、クライアントのキャッシュによって満たされなければならないと要求を処理するためにサーバーに送信する必要があります。読み取りまたは書き込み要求が部分的にロックされた領域と重なる場合、要求が適切に処理（ロックされたかどうか）は、各領域を有する複数の部分に細分されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.4. Data Caching and File Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3.4。データキャッシングとファイルアイデンティティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When clients cache data, the file data needs to be organized according to the filesystem object to which the data belongs. For NFS version 3 clients, the typical practice has been to assume for the purpose of caching that distinct filehandles represent distinct filesystem objects. The client then has the choice to organize and maintain the data cache on this basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがデータをキャッシュすると、ファイルデータは、データが属するファイルシステムの目的に応じて整理する必要があります。 NFSバージョン3つのクライアントのために、典型的な実施は、別個のファイルハンドルが別個のファイルシステムオブジェクトを表すキャッシングのために仮定することでした。その後、クライアントはこれに基づいてデータキャッシュを整理し、維持するための選択肢を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFS version 4 protocol, there is now the possibility to have significant deviations from a &#34;one filehandle per object&#34; model because a filehandle may be constructed on the basis of the object&#39;s pathname. Therefore, clients need a reliable method to determine if two filehandles designate the same filesystem object. If clients were simply to assume that all distinct filehandles denote distinct objects and proceed to do data caching on this basis, caching inconsistencies would arise between the distinct client side objects which mapped to the same server side object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルは、オブジェクトのパス名に基づいて構築することができるので、NFSバージョン4プロトコルでは、「一のファイルハンドルオブジェクトごとに」モデルから有意な偏差を持っている可能性が今あります。したがって、クライアントは、二つのファイルハンドルは、同じファイルシステムのオブジェクトを指定する場合に信頼性の高い方法を決定する必要があります。クライアントは単純にすべての個別のファイルハンドルが別個のオブジェクトを表すことを前提とし、これに基づいてデータのキャッシュを行うに進みした場合、キャッシュの不整合は、同じサーバー側オブジェクトにマッピングされた個別のクライアント側のオブジェクト間で生じるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By providing a method to differentiate filehandles, the NFS version 4 protocol alleviates a potential functional regression in comparison with the NFS version 3 protocol. Without this method, caching inconsistencies within the same client could occur and this has not been present in previous versions of the NFS protocol. Note that it is possible to have such inconsistencies with applications executing on multiple clients but that is not the issue being addressed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルハンドルを区別するための方法を提供することによって、NFSバージョン4プロトコルは、NFSバージョン3プロトコルと比較して潜在的な機能的回帰を緩和します。この方法がなければ、同じクライアント内のキャッシュの不整合が発生する可能性があり、これは、NFSプロトコルの以前のバージョンに存在していませんでした。複数のクライアント上で実行されるアプリケーションと、そのような矛盾を持つことが可能であるが、それはここで扱われている問題ではないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of data caching, the following steps allow an NFS version 4 client to determine whether two distinct filehandles denote the same server side object: o If GETATTR directed to two filehandles returns different values of the fsid attribute, then the filehandles represent distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTRは、2つのファイルハンドルに向けられている場合は、FSID属性の異なる値を返すO、次にファイルハンドルが別個のオブジェクトを表す：データキャッシュの目的のために、次の手順は、NFSバージョン4クライアントは、2つの別個のファイルハンドルは、同じサーバー側のオブジェクトを表すかどうかを決定することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR for any file with an fsid that matches the fsid of the two filehandles in question returns a unique_handles attribute with a value of TRUE, then the two objects are distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題の2つのファイルハンドルのFSIDと一致するFSIDを持つ任意のファイルのGETATTRがunique_handlesがTRUEの値を持つ属性を返した場合、O、その後、2つのオブジェクトが異なっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR directed to the two filehandles does not return the fileid attribute for both of the handles, then it cannot be determined whether the two objects are the same. Therefore, operations which depend on that knowledge (e.g., client side data caching) cannot be done reliably.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTRは、2つのファイルハンドルに向けられた場合、Oハンドルの両方のためFILEID属性を返さない、2つのオブジェクトが同一であるか否かを判断することはできません。したがって、その知識（例えば、クライアント側データキャッシュ）に依存する操作を確実に行うことができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If GETATTR directed to the two filehandles returns different values for the fileid attribute, then they are distinct objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTRは、2つのファイルハンドルに向けFILEID属性の異なる値を返す場合、O、それらは別個のオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise they are the same object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれ以外の場合は、同じオブジェクトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4。オープン委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a file is being OPENed, the server may delegate further handling of opens and closes for that file to the opening client. Any such delegation is recallable, since the circumstances that allowed for the delegation are subject to change. In particular, the server may receive a conflicting OPEN from another client, the server must recall the delegation before deciding whether the OPEN from the other client may be granted. Making a delegation is up to the server and clients should not assume that any particular OPEN either will or will not result in an open delegation. The following is a typical set of conditions that servers might use in deciding whether OPEN should be delegated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルが開かれている場合は、サーバーがオープンのさらなる取り扱いを委任し、開口部クライアントにそのファイルを閉じて。委任に対して許可状況が変更される場合がありますので、任意のそのような委任は、リコールです。特に、サーバは別のクライアントから競合OPENを受けることができる、サーバーは他のクライアントからのOPENを付与することができるかどうかを決定する前に委任を思い出す必要があります。委任を作ることはどちらかのいずれかの特定のOPENがまたは開いている委譲にはなりませんだろうと想定してはならない、サーバーとクライアント次第です。以下は、サーバーがOPENを委任する必要があるかどうかを決定する際に使用する可能性のある条件の典型的なセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client must be able to respond to the server&#39;s callback requests. The server will use the CB_NULL procedure for a test of callback ability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントは、サーバーのコールバック要求に応答できなければなりません。サーバーは、コールバック機能のテストのためにCB_NULLプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client must have responded properly to previous recalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントは、以前のリコールに適切に対応している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There must be no current open conflicting with the requested delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O要求された代表団とは、現在開いている矛盾があってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There should be no current delegation that conflicts with the delegation being requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O委任が要求されていると競合するどんな現在の代表団があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The probability of future conflicting open requests should be low based on the recent history of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oオープン要求が競合し、将来の確率が低いファイルの最近の履歴に基づくべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The existence of any server-specific semantics of OPEN/CLOSE that would make the required handling incompatible with the prescribed handling that the delegated client would apply (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要な規定の委任クライアントが適用されることを扱うと互換性の取り扱いになるだろうOPEN / CLOSEの任意のサーバ固有の意味の存在O（下記参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two types of open delegations, read and write. A read open delegation allows a client to handle, on its own, requests to open a file for reading that do not deny read access to others. Multiple read open delegations may be outstanding simultaneously and do not conflict. A write open delegation allows the client to handle, on its own, all opens. Only one write open delegation may exist for a given file at a given time and it is inconsistent with any read open delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン委譲の2種類、読み取りと書き込みがあります。読んで開いている委譲は、他人への読み取りアクセスを拒否していない読書のためのファイルを開くには、独自の、要求に、クライアントが処理することができます。複数の読み取りオープンの代表団が同時に優れたことと競合しないことがあります。書き込みオープン委譲が独自に、クライアントが処理することができ、すべてが表示されます。一つだけの書き込みオープン委譲は、与えられた時間に指定したファイルの存在する可能性があり、それはどの読んオープン委譲と矛盾しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has a read open delegation, it may not make any changes to the contents or attributes of the file but it is assured that no other client may do so. When a client has a write open delegation, it may modify the file data since no other client will be accessing the file&#39;s data. The client holding a write delegation may only affect file attributes which are intimately connected with the file data: size, time_modify, change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが読ん開いている委譲を持っている場合は、ファイルの内容や属性を変更しないかもしれないが、他のクライアントがそうしないことが保証されています。クライアントが書き込みオープン委譲を持っている場合は、他のクライアントがファイルのデータにアクセスできなくなりますので、ファイルのデータを変更することがあります。サイズ、time_modify、変更：書き込み委託を保持しているクライアントは、密接にファイルデータに接続されているファイルの属性に影響を与える可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has an open delegation, it does not send OPENs or CLOSEs to the server but updates the appropriate status internally. For a read open delegation, opens that cannot be handled locally (opens for write or that deny read access) must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが開いている委譲を持っているときは、サーバーに開閉するを送ったが、内部で適切なステータスを更新しません。読んで開いている委譲のために、それがサーバーに送信されなければならない（書き込みのために開くか、その読み拒否アクセス）ローカルで処理することができません開きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an open delegation is made, the response to the OPEN contains an open delegation structure which specifies the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開いている委譲が行われると、OPENへの応答は次のように指定するオープン委譲構造が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the type of delegation (read or write)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代表団のタイプO（読み取りまたは書き込み）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o space limitation information to control flushing of data on close (write open delegation only, see the section &#34;Open Delegation and Data Caching&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oスペースの制限情報が近い上のデータのフラッシュを制御する（セクション「オープン委任やデータキャッシング」を参照してください、唯一のオープン委譲を書きます）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o an nfsace4 specifying read and write permissions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読み取りおよび書き込み権限を指定nfsace4 O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o a stateid to represent the delegation for READ and WRITE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのstateidはREADとWRITEのための委任を表現します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The delegation stateid is separate and distinct from the stateid for the OPEN proper. The standard stateid, unlike the delegation stateid, is associated with a particular lock_owner and will continue to be valid after the delegation is recalled and the file remains open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任のstateidはOPEN適切ためのstateidから独立した別個です。標準のstateidは、委任のstateidとは異なり、特定のlock_ownerに関連付けられており、委任がリコールされた後に有効であり続けるであろうと、ファイルは開いたままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a request internal to the client is made to open a file and open delegation is in effect, it will be accepted or rejected solely on the basis of the following conditions. Any requirement for other checks to be made by the delegate should result in open delegation being denied so that the checks can be made by the server itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントへの内部要求がファイルを開くために作られ、開いている委譲が有効になっている場合、それは受け入れられたか、次の条件のみに基づいて拒否されます。チェックはサーバ自体によって行うことができるように、デリゲートによってなされる他のチェックのためにどのような要件が拒否され開いている委譲を生じるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The access and deny bits for the request and the file as described in the section &#34;Share Reservations&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスoおよびセクション「共有予約」に記載されているように要求し、ファイルのビットを否定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The read and write permissions as determined below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読み取りおよび書き込み権限O以下決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfsace4 passed with delegation can be used to avoid frequent ACCESS calls. The permission check should be as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代表団に渡さnfsace4は、頻繁にアクセス呼び出しを回避するために使用することができます。次のようにパーミッションチェックは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the nfsace4 indicates that the open may be done, then it should be granted without reference to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O nfsace4は、それがサーバーを参照することなく付与されなければならない、オープンを行うことができることを示している場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the nfsace4 indicates that the open may not be done, then an ACCESS request must be sent to the server to obtain the definitive answer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfsace4がオープンが行われない可能性があることを示した場合は、O、その後、アクセス要求は、決定的な答えを得るために、サーバーに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server may return an nfsace4 that is more restrictive than the actual ACL of the file. This includes an nfsace4 that specifies denial of all access. Note that some common practices such as mapping the traditional user &#34;root&#34; to the user &#34;nobody&#34; may make it incorrect to return the actual ACL of the file in the delegation response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ファイルの実際のACLよりも制限さnfsace4を返すことがあります。これは、すべてのアクセスの拒否を指定nfsace4が含まれています。こうしたユーザー「誰」に伝統的なユーザー「root」をマッピングするなど、いくつかの一般的な慣行が、それは間違った委任応じて、ファイルの実際のACLを返すように作ることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of delegation together with various other forms of caching creates the possibility that no server authentication will ever be performed for a given user since all of the user&#39;s requests might be satisfied locally. Where the client is depending on the server for authentication, the client should be sure authentication occurs for each user by use of the ACCESS operation. This should be the case even if an ACCESS operation would not be required otherwise. As mentioned before, the server may enforce frequent authentication by returning an nfsace4 denying all access with every open delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシングの様々な他の形態と一緒に委任の使用は、ユーザーのすべての要求をローカルに満足されることがありますので、何のサーバ認証が今まで与えられたユーザのために実行されません可能性が作成されます。クライアントが認証のためのサーバに依存している場合は、クライアントは、認証がアクセス動作を使用することによって、ユーザーごとに発生したことを確認する必要があります。これは、アクセス動作がそうでなければ必要とされない場合でも同様である必要があります。前に述べたように、サーバーはすべての開いている委譲を持つすべてのアクセスを拒否nfsace4を返すことによって、頻繁に認証を強制することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.1. Open Delegation and Data Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.1。オープン委任およびデータキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN delegation allows much of the message overhead associated with the opening and closing files to be eliminated. An open when an open delegation is in effect does not require that a validation message be sent to the server. The continued endurance of the &#34;read open delegation&#34; provides a guarantee that no OPEN for write and thus no write has occurred. Similarly, when closing a file opened for write and if write open delegation is in effect, the data written does not have to be flushed to the server until the open delegation is recalled. The continued endurance of the open delegation provides a guarantee that no open and thus no read or write has been done by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN代表団は、ファイルを開いたり閉じ関連付けられているメッセージオーバーヘッドの多くは解消することができます。開いている委譲が有効になっているオープンは、検証メッセージをサーバーに送信する必要はありません。 「読んで開いている委譲」の継続的な耐久性はありません書き込みのためOPENので、何の書き込みが発生していない保証を提供します。同様に閉じるときに、ファイルが書き込みのためにオープンし、書き込みオープン委譲が有効な場合、書き込まれたデータは、開いている委譲が呼び出されるまで、サーバーにフラッシュする必要はありません。開いている委譲の継続的な耐久性は、このようにオープンし、何の読み取りまたは書き込みまったく別のクライアントによって行われていないという保証を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of open delegation, READs and WRITEs done without an OPEN are treated as the functional equivalents of a corresponding type of OPEN. This refers to the READs and WRITEs that use the special stateids consisting of all zero bits or all one bits. Therefore, READs or WRITEs with a special stateid done by another client will force the server to recall a write open delegation. A WRITE with a special stateid done by another client will force a recall of read open delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープン委譲の目的のために、読み取り、OPENなく行わ書き込みがOPENの対応するタイプの機能的等価物として扱われます。これは、読み取り、すべてのゼロのビット又は全て1個のビットからなる特別のstateidsを使用するのWRITEを指します。そのため、読み取りや書き込みオープン委譲を思い出すために、サーバーを強制的に別のクライアントによって行わ特別なstateidで書き込みます。別の顧客によって行わ特別なstateidとのWRITEは読まオープン委譲のリコールを強制します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With delegations, a client is able to avoid writing data to the server when the CLOSE of a file is serviced. The file close system call is the usual point at which the client is notified of a lack of stable storage for the modified file data generated by the application. At the close, file data is written to the server and through normal accounting the server is able to determine if the available filesystem space for the data has been exceeded (i.e., server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT). This accounting includes quotas. The introduction of delegations requires that a alternative method be in place for the same type of communication to occur between client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代表団では、クライアントは、ファイルのCLOSEがサービスされているサーバへのデータの書き込みを避けることができます。ファイルクローズシステムコールは、クライアントがアプリケーションによって生成された変更されたファイルデータの保存安定性の不足が通知される通常のポイントです。 （すなわち、サーバはNFS4ERR_NOSPC又はNFS4ERR_DQUOTを返す）近くで、ファイルデータがサーバーに書き込まれ、通常を通じてサーバアカウンティング、データに利用可能なファイルシステムスペースを超えているかどうかを判断することができます。この会計は、クォータが含まれています。代表団の導入は、別の方法は、クライアントとサーバーの間で発生する通信の同じタイプのための場所であることが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the delegation response, the server provides either the limit of the size of the file or the number of modified blocks and associated block size. The server must ensure that the client will be able to flush data to the server of a size equal to that provided in the original delegation. The server must make this assurance for all outstanding delegations. Therefore, the server must be careful in its management of available space for new or modified data taking into account available filesystem space and any applicable quotas. The server can recall delegations as a result of managing the available filesystem space. The client should abide by the server&#39;s state space limits for delegations. If the client exceeds the stated limits for the delegation, the server&#39;s behavior is undefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任応答して、サーバは、ファイルまたは変更されたブロックの数と関連したブロックサイズの大きさの制限のいずれかを提供します。サーバーは、クライアントが、元代表団に提供されるものに等しいサイズのサーバにデータをフラッシュすることができるようになりますことを確認する必要があります。サーバーはすべての未処理の代表団のために、この保証をしなければなりません。そのため、サーバは、アカウント有効なファイルシステムのスペースおよび適用クォータを考慮して、新規または変更されたデータのために利用可能なスペースの経営で注意しなければなりません。サーバーは、使用可能なファイルシステム領域の管理の結果として、代表団を思い出すことができます。クライアントは、代表団のために、サーバの状態空間の制限を遵守しなければなりません。クライアントは、委譲のために述べた制限を超えた場合は、サーバーの動作は未定義です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on server conditions, quotas or available filesystem space, the server may grant write open delegations with very restrictive space limitations. The limitations may be defined in a way that will always force modified data to be flushed to the server on close.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの状況、クォータまたは使用可能なファイルシステムの容量に基づいて、サーバーは非常に制限容量の制限付きオープン委任を書く与えることができます。制限は、常に近くにサーバーにフラッシュされるように変更されたデータを強制する方法で定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With respect to authentication, flushing modified data to the server after a CLOSE has occurred may be problematic. For example, the user of the application may have logged off the client and unexpired authentication credentials may not be present. In this case, the client may need to take special care to ensure that local unexpired credentials will in fact be available. This may be accomplished by tracking the expiration time of credentials and flushing data well in advance of their expiration or by making private copies of credentials to assure their availability when needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証に関しては、CLOSEが発生した後、サーバーに変更されたデータをフラッシュすることは問題となり得ます。たとえば、アプリケーションのユーザは、クライアントがログオフしていることと、有効期限内の認証資格情報は存在しないかもしれません。この場合、クライアントは、ローカルの期限が切れていない証明書が実際に利用可能になることを保証するために特別な注意を払う必要があるかもしれません。これは、資格証明書の有効期限を追跡し、その有効期限の事前にデータをフラッシュするか、必要なときに自分の可用性を保証するために資格のプライベートコピーを作成することによって達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.2. Open Delegation and File Locks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.2。開いている委譲とファイルロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds a write open delegation, lock operations may be performed locally. This includes those required for mandatory file locking. This can be done since the delegation implies that there can be no conflicting locks. Similarly, all of the revalidations that would normally be associated with obtaining locks and the flushing of data associated with the releasing of locks need not be done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが書き込みオープン委譲を保持している場合は、ロック操作はローカルで実行することができます。これは必須ファイルのロックに必要なものも含まれます。代表団は、競合するロックがないことを意味するので、これは行うことができます。同様に、通常は入手ロックとロックの解除に関連したデータのフラッシュに関連付けられる再確認のすべてが行われる必要がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client holds a read open delegation, lock operations are not performed locally. All lock operations, including those requesting non-exclusive locks, are sent to the server for resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが読ん開いている委譲を保持している場合は、ロックの操作はローカルで実行されていません。非排他的ロックを要求するものも含め、すべてのロック操作は、解決のためにサーバに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.3. Handling of CB_GETATTR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.3。 CB_GETATTRの取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server needs to employ special handling for a GETATTR where the target is a file that has a write open delegation in effect. The reason for this is that the client holding the write delegation may have modified the data and the server needs to reflect this change to the second client that submitted the GETATTR. Therefore, the client holding the write delegation needs to be interrogated. The server will use the CB_GETATTR operation. The only attributes that the server can reliably query via CB_GETATTR are size and change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、ターゲットが有効な書き込みオープン委譲を持つファイルであるGETATTRのための特別な処理を採用する必要があります。この理由は、書き込み委託を保持しているクライアントがデータを変更した可能性と、サーバーがGETATTRを提出した2番目のクライアントにこの変更を反映する必要があるということです。そのため、書き込み委託を保持しているクライアントを尋問する必要があります。サーバーはCB_GETATTR操作を使用します。唯一のサーバが確実にサイズと変更されているCB_GETATTR経由で照会することができることを属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since CB_GETATTR is being used to satisfy another client&#39;s GETATTR request, the server only needs to know if the client holding the delegation has a modified version of the file. If the client&#39;s copy of the delegated file is not modified (data or size), the server can satisfy the second client&#39;s GETATTR request from the attributes stored locally at the server. If the file is modified, the server only needs to know about this modified state. If the server determines that the file is currently modified, it will respond to the second client&#39;s GETATTR as if the file had been modified locally at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_GETATTRは、別のクライアントのGETATTR要求を満たすために使用されているので、サーバは委任を保持しているクライアントは、ファイルの修正バージョンを持っているかどうかを知る必要があります。委任ファイルのクライアントのコピーが（データまたはサイズ）に変更されていない場合、サーバは、サーバにローカルに保存された属性から2番目のクライアントのGETATTR要求を満たすことができます。ファイルが変更されている場合は、サーバーにのみ、この修正された状態について知る必要があります。サーバーは、ファイルが現在変更されていると判断した場合は、ファイルをサーバーでローカルに変更されたかのように、それは2番目のクライアントのGETATTRに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the form of the change attribute is determined by the server and is opaque to the client, the client and server need to agree on a method of communicating the modified state of the file. For the size attribute, the client will report its current view of the file size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変化属性の形式は、サーバによって決定され、クライアントに不透明であるされているので、クライアントとサーバーは、ファイルの変更された状態を通信する方法に同意する必要があります。サイズ属性の場合、クライアントは、ファイルサイズの現在の見解を報告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the change attribute, the handling is more involved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変化属性の場合、取り扱いはより複雑です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the client, the following steps will be taken when receiving a write delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込み委託を受けたときに、クライアントの場合は、以下のステップが行われます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value of the change attribute will be obtained from the server and cached. Let this value be represented by c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O変化属性の値は、サーバーから取得し、キャッシュされます。この値はcで表すことがしてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client will create a value greater than c that will be used for communicating modified data is held at the client. Let this value be represented by d.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントは、クライアントに保持されている修正されたデータを通信するために使用されるCよりも大きい値を作成します。この値をdで表すことがしてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the client is queried via CB_GETATTR for the change attribute, it checks to see if it holds modified data. If the file is modified, the value d is returned for the change attribute value. If this file is not currently modified, the client returns the value c for the change attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが変更属性のCB_GETATTR経由で照会すると、O、それが変更されたデータを保持しているかどうかを確認します。ファイルが変更されている場合は、値dが変化属性値に返されます。このファイルは、現在変更されていない場合、クライアントは、変更属性の値cを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For simplicity of implementation, the client MAY for each CB_GETATTR return the same value d. This is true even if, between successive CB_GETATTR operations, the client again modifies in the file&#39;s data or metadata in its cache. The client can return the same value because the only requirement is that the client be able to indicate to the server that the client holds modified data. Therefore, the value of d may always be c + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装を簡単にするために、各CB_GETATTRのクライアントMAYは同じ値dを返します。これは場合にも当てはまり、連続CB_GETATTR操作の間、クライアントは再びそのキャッシュ内のファイルのデータやメタデータに変更します。唯一の要件は、クライアントは、クライアントが変更されたデータを保持するサーバに指示することができるということであるため、クライアントが同じ値を返すことができます。したがって、Dの値は常にC + 1であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the change attribute is opaque to the client in the sense that it has no idea what units of time, if any, the server is counting change with, it is not opaque in that the client has to treat it as an unsigned integer, and the server has to be able to see the results of the client&#39;s changes to that integer. Therefore, the server MUST encode the change attribute in network order when sending it to the client. The client MUST decode it from network order to its native order when receiving it and the client MUST encode it network order when sending it to the server. For this reason, change is defined as an unsigned integer rather than an opaque array of octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変化属性は、それはサーバーの変更をカウントしている時間の何単位があれば、何のアイデアを持っていないという意味で、クライアントに不透明であるが、それは、クライアントが符号なし整数として扱う必要があることで不透明ではなく、サーバーは、その整数に対するクライアントの変更の結果を確認することができなければなりません。それをクライアントに送信するときにそのため、サーバがネットワーク順に変化属性を符号化しなければなりません。それを受信したとき、クライアントはその本来の順序にネットワークオーダーからそれをデコードしなければならないし、それをサーバーに送信するときに、クライアントはネットワークの順に符号化しなければなりません。この理由のために、変化は、符号なし整数ではなくオクテットの不透明な配列として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the server, the following steps will be taken when providing a write delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込み委託を提供する場合、サーバの場合は、以下のステップが行われます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Upon providing a write delegation, the server will cache a copy of the change attribute in the data structure it uses to record the delegation. Let this value be represented by sc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O書き込み委任を提供する際に、サーバーは、それが委任を記録するために使用するデータ構造に変化属性のコピーをキャッシュします。この値は、SCで表すことがしてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a second client sends a GETATTR operation on the same file to the server, the server obtains the change attribute from the first client. Let this value be cc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2番目のクライアントがサーバに同じファイルにGETATTR操作を送信すると、O、サーバは、最初のクライアントからの変化属性を取得します。この値はccでみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the value cc is equal to sc, the file is not modified and the server returns the current values for change, time_metadata, and time_modify (for example) to the second client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値CCは皮下に等しい場合、O、ファイルが変更され、サーバは、第2のクライアントへの変化、time_metadata、および（例えば）time_modifyの現在の値が返されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the value cc is NOT equal to sc, the file is currently modified at the first client and most likely will be modified at the server at a future time. The server then uses its current time to construct attribute values for time_metadata and time_modify. A new value of sc, which we will call nsc, is computed by the server, such that nsc &gt;= sc + 1. The server then returns the constructed time_metadata, time_modify, and nsc values to the requester. The server replaces sc in the delegation record with nsc. To prevent the possibility of time_modify, time_metadata, and change from appearing to go backward (which would happen if the client holding the delegation fails to write its modified data to the server before the delegation is revoked or returned), the server SHOULD update the file&#39;s metadata record with the constructed attribute values. For reasons of reasonable performance, committing the constructed attribute values to stable storage is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値CCがSCに等しいされていない場合は、O、ファイルは現在、最初のクライアントで変更され、最も可能性の高い将来の時点でサーバーに変更されます。次に、サーバーはtime_metadataとtime_modifyの属性値を構築するために、現在の時刻を使用しています。我々は、NSCを呼び出すSCの新しい値は、NSC&gt; = SC + 1サーバは次いで、要求元に構築time_metadata、time_modify、およびNSC値を返すように、サーバによって計算されます。サーバーは、NSCとの委任レコードにSCを置き換えます。 time_modify、time_metadataの可能性を防止し、後方に行くように見えるから変更するには、サーバがファイルのを更新する必要があります（これは、委任を保持しているクライアントは、委任が取り消さまたは返される前に、サーバーにその変更されたデータの書き込みに失敗した場合に発生します）構成された属性値を持つメタデータレコード。妥当な性能の理由から、安定したストレージに構成された属性値をコミットすることは任意です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
As discussed earlier in this section, the client MAY return the same cc value on subsequent CB_GETATTR calls, even if the file was modified in the client&#39;s cache yet again between successive CB_GETATTR calls. Therefore, the server must assume that the file has been modified yet again, and MUST take care to ensure that the new nsc it constructs and returns is greater than the previous nsc it returned. An example implementation&#39;s delegation record would satisfy this mandate by including a boolean field (let us call it &#34;modified&#34;) that is set to false when the delegation is granted, and an sc value set at the time of grant to the change attribute value. The modified field would be set to true the first time cc != sc, and would stay true until the delegation is returned or revoked. The processing for constructing nsc, time_modify, and time_metadata would use this pseudo code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このセクションですでに述べたように、クライアントは、ファイルが連続したCB_GETATTRの呼び出しの間に再びまだ、クライアントのキャッシュに変更された場合でも、その後のCB_GETATTRの呼び出しで同じCC値を返すことがあります。そのため、サーバーは、ファイルが再び変更されていることを前提としなければならない、そしてそれは構築し、返す新しいNSCはそれが返され、前のNSC以上であることを保証するために注意しなければなりません。実装例の委任レコードは、委任が許可されている場合はfalseに設定されたbooleanフィールド（私たちは、「修正」と呼んでみましょう）、および変更の属性値に付与時に設定SC値を含むことによって、この任務を満たすでしょう。変更されたフィールドは=皮下！真初めてccに設定されるだろう、と委任を返すか、取り消されるまで、真とどまります。 NSCを構築するための処理、time_modify、およびtime_metadataは、この擬似コードを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
if (!modified) { do CB_GETATTR for change and size;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（！が変更された）場合は{変化やサイズのためCB_GETATTRを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             if (cc != sc)
                 modified = TRUE;
         } else {
                 do CB_GETATTR for size;
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         if (modified) {
             sc = sc + 1;
          time_modify = time_metadata = current_time; update sc, time_modify, time_metadata into file&#39;s metadata;
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
return to client (that sent GETATTR) the attributes it requested, but make sure size comes from what CB_GETATTR returned. Do not update the file&#39;s metadata with the client&#39;s modified size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
それは要求された属性（GETATTRを送信された）クライアントに返しますが、サイズはCB_GETATTRが返さ何から来ていることを確認してください。クライアントの変更サイズのファイルのメタデータを更新しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the case that the file attribute size is different than the server&#39;s current value, the server treats this as a modification regardless of the value of the change attribute retrieved via CB_GETATTR and responds to the second client as in the last step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oファイル属性のサイズがサーバの現在の値と異なる場合は、関係なく、変化属性CB_GETATTR経由で取得し、最後のステップのように、第2のクライアントに応答の値の変更などのサーバー扱いこれ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This methodology resolves issues of clock differences between client and server and other scenarios where the use of CB_GETATTR break down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この方法は、クライアントとサーバとCB_GETATTRの使用が打破他のシナリオ間のクロック差の問題を解決します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that the server is under no obligation to use CB_GETATTR and therefore the server MAY simply recall the delegation to avoid its use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがCB_GETATTRを使用するため、サーバは単にその使用を避けるために、委任を思い出すかもしれ義務を負いませんことに留意すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.4. Recall of Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.4。オープン委任のリコール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following events necessitate recall of an open delegation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のイベントが開いている委譲のリコールを余儀なく：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Potentially conflicting OPEN request (or READ/WRITE done with &#34;special&#34; stateid)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O潜在的OPEN要求（または &#34;特別&#34; なstateidで行わREAD / WRITE）を矛盾
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SETATTR issued by another client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SETATTR別のクライアントによって発行されました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o REMOVE request for the file
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルに対する要求を削除するには
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RENAME request for the file as either source or target of the RENAME
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RENAMEのソースまたはターゲットとしてファイルの要求の名前を変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whether a RENAME of a directory in the path leading to the file results in recall of an open delegation depends on the semantics of the server filesystem. If that filesystem denies such RENAMEs when a file is open, the recall must be performed to determine whether the file in question is, in fact, open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
開いている委譲のリコールで、ファイルの結果につながるパス内のディレクトリのRENAMEかどうかは、サーバーのファイルシステムのセマンティクスに依存します。ファイルが開いているときにそのファイルシステムは、このような名前に変更を拒否した場合、リコールは、問題のファイルは、実際には、開いているかどうかを決定するために行われなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the situations above, the server may choose to recall open delegations at any time if resource constraints make it advisable to do so. Clients should always be prepared for the possibility of recall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の状況に加えて、サーバは、リソースの制約がそうすることをお勧めします場合はいつでも開いている委任をリコールすることもできます。クライアントは常にリコールの可能性のために準備されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives a recall for an open delegation, it needs to update state on the server before returning the delegation. These same updates must be done whenever a client chooses to return a delegation voluntarily. The following items of state need to be dealt with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが開いている委譲のためのリコールを受信すると、それは代表団を返す前に、サーバー上での状態を更新する必要があります。これらの同じ更新は、クライアントが自発的に委任を返すことを選択したときに行われなければなりません。状態の以下の項目が扱われる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the file associated with the delegation is no longer open and no previous CLOSE operation has been sent to the server, a CLOSE operation must be sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代表団に関連付けられたファイルは、もはや開いていて、以前のCLOSE操作がサーバーに送信されていない場合は、O、CLOSE操作がサーバーに送信されませんする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a file has other open references at the client, then OPEN operations must be sent to the server. The appropriate stateids will be provided by the server for subsequent use by the client since the delegation stateid will not longer be valid. These OPEN requests are done with the claim type of CLAIM_DELEGATE_CUR. This will allow the presentation of the delegation stateid so that the client can establish the appropriate rights to perform the OPEN. (see the section &#34;Operation 18: OPEN&#34; for details.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがクライアントで開いている他の参照を持っている場合は、O、その後、OPEN操作はサーバに送信する必要があります。委任のstateidは、もはや有効ではありませんので、適切なのstateidsは、クライアントによって、その後の使用のために、サーバによって提供されます。これらのOPEN要求はCLAIM_DELEGATE_CURの請求タイプで行われます。クライアントがOPENを実行するための適切な権限を確立できるように、これは、委任のstateidのプレゼンテーションが可能になります。 （セクション「操作18：OPEN」を参照してください。詳細については、を）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there are granted file locks, the corresponding LOCK operations need to be performed. This applies to the write open delegation case only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルロックが付与されている場合は、O、対応するロック操作を実行する必要があります。これは、書き込みオープン委譲場合にのみ適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For a write open delegation, if at the time of recall the file is not open for write, all modified data for the file must be flushed to the server. If the delegation had not existed, the client would have done this data flush before the CLOSE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リコール時にファイルが書き込みのために開かれていない場合はO書き込みオープン委譲については、ファイルのすべての変更されたデータをサーバーにフラッシュする必要があります。代表団が存在していなかった場合、クライアントはCLOSE操作の前に、このデータフラッシュを行っているでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For a write open delegation when a file is still open at the time of recall, any modified data for the file needs to be flushed to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込みオープン委譲のためのOファイルはリコールの時にまだ開いている、ファイルの任意の変更されたデータをサーバーにフラッシュする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o With the write open delegation in place, it is possible that the file was truncated during the duration of the delegation. For example, the truncation could have occurred as a result of an OPEN UNCHECKED with a size attribute value of zero. Therefore, if a truncation of the file has occurred and this operation has not been propagated to the server, the truncation must occur before any modified data is written to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代わりに書き込みオープン委譲してO、ファイルが委任の期間中に切り捨てられた可能性があります。たとえば、切り捨てがゼロのサイズの属性値を持つOPEN UNCHECKEDの結果として発生した可能性があります。ファイルの切り捨てが発生していると、この操作は、サーバーに伝播されていない場合、任意の変更されたデータがサーバーに書き込まれる前にそのため、切り捨てが行われなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of write open delegation, file locking imposes some additional requirements. To precisely maintain the associated invariant, it is required to flush any modified data in any region for which a write lock was released while the write delegation was in effect. However, because the write open delegation implies no other locking by other clients, a simpler implementation is to flush all modified data for the file (as described just above) if any write lock has been released while the write open delegation was in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込みオープン委譲の場合は、ファイルロックは、いくつかの追加の要件を課します。正確関連不変を維持するために、書き込み委譲が有効であった書き込みロックが解放されたため、任意の領域内の任意の変更されたデータをフラッシュする必要があります。書き込みオープン委譲は、他のクライアントが他のロックを意味しないためしかし、より簡単な実装は、（ちょうど上記のように）書き込みオープン委譲が有効であった任意の書き込みロックが解除された場合、ファイルのすべての変更されたデータをフラッシュすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation need not wait until delegation recall (or deciding to voluntarily return a delegation) to perform any of the above actions, if implementation considerations (e.g., resource availability constraints) make that desirable. Generally, however, the fact that the actual open state of the file may continue to change makes it not worthwhile to send information about opens and closes to the server, except as part of delegation return. Only in the case of closing the open that resulted in obtaining the delegation would clients be likely to do this early, since, in that case, the close once done will not be undone. Regardless of the client&#39;s choices on scheduling these actions, all must be performed before the delegation is returned, including (when applicable) the close that corresponds to the open that resulted in the delegation. These actions can be performed either in previous requests or in previous operations in the same COMPOUND request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、実装上の考慮事項は、（例えば、リソースの可用性の制約）ことが望ましくする場合は、上記のいずれかのアクションを実行するために、委任のリコール（または自主的に委任を返すように決定）まで待つ必要はありません。しかしながら、一般的には、ファイルの実際のオープン状態が変化し続けているという事実が開き、委任リターンの一部として以外に、サーバーに閉じについて、それは価値がない情報を送信することができます。その場合には、一度行わ近いが取り消されることはありません、ので、唯一の代表団を得ることになったのオープンを閉じる場合にクライアントは、早期にこれを実行する可能性が高いだろう。委任が返される前にかかわらず、これらのアクションをスケジュール上のクライアントの選択肢の、すべては（該当する場合）の代表団が生じオープンに対応して近くを含め、実行する必要があります。これらのアクションは、以前の要求または同じCOMPOUND要求で以前の操作のいずれかで行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.5. Clients that Fail to Honor Delegation Recalls
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.5。委任リコールを称えるために失敗したクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may fail to respond to a recall for various reasons, such as a failure of the callback path from server to the client. The client may be unaware of a failure in the callback path. This lack of awareness could result in the client finding out long after the failure that its delegation has been revoked, and another client has modified the data for which the client had a delegation. This is especially a problem for the client that held a write delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーからクライアントへのコールバックパスの障害など、さまざまな理由でリコールへの対応に失敗することがあります。クライアントは、コールバックパスの障害に気づかないかもしれません。意識の欠如は、クライアントがその代表団が取り消された障害が発生した後、長い見つけると、別のクライアントは、クライアントが委任を持っていたため、データを変更したにつながる可能性があります。これは特に、書き込みの委任を開催クライアントの問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server also has a dilemma in that the client that fails to respond to the recall might also be sending other NFS requests, including those that renew the lease before the lease expires. Without returning an error for those lease renewing operations, the server leads the client to believe that the delegation it has is in force.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、サーバは、リコールへの応答に失敗したクライアントは、リースの期限が切れる前にリースを更新するものを含め、他のNFS要求を送信されるかもしれないというジレンマがあります。操作を更新、これらのリースのためのエラーを返さずに、サーバーは、それが持っている代表団が力であることを信じるようにクライアントをリードしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This difficulty is solved by the following rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この難しさは、次の規則によって解決されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the callback path is down, the server MUST NOT revoke the delegation if one of the following occurs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックパスがダウンしている場合は、次のいずれかが発生した場合、O、サーバが委任を取り消してはなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The client has issued a RENEW operation and the server has returned an NFS4ERR_CB_PATH_DOWN error. The server MUST renew the lease for any record locks and share reservations the client has that the server has known about (as opposed to those locks and share reservations the client has established but not yet sent to the server, due to the delegation). The server SHOULD give the client a reasonable time to return its delegations to the server before revoking the client&#39;s delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - クライアントがRENEW操作を発行している、サーバがNFS4ERR_CB_PATH_DOWNエラーを返しました。サーバーは、クライアントがサーバが（クライアントが確立したが、まだサーバに送信されていない、代表団のためにしているそれらのロックと共有の予約ではなく）については知られていることを持っているすべてのレコードロックとシェアの予約のためのリースを更新しなければなりません。サーバーはクライアントに、クライアントの代表団を取り消す前に、サーバーへの委任を返すために合理的な時間を与える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The client has not issued a RENEW operation for some period of time after the server attempted to recall the delegation. This period of time MUST NOT be less than the value of the lease_time attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - サーバが委任をリコールしようとした後、クライアントは、ある程度の時間のためにRENEW操作を発行しておりません。この期間はlease_time属性の値以上でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the client holds a delegation, it can not rely on operations, except for RENEW, that take a stateid, to renew delegation leases across callback path failures. The client that wants to keep delegations in force across callback path failures must use RENEW to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが委任を保持している場合は、O、それはコールバックパスの障害を越え委任リースを更新するために、のstateidを取るRENEWを除く操作、に頼ることはできません。コールバックパスの障害を越え力に代表団を維持したいクライアントがそうするようにRENEW使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.6. Delegation Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4.6。委任失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the point a delegation is revoked, if there are associated opens on the client, the applications holding these opens need to be notified. This notification usually occurs by returning errors for READ/WRITE operations or when a close is attempted for the open file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そこに関連付けられている場合時点で、委任がクライアントに開き、取り消され、これらを保持しているアプリケーションに通知する必要が開きます。この通知は、通常、READ / WRITE操作にエラーを返すとき、またはクローズが開いたファイルのためにしようとしていることによって起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If no opens exist for the file at the point the delegation is revoked, then notification of the revocation is unnecessary. However, if there is modified data present at the client for the file, the user of the application should be notified. Unfortunately, it may not be possible to notify the user since active applications may not be present at the client. See the section &#34;Revocation Recovery for Write Open Delegation&#34; for additional details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任が取り消された時点でファイルの存在開いたいかなる場合は、取り消しの通知は不要ではありません。ファイルのクライアントで変更されたデータが存在した場合ただし、アプリケーションの利用者に通知しなければなりません。残念ながら、アクティブなアプリケーションがクライアントに存在しないかもしれないので、ユーザに通知することはできないかもしれません。詳細については、「書き込みオープン委譲のための失効リカバリ」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. Data Caching and Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5。データキャッシングと失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When locks and delegations are revoked, the assumptions upon which successful caching depend are no longer guaranteed. For any locks or share reservations that have been revoked, the corresponding owner needs to be notified. This notification includes applications with a file open that has a corresponding delegation which has been revoked. Cached data associated with the revocation must be removed from the client. In the case of modified data existing in the client&#39;s cache, that data must be removed from the client without it being written to the server. As mentioned, the assumptions made by the client are no longer valid at the point when a lock or delegation has been revoked. For example, another client may have been granted a conflicting lock after the revocation of the lock at the first client. Therefore, the data within the lock range may have been modified by the other client. Obviously, the first client is unable to guarantee to the application what has occurred to the file in the case of revocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックや代表団が取り消された場合は、成功したキャッシュが依存する仮定はもはや保証されません。取り消されたすべてのロックまたは共有の予約の場合は、対応する所有者に通知する必要があります。この通知は取り消された対応する代表団を持っているファイルのオープンとアプリケーションが含まれています。失効に関連付けられたキャッシュされたデータは、クライアントから削除する必要があります。クライアントのキャッシュ内の既存の変更されたデータの場合には、そのデータは、それがサーバーに書き込まれずに、クライアントから削除する必要があります。前述のように、クライアントによって行われた仮定は、ロックまたは委任が取り消された時点で、もはや有効ではありません。例えば、別のクライアントは、最初のクライアントでのロックの失効後に矛盾するロックが付与されている可能性があります。したがって、ロック範囲内のデータは、他のクライアントによって修飾されていてもよいです。もちろん、最初のクライアントが失効した場合のファイルに発生したものをアプリケーションに保証することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notification to a lock owner will in many cases consist of simply returning an error on the next and all subsequent READs/WRITEs to the open file or on the close. Where the methods available to a client make such notification impossible because errors for certain operations may not be returned, more drastic action such as signals or process termination may be appropriate. The justification for this is that an invariant for which an application depends on may be violated. Depending on how errors are typically treated for the client operating environment, further levels of notification including logging, console messages, and GUI pop-ups may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロック所有者への通知は、多くの場合、単純に次のエラーを返すから構成され、後続のすべては/がオープンファイルまたは近くに読み書きを行います。特定の操作のためにエラーが返されない場合があるため、クライアントが利用可能な方法は、そのような通知が不可能ここで、このような信号またはプロセス終了、より思い切ったアクションが適切であり得ます。これを正当化する理由は、アプリケーションが依存するため、不変に違反することができるということです。エラーは通常、クライアントの動作環境のために処理されている方法に応じて、ログ、コンソールメッセージ、およびGUIのポップアップを含む通知のさらなるレベルが適切かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1. Revocation Recovery for Write Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5.1。書き込みオープン委譲のための失効回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Revocation recovery for a write open delegation poses the special issue of modified data in the client cache while the file is not open. In this situation, any client which does not flush modified data to the server on each close must ensure that the user receives appropriate notification of the failure as a result of the revocation. Since such situations may require human action to correct problems, notification schemes in which the appropriate user or administrator is notified may be necessary. Logging and console messages are typical examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルが開いていない間、書き込みオープン委譲のための失効回復は、クライアントキャッシュに変更されたデータの特別な問題を提起します。このような状況では、各近い上のサーバーに変更されたデータをフラッシュしない任意のクライアントは、ユーザーが失効した結果として故障の適切な通知を受けたことを確認する必要があります。このような状況は、問題を修正するために人間の行動を必要とするかもしれないので、適切なユーザまたは管理者に通知された通知方式が必要であってもよいです。ロギングとコンソールメッセージが典型的な例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is modified data on the client, it must not be flushed normally to the server. A client may attempt to provide a copy of the file data as modified during the delegation under a different name in the filesystem name space to ease recovery. Note that when the client can determine that the file has not been modified by any other client, or when the client has a complete cached copy of file in question, such a saved copy of the client&#39;s view of the file may be of particular value for recovery. In other case, recovery using a copy of the file based partially on the client&#39;s cached data and partially on the server copy as modified by other clients, will be anything but straightforward, so clients may avoid saving file contents in these situations or mark the results specially to warn users of possible problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント上のデータが変更された場合は、サーバーに正常にフラッシュされてはなりません。クライアントは、リカバリを容易にするために、ファイルシステムの名前空間に別の名前で、委任時に変更されたファイルデータのコピーを提供しようとすることができます。クライアントは、ファイルが他のクライアントによって変更されていないと判断できる場合に、クライアントが問題のファイルの完全なキャッシュされたコピーを持っている場合、または、ファイルのクライアントのビューのように保存されたコピーは、のために特定の値であってもよいことに注意してください回復。クライアントはこれらの状況では、ファイルの内容を保存避けるか、結果をマークすることができるので、他のケースでは、クライアントのキャッシュされたデータに部分的に他のクライアントによって変更されたサーバーコピーに部分的に基づいて、ファイルのコピーを使用して回復は、簡単な何でもなります特別可能性のある問題のユーザーに警告します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Saving of such modified data in delegation revocation situations may be limited to files of a certain size or might be used only when sufficient disk space is available within the target filesystem. Such saving may also be restricted to situations when the client has sufficient buffering resources to keep the cached copy available until it is properly stored to the target filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
委任失効状況で、このような変更されたデータの保存は、特定のサイズのファイルに限定することができるか、十分なディスク領域が、ターゲットファイルシステム内で利用可能である場合にのみ使用される可能性があります。このような節約はまた、それが適切にターゲットファイルシステムに格納されるまで、クライアントが利用できるキャッシュされたコピーを保持するのに十分なバッファリング資源を持っているときの状況に制限することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. Attribute Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6。属性のキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes discussed in this section do not include named attributes. Individual named attributes are analogous to files and caching of the data for these needs to be handled just as data caching is for ordinary files. Similarly, LOOKUP results from an OPENATTR directory are to be cached on the same basis as any other pathnames and similarly for directory contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションで説明する属性が指定された属性が含まれていません。個々の名前の属性は、ファイルやデータのキャッシングは通常のファイルのためであると同じように処理されるこれらのニーズのためのデータのキャッシュに似ています。同様に、OPENATTRディレクトリから参照結果は、ディレクトリの内容のための任意の他のパス名と同様に同じに基づいてキャッシュされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients may cache file attributes obtained from the server and use them to avoid subsequent GETATTR requests. Such caching is write through in that modification to file attributes is always done by means of requests to the server and should not be done locally and cached. The exception to this are modifications to attributes that are intimately connected with data caching. Therefore, extending a file by writing data to the local data cache is reflected immediately in the size as seen on the client without this change being immediately reflected on the server. Normally such changes are not propagated directly to the server but when the modified data is flushed to the server, analogous attribute changes are made on the server. When open delegation is in effect, the modified attributes may be returned to the server in the response to a CB_RECALL call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバから取得したファイル属性をキャッシュし、その後のGETATTR要求を避けるためにそれらを使用することができます。このようなキャッシュは常に、サーバーへのリクエストによって行われた属性をファイルにその変更にライトスルーし、ローカルに実行され、キャッシュすべきではないです。この例外は密接にデータキャッシュに接続されている属性に変更されています。したがって、ローカル・データ・キャッシュにデータを書き込むことで、ファイルを拡張すると、この変更はすぐにサーバーに反映されずに、クライアント上で見られるような大きさにすぐに反映されています。通常、このような変更は、サーバーに直接反映されませんが、変更されたデータをサーバーにフラッシュされたときに、類似した属性の変更は、サーバー上で行われています。開いている委譲が有効になっている場合には、変更された属性はCB_RECALLの呼び出しに応じてサーバに戻すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result of local caching of attributes is that the attribute caches maintained on individual clients will not be coherent. Changes made in one order on the server may be seen in a different order on one client and in a third order on a different client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性のローカルキャッシュの結果は、個々のクライアント上で維持さ属性キャッシュがコヒーレントではないということです。サーバー上の1つの順序で行われた変更は1つのクライアントと異なるクライアント上の三ために、異なる順序で見ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The typical filesystem application programming interfaces do not provide means to atomically modify or interrogate attributes for multiple files at the same time. The following rules provide an environment where the potential incoherences mentioned above can be reasonably managed. These rules are derived from the practice of previous NFS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的なファイルシステムのアプリケーション・プログラミング・インタフェースは、アトミック、同時に複数のファイルの属性を変更したり、尋問するための手段を提供しません。次の規則は、前述した可能性incoherencesが合理的に管理することができる環境を提供します。これらの規則は、以前のNFSプロトコルの実施から導出されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All attributes for a given file (per-fsid attributes excepted) are cached as a unit at the client so that no non-serializability can arise within the context of a single file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何の非直列可能で、単一のファイルのコンテキスト内で発生しないことができるように、O、指定されたファイルのすべての属性は、（あたり-FSID属性は除く）クライアントでの単位としてキャッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An upper time boundary is maintained on how long a client cache entry can be kept without being refreshed from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O上側の時間境界は、クライアントのキャッシュエントリは、サーバから更新されずに保持することができるどのくらいに維持されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When operations are performed that change attributes at the server, the updated attribute set is requested as part of the containing RPC. This includes directory operations that update attributes indirectly. This is accomplished by following the modifying operation with a GETATTR operation and then using the results of the GETATTR to update the client&#39;s cached attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作は変更がサーバーに属性をすることを行っている場合には、O、更新された属性のセットが含まRPCの一部として要求されています。これは、その更新が間接的に属性ディレクトリ操作を含んでいます。これは、GETATTR操作で改質操作を次し、クライアントのキャッシュされた属性を更新するために、GETATTRの結果を使用することによって達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the full set of attributes to be cached is requested by READDIR, the results can be cached by the client on the same basis as attributes obtained via GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キャッシュされる属性の完全なセットがREADDIRによって要求された場合、結果がGETATTRを介して取得した属性と同じ基準で、クライアントによってキャッシュされることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may validate its cached version of attributes for a file by fetching just both the change and time_access attributes and assuming that if the change attribute has the same value as it did when the attributes were cached, then no attributes other than time_access have changed. The reason why time_access is also fetched is because many servers operate in environments where the operation that updates change does not update time_access. For example, POSIX file semantics do not update access time when a file is modified by the write system call. Therefore, the client that wants a current time_access value should fetch it with change during the attribute cache validation processing and update its cached time_access.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、単に変化とtime_access属性の両方を取得し、属性がキャッシュされた時にそれがなかったとして変化属性が同じ値を持っている場合は、time_access以外の属性が変更されていないことを仮定することにより、ファイルの属性のそのキャッシュされたバージョンを検証することができます。多くのサーバーが変更を更新操作がtime_accessを更新していない環境でも動作するのでtime_accessもフェッチされる理由はあります。例えば、POSIXファイルのセマンティクスは、ファイルが書き込みシステムコールによって変更されたアクセス時間を更新しません。したがって、現在のtime_access値を望んでいるクライアントは、属性キャッシュの検証処理中に変更して、それをフェッチし、そのキャッシュされたtime_accessを更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client may maintain a cache of modified attributes for those attributes intimately connected with data of modified regular files (size, time_modify, and change). Other than those three attributes, the client MUST NOT maintain a cache of modified attributes. Instead, attribute changes are immediately sent to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは密接に変更され、通常のファイル（サイズ、time_modify、および変更）のデータに接続し、それらの属性のために変更された属性のキャッシュを維持することができます。これらの3つの属性以外にも、クライアントが変更された属性のキャッシュを維持してはなりません。代わりに、属性の変更は、すぐにサーバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some operating environments, the equivalent to time_access is expected to be implicitly updated by each read of the content of the file object. If an NFS client is caching the content of a file object, whether it is a regular file, directory, or symbolic link, the client SHOULD NOT update the time_access attribute (via SETATTR or a small READ or READDIR request) on the server with each read that is satisfied from cache. The reason is that this can defeat the performance benefits of caching content, especially since an explicit SETATTR of time_access may alter the change attribute on the server. If the change attribute changes, clients that are caching the content will think the content has changed, and will re-read unmodified data from the server. Nor is the client encouraged to maintain a modified version of time_access in its cache, since this would mean that the client will either eventually have to write the access time to the server with bad performance effects, or it would never update the server&#39;s time_access, thereby resulting in a situation where an application that caches access time between a close and open of the same file observes the access time oscillating between the past and present. The time_access attribute always means the time of last access to a file by a read that was satisfied by the server. This way clients will tend to see only time_access changes that go forward in time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のオペレーティング環境では、time_accessと同等のは暗黙のうちにファイルオブジェクトのコンテンツの各読み取りによって更新されることが期待されます。 NFSクライアントは、それが通常のファイル、ディレクトリ、シンボリックリンクであるかどうか、ファイルオブジェクトのコンテンツをキャッシュしている場合、クライアントはそれぞれに、サーバー上の（SETATTRや小さなREADまたはREADDIR要求を経由して）time_access属性を更新すべきではありませんそれはキャッシュから満足しているお読みください。その理由は、これがtime_accessの明示的なSETATTRは、サーバー上の変化属性を変更することができる、特に以来、キャッシュコンテンツのパフォーマンス上の利点を倒すことができるということです。変更属性の変更をした場合、コンテンツをキャッシュしているクライアントは、コンテンツがサーバーから変更されていないデータを変更した、と再読み込みすると思います。 NORクライアントは、これは、クライアントがいずれかの最終的に悪いパフォーマンスの影響で、サーバへのアクセス時間を記述する必要がありますことを意味する、またはそれは、サーバーのtime_accessを更新したことがないであろうから、それによって、そのキャッシュにtime_accessの修正版を維持することが奨励されます同じファイルのクローズとオープンの間のアクセス時間をキャッシュするアプリケーションは、過去と現在との間のアクセス時間の振動を観察状況になります。 time_access属性は常にサーバーによって満たされた読み取りがファイルへの最後のアクセスの時間を意味します。この方法では、クライアントが時間に前に進むのみtime_accessの変更を確認する傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. Data and Metadata Caching and Memory Mapped Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7。データおよびメタデータキャッシュとメモリマップファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some operating environments include the capability for an application to map a file&#39;s content into the application&#39;s address space. Each time the application accesses a memory location that corresponds to a block that has not been loaded into the address space, a page fault occurs and the file is read (or if the block does not exist in the file, the block is allocated and then instantiated in the application&#39;s address space).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のオペレーティング環境では、アプリケーションのアドレス空間にファイルの内容をマップするアプリケーションのための機能が含まれています。アドレス空間にロードされていないブロックに対応するメモリ位置にアクセスするアプリケーションごとに、ページフォールトが発生し、ファイルが読み込まれる（またはブロックがファイル内に存在しない場合、ブロックが割り当てられると）アプリケーションのアドレス空間でインスタンス化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As long as each memory mapped access to the file requires a page fault, the relevant attributes of the file that are used to detect access and modification (time_access, time_metadata, time_modify, and change) will be updated. However, in many operating environments, when page faults are not required these attributes will not be updated on reads or updates to the file via memory access (regardless whether the file is local file or is being access remotely). A client or server MAY fail to update attributes of a file that is being accessed via memory mapped I/O. This has several implications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
限り、各メモリは、ファイルへのアクセスをマッピングしてページフォルトを必要とし、アクセスと変更（time_access、time_metadata、time_modify、および変更）を検出するために使用されているファイルの関連属性が更新されます。ただし、ページフォールトがこれらの属性は、上の更新されません必要はありません多くのオペレーティング環境で（ファイルはローカルファイルであるかリモートでアクセスされているかどうかにかかわらず）、メモリアクセスを経由してファイルへの読み取りまたは更新されます。クライアントまたはサーバは、メモリマップドI / Oを経由してアクセスされているファイルの属性を更新するために失敗することがあります。これにはいくつかの意味を持っています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is an application on the server that has memory mapped a file that a client is also accessing, the client may not be able to get a consistent value of the change attribute to determine whether its cache is stale or not. A server that knows that the file is memory mapped could always pessimistically return updated values for change so as to force the application to always get the most up to date data and metadata for the file. However, due to the negative performance implications of this, such behavior is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メモリは、クライアントにもアクセスしているファイルをマッピングしているサーバー上のアプリケーションがある場合は、O、クライアントは、そのキャッシュが古くなっているかいないかどうかを判断するために変化属性の一貫性のある値を取得することができない場合があります。常に最新のデータやファイルのメタデータまでのほとんどを取得するためにアプリケーションを強制するように、ファイルがメモリマップされていることを知っているサーバーは、常に悲観的に変更のための更新された値を返すことができます。しかし、この負のパフォーマンスへの影響のために、そのような行動はオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the memory mapped file is not being modified on the server, and instead is just being read by an application via the memory mapped interface, the client will not see an updated time_access attribute. However, in many operating environments, neither will any process running on the server. Thus NFS clients are at no disadvantage with respect to local processes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メモリマップされたファイルがサーバー上で変更されていない、とだけではなく、メモリマップされたインタフェースを介してアプリケーションによって読み取られている場合は、O、クライアントが更新されtime_access属性は表示されません。しかし、多くのオペレーティング環境では、どちらも任意のプロセスは、サーバー上で実行されているんでしょう。したがってNFSクライアントは、ローカルプロセスに対してない不利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is another client that is memory mapping the file, and if that client is holding a write delegation, the same set of issues as discussed in the previous two bullet items apply. So, when a server does a CB_GETATTR to a file that the client has modified in its cache, the response from CB_GETATTR will not necessarily be accurate. As discussed earlier, the client&#39;s obligation is to report that the file has been modified since the delegation was granted, not whether it has been modified again between successive CB_GETATTR calls, and the server MUST assume that any file the client has modified in cache has been modified again between successive CB_GETATTR calls. Depending on the nature of the client&#39;s memory management system, this weak obligation may not be possible. A client MAY return stale information in CB_GETATTR whenever the file is memory mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oメモリのファイルをマッピングしている別のクライアントが存在する場合は、前の2箇条書きの項目に適用されます述べたように、そのクライアントは、問題の同じセットを書き込み委託を保持している場合。サーバは、クライアントがそのキャッシュ内で変更したファイルにCB_GETATTRをするときに、CB_GETATTRからの応答は必ずしも正確ではありません。先に述べたように、クライアントの義務は、委任が許可されたので、それが連続CB_GETATTR呼び出しの間で再び変更されているかどうか、ファイルが変更されたことを報告することで、サーバは、クライアントがキャッシュ内で変更したすべてのファイルがされていると仮定しなければなりません連続CB_GETATTR呼び出しの間で再び修正。クライアントのメモリ管理システムの性質に応じて、この弱い義務はできないことがあります。ファイルがメモリマップされたときはいつでも、クライアントはCB_GETATTRに古い情報が返されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The mixture of memory mapping and file locking on the same file is problematic. Consider the following scenario, where the page size on each client is 8192 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O同じファイルのメモリマッピングおよびファイルのロックの混合物が問題となります。各クライアント上のページサイズが8192バイトである場合、次のシナリオを検討してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client A memory maps first page (8192 bytes) of file X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - クライアントのメモリは、ファイルXの最初のページ（8192バイト）にマップ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client B memory maps first page (8192 bytes) of file X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - クライアントBのメモリは、ファイルXの最初のページ（8192バイト）にマップ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client A write locks first 4096 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - クライアントの書き込みロック最初の4096のバイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client B write locks second 4096 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - クライアントBの書き込みロック第4096バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Client A, via a STORE instruction modifies part of its locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  STORE命令を介してクライアントAは、そのロックされた領域の一部を修正します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- Simultaneous to client A, client B issues a STORE on part of its locked region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - クライアントAへの同時、クライアントBはそのロックされた領域の一部にSTOREを発行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here the challenge is for each client to resynchronize to get a correct view of the first page. In many operating environments, the virtual memory management systems on each client only know a page is modified, not that a subset of the page corresponding to the respective lock regions has been modified. So it is not possible for each client to do the right thing, which is to only write to the server that portion of the page that is locked. For example, if client A simply writes out the page, and then client B writes out the page, client A&#39;s data is lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各クライアントは、最初のページの正しいビューを取得するために再同期化するためにここで課題となっています。多くのオペレーティング環境では、各クライアント上の仮想メモリ管理システムが唯一のページが変更されて知っている、それぞれのロック領域に対応するページのサブセットが変更されていないこと。だから、それぞれのクライアントのみがロックされているページのサーバー部分を書くことである正しいことを、行うことは可能ではありません。例えば、クライアントAは、単にページを書き出した場合、その後、クライアントBがページを書き出し、クライアントAのデータが失われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Moreover, if mandatory locking is enabled on the file, then we have a different problem. When clients A and B issue the STORE instructions, the resulting page faults require a record lock on the entire page. Each client then tries to extend their locked range to the entire page, which results in a deadlock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
強制ロックがファイル上で有効になっている場合はまた、我々は別の問題を抱えています。クライアントのAとBの問題STORE命令は、結果のページフォルトはページ全体のレコードロックを必要とするとき。各クライアントは、その後、デッドロックになり、ページ全体に彼らのロックされた範囲を拡張しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Communicating the NFS4ERR_DEADLOCK error to a STORE instruction is difficult at best.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STORE命令にNFS4ERR_DEADLOCKエラーを伝えることは最高に困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client is locking the entire memory mapped file, there is no problem with advisory or mandatory record locking, at least until the client unlocks a region in the middle of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが全体のメモリマップされたファイルをロックしている場合、クライアントはファイルの途中で地域のロックを解除し、少なくともまで、諮問または必須レコードロックに問題がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given the above issues the following are permitted:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の問題を考えると、次は許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clients and servers MAY deny memory mapping a file they know there are record locks for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - クライアントとサーバは、彼らがために、レコードロックが知っているファイルをマッピングするメモリを拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clients and servers MAY deny a record lock on a file they know is memory mapped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - クライアントとサーバーは、メモリがマッピングされている知っているファイルのレコードロックを拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- A client MAY deny memory mapping a file that it knows requires mandatory locking for I/O. If mandatory locking is enabled after the file is opened and mapped, the client MAY deny the application further access to its mapped file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - クライアントは、それがI / Oのための強制ロックを必要と知っているファイルをマッピングするメモリを拒否することができます。ファイルが開かれ、マップされた後に強制ロックが有効になっている場合、クライアントはそのマップされたファイルへのアプリケーションのさらなるアクセスを拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. Name Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8。名前キャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of LOOKUP and READDIR operations may be cached to avoid the cost of subsequent LOOKUP operations. Just as in the case of attribute caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies and given the context of typical filesystem APIs, an upper time boundary is maintained on how long a client name cache entry can be kept without verifying that the entry has not been made invalid by a directory change operation performed by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPとREADDIR操作の結果は、その後のLOOKUP操作のコストを回避するためにキャッシュされる場合があります。ただ、属性のキャッシングの場合のように、矛盾がさまざまなクライアントキャッシュ間生じる可能性があります。これらの不整合の影響を緩和し、一般的なファイルシステムのAPIのコンテキストを与えるために、上側の時間境界は、クライアント名のキャッシュエントリが、によって行われるディレクトリの変更操作によって無効にされていないことを確認せずに維持することができるどのくらいに維持されています別のクライアント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client is not making changes to a directory for which there exist name cache entries, the client needs to periodically fetch attributes for that directory to ensure that it is not being modified. After determining that no modification has occurred, the expiration time for the associated name cache entries may be updated to be the current time plus the name cache staleness bound.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが名前のキャッシュエントリが存在するためにディレクトリを変更するされていない場合、クライアントは定期的にそれが修正されていないことを確認するために、そのディレクトリの属性を取得する必要があります。何も変更が発生していないことを決定した後、関連する名前のキャッシュエントリの有効期限は、現在の時刻プラスバインド名キャッシュ古さに更新することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client is making changes to a given directory, it needs to determine whether there have been changes made to the directory by other clients. It does this by using the change attribute as reported before and after the directory operation in the associated change_info4 value returned for the operation. The server is able to communicate to the client whether the change_info4 data is provided atomically with respect to the directory operation. If the change values are provided atomically, the client is then able to compare the pre-operation change value with the change value in the client&#39;s name cache. If the comparison indicates that the directory was updated by another client, the name cache associated with the modified directory is purged from the client. If the comparison indicates no modification, the name cache can be updated on the client to reflect the directory operation and the associated timeout extended. The post-operation change value needs to be saved as the basis for future change_info4 comparisons.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが指定したディレクトリに変更を行っているとき、それは他のクライアントがディレクトリへの変更があったかどうかを決定する必要があります。これは、操作のために返される関連する変化_info4値のディレクトリ操作の前と後に報告されたように変化属性を使用してこれを行います。サーバは変化_info4データがディレクトリ動作に関してアトミックに設けられているかどうかをクライアントに通信することができます。変更値をアトミックに提供されている場合、クライアントは、クライアントの名前キャッシュに変更値が事前に動作変更値を比較することです。比較はディレクトリが別のクライアントによって更新されたことを示している場合、修正ディレクトリに関連付けられた名前のキャッシュは、クライアントからパージされます。比較は何も変更がないことを示す場合は、名前のキャッシュは、ディレクトリ操作を反映するために、クライアント上で更新することができ、関連するタイムアウトを延長しました。術後変化値は、将来の変化_info4比較のための基礎として保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As demonstrated by the scenario above, name caching requires that the client revalidate name cache data by inspecting the change attribute of a directory at the point when the name cache item was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre and post operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のシナリオによって示されるように、名前のキャッシュは、クライアントが名前のキャッシュ項目がキャッシュされた時点で、ディレクトリの変更属性を調べることによって、名前のキャッシュデータを再検証する必要があります。これは、対応するディレクトリの内容が変更されたときに、サーバがディレクトリの変更属性を更新する必要があります。クライアントは、適切かつ正確に変化_info4情報を使用するには、サーバーは、前と後の動作の変更がアトミックに属性値を報告しなければなりません。サーバーは、ディレクトリ操作に関して原子論前後の値を報告することができない場合は、サーバーは変化_info4の戻り値であることを示す必要があります。情報がアトミックに報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないことを仮定するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9. Directory Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9。ディレクトリのキャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of READDIR operations may be used to avoid subsequent READDIR operations. Just as in the cases of attribute and name caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies, and given the context of typical filesystem APIs, the following rules should be followed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作の結果は、その後のREADDIR操作を回避するために使用されてもよいです。ただ、属性と名前のキャッシュの例のように、矛盾がさまざまなクライアントキャッシュ間生じる可能性があります。これらの不整合の影響を軽減し、一般的なファイルシステムのAPIのコンテキストを与えるために、次の規則に従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cached READDIR information for a directory which is not obtained in a single READDIR operation must always be a consistent snapshot of directory contents. This is determined by using a GETATTR before the first READDIR and after the last of READDIR that contributes to the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O単一READDIR操作で得られていないディレクトリのキャッシュREADDIR情報は常にディレクトリの内容の一貫性のあるスナップショットでなければなりません。これは最初のREADDIR前に、キャッシュに寄与することREADDIRの最後の後GETATTRを用いて決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An upper time boundary is maintained to indicate the length of time a directory cache entry is considered valid before the client must revalidate the cached information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O上側の時間境界は、クライアントがキャッシュされた情報を再検証する必要があります前に、ディレクトリキャッシュエントリが有効と考えられている時間の長さを示すために維持されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The revalidation technique parallels that discussed in the case of name caching. When the client is not changing the directory in question, checking the change attribute of the directory with GETATTR is adequate. The lifetime of the cache entry can be extended at these checkpoints. When a client is modifying the directory, the client needs to use the change_info4 data to determine whether there are other clients modifying the directory. If it is determined that no other client modifications are occurring, the client may update its directory cache to reflect its own changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前キャッシュの場合で説明した再検証技術の緯線。クライアントがGETATTRとディレクトリの変更属性をチェックし、問題のディレクトリを変更していない場合は十分です。キャッシュエントリの寿命は、これらのチェックポイントに拡張することができます。クライアントがディレクトリを変更している場合は、クライアントがディレクトリを変更する他のクライアントが存在するかどうかを判断するために変化_info4データを使用する必要があります。他のクライアントの変更が発生していないと判断された場合、クライアントは自身の変更を反映するために、そのディレクトリキャッシュを更新することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As demonstrated previously, directory caching requires that the client revalidate directory cache data by inspecting the change attribute of a directory at the point when the directory was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre and post operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前に実証されているように、ディレクトリキャッシュは、クライアントがディレクトリがキャッシュされた時点でのディレクトリの変更属性を調べることによって、ディレクトリキャッシュデータを再検証する必要があります。これは、対応するディレクトリの内容が変更されたときに、サーバがディレクトリの変更属性を更新する必要があります。クライアントは、適切かつ正確に変化_info4情報を使用するには、サーバーは、前と後の動作の変更がアトミックに属性値を報告しなければなりません。サーバーは、ディレクトリ操作に関して原子論前後の値を報告することができない場合は、サーバーは変化_info4の戻り値であることを示す必要があります。情報がアトミックに報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないことを仮定するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Minor Versioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.マイナーバージョン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To address the requirement of an NFS protocol that can evolve as the need arises, the NFS version 4 protocol contains the rules and framework to allow for future minor changes or versioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要に応じて進化することができるNFSプロトコルの要件に対処するために、NFSバージョン4プロトコルは、将来のマイナーな変更やバージョンを可能にする規則およびフレームワークを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base assumption with respect to minor versioning is that any future accepted minor version must follow the IETF process and be documented in a standards track RFC. Therefore, each minor version number will correspond to an RFC. Minor version zero of the NFS version 4 protocol is represented by this RFC. The COMPOUND procedure will support the encoding of the minor version being requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイナーバージョンに関する基本仮定は、将来のマイナーバージョンIETFプロセスに従わなければなりませんし、標準トラックRFCに文書化することを受け入れたことです。したがって、各マイナーバージョン番号は、RFCに対応することになります。 NFSバージョン4プロトコルのマイナーバージョンゼロは、このRFCによって表されます。 COMPOUND手順は、クライアントによって要求されたマイナーバージョンのエンコーディングをサポートします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following items represent the basic rules for the development of minor versions. Note that a future minor version may decide to modify or add to the following rules as part of the minor version definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の項目は、マイナーバージョンの開発のための基本的なルールを表しています。将来のマイナーバージョンが変更またはマイナーバージョン定義の一部として、次のルールに追加することを決定することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. Procedures are not added or deleted
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1.手順が追加または削除されていません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        To maintain the general RPC model, NFS version 4 minor versions
        will not add to or delete procedures from the NFS program.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. Minor versions may add operations to the COMPOUND and CB_COMPOUND procedures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2.マイナーバージョンは、化合物およびCB_COMPOUND手順に操作を追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        The addition of operations to the COMPOUND and CB_COMPOUND
        procedures does not affect the RPC model.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2.1 Minor versions may append attributes to GETATTR4args, bitmap4, and GETATTR4res.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2.1マイナーバージョンはGETATTR4args、bitmap4、及びGETATTR4resに属性を追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        This allows for the expansion of the attribute model to allow
        for future growth or adaptation.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2.2 Minor version X must append any new attributes after the last documented attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2.2マイナーバージョンXは、最後の文書属性の後に任意の新しい属性を追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Since attribute results are specified as an opaque array of
        per-attribute XDR encoded results, the complexity of adding new
        attributes in the midst of the current definitions will be too
        burdensome.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3. Minor versions must not modify the structure of an existing operation&#39;s arguments or results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3.マイナーバージョンでは、既存のオペレーションの引数や結果の構造を変更してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Again the complexity of handling multiple structure definitions
        for a single operation is too burdensome.  New operations should
        be added instead of modifying existing structures for a minor
        version.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
This rule does not preclude the following adaptations in a minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
この規則は、マイナーバージョンでは、以下の適応を妨げるものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o adding bits to flag fields such as new attributes to GETATTR&#39;s bitmap4 data type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
GETATTRのbitmap4データ型に新たな属性としてフラグフィールドにビットを追加O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o adding bits to existing attributes like ACLs that have flag words
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Oフラグワードを有するACLのような既存の属性にビットを付加
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
o extending enumerated types (including NFS4ERR_*) with new values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
新しい値で（NFS4ERR_ *を含む）列挙型を拡張するO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. Minor versions may not modify the structure of existing attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4.マイナーバージョンには、既存の属性の構造を変更することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
5. Minor versions may not delete operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
5.マイナーバージョンでは、操作を削除しないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        This prevents the potential reuse of a particular operation
        &#34;slot&#34; in a future minor version.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
6. Minor versions may not delete attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
6.マイナーバージョンでは、属性を削除しないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
7. Minor versions may not delete flag bits or enumeration values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
7.マイナーバージョンは、フラグビットまたは列挙値を削除しなくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8. Minor versions may declare an operation as mandatory to NOT implement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8.マイナーバージョンを実装しないために必須の動作を宣言することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Specifying an operation as &#34;mandatory to not implement&#34; is
        equivalent to obsoleting an operation.  For the client, it means
        that the operation should not be sent to the server.  For the
        server, an NFS error can be returned as opposed to &#34;dropping&#34;
        the request as an XDR decode error.  This approach allows for
        the obsolescence of an operation while maintaining its structure
        so that a future minor version can reintroduce the operation.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8.1 Minor versions may declare attributes mandatory to NOT implement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8.1マイナーバージョンでは実装しないように必須属性を宣言してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8.2 Minor versions may declare flag bits or enumeration values as mandatory to NOT implement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8.2マイナーバージョンを実装しないことを必須としてフラグビットまたは列挙値を宣言することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
9. Minor versions may downgrade features from mandatory to recommended, or recommended to optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
9.マイナーバージョンを推奨、またはオプションの推奨に必須の機能をダウングレードすることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
10. Minor versions may upgrade features from optional to recommended or recommended to mandatory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
10.マイナーバージョンは、オプションからの推奨または必須に推奨する機能をアップグレードすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
11. A client and server that support minor version X must support minor versions 0 (zero) through X-1 as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
マイナーバージョンXをサポート11.クライアントとサーバーは、同様にX-1を介してマイナーバージョン0（ゼロ）をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
12. No new features may be introduced as mandatory in a minor version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
12.何の新機能は、マイナーバージョンで必須として導入することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        This rule allows for the introduction of new functionality and
        forces the use of implementation experience before designating a
        feature as mandatory.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
13. A client MUST NOT attempt to use a stateid, filehandle, or similar returned object from the COMPOUND procedure with minor version X for another COMPOUND procedure with minor version Y, where X != Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
13.クライアントは、X！= Y.マイナーバージョンY、と別のCOMPOUND手順のためにマイナーバージョンXでCOMPOUND手順からのstateid、ファイルハンドル、または同様返されたオブジェクトを使用することを試みてはいけません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Internationalization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.国際化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary issue in which NFS version 4 needs to deal with internationalization, or I18N, is with respect to file names and other strings as used within the protocol. The choice of string representation must allow reasonable name/string access to clients which use various languages. The UTF-8 encoding of the UCS as defined by [ISO10646] allows for this type of access and follows the policy described in &#34;IETF Policy on Character Sets and Languages&#34;, [RFC2277].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4は、国際化、またはI18Nに対処する必要のある主な問題は、プロトコル内で使用される名前や他の文字列をファイルに関連しています。文字列表現の選択は、さまざまな言語を使用するクライアントへの合理的な名前/文字列へのアクセスを許可する必要があります。 UTF-8で定義されるようにUCSのエンコーディング[ISO10646]はこのタイプのアクセスを可能にし、「文字セットと言語でIETFポリシー」、[RFC2277]に記載されたポリシーに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3454], otherwise know as &#34;stringprep&#34;, documents a framework for using Unicode/UTF-8 in networking protocols, so as &#34;to increase the likelihood that string input and string comparison work in ways that make sense for typical users throughout the world.&#34; A protocol must define a profile of stringprep &#34;in order to fully specify the processing options.&#34; The remainder of this Internationalization section defines the NFS version 4 stringprep profiles. Much of terminology used for the remainder of this section comes from stringprep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その可能性を高める」ように[RFC3454]は、そうでない場合は、ネットワークプロトコルでのUnicode / UTF-8を使用するためのフレームワークを文書化、「文字列前」として知られ、世界中で一般的なユーザーのために意味をなす方法で文字列を入力し、文字列比較作業。」プロトコルは、「完全に処理オプションを指定するために。」文字列準備のプロファイルを定義する必要がありますこの国際部の残りの部分は、NFSバージョン4つの文字列準備プロファイルを定義します。このセクションの残りのために使用される用語の多くは、文字列前から来ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three UTF-8 string types defined for NFS version 4: utf8str_cs, utf8str_cis, and utf8str_mixed. Separate profiles are defined for each. Each profile defines the following, as required by stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cs、utf8str_cis、およびutf8str_mixed：NFSバージョン4用に定義された3 UTF-8文字列の種類があります。個別のプロファイルがそれぞれのために定義されています。文字列準備することにより、必要に応じて、各プロファイルには、次のように定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The intended applicability of the profile o The character repertoire that is the input and output to stringprep (which is Unicode 3.2 for referenced version of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（文字列準備の参照バージョンにUnicode 3.2である）STRINGPREPする入力と出力される文字レパートリOプロファイルの意図された適用O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The mapping tables from stringprep used (as described in section 3 of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用される文字列準備からマッピングテーブルO（文字列準備のセクション3に記載されているように）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any additional mapping tables specific to the profile
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルに固有の任意の追加のマッピングテーブルO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Unicode normalization used, if any (as described in section 4 of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用されるUnicode正規O、（文字列準備のセクション4に記載されているように）もしあれば
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The tables from stringprep listing of characters that are prohibited as output (as described in section 5 of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出力として禁止されている文字の文字列準備リストからテーブルO（文字列準備のセクション5に記載されているように）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The bidirectional string testing used, if any (as described in section 6 of stringprep)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用される双方向ストリングテストO、（文字列準備のセクション6で説明したように）もしあれば
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Any additional characters that are prohibited as output specific to the profile
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイルに固有の出力として禁止されている任意の追加文字O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stringprep discusses Unicode characters, whereas NFS version 4 renders UTF-8 characters. Since there is a one to one mapping from UTF-8 to Unicode, where ever the remainder of this document refers to to Unicode, the reader should assume UTF-8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4は、UTF-8文字をレンダリングするのに対し。文字列は、Unicode文字を説明します。 UnicodeへのUTF-8から1対1のマッピングがあるので、この文書の残りはユニコードに指すこれまで、ここで、読者は、UTF-8を想定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Much of the text for the profiles comes from [RFC3454].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロファイル用のテキストの多くは、[RFC3454]から来ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Stringprep profile for the utf8str_cs type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1。 utf8str_csの種類の文字列準備プロフィール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every use of the utf8str_cs type definition in the NFS version 4 protocol specification follows the profile named nfs4_cs_prep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコル仕様でutf8str_cs型定義のすべての使用はnfs4_cs_prepという名前のプロファイルに従っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. Intended applicability of the nfs4_cs_prep profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1。 nfs4_cs_prepプロファイルの意図適用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The utf8str_cs type is a case sensitive string of UTF-8 characters. Its primary use in NFS Version 4 is for naming components and pathnames. Components and pathnames are stored on the server&#39;s filesystem. Two valid distinct UTF-8 strings might be the same after processing via the utf8str_cs profile. If the strings are two names inside a directory, the NFS version 4 server will need to either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cs型はUTF-8文字の大文字と小文字を区別した文字列です。 NFSバージョン4での主な用途は、コンポーネントとパス名の命名です。コンポーネントとパス名は、サーバのファイルシステムに格納されています。 2つの有効な個別のUTF-8文字列は、utf8str_csプロファイルを経由して処理した後、同じかもしれません。文字列は、ディレクトリ内の2名の場合は、NFSバージョン4サーバは、どちらかにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o disallow the creation of a second name if it&#39;s post processed form collides with that of an existing name, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それの後処理フォームが既存の名前のそれと衝突する場合、またはO 2番目の名前の作成を許可しません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o allow the creation of the second name, but arrange so that after post processing, the second name is different than the post processed form of the first name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O 2番目の名前の作成を許可しますが、後処理の後、2番目の名前は、最初の名前のポストプロセシングされた形態とは異なっているようにアレンジ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2. Character repertoire of nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.2。 nfs4_cs_prepの文字レパートリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile uses Unicode 3.2, as defined in stringprep&#39;s Appendix A.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、Unicode 3.2を使用して、文字列前の付録A.1で定義されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3. Mapping used by nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.3。 nfs4_cs_prepで使用されるマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile specifies mapping using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、文字列前から、次の表を使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table B.2 is normally not part of the nfs4_cs_prep profile as it is primarily for dealing with case-insensitive comparisons. However, if the NFS version 4 file server supports the case_insensitive filesystem attribute, and if case_insensitive is true, the NFS version 4 server MUST use Table B.2 (in addition to Table B1) when processing utf8str_cs strings, and the NFS version 4 client MUST assume Table B.2 (in addition to Table B.1) are being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは大文字と小文字を区別しない比較に対処するため、主なように表B.2は、通常nfs4_cs_prepプロファイルの一部ではありません。しかし、NFSバージョン4ファイルサーバがCASE_INSENSITIVEファイルシステム属性をサポートし、CASE_INSENSITIVEがtrueの場合は、NFSバージョン4サーバは（表B1に加えて）表B.2を使用しなければならないutf8str_cs文字列を処理するとき、及び場合はNFSバージョン4クライアント表B.2を想定しなければならない（表B.1に加えて）使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the case_preserving attribute is present and set to false, then the NFS version 4 server MUST use table B.2 to map case when processing utf8str_cs strings. Whether the server maps from lower to upper case or the upper to lower case is an implementation dependency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
case_preserving属性がfalseに存在し、設定されている場合は、NFSバージョン4サーバーがutf8str_cs文字列を処理する際にケースをマッピングするためのテーブルB.2を使用しなければなりません。下ケースに大文字に下位または上位からサーバーマップかどうかは実装依存です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.4. Normalization used by nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.4。 nfs4_cs_prepで使用される正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile does not specify a normalization form. A later revision of this specification may specify a particular normalization form. Therefore, the server and client can expect that they may receive unnormalized characters within protocol requests and responses. If the operating environment requires normalization, then the implementation must normalize utf8str_cs strings within the protocol before presenting the information to an application (at the client) or local filesystem (at the server).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、正規化形式を指定しません。本明細書の以降の改訂は、特定の正規化形式を指定することができます。そのため、サーバとクライアントは、彼らがプロトコルの要求と応答の中に正規化されていない文字を受け取ることができることを期待することができます。動作環境が正常化が必要な場合は、その実装は、（サーバーで）（クライアントで）アプリケーションまたはローカルファイルシステムに情報を提示する前に、プロトコル内utf8str_cs文字列を正規化しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.5. Prohibited output for nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.5。 nfs4_cs_prepのための出力禁止
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile specifies prohibiting using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは、文字列前から、次の表を使用禁止に指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.3 Table C.4 Table C.5 Table C.6 Table C.7 Table C.8 Table C.9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.3表C.4表C.5表C.6表C.7表C.8表C.9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.6. Bidirectional output for nfs4_cs_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.6。 nfs4_cs_prepのための双方向出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cs_prep profile does not specify any checking of bidirectional strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cs_prepプロファイルは双方向の文字列のいずれかのチェックを指定していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Stringprep profile for the utf8str_cis type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2。 utf8str_cisの種類の文字列準備プロフィール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every use of the utf8str_cis type definition in the NFS version 4 protocol specification follows the profile named nfs4_cis_prep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコル仕様でutf8str_cis型定義のすべての使用はnfs4_cis_prepという名前のプロファイルに従っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.1. Intended applicability of the nfs4_cis_prep profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.1。 nfs4_cis_prepプロファイルの意図適用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The utf8str_cis type is a case insensitive string of UTF-8 characters. Its primary use in NFS Version 4 is for naming NFS servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_cis型はUTF-8文字の大文字小文字を区別しない文字列です。 NFSバージョン4で、その主な用途は、NFSサーバに名前を付けるためのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.2. Character repertoire of nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.2。 nfs4_cis_prepの文字レパートリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile uses Unicode 3.2, as defined in stringprep&#39;s Appendix A.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、Unicode 3.2を使用して、文字列前の付録A.1で定義されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.3. Mapping used by nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.3。 nfs4_cis_prepで使用されるマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies mapping using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、文字列前から、次の表を使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1 Table B.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1表B.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.4. Normalization used by nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.4。 nfs4_cis_prepで使用される正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies using Unicode normalization form KC, as described in stringprep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、文字列準備で説明したように、KC形態ユニコード正規化を使用して指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.5. Prohibited output for nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.5。 nfs4_cis_prepのための出力禁止
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies prohibiting using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、文字列前から、次の表を使用禁止に指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.1.2 Table C.2.2 Table C.3 Table C.4 Table C.5 Table C.6 Table C.7 Table C.8 Table C.9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.1.2表C.2.2表C.3表C.4表C.5表C.6表C.7表C.8表C.9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.6. Bidirectional output for nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.6。 nfs4_cis_prepのための双方向出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_cis_prep profile specifies checking bidirectional strings as described in stringprep&#39;s section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_cis_prepプロファイルは、文字列前のセクション6で説明したように、双方向の文字列をチェックする指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. Stringprep profile for the utf8str_mixed type
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3。 utf8str_mixedタイプの文字列準備プロフィール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every use of the utf8str_mixed type definition in the NFS version 4 protocol specification follows the profile named nfs4_mixed_prep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコル仕様でutf8str_mixed型定義のすべての使用はnfs4_mixed_prepという名前のプロファイルに従っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1. Intended applicability of the nfs4_mixed_prep profile
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1。 nfs4_mixed_prepプロファイルの意図適用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The utf8str_mixed type is a string of UTF-8 characters, with a prefix that is case sensitive, a separator equal to &#39;@&#39;, and a suffix that is fully qualified domain name. Its primary use in NFS Version 4 is for naming principals identified in an Access Control Entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixedタイプは大文字と小文字が区別され、プレフィックス、「@」に等しく、セパレータ、および完全修飾ドメイン名である接尾辞UTF-8文字の文字列です。 NFSバージョン4で、その主な用途は、アクセス制御エントリで識別プリンシパルに名前を付けるためのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.2. Character repertoire of nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.2。 nfs4_mixed_prepの文字レパートリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile uses Unicode 3.2, as defined in stringprep&#39;s Appendix A.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、Unicode 3.2を使用して、文字列前の付録A.1で定義されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.3. Mapping used by nfs4_cis_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.3。 nfs4_cis_prepで使用されるマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the prefix and the separator of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following table from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プレフィックスとutf8str_mixed列の分離のために、nfs4_mixed_prepプロファイルが文字列準備から次の表を使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the suffix of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
utf8str_mixed文字列のサフィックスについて、nfs4_mixed_prepプロファイルは、文字列前から、次の表を使用してマッピングを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table B.1 Table B.2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表B.1表B.2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.4. Normalization used by nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.4。 nfs4_mixed_prepで使用される正規化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile specifies using Unicode normalization form KC, as described in stringprep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、文字列準備で説明したように、KC形態ユニコード正規化を使用して指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.5. Prohibited output for nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.5。 nfs4_mixed_prepのための出力禁止
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile specifies prohibiting using the following tables from stringprep:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、文字列前から、次の表を使用禁止に指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table C.1.2 Table C.2.2 Table C.3 Table C.4 Table C.5 Table C.6 Table C.7 Table C.8 Table C.9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表C.1.2表C.2.2表C.3表C.4表C.5表C.6表C.7表C.8表C.9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.6. Bidirectional output for nfs4_mixed_prep
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.6。 nfs4_mixed_prepのための双方向出力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The nfs4_mixed_prep profile specifies checking bidirectional strings as described in stringprep&#39;s section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nfs4_mixed_prepプロファイルは、文字列前のセクション6で説明したように、双方向の文字列をチェックする指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. UTF-8 Related Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4。 UTF-8関連のエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the client sends an invalid UTF-8 string, the server should return an NFS4ERR_INVAL error. This includes cases in which inappropriate prefixes are detected and where the count includes trailing bytes that do not constitute a full UCS character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが無効なUTF-8文字列を送信する場合、サーバはNFS4ERR_INVALエラーを返す必要があります。これは、不適切なプレフィックスが検出されている場合も含むとカウントがフルUCS文字を構成しないバイトを末尾に含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the client supplied string is valid UTF-8 but contains characters that are not supported by the server as a value for that string (e.g., names containing characters that have more than two octets on a filesystem that supports Unicode characters only), the server should return an NFS4ERR_BADCHAR error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント与えられた文字列が有効なUTF-8であるが、その文字列の値として、サーバでサポートされていない文字が含まれている（例えば、唯一のUnicode文字をサポートしているファイルシステム上の二つ以上のオクテットを持つ文字を含む名前）、サーバーNFS4ERR_BADCHARエラーを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where a UTF-8 string is used as a file name, and the filesystem, while supporting all of the characters within the name, does not allow that particular name to be used, the server should return the error NFS4ERR_BADNAME. This includes situations in which the server filesystem imposes a normalization constraint on name strings, but will also include such situations as filesystem prohibitions of &#34;.&#34; and &#34;..&#34; as file names for certain operations, and other such constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UTF-8文字列は、ファイル名、およびファイルシステムとして使用されている場合は名前の中のすべての文字をサポートしながら、サーバがエラーNFS4ERR_BADNAMEを返す必要があり、その特定の名前を使用することはできません。これは、サーバーのファイルシステムが名前文字列の正規化制約を課しているが、またのファイルシステムの禁止などの状況を含むであろう状況を含みます「」そして、「..」ファイルの特定の操作の名前、および他のそのような制約など。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Error Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.エラーの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS error numbers are assigned to failed operations within a compound request. A compound request contains a number of NFS operations that have their results encoded in sequence in a compound reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply and the compound request will be terminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSエラー番号が複合要求の中に失敗した操作に割り当てられています。複合要求は化合物応答のシーケンスで、その結果を符号化されたNFS操作の数を含んでいます。成功した操作の結果は、動作の符号化された結果に続いNFS4_OK状態で構成されます。 NFS操作が失敗した場合、エラー状態は、返信に入力されますと、複合要求は終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A description of each defined error follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各定義されたエラーの説明は次の通りです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_OK Indicates the operation completed successfully.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_OKが正常に完了した操作を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ACCESS Permission denied. The caller does not have the correct permission to perform the requested operation. Contrast this with NFS4ERR_PERM, which restricts itself to owner or privileged user permission failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ACCESSの権限が拒否されました。呼び出し側は、要求された操作を実行するための正しい権限がありません。所有者または特権ユーザー権限失敗に自分自身を制限NFS4ERR_PERM、とは対照的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ATTRNOTSUPP An attribute specified is not supported by the server. Does not apply to the GETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ATTRNOTSUPPは、指定された属性は、サーバによってサポートされていません。 GETATTR操作には適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ADMIN_REVOKED Due to administrator intervention, the lockowner&#39;s record locks, share reservations, and delegations have been revoked by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
管理者の介入にNFS4ERR_ADMIN_REVOKED、lockownerのレコードロック、共有の予約、および代表団は、サーバーによって取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADCHAR A UTF-8 string contains a character which is not supported by the server in the context in which it being used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADCHAR UTF-8文字列は、それが使用されている文脈では、サーバーでサポートされていない文字が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_COOKIE READDIR cookie is stale.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_COOKIE READDIR Cookieが古くなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADHANDLE Illegal NFS filehandle. The filehandle failed internal consistency checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADHANDLE不正なNFSファイルハンドル。ファイルハンドルは、内部整合性チェックに失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADNAME A name string in a request consists of valid UTF-8 characters supported by the server but the name is not supported by the server as a valid name for current operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストでNFS4ERR_BADNAME A名の文字列は、サーバーでサポートされている有効なUTF-8文字で構成されていますが名前は現在の操作のための有効な名前など、サーバーでサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADOWNER An owner, owner_group, or ACL attribute value can not be translated to local representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADOWNERは、所有者、owner_group、またはACL属性の値は、ローカルの表現に変換することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADTYPE An attempt was made to create an object of a type not supported by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADTYPE試みは、サーバーでサポートされていないタイプのオブジェクトを作成しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_RANGE The range for a LOCK, LOCKT, or LOCKU operation is not appropriate to the allowable range of offsets for the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4 ERR_BAD_RANGEはLOCK、LOCK、またはLOCK操作の範囲は、サーバのためのオフセットの許容範囲に適切ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_SEQID The sequence number in a locking request is neither the next expected number or the last number processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_SEQIDロック要求のシーケンス番号は、次の予想される数または最後に処理数でもありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_STATEID A stateid generated by the current server instance, but which does not designate any locking state (either current or superseded) for a current lockowner-file pair, was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BAD_STATEID Aは、現在のサーバインスタンスによって生成されたのstateidが、使用された、現在のlockownerファイルペアに対して（現在または置き換えのいずれか）、任意のロック状態を指定しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADXDR The server encountered an XDR decoding error while processing an operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_BADXDRサーバーが動作処理中にエラーをデコードするXDRが発生しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_CLID_INUSE The SETCLIENTID operation has found that a client id is already in use by another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_CLID_INUSE SETCLIENTID操作は、クライアントIDが別のクライアントによってすでに使用中であることを見出しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DEADLOCK The server has been able to determine a file locking deadlock condition for a blocking lock request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DEADLOCKサーバーは、ブロッキングロック要求のファイルロックデッドロック状態を決定することができました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DELAY The server initiated the request, but was not able to complete it in a timely fashion. The client should wait and then try the request with a new RPC transaction ID. For example, this error should be returned from a server that supports hierarchical storage and receives a request to process a file that has been migrated. In this case, the server should start the immigration process and respond to client with this error. This error may also occur when a necessary delegation recall makes processing a request in a timely fashion impossible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DELAYは、サーバは、要求を開始したが、タイムリーにそれを完了することができませんでした。クライアントが待機してから、新しいRPCのトランザクションIDとリクエストを試してみてください。たとえば、このエラーは、階層型ストレージをサポートし、移行されたファイルを処理するための要求を受けたサーバから返されるべきです。この場合、サーバは、移民プロセスを開始する必要があり、このエラーでクライアントに応答します。必要な委任のリコールが不可能にタイムリーに要求を処理して行ったときにも、このエラーが発生することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DENIED An attempt to lock a file is denied. Since this may be a temporary condition, the client is encouraged to retry the lock request until the lock is accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拒否されたファイルをロックしようとする試みをNFS4ERR_DENIED。これは一時的な状態であるかもしれないので、クライアントはロックが受理されるまで、ロック要求を再試行することが奨励されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DQUOT Resource (quota) hard limit exceeded. The user&#39;s resource limit on the server has been exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_DQUOTリソース（クオータ）ハードリミットを超えました。サーバー上のユーザーのリソース制限を超えました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXIST File exists. The file specified already exists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXISTファイルが存在します。指定されたファイルはすでに存在しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXPIRED A lease has expired that is being used in the current operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXPIREDリースは、現在の操作で使用されている有効期限が切れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FBIG File too large. The operation would have caused a file to grow beyond the server&#39;s limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FBIGは、ファイルが大きすぎます。操作は、ファイルがサーバーの制限を超えて成長させただろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FHEXPIRED The filehandle provided is volatile and has expired at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FHEXPIRED提供ファイルハンドルが揮発性であり、サーバーで有効期限が切れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_FILE_OPEN The operation can not be successfully processed because a file involved in the operation is currently open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作に関連するファイルが現在開いているため、操作が正常に処理することができませんNFS4ERR_FILE_OPEN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_GRACE The server is in its recovery or grace period which should match the lease period of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_GRACEサーバは、サーバのリース期間を一致させる必要があり、その回復または猶予期間にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_INVAL Invalid argument or unsupported argument for an operation. Two examples are attempting a READLINK on an object other than a symbolic link or specifying a value for an enum field that is not defined in the protocol (e.g., nfs_ftype4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_INVAL無効な引数や操作のためにサポートされていない引数。二つの例は、シンボリックリンク以外のオブジェクトにREADLINKを試行またはプロトコル（例えば、nfs_ftype4）で定義されていない列挙フィールドの値を指定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_IO I/O error. A hard error (for example, a disk error) occurred while processing the requested operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_IO I / Oエラー。要求された操作を処理している間（例えば、ディスクエラー）ハードエラーが発生しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ISDIR Is a directory. The caller specified a directory in a non-directory operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ISDIRはディレクトリです。呼び出し側が非ディレクトリ操作でディレクトリを指定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LEASE_MOVED A lease being renewed is associated with a filesystem that has been migrated to a new server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいサーバに移行されたファイルシステムに関連付けられている更新されたリースをNFS4ERR_LEASE_MOVED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCKED A read or write operation was attempted on a locked file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCKED Aの読み取りまたは書き込み操作がロックされたファイルにしようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCK_NOTSUPP Server does not support atomic upgrade or downgrade of locks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCK_NOTSUPP Serverは、ロックの原子アップグレードまたはダウングレードをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCK_RANGE A lock request is operating on a sub-range of a current lock for the lock owner and the server does not support this type of request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCK_RANGE Aロック要求がロック所有者の現在のロックのサブ範囲で動作し、サーバは、要求のこのタイプをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCKS_HELD A CLOSE was attempted and file locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_LOCKS_HELD A CLOSEを試みたとファイルロックはCLOSEの後に存在することになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MINOR_VERS_MISMATCH The server has received a request that specifies an unsupported minor version. The server must return a COMPOUND4res with a zero length operations result array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MINOR_VERS_MISMATCHサーバがサポートされていないマイナーバージョンを指定する要求を受信しました。サーバは、長さゼロの操作結果アレイとCOMPOUND4resを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MLINK Too many hard links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MLINKあまりにも多くのハードリンク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MOVED The filesystem which contains the current filehandle object has been relocated or migrated to another server. The client may obtain the new filesystem location by obtaining the &#34;fs_locations&#34; attribute for the current filehandle. For further discussion, refer to the section &#34;Filesystem Migration or Relocation&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_MOVED現在のファイルハンドルオブジェクトが含まれているファイルシステムは、移転または別のサーバーに移行されました。クライアントは、現在のファイルハンドルのための「fs_位置」属性を取得することによって、新しいファイルシステムの場所を得ることができます。さらなる議論については、「ファイルシステムの移行または再配置」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NAMETOOLONG The filename in an operation was too long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作でファイル名をNFS4ERR_NAMETOOLONGが長すぎました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOENT No such file or directory. The file or directory name specified does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOENTそのようなファイルやディレクトリはありません。指定したファイルまたはディレクトリ名は存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOFILEHANDLE The logical current filehandle value (or, in the case of RESTOREFH, the saved filehandle value) has not been set properly. This may be a result of a malformed COMPOUND operation (i.e., no PUTFH or PUTROOTFH before an operation that requires the current filehandle be set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOFILEHANDLE論理現在のファイルハンドル値（または、RESTOREFHの場合には、保存されたファイルハンドル値）が適切に設定されていません。これは、（現在のファイルハンドルを設定する必要があり、操作の前に、すなわち、無PUTFH又はPUTROOTFH）不正な複合操作の結果であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NO_GRACE A reclaim of client state has fallen outside of the grace period of the server. As a result, the server can not guarantee that conflicting state has not been provided to another client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NO_GRACEは、クライアントの状態の再利用は、サーバーの猶予期間の外に落ちています。その結果、サーバは相反する状態が別のクライアントに提供されていないことを保証することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOSPC No space left on device. The operation would have caused the server&#39;s filesystem to exceed its limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4 ERR NOSPCデバイスに残さスペースがありません。操作は、その限界を超えるサーバのファイルシステムを引き起こしているだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTDIR Not a directory. The caller specified a non-directory in a directory operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTDIRないディレクトリ。呼び出し側はディレクトリ操作で非ディレクトリを指定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTEMPTY An attempt was made to remove a directory that was not empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTEMPTYは試みが空ではなかったディレクトリを削除しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTSUPP Operation is not supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOTSUPP操作がサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOT_SAME This error is returned by the VERIFY operation to signify that the attributes compared were not the same as provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NOT_SAMEこのエラーは、クライアントの要求で提供される比較の属性が同じではなかったことを意味するベリファイ動作によって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NXIO I/O error. No such device or address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_NXIO I / Oエラー。そのようなデバイスんまたはアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OLD_STATEID A stateid which designates the locking state for a lockowner-file at an earlier time was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OLD_STATEID早い時点でlockownerファイルのロック状態を指定するのstateidを使用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OPENMODE The client attempted a READ, WRITE, LOCK or SETATTR operation not sanctioned by the stateid passed (e.g., writing to a file opened only for read).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OPENMODEクライアントはなstateid渡された（例えば、ファイルへの書き込みは、読み取りのためにのみ開かれた）によって認可いないREAD、WRITE、LOCKまたはSETATTR操作を実行しようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL An illegal operation value has been specified in the argop field of a COMPOUND or CB_COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGALアン不正操作値は、化合物またはCB_COMPOUND手順のargopフィールドに指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_PERM Not owner. The operation was not allowed because the caller is either not a privileged user (root) or not the owner of the target of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_PERMない所有者。発呼者が特権ユーザ（ルート）であるか否か、操作の対象の所有者のいずれかではないため、操作は許可されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_BAD The reclaim provided by the client does not match any of the server&#39;s state consistency checks and is bad.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_BADクライアントが提供する再利用は、サーバーの状態の整合性チェックのいずれかに一致して悪いことはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_CONFLICT The reclaim provided by the client has encountered a conflict and can not be provided. Potentially indicates a misbehaving client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RECLAIM_CONFLICTクライアントが提供する再利用は、競合が発生したため、提供することはできません。潜在的に誤動作クライアントを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RESOURCE For the processing of the COMPOUND procedure, the server may exhaust available resources and can not continue processing operations within the COMPOUND procedure. This error will be returned from the server in those instances of resource exhaustion related to the processing of the COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RESOURCEはCOMPOUND手順の処理のために、サーバは、利用可能なリソースを使い果たしてもよいし、化合物プロシージャ内の処理動作を継続することができません。このエラーはCOMPOUND手順の処理に関連するリソースの枯渇のこれらの例では、サーバから返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RESTOREFH The RESTOREFH operation does not have a saved filehandle (identified by SAVEFH) to operate upon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_RESTOREFHザ・RESTOREFH操作は時に動作するように（SAVEFHによって識別される）保存されたファイルハンドルを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ROFS Read-only filesystem. A modifying operation was attempted on a read-only filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_ROFSは、読み取り専用ファイルシステムを。変更操作は、読み取り専用のファイルシステム上で実行しようとしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SAME This error is returned by the NVERIFY operation to signify that the attributes compared were the same as provided in the client&#39;s request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SAMEこのエラーは、クライアントの要求で提供される比べ属性が同じであったことを示すためにNVERIFY操作によって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SERVERFAULT An error occurred on the server which does not map to any of the legal NFS version 4 protocol error values. The client should translate this into an appropriate error. UNIX clients may choose to translate this to EIO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
法律上のNFSバージョン4つのプロトコルエラー値のいずれかにマップされないサーバー上で発生したエラーをNFS4ERR_SERVERFAULT。クライアントは、適切なエラーにこれを変換する必要があります。 UNIXクライアントがEIOにこれを翻訳することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SHARE_DENIED An attempt to OPEN a file with a share reservation has failed because of a share conflict.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シェア予約でファイルを開こうとしNFS4ERR_SHARE_DENIEDため、株式紛争のに失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE Invalid filehandle. The filehandle given in the arguments was invalid. The file referred to by that filehandle no longer exists or access to it has been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE無効なファイルハンドル。引数に指定したファイルハンドルが無効でした。そのファイルハンドルが参照するファイルは、もはや存在しないか、それへのアクセス取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE_CLIENTID A clientid not recognized by the server was used in a locking or SETCLIENTID_CONFIRM request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE_CLIENTID Aはロック又はSETCLIENTID_CONFIRM要求で使用されたサーバーによって認識されないのClientID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE_STATEID A stateid generated by an earlier server instance was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_STALE_STATEID Aは、インスタンスを使用した以前のサーバによって生成のstateid。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SYMLINK The current filehandle provided for a LOOKUP is not a directory but a symbolic link. Also used if the final component of the OPEN path is a symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_SYMLINK LOOKUPのために設けられた電流ファイルハンドルは、ディレクトリが、シンボリックリンクではありません。 OPENパスの最後の構成要素がシンボリックリンクである場合にも使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_TOOSMALL The encoded response to a READDIR request exceeds the size limit set by the initial request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR要求に符号化された応答は、最初の要求により設定されたサイズ制限を超えNFS4ERR_TOOSMALL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_WRONGSEC The security mechanism being used by the client for the operation does not match the server&#39;s security policy. The client should change the security mechanism being used and retry the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_WRONGSECは、操作のために、クライアントによって使用されているセキュリティ・メカニズムは、サーバーのセキュリティポリシーと一致していません。クライアントが使用されているセキュリティ・メカニズムを変更し、操作を再試行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_XDEV Attempt to do an operation between different fsids.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_XDEVは異なるfsids間の動作を行うことを試みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. NFS version 4 Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. NFSバージョン4つの要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the NFS version 4 RPC program, there are two traditional RPC procedures: NULL and COMPOUND. All other functionality is defined as a set of operations and these operations are defined in normal XDR/RPC syntax and semantics. However, these operations are encapsulated within the COMPOUND procedure. This requires that the client combine one or more of the NFS version 4 operations into a single request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NULLとCOMPOUND：NFSバージョン4 RPCプログラムの場合は、2つの伝統的なRPCの手順があります。その他のすべての機能は、一連の操作として定義されており、これらの操作は、通常のXDR / RPCの構文およびセマンティクスで定義されています。しかし、これらの操作は、COMPOUNDプロシージャ内に封入されています。これにより、クライアントは単一の要求にNFSバージョン4のいずれかの操作を組み合わせることが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS4_CALLBACK program is used to provide server to client signaling and is constructed in a similar fashion as the NFS version 4 program. The procedures CB_NULL and CB_COMPOUND are defined in the same way as NULL and COMPOUND are within the NFS program. The CB_COMPOUND request also encapsulates the remaining operations of the NFS4_CALLBACK program. There is no predefined RPC program number for the NFS4_CALLBACK program. It is up to the client to specify a program number in the &#34;transient&#34; program range. The program and port number of the NFS4_CALLBACK program are provided by the client as part of the SETCLIENTID/SETCLIENTID_CONFIRM sequence. The program and port can be changed by another SETCLIENTID/SETCLIENTID_CONFIRM sequence, and it is possible to use the sequence to change them within a client incarnation without removing relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4_CALLBACKプログラムは、クライアント・シグナリングにサーバーを提供するために使用され、NFSバージョン4プログラムと同様の方法で構成されています。 NULLおよび化合物はNFSプログラム内にあるような手順CB_NULLとCB_COMPOUNDも同様に定義されます。 CB_COMPOUND要求もNFS4_CALLBACKプログラムの残りの操作をカプセル化します。 NFS4_CALLBACKプログラムには事前に定義されたRPCプログラム番号がありません。これは、「一時的な」プログラムの範囲でプログラム番号を指定するには、クライアント次第です。 NFS4_CALLBACKプログラムのプログラムとポート番号はSETCLIENTID / SETCLIENTID_CONFIRMシーケンスの一部として、クライアントによって提供されています。プログラムとポートが別のSETCLIENTID / SETCLIENTID_CONFIRMシーケンスにより変更することができ、そして関連するリースのクライアントの状態を削除せずに、クライアントの化身内でそれらを変更するシーケンスを使用することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Compound Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1。 COMPOUND手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure provides the opportunity for better performance within high latency networks. The client can avoid cumulative latency of multiple RPCs by combining multiple dependent operations into a single COMPOUND procedure. A compound operation may provide for protocol simplification by allowing the client to combine basic procedures into a single request that is customized for the client&#39;s environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順は、高遅延ネットワーク内のパフォーマンス向上のための機会を提供します。クライアントは、単一の化合物の手順に複数の依存の操作を組み合わせることにより、複数のRPCの累積遅延を回避することができます。化合物の操作は、クライアントは、クライアントの環境に合わせてカスタマイズされた単一の要求に基本的な手順を組み合わせてできるようにすることで、プロトコルの簡素化を提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure precisely parallels the features of COMPOUND as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のようにCB_COMPOUND手順は正確化合物の機能に匹敵します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic structure of the COMPOUND procedure is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順の基本的な構造は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----+--------------+--------+-----------+-----------+-----------+--
   | tag | minorversion | numops | op + args | op + args | op + args |
   +-----+--------------+--------+-----------+-----------+-----------+-- and the reply&#39;s structure is:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +------------+-----+--------+-----------------------+--
      |last status | tag | numres | status + op + results |
      +------------+-----+--------+-----------------------+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The numops and numres fields, used in the depiction above, represent the count for the counted array encoding use to signify the number of arguments or results encoded in the request and response. As per the XDR encoding, these counts must match exactly the number of operation arguments or results encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の描写に使用numopsとnumresフィールドは、要求に応答して符号化された引数または結果の数を意味するカウントアレイエンコード用のカウントを表します。 XDRエンコーディングごとに、これらのカウントは正確にエンコードされた操作の引数や結果の数と一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Evaluation of a Compound Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2。複合要求の評価
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will process the COMPOUND procedure by evaluating each of the operations within the COMPOUND procedure in order. Each component operation consists of a 32 bit operation code, followed by the argument of length determined by the type of operation. The results of each operation are encoded in sequence into a reply buffer. The results of each operation are preceded by the opcode and a status code (normally zero). If an operation results in a non-zero status code, the status will be encoded and evaluation of the compound sequence will halt and the reply will be returned. Note that evaluation stops even in the event of &#34;non error&#34; conditions such as NFS4ERR_SAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、注文中の化合物のプロシージャ内の各操作を評価することにより、化合物手続きを処理します。各コンポーネントの動作は、操作の種類によって決定される長さの引数に続く32ビットのオペコードからなります。各演算の結果が応答バッファ内に順に符号化されます。各演算の結果がオペコードとステータスコード（通常はゼロ）が先行しています。ゼロ以外のステータスコードの動作結果場合、ステータスは、符号化され、化合物配列の評価は停止し、応答が返されます。評価がさえ、このようなNFS4ERR_SAMEなどの「非エラー」の条件の場合に停止することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are no atomicity requirements for the operations contained within the COMPOUND procedure. The operations being evaluated as part of a COMPOUND request may be evaluated simultaneously with other COMPOUND requests that the server receives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順内に含まれる操作にはアトミック要件はありません。複合要求の一部として評価されている操作は、サーバーが受信した他の化合物の要求と同時に評価することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is the client&#39;s responsibility for recovering from any partially completed COMPOUND procedure. Partially completed COMPOUND procedures may occur at any point due to errors such as NFS4ERR_RESOURCE and NFS4ERR_DELAY. This may occur even given an otherwise valid operation string. Further, a server reboot which occurs in the middle of processing a COMPOUND procedure may leave the client with the difficult task of determining how far COMPOUND processing has proceeded. Therefore, the client should avoid overly complex COMPOUND procedures in the event of the failure of an operation within the procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、任意の部分的に完成されたCOMPOUND手順から回復するためのクライアントの責任です。部分的に完成したCOMPOUND手順は、NFS4ERR_RESOURCEとNFS4ERR_DELAYなどのエラーに起因する任意の時点で起こり得ます。これはさえそうでない場合は有効な操作文字列与え発生する可能性があります。さらに、COMPOUND手順の処理の途中で発生するサーバーの再起動がはるかCOMPOUND処理が進んでいるかを決定するのは困難な作業でクライアントを残すことができます。そのため、クライアントは、プロシージャ内の動作障害が発生した場合に、過度に複雑なCOMPOUND手順を避ける必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each operation assumes a &#34;current&#34; and &#34;saved&#34; filehandle that is available as part of the execution context of the compound request. Operations may set, change, or return the current filehandle. The &#34;saved&#34; filehandle is used for temporary storage of a filehandle value and as operands for the RENAME and LINK operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各操作は、複合要求の実行コンテキストの一部として利用可能である「現在の」および「保存」ファイルハンドルをとります。操作は、設定変更、または現在のファイルハンドルを返すことがあります。 「保存」ファイルハンドルは、ファイルハンドルの値を一時的に保存するためにと名前を変更し、LINK操作のオペランドとして使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. Synchronous Modifying Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3。同期の変更操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS version 4 operations that modify the filesystem are synchronous. When an operation is successfully completed at the server, the client can depend that any data associated with the request is now on stable storage (the one exception is in the case of the file data in a WRITE operation with the UNSTABLE option specified).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルシステムを変更するNFSバージョン4つの操作が同期しています。操作が正常にサーバーに完了すると、クライアントは、要求に関連付けられたすべてのデータは、安定したストレージ上に今あることを依存することができます（唯一の例外は、指定されたUNSTABLEオプションとWRITE操作でファイルデータの場合です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This implies that any previous operations within the same compound request are also reflected in stable storage. This behavior enables the client&#39;s ability to recover from a partially executed compound request which may resulted from the failure of the server. For example, if a compound request contains operations A and B and the server is unable to send a response to the client, depending on the progress the server made in servicing the request the result of both operations may be reflected in stable storage or just operation A may be reflected. The server must not have just the results of operation B in stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、同じ化合物の要求内の任意の以前の動作も安定したストレージに反映されていることを意味します。この動作は、サーバの障害に起因して部分的に実行する複合要求から回復するためのクライアントの能力を可能にします。例えば、化合物の要求は、操作AおよびBを含み、サーバは、クライアントに応答を送信することができない、両方の操作の結果は、安定な保存または単に操作に反映させることができる要求をサービスの進捗に応じてサーバ場合反射されてもよいです。サーバーは安定したストレージに操作Bの結果だけを持っていなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. Operation Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4。演算値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operations encoded in the COMPOUND procedure are identified by operation values. To avoid overlap with the RPC procedure numbers, operations 0 (zero) and 1 are not defined. Operation 2 is not defined but reserved for future use with minor versioning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順で符号化操作は、操作値によって識別されます。 RPCプロシージャ番号の重複を避けるために、操作0（ゼロ）と1が定義されていません。操作2が定義されているがマイナーバージョンとの将来の使用のために予約されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. NFS version 4 Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. NFSバージョン4つの手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. Procedure 0: NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1。手順0：NULL  - 動作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;null&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;NULL&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Standard NULL procedure. Void argument, void response. This procedure has no functionality associated with it. Because of this it is sometimes used to measure the overhead of processing a service request. Therefore, the server should ensure that no unnecessary work is done in servicing this procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
標準NULL手続き。ボイド引数、無効応答。この手順は、それに関連付けられた機能を持っていません。このため、時々、サービス要求の処理のオーバーヘッドを測定するために使用されます。そのため、サーバは不要な作業は、この手順を整備中で行われていないことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
None.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
無し。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. Procedure 1: COMPOUND - Compound Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2。手順1：COMPOUND  - 化合物の操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
compoundargs -&gt; compoundres
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
compoundargs  - &gt; compoundres
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_argop4 switch (nfs_opnum4 argop) {
             case &lt;OPCODE&gt;: &lt;argument&gt;;
             ...
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct COMPOUND4args {
             utf8str_cs      tag;
             uint32_t        minorversion;
             nfs_argop4      argarray&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_resop4 switch (nfs_opnum4 resop){
             case &lt;OPCODE&gt;: &lt;result&gt;;
             ...
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct COMPOUND4res {
             nfsstat4        status;
             utf8str_cs      tag;
             nfs_resop4      resarray&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure is used to combine one or more of the NFS operations into a single RPC request. The main NFS RPC program has two main procedures: NULL and COMPOUND. All other operations use the COMPOUND procedure as a wrapper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順は、単一のRPC要求にNFS操作の1つまたは複数を組み合わせるために使用されます。 NULLとCOMPOUND：メインNFS RPCプログラムは、主に2つの手順があります。他のすべての操作は、ラッパーとしてCOMPOUNDプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND procedure is used to combine individual operations into a single RPC request. The server interprets each of the operations in turn. If an operation is executed by the server and the status of that operation is NFS4_OK, then the next operation in the COMPOUND procedure is executed. The server continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順は、単一のRPC要求に個々の操作を組み合わせるために使用されます。サーバは、順番にそれぞれの操作を解釈します。動作は、サーバによって実行され、その操作のステータスがNFS4_OKである場合、COMPOUND手順における次の動作が実行されます。が実行されるべきそれ以上の操作がされないかのいずれかの操作がNFS4_OK以外の状態値を有するまで、サーバは、このプロセスを継続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the processing of the COMPOUND procedure, the server may find that it does not have the available resources to execute any or all of the operations within the COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the COMPOUND sequence have been evaluated successfully. The results for all of the evaluated operations must be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順の処理では、サーバはそれがCOMPOUND配列内の操作のいずれか、またはすべてを実行するために使用可能なリソースを持っていないことがあります。この場合、エラーNFS4ERR_RESOURCEは、リソースの枯渇が発生しCOMPOUNDプロシージャ内の特定の操作のために返されます。これは、化合物配列内のすべての以前の操作が正常に評価されていることを前提としています。評価したすべての操作の結果はクライアントに返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will generally choose between two methods of decoding the client&#39;s request. The first would be the traditional one-pass XDR decode, in which decoding of the entire COMPOUND precedes execution of any operation within it. If there is an XDR decoding error in this case, an RPC XDR decode error would be returned. The second method would be to make an initial pass to decode the basic COMPOUND request and then to XDR decode each of the individual operations, as the server is ready to execute it. In this case, the server may encounter an XDR decode error during such an operation decode, after previous operations within the COMPOUND have been executed. In this case, the server would return the error NFS4ERR_BADXDR to signify the decode error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、一般的にクライアントの要求を復号化する二つの方法のどちらかを選択します。最初は、化合物全体の復号がその中に任意の操作の実行に先行する従来のワンパスXDRデコード、あろう。この場合XDRデコードエラーがある場合、RPCのXDRデコードエラーが返されることになります。第二の方法は、塩基性化合物の要求を復号化するための初期のパスを作成し、サーバはそれを実行する準備ができているように、次にXDRに、個々の操作のそれぞれを復号化することであろう。この場合、サーバは、その化合物内の前の操作が実行された後、このような動作デコード中XDRデコードエラーが発生する場合があります。この場合、サーバは、デコードエラーを示すために、エラーNFS4ERR_BADXDRを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMPOUND arguments contain a &#34;minorversion&#34; field. The initial and default value for this field is 0 (zero). This field will be used by future minor versions such that the client can communicate to the server what minor version is being requested. If the server receives a COMPOUND procedure with a minorversion field value that it does not support, the server MUST return an error of NFS4ERR_MINOR_VERS_MISMATCH and a zero length resultdata array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUNDの引数は「MINORVERSION」フィールドが含まれています。このフィールドの初期およびデフォルト値は0（ゼロ）です。このフィールドは、クライアントが要求されているマイナーバージョンをサーバーに伝えることができるように、将来のマイナーバージョンによって使用されます。サーバがサポートしていないMINORVERSIONフィールド値を有する化合物の手続きを受信した場合、サーバはNFS4ERR_MINOR_VERS_MISMATCHの誤差とゼロ長resultdata配列を返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contained within the COMPOUND results is a &#34;status&#34; field. If the results array length is non-zero, this status must be equivalent to the status of the last operation that was executed within the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND結果に含まれる「状態」フィールドです。結果の配列の長さがゼロでない場合、この状態は内で実行された最後の操作の状態と同等でなければなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND procedure. Therefore, if an operation incurred an error then the &#34;status&#34; value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPOUND手順。操作がエラーを発生した場合、したがって、次に「状態」の値は、失敗した操作のために返される同じエラー値となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that operations, 0 (zero) and 1 (one) are not defined for the COMPOUND procedure. Operation 2 is not defined but reserved for future definition and use with minor versioning. If the server receives a operation array that contains operation 2 and the minorversion field has a value of 0 (zero), an error of NFS4ERR_OP_ILLEGAL, as described in the next paragraph, is returned to the client. If an operation array contains an operation 2 and the minorversion field is non-zero and the server does not support the minor version, the server returns an error of NFS4ERR_MINOR_VERS_MISMATCH. Therefore, the NFS4ERR_MINOR_VERS_MISMATCH error takes precedence over all other errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作、0（ゼロ）と1（1）はCOMPOUND手順のために定義されていないことに留意されたいです。操作2が定義されているが、将来の定義のために予約し、マイナーバージョンで使用されていません。サーバが動作2を含み、MINORVERSIONフィールドが0（ゼロ）の値を有する演算アレイ、NFS4ERR_OP_ILLEGALのエラーを受信した場合、次の段落で説明したように、クライアントに返されます。操作配列が操作2を含んでおり、MINORVERSIONフィールドがゼロでないと、サーバがマイナーバージョンをサポートしていない場合、サーバーはNFS4ERR_MINOR_VERS_MISMATCHのエラーを返します。したがって、NFS4ERR_MINOR_VERS_MISMATCHエラーは、他のすべてのエラーよりも優先されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that the server receives a request that contains an operation that is less than the first legal operation (OP_ACCESS) or greater than the last legal operation (OP_RELEASE_LOCKOWNER).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが最後の法的な操作（OP_RELEASE_LOCKOWNER）よりも第1の法的動作（OP_ACCESS）未満以上である動作を含む要求を受信することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, the server&#39;s response will encode the opcode OP_ILLEGAL rather than the illegal opcode of the request. The status field in the ILLEGAL return results will set to NFS4ERR_OP_ILLEGAL. The COMPOUND procedure&#39;s return results will also be NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、サーバの応答は、オペコードOP_ILLEGALではなく、要求の不正命令コードをエンコードします。 ILLEGALリターン結果のステータスフィールドはNFS4ERR_OP_ILLEGALに設定されます。 COMPOUND手順のリターン結果もNFS4ERR_OP_ILLEGALになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of the &#34;tag&#34; in the request is left to the implementor. It may be used to summarize the content of the compound request for the benefit of packet sniffers and engineers debugging implementations. However, the value of &#34;tag&#34; in the response SHOULD be the same value as provided in the request. This applies to the tag field of the CB_COMPOUND procedure as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスト内の「タグ」の定義は実装者に任されています。パケットスニファおよび実装のデバッグ技術の利益のために化合物の要求の内容を要約するために使用することができます。しかし、応答の「タグ」の値は、要求で提供されるような同じ値であるべきです。これは、同様にCB_COMPOUND手順のタグフィールドに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since an error of any type may occur after only a portion of the operations have been evaluated, the client must be prepared to recover from any failure. If the source of an NFS4ERR_RESOURCE error was a complex or lengthy set of operations, it is likely that if the number of operations were reduced the server would be able to evaluate them successfully. Therefore, the client is responsible for dealing with this type of complexity in recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
操作の一部のみが評価された後、任意のタイプのエラーが発生する可能性があるので、クライアントは、任意の障害から回復するために用意されなければなりません。 NFS4ERR_RESOURCEエラーの原因が業務の複雑または長いセットした場合は、操作の数が減少した場合、サーバーが正常にそれらを評価することができるだろうと思われます。そのため、クライアントは回復における複雑さのこのタイプを扱うための責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All errors defined in the protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルで定義されたすべてのエラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.1. Operation 3: ACCESS - Check Access Rights
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.1。動作3：アクセス - アクセス権限をチェック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), accessreq -&gt; supported, accessrights
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、accessreq  - &gt;サポート、て、AccessRights
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     const ACCESS4_READ      = 0x00000001;
     const ACCESS4_LOOKUP    = 0x00000002;
     const ACCESS4_MODIFY    = 0x00000004;
     const ACCESS4_EXTEND    = 0x00000008;
     const ACCESS4_DELETE    = 0x00000010;
     const ACCESS4_EXECUTE   = 0x00000020;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct ACCESS4args {
             /* CURRENT_FH: object */
             uint32_t        access;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct ACCESS4resok {
             uint32_t        supported;
             uint32_t        access;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union ACCESS4res switch (nfsstat4 status) {
      case NFS4_OK:
              ACCESS4resok   resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS determines the access rights that a user, as identified by the credentials in the RPC request, has with respect to the file system object specified by the current filehandle. The client encodes the set of access rights that are to be checked in the bit mask &#34;access&#34;. The server checks the permissions encoded in the bit mask. If a status of NFS4_OK is returned, two bit masks are included in the response. The first, &#34;supported&#34;, represents the access rights for which the server can verify reliably. The second, &#34;access&#34;, represents the access rights available to the user for the filehandle provided. On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESSは、RPC要求に資格情報によって識別されるユーザは、現在のファイルハンドルに指定されたファイル・システム・オブジェクトに対して有するアクセス権を決定します。クライアントは、ビットマスク「アクセス」にチェックされるアクセス権のセットを符号化します。サーバはビットマスクで符号化権限をチェックします。 NFS4_OKのステータスが返された場合、2枚のビットマスクが応答に含まれています。 、まず、「サポート」は、サーバが確実に確認することができますするアクセス権を表します。二、「アクセス」、提供ファイルハンドルのためにユーザに利用可能なアクセス権を表します。成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the supported field will contain only as many values as were originally sent in the arguments. For example, if the client sends an ACCESS operation with only the ACCESS4_READ value set and the server supports this value, the server will return only ACCESS4_READ even if it could have reliably checked other values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
元々の引数に送られたとしてサポートフィールドだけのように多くの値が含まれていることに注意してください。クライアントは設定のみACCESS4_READ値にアクセス動作を送信し、サーバーがこの値をサポートしている場合たとえば、サーバーは、それが確実に他の値をチェックすることができた場合でも、唯一のACCESS4_READ戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results of this operation are necessarily advisory in nature. A return status of NFS4_OK and the appropriate bit set in the bit mask does not imply that such access will be allowed to the file system object in the future. This is because access rights can be revoked by the server at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作の結果は、自然の中で必然的に助言しています。 NFS4_OKの戻りステータスとビットマスクに設定された適切なビットは、そのようなアクセスは、将来的にファイル・システム・オブジェクトに許可されることを意味するものではありません。アクセス権限は、いつでもサーバーによって取り消すことができるからです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following access permissions may be requested:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のアクセス許可を要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_READ Read data from file or read a directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_READ読むデータファイルまたはディレクトリをお読みください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_LOOKUP Look up a name in a directory (no meaning for non-directory objects).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_LOOKUPディレクトリ（非ディレクトリオブジェクトのための意味無し）で名前を検索します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_MODIFY Rewrite existing file data or modify existing directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のファイルのデータを書き換えたり、既存のディレクトリエントリを変更ACCESS4_MODIFY。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXTEND Write new data or add directory entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXTENDは、新しいデータを書き込むか、ディレクトリエントリを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_DELETE Delete an existing directory entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_DELETEは、既存のディレクトリエントリを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXECUTE Execute file (no meaning for a directory).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS4_EXECUTEは、ファイル（ディレクトリの意味無し）を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, it is not sufficient for the client to attempt to deduce access permissions by inspecting the uid, gid, and mode fields in the file attributes or by attempting to interpret the contents of the ACL attribute. This is because the server may perform uid or gid mapping or enforce additional access control restrictions. It is also possible that the server may not be in the same ID space as the client. In these cases (and perhaps others), the client can not reliably perform an access check with only current file attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがファイル属性でUID、GID、およびモードフィールドを検査することによって、またはACL属性の内容を解釈しようとすることで、アクセス権限を推測しようとするために一般的には、それは十分ではありません。サーバーは、UIDまたはGIDマッピングを実行するか、追加のアクセス制御制限を強制する可能性があるためです。サーバがクライアントと同じIDスペースにないかもしれないことも可能です。 （おそらく他）これらの例では、クライアントは確実にのみ、現在のファイル属性とアクセスチェックを実行することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NFS version 2 protocol, the only reliable way to determine whether an operation was allowed was to try it and see if it succeeded or failed. Using the ACCESS operation in the NFS version 4 protocol, the client can ask the server to indicate whether or not one or more classes of operations are permitted. The ACCESS operation is provided to allow clients to check before doing a series of operations which will result in an access failure. The OPEN operation provides a point where the server can verify access to the file object and method to return that information to the client. The ACCESS operation is still useful for directory operations or for use in the case the UNIX API &#34;access&#34; is used on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン2プロトコルでは、操作が許可されたかどうかを判断する唯一の確実な方法は、それを試してみて、それが成功したか失敗したかどうかを確認することでした。 NFSバージョン4プロトコルでアクセス動作を使用して、クライアントは操作の1つまたは複数のクラスが許可されているかどうかを示すために、サーバに依頼することができます。アクセス動作は、クライアントがアクセス障害につながる一連の操作を行う前にチェックできるようにするために提供されます。 OPEN操作はサーバがクライアントに情報を返すためにファイルオブジェクトとメソッドへのアクセスを確認することができますポイントを提供します。アクセス動作は、まだディレクトリ操作用またはUNIX用API「アクセス」は、クライアント上で使用する場合に使用するのに便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information returned by the server in response to an ACCESS call is not permanent. It was correct at the exact time that the server performed the checks, but not necessarily afterwards. The server can revoke access permission at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスの呼び出しに応じてサーバから返された情報は永久的ではありません。それは必ずしも必要ではないが、その後、サーバがチェックを行って正確な時間で正しかったです。サーバーは、いつでもアクセス許可を取り消すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client should use the effective credentials of the user to build the authentication information in the ACCESS request used to determine access rights. It is the effective user and group credentials that are used in subsequent read and write operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、アクセス権を決定するために使用するアクセス要求で認証情報を構築するために、ユーザーの効果的な資格情報を使用する必要があります。これは、その後の読み取りおよび書き込み操作に使用されている有効なユーザおよびグループの資格情報です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many implementations do not directly support the ACCESS4_DELETE permission. Operating systems like UNIX will ignore the ACCESS4_DELETE bit if set on an access request on a non-directory object. In these systems, delete permission on a file is determined by the access permissions on the directory in which the file resides, instead of being determined by the permissions of the file itself. Therefore, the mask returned enumerating which access rights can be determined will have the ACCESS4_DELETE value set to 0. This indicates to the client that the server was unable to check that particular access right. The ACCESS4_DELETE bit in the access mask returned will then be ignored by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの実装では、直接ACCESS4_DELETE許可をサポートしていません。非ディレクトリ・オブジェクトに対するアクセス要求に設定した場合、UNIXのようなオペレーティングシステムはACCESS4_DELETEビットを無視します。これらのシステムでは、ファイルのアクセス許可を削除する代わりに、ファイル自体の権限によって決定されるのファイルが存在するディレクトリへのアクセス権限によって決定されます。そのため、マスクは、これは、サーバーがその特定のアクセス権を確認することができなかったことをクライアントに指示する0に設定ACCESS4_DELETE値を持つことになります判断することができる権利にアクセス列挙を返しました。返されたアクセスマスクでACCESS4_DELETEビットは、クライアントによって無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.2. Operation 4: CLOSE - Close File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.2。操作4：CLOSE  - ファイルを閉じます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), seqid, open_stateid -&gt; open_stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、SEQID、open_stateid  - &gt; open_stateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CLOSE4args {
             /* CURRENT_FH: object */
             seqid4          seqid
             stateid4        open_stateid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union CLOSE4res switch (nfsstat4 status) {
      case NFS4_OK:
              stateid4       open_stateid;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CLOSE operation releases share reservations for the regular or named attribute file as specified by the current filehandle. The share reservations and other state information released at the server as a result of this CLOSE is only associated with the supplied stateid. The sequence id provides for the correct ordering. State associated with other OPENs is not affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルで指定されCLOSE操作は、通常のまたは名前付き属性ファイルの共有の予約を解放します。共有予約このCLOSEの結果としてサーバで放出他の状態情報のみ供給のstateidと関連しています。シーケンスIDは、正しい順序付けのために用意されています。他のOPENsに関連した状態は影響を受けません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If record locks are held, the client SHOULD release all locks before issuing a CLOSE. The server MAY free all outstanding locks on CLOSE but some servers may not support the CLOSE of a file that still has record locks held. The server MUST return failure if any locks would exist after the CLOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコードロックが保持されている場合、クライアントはCLOSEを発行する前に、すべてのロックを解除しなければなりません。サーバーは、CLOSE上のすべての未解決のロックを解放するかもしれませんが、いくつかのサーバは、まだ開催されたレコードロックを持っているファイルのCLOSEをサポートしていないかもしれません。すべてのロックは、CLOSEの後に存在するならば、サーバーは失敗を返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though CLOSE returns a stateid, this stateid is not useful to the client and should be treated as deprecated. CLOSE &#34;shuts down&#34; the state associated with all OPENs for the file by a single open_owner. As noted above, CLOSE will either release all file locking state or return an error. Therefore, the stateid returned by CLOSE is not useful for operations that follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLOSEがたstateidを返すにもかかわらず、これのstateidは、クライアントにとって有用なものではなく、非推奨として扱われるべきです。 CLOSE単一open_ownerによってファイルのすべてのOPENsに関連付けられている状態を「シャットダウンします」。上述したように、CLOSE状態をロックするすべてのファイルを解放するか、またはエラーが返されるいずれかです。したがって、CLOSEによって返されたstateidは続く操作のために有用ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKS_HELD NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKS_HELD NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.3. Operation 5: COMMIT - Commit Cached Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.3。操作5：COMMITは - キャッシュされたデータをコミット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), offset, count -&gt; verifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、オフセット、カウント - &gt;検証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct COMMIT4args {
             /* CURRENT_FH: file */
             offset4         offset;
             count4          count;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct COMMIT4resok {
             verifier4       writeverf;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union COMMIT4res switch (nfsstat4 status) {
      case NFS4_OK:
              COMMIT4resok   resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMMIT operation forces or flushes data to stable storage for the file specified by the current filehandle. The flushed data is that which was previously written with a WRITE operation which had the stable field set to UNSTABLE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルで指定されたファイルのために安定したストレージに操作力やフラッシュのデータをコミットします。フラッシュされたデータは、以前UNSTABLE4に安定したフィールドのセットを持っていたWRITE操作で書かれたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The offset specifies the position within the file where the flush is to begin. An offset value of 0 (zero) means to flush data starting at the beginning of the file. The count specifies the number of bytes of data to flush. If count is 0 (zero), a flush from offset to the end of the file is done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセットは、フラッシュが開始するファイル内の位置を指定します。 0（ゼロ）のオフセット値は、ファイルの先頭からデータをフラッシュすることを意味します。カウントは、フラッシュへのデータのバイト数を指定します。カウントが0（ゼロ）の場合、ファイルの最後にオフセットからのフラッシュが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server returns a write verifier upon successful completion of the COMMIT. The write verifier is used by the client to determine if the server has restarted or rebooted between the initial WRITE(s) and the COMMIT. The client does this by comparing the write verifier returned from the initial writes and the verifier returned by the COMMIT operation. The server must vary the value of the write verifier at each server event or instantiation that may lead to a loss of uncommitted data. Most commonly this occurs when the server is rebooted; however, other events at the server may result in uncommitted data loss as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、COMMITが正常に完了すると、書き込みベリファイアを返します。書き込みベリファイアは、サーバが再起動または初期WRITE（S）とCOMMITの間再起動しているかどうかを決定するためにクライアントによって使用されます。クライアントは、最初の書き込みとCOMMIT操作によって返された検証者から返された書き込みベリファイアを比較することによって、これを行います。サーバは、コミットされていないデータの損失につながる可能性があり、各サーバイベントまたはインスタンスに書き込み検証の値を変更しなければなりません。サーバーが再起動されたときに最も一般的には、これは発生します。ただし、サーバーで他のイベントも同様にコミットされていないデータが失われることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The COMMIT operation is similar in operation and semantics to the POSIX fsync(2) system call that synchronizes a file&#39;s state with the disk (file data and metadata is flushed to disk or stable storage). COMMIT performs the same operation for a client, flushing any unsynchronized data and metadata on the server to the server&#39;s disk or stable storage for the specified file. Like fsync(2), it may be that there is some modified data or no modified data to synchronize. The data may have been synchronized by the server&#39;s normal periodic buffer synchronization activity. COMMIT should return NFS4_OK, unless there has been an unexpected error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT操作は、POSIX FSYNCディスクにファイルの状態を同期させる（ファイルデータとメタデータがディスクまたは安定記憶にフラッシュされる）、（2）システムコールの動作と意味論に類似しています。 COMMIT指定されたファイルは、サーバーのディスクにサーバーまたは安定したストレージ上の任意の非同期のデータとメタデータをフラッシュする、クライアントのために同じ操作を実行します。 FSYNCように（2）、それはいくつかの変更されたデータ又は同期させる無修正されたデータが存在することであってもよいです。データは、サーバーの正常な周期的なバッファ同期活動で同期されている可能性があります。予期せぬエラーがあった場合を除き、NFS4_OKを返す必要がCOMMIT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMIT differs from fsync(2) in that it is possible for the client to flush a range of the file (most likely triggered by a buffer-reclamation scheme on the client before file has been completely written).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがファイルの範囲を（ファイルが完全に書き込まれる前に、最も可能性の高いクライアント上のバッファ・再生スキームによってトリガ）フラッシュすることが可能であるという点ではfsync（2）とは異なるがCOMMIT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server implementation of COMMIT is reasonably simple. If the server receives a full file COMMIT request, that is starting at offset 0 and count 0, it should do the equivalent of fsync()&#39;ing the file. Otherwise, it should arrange to have the cached data in the range specified by offset and count to be flushed to stable storage. In both cases, any metadata associated with the file must be flushed to stable storage before returning. It is not an error for there to be nothing to flush on the server. This means that the data and metadata that needed to be flushed have already been flushed or lost during the last server failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITのサーバの実装は合理的に簡単です。サーバーは、完全なファイルがCOMMIT要求を受けた場合は0をオフセットし、0カウントで、それが開始され、それはFSYNCの同等の（） &#39;ファイルをINGのを行う必要があります。それ以外の場合は、offsetで指定した範囲のキャッシュされたデータを持っており、安定したストレージにフラッシュされるようにカウントするように手配しなければなりません。どちらの場合も、ファイルに関連付けられたすべてのメタデータが戻る前に、安定したストレージにフラッシュする必要があります。サーバー上で洗い流すことは何もないことはエラーではありません。これはフラッシュするために必要なデータおよびメタデータがすでに最後のサーバ障害時のフラッシュまたは失われていることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client implementation of COMMIT is a little more complex. There are two reasons for wanting to commit a client buffer to stable storage. The first is that the client wants to reuse a buffer. In this case, the offset and count of the buffer are sent to the server in the COMMIT request. The server then flushes any cached data based on the offset and count, and flushes any metadata associated with the file. It then returns the status of the flush and the write verifier. The other reason for the client to generate a COMMIT is for a full file flush, such as may be done at close. In this case, the client would gather all of the buffers for this file that contain uncommitted data, do the COMMIT operation with an offset of 0 and count of 0, and then free all of those buffers. Any other dirty buffers would be sent to the server in the normal fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMMITのクライアントの実装はもう少し複雑です。安定したストレージにクライアントバッファをコミットしたいのための2つの理由があります。最初は、クライアントがバッファを再利用したいということです。この場合、オフセットおよびバッファのカウントがCOMMITリクエストでサーバーに送信されます。次に、サーバーはオフセットとカウントに基づいてキャッシュされたデータをフラッシュし、ファイルに関連付けられたすべてのメタデータをフラッシュします。その後、フラッシュやライト・ベリファイアの状態を返します。 COMMITを生成するためのクライアントのための他の理由は、近くで行うことができるよう、完全なファイルのフラッシュのためです。この場合、クライアントは0の0カウントのオフセット、およびそれらのバッファをすべて、その後自由にCOMMIT操作を行い、コミットされていないデータが含まれているこのファイルのバッファのすべてを収集します。その他のダーティバッファは、通常の方法でサーバに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a buffer is written by the client with the stable parameter set to UNSTABLE4, the buffer must be considered as modified by the client until the buffer has either been flushed via a COMMIT operation or written via a WRITE operation with stable parameter set to FILE_SYNC4 or DATA_SYNC4. This is done to prevent the buffer from being freed and reused before the data can be flushed to stable storage on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファがUNSTABLE4に設定され、安定したパラメータを用いてクライアントによって書き込まれた後にクライアントによって修正され、バッファがFILE_SYNC4に安定したパラメータセットとWRITE動作を介して操作または書き込みをCOMMITまたは介しフラッシュされたかまで、バッファを考慮しなければなりませんDATA_SYNC4。これは、データはサーバー上の安定したストレージにフラッシュする前に解放され、再利用されることから、バッファを防止するために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a response is returned from either a WRITE or a COMMIT operation and it contains a write verifier that is different than previously returned by the server, the client will need to retransmit all of the buffers containing uncommitted cached data to the server. How this is to be done is up to the implementor. If there is only one buffer of interest, then it should probably be sent back over in a WRITE request with the appropriate stable parameter. If there is more than one buffer, it might be worthwhile retransmitting all of the buffers in WRITE requests with the stable parameter set to UNSTABLE4 and then retransmitting the COMMIT operation to flush all of the data on the server to stable storage. The timing of these retransmissions is left to the implementor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答がWRITEかCOMMIT操作のいずれかから返されると、それは以前にサーバから返されたと異なる書き込み検証が含まれている場合、クライアントはサーバーにコミットされていないキャッシュされたデータを含む全てのバッファを再送信する必要があります。これを実行する方法を実装までです。関心の一つだけのバッファが存在する場合、それはおそらく、適切な安定したパラメータを使用してWRITE要求に背を超える送信する必要があります。複数のバッファが存在する場合、それはUNSTABLE4に設定し、安定したパラメータでWRITE要求内のバッファのすべてを再送して、安定したストレージにサーバー上のすべてのデータをフラッシュするCOMMIT操作を再送信する価値があるかもしれません。これらの再送信のタイミングは、実装者に任されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above description applies to page-cache-based systems as well as buffer-cache-based systems. In those systems, the virtual memory system will need to be modified instead of the buffer cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の説明は、ページキャッシュベースのシステムと同様に、バッファ・キャッシュベースのシステムに適用されます。これらのシステムでは、仮想メモリシステムは、バッファ・キャッシュの代わりに変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.4. Operation 6: CREATE - Create a Non-Regular File Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.4。操作6：CREATE  - 非正規ファイルオブジェクトを作成します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), name, type, attrs -&gt; (cfh), change_info, attrs_set
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、名前、タイプ、ATTRS  - &gt;（CFH）、change_info、attrs_set
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union createtype4 switch (nfs_ftype4 type) {
      case NF4LNK:
              linktext4      linkdata;
      case NF4BLK:
      case NF4CHR:
              specdata4      devdata;
      case NF4SOCK:
      case NF4FIFO:
      case NF4DIR:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CREATE4args {
             /* CURRENT_FH: directory for creation */
             createtype4     objtype;
             component4      objname;
             fattr4          createattrs;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CREATE4resok {
             change_info4    cinfo;
             bitmap4         attrset;        /* attributes set */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union CREATE4res switch (nfsstat4 status) {
      case NFS4_OK:
              CREATE4resok resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CREATE operation creates a non-regular file object in a directory with a given name. The OPEN operation MUST be used to create a regular file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CREATE操作は、指定した名前のディレクトリにある非正規ファイルオブジェクトを作成します。 OPEN操作は、通常のファイルを作成するために使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The objname specifies the name for the new object. The objtype determines the type of object to be created: directory, symlink, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
objnameには、新しいオブジェクトの名前を指定します。ディレクトリ、シンボリックリンクなど：OBJTYPEは、作成するオブジェクトの種類を決定します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an object of the same name already exists in the directory, the server will return the error NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ名前のオブジェクトがすでにディレクトリに存在する場合、サーバーはエラーNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the directory where the new file object was created, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the file object creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいファイルオブジェクトが作成されたディレクトリのために、サーバはcinfoの変化_info4情報を返します。前と後の変更属性はファイルオブジェクトの作成に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the objname has a length of 0 (zero), or if objname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
objnameには、UTF-8定義に従わない場合objnameには0（ゼロ）の長さを有する場合、または、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle is replaced by that of the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは、新しいオブジェクトのものに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The createattrs specifies the initial set of attributes for the object. The set of attributes may include any writable attribute valid for the object type. When the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
createattrsは、オブジェクトの属性の初期セットを指定します。一連の属性は、オブジェクト・タイプに対して有効な任意の書き込み可能な属性を含むことができます。操作が成功すると、サーバーはクライアントに正常にオブジェクトに設定された属性の属性マスクの意味を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If createattrs includes neither the owner attribute nor an ACL with an ACE for the owner, and if the server&#39;s filesystem both supports and requires an owner attribute (or an owner ACE) then the server MUST derive the owner (or the owner ACE). This would typically be from the principal indicated in the RPC credentials of the call, but the server&#39;s operating environment or filesystem semantics may dictate other methods of derivation. Similarly, if createattrs includes neither the group attribute nor a group ACE, and if the server&#39;s filesystem both supports and requires the notion of a group attribute (or group ACE), the server MUST derive the group attribute (or the corresponding owner ACE) for the file. This could be from the RPC call&#39;s credentials, such as the group principal if the credentials include it (such as with AUTH_SYS), from the group identifier associated with the principal in the credentials (for e.g., POSIX systems have a passwd database that has the group identifier for every user identifier), inherited from directory the object is created in, or whatever else the server&#39;s operating environment or filesystem semantics dictate. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
createattrsの両方をサポートし、所有者属性も所有者のACEとACL、およびサーバのファイルシステムならばどちらが含まれており、所有者属性（または所有者のACE）が必要な場合は、サーバーは、所有者（または所有者のACE）を導出しなければなりません。これは通常、コールのRPC資格で示さ校長からだろうが、サーバーの動作環境やファイルシステムのセマンティクスが派生する他の方法を指示することができます。 createattrsは、グループ属性やグループACE、およびサーバのファイルシステムの両方をサポートしている場合のいずれもが含まれており、グループの属性（またはグループACE）の概念を必要とする場合も同様に、サーバはグループ属性（または対応する所有者のACE）のために派生しなければなりませんファイル。資格情報が（例えばAUTH_SYSのように）それを含める場合、これは、そのようなグループプリンシパルとしてRPCコールの資格、からかもしれない資格証明書に校長に関連付けられたグループ識別子から（たとえばため、POSIXシステムではありpasswdデータベースを持っていますすべてのユーザ識別子のためのグループ識別子）、オブジェクトが中に作成されたディレクトリから継承された、または任意の他のサーバの動作環境やファイルシステムのセマンティクスが決まります。これは、あまりにもOPEN操作に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Conversely, it is possible the client will specify in createattrs an owner attribute or group attribute or ACL that the principal indicated the RPC call&#39;s credentials does not have permissions to create files for. The error to be returned in this instance is NFS4ERR_PERM. This applies to the OPEN operation too.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆に、クライアントがcreateattrsに本人がためにファイルを作成する権限を持っていないRPC呼び出しの資格を示したことを所有者属性またはグループ属性またはACLを指定しますことも可能です。この例で返されるエラーはNFS4ERR_PERMです。これは、あまりにもOPEN操作に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client desires to set attribute values after the create, a SETATTR operation can be added to the COMPOUND request so that the appropriate attributes will be set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが作成した後、属性値を設定したい場合、適切な属性が設定されるように、SETATTR操作はCOMPOUND要求に追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADOWNER NFS4ERR_BADTYPE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_PERM NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADOWNER NFS4ERR_BADTYPE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_PERM NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.5. Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.5。操作7：DELEGPURGE  - 回復を待ちパージ代表団
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid -&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ClientIDを - &gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct DELEGPURGE4args {
             clientid4       clientid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct DELEGPURGE4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Purges all of the delegations awaiting recovery for a given client. This is useful for clients which do not commit delegation information to stable storage to indicate that conflicting requests need not be delayed by the server awaiting recovery of delegation information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与えられたクライアントのための回復を待っている代表団のすべてを消去します。これは矛盾する要求が委任情報の回復を待って、サーバーによって遅延される必要がないことを示すために、安定したストレージへの委任情報をコミットしていないクライアントのために有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation should be used by clients that record delegation information on stable storage on the client. In this case, DELEGPURGE should be issued immediately after doing delegation recovery on all delegations known to the client. Doing so will notify the server that no additional delegations for the client will be recovered allowing it to free resources, and avoid delaying other clients who make requests that conflict with the unrecovered delegations. The set of delegations known to the server and the client may be different. The reason for this is that a client may fail after making a request which resulted in delegation but before it received the results and committed them to the client&#39;s stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、クライアント上の安定したストレージに記録委任情報というクライアントによって使用されなければなりません。この場合、DELEGPURGEは、クライアントに知られている全ての代表団に委任リカバリを実行した直後に発行されなければなりません。そうすることで、クライアントのための追加の代表団は、リソースを解放することが可能に回復されませんサーバーに通知し、その未回収の代表団との競合要求を行う他のクライアントを遅らせる避けることができます。サーバとクライアントに知られている代表団のセットが異なる場合があります。この理由は、クライアントが委任が生じたが、それは結果を受信し、クライアントの安定した記憶領域にそれらをコミットする前に要求を行った後、失敗する可能性があることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MAY support DELEGPURGE, but if it does not, it MUST NOT support CLAIM_DELEGATE_PREV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーはDELEGPURGEをサポートするかもしれないが、それがない場合、それはCLAIM_DELEGATE_PREVをサポートしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_NOTSUPP NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_RESOURCE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_NOTSUPP NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_RESOURCE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.6. Operation 8: DELEGRETURN - Return Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.6。操作8：DELEGRETURN  - 戻る委任
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid -&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、のstateid  - &gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct DELEGRETURN4args {
             /* CURRENT_FH: delegated file */
             stateid4        stateid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct DELEGRETURN4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Returns the delegation represented by the current filehandle and stateid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルとのstateidで表さ委任を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Delegations may be returned when recalled or voluntarily (i.e., before the server has recalled them). In either case the client must properly propagate state changed under the context of the delegation to the server before returning the delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（サーバは、それらをリコールしている、すなわち、前に）自発的にリコール又は場合委任が返されてもよいです。いずれの場合も、クライアントは正常に状態を伝播しなければならない委任を返す前に、サーバーへの委任のコンテキストで変更。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_INVAL NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_INVAL NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.7. Operation 9: GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.7。操作9：GETATTR  - 属性を取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), attrbits -&gt; attrbits, attrvals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、attrbits  - &gt; attrbits、attrvals
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct GETATTR4args {
             /* CURRENT_FH: directory or file */
             bitmap4         attr_request;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct GETATTR4resok {
             fattr4          obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union GETATTR4res switch (nfsstat4 status) {
      case NFS4_OK:
              GETATTR4resok  resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GETATTR operation will obtain attributes for the filesystem object specified by the current filehandle. The client sets a bit in the bitmap argument for each attribute value that it would like the server to return. The server returns an attribute bitmap that indicates the attribute values for which it was able to return, followed by the attribute values ordered lowest attribute number first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETATTR操作は、現在のファイルハンドルで指定されたファイルシステムオブジェクトの属性を取得します。クライアントは、サーバーが返すしたい各属性値のビットマップ引数のビットを設定します。サーバーは、最初に最低の属性番号を注文した属性値に続いて、それを返すことができた対象の属性値を示す属性ビットマップを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server must return a value for each attribute that the client requests if the attribute is supported by the server. If the server does not support an attribute or cannot approximate a useful value then it must not return the attribute value and must not set the attribute bit in the result bitmap. The server must return an error if it supports an attribute but cannot obtain its value. In that case no attribute values will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性は、サーバーによってサポートされている場合、サーバーはクライアントの要求する各属性の値を返す必要があります。サーバーが属性をサポートしていないか、有益な値に近づけることができない場合、それは属性値を返さなければならないと、結果のビットマップ内の属性ビットを設定してはいけません。それは属性をサポートしていますが、その値を取得できない場合、サーバーはエラーを返す必要があります。その場合には何の属性値が返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All servers must support the mandatory attributes as specified in the section &#34;File Attributes&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション「ファイル属性」に指定されているすべてのサーバーが必須属性をサポートしている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.8. Operation 10: GETFH - Get Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.8。操作10：GETFH  - 現在のファイルハンドルを取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; filehandle
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH） - &gt;ファイルハンドル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct GETFH4resok {
             nfs_fh4         object;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union GETFH4res switch (nfsstat4 status) {
      case NFS4_OK:
             GETFH4resok     resok4;
      default:
             void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation returns the current filehandle value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、現在のファイルハンドル値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operations that change the current filehandle like LOOKUP or CREATE do not automatically return the new filehandle as a result. For instance, if a client needs to lookup a directory entry and obtain its filehandle then the following request is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPのような現在のファイルハンドルを変更したり、CREATE操作は、自動的に結果として新しいファイルハンドルを返しません。例えば、クライアントがディレクトリエントリを検索し、次の要求が必要とされ、そのファイルハンドルを取得する必要がある場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH (directory filehandle) LOOKUP (entry name) GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH（ディレクトリのファイルハンドル）LOOKUP（エントリ名）GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.9. Operation 11: LINK - Create Link to a File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.9。操作11：LINK  - ファイルへのリンクを作成します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh), (cfh), newname -&gt; (cfh), change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（SFH）、（CFH）、NEWNAME  - &gt;（CFH）、change_info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LINK4args {
             /* SAVED_FH: source object */
             /* CURRENT_FH: target directory */
             component4      newname;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LINK4resok {
             change_info4    cinfo;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union LINK4res switch (nfsstat4 status) {
      case NFS4_OK:
              LINK4resok resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LINK operation creates an additional newname for the file represented by the saved filehandle, as set by the SAVEFH operation, in the directory represented by the current filehandle. The existing file and the target directory must reside within the same filesystem on the server. On success, the current filehandle will continue to be the target directory. If an object exists in the target directory with the same name as newname, the server must return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルによって表されるディレクトリに、SAVEFH操作によって設定されたLINK操作は、保存されたファイルハンドルによって表されるファイルのための追加NEWNAMEを作成します。既存のファイルとターゲット・ディレクトリは、サーバー上の同じファイルシステム内に存在する必要があります。成功すると、現在のファイルハンドルは、ターゲットディレクトリであり続けるだろう。オブジェクトがNEWNAMEと同じ名前のターゲットディレクトリに存在する場合、サーバはNFS4ERR_EXISTを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリの場合、サーバはcinfoの変化_info4情報を返します。前と後の変更属性がリンク作成に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the newname has a length of 0 (zero), or if newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NEWNAMEがUTF-8定義に従わない場合NEWNAMEは0（ゼロ）の長さを有する場合、または、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changes to any property of the &#34;hard&#34; linked files are reflected in all of the linked files. When a link is made to a file, the attributes for the file should have a value for numlinks that is one greater than the value before the LINK operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ハード」リンクされたファイルの任意のプロパティを変更すると、リンクされたファイルのすべてに反映されています。リンクをファイルにするとき、ファイルの属性はLINK操作前の値より1大きいnumlinksの値を持つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The statement &#34;file and the target directory must reside within the same filesystem on the server&#34; means that the fsid fields in the attributes for the objects are the same. If they reside on different filesystems, the error, NFS4ERR_XDEV, is returned. On some servers, the filenames, &#34;.&#34; and &#34;..&#34;, are illegal as newname.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
声明「ファイルとターゲット・ディレクトリは、サーバー上の同じファイルシステム内に存在しなければならない」オブジェクトの属性でFSIDフィールドが同じであることを意味します。彼らは別のファイルシステム上に存在する場合は、エラー、NFS4ERR_XDEVは、返されます。一部のサーバーでは、ファイル名、「」そして、「..」、NEWNAMEとして違法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that newname is already linked to the file represented by the saved filehandle, the server will return NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NEWNAMEがすでに保存されたファイルハンドルによって表されるファイルにリンクされている場合には、サーバがNFS4ERR_EXISTを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that symbolic links are created with the CREATE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンボリックリンクが作成操作で作成されていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MLINK NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MLINK NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.10. Operation 12: LOCK - Create Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.10。操作12：LOCK  - ロックを作成します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) locktype, reclaim, offset, length, locker -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）種類のLockType、再利用、オフセット、長さ、ロッカー - &gt;のstateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct open_to_lock_owner4 {
             seqid4          open_seqid;
             stateid4        open_stateid;
             seqid4          lock_seqid;
             lock_owner4     lock_owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct exist_lock_owner4 {
             stateid4        lock_stateid;
             seqid4          lock_seqid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union locker4 switch (bool new_lock_owner) {
      case TRUE:
             open_to_lock_owner4     open_owner;
      case FALSE:
             exist_lock_owner4       lock_owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
enum nfs_lock_type4 { READ_LT = 1, WRITE_LT = 2,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
列挙nfs_lock_type4 {READ_LT = 1、WRITE_LT = 2、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             READW_LT        = 3,    /* blocking read */
             WRITEW_LT       = 4     /* blocking write */
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCK4args {
             /* CURRENT_FH: file */
             nfs_lock_type4  locktype;
             bool            reclaim;
             offset4         offset;
             length4         length;
             locker4         locker;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCK4denied {
             offset4         offset;
             length4         length;
             nfs_lock_type4  locktype;
             lock_owner4     owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCK4resok {
             stateid4        lock_stateid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union LOCK4res switch (nfsstat4 status) {
      case NFS4_OK:
              LOCK4resok     resok4;
      case NFS4ERR_DENIED:
              LOCK4denied    denied;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCK operation requests a record lock for the byte range specified by the offset and length parameters. The lock type is also specified to be one of the nfs_lock_type4s. If this is a reclaim request, the reclaim parameter will be TRUE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK操作は、オフセットと長さのパラメータで指定されたバイト範囲のレコードロックを要求します。ロックタイプもnfs_lock_type4sの一つであることが指定されています。これは再利用要求がある場合は、再利用パラメータがTRUEになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bytes in a file may be locked even if those bytes are not currently allocated to the file. To lock the file from a specific offset through the end-of-file (no matter how long the file actually is) use a length field with all bits set to 1 (one). If the length is zero, or if a length which is not all bits set to one is specified, and length when added to the offset exceeds the maximum 64-bit unsigned integer value, the error NFS4ERR_INVAL will result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それらのバイトが現在のファイルに割り当てられていない場合でも、ファイル内のバイトをロックすることができます。ファイルの終わりを介して特定のオフセット（ファイルが実際にどのくらいの時間に関係なく）からファイルをロックするには1（1）に設定されたすべてのビットと長さフィールドを使用します。長さがゼロである、または全てのビットが1に設定されていない長さを指定し、オフセットに追加の長さが最大64ビットの符号なし整数値を超えている場合、エラーNFS4ERR_INVALが生じる。場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some servers may only support locking for byte offsets that fit within 32 bits. If the client specifies a range that includes a byte beyond the last byte offset of the 32-bit range, but does not include the last byte offset of the 32-bit and all of the byte offsets beyond it, up to the end of the valid 64-bit range, such a 32-bit server MUST return the error NFS4ERR_BAD_RANGE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバーのみ32ビットに収まるバイトオフセットのロックサポートすることができます。クライアントは、32ビットの範囲のオフセットが最後のバイトを超えたバイトを含む範囲を指定しますが、年末までに、それを超えたバイトオフセットのすべてを、最後の32ビットのバイトオフセットとが含まれていない場合有効な64ビットの範囲、例えば32ビットサーバーは、エラーNFS4ERR_BAD_RANGEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the lock is denied, the owner, offset, and length of a conflicting lock are returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックが拒否された場合に、競合するロックの所有者、オフセット、および長さが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. The File Locking section contains a full description of this and the other file locking operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは競合ロックの正確なオフセットと長さを決定することができない場合は、引数に与えたのと同じオフセットと長さが拒否された結果で返されるべきです。ファイルのロックセクションでは、このの完全な説明や操作をロックし、他のファイルが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK operations are subject to permission checks and to checks against the access type of the associated file. However, the specific right and modes required for various type of locks, reflect the semantics of the server-exported filesystem, and are not specified by the protocol. For example, Windows 2000 allows a write lock of a file open for READ, while a POSIX-compliant system does not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCK操作は、権限チェックにと関連付けられたファイルのアクセスタイプに対するチェックの対象となります。しかし、ロックの様々なタイプのために必要な具体的な権利とモードは、サーバー・エクスポートファイルシステムのセマンティクスを反映しており、プロトコルによって指定されていません。 POSIX準拠のシステムではそうではないたとえば、Windows 2000は、READのために開いているファイルの書き込みロックを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client makes a lock request that corresponds to a range that the lockowner has locked already (with the same or different lock type), or to a sub-region of such a range, or to a region which includes multiple locks already granted to that lockowner, in whole or in part, and the server does not support such locking operations (i.e., does not support POSIX locking semantics), the server will return the error NFS4ERR_LOCK_RANGE. In that case, the client may return an error, or it may emulate the required operations, using only LOCK for ranges that do not include any bytes already locked by that lock_owner and LOCKU of locks held by that lock_owner (specifying an exactly-matching range and type). Similarly, when the client makes a lock request that amounts to upgrading (changing from a read lock to a write lock) or downgrading (changing from write lock to a read lock) an existing record lock, and the server does not support such a lock, the server will return NFS4ERR_LOCK_NOTSUPP. Such operations may not perfectly reflect the required semantics in the face of conflicting lock requests from other clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはlockownerは、（同一または異なるロックタイプを有する）、又はこのような範囲のサブ領域に、またはすでにに付与された複数のロックを含む領域に既にロックされていること範囲に対応するロック要求を行うとそのlockownerが、全体的または部分的に、そしてサーバは、このようなロック操作をサポートしていません（つまり、POSIXロックのセマンティクスをサポートしていない）、サーバがエラーNFS4ERR_LOCK_RANGEを返します。その場合には、既にそのlock_ownerによって保持されているロックのlock_ownerとLOCKUによってロック任意のバイトを含まない範囲でのみロックを使用して、クライアントは、エラーを返すことがあり、またはそれは必要な操作をエミュレートすることができる（正確にマッチング範囲を指定そして、タイプ）。同様に、クライアントがアップグレードになるロック要求があった場合、（書き込みロックに読み取りロックから変更）、または既存のレコードロック（読み取りロックに書き込みロックから変更）ダウングレード、およびサーバは、そのようなロックをサポートしていません。 、サーバーはNFS4ERR_LOCK_NOTSUPPを返します。このような操作は完全に他のクライアントから競合ロック要求の顔に必要なセマンティクスを反映していないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The locker argument specifies the lock_owner that is associated with the LOCK request. The locker4 structure is a switched union that indicates whether the lock_owner is known to the server or if the lock_owner is new to the server. In the case that the lock_owner is known to the server and has an established lock_seqid, the argument is just the lock_owner and lock_seqid. In the case that the lock_owner is not known to the server, the argument contains not only the lock_owner and lock_seqid but also the open_stateid and open_seqid. The new lock_owner case covers the very first lock done by the lock_owner and offers a method to use the established state of the open_stateid to transition to the use of the lock_owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロッカー引数はLOCK要求に関連付けられているlock_ownerを指定します。 locker4構造はlock_ownerがサーバまたはlock_ownerがサーバーに新しいものである場合には知られているかどうかを示し切り替え組合です。 lock_ownerがサーバに知られており、確立lock_seqidを持っている場合には、引数がちょうどlock_ownerとlock_seqidです。 lock_ownerがサーバーに知られていない場合には、引数がlock_ownerとlock_seqidもopen_stateidとopen_seqidないだけが含まれています。新しいlock_ownerケースがlock_ownerによって行わ非常に最初のロックをカバーし、lock_ownerの使用に移行するopen_stateidの確立状態を使用するための方法を提供しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DEADLOCK NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_NOTSUPP NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NO_GRACE NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RECLAIM_BAD NFS4ERR_RECLAIM_CONFLICT NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DEADLOCK NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_NOTSUPP NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NO_GRACE NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RECLAIM_BAD NFS4ERR_RECLAIM_CONFLICT NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.11. Operation 13: LOCKT - Test For Lock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.11。操作13：ルアー - ロックのテスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) locktype, offset, length owner -&gt; {void, NFS4ERR_DENIED -&gt; owner}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）種類のLockType、オフセット、長さの所有者 - &gt; {ボイド、NFS4ERR_DENIED  - &gt;所有者}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCKT4args {
             /* CURRENT_FH: file */
             nfs_lock_type4  locktype;
             offset4         offset;
             length4         length;
             lock_owner4     owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCK4denied {
             offset4         offset;
             length4         length;
             nfs_lock_type4  locktype;
             lock_owner4     owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union LOCKT4res switch (nfsstat4 status) {
      case NFS4ERR_DENIED:
              LOCK4denied    denied;
      case NFS4_OK:
              void;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCKT operation tests the lock as specified in the arguments. If a conflicting lock exists, the owner, offset, length, and type of the conflicting lock are returned; if no lock is held, nothing other than NFS4_OK is returned. Lock types READ_LT and READW_LT are processed in the same way in that a conflicting lock test is done without regard to blocking or non-blocking. The same is true for WRITE_LT and WRITEW_LT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKT操作は、引数で指定されたロックをテストします。競合するロックが存在する場合、所有者は、競合するロックのオフセット、長さ、およびタイプが戻されます。何もロックが保持されていない場合、NFS4_OK以外何も返されません。ロックタイプREAD_LTとREADW_LTがその矛盾するロックテストで同じように処理されているが、ブロッキングまたは非ブロッキングとは関係なく行われます。同じことがWRITE_LTとWRITEW_LTについても同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲はLOCK用として指定されています。 NFS4ERR_INVALとNFS4ERR_BAD_RANGEエラーがLOCKと同じ状況下で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results. The File Locking section contains further discussion of the file locking mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは競合ロックの正確なオフセットと長さを決定することができない場合は、引数に与えたのと同じオフセットと長さが拒否された結果で返されるべきです。ファイルのロックセクションでは、ファイルロック機構のさらなる議論が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKT uses a lock_owner4 rather a stateid4, as is used in LOCK to identify the owner. This is because the client does not have to open the file to test for the existence of a lock, so a stateid may not be available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKTは、所有者を識別するためにLOCKに使用されるように、むしろstateid4をlock_owner4を使用します。クライアントはロックが存在するかどうかをテストするためにファイルを開く必要がないので、のstateidは使用できない可能性があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The test for conflicting locks should exclude locks for the current lockowner. Note that since such locks are not examined the possible existence of overlapping ranges may not affect the results of LOCKT. If the server does examine locks that match the lockowner for the purpose of range checking, NFS4ERR_LOCK_RANGE may be returned.. In the event that it returns NFS4_OK, clients may do a LOCK and receive NFS4ERR_LOCK_RANGE on the LOCK request because of the flexibility provided to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
競合するロックのためのテストは、現在のlockownerのためのロックを除外する必要があります。このようなロックが検討されていないので、重複範囲の可能な存在はLOCKTの結果に影響を与えないかもしれないことに留意されたいです。サーバはそれがNFS4_OKを返したときに.. NFS4ERR_LOCK_RANGEが返されることがあります範囲チェックの目的のためにlockownerに一致するロックを調べていた場合、クライアントはLOCKを行うとしているため、柔軟性のLOCK要求にNFS4ERR_LOCK_RANGEを受け取ることができますサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.12. Operation 14: LOCKU - Unlock File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.12。操作14：LOCKU  - ファイルのロックを解除
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) type, seqid, stateid, offset, length -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）タイプ、SEQID、のstateid、オフセット、長さ - &gt;のstateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOCKU4args {
             /* CURRENT_FH: file */
             nfs_lock_type4  locktype;
             seqid4          seqid;
             stateid4        stateid;
             offset4         offset;
             length4         length;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union LOCKU4res switch (nfsstat4 status) {
      case   NFS4_OK:
              stateid4       stateid;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LOCKU operation unlocks the record lock specified by the parameters. The client may set the locktype field to any value that is legal for the nfs_lock_type4 enumerated type, and the server MUST accept any legal value for locktype. Any legal value for locktype has no effect on the success or failure of the LOCKU operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOCKU操作は、パラメータで指定されたレコードのロックを解除します。クライアントはnfs_lock_type4列挙型のために合法的である任意の値にLockTypeのフィールドを設定すること、およびサーバーがのLockTypeのための法的な価値を受け入れなければなりません。 LockTypeのための任意の有効な値はLOCKU操作の成功または失敗には影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲はLOCK用として指定されています。 NFS4ERR_INVALとNFS4ERR_BAD_RANGEエラーがLOCKと同じ状況下で返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the area to be unlocked does not correspond exactly to a lock actually held by the lockowner the server may return the error NFS4ERR_LOCK_RANGE. This includes the case in which the area is not locked, where the area is a sub-range of the area locked, where it overlaps the area locked without matching exactly or the area specified includes multiple locks held by the lockowner. In all of these cases, allowed by POSIX locking semantics, a client receiving this error, should if it desires support for such operations, simulate the operation using LOCKU on ranges corresponding to locks it actually holds, possibly followed by LOCK requests for the sub-ranges not being unlocked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロックを解除するための領域が実際にlockownerで開催されたロックに正確に対応していない場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返すことがあります。これは、領域は、それが正確に一致せずにロックされた領域と重なる、または指定された領域がlockownerによって保持された複数のロックを含むロックされた領域のサブ領域である領域がロックされていない場合を含みます。それは、このような操作のサポートを希望する場合は、これらの例すべてでは、POSIXロックのセマンティクスによって許可され、このエラーを受信するクライアントは、それをロックするために対応する範囲にLOCKUを使用して動作をシミュレートする必要があり、実際に、おそらくサブ用LOCK要求に続いて、保持していますアンロックされていない範囲です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_RANGE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCK_RANGE NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.13. Operation 15: LOOKUP - Lookup Filename
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.13。操作15：LOOKUP  - 検索ファイル名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), component -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、成分 - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOOKUP4args {
             /* CURRENT_FH: directory */
             component4      objname;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOOKUP4res {
             /* CURRENT_FH: object */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation LOOKUPs or finds a filesystem object using the directory specified by the current filehandle. LOOKUP evaluates the component and if the object exists the current filehandle is replaced with the component&#39;s filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作ルックアップまたは現在のファイルハンドルで指定されたディレクトリを使用して、ファイルシステムオブジェクトを見つけ。 LOOKUPは、コンポーネントを評価したオブジェクトが存在する場合、現在のファイルハンドルは、コンポーネントのファイルハンドルに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component cannot be evaluated either because it does not exist or because the client does not have permission to evaluate the component, then an error will be returned and the current filehandle will be unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントは評価できない場合、クライアントはコンポーネントを評価する権限を持っていないので、それが存在したりしないのでどちらか、エラーが返され、現在のファイルハンドルは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component is a zero length string or if any component does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
部品は長さゼロの文字列である場合、またはいずれかのコンポーネントがUTF-8定義に従わない場合は、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to achieve the effect of a multi-component lookup, it may construct a COMPOUND request such as (and obtain each filehandle):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、多成分のルックアップの効果を実現したい場合、それは、次のような複合要求を構築（および各ファイルハンドルを得る）ことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH (directory filehandle) LOOKUP &#34;pub&#34; GETFH LOOKUP &#34;foo&#34; GETFH LOOKUP &#34;bar&#34; GETFH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH（ディレクトリファイルハンドル）LOOKUP &#34;パブ&#34; GETFH LOOKUP &#34;foo&#34; というGETFH LOOKUP &#34;バー&#34; GETFH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS version 4 servers depart from the semantics of previous NFS versions in allowing LOOKUP requests to cross mountpoints on the server. The client can detect a mountpoint crossing by comparing the fsid attribute of the directory with the fsid attribute of the directory looked up. If the fsids are different then the new directory is a server mountpoint. UNIX clients that detect a mountpoint crossing will need to mount the server&#39;s filesystem. This needs to be done to maintain the file object identity checking mechanisms common to UNIX clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4台のサーバは、LOOKUP要求がサーバー上でマウントポイントを横断できるようにするには、以前のNFSバージョンの意味論から出発します。ディレクトリのFSID属性を持つディレクトリのFSID属性を比較することにより、マウントポイントの交差を検出することができ、クライアントは見上げました。 fsidsが異なる場合は、新しいディレクトリがサーバマウントポイントです。マウントポイントの交差点を検出するUNIXクライアントは、サーバのファイルシステムをマウントする必要があります。これは、UNIXクライアントに共通のメカニズムをチェックするファイルオブジェクトのアイデンティティを維持するために行われる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers that limit NFS access to &#34;shares&#34; or &#34;exported&#34; filesystems should provide a pseudo-filesystem into which the exported filesystems can be integrated, so that clients can browse the server&#39;s name space. The clients&#39; view of a pseudo filesystem will be limited to paths that lead to exported filesystems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーの名前空間を参照することができるように、「株式」または「エクスポート」ファイルシステムへのNFSアクセスを制限するサーバーは、エクスポートされたファイルシステムを統合することができますその中に擬似ファイルシステムを提供する必要があります。疑似ファイルシステムのクライアントのビューは、エクスポートファイルシステムにつながるパスに制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: previous versions of the protocol assigned special semantics to the names &#34;.&#34; and &#34;..&#34;. NFS version 4 assigns no special semantics to these names. The LOOKUPP operator must be used to lookup a parent directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：名前に特別な意味を割り当てるプロトコルの以前のバージョン「」そして、 &#34;..&#34;。 NFSバージョン4は、これらの名前に特別な意味を割り当てません。 LOOKUPP演算子は、親ディレクトリを検索するために使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this operation does not follow symbolic links. The client is responsible for all parsing of filenames including filenames that are modified by symbolic links encountered during the lookup process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作はシンボリックリンクをたどらないことに注意してください。クライアントは、ルックアップ・プロセス中に遭遇したシンボリックリンクで変更されたファイル名を含むファイル名のすべての解析を担当しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle supplied is not a directory but a symbolic link, the error NFS4ERR_SYMLINK is returned as the error. For all other non-directory file types, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
供給される電流のファイルハンドルがディレクトリが、シンボリックリンクではない場合は、エラーNFS4ERR_SYMLINKはエラーとして返されます。他のすべてのディレクトリ以外のファイルタイプの場合は、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_SYMLINK NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_SYMLINK NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.14. Operation 16: LOOKUPP - Lookup Parent Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.14。操作16：LOOKUPP  - 検索親ディレクトリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH） - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: object */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct LOOKUPP4res {
             /* CURRENT_FH: directory */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current filehandle is assumed to refer to a regular directory or a named attribute directory. LOOKUPP assigns the filehandle for its parent directory to be the current filehandle. If there is no parent directory an NFS4ERR_NOENT error must be returned. Therefore, NFS4ERR_NOENT will be returned by the server when the current filehandle is at the root or top of the server&#39;s file tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルは通常のディレクトリや名前付き属性のディレクトリを参照すると想定されます。 LOOKUPPは、現在のファイルハンドルであることを、その親ディレクトリのファイルハンドルを割り当てます。親ディレクトリが存在しない場合NFS4ERR_NOENTエラーが返されなければなりません。現在のファイルハンドルは、ルートまたはサーバーのファイルツリーの最上部にあるときにそのため、NFS4ERR_NOENTは、サーバーによって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As for LOOKUP, LOOKUPP will also cross mountpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOOKUPについては、LOOKUPもマウントポイントを横切ることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not a directory or named attribute directory, the error NFS4ERR_NOTDIR is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルがディレクトリまたは名前付き属性ディレクトリでない場合は、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.15. Operation 17: NVERIFY - Verify Difference in Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.15。操作17：NVERIFY  - 属性の違いを確認してください
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), fattr -&gt; -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、fattr  - &gt;  - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct NVERIFY4args {
             /* CURRENT_FH: object */
             fattr4          obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct NVERIFY4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to prefix a sequence of operations to be performed if one or more attributes have changed on some filesystem object. If all the attributes match then the error NFS4ERR_SAME must be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、1つ以上の属性は、いくつかのファイルシステムオブジェクトに変更した場合に実行する一連の操作の前に付けるために使用されます。すべての属性が一致した場合、エラーNFS4ERR_SAMEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is useful as a cache validation operator. If the object to which the attributes belong has changed then the following operations may obtain new data associated with that object. For instance, to check if a file has been changed and obtain new data if it has:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、キャッシュ検証オペレーターとして有用です。属性が所属するオブジェクトが変更された場合は、以下の操作は、そのオブジェクトに関連付けられた新しいデータを得ることができます。たとえば、ファイルが変更されているかどうかを確認し、それが持っている場合、新たなデータを取得します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH (public) LOOKUP &#34;foobar&#34; NVERIFY attrbits attrs READ 0 32767
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PUTFH（パブリック）LOOKUP &#34;foobarの&#34; NVERIFY attrbits attrsには0 32767をREAD
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a recommended attribute is specified in the NVERIFY operation and the server does not support that attribute for the filesystem object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨属性がNVERIFY操作で指定され、サーバがファイルシステムオブジェクトのその属性をサポートしていない場合は、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the attribute rdattr_error or any write-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性rdattr_errorまたは任意の書き込み専用の属性（例えば、time_modify_set）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SAME NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SAME NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.16. Operation 18: OPEN - Open a Regular File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.16。操作18：OPEN  - は、通常のファイルを開きます。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), seqid, share_access, share_deny, owner, openhow, claim -&gt; (cfh), stateid, cinfo, rflags, open_confirm, attrset delegation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、SEQID、share_access、share_deny、所有者、openhow、請求 - &gt;（CFH）のstateid、CINFO、RFLAGS、オープン_CONFIRM、attrset委任
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN4args {
             seqid4          seqid;
             uint32_t        share_access;
             uint32_t        share_deny;
             open_owner4     owner;
             openflag4       openhow;
             open_claim4     claim;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
enum createmode4 { UNCHECKED4 = 0, GUARDED4 = 1, EXCLUSIVE4 = 2 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
列挙createmode4 {UNCHECKED4 = 0、GUARDED4 = 1、EXCLUSIVE4 = 2}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union createhow4 switch (createmode4 mode) {
      case UNCHECKED4:
      case GUARDED4:
              fattr4         createattrs;
      case EXCLUSIVE4:
              verifier4      createverf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
enum opentype4 { OPEN4_NOCREATE = 0, OPEN4_CREATE = 1 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
列挙opentype4 {OPEN4_NOCREATE = 0、OPEN4_CREATE = 1}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union openflag4 switch (opentype4 opentype) {
      case OPEN4_CREATE:
              createhow4     how;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* Next definitions used for OPEN delegation */
     enum limit_by4 {
             NFS_LIMIT_SIZE          = 1,
             NFS_LIMIT_BLOCKS        = 2
             /* others as needed */
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct nfs_modified_limit4 {
             uint32_t        num_blocks;
             uint32_t        bytes_per_block;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_space_limit4 switch (limit_by4 limitby) {
      /* limit specified as file size */
      case NFS_LIMIT_SIZE:
              uint64_t               filesize;
      /* limit specified by number of blocks */
      case NFS_LIMIT_BLOCKS:
              nfs_modified_limit4    mod_blocks;
     } ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
enum open_delegation_type4 { OPEN_DELEGATE_NONE = 0, OPEN_DELEGATE_READ = 1, OPEN_DELEGATE_WRITE = 2 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
列挙open_delegation_type4 {OPEN_DELEGATE_NONE = 0、OPEN_DELEGATE_READ = 1、OPEN_DELEGATE_WRITE = 2}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum open_claim_type4 {
             CLAIM_NULL              = 0,
             CLAIM_PREVIOUS          = 1,
             CLAIM_DELEGATE_CUR      = 2,
             CLAIM_DELEGATE_PREV     = 3
     }; struct open_claim_delegate_cur4 {
             stateid4        delegate_stateid;
             component4      file;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union open_claim4 switch (open_claim_type4 claim) {
      /*
       * No special rights to file. Ordinary OPEN of the specified file.
       */
      case CLAIM_NULL:
              /* CURRENT_FH: directory */
              component4     file;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /*
       * Right to the file established by an open previous to server
       * reboot.  File identified by filehandle obtained at that time
       * rather than by name.
       */
      case CLAIM_PREVIOUS:
              /* CURRENT_FH: file being reclaimed */
              open_delegation_type4   delegate_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /*
       * Right to file based on a delegation granted by the server.
       * File is specified by name.
       */
      case CLAIM_DELEGATE_CUR:
              /* CURRENT_FH: directory */
              open_claim_delegate_cur4       delegate_cur_info;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* Right to file based on a delegation granted to a previous boot
       * instance of the client.  File is specified by name.
       */
      case CLAIM_DELEGATE_PREV:
              /* CURRENT_FH: directory */
              component4     file_delegate_prev;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_read_delegation4 {
           stateid4        stateid;        /* Stateid for delegation*/
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfsace4         permissions;    /* Defines users who don&#39;t
                                              need an ACCESS call to open for read */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_write_delegation4 {
           stateid4        stateid;        /* Stateid for delegation*/
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfs_space_limit4 space_limit;   /* Defines condition that
                                              the client must check to
                                              determine whether the
                                              file needs to be flushed
                                              to the server on close.
                                              */
           nfsace4         permissions;    /* Defines users who don&#39;t
                                              need an ACCESS call as
                                              part of a delegated
                                              open. */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_delegation4
   switch (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN4resok {
           stateid4        stateid;        /* Stateid for open */
           change_info4    cinfo;          /* Directory Change Info */
           uint32_t        rflags;         /* Result flags */
           bitmap4         attrset;        /* attributes on create */
           open_delegation4 delegation;    /* Info on any open
                                              delegation */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* CURRENT_FH: opened file */
           OPEN4resok      resok4;
    default:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WARNING TO CLIENT IMPLEMENTORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント実装者へ警告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN resembles LOOKUP in that it generates a filehandle for the client to use. Unlike LOOKUP though, OPEN creates server state on the filehandle. In normal circumstances, the client can only release this state with a CLOSE operation. CLOSE uses the current filehandle to determine which file to close. Therefore the client MUST follow every OPEN operation with a GETFH operation in the same COMPOUND procedure. This will supply the client with the filehandle such that CLOSE can be used appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN似ているが、それは、クライアントが使用するファイルハンドルを生成するルックアップ。しかしLOOKUPとは異なり、OPENはファイルハンドルの上にサーバの状態を作成します。通常の状況では、クライアントはCLOSE操作で、この状態を解除することができます。 CLOSEは閉鎖するファイルを決定するために、現在のファイルハンドルを使用しています。そのため、クライアントは同じCOMPOUND手順でGETFH操作ですべてのOPEN操作に従わなければなりません。これは、CLOSEを適切に使用することができるように、ファイルハンドルをクライアントに提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Simply waiting for the lease on the file to expire is insufficient because the server may maintain the state indefinitely as long as another client does not attempt to make a conflicting access to the same file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが無期限に限り、別のクライアントが同じファイルへの競合アクセスを作るしようとしないような状態を維持することができるので、単純に期限切れにするファイルのリースを待っていることは不十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation creates and/or opens a regular file in a directory with the provided name. If the file does not exist at the server and creation is desired, specification of the method of creation is provided by the openhow parameter. The client has the choice of three creation methods: UNCHECKED, GUARDED, or EXCLUSIVE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作が作成および/または提供された名前のディレクトリにある通常のファイルを開きます。ファイルがサーバーに存在しないと作成を希望する場合、作成方法の指定は、openhowパラメータによって提供されます。 UNCHECKED、GUARDED、またはEXCLUSIVE：クライアントが3つの作成方法の選択肢を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is a named attribute directory, OPEN will then create or open a named attribute file. Note that exclusive create of a named attribute is not supported. If the createmode is EXCLUSIVE4 and the current filehandle is a named attribute directory, the server will return EINVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが指定された属性ディレクトリである場合、OPENは、名前の属性ファイルを作成または開きます。排他的にサポートされていないという属性を作成することに注意してください。 createmodeがEXCLUSIVE4であり、現在のファイルハンドルが指定された属性ディレクトリである場合、サーバはEINVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNCHECKED means that the file should be created if a file of that name does not exist and encountering an existing regular file of that name is not an error. For this type of create, createattrs specifies the initial set of attributes for the file. The set of attributes may include any writable attribute valid for regular files. When an UNCHECKED create encounters an existing file, the attributes specified by createattrs are not used, except that when an size of zero is specified, the existing file is truncated. If GUARDED is specified, the server checks for the presence of a duplicate object by name before performing the create. If a duplicate exists, an error of NFS4ERR_EXIST is returned as the status. If the object does not exist, the request is performed as described for UNCHECKED. For each of these cases (UNCHECKED and GUARDED) where the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNCHECKEDは、その名前のファイルが存在しないと、その名前の既存の通常のファイルに遭遇してもエラーではありませんない場合、ファイルが作成されなければならないことを意味しています。作成のこのタイプのため、createattrsは、ファイルの属性の初期セットを指定します。属性のセットは、通常のファイルに有効な任意の書き込み可能な属性を含むことができます。 UNCHECKEDは、既存のファイルの出会いを作成すると、createattrsによって指定された属性は、ゼロのサイズが指定されている場合、既存のファイルが切り捨てられることを除いて、使用されていません。 GUARDEDを作成実行する前に、名前の重複したオブジェクトが存在するサーバーのチェックを指定された場合。重複が存在する場合は、NFS4ERR_EXISTの誤差がステータスとして返されます。オブジェクトが存在しない場合は、オフのために記載したように、要求が行われます。このような場合、操作が成功した（UNCHECKEDとGUARDED）のそれぞれについて、サーバがクライアントに正常にオブジェクトに設定された属性の属性マスクの意味を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVE specifies that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. The server should check for the presence of a duplicate object by name. If the object does not exist, the server creates the object and stores the verifier with the object. If the object does exist and the stored verifier matches the client provided verifier, the server uses the existing object as the newly created object. If the stored verifier does not match, then an error of NFS4ERR_EXIST is returned. No attributes may be provided in this case, since the server may use an attribute of the target object to store the verifier. If the server uses an attribute to store the exclusive create verifier, it will signify which attribute by setting the appropriate bit in the attribute mask that is returned in the results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXCLUSIVEは、サーバがターゲットの排他的な作成を確保するために検証を使用して、排他的な作成のセマンティクスに従うことであることを指定します。サーバーは名前で重複したオブジェクトが存在するかどうかをチェックする必要があります。オブジェクトが存在しない場合は、サーバーはオブジェクトを作成し、オブジェクトに検証を保存します。オブジェクトが存在しないと保存された検証がクライアントに提供ベリファイアと一致した場合、サーバーは、新しく作成されたオブジェクトとして既存のオブジェクトを使用しています。保存された検証が一致しない場合は、NFS4ERR_EXISTのエラーが返されます。サーバーが検証を保存するために、ターゲットオブジェクトの属性を使用することができるので、何の属性が、この場合に設けなくてもよいです。サーバが排他作成、検証を格納する属性を使用している場合、それが結果に返された属性マスクの適切なビットを設定することにより、どの属性を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリの場合、サーバはcinfoの変化_info4情報を返します。前と後の変更属性がリンク作成に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon successful creation, the current filehandle is replaced by that of the new object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作成に成功すると、現在のファイルハンドルは、新しいオブジェクトのものに置き換えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation provides for Windows share reservation capability with the use of the share_access and share_deny fields of the OPEN arguments. The client specifies at OPEN the required share_access and share_deny modes. For clients that do not directly support SHAREs (i.e., UNIX), the expected deny value is DENY_NONE. In the case that there is a existing SHARE reservation that conflicts with the OPEN request, the server returns the error NFS4ERR_SHARE_DENIED. For a complete SHARE request, the client must provide values for the owner and seqid fields for the OPEN argument. For additional discussion of SHARE semantics see the section on &#39;Share Reservations&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作がOPEN引数のshare_accessとshare_denyフィールドを使用して、Windowsのシェア予約機能を提供します。クライアントは、OPENで必要share_accessとshare_denyモードを指定します。直接株（すなわち、UNIX）をサポートしていないクライアントの場合、期待値はDENY_NONEで否定しています。 OPEN要求と競合する既存のSHAREの予約がある場合には、サーバがエラーNFS4ERR_SHARE_DENIEDを返します。完全SHARE要求の場合、クライアントがOPEN引数の所有者およびSEQIDフィールドの値を指定する必要があります。 SHARE意味論の追加の議論については「共有予約」に関するセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that the client is recovering state from a server failure, the claim field of the OPEN argument is used to signify that the request is meant to reclaim state previously held.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバー障害から状態を回復している場合には、OPEN引数の請求フィールドには、要求が以前に開催された状態を取り戻すことを意図していることを意味するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;claim&#34; field of the OPEN argument is used to specify the file to be opened and the state information which the client claims to possess. There are four basic claim types which cover the various situations for an OPEN. They are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN引数の「主張」フィールドがオープンするファイルとクライアントが持っていると主張する状態情報を指定するために使用されます。 OPENのための様々な状況をカバーする四つの基本的な要求の種類があります。それらは次の通りです：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_NULL For the client, this is a new OPEN request and there is no previous state associate with the file for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの場合CLAIM_NULLが、これは新しいOPENのリクエストで、クライアント用のファイルとは以前の状態に関連付けはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_PREVIOUS The client is claiming basic OPEN state for a file that was held previous to a server reboot. Generally used when a server is returning persistent filehandles; the client may not have the file name to reclaim the OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_PREVIOUSは、クライアントはサーバーの再起動に以前開催されたファイルのための基本的なOPEN状態を主張しています。一般的に、サーバーが永続的なファイルハンドルを返すときに使用されます。クライアントは、OPENを取り戻すために、ファイル名を持っていないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_CUR The client is claiming a delegation for OPEN as granted by the server. Generally this is done as part of recalling a delegation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバによって付与されたようCLAIM_DELEGATE_CURは、クライアントがOPENのための委任を主張しています。一般に、これは代表団をリコールの一部として行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_PREV The client is claiming a delegation granted to a previous client instance; used after the client reboots. The server MAY support CLAIM_DELEGATE_PREV. If it does support CLAIM_DELEGATE_PREV, SETCLIENTID_CONFIRM MUST NOT remove the client&#39;s delegation state, and the server MUST support the DELEGPURGE operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CLAIM_DELEGATE_PREVは、クライアントは、以前のクライアントインスタンスに付与された委任を主張しています。クライアントの再起動後に使用。サーバーはCLAIM_DELEGATE_PREVをサポートするかもしれません。それはCLAIM_DELEGATE_PREVをサポートしている場合、SETCLIENTID_CONFIRMはクライアントの委任状態を削除してはならない、とサーバがDELEGPURGE操作をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For OPEN requests whose claim type is other than CLAIM_PREVIOUS (i.e., requests other than those devoted to reclaiming opens after a server reboot) that reach the server during its grace or lease expiration period, the server returns an error of NFS4ERR_GRACE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その猶予又はリース満了期間中にサーバに到達し、そのクレームタイプCLAIM_PREVIOUS以外のオープン要求（すなわち、再利用に専念以外の要求サーバーの再起動後に開く）ために、サーバはNFS4ERR_GRACEのエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any OPEN request, the server may return an open delegation, which allows further opens and closes to be handled locally on the client as described in the section Open Delegation. Note that delegation is up to the server to decide. The client should never assume that delegation will or will not be granted in a particular instance. It should always be prepared for either case. A partial exception is the reclaim (CLAIM_PREVIOUS) case, in which a delegation type is claimed. In this case, delegation will always be granted, although the server may specify an immediate recall in the delegation structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意のOPEN要求の場合、サーバーはさらに可能に開き、セクションオープン委任で説明したように、クライアント上でローカルに処理されるように閉じ、開いている委譲を返すことがあります。代表団が決定するサーバー次第であることに注意してください。クライアントは、代表団は、または特定のインスタンスで付与されないだろうと想定してはいけません。それは、常にどちらかの場合のために準備する必要があります。部分的な例外は、委譲タイプが記載されて再利用（CLAIM_PREVIOUS）場合、です。サーバが委任構造で即時リコールを指定することもできますが、この場合には、代表団は常に、付与されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rflags returned by a successful OPEN allow the server to return information governing how the open file is to be handled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功OPENによって返さRFLAGSは、サーバが開いているファイルを処理する方法を規定する情報を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_RESULT_CONFIRM indicates that the client MUST execute an OPEN_CONFIRM operation before using the open file. OPEN4_RESULT_LOCKTYPE_POSIX indicates the server&#39;s file locking behavior supports the complete set of Posix locking techniques. From this the client can choose to manage file locking state in a way to handle a mis-match of file locking management.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN4_RESULT_CONFIRMは、クライアントが開いているファイルを使用する前に、オープン_CONFIRM操作を実行しなければならないことを示しています。 OPEN4_RESULT_LOCKTYPE_POSIXは、サーバのファイルロック動作はPOSIXのロック技術の完全なセットをサポートして示しています。このことから、クライアントは、ファイルロック管理の不整合を処理するための方法でファイルのロック状態を管理するために選択することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component is of zero length, NFS4ERR_INVAL will be returned. The component is also subject to the normal UTF-8, character support, and name checks. See the section &#34;UTF-8 Related Errors&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンポーネントは、長さゼロである場合、NFS4ERR_INVALが返されます。コンポーネントは、通常のUTF-8文字のサポート、および名前のチェックの対象となります。さらなる議論については、「UTF-8関連のエラー」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an OPEN is done and the specified lockowner already has the resulting filehandle open, the result is to &#34;OR&#34; together the new share and deny status together with the existing status. In this case, only a single CLOSE need be done, even though multiple OPENs were completed. When such an OPEN is done, checking of share reservations for the new OPEN proceeds normally, with no exception for the existing OPEN held by the same lockowner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENが行われ、指定されたlockownerが既に開いたファイルハンドルを持っている場合は、その結果が「OR」一緒に新しい共有され、既存のステータスと一緒に状況を否定します。この場合、単一のCLOSEは、複数のOPENsが完了したにもかかわらず、行われる必要があります。そのようなOPENが行われると、同じlockownerが保有する既存のOPENのための例外なく、通常は新しいOPEN収益の共有予約の確認。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the underlying filesystem at the server is only accessible in a read-only mode and the OPEN request has specified ACCESS_WRITE or ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-only filesystem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの基本となるファイルシステムが読み取り専用モードでのみアクセス可能で、OPEN要求がACCESS_WRITEまたはACCESS_BOTHを指定した場合、サーバーは、読み取り専用ファイルシステムを示すためにNFS4ERR_ROFSを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with the CREATE operation, the server MUST derive the owner, owner ACE, group, or group ACE if any of the four attributes are required and supported by the server&#39;s filesystem. For an OPEN with the EXCLUSIVE4 createmode, the server has no choice, since such OPEN calls do not include the createattrs field. Conversely, if createattrs is specified, and includes owner or group (or corresponding ACEs) that the principal in the RPC call&#39;s credentials does not have authorization to create files for, then the server may return NFS4ERR_PERM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4つの属性のいずれかが必要とサーバのファイルシステムによってサポートされている場合は、CREATE操作と同じように、サーバは、所有者、所有者のACE、グループ、またはグループのACEを導出しなければなりません。 EXCLUSIVE4のcreatemodeとOPENの場合、サーバーは、OPEN呼び出しがcreateattrsフィールドが含まれないので、選択の余地はありません。逆に、場合createattrsは、サーバはNFS4ERR_PERMを返すことがあり、RPCコールの資格でプリンシパルがためのファイルを作成する権限を持っていないことを指定し、所有者またはグループ（またはACEを相当）を備えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of a OPEN which specifies a size of zero (e.g., truncation) and the file has named attributes, the named attributes are left as is. They are not removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゼロ（例えば、切り捨て）のサイズを指定し、ファイル属性と名付けたOPENの場合には、名前付き属性はそのまま残されます。彼らは削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPEN operation contains support for EXCLUSIVE create. The mechanism is similar to the support in NFS version 3 [RFC1813]. As in NFS version 3, this mechanism provides reliable exclusive creation. Exclusive create is invoked when the how parameter is EXCLUSIVE. In this case, the client provides a verifier that can reasonably be expected to be unique. A combination of a client identifier, perhaps the client network address, and a unique number generated by the client, perhaps the RPC transaction identifier, may be appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPEN操作はEXCLUSIVEを作成するためのサポートが含まれています。機構は、NFSバージョン3 [RFC1813]でサポートと同様です。 NFSバージョン3のように、このメカニズムは、信頼できる排他的な創造を提供します。独占は、どのようにパラメータがEXCLUSIVEときに呼び出されます作成します。この場合、クライアントは、合理的に一意であることが期待できる検証を提供します。クライアント識別子の組み合わせ、恐らくクライアントネットワークアドレス、およびクライアントによって生成された固有の番号、恐らくRPCトランザクション識別子は、適切であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the object does not exist, the server creates the object and stores the verifier in stable storage. For filesystems that do not provide a mechanism for the storage of arbitrary file attributes, the server may use one or more elements of the object meta-data to store the verifier. The verifier must be stored in stable storage to prevent erroneous failure on retransmission of the request. It is assumed that an exclusive create is being performed because exclusive semantics are critical to the application. Because of the expected usage, exclusive CREATE does not rely solely on the normally volatile duplicate request cache for storage of the verifier. The duplicate request cache in volatile storage does not survive a crash and may actually flush on a long network partition, opening failure windows. In the UNIX local filesystem environment, the expected storage location for the verifier on creation is the meta-data (time stamps) of the object. For this reason, an exclusive object create may not include initial attributes because the server would have nowhere to store the verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトが存在しない場合は、サーバーはオブジェクトを作成し、安定したストレージに検証を保存します。任意のファイル属性を格納するためのメカニズムを提供していないファイルシステムのために、サーバは、検証を格納するオブジェクトのメタデータの1つの以上の要素を使用することができます。検証者は、要求の再送に誤った故障を防ぐために、安定したストレージに格納されなければなりません。排他的な意味はアプリケーションに不可欠であるため、排他が行われて作成することを想定しています。そのため、予想される使用法の、排他的な検証の記憶のため、通常は揮発性の重複要求キャッシュのみに依存しませんCREATE。揮発性記憶装置内の重複要求キャッシュは、クラッシュを存続しないと、実際に障害の窓を開け、長いネットワークパーティションにフラッシュすることがあります。 UNIXローカルファイルシステム環境では、作成時に検証者の期待記憶場所は、オブジェクトのメタデータ（タイムスタンプ）です。このため、排他的なオブジェクトは、サーバには、検証を保存する場所がないでしょう、したがって、初期の属性を含まないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server can not support these exclusive create semantics, possibly because of the requirement to commit the verifier to stable storage, it should fail the OPEN request with the error, NFS4ERR_NOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、これらの排他的で安定したストレージに検証をコミットする可能性があるための要件の、セマンティクスを作成サポートできない場合は、エラー、NFS4ERR_NOTSUPPとOPEN要求を失敗するはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During an exclusive CREATE request, if the object already exists, the server reconstructs the object&#39;s verifier and compares it with the verifier in the request. If they match, the server treats the request as a success. The request is presumed to be a duplicate of an earlier, successful request for which the reply was lost and that the server duplicate request cache mechanism did not detect. If the verifiers do not match, the request is rejected with the status, NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトがすでに存在する場合、排他的、CREATE要求の間に、サーバーは、オブジェクトの検証を再構築し、要求で検証とそれを比較します。それらが一致した場合、サーバは成功として要求を処理します。要求は応答が失われたとサーバーの重複要求キャッシュメカニズムが検出されなかったことをそのため、以前、成功した要求の重複であると推定されます。検証が一致しない場合、要求はステータス、NFS4ERR_EXISTで拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the client has performed a successful exclusive create, it must issue a SETATTR to set the correct object attributes. Until it does so, it should not rely upon any of the object attributes, since the server implementation may need to overload object meta-data to store the verifier. The subsequent SETATTR must not occur in the same COMPOUND request as the OPEN. This separation will guarantee that the exclusive create mechanism will continue to function properly in the face of retransmission of the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが作成した排他的な成功を行った後、それが正しいオブジェクトの属性を設定するSETATTRを発行する必要があります。それはそうするまで、サーバの実装は、検証を保存するために、オブジェクトのメタデータをオーバーロードする必要があるかもしれないので、それは、オブジェクトの属性のいずれかに頼るべきではありません。その後のSETATTRはOPENと同じCOMPOUND要求で発生してはなりません。この分離は、排他的な作成メカニズムは、要求の再送信の顔に適切に機能し続けることを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of the GUARDED attribute does not provide exactly-once semantics. In particular, if a reply is lost and the server does not detect the retransmission of the request, the operation can fail with
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
守ら属性の使用は、正確にワンスセマンティクスを提供していません。回答が失われ、サーバが要求の再送信を検出しない場合は特に、操作がで失敗する可能性があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXIST, even though the create was performed successfully. The client would use this behavior in the case that the application has not requested an exclusive create but has asked to have the file truncated when the file is opened. In the case of the client timing out and retransmitting the create request, the client can use GUARDED to prevent against a sequence like: create, write, create (retransmitted) from occurring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_EXISTは、作成にもかかわらず、正常に実行されました。クライアントは、アプリケーションが排他的に作成要求していないが、ファイルを開いたときに切り捨てられたファイルを持っているように頼まれた場合には、この動作を使用します。発生から作成、書き込み、作成（再送）：クライアントのタイムアウトと作成要求を再送信する場合、クライアントは次のように配列に対する予防するために守ら使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For SHARE reservations, the client must specify a value for share_access that is one of READ, WRITE, or BOTH. For share_deny, the client must specify one of NONE, READ, WRITE, or BOTH. If the client fails to do this, the server must return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHAREのご予約は、クライアントがREADの1、WRITE、またはBOTHですshare_accessの値を指定する必要があります。 share_denyのために、クライアントは、読み取り、書き込みNONEのいずれかまたは両方を指定する必要があります。クライアントはこれを行うに失敗した場合、サーバーはNFS4ERR_INVALを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the share_access value (READ, WRITE, or BOTH) the client should check that the requester has the proper access rights to perform the specified operation. This would generally be the results of applying the ACL access rules to the file for the current requester. However, just as with the ACCESS operation, the client should not attempt to second-guess the server&#39;s decisions, as access rights may change and may be subject to server administrative controls outside the ACL framework. If the requester is not authorized to READ or WRITE (depending on the share_access value), the server must return NFS4ERR_ACCESS. Note that since the NFS version 4 protocol does not impose any requirement that READs and WRITEs issued for an open file have the same credentials as the OPEN itself, the server still must do appropriate access checking on the READs and WRITEs themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
share_access値に基づいて（READ、WRITE、またはBOTH）クライアントは、要求者が指定した操作を実行するための適切なアクセス権を持っていることを確認する必要があります。これは、一般的に、現在の要求者用のファイルにACLのアクセスルールを適用した結果だろう。しかし、単にアクセス動作と同様に、クライアントは、アクセス権が変更される可能性とACLのフレームワーク外部のサーバ管理統制を受ける可能性があるとして、サーバーの決定を第二推測を試みるべきではありません。依頼者は、（share_access値に応じて）読み出しまたは書き込みを許可されていない場合、サーバーはNFS4ERR_ACCESSを返さなければなりません。 NFSバージョン4プロトコルは読み込み、開いているファイルに対して発行された書き込みはOPEN自体と同じ資格情報を持っているどのような要件を課していないので、サーバはまだ読み込み、自分の書き込みを行うにチェックし、適切なアクセスを行う必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the component provided to OPEN is a symbolic link, the error NFS4ERR_SYMLINK will be returned to the client. If the current filehandle is not a directory, the error NFS4ERR_NOTDIR will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENに提供されるコンポーネントがシンボリックリンクの場合、エラーNFS4ERR_SYMLINKがクライアントに返されます。現在のファイルハンドルがディレクトリでない場合は、エラーNFS4ERR_NOTDIRが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADOWNER NFS4ERR_BAD_SEQID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_EXPIRED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADOWNER NFS4ERR_BAD_SEQID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_EXPIRED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_NO_GRACE NFS4ERR_PERM NFS4ERR_RECLAIM_BAD NFS4ERR_RECLAIM_CONFLICT NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_SHARE_DENIED NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_SYMLINK NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP NFS4ERR_NO_GRACE NFS4ERR_PERM NFS4ERR_RECLAIM_BAD NFS4ERR_RECLAIM_CONFLICT NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_SHARE_DENIED NFS4ERR_STALE NFS4ERR_STALE_CLIENTID NFS4ERR_SYMLINK NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.17. Operation 19: OPENATTR - Open Named Attribute Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.17。操作19：OPENATTR  - オープン名前付き属性ディレクトリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) createdir -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）createdir  - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPENATTR4args {
             /* CURRENT_FH: object */
             bool    createdir;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPENATTR4res {
             /* CURRENT_FH: named attr directory*/
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPENATTR operation is used to obtain the filehandle of the named attribute directory associated with the current filehandle. The result of the OPENATTR will be a filehandle to an object of type NF4ATTRDIR. From this filehandle, READDIR and LOOKUP operations can be used to obtain filehandles for the various named attributes associated with the original filesystem object. Filehandles returned within the named attribute directory will have a type of NF4NAMEDATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENATTR操作は、現在のファイルハンドルに関連付けられた名前の属性ディレクトリのファイルハンドルを取得するために使用されます。 OPENATTRの結果は、タイプNF4ATTRDIRのオブジェクトへのファイルハンドルであろう。このファイルハンドルから、READDIRとLOOKUP操作は、元のファイルシステム・オブジェクトに関連付けられた種々の名前属性のファイルハンドルを取得するために使用することができます。ファイルハンドルはNF4NAMEDATTRの種類がありますという名前の属性ディレクトリに戻りました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The createdir argument allows the client to signify if a named attribute directory should be created as a result of the OPENATTR operation. Some clients may use the OPENATTR operation with a value of FALSE for createdir to determine if any named attributes exist for the object. If none exist, then NFS4ERR_NOENT will be returned. If createdir has a value of TRUE and no named attribute directory exists, one is created. The creation of a named attribute directory assumes that the server has implemented named attribute support in this fashion and is not required to do so by this definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
createdir引数が指定された属性ディレクトリがOPENATTR操作の結果として作成されなければならない場合、クライアントが意味することができます。任意の名前の属性がオブジェクトのために存在している場合、一部のクライアントが決定するためにcreatedirためFALSEの値でOPENATTR操作を使用することができます。何も存在しない場合、NFS4ERR_NOENTが返されます。 createdirがTRUEの値を持ち、何という名前の属性ディレクトリが存在しない場合は、新たに作成されます。名前の属性ディレクトリの作成は、サーバが、このやり方でという名前の属性のサポートを実装しており、この定義によってそうするために必要とされていないことを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server does not support named attributes for the current filehandle, an error of NFS4ERR_NOTSUPP will be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、現在のファイルハンドルの名前が付いた属性をサポートしていない場合は、NFS4ERR_NOTSUPPのエラーがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_FHEXPIRED NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.18. Operation 20: OPEN_CONFIRM - Confirm Open
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.18。操作20：オープン_CONFIRM  - 確認開きます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), seqid, stateid-&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、SEQID、stateid-&gt;のstateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN_CONFIRM4args {
             /* CURRENT_FH: opened file */
             stateid4        open_stateid;
             seqid4          seqid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN_CONFIRM4resok {
             stateid4        open_stateid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union OPEN_CONFIRM4res switch (nfsstat4 status) {
      case NFS4_OK:
              OPEN_CONFIRM4resok     resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to confirm the sequence id usage for the first time that a open_owner is used by a client. The stateid returned from the OPEN operation is used as the argument for this operation along with the next sequence id for the open_owner. The sequence id passed to the OPEN_CONFIRM must be 1 (one) greater than the seqid passed to the OPEN operation from which the open_confirm value was obtained. If the server receives an unexpected sequence id with respect to the original open, then the server assumes that the client will not confirm the original OPEN and all state associated with the original OPEN is released by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作はopen_ownerは、クライアントによって使用される最初の時間のためのシーケンスIDの使用状況を確認するために使用されます。 OPEN操作から返さのstateidはopen_ownerための次のシーケンスIDとともに、この操作の引数として使用されます。オープン_CONFIRMに渡されたシーケンス番号は、オープン_CONFIRM値が得られたOPEN操作に渡さSEQIDより1（1）大きくなければなりません。サーバは、元のオープンに関して予想外シーケンスIDを受信した場合、サーバは、クライアントがサーバーによって解放され、元のOPENと元OPENに関連するすべての状態を確認しないことを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A given client might generate many open_owner4 data structures for a given clientid. The client will periodically either dispose of its open_owner4s or stop using them for indefinite periods of time. The latter situation is why the NFS version 4 protocol does not have an explicit operation to exit an open_owner4: such an operation is of no use in that situation. Instead, to avoid unbounded memory use, the server needs to implement a strategy for disposing of open_owner4s that have no current lock, open, or delegation state for any files and have not been used recently. The time period used to determine when to dispose of open_owner4s is an implementation choice. The time period should certainly be no less than the lease time plus any grace period the server wishes to implement beyond a lease time. The OPEN_CONFIRM operation allows the server to safely dispose of unused open_owner4 data structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与えられたクライアントは、与えられたclientidのための多くのopen_owner4データ構造を生成することがあります。クライアントは、定期的にどちらかのopen_owner4sを処分または無期限の期間のためにそれらを使用して停止します。このような動作は、そのような状況では役に立たない：NFSバージョン4プロトコルはopen_owner4を終了するために、明示的な操作を持っていない理由後者の状況です。代わりに、無限のメモリ使用を避けるために、サーバはすべてのファイルには現在のロック、オープン、または委任状態を持っていないし、最近使用されていないopen_owner4sの処分のための戦略を実装する必要があります。ときopen_owner4sの処分を決定するために使用される期間は、実装の選択です。期間は確かにリース時間を加えたサーバがリース時間を超えて実施することを希望する任意の猶予期間よりも少なくないはずです。オープン_CONFIRM操作は、サーバーが安全に使用されていないopen_owner4データ構造を処分することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a client issues an OPEN operation and the server no longer has a record of the open_owner4, the server needs to ensure that this is a new OPEN and not a replay or retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはもはやOPEN操作して、サーバを発行open_owner4の記録を持っている場合、サーバは、これは再生や再送信、新規OPENとされていないことを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers must not require confirmation on OPENs that grant delegations or are doing reclaim operations. See section &#34;Use of Open Confirmation&#34; for details. The server can easily avoid this by noting whether it has disposed of one open_owner4 for the given clientid. If the server does not support delegation, it might simply maintain a single bit that notes whether any open_owner4 (for any client) has been disposed of.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは委託を付与したり再生操作をしているのOPENsの確認を要求してはなりません。詳細については、「開くときに確認の使用」を参照してください。サーバーは簡単にそれが与えられたclientidのために1 open_owner4を処分したかどうかに注目することによってこれを避けることができます。サーバは委任をサポートしていない場合、それは単に（任意のクライアントのための）任意のopen_owner4が破棄されているかどうかを指摘し、単一のビットを維持する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server must hold unconfirmed OPEN state until one of three events occur. First, the client sends an OPEN_CONFIRM request with the appropriate sequence id and stateid within the lease period. In this case, the OPEN state on the server goes to confirmed, and the open_owner4 on the server is fully established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3つのイベントのいずれかが発生するまで、サーバは未確認OPEN状態を保持しなければなりません。まず、クライアントはリース期間内の適切なシーケンスidとのstateidとのオープン_CONFIRM要求を送信します。この場合、サーバー上のOPEN状態を確認に行くと、サーバー上のopen_owner4が完全に確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Second, the client sends another OPEN request with a sequence id that is incorrect for the open_owner4 (out of sequence). In this case, the server assumes the second OPEN request is valid and the first one is a replay. The server cancels the OPEN state of the first OPEN request, establishes an unconfirmed OPEN state for the second OPEN request, and responds to the second OPEN request with an indication that an OPEN_CONFIRM is needed. The process then repeats itself. While there is a potential for a denial of service attack on the client, it is mitigated if the client and server require the use of a security flavor based on Kerberos V5, LIPKEY, or some other flavor that uses cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二に、クライアントは、（シーケンスのうち）open_owner4について間違っているシーケンスIDを持つ別のOPEN要求を送信します。この場合、サーバは、2番目のOPEN要求が有効であるとみなし、最初のものはリプレイです。サーバは、最初のOPEN要求のOPEN状態を解除する第二のOPEN要求の未確認OPEN状態を確立し、オープン_CONFIRMが必要であるという指示を有する第二OPEN要求に応答します。プロセスはその後、自分自身を繰り返します。クライアント上のサービス拒否攻撃の可能性がある一方で、クライアントとサーバーがKerberos V5、LIPKEY、または暗号を使用して、いくつかの他のフレーバーに基づくセキュリティ風味を使用する必要があれば、それが軽減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
What if the server is in the unconfirmed OPEN state for a given open_owner4, and it receives an operation on the open_owner4 that has a stateid but the operation is not OPEN, or it is OPEN_CONFIRM but with the wrong stateid? Then, even if the seqid is correct, the server returns NFS4ERR_BAD_STATEID, because the server assumes the operation is a replay: if the server has no established OPEN state, then there is no way, for example, a LOCK operation could be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どのようなサーバーが指定されたopen_owner4ため未確認OPEN状態にあり、それはたstateidを持っていますが、操作が開いていない、またはそれがオープン_CONFIRMあるopen_owner4ではなく、間違ったstateidを使用して操作を受信した場合？サーバが何の確立OPEN状態を持っていない場合、方法はありません、例えば、LOCK操作が有効である可能性：SEQIDが正しい場合でも、サーバーは操作がリプレイであると仮定しているため、その後、サーバは、NFS4ERR_BAD_STATEIDを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Third, neither of the two aforementioned events occur for the open_owner4 within the lease period. In this case, the OPEN state is canceled and disposal of the open_owner4 can occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第三に、上記の2つのイベントのどちらもリース期間内open_owner4ために起こります。この場合、OPEN状態が解除され、open_owner4の廃棄が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.19. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.19。操作21：OPEN_DOWNGRADE  - オープンファイルアクセスを削減
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, seqid, access, deny -&gt; stateid
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、のstateid、SEQID、アクセス、拒否 - &gt;のstateid
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN_DOWNGRADE4args {
             /* CURRENT_FH: opened file */
             stateid4        open_stateid;
             seqid4          seqid;
             uint32_t        share_access;
             uint32_t        share_deny;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct OPEN_DOWNGRADE4resok {
             stateid4        open_stateid;
     }; union OPEN_DOWNGRADE4res switch(nfsstat4 status) {
      case NFS4_OK:
             OPEN_DOWNGRADE4resok    resok4;
      default:
             void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to adjust the share_access and share_deny bits for a given open. This is necessary when a given openowner opens the same file multiple times with different share_access and share_deny flags. In this situation, a close of one of the opens may change the appropriate share_access and share_deny flags to remove bits associated with opens no longer in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この動作は、指定された開放のためshare_accessとshare_denyビットを調整するために使用されます。与えられたopenownerが異なるshare_accessとshare_deny旗と同じファイルを複数回開いたときに、これが必要です。この状況では、開きの一つの近くには有効でなくなった開きに関連するビットを除去するために適切なshare_accessとshare_denyフラグを変更することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The share_access and share_deny bits specified in this operation replace the current ones for the specified open file. The share_access and share_deny bits specified must be exactly equal to the union of the share_access and share_deny bits specified for some subset of the OPENs in effect for current openowner on the current file. If that constraint is not respected, the error NFS4ERR_INVAL should be returned. Since share_access and share_deny bits are subsets of those already granted, it is not possible for this request to be denied because of conflicting share reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作で指定share_accessとshare_denyビットが指定されたオープンファイルの現在のものを交換してください。指定share_accessとshare_denyビットは、現在のファイルの現在openowner効果で開きのサブセットに指定share_accessとshare_denyビットの和集合に正確に等しくなければなりません。その制約が尊重されていない場合は、エラーNFS4ERR_INVALが返されます。 share_accessとshare_denyビットが既に許可されたもののサブセットであるので、この要求があるため、競合シェアの予約を拒否されるため、それは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.20. Operation 22: PUTFH - Set Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.20。操作22：PUTFH  - 設定された現在のファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
filehandle -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ファイルハンドル - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct PUTFH4args {
             nfs_fh4         object;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct PUTFH4res {
             /* CURRENT_FH: */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replaces the current filehandle with the filehandle provided as an argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数として与えられたファイルハンドルと、現在のファイルハンドルを置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the security mechanism used by the requester does not meet the requirements of the filehandle provided to this operation, the server MUST return NFS4ERR_WRONGSEC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
依頼者が使用するセキュリティ・メカニズムは、この操作に提供されるファイルハンドルの要件を満たしていない場合、サーバーはNFS4ERR_WRONGSECを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Commonly used as the first operator in an NFS request to set the context for following operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的操作を以下のコンテキストを設定するために、NFS要求の最初の演算子として使用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.21. Operation 23: PUTPUBFH - Set Public Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.21。操作23：PUTPUBFH  - セットの公開ファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
 -   - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct PUTPUBFH4res {
             /* CURRENT_FH: public fh */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replaces the current filehandle with the filehandle that represents the public filehandle of the server&#39;s name space. This filehandle may be different from the &#34;root&#34; filehandle which may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの名前空間の公開ファイルハンドルを表し、ファイルハンドルと、現在のファイルハンドルを置き換えます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けすることができる「ルート」ファイルハンドルは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The public filehandle represents the concepts embodied in [RFC2054], [RFC2055], [RFC2224]. The intent for NFS version 4 is that the public filehandle (represented by the PUTPUBFH operation) be used as a method of providing WebNFS server compatibility with NFS versions 2 and 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公共ファイルハンドルは、[RFC2054]、[RFC2055]、[RFC2224]で具現化の概念を表します。 NFSバージョン4のための意図は、（PUTPUBFH動作によって表される）は、公開ファイルハンドルは、NFSバージョン2と3とWebNFSのサーバとの互換性を提供する方法として使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The public filehandle and the root filehandle (represented by the PUTROOTFH operation) should be equivalent. If the public and root filehandles are not equivalent, then the public filehandle MUST be a descendant of the root filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（PUTROOTFH操作によって表される）は、公開ファイルハンドルとルートファイルハンドルは、同等であるべきです。公共とルートファイルハンドルが等しくない場合には、公共ファイルハンドルはルートファイルハンドルの子孫でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Used as the first operator in an NFS request to set the context for following operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
動作を以下のコンテキストを設定するために、NFS要求の最初の演算子として使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the NFS version 2 and 3 public filehandle, the client is able to specify whether the path name provided in the LOOKUP should be evaluated as either an absolute path relative to the server&#39;s root or relative to the public filehandle. [RFC2224] contains further discussion of the functionality. With NFS version 4, that type of specification is not directly available in the LOOKUP operation. The reason for this is because the component separators needed to specify absolute vs. relative are not allowed in NFS version 4. Therefore, the client is responsible for constructing its request such that the use of either PUTROOTFH or PUTPUBFH are used to signify absolute or relative evaluation of an NFS URL respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン2と3の公共ファイルハンドルを使用すると、クライアントはLOOKUPで指定したパス名は、サーバのルートからの相対または公共ファイルハンドルからの相対、絶対パスのいずれかのように評価されるべきかどうかを指定することができます。 [RFC2224]は機能のさらなる議論を含んでいます。 NFSバージョン4を用いて、仕様のタイプは、ルックアップ操作で直接使用できません。相対的な対絶対指定するために必要なコンポーネントの区切りがNFSバージョン4で許可されていないので、この理由はそのため、クライアントはPUTROOTFHまたはPUTPUBFHのいずれかの使用は絶対的または相対を意味するために使用されるようにその要求を構築するための責任があるさそれぞれNFS URLの評価。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there are warnings mentioned in [RFC2224] with respect to the use of absolute evaluation and the restrictions the server may place on that evaluation with respect to how much of its namespace has been made available. These same warnings apply to NFS version 4. It is likely, therefore that because of server implementation details, an NFS version 3 absolute public filehandle lookup may behave differently than an NFS version 4 absolute resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
絶対評価の使用に関して、[RFC2224]で述べた警告とサーバが利用可能になってきたどのくらいその名前空間のに対し、評価の上に置くことの制限があることに注意してください。これらの同じ警告は、それが原因で、サーバーの実装の詳細を、NFSバージョン3絶対公共ファイルハンドルの参照がNFSバージョン4絶対解像度とは異なる動作をする場合があり、したがってという、ありそうであるNFSバージョン4に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is a form of security negotiation as described in [RFC2755] that uses the public filehandle a method of employing SNEGO. This method is not available with NFS version 4 as filehandles are not overloaded with special meaning and therefore do not provide the same framework as NFS versions 2 and 3. Clients should therefore use the security negotiation mechanisms described in this RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パブリックファイルハンドルをSNEGOを用いた方法を使用して、[RFC2755]に記載されているようにセキュリティネゴシエーションの形態があります。ファイルハンドルは特別な意味を持つオーバーロードされていないため、NFSバージョン2と同じフレームワークを提供していませんし、3クライアントは、したがって、このRFCで説明されているセキュリティ交渉メカニズムを使用する必要があるとして、この方法では、NFSバージョン4では使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.22. Operation 24: PUTROOTFH - Set Root Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.22。操作24：PUTROOTFH  - セットのルートファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
 -   - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct PUTROOTFH4res {
             /* CURRENT_FH: root fh */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replaces the current filehandle with the filehandle that represents the root of the server&#39;s name space. From this filehandle a LOOKUP operation can locate any other filehandle on the server. This filehandle may be different from the &#34;public&#34; filehandle which may be associated with some other directory on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの名前空間のルートを表すファイルハンドルと、現在のファイルハンドルを置き換えます。このファイルハンドルからLOOKUP操作は、サーバー上の他のファイルハンドルを見つけることができます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けすることができる「パブリック」ファイルハンドルは異なる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Commonly used as the first operator in an NFS request to set the context for following operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的操作を以下のコンテキストを設定するために、NFS要求の最初の演算子として使用しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.23. Operation 25: READ - Read from File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.23。操作25：READ  - ファイルから読み込みます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, offset, count -&gt; eof, data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、のstateid、オフセットは、カウント - &gt; EOF、データ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READ4args {
             /* CURRENT_FH: file */
             stateid4        stateid;
             offset4         offset;
             count4          count;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READ4resok {
             bool            eof;
             opaque          data&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union READ4res switch (nfsstat4 status) {
      case NFS4_OK:
              READ4resok     resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READ operation reads data from the regular file identified by the current filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ操作は、現在のファイルハンドルで識別される通常のファイルからデータを読み込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client provides an offset of where the READ is to start and a count of how many bytes are to be read. An offset of 0 (zero) means to read data starting at the beginning of the file. If offset is greater than or equal to the size of the file, the status, NFS4_OK, is returned with a data length set to 0 (zero) and eof is set to TRUE. The READ is subject to access permissions checking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはREADが開始することで、どのように多くのバイト数を読み取ることがどこのオフセットを提供します。 0（ゼロ）のオフセットをファイルの先頭から始まるデータを読み取ることを意味します。オフセットがより大きいかまたはファイルのサイズに等しい場合、ステータス、NFS4_OKは、TRUEに設定されている0（ゼロ）とEOFに設定されたデータ長と戻されます。 READは、チェックアクセス許可の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client specifies a count value of 0 (zero), the READ succeeds and returns 0 (zero) bytes of data again subject to access permissions checking. The server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、0（ゼロ）のカウント値を指定した場合、READは成功し、アクセス権限をチェックするために、再度対象データの0（ゼロ）バイトを返します。サーバーは、クライアントによって指定されたよりも少ないバイト数を返すように選択することができます。クライアントは、この状態を確認し、適切な条件を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid value for a READ request represents a value returned from a previous record lock or share reservation request. The stateid is used by the server to verify that the associated share reservation and any record locks are still valid and to update lease timeouts for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ要求のためのstateid値は、前のレコードロックまたは共有の予約要求から返された値を表します。 stateidは、関連する株式予約と任意のレコードロックがまだ有効であることを確認するために、クライアントのリースのタイムアウトを更新するためにサーバによって使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the read ended at the end-of-file (formally, in a correctly formed READ request, if offset + count is equal to the size of the file), or the read request extends beyond the size of the file (if offset + count is greater than the size of the file), eof is returned as TRUE; otherwise it is FALSE. A successful READ of an empty file will always return eof as TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オフセットが（ファイルの終わりで終了読み取り（オフセット+回数場合、正しく形成さREAD要求で、正式には、ファイルのサイズと同じである）、または読み取り要求はファイルのサイズを超えて拡張する場合+カウントは、EOFがTRUEとして返され、）ファイルのサイズよりも大きいです。それ以外の場合はFALSEです。空のファイルの成功READは常にEOFとしてTRUEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the current filehandle is not a regular file, an error will be returned to the client. In the case the current filehandle represents a directory, NFS4ERR_ISDIR is return; otherwise, NFS4ERR_INVAL is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルが通常のファイルでない場合は、エラーがクライアントに返されます。現在のファイルハンドルがディレクトリを表す場合には、NFS4ERR_ISDIRはリターンです。そうでない場合は、NFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a READ with a stateid value of all bits 0, the server MAY allow the READ to be serviced subject to mandatory file locks or the current share deny modes for the file. For a READ with a stateid value of all bits 1, the server MAY allow READ operations to bypass locking checks at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全ビット0のstateid値がREADのために、サーバは、READが必須のファイルロックまたは現在の共有ファイルのためのモードを拒否する対象サービスを受けることを可能にすることができます。全ビット1のstateid値がREADのために、サーバは、READ操作はサーバにロックチェックをバイパスすることを可能にし得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible for the server to return fewer than count bytes of data. If the server returns less than the count requested and eof is set to FALSE, the client should issue another READ to get the remaining data. A server may return less data than requested under several circumstances. The file may have been truncated by another client or perhaps on the server itself, changing the file size from what the requesting client believes to be the case. This would reduce the actual amount of data available to the client. It is possible that the server may back off the transfer size and reduce the read request return. Server resource exhaustion may also occur necessitating a smaller read return.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがデータのバイト数を数えるよりも少ない数を返すことが可能です。サーバは要求された数よりも少ない返し、EOFがFALSEに設定されている場合は、別のREADを発行する必要があり、クライアントは、残りのデータを取得します。サーバーには、いくつかの状況下で要求されたよりも少ないデータを返すことがあります。ファイルが要求しているクライアントは、ケースのように信じているから、ファイルサイズを変更し、別のクライアントによって、またはおそらく、サーバー自体に切り捨てられている可能性があります。これは、クライアントが利用可能なデータの実際の量を減少させるであろう。サーバーが転送サイズをバックオフし、読み出し要求リターンを減らすことが可能です。また、サーバリソース疲労困憊は、より小さな読み取りリターンを必要と発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If mandatory file locking is on for the file, and if the region corresponding to the data to be read from file is write locked by an owner not associated the stateid, the server will return the NFS4ERR_LOCKED error. The client should try to get the appropriate read record lock via the LOCK operation before re-attempting the READ. When the READ completes, the client should release the record lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須のファイルのロックは、ファイルのためである場合、ファイルから読み出されるべきデータに対応する領域がのstateidに関連付けられていない所有者によってロック書き込みである場合、サーバはNFS4ERR_LOCKEDエラーを返します。クライアントはREADを再試行する前にLOCK操作を介して適切な読み取りレコードロックを取得しようとする必要があります。 READが完了すると、クライアントはLOCKUを経由して、レコードのロックを解除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_IO NFS4ERR_INVAL NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.24. Operation 26: READDIR - Read Directory
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.24。操作26：READDIR  - 読むディレクトリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS (cfh), cookie, cookieverf, dircount, maxcount, attr_request -&gt; cookieverf { cookie, name, attrs }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書式（CFH）、クッキー、にcookieverf、dircount、MAXCOUNT、attr_request  - &gt;にcookieverf {クッキー、名前、ATTRS}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READDIR4args {
             /* CURRENT_FH: directory */
             nfs_cookie4     cookie;
             verifier4       cookieverf;
             count4          dircount;
             count4          maxcount;
             bitmap4         attr_request;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct entry4 {
             nfs_cookie4     cookie;
             component4      name;
             fattr4          attrs;
             entry4          *nextentry;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct dirlist4 {
             entry4          *entries;
             bool            eof;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READDIR4resok {
             verifier4       cookieverf;
             dirlist4        reply;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union READDIR4res switch (nfsstat4 status) {
      case NFS4_OK:
              READDIR4resok  resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READDIR operation retrieves a variable number of entries from a filesystem directory and returns client requested attributes for each entry along with information to allow the client to request additional directory entries in a subsequent READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作は、ファイルシステムディレクトリのエントリの可変数を取得し、クライアントは、クライアントがその後のREADDIRに追加のディレクトリエントリを要求することを可能にする情報とともに、各エントリの属性を要求返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arguments contain a cookie value that represents where the READDIR should start within the directory. A value of 0 (zero) for the cookie is used to start reading at the beginning of the directory. For subsequent READDIR requests, the client specifies a cookie value that is provided by the server on a previous READDIR request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数はREADDIRがディレクトリ内の開始すべき場所を表すクッキー値が含まれています。 Cookieの0（ゼロ）の値は、ディレクトリの始めに読み始めるために使用されます。その後のREADDIR要求の場合、クライアントは前のREADDIR要求にサーバーによって提供されたクッキーの値を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookieverf value should be set to 0 (zero) when the cookie value is 0 (zero) (first directory read). On subsequent requests, it should be a cookieverf as returned by the server. The cookieverf must match that returned by the READDIR in which the cookie was acquired. If the server determines that the cookieverf is no longer valid for the directory, the error NFS4ERR_NOT_SAME must be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クッキー値が0（ゼロ）である場合にcookieverf値（最初のディレクトリは、読み取り）0（ゼロ）に設定されるべきです。後続の要求では、サーバで返すようにcookieverfでなければなりません。 cookieverfはクッキーが取得されたREADDIRによって返されたものと一致する必要があります。サーバはにcookieverfは、もはや有効なディレクトリのためではないと判断した場合、エラーNFS4ERR_NOT_SAMEを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dircount portion of the argument is a hint of the maximum number of bytes of directory information that should be returned. This value represents the length of the names of the directory entries and the cookie value for these entries. This length represents the XDR encoding of the data (names and cookies) and not the length in the native format of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数のdircount部分が返されるべきであるディレクトリ情報のバイトの最大数のヒントです。この値は、ディレクトリエントリとこれらのエントリのクッキー値の名前の長さを表しています。この長さは、XDRデータ（名前およびクッキー）の符号化ではなく、サーバのネイティブフォーマットにおける長さを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The maxcount value of the argument is the maximum number of bytes for the result. This maximum size represents all of the data being returned within the READDIR4resok structure and includes the XDR overhead. The server may return less data. If the server is unable to return a single directory entry within the maxcount limit, the error NFS4ERR_TOOSMALL will be returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数のMAXCOUNT値は、結果の最大バイト数です。この最大サイズはREADDIR4resok構造内に返されるすべてのデータを表し、XDRオーバーヘッドを含みます。サーバーは、少ないデータを返すことがあります。サーバがMAXCOUNT限度内の単一のディレクトリエントリを返すことができない場合は、エラーNFS4ERR_TOOSMALLがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, attr_request represents the list of attributes to be returned for each directory entry supplied by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、attr_requestは、サーバによって供給される各ディレクトリエントリのために返される属性のリストを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On successful return, the server&#39;s response will provide a list of directory entries. Each of these entries contains the name of the directory entry, a cookie value for that entry, and the associated attributes as requested. The &#34;eof&#34; flag has a value of TRUE if there are no more entries in the directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功のリターンで、サーバの応答は、ディレクトリエントリのリストを提供します。要求に応じてこれらの各エントリには、ディレクトリエントリ、そのエントリのクッキー値、および関連する属性の名前が含まれています。ディレクトリには複数のエントリが存在しない場合は、「EOF」フラグがTRUEの値を持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookie value is only meaningful to the server and is used as a &#34;bookmark&#34; for the directory entry. As mentioned, this cookie is used by the client for subsequent READDIR operations so that it may continue reading a directory. The cookie is similar in concept to a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クッキー値は、サーバーにのみ意味があり、ディレクトリエントリの「しおり」として使用されています。前述のように、それはディレクトリを読み続けることができるように、このクッキーは、その後のREADDIR操作のためにクライアントによって使用されます。クッキーは、とコンセプトが似ています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READ offset but should not be interpreted as such by the client. Ideally, the cookie value should not change if the directory is modified since the client may be caching these values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READは、オフセットが、クライアントによってそのように解釈すべきではありません。ディレクトリが変更された場合、クライアントは、これらの値をキャッシュすることができるので、理想的には、クッキーの値は変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, the server may encounter an error while obtaining the attributes for a directory entry. Instead of returning an error for the entire READDIR operation, the server can instead return the attribute &#39;fattr4_rdattr_error&#39;. With this, the server is able to communicate the failure to the client and not fail the entire operation in the instance of what might be a transient failure. Obviously, the client must request the fattr4_rdattr_error attribute for this method to work properly. If the client does not request the attribute, the server has no choice but to return failure for the entire READDIR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ディレクトリエントリの属性を取得しながら、いくつかのケースでは、サーバがエラーが発生することがあります。代わりに、全体のREADDIR操作のためのエラーを返すので、サーバーではなく、属性「fattr4_rdattr_error」を返すことができます。これにより、サーバはクライアントに障害が発生して通信し、一時的な障害であるかもしれないもののインスタンスで全体の動作を失敗しないことが可能です。もちろん、クライアントは正常に動作するために、このメソッドのfattr4_rdattr_error属性を要求する必要があります。クライアントが属性を要求しない場合、サーバは全体のREADDIR操作のために失敗を返すしかありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some filesystem environments, the directory entries &#34;.&#34; and &#34;..&#34; have special meaning and in other environments, they may not. If the server supports these special entries within a directory, they should not be returned to the client as part of the READDIR response. To enable some client environments, the cookie values of 0, 1, and 2 are to be considered reserved. Note that the UNIX client will use these values when combining the server&#39;s response and local representations to enable a fully formed UNIX directory presentation to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのファイルシステム環境では、ディレクトリエントリ「」そして、「..」は特別な意味を持っており、他の環境では、彼らはないかもしれません。サーバーは、ディレクトリ内のこれらの特別項目をサポートしている場合、彼らはREADDIR応答の一部としてクライアントに返すべきではありません。いくつかのクライアント環境を有効にするには、0、1、および2のクッキー値は、予約された考慮されるべきです。アプリケーションに完全に形成されたUNIXディレクトリのプレゼンテーションを可能にするために、サーバーの応答とローカル表現を組み合わせる場合、UNIXクライアントはこれらの値を使用することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For READDIR arguments, cookie values of 1 and 2 should not be used and for READDIR results cookie values of 0, 1, and 2 should not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIRの引数の場合、1と2のクッキー値を使用すべきではないとREADDIR 0のクッキー値、結果は1と2が返されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server&#39;s filesystem directory representations can differ greatly. A client&#39;s programming interfaces may also be bound to the local operating environment in a way that does not translate well into the NFS protocol. Therefore the use of the dircount and maxcount fields are provided to allow the client the ability to provide guidelines to the server. If the client is aggressive about attribute collection during a READDIR, the server has an idea of how to limit the encoded response. The dircount field provides a hint on the number of entries based solely on the names of the directory entries. Since it is a hint, it may be possible that a dircount value is zero. In this case, the server is free to ignore the dircount value and return directory information based on the specified maxcount value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバのファイルシステムのディレクトリ表現は大きく異なることができます。クライアントのプログラミング・インタフェースは、NFSプロトコルにうまく変換されないように、ローカルの動作環境に結合させることができます。したがってdircountとMAXCOUNTフィールドの使用は、クライアントにサーバーへの指針を提供する能力を可能にするために提供されています。クライアントは、READDIR時の属性コレクションについて積極的である場合、サーバーはエンコードされた応答を制限する方法のアイデアを持っています。 dircountフィールドは、単にディレクトリエントリの名前に基づいてエントリの数にヒントを提供します。それはヒントなので、dircount値がゼロであることが可能であってもよいです。この場合、サーバはdircount値を無視し、指定されたMAXCOUNT値に基づいて、ディレクトリ情報を返すために自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cookieverf may be used by the server to help manage cookie values that may become stale. It should be a rare occurrence that a server is unable to continue properly reading a directory with the provided cookie/cookieverf pair. The server should make every effort to avoid this condition since the application at the client may not be able to properly handle this type of failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieverfは古くなる可能性がクッキー値の管理を支援するためにサーバが使用することができます。これは、サーバーが提供するクッキー/にcookieverfペアでディレクトリを読み、適切に継続することができないまれな出来事でなければなりません。サーバーは、クライアントのアプリケーションが正常にこのタイプの障害を処理することができない場合がありますので、この状態を回避するためにあらゆる努力をする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the cookieverf will also protect the client from using READDIR cookie values that may be stale. For example, if the file system has been migrated, the server may or may not be able to use the same cookie values to service READDIR as the previous server used. With the client providing the cookieverf, the server is able to provide the appropriate response to the client. This prevents the case where the server may accept a cookie value but the underlying directory has changed and the response is invalid from the client&#39;s context of its previous READDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieverfの使用も古いかもしれREADDIRクッキー値を使用してからクライアントを保護します。ファイルシステムが移行された場合、例えば、サーバは、または使用前サーバーとしてREADDIRにサービスを提供するために、同じクッキー値を使用することであってもなくてもよいです。クライアントがにcookieverfを提供すると、サーバはクライアントに適切な応答を提供することができます。これは、サーバがクッキー値を受け入れるかもしれませんが、基本となるディレクトリが変更されたとの応答がその前のREADDIRのクライアントの文脈から無効である場合を防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since some servers will not be returning &#34;.&#34; and &#34;..&#34; entries as has been done with previous versions of the NFS protocol, the client that requires these entries be present in READDIR responses must fabricate them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのサーバは戻ることはありませんので、「」そして、「..」エントリNFSプロトコルの以前のバージョンで行われているように、これらのエントリはREADDIR応答に存在することが必要とするクライアントは、それらを製作しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BAD_COOKIE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_TOOSMALL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_BAD_COOKIE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_TOOSMALL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.25. Operation 27: READLINK - Read Symbolic Link
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.25。操作27：READLINK  - シンボリックリンクを読みます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; linktext
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH） - &gt;リンクテキスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: symlink */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct READLINK4resok {
             linktext4       link;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union READLINK4res switch (nfsstat4 status) {
      case NFS4_OK:
              READLINK4resok resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINK reads the data associated with a symbolic link. The data is a UTF-8 string that is opaque to the server. That is, whether created by an NFS client or created locally on the server, the data in a symbolic link is not interpreted when created, but is simply stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINKは、シンボリックリンクに関連付けられたデータを読み込みます。データはサーバに不透明であるUTF-8文字列です。これは、作成した際に、NFSクライアントによって作成されたか、サーバー上でローカルに作成されたかどうか、シンボリックリンクのデータは解釈されないが、単純に保存されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A symbolic link is nominally a pointer to another file. The data is not necessarily interpreted by the server, just stored in the file. It is possible for a client implementation to store a path name that is not meaningful to the server operating system in a symbolic link. A READLINK operation returns the data to the client for interpretation. If different implementations want to share access to symbolic links, then they must agree on the interpretation of the data in the symbolic link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンボリックリンクは、名目上は別のファイルへのポインタです。データは必ずしも単にファイルに保存され、サーバーによって解釈されていません。クライアントの実装がシンボリックリンクで、サーバーのオペレーティングシステムには意味がありませんパス名を保存することが可能です。 READLINK操作は、解釈のために、クライアントにデータを返します。異なる実装がシンボリックリンクへのアクセスを共有したい場合は、それらはシンボリックリンクでのデータの解釈に同意しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READLINK operation is only allowed on objects of type NF4LNK. The server should return the error, NFS4ERR_INVAL, if the object is not of type, NF4LNK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READLINK操作は、タイプがNF4LNKのオブジェクトに許可されています。オブジェクトは、種類のNF4LNKでない場合、サーバーは、エラー、NFS4ERR_INVALを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_DELAY
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADHANDLE NFS4ERR_DELAY
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOTSUPP NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.26. Operation 28: REMOVE - Remove Filesystem Object
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.26。操作28：REMOVE  - ファイルシステムオブジェクトを削除します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), filename -&gt; change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、ファイル名 - &gt; change_info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct REMOVE4args {
             /* CURRENT_FH: directory */
             component4       target;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
struct REMOVE4resok { change_info4 cinfo; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
構造体REMOVE4resok {変化_info4のCINFO。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union REMOVE4res switch (nfsstat4 status) {
      case NFS4_OK:
              REMOVE4resok   resok4;
      default:
              void;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REMOVE operation removes (deletes) a directory entry named by filename from the directory corresponding to the current filehandle. If the entry in the directory was the last reference to the corresponding filesystem object, the object may be destroyed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REMOVE操作は、現在のファイルハンドルに対応するディレクトリからファイル名で指定されたディレクトリエントリを削除（消去します）。ディレクトリ内のエントリは、対応するファイルシステムオブジェクトへの最後の参照であった場合、オブジェクトが破棄されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the directory where the filename was removed, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the removal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイル名が削除されたディレクトリのために、サーバはcinfoの変化_info4情報を返します。前と後の変更属性が除去に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target has a length of 0 (zero), or if target does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットがUTF-8定義に従わない場合、ターゲットは0（ゼロ）の長さを有する場合、または、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS versions 2 and 3 required a different operator RMDIR for directory removal and REMOVE for non-directory removal. This allowed clients to skip checking the file type when being passed a non-directory delete system call (e.g., unlink() in POSIX) to remove a directory, as well as the converse (e.g., a rmdir() on a non-directory) because they knew the server would check the file type. NFS version 4 REMOVE can be used to delete any directory entry independent of its file type. The implementor of an NFS version 4 client&#39;s entry points from the unlink() and rmdir() system calls should first check the file type against the types the system call is allowed to remove before issuing a REMOVE. Alternatively, the implementor can produce a COMPOUND call that includes a LOOKUP/VERIFY sequence to verify the file type before a REMOVE operation in the same COMPOUND call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン2及び3は、ディレクトリ除去のための異なるオペレータRMDIRを必要と非ディレクトリの除去のために削除します。これは、非ディレクトリに）ディレクトリを削除するだけでなく、その逆（例えば、RMDIR（する非ディレクトリは（POSIXでは例えば、リンク解除（））システムコールを削除渡されるときに、クライアントは、ファイルの種類をチェックするスキップすることができ彼らは知っていたので）、サーバーは、ファイルの種類を確認します。 NFSバージョン4 REMOVEは、そのファイルの種類のいずれかのディレクトリエントリの独立を削除するために使用することができます。リンク解除（）とは、rmdir（）システムコールからNFSバージョン4のクライアントのエントリポイントの実装は、最初のシステムコールがREMOVEを発行する前に削除することが許可されているタイプに対してファイルの種類を確認する必要があります。代替として、実装者は、同じ化合物の呼び出しでREMOVE操作の前にファイルの種類を確認するために配列を検証/ LOOKUPを含む化合物のコールを生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The concept of last reference is server specific. However, if the numlinks field in the previous attributes of the object had the value 1, the client should not rely on referring to the object via a filehandle. Likewise, the client should not rely on the resources (disk space, directory entry, and so on) formerly associated with the object becoming immediately available. Thus, if a client needs to be able to continue to access a file after using REMOVE to remove it, the client should take steps to make sure that the file will still be accessible. The usual mechanism used is to RENAME the file from its old name to a new hidden name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の参照の概念は、サーバ固有のものです。オブジェクトの前の属性でnumlinksフィールドが値1を持っていた場合は、クライアントがファイルハンドルを経由してオブジェクトを参照するに頼るべきではありません。同様に、クライアントは以前すぐに利用可能になってきたオブジェクトに関連付けられたリソース（ディスク容量、ディレクトリエントリなど）に依存しないでください。クライアントは、それを削除するREMOVEを使用した後、ファイルへのアクセスを継続できるようにする必要がある場合はこのように、クライアントは、ファイルがまだアクセス可能になることを確認する手順を実行する必要があります。使用される通常のメカニズムは、新しい隠された名前に古い名前からファイルの名前を変更することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server finds that the file is still open when the REMOVE arrives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、REMOVEが到着したときにファイルがまだ開いていることを発見した場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server SHOULD NOT delete the file&#39;s directory entry if the file was opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれた場合、Oサーバは、ファイルのディレクトリエントリを削除しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the file was not opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, the server SHOULD delete the file&#39;s directory entry. However, until last CLOSE of the file, the server MAY continue to allow access to the file via its filehandle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれていない場合は、O、サーバーは、ファイルのディレクトリエントリを削除する必要があります。ただし、ファイルの最後のCLOSEまで、サーバーはそのファイルハンドルを経由してファイルへのアクセスを許可し続けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.27. Operation 29: RENAME - Rename Directory Entry
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.27。操作29：RENAME  - ディレクトリエントリの名前を変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh), oldname, (cfh), newname -&gt; source_change_info, target_change_info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（SFH）、OLDNAME、（CFH）、NEWNAME  - &gt; source_change_info、target_change_info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RENAME4args {
             /* SAVED_FH: source directory */
             component4      oldname;
             /* CURRENT_FH: target directory */
             component4      newname;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RENAME4resok {
             change_info4    source_cinfo;
             change_info4    target_cinfo;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union RENAME4res switch (nfsstat4 status) {
      case NFS4_OK:
              RENAME4resok   resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENAME operation renames the object identified by oldname in the source directory corresponding to the saved filehandle, as set by the SAVEFH operation, to newname in the target directory corresponding to the current filehandle. The operation is required to be atomic to the client. Source and target directories must reside on the same filesystem on the server. On success, the current filehandle will continue to be the target directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルに対応するターゲットディレクトリにnewnameに、SAVEFH操作によって設定さRENAME操作は、保存されたファイルハンドルに対応するソースディレクトリにOLDNAMEによって識別されたオブジェクトの名前を変更します。操作は、クライアント原子であることが必要です。ソースとターゲットディレクトリは、サーバー上の同じファイルシステム上に存在する必要があります。成功すると、現在のファイルハンドルは、ターゲットディレクトリであり続けるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the target directory already contains an entry with the name, newname, the source object must be compatible with the target: either both are non-directories or both are directories and the target must be empty. If compatible, the existing target is removed before the rename occurs (See the IMPLEMENTATION subsection of the section &#34;Operation 28: REMOVE - Remove Filesystem Object&#34; for client and server actions whenever a target is removed). If they are not compatible or if the target is a directory but not empty, the server will return the error, NFS4ERR_EXIST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターゲットディレクトリが既に名前、newnameの持つエントリが含まれている場合は、ソースオブジェクトがターゲットと互換性がなければならない：両方が非ディレクトリであるか、両方のディレクトリであり、ターゲットは空である必要があります。互換性のある場合は、既存のターゲットは、（： - ターゲットが削除されるたびに、クライアントとサーバーの操作については、「ファイルシステムオブジェクトを削除オペレーション28」の実装サブセクションを参照してください）名前の変更が発生する前に除去されます。彼らは互換性がないか、対象がディレクトリであるが、空でない場合、サーバは、NFS4ERR_EXISTをエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If oldname and newname both refer to the same file (they might be hard links of each other), then RENAME should perform no action and return success.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OLDNAMEとnewnameの両方が同じファイルを参照する場合は、何もアクションを実行しないと成功を返す必要がありRENAME（彼らはお互いのハードリンクであるかもしれません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For both directories involved in the RENAME, the server returns change_info4 information. With the atomic field of the change_info4 struct, the server will indicate if the before and after change attributes were obtained atomically with respect to the rename.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAMEにかかわる両方のディレクトリの場合、サーバーは変化_info4情報を返します。前と後の変更属性が名前の変更に関して原子論が得られた場合には変化_info4構造体の原子分野、意志が示すサーバ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the oldname refers to a named attribute and the saved and current filehandles refer to different filesystem objects, the server will return NFS4ERR_XDEV just as if the saved and current filehandles represented directories on different filesystems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OLDNAMEという名前の属性を参照し、保存され、現在のファイルハンドルは異なるファイルシステムのオブジェクトを参照する場合、サーバーが保存され、現在のファイルハンドルは異なるファイルシステム上のディレクトリを表すかのようにNFS4ERR_XDEVを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the oldname or newname has a length of 0 (zero), or if oldname or newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OLDNAMEまたはNEWNAMEが0（ゼロ）の長さを有する場合、またはOLDNAMEまたはNEWNAMEがUTF-8定義に従わない場合、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENAME operation must be atomic to the client. The statement &#34;source and target directories must reside on the same filesystem on the server&#34; means that the fsid fields in the attributes for the directories are the same. If they reside on different filesystems, the error, NFS4ERR_XDEV, is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENAME操作はクライアントにアトミックでなければなりません。声明「ソースとターゲットのディレクトリサーバー上の同じファイルシステム上に存在しなければならない」ディレクトリの属性におけるFSIDフィールドが同じであることを意味します。彼らは別のファイルシステム上に存在する場合は、エラー、NFS4ERR_XDEVは、返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the value of the fh_expire_type attribute for the object, the filehandle may or may not expire on a RENAME. However, server implementors are strongly encouraged to attempt to keep filehandles from expiring in this fashion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクトのfh_expire_type属性の値に基づいて、ファイルハンドルは、名前の変更には有効期限が切れていない場合があります。ただし、サーバーの実装は強く、この方法で期限切れからファイルハンドルを維持しようとすることが奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On some servers, the file names &#34;.&#34; and &#34;..&#34; are illegal as either oldname or newname, and will result in the error NFS4ERR_BADNAME. In addition, on many servers the case of oldname or newname being an alias for the source directory will be checked for. Such servers will return the error NFS4ERR_INVAL in these cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のサーバでは、ファイル名「」そして、「..」OLDNAMEかnewnameのいずれかとして違法であり、エラーNFS4ERR_BADNAMEになります。また、多くのサーバ上OLDNAMEまたはnewnameのソースディレクトリの別名であることの場合は、チェックされます。このようなサーバは、これらの場合にエラーNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If either of the source or target filehandles are not directories, the server will return NFS4ERR_NOTDIR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースまたはターゲットファイルハンドルのいずれかがディレクトリでない場合、サーバはNFS4ERR_NOTDIRを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_RESOURCE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_FILE_OPEN NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTEMPTY NFS4ERR_RESOURCE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC NFS4ERR_XDEV
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.28. Operation 30: RENEW - Renew a Lease
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.28。操作30：RENEW  - リースを更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ClientIDを - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RENEW4args {
             clientid4       clientid;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RENEW4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RENEW operation is used by the client to renew leases which it currently holds at a server. In processing the RENEW request, the server renews all leases associated with the client. The associated leases are determined by the clientid provided via the SETCLIENTID operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RENEW操作は、それが現在のサーバで保持しているリースを更新するために、クライアントによって使用されます。 RENEW要求を処理するには、サーバーは、クライアントに関連付けられているすべてのリースを更新します。関連リースはSETCLIENTID操作を介して提供されるクライアントIDによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client holds delegations, it needs to use RENEW to detect when the server has determined that the callback path is down. When the server has made such a determination, only the RENEW operation will renew the lease on delegations. If the server determines the callback path is down, it returns NFS4ERR_CB_PATH_DOWN. Even though it returns NFS4ERR_CB_PATH_DOWN, the server MUST renew the lease on the record locks and share reservations that the client has established on the server. If for some reason the lock and share reservation lease cannot be renewed, then the server MUST return an error other than NFS4ERR_CB_PATH_DOWN, even if the callback path is also down.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが代表団を保持しているときは、サーバーがコールバックパスがダウンしていると判断したときを検出するためにRENEWを使用する必要があります。サーバは、このような決意をしたときに、唯一のRENEW操作は代表団のリースを更新します。サーバーがコールバックパスがダウンしていると判断した場合、それはNFS4ERR_CB_PATH_DOWNを返します。それはNFS4ERR_CB_PATH_DOWNを返すにもかかわらず、サーバーは、クライアントがサーバー上で確立しているレコードロックと共有の予約にリースを更新しなければなりません。何らかの理由でロックと共有予約のリースを更新することができない場合、サーバは、コールバックパスがダウンしても場合でも、NFS4ERR_CB_PATH_DOWN以外のエラーを返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client that issues RENEW MUST choose the principal, RPC security flavor, and if applicable, GSS-API mechanism and service via one of the following algorithms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
問題はRENEWクライアントは、次のアルゴリズムのうちの1つを介して主要な、RPCセキュリティ風味、および該当する場合、GSS-APIメカニズムとサービスを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client uses the same principal, RPC security flavor -- and if the flavor was RPCSEC_GSS -- the same mechanism and service that was used when the client id was established via SETCLIENTID_CONFIRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントが同じ主、RPCセキュリティ風味を使用 - 及び風味はRPCSEC_GSSた場合 - クライアントIDがSETCLIENTID_CONFIRMを介して確立されたときに使用された同じメカニズムとサービス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client uses any principal, RPC security flavor mechanism and service combination that currently has an OPEN file on the server. I.e., the same principal had a successful OPEN operation, the file is still open by that principal, and the flavor, mechanism, and service of RENEW match that of the previous OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントは任意の校長、RPCセキュリティ風味のメカニズムと、現在のサーバー上のファイルを開いているサービスの組み合わせを使用しています。すなわち、同じ主体が成功OPEN操作を持っていた、ファイルはまだその元本によって開かれている、との風味、メカニズム、およびサービスは、その前のOPENの試合をRENEW。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST reject a RENEW that does not use one the aforementioned algorithms, with the error NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、それがエラーNFS4ERR_ACCESSで、1つの前述のアルゴリズムを使用していないRENEWを拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADXDR NFS4ERR_CB_PATH_DOWN NFS4ERR_EXPIRED NFS4ERR_LEASE_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADXDR NFS4ERR_CB_PATH_DOWN NFS4ERR_EXPIRED NFS4ERR_LEASE_MOVED NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.29. Operation 31: RESTOREFH - Restore Saved Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.29。操作31：RESTOREFH  - 保存されたファイルハンドルを復元
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(sfh) -&gt; (cfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（SFH） - &gt;（CFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* SAVED_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RESTOREFH4res {
             /* CURRENT_FH: value of saved fh */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Set the current filehandle to the value in the saved filehandle. If there is no saved filehandle then return the error NFS4ERR_RESTOREFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保存されたファイルハンドルの値に現在のファイルハンドルを設定します。何も保存されたファイルハンドルがない場合、エラーNFS4ERR_RESTOREFHを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operations like OPEN and LOOKUP use the current filehandle to represent a directory and replace it with a new filehandle. Assuming the previous filehandle was saved with a SAVEFH operator, the previous filehandle can be restored as the current filehandle. This is commonly used to obtain post-operation attributes for the directory, e.g.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPENとLOOKUPのような操作は、ディレクトリを表し、新しいファイルハンドルでそれを置き換えるために、現在のファイルハンドルを使用します。 SAVEFH演算子で保存された前回のファイルハンドルを仮定すると、以前のファイルハンドルは、現在のファイルハンドルとして復元することができます。これは、一般的に、術後は、例えば、ディレクトリの属性を取得するために使用されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         PUTFH (directory filehandle)
         SAVEFH
         GETATTR attrbits     (pre-op dir attrs)
         CREATE optbits &#34;foo&#34; attrs
         GETATTR attrbits     (file attributes)
         RESTOREFH
         GETATTR attrbits     (post-op dir attrs)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_RESTOREFH NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_RESOURCE NFS4ERR_RESTOREFH NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_WRONGSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.30. Operation 32: SAVEFH - Save Current Filehandle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.30。操作32：SAVEFH  - 保存現在のファイルハンドル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh) -&gt; (sfh)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH） - &gt;（SFH）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     /* CURRENT_FH: */
     void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SAVEFH4res {
             /* SAVED_FH: value of current fh */
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Save the current filehandle. If a previous filehandle was saved then it is no longer accessible. The saved filehandle can be restored as the current filehandle with the RESTOREFH operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のファイルハンドルを保存します。以前のファイルハンドルを保存した場合、それはアクセスできなくなります。保存されたファイルハンドルはRESTOREFH演算子で、現在のファイルハンドルとして復元することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_FHEXPIRED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.31. Operation 33: SECINFO - Obtain Available Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.31。操作33：SECINFO  - 利用可能なセキュリティを取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), name -&gt; { secinfo }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、名前 - &gt; {} SECINFO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SECINFO4args {
             /* CURRENT_FH: directory */
             component4     name;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum rpc_gss_svc_t {/* From RFC 2203 */
             RPC_GSS_SVC_NONE        = 1,
             RPC_GSS_SVC_INTEGRITY   = 2,
             RPC_GSS_SVC_PRIVACY     = 3
     }; struct rpcsec_gss_info {
             sec_oid4        oid;
             qop4            qop;
             rpc_gss_svc_t   service;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union secinfo4 switch (uint32_t flavor) {
      case RPCSEC_GSS:
              rpcsec_gss_info        flavor_info;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
typedef secinfo4 SECINFO4resok&lt;&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
typedefのsecinfo4 SECINFO4resok &lt;&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union SECINFO4res switch (nfsstat4 status) {
      case NFS4_OK:
              SECINFO4resok resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SECINFO operation is used by the client to obtain a list of valid RPC authentication flavors for a specific directory filehandle, file name pair. SECINFO should apply the same access methodology used for LOOKUP when evaluating the name. Therefore, if the requester does not have the appropriate access to LOOKUP the name then SECINFO must behave the same way and return NFS4ERR_ACCESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO操作は特定のディレクトリのファイルハンドル、ファイル名のペアのための有効なRPC認証フレーバのリストを取得するために、クライアントによって使用されます。名前を評価するときSECINFOは、LOOKUPのために使用したのと同じアクセス方法論を適用する必要があります。依頼者は、名前を検索するための適切なアクセス権を持っていない場合、したがって、SECINFO同じように動作し、NFS4ERR_ACCESSを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result will contain an array which represents the security mechanisms available, with an order corresponding to server&#39;s preferences, the most preferred being first in the array. The client is free to pick whatever security mechanism it both desires and supports, or to pick in the server&#39;s preference order the first one it supports. The array entries are represented by the secinfo4 structure. The field &#39;flavor&#39; will contain a value of AUTH_NONE, AUTH_SYS (as defined in [RFC1831]), or RPCSEC_GSS (as defined in [RFC2203]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果はサーバの好みに対応する順序で、セキュリティメカニズムが利用可能で表す配列を含有するであろう、最も最初の配列であることが好ましいです。クライアントは、どのようなセキュリティメカニズム、それの両方の欲望とサポートを選択するか、サーバーの優先順位、それがサポートする最初のものに選択する自由です。アレイエントリはsecinfo4構造によって表されます。フィールド &#39;風味&#39;（[RFC2203]で定義されるように）AUTH_NONE、AUTH_SYS（[RFC1831]で定義される）の値を含む、またはRPCSEC_GSSう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the flavors AUTH_NONE and AUTH_SYS, no additional security information is returned. For a return value of RPCSEC_GSS, a security triple is returned that contains the mechanism object id (as defined in [RFC2743]), the quality of protection (as defined in [RFC2743]) and the service type (as defined in [RFC2203]). It is possible for SECINFO to return multiple entries with flavor equal to RPCSEC_GSS with different security triple values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
味AUTH_NONEおよびAUTH_SYSの場合は、追加のセキュリティ情報が返されません。 RPCSEC_GSSの戻り値を、三重セキュリティは機構のオブジェクトID（[RFC2743]で定義されるように）、保護の品質（[RFC2743]で定義されるように）とサービスタイプを（[RFC2203]で定義されるように含まれる返されます）。 SECINFOが異なるセキュリティトリプル値のRPCSEC_GSSと等しい味で複数のエントリを返すことが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the name has a length of 0 (zero), or if name does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前がUTF-8定義に従わない場合、名前は0（ゼロ）の長さを持っている場合、または、エラーNFS4ERR_INVALが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SECINFO operation is expected to be used by the NFS client when the error value of NFS4ERR_WRONGSEC is returned from another NFS operation. This signifies to the client that the server&#39;s security policy is different from what the client is currently using. At this point, the client is expected to obtain a list of possible security flavors and choose what best suits its policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFO操作はNFS4ERR_WRONGSECのエラー値が別のNFS操作から返されたNFSクライアントによって使用されることが期待されます。これは、サーバーのセキュリティポリシーは、クライアントが現在使用しているものと異なっていることをクライアントに示します。この時点で、クライアントが可能なセキュリティ風味のリストを取得し、最高のは、そのポリシーに合ったものを選択することが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned, the server&#39;s security policies will determine when a client request receives NFS4ERR_WRONGSEC. The operations which may receive this error are: LINK, LOOKUP, OPEN, PUTFH, PUTPUBFH, PUTROOTFH, RESTOREFH, RENAME, and indirectly READDIR. LINK and RENAME will only receive this error if the security used for the operation is inappropriate for saved filehandle. With the exception of READDIR, these operations represent the point at which the client can instantiate a filehandle into the &#34;current filehandle&#34; at the server. The filehandle is either provided by the client (PUTFH, PUTPUBFH, PUTROOTFH) or generated as a result of a name to filehandle translation (LOOKUP and OPEN). RESTOREFH is different because the filehandle is a result of a previous SAVEFH. Even though the filehandle, for RESTOREFH, might have previously passed the server&#39;s inspection for a security match, the server will check it again on RESTOREFH to ensure that the security policy has not changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前述のように、クライアントの要求がNFS4ERR_WRONGSECを受信したときに、サーバーのセキュリティポリシーが決定されます。このエラーを受信することができる操作は、次のとおりLINK、LOOKUP、OPEN、PUTFH、PUTPUBFH、PUTROOTFH、RESTOREFH、RENAME、および間接的READDIR。操作のために使用されるセキュリティは、保存されたファイルハンドルに不適切な場合LINKとRENAMEのみ、このエラーが発生します。 READDIRを除いて、これらの操作は、クライアントがサーバーに「現在のファイルハンドル」にファイルハンドルをインスタンス化することができた時点を表します。ファイルハンドルは、いずれかのクライアント（PUTFH、PUTPUBFH、PUTROOTFH）によって提供されるか、またはファイルハンドル翻訳（LOOKUPとOPEN）に名前の結果として生成されます。ファイルハンドルが前SAVEFHの結果であるため、RESTOREFHが異なっています。ファイルハンドルは、RESTOREFHのために、以前にセキュリティの試合のために、サーバーの検査に合格した場合でも、サーバーは、セキュリティポリシーが変更されていないことを確認するためにRESTOREFHに再びそれをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client wants to resolve an error return of NFS4ERR_WRONGSEC, the following will occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはNFS4ERR_WRONGSECのエラーリターンを解決したい場合は、次のことが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For LOOKUP and OPEN, the client will use SECINFO with the same current filehandle and name as provided in the original LOOKUP or OPEN to enumerate the available security triples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
利用可能なセキュリティトリプルを列挙するために、元のLOOKUPまたはOPENで提供されるO LOOKUPとOPENの場合、クライアントは同じ電流ファイルハンドルと名前をSECINFOを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For LINK, PUTFH, RENAME, and RESTOREFH, the client will use SECINFO and provide the parent directory filehandle and object name which corresponds to the filehandle originally provided by the PUTFH RESTOREFH, or for LINK and RENAME, the SAVEFH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O LINKについて、PUTFHは、RENAME、およびRESTOREFHは、クライアントがSECINFOを使用し、親ディレクトリのファイルハンドルを提供し、またはLINKのために元々PUTFH RESTOREFHが提供するファイルハンドルに対応する名前をオブジェクトと、SAVEFHの名前を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For PUTROOTFH and PUTPUBFH, the client will be unable to use the SECINFO operation since SECINFO requires a current filehandle and none exist for these two operations. Therefore, the client must iterate through the security triples available at the client and reattempt the PUTROOTFH or PUTPUBFH operation. In the unfortunate event none of the MANDATORY security triples are supported by the client and server, the client SHOULD try using others that support integrity. Failing that, the client can try using AUTH_NONE, but because such forms lack integrity checks, this puts the client at risk. Nonetheless, the server SHOULD allow the client to use whatever security form the client requests and the server supports, since the risks of doing so are on the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFOは、現在のファイルハンドルを必要とし、どれもこれら二つの操作のために存在しないので、O PUTROOTFHとPUTPUBFHのために、クライアントはSECINFO操作を使用することができません。そのため、クライアントは、クライアントで利用可能なセキュリティトリプルを反復処理し、PUTROOTFHまたはPUTPUBFH操作を再試行しなければなりません。 MANDATORYセキュリティトリプルは、クライアントとサーバによってサポートされているの不幸な出来事なしでは、クライアントは、整合性をサポートする他の人を使用してみてください。それに失敗すると、クライアントはAUTH_NONEを使用して試すことができますが、このようなフォームは、整合性チェックがないため、これは危険でクライアントを置きます。それにもかかわらず、サーバーは、クライアントがそうすることのリスクは、クライアント上にあることから、クライアントの要求とサーバのサポートを形成するものは何でもセキュリティを使用できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The READDIR operation will not directly return the NFS4ERR_WRONGSEC error. However, if the READDIR request included a request for attributes, it is possible that the READDIR request&#39;s security triple does not match that of a directory entry. If this is the case and the client has requested the rdattr_error attribute, the server will return the NFS4ERR_WRONGSEC error in rdattr_error for the entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
READDIR操作は直接NFS4ERR_WRONGSECエラーを返しません。 READDIR要求が属性を要求が含まれている場合しかし、READDIR要求のセキュリティはトリプルディレクトリエントリと一致しないことも可能です。このような場合は、クライアントがrdattr_error属性を要求した場合、サーバはエントリのrdattr_errorにNFS4ERR_WRONGSECエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See the section &#34;Security Considerations&#34; for a discussion on the recommendations for security flavor used by SECINFO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SECINFOで使用されるセキュリティ風味のための勧告に関する議論については、「セキュリティの考慮事項」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADNAME NFS4ERR_BADXDR NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NAMETOOLONG NFS4ERR_NOENT NFS4ERR_NOFILEHANDLE NFS4ERR_NOTDIR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.32. Operation 34: SETATTR - Set Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.32。操作34：SETATTR  - 属性セット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, attrmask, attr_vals -&gt; attrsset
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、のstateid、attrmask、attr_vals  - &gt; attrsset
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETATTR4args {
             /* CURRENT_FH: target object */
             stateid4        stateid;
             fattr4          obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETATTR4res {
             nfsstat4        status;
             bitmap4         attrsset;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SETATTR operation changes one or more of the attributes of a filesystem object. The new attributes are specified with a bitmap and the attributes that follow the bitmap in bit order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR操作は、ファイルシステムオブジェクトの属性の一つ以上を変更します。新しい属性は、ビットマップとビット順にビットマップに従った属性で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid argument for SETATTR is used to provide file locking context that is necessary for SETATTR requests that set the size attribute. Since setting the size attribute modifies the file&#39;s data, it has the same locking requirements as a corresponding WRITE. Any SETATTR that sets the size attribute is incompatible with a share reservation that specifies DENY_WRITE. The area between the old end-of-file and the new end-of-file is considered to be modified just as would have been the case had the area in question been specified as the target of WRITE, for the purpose of checking conflicts with record locks, for those cases in which a server is implementing mandatory record locking behavior. A valid stateid should always be specified. When the file size attribute is not set, the special stateid consisting of all bits zero should be passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRのためのstateid引数は、サイズ属性を設定するSETATTR要求するために必要なファイルロックのコンテキストを提供するために使用されます。サイズ属性を設定すると、ファイルのデータを変更するので、それは、対応するWRITEと同じロッキング要件があります。サイズ属性を設定し、任意のSETATTRはDENY_WRITEを指定シェア予約と互換性がありません。問題の領域はWRITEの対象として指定されていた場合であったであろうと、古いファイルの終わりと新しいファイルの終端との間の領域は、との衝突をチェックする目的のために、単に変更されていると考えられますサーバーは必須レコードロック動作を実装しているような場合のためにレコードロック、。有効なstateidは必ず指定する必要があります。ファイルサイズ属性が設定されていない場合は、すべてのビットがゼロから成る特別なstateidを渡す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On either success or failure of the operation, the server will return the attrsset bitmask to represent what (if any) attributes were successfully set. The attrsset in the response is a subset of the bitmap4 that is part of the obj_attributes in the argument.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性正常に設定された（もしあれば）は、操作の成功または失敗のいずれかで、サーバが何を表現するためにattrssetビットマスクを返します。応答attrssetは、引数でobj_属性の一部であるbitmap4のサブセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request specifies the owner attribute to be set, the server should allow the operation to succeed if the current owner of the object matches the value specified in the request. Some servers may be implemented in a way as to prohibit the setting of the owner attribute unless the requester has privilege to do so. If the server is lenient in this one case of matching owner values, the client implementation may be simplified in cases of creation of an object followed by a SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求を設定する所有者属性を指定している場合、サーバーはオブジェクトの現在の所有者がリクエストで指定された値と一致した場合、操作が成功できるようにする必要があります。一部のサーバーは、要求者がそうする権限を持っていない限り、所有者属性の設定を禁止するような方法で実現することができます。サーバが一致する所有者値のこの一つの場合に寛大である場合、クライアントの実装はSETATTR続いてオブジェクトの作成の場合に簡素化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file size attribute is used to request changes to the size of a file. A value of 0 (zero) causes the file to be truncated, a value less than the current size of the file causes data from new size to the end of the file to be discarded, and a size greater than the current size of the file causes logically zeroed data bytes to be added to the end of the file. Servers are free to implement this using holes or actual zero data bytes. Clients should not make any assumptions regarding a server&#39;s implementation of this feature, beyond that the bytes returned will be zeroed. Servers must support extending the file size via SETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルサイズ属性は、ファイルのサイズの変更を要求するのに使用されます。 0（ゼロ）の値は、ファイルがファイルの現在のサイズより小さい値を廃棄するファイルの末尾に新たなサイズのデータ​​を生じ、切り捨て、およびさせるファイルの現在のサイズよりも大きいサイズ論理的にファイルの末尾に追加されるデータのバイト数をゼロになります。サーバはこの使用して穴や実際のゼロデータのバイト数を自由に実装できます。クライアントは、返されたバイトがゼロにされることを超えて、この機能のサーバの実装に関するいかなる仮定を行うべきではありません。サーバはSETATTRを経由してファイルサイズを拡張サポートしている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTR is not guaranteed atomic. A failed SETATTR may partially change a file&#39;s attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRは原子保証されません。失敗したSETATTRは、部分的にファイルの属性を変更することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changing the size of a file with SETATTR indirectly changes the time_modify. A client must account for this as size changes can result in data deletion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETATTRとファイルのサイズを変更すると、間接的にtime_modifyを変更します。サイズの変更は、データの削除につながることができますように、クライアントは、このことを考慮しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes time_access_set and time_modify_set are write-only attributes constructed as a switched union so the client can direct the server in setting the time values. If the switched union specifies SET_TO_CLIENT_TIME4, the client has provided an nfstime4 to be used for the operation. If the switch union does not specify SET_TO_CLIENT_TIME4, the server is to use its current time for the SETATTR operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性time_access_setとtime_modify_setは、クライアントが時間値を設定することで、サーバーに指示することができるように切り替え組合として構成書き込み専用属性です。切り替え組合がSET_TO_CLIENT_TIME4を指定した場合、クライアントは、操作に使用するnfstime4を提供してきました。スイッチ組合がSET_TO_CLIENT_TIME4を指定しない場合、サーバはSETATTR操作のために、現在の時刻を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If server and client times differ, programs that compare client time to file times can break. A time maintenance protocol should be used to limit client/server time skew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーとクライアントの時間が異なる場合は、時間をファイルにクライアントの時間を比較するプログラムが壊れることができます。タイムメンテナンスプロトコルは、クライアント/サーバ時間スキューを制限するために使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of a COMPOUND containing a VERIFY operation specifying only the change attribute, immediately followed by a SETATTR, provides a means whereby a client may specify a request that emulates the functionality of the SETATTR guard mechanism of NFS version 3. Since the function of the guard mechanism is to avoid changes to the file attributes based on stale information, delays between checking of the guard condition and the setting of the attributes have the potential to compromise this function, as would the corresponding delay in the NFS version 4 emulation. Therefore, NFS version 4 servers should take care to avoid such delays, to the degree possible, when executing such a request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
直ちにSETATTR続いのみ変更属性を指定するベリファイ動作を含む化合物の使用、クライアントは、ガードの機能ので、NFSバージョン3のSETATTRガード機構の機能をエミュレート要求を指定してもよいができる手段を提供しますメカニズムは古い情報に基づいてファイル属性の変更を避けるためであるNFSバージョン4エミュレーションで対応する遅延と同じように、ガード条件の確認と属性の設定間の遅延は、この機能を損なう可能性を秘めています。そのため、NFSバージョン4サーバは、要求を実行する際に、可能な程度まで、このような遅延を避けるために注意を払う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server does not support an attribute as requested by the client, the server should return NFS4ERR_ATTRNOTSUPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントによって要求されるように、サーバが属性をサポートしていない場合、サーバーはNFS4ERR_ATTRNOTSUPPを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A mask of the attributes actually set is returned by SETATTR in all cases. That mask must not include attributes bits not requested to be set by the client, and must be equal to the mask of attributes requested to be set only if the SETATTR completes without error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際に設定された属性のマスクは、すべての場合にSETATTRによって返されます。そのマスクは、属性ビットクライアントによって設定することが要求され、SETATTRがエラーなしで完了した場合にのみ設定することが要求された属性のマスクと等しくなければならないを含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADOWNER NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_PERM NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADOWNER NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXPIRED NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_PERM NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.33. Operation 35: SETCLIENTID - Negotiate Clientid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.33。操作35：SETCLIENTID  -  CLIENTIDネゴシエート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
client, callback, callback_ident -&gt; clientid, setclientid_confirm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
クライアント、コールバック、callback_ident  - &gt;のClientID、SETCLIENTID_CONFIRM
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETCLIENTID4args {
             nfs_client_id4  client;
             cb_client4      callback;
             uint32_t        callback_ident;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETCLIENTID4resok {
             clientid4       clientid;
             verifier4       setclientid_confirm;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union SETCLIENTID4res switch (nfsstat4 status) {
      case NFS4_OK:
              SETCLIENTID4resok      resok4;
      case NFS4ERR_CLID_INUSE:
              clientaddr4    client_using;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client uses the SETCLIENTID operation to notify the server of its intention to use a particular client identifier, callback, and callback_ident for subsequent requests that entail creating lock, share reservation, and delegation state on the server. Upon successful completion the server will return a shorthand clientid which, if confirmed via a separate step, will be used in subsequent file locking and file open requests. Confirmation of the clientid must be done via the SETCLIENTID_CONFIRM operation to return the clientid and setclientid_confirm values, as verifiers, to the server. The reason why two verifiers are necessary is that it is possible to use SETCLIENTID and SETCLIENTID_CONFIRM to modify the callback and callback_ident information but not the shorthand clientid. In that event, the setclientid_confirm value is effectively the only verifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバー上のロック、共有予約、および委任状態を作り出す伴う後続の要求のために、特定のクライアント識別子、コールバック、およびcallback_identを使用する意向をサーバに通知するためにSETCLIENTID操作を使用しています。正常に完了すると、サーバーは、別の工程を経て確認した場合、その後のファイルのロックに使用し、オープン要求を提出します速記のClientIDを返します。 ClientIDの確認は、サーバーに、検証として、そのclientidとSETCLIENTID_CONFIRM値を返すためにSETCLIENTID_CONFIRM操作を介して行われなければなりません。 2つの検証が必要な理由は、コールバックとcallback_ident情報ではなく、速記のClientIDを変更するSETCLIENTIDとSETCLIENTID_CONFIRMを使用することが可能であるということです。その場合には、SETCLIENTID_CONFIRM値は事実のみ検証です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback information provided in this operation will be used if the client is provided an open delegation at a future point. Therefore, the client must correctly reflect the program and port numbers for the callback program at the time SETCLIENTID is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、将来の時点で開いている委譲を提供する場合は、この操作で提供されるコールバック情報が使用されます。したがって、クライアントが正しくSETCLIENTIDが使用されている時にコールバックプログラムのためのプログラムとポート番号を反映しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The callback_ident value is used by the server on the callback. The client can leverage the callback_ident to eliminate the need for more than one callback RPC program number, while still being able to determine which server is initiating the callback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
callback_ident値はコールバック上のサーバーで使用されています。クライアントはコールバックを開始しているサーバーを決定することが可能でありながら、複数のコールバックRPCプログラム番号の必要性を排除するためにcallback_identを活用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To understand how to implement SETCLIENTID, make the following notations. Let:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDを実装する方法を理解するには、次の表記を作ります。してみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
x be the value of the client.id subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X SETCLIENTID4args構造のclient.idサブフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
v be the value of the client.verifier subfield of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
V SETCLIENTID4args構造のclient.verifierサブフィールドの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c be the value of the clientid field returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ClientIDフィールドの値はSETCLIENTID4resok構造に返されるcは。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
k represent the value combination of the fields callback and callback_ident fields of the SETCLIENTID4args structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックとcallback_identフィールドSETCLIENTID4args構造体のフィールドの値の組み合わせを表すKです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
s be the setclientid_confirm value returned in the SETCLIENTID4resok structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S SETCLIENTID4resok構造体に返さSETCLIENTID_CONFIRM値で。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ v, x, c, k, s } be a quintuple for a client record. A client record is confirmed if there has been a SETCLIENTID_CONFIRM operation to confirm it. Otherwise it is unconfirmed. An unconfirmed record is established by a SETCLIENTID call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{V、X、C、K、S}は、クライアントレコードの五重です。それを確認するSETCLIENTID_CONFIRM操作があった場合、クライアントのレコードが確認されました。それ以外の場合は未確認です。未確認のレコードがSETCLIENTID呼び出しによって確立されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since SETCLIENTID is a non-idempotent operation, let us assume that the server is implementing the duplicate request cache (DRC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDが非冪等操作ですので、私たちは、サーバが重複要求キャッシュ（DRC）を実施していると仮定しましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server gets a SETCLIENTID { v, x, k } request, it processes it in the following manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはSETCLIENTID {V、X、K}の要求を受け取ると、それは次のようにそれを処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It first looks up the request in the DRC. If there is a hit, it returns the result cached in the DRC. The server does NOT remove client state (locks, shares, delegations) nor does it modify any recorded callback and callback_ident information for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは最初のDRCで要求を検索します。ヒットがあれば、それはDRCにキャッシュされた結果を返します。サーバーは、クライアントの状態（ロック、株式、代表団を）削除しておらず、クライアント{X}のための任意の記録コールバックとcallback_ident情報を変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For any DRC miss, the server takes the client id string x, and searches for client records for x that the server may have recorded from previous SETCLIENTID calls. For any confirmed record with the same id string x, if the recorded principal does not match that of SETCLIENTID call, then the server returns a NFS4ERR_CLID_INUSE error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
いずれのDRCミスの場合、サーバーはクライアントIDの文字列xを取り、サーバーが以前のSETCLIENTID呼び出しから記録されている可能性がxのクライアントレコードを検索。同じid列Xと任意の確認記録のために、記録されたプリンシパルがSETCLIENTID呼び出しと一致しない場合、サーバーはNFS4ERR_CLID_INUSEエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
For brevity of discussion, the remaining description of the processing assumes that there was a DRC miss, and that where the server has previously recorded a confirmed record for client x, the aforementioned principal check has successfully passed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
議論を簡単にするために、処理の残りの説明はDRCミスがあったこと、およびサーバーが以前のクライアントxの確認記録を記録したところ、前述の主なチェックに合格していることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server checks if it has recorded a confirmed record for { v, x, c, l, s }, where l may or may not equal k. If so, and since the id verifier v of the request matches that which is confirmed and recorded, the server treats this as a probable callback information update and records an unconfirmed { v, x, c, k, t } and leaves the confirmed { v, x, c, l, s } in place, such that t != s. It does not matter if k equals l or not. Any pre-existing unconfirmed { v, x, c, *, * } is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバチェックoをそれが{V、X、C、L、S}、Lよいかよい等しいkに対する確認レコードが記録されている場合。もしそうであれば、リクエストのID検証vが確認され、記録されるものと一致しているので、サーバの可能性のコールバック情報の更新として扱いこれとは未確認{V、X、C、K、T}を記録し、確認した葉{代わりにV、X、C、L、S}、例えば、T！= sです。 kはLと等しいかどうかは関係ありません。任意の既存の未確認{V、X、C、*、*}が除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { c, t }. It is indeed returning the old clientid4 value c, because the client apparently only wants to update callback value k to value l. It&#39;s possible this request is one from the Byzantine router that has stale callback information, but this is not a problem. The callback information update is only confirmed if followed up by a SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバ復帰{C、T}。クライアントが明らかにのみ値lにコールバック値kを更新したいので、それは確かに、古いclientid4値cを返しています。これは、この要求が古いコールバック情報を持っているビザンチンルータから1であることは可能ですが、これは問題ではありません。 SETCLIENTID_CONFIRM {C、T}によって追跡場合、コールバック情報の更新のみが確認されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of k via SETCLIENTID_CONFIRM { c, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバはSETCLIENTID_CONFIRM {C、T}介しkの確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and has not recorded any unconfirmed { *, x, *, *, * } record for x. The server records an unconfirmed { v, x, d, k, t } (d != c, t != s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが以前にそのようなV！= U、Lよいかよい等しいKことが確認{U、X、C、L、S}レコードを記録しており、*、*、任意未確認{*、Xを記録していない、O *} xについて記録します。サーバは、未確認{V、X、D、K、T}（D！= C、T！= S）を記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバ復帰{D、T}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバはSETCLIENTID_CONFIRM {D、T}介し{D、K}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has previously recorded a confirmed { u, x, c, l, s } record such that v != u, l may or may not equal k, and recorded an unconfirmed { w, x, d, m, t } record such that c != d, t != s, m may or may not equal k, m may or may not equal l, and k may or may not equal l. Whether w == v or w != v makes no difference. The server simply removes the unconfirmed { w, x, d, m, t } record and replaces it with an unconfirmed { v, x, e, k, r } record, such that e != d, e != c, r != t, r != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは、以前に、U、Lかもしれまたはかもしれない等しいK =！Vように確認{U、X、C、L、S}レコードを記録し、未確認{W、X、D、M、T}を記録していますレコード例えばC！= D、T！= sで、Mかもしれまたはかもしれない等しいK、MまたはLよい等しくなくてもよく、Kよいかよい等しいLています。 == Vまたはwのかどうか！= vが違いはありません。サーバは単にように、E！= D、E！= Cを、R、未確認{W、X、D、M、T}レコードを削除し、未確認{V、X、E、K、R}レコードに置き換え！= T、R！= sで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバ復帰{E、R}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { e, k } via SETCLIENTID_CONFIRM { e, r }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバはSETCLIENTID_CONFIRM {E、R}介し{E、K}の確認を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has no confirmed { *, x, *, *, * } for x. It may or may not have recorded an unconfirmed { u, x, c, l, s }, where l may or may not equal k, and u may or may not equal v. Any unconfirmed record { u, x, c, l, * }, regardless whether u == v or l == k, is replaced with an unconfirmed record { v, x, d, k, t } where d != c, t != s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは全く認識していxに対して{*、*、*、*、xはありません}。これはまたは、ここで、Lよいかよい等しいKおよびUよいかよい等しいVを未確認{U、X、C、L、S}を記録しなくてもよい。任意の未確認のレコード{U、X、C、Lを、*}にかかわらず、UはVまたはL == kは==かどうか、未確認のレコード{V、X、D、K、T} D！= C、T！= Sに置換されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns { d, t }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバ復帰{D、T}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM { d, t }. The server does NOT remove client (lock/share/delegation) state for x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバはSETCLIENTIDが確認介し{D、K}、へ}の確認を待ちます。サーバーは、xのために、クライアント（ロック/株/委任）状態は削除されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server generates the clientid and setclientid_confirm values and must take care to ensure that these values are extremely unlikely to ever be regenerated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはclientidにとSETCLIENTID_CONFIRM値を生成し、これらの値は、これまでに再生することが極めてそうにないように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_INVAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_INVAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.34. Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.34。操作36：SETCLIENTID_CONFIRM  -  CLIENTIDを確認
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
clientid, verifier -&gt; -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ClientIDを、検証 - &gt;  - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETCLIENTID_CONFIRM4args {
             clientid4       clientid;
             verifier4       setclientid_confirm;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct SETCLIENTID_CONFIRM4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used by the client to confirm the results from a previous call to SETCLIENTID. The client provides the server supplied (from a SETCLIENTID response) clientid. The server responds with a simple status of success or failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、SETCLIENTIDへの以前の呼び出しからの結果を確認するために、クライアントによって使用されます。クライアントは、のclientid（SETCLIENTID応答から）供給サーバを提供します。サーバーは、成功か失敗かの簡単な状況で応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client must use the SETCLIENTID_CONFIRM operation to confirm the following two distinct cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、次の2つの異なる例を確認するためにSETCLIENTID_CONFIRM操作を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s use of a new shorthand client identifier (as returned from the server in the response to SETCLIENTID), a new callback value (as specified in the arguments to SETCLIENTID) and a new callback_ident (as specified in the arguments to SETCLIENTID) value. The client&#39;s use of SETCLIENTID_CONFIRM in this case also confirms the removal of any of the client&#39;s previous relevant leased state. Relevant leased client state includes record locks, share reservations, and where the server does not support the CLAIM_DELEGATE_PREV claim type, delegations. If the server supports CLAIM_DELEGATE_PREV, then SETCLIENTID_CONFIRM MUST NOT remove delegations for this client; relevant leased client state would then just include record locks and share reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい速記クライアント識別子のクライアントの使用O（SETCLIENTIDに応じてサーバから返される）、新しいコールバック値（SETCLIENTIDへの引数に指定されている）と、新たなcallback_ident（SETCLIENTIDへの引数に指定されている）値。この場合SETCLIENTID_CONFIRMのクライアントの使用はまた、クライアントの以前の関連するリースの状態のいずれかを除去することを確認します。関連リースクライアントの状態は、レコードロック、共有の予約が含まれており、どこのサーバは、委任をCLAIM_DELEGATE_PREV請求タイプをサポートしていません。サーバがCLAIM_DELEGATE_PREVをサポートしている場合は、SETCLIENTID_CONFIRMは、このクライアントのために代表団を削除してはなりません。関連するリースクライアントの状態は、単にレコードロックと共有の予約が含まれるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client&#39;s re-use of an old, previously confirmed, shorthand client identifier, a new callback value, and a new callback_ident value. The client&#39;s use of SETCLIENTID_CONFIRM in this case MUST NOT result in the removal of any previous leased state (locks, share reservations, and delegations)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
古い、以前に確認され、速記クライアント識別子、新しいコールバック値、および新しいcallback_ident値のクライアントの再利用、O。この場合SETCLIENTID_CONFIRMのクライアントの使用は、以前のリースの状態（ロック、シェアの予約、および代表団）の除去につながるならない（MUST NOT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We use the same notation and definitions for v, x, c, k, s, and unconfirmed and confirmed client records as introduced in the description of the SETCLIENTID operation. The arguments to SETCLIENTID_CONFIRM are indicated by the notation { c, s }, where c is a value of type clientid4, and s is a value of type verifier4 corresponding to the setclientid_confirm field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、V、X、C、K、S、および未確認のために同じ表記法および定義を使用し、SETCLIENTID操作の説明に導入されるようクライアントレコードを確認しました。 SETCLIENTID_CONFIRMへの引数は、Cは、タイプclientid4の値であり、sはSETCLIENTID_CONFIRMフィールドに対応するverifier4タイプの値で表記{C、S}で示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with SETCLIENTID, SETCLIENTID_CONFIRM is a non-idempotent operation, and we assume that the server is implementing the duplicate request cache (DRC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTIDと同じように、SETCLIENTID_CONFIRMは非冪等操作であり、私たちは、サーバが重複要求キャッシュ（DRC）を実装していることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the server gets a SETCLIENTID_CONFIRM { c, s } request, it processes it in the following manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはSETCLIENTID_CONFIRM {C、S}要求を受け取ると、それは次のようにそれを処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It first looks up the request in the DRC. If there is a hit, it returns the result cached in the DRC. The server does not remove any relevant leased client state nor does it modify any recorded callback and callback_ident information for client { x } as represented by the shorthand value c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは最初のDRCで要求を検索します。ヒットがあれば、それはDRCにキャッシュされた結果を返します。サーバは、任意の関連する専用クライアントの状態を削除しておらず、{X}速記値cによって表されるように、クライアントのために任意の記録されたコールバックとcallback_ident情報を変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a DRC miss, the server checks for client records that match the shorthand value c. The processing cases are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DRCミス、速記値cに一致するクライアントレコードのためのサーバーをチェックしてください。次のように処理例は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has recorded an unconfirmed { v, x, c, k, s } record and a confirmed { v, x, c, l, t } record, such that s != t. If the principals of the records do not match that of the SETCLIENTID_CONFIRM, the server returns NFS4ERR_CLID_INUSE, and no relevant leased client state is removed and no recorded callback and callback_ident information for client { x } is changed. Otherwise, the confirmed { v, x, c, l, t } record is removed and the unconfirmed { v, x, c, k, s } is marked as confirmed, thereby modifying recorded and confirmed callback and callback_ident information for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは未確認{V、X、C、K、S}レコードと確認{V、X、C、L、T}レコード、ようだ！= Tが記録されています。レコードのプリンシパルがSETCLIENTID_CONFIRMのものと一致しない場合、サーバはNFS4ERR_CLID_INUSEを返し、該当専用クライアント状態が除去されず、クライアント{X}のための記録のコールバックとcallback_ident情報が変更されません。そうでなければ、確認{V、X、C、L、T}レコードが除去され、それによって記録修正、確認されるように未確認{V、X、C、K、S}はマークされ、クライアント{Xのコールバックとcallback_ident情報を確認しました}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server does not remove any relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバは、関連するすべてのリースクライアントの状態を削除しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has not recorded an unconfirmed { v, x, c, *, * } and has recorded a confirmed { v, x, c, *, s }. If the principals of the record and of SETCLIENTID_CONFIRM do not match, the server returns NFS4ERR_CLID_INUSE without removing any relevant leased client state and without changing recorded callback and callback_ident values for client { x }.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは、{*、*、V、X、C}未確認を記録していないと確認{V、X、C、*、S}を記録しました。レコードのとSETCLIENTID_CONFIRMのプリンシパルが一致しない場合、サーバは、任意の関連する専用のクライアント状態を除去することなく、クライアント{X}について記録のコールバックとcallback_ident値を変更せずNFS4ERR_CLID_INUSEを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the principals match, then what has likely happened is that the client never got the response from the SETCLIENTID_CONFIRM, and the DRC entry has been purged. Whatever the scenario, since the principals match, as well as { c, s } matching a confirmed record, the server leaves client x&#39;s relevant leased client state intact, leaves its callback and callback_ident values unmodified, and returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プリンシパルが一致する場合、どのような可能性が起こったことは、クライアントがSETCLIENTID_CONFIRMからの応答をやったことがなかった、とDRCエントリが削除されたことです。どのようなシナリオでは、プリンシパルが一致するので、同様に確認されたレコードに一致{C、S}、サーバは、未修飾のコールバックとcallback_ident値を残し、無傷のクライアントXの関連する専用クライアントの状態を離れ、そしてNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has not recorded a confirmed { *, *, c, *, * }, and has recorded an unconfirmed { *, x, c, k, s }. Even if this is a retry from client, nonetheless the client&#39;s first SETCLIENTID_CONFIRM attempt was not received by the server. Retry or not, the server doesn&#39;t know, but it processes it as if were a first try. If the principal of the unconfirmed { *, x, c, k, s } record mismatches that of the SETCLIENTID_CONFIRM request the server returns NFS4ERR_CLID_INUSE without removing any relevant leased client state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは、{*、*、*、*、C}確認を記録していない、及び未確認{*、X、C、K、S}を記録しました。これは、クライアントからのリトライであっても、それにもかかわらず、クライアントの最初のSETCLIENTID_CONFIRMの試みは、サーバーによって受信されませんでした。再試行するかどうか、サーバーは知りませんが、最初の試みであるかのようにそれを処理します。もしSETCLIENTID_CONFIRM要求サーバは、任意の関連する専用のクライアント状態を除去することなくNFS4ERR_CLID_INUSEを返すこと未確認{*、X、C、K、S}レコード不一致の主要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Otherwise, the server records a confirmed { *, x, c, k, s }. If there is also a confirmed { *, x, d, *, t }, the server MUST remove the client x&#39;s relevant leased client state, and overwrite the callback state with k. The confirmed record { *, x, d, *, t } is removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
そうでない場合、サーバは、確認{*、X、C、K、S}を記録します。また、確認した{*、X、D、*、T}が存在する場合、サーバはクライアントXの関連リースクライアントの状態を削除し、そしてkとコールバック状態を上書きする必要があります。確認レコード{*、X、D、*、T}が除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Server returns NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーはNFS4_OKを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The server has no record of a confirmed or unconfirmed { *, *, c, *, s }. The server returns NFS4ERR_STALE_CLIENTID. The server does not remove any relevant leased client state, nor does it modify any recorded callback and callback_ident information for any client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oサーバは、確認または未確認{*、*、C *、S}のレコードがありません。サーバーはNFS4ERR_STALE_CLIENTIDを返します。サーバは、関連するすべてのリースクライアントの状態を削除しません。また、任意のクライアントのための任意の記録コールバックとcallback_ident情報を変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server needs to cache unconfirmed { v, x, c, k, s } client records and await for some time their confirmation. As should be clear from the record processing discussions for SETCLIENTID and SETCLIENTID_CONFIRM, there are cases where the server does not deterministically remove unconfirmed client records. To avoid running out of resources, the server is not required to hold unconfirmed records indefinitely. One strategy the server might use is to set a limit on how many unconfirmed client records it will maintain, and then when the limit would be exceeded, remove the oldest record. Another strategy might be to remove an unconfirmed record when some amount of time has elapsed. The choice of the amount of time is fairly arbitrary but it is surely no higher than the server&#39;s lease time period. Consider that leases need to be renewed before the lease time expires via an operation from the client. If the client cannot issue a SETCLIENTID_CONFIRM after a SETCLIENTID before a period of time equal to that of a lease expires, then the client is unlikely to be able maintain state on the server during steady state operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは未確認{V、X、C、K、S}クライアントレコードをキャッシュし、しばらくの間その確認のために待機する必要があります。 SETCLIENTIDとSETCLIENTID_CONFIRMの記録処理の議論から明らかであるように、サーバは、決定論未確認のクライアントレコードを削除しない場合があります。リソースの不足を回避するために、サーバーは無期限に未確認のレコードを保持するために必要とされていません。サーバが使用する可能性の1つの戦略は、それが維持されますどのように多くの未確認のクライアントレコードに制限を設定し、上限を超えてしまうときに、最も古いレコードを削除することです。別の戦略は、ある程度の時間が経過したときに未確認のレコードを削除するかもしれません。時間の量の選択はかなり任意であるが、それは確かに、サーバーのリース期間よりも高くありません。リースは、リース時間は、クライアントからの操作を経て有効期限が切れる前に更新する必要があることを考えてみましょう。クライアントはリース期限が切れると同等の一定期間前にSETCLIENTID後SETCLIENTID_CONFIRMを発行することができない場合、クライアントは、定常状態動作中にサーバー上の状態を維持できることはほとんどありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client does send a SETCLIENTID_CONFIRM for an unconfirmed record that the server has already deleted, the client will get NFS4ERR_STALE_CLIENTID back. If so, the client should then start over, and send SETCLIENTID to reestablish an unconfirmed client record and get back an unconfirmed clientid and setclientid_confirm verifier. The client should then send the SETCLIENTID_CONFIRM to confirm the clientid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、サーバーが既に削除されたことを未確認のレコードのSETCLIENTID_CONFIRMを送信した場合、クライアントはバックNFS4ERR_STALE_CLIENTIDを取得します。もしそうなら、次にクライアントは、最初からやり直し、および未確認のクライアントレコードを再確立し、未確認のClientIDとSETCLIENTID_CONFIRM検証を取り戻すためにSETCLIENTIDを送信する必要があります。クライアントはその後のclientidを確認するためにSETCLIENTID_CONFIRMを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID_CONFIRM does not establish or renew a lease. However, if SETCLIENTID_CONFIRM removes relevant leased client state, and that state does not include existing delegations, the server MUST allow the client a period of time no less than the value of lease_time attribute, to reclaim, (via the CLAIM_DELEGATE_PREV claim type of the OPEN operation) its delegations before removing unreclaimed delegations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID_CONFIRM確立またはリースを更新しません。 SETCLIENTID_CONFIRMは、関連するリースクライアントの状態を削除し、その状態は、既存の委任が含まれていない場合は、サーバーはクライアントにlease_time属性の値を下回らない時間、OPENのCLAIM_DELEGATE_PREV請求タイプを経由して（、再利用するの期間を許容しなければなりません操作）unreclaimed委任を削除する前に、その代表団。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADXDR NFS4ERR_CLID_INUSE NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.35. Operation 37: VERIFY - Verify Same Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.35。操作37：VERIFY  - 同じ属性を確認してください
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), fattr -&gt; -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、fattr  - &gt;  - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct VERIFY4args {
             /* CURRENT_FH: object */
             fattr4          obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct VERIFY4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The VERIFY operation is used to verify that attributes have a value assumed by the client before proceeding with following operations in the compound request. If any of the attributes do not match then the error NFS4ERR_NOT_SAME must be returned. The current filehandle retains its value after successful completion of the operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイ動作は、属性が複合要求に次の操作に進む前に、クライアントが想定値を有することを確認するために使用されます。属性のいずれかが一致しない場合は、エラーNFS4ERR_NOT_SAMEを返さなければなりません。現在のファイルハンドルは、操作が正常に完了した後にその値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible use of the VERIFY operation is the following compound sequence. With this the client is attempting to verify that the file being removed will match what the client expects to be removed. This sequence can help prevent the unintended deletion of a file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベリファイ動作の一つの可能​​な用途は、以下の化合物配列です。これにより、クライアントは削除されたファイルは、クライアントが削除されることを想定しているものと一致することを検証しようとしています。このシーケンスは、ファイルの意図しない削除を防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         PUTFH (directory filehandle)
         LOOKUP (file name)
         VERIFY (filehandle == fh)
         PUTFH (directory filehandle)
         REMOVE (file name)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This sequence does not prevent a second client from removing and creating a new file in the middle of this sequence but it does help avoid the unintended result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このシーケンスは、このシーケンスの途中で新しいファイルを削除し、作成から2番目のクライアントを防ぐことはできませんが、それは予期しない結果を回避するのに役立つん。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that a recommended attribute is specified in the VERIFY operation and the server does not support that attribute for the filesystem object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
推奨属性がVERIFY操作で指定され、サーバがファイルシステムオブジェクトのその属性をサポートしていない場合は、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the attribute rdattr_error or any write-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性rdattr_errorまたは任意の書き込み専用の属性（例えば、time_modify_set）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOT_SAME NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ATTRNOTSUPP NFS4ERR_BADCHAR NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOT_SAME NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.36. Operation 38: WRITE - Write to File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.36。操作38：WRITE  - ファイルに書き込みます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(cfh), stateid, offset, stable, data -&gt; count, committed, writeverf
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（CFH）、のstateid、オフセット、安定した、データ - &gt;数、コミット、writeverf
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
enum stable_how4 { UNSTABLE4 = 0, DATA_SYNC4 = 1, FILE_SYNC4 = 2 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
列挙stable_how4 {UNSTABLE4 = 0、DATA_SYNC4 = 1、FILE_SYNC4 = 2}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct WRITE4args {
             /* CURRENT_FH: file */
             stateid4        stateid;
             offset4         offset; stable_how4     stable;
             opaque          data&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct WRITE4resok {
             count4          count;
             stable_how4     committed;
             verifier4       writeverf;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union WRITE4res switch (nfsstat4 status) {
      case NFS4_OK:
              WRITE4resok    resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The WRITE operation is used to write data to a regular file. The target file is specified by the current filehandle. The offset specifies the offset where the data should be written. An offset of 0 (zero) specifies that the write should start at the beginning of the file. The count, as encoded as part of the opaque data parameter, represents the number of bytes of data that are to be written. If the count is 0 (zero), the WRITE will succeed and return a count of 0 (zero) subject to permissions checking. The server may choose to write fewer bytes than requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE操作は、通常のファイルにデータを書き込むために使用されます。対象のファイルは、現在のファイルハンドルで指定されています。オフセットは、データが書き込まれるべき場所オフセットを指定します。 0（ゼロ）のオフセットを書き込み、ファイルの先頭から開始することを指定します。カウントは、不透明なデータパラメータの一部として符号化として、書き込まれるデータのバイト数を表します。カウントが0（ゼロ）の場合、WRITEは成功し、チェック権限に0（ゼロ）は、被験者の数を返します。サーバは、クライアントから要求されたよりも少ないバイトを書くことを選んでもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Part of the write request is a specification of how the write is to be performed. The client specifies with the stable parameter the method of how the data is to be processed by the server. If stable is FILE_SYNC4, the server must commit the data written plus all filesystem metadata to stable storage before returning results. This corresponds to the NFS version 2 protocol semantics. Any other behavior constitutes a protocol violation. If stable is DATA_SYNC4, then the server must commit all of the data to stable storage and enough of the metadata to retrieve the data before returning. The server implementor is free to implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a possible performance drop. If stable is UNSTABLE4, the server is free to commit any part of the data and the metadata to stable storage, including all or none, before returning a reply to the client. There is no guarantee whether or when any uncommitted data will subsequently be committed to stable storage. The only guarantees made by the server are that it will not destroy any data without changing the value of verf and that it will not commit the data and metadata at a level less than that requested by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
書き込み要求の一部は、書き込みが行われるべきかの仕様です。クライアントは、安定したパラメータを使用してデータがサーバによって処理されるかの方法を指定します。安定がFILE_SYNC4であれば、サーバは結果を返す前に、安定したストレージに書き込まれたデータに加えて、すべてのファイルシステムのメタデータをコミットする必要があります。これは、NFSバージョン2プロトコルのセマンティクスに対応しています。その他の動作は、プロトコル違反を構成しています。安定がDATA_SYNC4ある場合、サーバーは安定して保管し、返す前にデータを取得するメタデータの十分にすべてのデータをコミットする必要があります。サーバ実装者はFILE_SYNC4と同じように、しかし、可能性、パフォーマンスの低下とDATA_SYNC4を実装して自由です。安定がUNSTABLE4ある場合、サーバーはクライアントへの応答を返す前に、すべてまたはnoneを含む安定したストレージへのデータの任意の部分とメタデータをコミットして自由です。コミットされていないデータは、その後安定したストレージにコミットするかどうかとき保証はありません。サーバによって作られた唯一の保証は、それがVERFの値を変更することなく、任意のデータを破壊し、それがクライアントによって要求されたよりも低いレベルでのデータとメタデータをコミットしていないということではないだろうということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The stateid value for a WRITE request represents a value returned from a previous record lock or share reservation request. The stateid is used by the server to verify that the associated share reservation and any record locks are still valid and to update lease timeouts for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WRITE要求のためのstateid値は、前のレコードロックまたは共有の予約要求から返された値を表します。 stateidは、関連する株式予約と任意のレコードロックがまだ有効であることを確認するために、クライアントのリースのタイムアウトを更新するためにサーバによって使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon successful completion, the following results are returned. The count result is the number of bytes of data written to the file. The server may write fewer bytes than requested. If so, the actual number of bytes written starting at location, offset, is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常に完了すると、次の結果が返されます。カウント結果はファイルに書き込まれたデータのバイト数です。サーバーは、要求されたよりも少ないバイトを書き込むことができます。その場合、位置から始まる書き込まれたバイトの実際の数は、オフセット、戻されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server also returns an indication of the level of commitment of the data and metadata via committed. If the server committed all data and metadata to stable storage, committed should be set to FILE_SYNC4. If the level of commitment was at least as strong as DATA_SYNC4, then committed should be set to DATA_SYNC4. Otherwise, committed must be returned as UNSTABLE4. If stable was FILE4_SYNC, then committed must also be FILE_SYNC4: anything else constitutes a protocol violation. If stable was DATA_SYNC4, then committed may be FILE_SYNC4 or DATA_SYNC4: anything else constitutes a protocol violation. If stable was UNSTABLE4, then committed may be either FILE_SYNC4, DATA_SYNC4, or UNSTABLE4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、サーバーはコミットを介したデータおよびメタデータのコミットメントのレベルを示す値を返します。サーバーが安定したストレージにすべてのデータとメタデータを犯した場合、コミットはFILE_SYNC4に設定する必要があります。コミットメントのレベルがDATA_SYNC4と少なくとも同じくらい強かった場合、コミットはDATA_SYNC4に設定する必要があります。そうでない場合、コミットはUNSTABLE4として返さなければなりません。安定したがFILE4_SYNCた場合は、コミットもFILE_SYNC4でなければなりません：他の何かがプロトコル違反を構成しています。安定したがDATA_SYNC4た場合は、コミットFILE_SYNC4またはDATA_SYNC4ことがあります何か他のものは、プロトコル違反を構成しています。安定したがUNSTABLE4た場合は、コミットFILE_SYNC4、DATA_SYNC4、またはUNSTABLE4のいずれであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The final portion of the result is the write verifier. The write verifier is a cookie that the client can use to determine whether the server has changed instance (boot) state between a call to WRITE and a subsequent call to either WRITE or COMMIT. This cookie must be consistent during a single instance of the NFS version 4 protocol service and must be unique between instances of the NFS version 4 protocol server, where uncommitted data may be lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果の最後の部分は、書き込み検証です。書き込み検証は、クライアントが、サーバが書き込みの呼び出しとWRITEまたはCOMMITのいずれかへのその後の呼び出しの間インスタンス（ブート）状態に変化したか否かを判断するために使用できるクッキーです。このクッキーは、NFSバージョン4プロトコルサービスの単一のインスタンス間に一貫性がなければならず、コミットされていないデータが失われる可能性がNFSバージョン4プロトコルサーバのインスタンス間で一意でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client writes data to the server with the stable argument set to UNSTABLE4 and the reply yields a committed response of DATA_SYNC4 or UNSTABLE4, the client will follow up some time in the future with a COMMIT operation to synchronize outstanding asynchronous data and metadata with the server&#39;s stable storage, barring client error. It is possible that due to client crash or other error that a subsequent COMMIT will not be received by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがUNSTABLE4に設定された安定した引数を使用してサーバにデータを書き込み、返信がDATA_SYNC4またはUNSTABLE4のコミット応答を生成する場合は、クライアントが持つ優れた非同期データおよびメタデータを同期させるためにCOMMIT操作で、将来的にいくつかの時間をフォローアップしますサーバの安定したストレージ、クライアントエラーがなければ。その後のCOMMITというクライアントのクラッシュまたはその他のエラーが原因で、サーバによって受信されない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a WRITE with a stateid value of all bits 0, the server MAY allow the WRITE to be serviced subject to mandatory file locks or the current share deny modes for the file. For a WRITE with a stateid value of all bits 1, the server MUST NOT allow the WRITE operation to bypass locking checks at the server and are treated exactly the same as if a stateid of all bits 0 were used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全ビット0のstateid値がWRITEのために、サーバは、書き込みが必須のファイルロックまたは現在の共有ファイルのためのモードを拒否する対象サービスを受けることを可能にすることができます。全ビット1のstateid値がWRITEのために、サーバは、書き込み動作がサーバにチェックをロック回避することを可能にしてはいけませんと全ビット0のstateidが使用された場合と全く同様に扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On success, the current filehandle retains its value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功すると、現在のファイルハンドルは、その値を保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible for the server to write fewer bytes of data than requested by the client. In this case, the server should not return an error unless no data was written at all. If the server writes less than the number of bytes specified, the client should issue another WRITE to write the remaining data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、クライアントから要求されたよりも少ないデータのバイト数を書き込むことが可能です。データが全く書かれていない限りこの場合、サーバがエラーを返すべきではありません。サーバーは、指定されたバイト数よりも少ないが書き込まれた場合、クライアントは残りのデータを書き込むために、別のWRITEを発行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that the act of writing data to a file will cause the time_modified of the file to be updated. However, the time_modified of the file should not be changed unless the contents of the file are changed. Thus, a WRITE request with count set to 0 should not cause the time_modified of the file to be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルにデータを書き込む行為は、ファイルのtime_modifiedが更新されますと仮定されます。ファイルの内容が変更されない限りただし、ファイルのtime_modifiedは変更すべきではありません。このように、0に設定されたカウントと書き込み要求がファイルのtime_modifiedをアップデートするべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of stable storage has been historically a point of contention. The following expected properties of stable storage may help in resolving design issues in the implementation. Stable storage is persistent storage that survives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
貯蔵安定性の定義は歴史的に競合のポイントとなっています。安定したストレージの以下の期待される特性は、実装に設計上の問題の解決に役立つことがあります。安定したストレージは生き残る永続的なストレージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Repeated power failures. 2. Hardware failures (of any board, power supply, etc.). 3. Repeated software crashes, including reboot cycle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1.繰り返し停電。 （任意ボード、電源などの）2.ハードウェア障害。再起動のサイクルを含む3繰り返しソフトウェアがクラッシュしました、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This definition does not address failure of the stable storage module itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この定義は、安定したストレージモジュール自体の故障に対応していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The verifier is defined to allow a client to detect different instances of an NFS version 4 protocol server over which cached, uncommitted data may be lost. In the most likely case, the verifier allows the client to detect server reboots. This information is required so that the client can safely determine whether the server could have lost cached data. If the server fails unexpectedly and the client has uncommitted data from previous WRITE requests (done with the stable argument set to UNSTABLE4 and in which the result committed was returned as UNSTABLE4 as well) it may not have flushed cached data to stable storage. The burden of recovery is on the client and the client will need to retransmit the data to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
検証者は、コミットされていないデータが失われる可能性があり、キャッシュされたその上NFSバージョン4プロトコルサーバの異なるインスタンスを検出するためのクライアントを許可するように定義されています。最も可能性が高い場合には、検証は、クライアントがサーバーの再起動を検出することができます。クライアントが安全にサーバがキャッシュされたデータを失っていることができるかどうかを判断できるように、この情報が必要になります。サーバーが予期せずに失敗し、クライアントは、前のWRITE要求（UNSTABLE4に設定された安定した引数で行われ、結果はコミットしているが、同様UNSTABLE4として返された）からのコミットされていないデータがある場合には、安定したストレージにキャッシュされたデータをフラッシュしていない可能性があり。回復の負担は、クライアント上で、クライアントがサーバにデータを再送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A suggested verifier would be to use the time that the server was booted or the time the server was last started (if restarting the server without a reboot results in lost buffers).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
提案検証は、サーバが起動された時刻または（失われたバッファにリブート結果なしでサーバーを再起動する場合）、サーバーが最後に開始された時刻を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The committed field in the results allows the client to do more effective caching. If the server is committing all WRITE requests to stable storage, then it should return with committed set to FILE_SYNC4, regardless of the value of the stable field in the arguments. A server that uses an NVRAM accelerator may choose to implement this policy. The client can use this to increase the effectiveness of the cache by discarding cached data that has already been committed on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果内のコミットフィールドは、クライアントがより効果的なキャッシングを行うことができます。サーバーが安定したストレージにすべてのWRITE要求をコミットしている場合、それは関係なく、引数で安定したフィールドの値の、FILE_SYNC4にコミット設定して返す必要があります。 NVRAMアクセラレータを使用するサーバーは、このポリシーを実装することを選択できます。クライアントがすでにサーバーにコミットされたキャッシュされたデータを破棄することにより、キャッシュの有効性を高めるためにこれを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some implementations may return NFS4ERR_NOSPC instead of NFS4ERR_DQUOT when a user&#39;s quota is exceeded. In the case that the current filehandle is a directory, the server will return NFS4ERR_ISDIR. If the current filehandle is not a regular file or a directory, the server will return NFS4ERR_INVAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザのクォータを超えた場合、いくつかの実装がNFS4ERR_DQUOTの代わりにNFS4ERR_NOSPCを返すことがあります。現在のファイルハンドルがディレクトリである場合、サーバはNFS4ERR_ISDIRを返します。現在のファイルハンドルは通常のファイルまたはディレクトリでない場合、サーバはNFS4ERR_INVALを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If mandatory file locking is on for the file, and corresponding record of the data to be written file is read or write locked by an owner that is not associated with the stateid, the server will return NFS4ERR_LOCKED. If so, the client must check if the owner corresponding to the stateid used with the WRITE operation has a conflicting read lock that overlaps with the region that was to be written. If the stateid&#39;s owner has no conflicting read lock, then the client should try to get the appropriate write record lock via the LOCK operation before re-attempting the WRITE. When the WRITE completes, the client should release the record lock via LOCKU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須のファイルのロックは、ファイルのためであり、データの対応するレコードは、ファイルが読み取られ、またはのstateidに関連付けられていない所有者によってロック書き込み書き込まれる場合、サーバはNFS4ERR_LOCKEDを返します。もしそうであればWRITE動作と使用のstateidに対応する所有者が書き込まれることになっていた領域と重なる競合読み取りロックを有している場合、クライアントはチェックしなければなりません。 stateidの所有者が競合する読み取りロックを持っていない場合、クライアントは再試行する前に、WRITE LOCK操作を介して適切な書き込みレコードロックを取得しようとする必要があります。 WRITEが完了すると、クライアントはLOCKUを経由して、レコードのロックを解除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the stateid&#39;s owner had a conflicting read lock, then the client has no choice but to return an error to the application that attempted the WRITE. The reason is that since the stateid&#39;s owner had a read lock, the server either attempted to temporarily effectively upgrade this read lock to a write lock, or the server has no upgrade capability. If the server attempted to upgrade the read lock and failed, it is pointless for the client to re-attempt the upgrade via the LOCK operation, because there might be another client also trying to upgrade. If two clients are blocked trying upgrade the same lock, the clients deadlock. If the server has no upgrade capability, then it is pointless to try a LOCK operation to upgrade.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stateidの所有者は、矛盾する読み取りロックを持っていた場合、クライアントはWRITEを試みたアプリケーションにエラーを返すしかありません。その理由は、のstateidの所有者は読み取りロックを持っていたことから、サーバーが一時的に効果的に、これは書き込みロックにロックを読み、またはサーバーが何のアップグレード機能を持っていないアップグレードしようとしたのどちらかということです。サーバーは、読み取りロックをアップグレードしようとして失敗した場合は、別のクライアントもアップグレードしようとしているがあるかもしれないので、クライアントは、LOCK操作を経由してアップグレードを再試行するために、それは無意味です。 2つのクライアントが同じロックをアップグレードしようとしてブロックされている場合、クライアントがデッドロック。サーバが何のアップグレード機能を持っていない場合、アップグレードするためにLOCK操作を試して無意味です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXPIRED
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ACCESS NFS4ERR_ADMIN_REVOKED NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_DELAY NFS4ERR_DQUOT NFS4ERR_EXPIRED
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_FBIG NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_IO NFS4ERR_ISDIR NFS4ERR_LEASE_MOVED NFS4ERR_LOCKED NFS4ERR_MOVED NFS4ERR_NOFILEHANDLE NFS4ERR_NOSPC NFS4ERR_NXIO NFS4ERR_OLD_STATEID NFS4ERR_OPENMODE NFS4ERR_RESOURCE NFS4ERR_ROFS NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_STATEID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.37. Operation 39: RELEASE_LOCKOWNER - Release Lockowner State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.37。操作39：RELEASE_LOCKOWNER  - リリースLockowner州
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
lockowner -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
lockowner  - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RELEASE_LOCKOWNER4args {
             lock_owner4     lock_owner;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct RELEASE_LOCKOWNER4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is used to notify the server that the lock_owner is no longer in use by the client. This allows the server to release cached state related to the specified lock_owner. If file locks, associated with the lock_owner, are held at the server, the error NFS4ERR_LOCKS_HELD will be returned and no further action will be taken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作はlock_ownerは、クライアントによって使用されなくなっているサーバーに通知するために使用されます。これは、サーバーが指定されたlock_ownerに関連するキャッシュされた状態を解除することができます。 lock_ownerに関連付けられたファイルロックは、サーバーに保持されている場合は、エラーNFS4ERR_LOCKS_HELDが返され、それ以上のアクションは取られません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client may choose to use this operation to ease the amount of server state that is held. Depending on behavior of applications at the client, it may be important for the client to use this operation since the server has certain obligations with respect to holding a reference to a lock_owner as long as the associated file is open. Therefore, if the client knows for certain that the lock_owner will no longer be used under the context of the associated open_owner4, it should use RELEASE_LOCKOWNER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが保持されているサーバーの状態の量を容易にするために、この操作を使用することもできます。クライアントは、この操作を使用するためにサーバがある限り、関連するファイルが開いているようlock_ownerへの参照を保持に対して一定の義務を持っているので、クライアントでのアプリケーションの動作に応じて、それは重要であるかもしれません。クライアントはlock_ownerは、もはや関連しopen_owner4のコンテキストで使用されないことを確実に知っている場合ので、それはRELEASE_LOCKOWNERを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_LEASE_MOVED NFS4ERR_LOCKS_HELD NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_ADMIN_REVOKED NFS4ERR_BADXDR NFS4ERR_EXPIRED NFS4ERR_LEASE_MOVED NFS4ERR_LOCKS_HELD NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT NFS4ERR_STALE_CLIENTID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.38. Operation 10044: ILLEGAL - Illegal operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2.38。オペレーション10044：ILLEGAL  - 不正な操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;null&gt; -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;ヌル&gt;  - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             struct ILLEGAL4res {
                     nfsstat4        status;
             };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See the COMPOUND procedure description for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作はサポートされていない化合物内のオペレーションコードを送信したクライアントの場合を処理するために結果を符号化するためのプレースホルダです。詳細はCOMPOUND手順の説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The status field of ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client will probably not send an operation with code OP_ILLEGAL but if it does, the response will be ILLEGAL4res just as it would be with any other invalid operation code. Note that if the server gets an illegal operation code that is not OP_ILLEGAL, and if the server checks for legal operation codes during the XDR decode phase, then the ILLEGAL4res would not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、おそらくコードOP_ILLEGALで操作を送信しませんが、それがない場合、応答は、それが他の不正なオペレーションコードを持つことと同じようにILLEGAL4resになります。注意サーバがOP_ILLEGALない不正な操作コードを取得した場合、およびXDRデコード段階の間法的操作コードのサーバをチェックし、次にILLEGAL4resが返されない場合に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFS version 4 Callback Procedures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. NFSバージョン4コールバック手続き
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedures used for callbacks are defined in the following sections. In the interest of clarity, the terms &#34;client&#34; and &#34;server&#34; refer to NFS clients and servers, despite the fact that for an individual callback RPC, the sense of these terms would be precisely the opposite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コールバックのために使用される手順は、次のセクションで定義されています。明瞭にするために、用語「クライアント」と「サーバー」は、個々のコールバックRPCのために、これらの用語の意味は正反対になるという事実にもかかわらず、NFSクライアントとサーバを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. Procedure 0: CB_NULL - No Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1。手順0：CB_NULL  - 動作なし
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;null&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;NULL&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standard NULL procedure. Void argument, void response. Even though there is no direct functionality associated with this procedure, the server will use CB_NULL to confirm the existence of a path for RPCs from server to client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準NULL手続き。ボイド引数、無効応答。この手順に関連した直接的な機能はありませんにもかかわらず、サーバは、サーバからクライアントへのRPCのパスの存在を確認するためにCB_NULLを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
None.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無し。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. Procedure 1: CB_COMPOUND - Compound Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2。手順1：CB_COMPOUND  - 化合物の操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
compoundargs -&gt; compoundres
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
compoundargs  - &gt; compoundres
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
enum nfs_cb_opnum4 { OP_CB_GETATTR = 3, OP_CB_RECALL = 4, OP_CB_ILLEGAL = 10044 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
列挙{nfs_cb_opnum4 OP_CB_GETATTR = 3、OP_CB_RECALL = 4、OP_CB_ILLEGAL = 10044}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_cb_argop4 switch (unsigned argop) {
      case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;
      case OP_CB_RECALL:     CB_RECALL4args  opcbrecall;
      case OP_CB_ILLEGAL:    void            opcbillegal;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_COMPOUND4args {
             utf8str_cs      tag;
             uint32_t        minorversion;
             uint32_t        callback_ident;
             nfs_cb_argop4   argarray&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union nfs_cb_resop4 switch (unsigned resop){
      case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
      case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_COMPOUND4res {
             nfsstat4 status;
             utf8str_cs      tag;
             nfs_cb_resop4   resarray&lt;&gt;;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure is used to combine one or more of the callback procedures into a single RPC request. The main callback RPC program has two main procedures: CB_NULL and CB_COMPOUND. All other operations use the CB_COMPOUND procedure as a wrapper.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUND手順は、単一のRPC要求にコールバック手続きの一つ以上を組み合わせるために使用されます。 CB_NULLとCB_COMPOUND：メインのコールバックRPCプログラムは、主に2つの手順があります。他のすべての操作は、ラッパーとしてCB_COMPOUNDプロシージャを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the processing of the CB_COMPOUND procedure, the client may find that it does not have the available resources to execute any or all of the operations within the CB_COMPOUND sequence. In this case, the error NFS4ERR_RESOURCE will be returned for the particular operation within the CB_COMPOUND procedure where the resource exhaustion occurred. This assumes that all previous operations within the CB_COMPOUND sequence have been evaluated successfully.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUND手順の処理では、クライアントは、それがCB_COMPOUND配列内の操作のいずれか、またはすべてを実行するために使用可能なリソースを持っていないことがあります。この場合、エラーNFS4ERR_RESOURCEは、リソースの枯渇が発生しCB_COMPOUNDプロシージャ内の特定の操作のために返されます。これはCB_COMPOUND配列内のすべての以前の操作が正常に評価されていることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contained within the CB_COMPOUND results is a &#39;status&#39; field. This status must be equivalent to the status of the last operation that was executed within the CB_COMPOUND procedure. Therefore, if an operation incurred an error then the &#39;status&#39; value will be the same error value as is being returned for the operation that failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUND結果に含まれる「状態」欄です。このステータスはCB_COMPOUND手順の中で実行された最後の操作の状態と同等でなければなりません。操作がエラーを発生した場合、したがって、次に「ステータス」値は、失敗した操作のために返される同じエラー値となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the definition of the &#34;tag&#34; field, see the section &#34;Procedure 1: COMPOUND - Compound Operations&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「： - 複合オペレーションCOMPOUND手順1」「タグ」フィールドの定義については、セクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of callback_ident is supplied by the client during SETCLIENTID. The server must use the client supplied callback_ident during the CB_COMPOUND to allow the client to properly identify the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
callback_identの値はSETCLIENTID中に、クライアントによって供給されています。サーバーは、クライアントがサーバーを正しく識別できるようにするためにCB_COMPOUND中に、クライアント供給callback_identを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Illegal operation codes are handled in the same way as they are handled for the COMPOUND procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不正操作コードは、それらは、化合物処置のために処理されるのと同じ方法で処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_COMPOUND procedure is used to combine individual operations into a single RPC request. The client interprets each of the operations in turn. If an operation is executed by the client and the status of that operation is NFS4_OK, then the next operation in the CB_COMPOUND procedure is executed. The client continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_COMPOUND手順は、単一のRPC要求に個々の操作を組み合わせるために使用されます。クライアントは、順番にそれぞれの操作を解釈します。操作は、クライアントで実行されると、その操作のステータスがNFS4_OKでされている場合は、CB_COMPOUNDの手順の次の動作が実行されます。が実行されるべきそれ以上の操作がされないかのいずれかの操作がNFS4_OK以外の状態値を有するまで、クライアントは、このプロセスを継続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_OP_ILLEGAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_OP_ILLEGAL NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1. Operation 3: CB_GETATTR - Get Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.1。動作3：CB_GETATTR  - 属性を取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
fh, attr_request -&gt; attrmask, attr_vals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
FH、attr_request  - &gt; attrmask、attr_vals
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_GETATTR4args {
             nfs_fh4 fh;
             bitmap4 attr_request;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_GETATTR4resok {
             fattr4  obj_attributes;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     union CB_GETATTR4res switch (nfsstat4 status) {
      case NFS4_OK:
              CB_GETATTR4resok       resok4;
      default:
              void;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_GETATTR operation is used by the server to obtain the current modified state of a file that has been write delegated. The attributes size and change are the only ones guaranteed to be serviced by the client. See the section &#34;Handling of CB_GETATTR&#34; for a full description of how the client and server are to interact with the use of CB_GETATTR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_GETATTR動作が書き込み委任されたファイルの現在の修正された状態を得るためにサーバによって使用されます。属性のサイズと変更は、クライアントがサービスを提供することが保証だけです。クライアントとサーバがCB_GETATTRの使用と対話するある方法の完全な説明については、「CB_GETATTRの取り扱い」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the filehandle specified is not one for which the client holds a write open delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたファイルハンドルは、クライアントが書き込みオープン委譲を保持するためのものではない場合は、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client returns attrmask bits and the associated attribute values only for the change attribute, and attributes that it may change (time_modify, and size).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、変更属性のattrmaskビットと関連付けられた属性値を返し、それが（time_modify、およびサイズ）を変更してもよいこと属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BADXDR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4 ERR_BADHANDLE NFS4 ERR_BADXDR NFS4 ERR_RESOURCE NFS4 ERR_SERVERFAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2. Operation 4: CB_RECALL - Recall an Open Delegation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.2。操作4：CB_RECALL  - オープン委任を思い出してください
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
stateid, truncate, fh -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
stateid、切り捨て、FH  - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_RECALL4args {
             stateid4        stateid;
             bool            truncate;
             nfs_fh4         fh;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct CB_RECALL4res {
             nfsstat4        status;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CB_RECALL operation is used to begin the process of recalling an open delegation and returning it to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_RECALL操作が開いている委譲を想起し、それをサーバーに戻す処理を開​​始するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The truncate flag is used to optimize recall for a file which is about to be truncated to zero. When it is set, the client is freed of obligation to propagate modified data for the file to the server, since this data is irrelevant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRUNCATEフラグはゼロに切り捨てされようとしているファイルのリコールを最適化するために使用されます。それが設定されている場合、クライアントは、このデータは無関係であるため、サーバーへのファイルのために変更されたデータを伝播する義務が除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the handle specified is not one for which the client holds an open delegation, an NFS4ERR_BADHANDLE error is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたハンドルは、クライアントが開いている委譲を保持するためのものではない場合は、NFS4ERR_BADHANDLEエラーが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the stateid specified is not one corresponding to an open delegation for the file specified by the filehandle, an NFS4ERR_BAD_STATEID is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたstateidは、ファイルハンドルで指定されたファイルのオープン委譲に対応していないものである場合、NFS4ERR_BAD_STATEIDが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client should reply to the callback immediately. Replying does not complete the recall except when an error was returned. The recall is not complete until the delegation is returned using a DELEGRETURN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはすぐにコールバックに返信する必要があります。返信するには、エラーが返された場合を除き、リコールを完了していません。代表団はDELEGRETURNを使用して返されるまで、リコールは完全ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
NFS4ERR_BADHANDLE NFS4ERR_BAD_STATEID NFS4ERR_BADXDR NFS4ERR_RESOURCE NFS4ERR_SERVERFAULT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3. Operation 10044: CB_ILLEGAL - Illegal Callback Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2.3。オペレーション10044：CB_ILLEGAL  - 不正なコールバックの操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SYNOPSIS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;null&gt; -&gt; ()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;ヌル&gt;  - &gt;（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARGUMENT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
void;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
無効;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESULT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             struct CB_ILLEGAL4res {
                     nfsstat4        status;
             };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESCRIPTION
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See the COMPOUND procedure description for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作はサポートされていない化合物内のオペレーションコードを送信したクライアントの場合を処理するために結果を符号化するためのプレースホルダです。詳細はCOMPOUND手順の説明を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The status field of CB_ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CB_ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IMPLEMENTATION
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server will probably not send an operation with code OP_CB_ILLEGAL but if it does, the response will be CB_ILLEGAL4res just as it would be with any other invalid operation code. Note that if the client gets an illegal operation code that is not OP_ILLEGAL, and if the client checks for legal operation codes during the XDR decode phase, then the CB_ILLEGAL4res would not be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、おそらくコードOP_CB_ILLEGALで操作を送信しませんが、それがない場合、応答は、それが他の不正なオペレーションコードを持つことと同じようにCB_ILLEGAL4resになります。注クライアントがOP_ILLEGALない不正な操作コードを取得した場合、およびXDRデコード段階の間法的操作コードのクライアントチェックは、その後CB_ILLEGAL4resが返されない場合に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERRORS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS4ERR_OP_ILLEGAL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFS has historically used a model where, from an authentication perspective, the client was the entire machine, or at least the source IP address of the machine. The NFS server relied on the NFS client to make the proper authentication of the end-user. The NFS server in turn shared its files only to specific clients, as identified by the client&#39;s source IP address. Given this model, the AUTH_SYS RPC security flavor simply identified the end-user using the client to the NFS server. When processing NFS responses, the client ensured that the responses came from the same IP address and port number that the request was sent to. While such a model is easy to implement and simple to deploy and use, it is certainly not a safe model. Thus, NFSv4 mandates that implementations support a security model that uses end to end authentication, where an end-user on a client mutually authenticates (via cryptographic schemes that do not expose passwords or keys in the clear on the network) to a principal on an NFS server. Consideration should also be given to the integrity and privacy of NFS requests and responses. The issues of end to end mutual authentication, integrity, and privacy are discussed as part of the section on &#34;RPC and Security Flavor&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSは、歴史的に、認証の観点から、クライアントはマシン全体、または機械の少なくとも送信元IPアドレスだった、モデルを使用しています。 NFSサーバーは、エンドユーザーの適切な認証を行うためにNFSクライアントに依存していました。クライアントのソースIPアドレスによって識別されるように順番にNFSサーバは、特定のクライアントだけにそのファイルを共有しました。このモデルを考えると、AUTH_SYS RPCセキュリティ風味は、単純にNFSサーバーにクライアントを使用して、エンドユーザを特定しました。 NFS応答を処理する場合、クライアントは応答が要求が送られた同じIPアドレスとポート番号から来たことを確実にしました。このようなモデルを展開し、使用するために実装するのは簡単でシンプルですが、それは確かに安全なモデルではありません。従って、実装がエンド認証に終止符を使用するセキュリティモデルをサポートするのNFSv4義務ここで主に（ネットワーク上明らかにパスワードまたはキーを公開していない暗号スキームを介して）クライアントのエンドユーザーは、相互認証を行いますNFSサーバ。配慮もNFS要求と応答の整合性とプライバシーに与えられるべきです。相互認証、整合性、およびプライバシーをエンドツーエンドの問題は、「RPCとセキュリティの味」のセクションの一部として議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that while NFSv4 mandates an end to end mutual authentication model, the &#34;classic&#34; model of machine authentication via IP address checking and AUTH_SYS identification can still be supported with the caveat that the AUTH_SYS flavor is neither MANDATORY nor RECOMMENDED by this specification, and so interoperability via AUTH_SYS is not assured.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSv4のは終わりを義務付けながら、相互認証モデルを終了することに注意してください、IPアドレスのチェックやAUTH_SYS識別を介したマシン認証の「古典的」モデルは、まだAUTH_SYSの風味がMANDATORYもこの仕様で推奨され、そうでもないことを警告してサポートすることができますAUTH_SYSを介した相互運用性が保証されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For reasons of reduced administration overhead, better performance and/or reduction of CPU utilization, users of NFS version 4 implementations may choose to not use security mechanisms that enable integrity protection on each remote procedure call and response. The use of mechanisms without integrity leaves the customer vulnerable to an attacker in between the NFS client and server that modifies the RPC request and/or the response. While implementations are free to provide the option to use weaker security mechanisms, there are two operations in particular that warrant the implementation overriding user choices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
削減管理オーバーヘッド、より良い性能および/またはCPU使用率の削減の理由から、NFSバージョンのユーザ4つの実装は、各リモート・プロシージャ・コールとレスポンスの完全性保護を可能にするセキュリティ・メカニズムを使用しないことを選択できます。整合性のないメカニズムを使用すると、RPC要求および/または応答を変更するNFSクライアントとサーバの間で、攻撃者に対して脆弱顧客を残します。実装が弱いセキュリティメカニズムを使用するためのオプションを提供するために自由ですが、ユーザーの選択をオーバーライド実装を保証し、特に2つの操作があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first such operation is SECINFO. It is recommended that the client issue the SECINFO call such that it is protected with a security flavor that has integrity protection, such as RPCSEC_GSS with a security triple that uses either rpc_gss_svc_integrity or rpc_gss_svc_privacy (rpc_gss_svc_privacy includes integrity protection) service. Without integrity protection encapsulating SECINFO and therefore its results, an attacker in the middle could modify results such that the client might select a weaker algorithm in the set allowed by server, making the client and/or server vulnerable to further attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のそのような操作はSECINFOあります。それは推奨されているクライアントの問題、それがrpc_gss_svc_integrityまたはrpc_gss_svc_privacyのいずれかを使用して、セキュリティ、トリプルでそのようなRPCSEC_GSSなど完全性保護、（rpc_gss_svc_privacyは、完全性保護を含みます）のサービスがあり、セキュリティの味で保護されるようにSECINFOコール。 SECINFOため、その結果をカプセル化する完全性保護がなければ、途中で攻撃者がさらなる攻撃へのクライアントおよび/またはサーバが脆弱作り、クライアントがサーバーによって許可されたセットの中の弱いアルゴリズムを選択するかもしれないような結果を修正することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second operation that should definitely use integrity protection is any GETATTR for the fs_locations attribute. The attack has two steps. First the attacker modifies the unprotected results of some operation to return NFS4ERR_MOVED. Second, when the client follows up with a GETATTR for the fs_locations attribute, the attacker modifies the results to cause the client migrate its traffic to a server controlled by the attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
間違いなく、完全性保護を使用する必要があり、第2の動作はfs_位置の属性のいずれかのGETATTRです。攻撃は、2つのステップがあります。まず、攻撃者はNFS4ERR_MOVEDを返すために、いくつかの操作の保護されていない結果を変更します。クライアントは、属性fs_位置のためのGETATTRをフォローアップしたときに第二に、攻撃者は、クライアントが攻撃者によって制御されるサーバーへのトラフィックの移行が発生し、結果を変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the operations SETCLIENTID/SETCLIENTID_CONFIRM are responsible for the release of client state, it is imperative that the principal used for these operations is checked against and match the previous use of these operations. See the section &#34;Client ID&#34; for further discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SETCLIENTID / SETCLIENTID_CONFIRM操作は、クライアント状態の解除を担当しているので、これらの操作のために使用される主はに対してチェックし、これらの操作の以前の使用と一致していることが不可欠です。さらなる議論については、「クライアントID」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. Named Attribute Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1。名前の属性の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NFS version 4 protocol provides for the association of named attributes to files. The name space identifiers for these attributes are defined as string names. The protocol does not define the specific assignment of the name space for these file attributes. Even though the name space is not specifically controlled to prevent collisions, an IANA registry has been created for the registration of NFS version 4 named attributes. Registration will be achieved through the publication of an Informational RFC and will require not only the name of the attribute but the syntax and semantics of the named attribute contents; the intent is to promote interoperability where common interests exist. While application developers are allowed to define and use attributes as needed, they are encouraged to register the attributes with IANA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NFSバージョン4プロトコルは、ファイルに指定された属性との関連付けのために用意されています。これらの属性の名前空間識別子は、文字列名として定義されています。プロトコルは、これらのファイル属性の名前空間の特定の割り当てを定義していません。名前空間は、具体的に衝突を防ぐように制御されていないにもかかわらず、IANAレジストリは、NFSバージョン4つのという名前の属性の登録のために作成されています。登録は情報RFCの公表によって達成され、属性の名前が、指定した属性の内容の構文と意味だけでなく、必要になります。その意図は、共通の利益が存在し、相互運用性を促進することです。アプリケーション開発者は、必要に応じて属性を定義して使用することを許可されているが、それらは、IANAで属性を登録することが奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. ONC RPC Network Identifiers (netids)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2。 ONC RPCネットワーク識別子（netids）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The section &#34;Structured Data Types&#34; discussed the r_netid field and the corresponding r_addr field of a clientaddr4 structure. The NFS version 4 protocol depends on the syntax and semantics of these fields to effectively communicate callback information between client and server. Therefore, an IANA registry has been created to include the values defined in this document and to allow for future expansion based on transport usage/availability. Additions to this ONC RPC Network Identifier registry must be done with the publication of an RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「構造化データタイプ」r_netidフィールドとclientaddr4構造の対応R_ADDRフィールドについて議論しました。 NFSバージョン4プロトコルは、効果的に、クライアントとサーバ間のコールバック情報を通信するために、これらのフィールドの構文とセマンティクスに依存します。したがって、IANAレジストリは、この文書で定義された値が含まれるように、輸送の利用/利用可能性に基づいて将来の拡張を可能にするために作成されています。このONC RPCネットワーク識別子レジストリへの追加は、RFCの公表を行わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial values for this registry are as follows (some of this text is replicated from section 2.2 for clarity):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（このテキストの一部は、明確化のためにセクション2.2から複製された）次のように、このレジストリの初期値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Network Identifier (or r_netid for short) is used to specify a transport protocol and associated universal address (or r_addr for short). The syntax of the Network Identifier is a US-ASCII string. The initial definitions for r_netid are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワーク識別子（または略しr_netid）は、トランスポートプロトコル及び関連汎用アドレス（または略してR_ADDR）を指定するために使用されます。ネットワーク識別子の構文はUS-ASCII文字列です。 r_netidのための最初の定義は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;tcp&#34; - TCP over IP version 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;TCP&#34;  -  IPバージョン4以上のTCP
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;udp&#34; - UDP over IP version 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;UDP&#34;  -  IPバージョン4以上のUDP
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;tcp6&#34; - TCP over IP version 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPバージョン6以上のTCP  -  &#34;にtcp6&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&#34;udp6&#34; - UDP over IP version 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPバージョン6以上のUDP  -  &#34;UDP6&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: the &#39;&#34;&#39; marks are used for delimiting the strings for this document and are not part of the Network Identifier string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：「&#34;」マークは、この文書の文字列を区切るために使用し、ネットワーク識別子の文字列の一部ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the &#34;tcp&#34; and &#34;udp&#34; Network Identifiers the Universal Address or r_addr (for IPv4) is a US-ASCII string and is of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「TCP」および「UDP」ネットワーク識別子の（IPv4用）ユニバーサルアドレスまたはR_ADDRはUS-ASCII文字列で、形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
h1.h2.h3.h4.p1.p2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
h1.h2.h3.h4.p1.p2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prefix, &#34;h1.h2.h3.h4&#34;, is the standard textual form for representing an IPv4 address, which is always four octets long. Assuming big-endian ordering, h1, h2, h3, and h4, are respectively, the first through fourth octets each converted to ASCII-decimal. Assuming big-endian ordering, p1 and p2 are, respectively, the first and second octets each converted to ASCII-decimal. For example, if a host, in big-endian order, has an address of 0x0A010307 and there is a service listening on, in big endian order, port 0x020F (decimal 527), then complete universal address is &#34;10.1.3.7.2.15&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接頭辞、「h1.h2.h3.h4は」、常に4つのオクテット長であるIPv4アドレスを表現するための標準的なテキスト形式、です。ビッグエンディアン順序、H1、H2、H3、およびH4と仮定すると、それぞれ、各第四オクテット〜第はASCII-小数に変換されます。それぞれ、ビッグエンディアン順序、P1とP2をしていると仮定すると、第一及び第二のオクテットはそれぞれ、ASCII-10進数に変換しました。例えば、ホストは、ビッグエンディアン順に、0x0A010307のアドレスを持ち、上のリスニングサービスがある場合には、ビッグエンディアン順、ポート0x020F（小数点以下527）で、その後、完全な汎用アドレスは「10.1.3.7.2.15」であります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the &#34;tcp6&#34; and &#34;udp6&#34; Network Identifiers the Universal Address or r_addr (for IPv6) is a US-ASCII string and is of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「にtcp6」と「UDP6」ネットワーク識別子の（IPv6用）ユニバーサルアドレスまたはR_ADDRはUS-ASCII文字列で、形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
x1:x2:x3:x4:x5:x6:x7:x8.p1.p2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
X1：X2：X3：X4：X5：X6：X7：x8.p1.p2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The suffix &#34;p1.p2&#34; is the service port, and is computed the same way as with universal addresses for &#34;tcp&#34; and &#34;udp&#34;. The prefix, &#34;x1:x2:x3:x4:x5:x6:x7:x8&#34;, is the standard textual form for representing an IPv6 address as defined in Section 2.2 of [RFC2373]. Additionally, the two alternative forms specified in Section 2.2 of [RFC2373] are also acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接尾辞「p1.p2は、」サービスポートで、「TCP」および「UDP」のための普遍的なアドレスと同じ方法で計算されます。接頭辞 &#34;X1：X2：X3：X4：X5：X6：X7：X8&#34; は、[RFC2373]のセクション2.2で定義されたIPv6アドレスを表すための標準的なテキスト形式です。また、[RFC2373]のセクション2.2で指定された2つの代替形態も許容されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned, the registration of new Network Identifiers will require the publication of an Information RFC with similar detail as listed above for the Network Identifier itself and corresponding Universal Address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述したように、新しいネットワーク識別子の登録は、ネットワーク識別子自体のユニバーサルアドレスに対応する上記と同様のディテール情報RFCの公表を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. RPC definition file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. RPC定義ファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *  Copyright (C) The Internet Society (1998,1999,2000,2001,2002).
    *  All Rights Reserved.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    *      nfs4_prot.x
    *
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
%#pragma ident &#34;%W%&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
％の#pragma identを &#34;%%で&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Basic typedefs for RFC 1832 data type definitions
    */
   typedef int             int32_t;
   typedef unsigned int    uint32_t;
   typedef hyper           int64_t;
   typedef unsigned hyper  uint64_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Sizes
    */
   const NFS4_FHSIZE               = 128;
   const NFS4_VERIFIER_SIZE        = 8;
   const NFS4_OPAQUE_LIMIT         = 1024;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * File types
    */
   enum nfs_ftype4 {
           NF4REG          = 1,    /* Regular File */
           NF4DIR          = 2,    /* Directory */
           NF4BLK          = 3,    /* Special File - block device */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           NF4CHR          = 4,    /* Special File - character device */
           NF4LNK          = 5,    /* Symbolic Link */
           NF4SOCK         = 6,    /* Special File - socket */
           NF4FIFO         = 7,    /* Special File - fifo */
           NF4ATTRDIR      = 8,    /* Attribute Directory */
           NF4NAMEDATTR    = 9     /* Named Attribute */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Error status
    */
   enum nfsstat4 {
           NFS4_OK                 = 0,    /* everything is okay      */
           NFS4ERR_PERM            = 1,    /* caller not privileged   */
           NFS4ERR_NOENT           = 2,    /* no such file/directory  */
           NFS4ERR_IO              = 5,    /* hard I/O error          */
           NFS4ERR_NXIO            = 6,    /* no such device          */
           NFS4ERR_ACCESS          = 13,   /* access denied           */
           NFS4ERR_EXIST           = 17,   /* file already exists     */
           NFS4ERR_XDEV            = 18,   /* different filesystems   */
           /* Unused/reserved        19 */
           NFS4ERR_NOTDIR          = 20,   /* should be a directory   */
           NFS4ERR_ISDIR           = 21,   /* should not be directory */
           NFS4ERR_INVAL           = 22,   /* invalid argument        */
           NFS4ERR_FBIG            = 27,   /* file exceeds server max */
           NFS4ERR_NOSPC           = 28,   /* no space on filesystem  */
           NFS4ERR_ROFS            = 30,   /* read-only filesystem    */
           NFS4ERR_MLINK           = 31,   /* too many hard links     */
           NFS4ERR_NAMETOOLONG     = 63,   /* name exceeds server max */
           NFS4ERR_NOTEMPTY        = 66,   /* directory not empty     */
           NFS4ERR_DQUOT           = 69,   /* hard quota limit reached*/
           NFS4ERR_STALE           = 70,   /* file no longer exists   */
           NFS4ERR_BADHANDLE       = 10001,/* Illegal filehandle      */
           NFS4ERR_BAD_COOKIE      = 10003,/* READDIR cookie is stale */
           NFS4ERR_NOTSUPP         = 10004,/* operation not supported */
           NFS4ERR_TOOSMALL        = 10005,/* response limit exceeded */
           NFS4ERR_SERVERFAULT     = 10006,/* undefined server error  */
           NFS4ERR_BADTYPE         = 10007,/* type invalid for CREATE */
           NFS4ERR_DELAY           = 10008,/* file &#34;busy&#34; - retry     */
           NFS4ERR_SAME            = 10009,/* nverify says attrs same */
           NFS4ERR_DENIED          = 10010,/* lock unavailable        */
           NFS4ERR_EXPIRED         = 10011,/* lock lease expired      */
           NFS4ERR_LOCKED          = 10012,/* I/O failed due to lock  */
           NFS4ERR_GRACE           = 10013,/* in grace period         */
           NFS4ERR_FHEXPIRED       = 10014,/* filehandle expired      */
           NFS4ERR_SHARE_DENIED    = 10015,/* share reserve denied    */
           NFS4ERR_WRONGSEC        = 10016,/* wrong security flavor   */
           NFS4ERR_CLID_INUSE      = 10017,/* clientid in use         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           NFS4ERR_RESOURCE        = 10018,/* resource exhaustion     */
           NFS4ERR_MOVED           = 10019,/* filesystem relocated    */
           NFS4ERR_NOFILEHANDLE    = 10020,/* current FH is not set   */
           NFS4ERR_MINOR_VERS_MISMATCH = 10021,/* minor vers not supp */
           NFS4ERR_STALE_CLIENTID  = 10022,/* server has rebooted     */
           NFS4ERR_STALE_STATEID   = 10023,/* server has rebooted     */
           NFS4ERR_OLD_STATEID     = 10024,/* state is out of sync    */
           NFS4ERR_BAD_STATEID     = 10025,/* incorrect stateid       */
           NFS4ERR_BAD_SEQID       = 10026,/* request is out of seq.  */
           NFS4ERR_NOT_SAME        = 10027,/* verify - attrs not same */
           NFS4ERR_LOCK_RANGE      = 10028,/* lock range not supported*/
           NFS4ERR_SYMLINK         = 10029,/* should be file/directory*/
           NFS4ERR_RESTOREFH       = 10030,/* no saved filehandle     */
           NFS4ERR_LEASE_MOVED     = 10031,/* some filesystem moved   */
           NFS4ERR_ATTRNOTSUPP     = 10032,/* recommended attr not sup*/
           NFS4ERR_NO_GRACE        = 10033,/* reclaim outside of grace*/
           NFS4ERR_RECLAIM_BAD     = 10034,/* reclaim error at server */
           NFS4ERR_RECLAIM_CONFLICT = 10035,/* conflict on reclaim    */
           NFS4ERR_BADXDR          = 10036,/* XDR decode failed       */
           NFS4ERR_LOCKS_HELD      = 10037,/* file locks held at CLOSE*/
           NFS4ERR_OPENMODE        = 10038,/* conflict in OPEN and I/O*/
           NFS4ERR_BADOWNER        = 10039,/* owner translation bad   */
           NFS4ERR_BADCHAR         = 10040,/* utf-8 char not supported*/
           NFS4ERR_BADNAME         = 10041,/* name not supported      */
           NFS4ERR_BAD_RANGE       = 10042,/* lock range not supported*/
           NFS4ERR_LOCK_NOTSUPP    = 10043,/* no atomic up/downgrade  */
           NFS4ERR_OP_ILLEGAL      = 10044,/* undefined operation     */
           NFS4ERR_DEADLOCK        = 10045,/* file locking deadlock   */
           NFS4ERR_FILE_OPEN       = 10046,/* open file blocks op.    */
           NFS4ERR_ADMIN_REVOKED   = 10047,/* lockowner state revoked */
           NFS4ERR_CB_PATH_DOWN    = 10048 /* callback path down      */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Basic data types
    */
   typedef uint32_t        bitmap4&lt;&gt;;
   typedef uint64_t        offset4;
   typedef uint32_t        count4;
   typedef uint64_t        length4;
   typedef uint64_t        clientid4;
   typedef uint32_t        seqid4;
   typedef opaque          utf8string&lt;&gt;;
   typedef utf8string      utf8str_cis;
   typedef utf8string      utf8str_cs;
   typedef utf8string      utf8str_mixed;
   typedef utf8str_cs      component4;
   typedef component4      pathname4&lt;&gt;; typedef uint64_t        nfs_lockid4;
   typedef uint64_t        nfs_cookie4;
   typedef utf8str_cs      linktext4;
   typedef opaque          sec_oid4&lt;&gt;;
   typedef uint32_t        qop4;
   typedef uint32_t        mode4;
   typedef uint64_t        changeid4;
   typedef opaque          verifier4[NFS4_VERIFIER_SIZE];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Timeval
    */
   struct nfstime4 {
           int64_t         seconds;
           uint32_t        nseconds;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum time_how4 { SET_TO_SERVER_TIME4 = 0, SET_TO_CLIENT_TIME4 = 1 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙time_how4 {SET_TO_SERVER_TIME4 = 0、SET_TO_CLIENT_TIME4 = 1}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union settime4 switch (time_how4 set_it) {
    case SET_TO_CLIENT_TIME4:
            nfstime4       time;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * File access handle
    */
   typedef opaque  nfs_fh4&lt;NFS4_FHSIZE&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * File attribute definitions
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * FSID structure for major/minor
    */
   struct fsid4 {
           uint64_t        major;
           uint64_t        minor;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    * Filesystem locations attribute for relocation/migration
    */
   struct fs_location4 {
           utf8str_cis     server&lt;&gt;;
           pathname4       rootpath;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fs_locations4 {
           pathname4       fs_root;
           fs_location4    locations&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Various Access Control Entry definitions
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Mask that indicates which Access Control Entries are supported.
    * Values for the fattr4_aclsupport attribute.
    */
   const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;
   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;
   const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;
   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef uint32_t        acetype4;
   /*
    * acetype4 values, others can be added as needed.
    */
   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;
   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;
   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;
   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE flag
    */
   typedef uint32_t aceflag4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE flag values
    */
   const ACE4_FILE_INHERIT_ACE             = 0x00000001;
   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;
   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;
   const ACE4_INHERIT_ONLY_ACE             = 0x00000008; const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;
   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;
   const ACE4_IDENTIFIER_GROUP             = 0x00000040;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE mask
    */
   typedef uint32_t        acemask4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE mask values
    */
   const ACE4_READ_DATA            = 0x00000001;
   const ACE4_LIST_DIRECTORY       = 0x00000001;
   const ACE4_WRITE_DATA           = 0x00000002;
   const ACE4_ADD_FILE             = 0x00000002;
   const ACE4_APPEND_DATA          = 0x00000004;
   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;
   const ACE4_READ_NAMED_ATTRS     = 0x00000008;
   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;
   const ACE4_EXECUTE              = 0x00000020;
   const ACE4_DELETE_CHILD         = 0x00000040;
   const ACE4_READ_ATTRIBUTES      = 0x00000080;
   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const ACE4_DELETE               = 0x00010000;
   const ACE4_READ_ACL             = 0x00020000;
   const ACE4_WRITE_ACL            = 0x00040000;
   const ACE4_WRITE_OWNER          = 0x00080000;
   const ACE4_SYNCHRONIZE          = 0x00100000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE4_GENERIC_READ -- defined as combination of
    *      ACE4_READ_ACL |
    *      ACE4_READ_DATA |
    *      ACE4_READ_ATTRIBUTES |
    *      ACE4_SYNCHRONIZE
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const ACE4_GENERIC_READ = 0x00120081;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
constのACE4_GENERIC_READ = 0x00120081;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE4_GENERIC_WRITE -- defined as combination of
    *      ACE4_READ_ACL |
    *      ACE4_WRITE_DATA |
    *      ACE4_WRITE_ATTRIBUTES |
    *      ACE4_WRITE_ACL |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 * ACE4_APPEND_DATA | * ACE4_SYNCHRONIZE */ const ACE4_GENERIC_WRITE = 0x00160106;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ACE4_APPEND_DATA | * ACE4_SYNCHRONIZE * / constのACE4_GENERIC_WRITE = 0x00160106;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACE4_GENERIC_EXECUTE -- defined as combination of
    *      ACE4_READ_ACL
    *      ACE4_READ_ATTRIBUTES
    *      ACE4_EXECUTE
    *      ACE4_SYNCHRONIZE
    */
   const ACE4_GENERIC_EXECUTE = 0x001200A0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Access Control Entry definition
    */
   struct nfsace4 {
           acetype4        type;
           aceflag4        flag;
           acemask4        access_mask;
           utf8str_mixed   who;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Field definitions for the fattr4_mode attribute
    */
   const MODE4_SUID = 0x800;  /* set user id on execution */
   const MODE4_SGID = 0x400;  /* set group id on execution */
   const MODE4_SVTX = 0x200;  /* save text even after use */
   const MODE4_RUSR = 0x100;  /* read permission: owner */
   const MODE4_WUSR = 0x080;  /* write permission: owner */
   const MODE4_XUSR = 0x040;  /* execute permission: owner */
   const MODE4_RGRP = 0x020;  /* read permission: group */
   const MODE4_WGRP = 0x010;  /* write permission: group */
   const MODE4_XGRP = 0x008;  /* execute permission: group */
   const MODE4_ROTH = 0x004;  /* read permission: other */
   const MODE4_WOTH = 0x002;  /* write permission: other */
   const MODE4_XOTH = 0x001;  /* execute permission: other */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Special data/attribute associated with
    * file types NF4BLK and NF4CHR.
    */
   struct specdata4 {
           uint32_t        specdata1;      /* major device number */ uint32_t        specdata2;      /* minor device number */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Values for fattr4_fh_expire_type
    */
   const   FH4_PERSISTENT          = 0x00000000;
   const   FH4_NOEXPIRE_WITH_OPEN  = 0x00000001;
   const   FH4_VOLATILE_ANY        = 0x00000002;
   const   FH4_VOL_MIGRATION       = 0x00000004;
   const   FH4_VOL_RENAME          = 0x00000008;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef bitmap4         fattr4_supported_attrs;
   typedef nfs_ftype4      fattr4_type;
   typedef uint32_t        fattr4_fh_expire_type;
   typedef changeid4       fattr4_change;
   typedef uint64_t        fattr4_size;
   typedef bool            fattr4_link_support;
   typedef bool            fattr4_symlink_support;
   typedef bool            fattr4_named_attr;
   typedef fsid4           fattr4_fsid;
   typedef bool            fattr4_unique_handles;
   typedef uint32_t        fattr4_lease_time;
   typedef nfsstat4        fattr4_rdattr_error;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   typedef nfsace4         fattr4_acl&lt;&gt;;
   typedef uint32_t        fattr4_aclsupport;
   typedef bool            fattr4_archive;
   typedef bool            fattr4_cansettime;
   typedef bool            fattr4_case_insensitive;
   typedef bool            fattr4_case_preserving;
   typedef bool            fattr4_chown_restricted;
   typedef uint64_t        fattr4_fileid;
   typedef uint64_t        fattr4_files_avail;
   typedef nfs_fh4         fattr4_filehandle;
   typedef uint64_t        fattr4_files_free;
   typedef uint64_t        fattr4_files_total;
   typedef fs_locations4   fattr4_fs_locations;
   typedef bool            fattr4_hidden;
   typedef bool            fattr4_homogeneous;
   typedef uint64_t        fattr4_maxfilesize;
   typedef uint32_t        fattr4_maxlink;
   typedef uint32_t        fattr4_maxname;
   typedef uint64_t        fattr4_maxread;
   typedef uint64_t        fattr4_maxwrite;
   typedef utf8str_cs      fattr4_mimetype;
   typedef mode4           fattr4_mode; typedef uint64_t        fattr4_mounted_on_fileid;
   typedef bool            fattr4_no_trunc;
   typedef uint32_t        fattr4_numlinks;
   typedef utf8str_mixed   fattr4_owner;
   typedef utf8str_mixed   fattr4_owner_group;
   typedef uint64_t        fattr4_quota_avail_hard;
   typedef uint64_t        fattr4_quota_avail_soft;
   typedef uint64_t        fattr4_quota_used;
   typedef specdata4       fattr4_rawdev;
   typedef uint64_t        fattr4_space_avail;
   typedef uint64_t        fattr4_space_free;
   typedef uint64_t        fattr4_space_total;
   typedef uint64_t        fattr4_space_used;
   typedef bool            fattr4_system;
   typedef nfstime4        fattr4_time_access;
   typedef settime4        fattr4_time_access_set;
   typedef nfstime4        fattr4_time_backup;
   typedef nfstime4        fattr4_time_create;
   typedef nfstime4        fattr4_time_delta;
   typedef nfstime4        fattr4_time_metadata;
   typedef nfstime4        fattr4_time_modify;
   typedef settime4        fattr4_time_modify_set;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Mandatory Attributes
    */
   const FATTR4_SUPPORTED_ATTRS    = 0;
   const FATTR4_TYPE               = 1;
   const FATTR4_FH_EXPIRE_TYPE     = 2;
   const FATTR4_CHANGE             = 3;
   const FATTR4_SIZE               = 4;
   const FATTR4_LINK_SUPPORT       = 5;
   const FATTR4_SYMLINK_SUPPORT    = 6;
   const FATTR4_NAMED_ATTR         = 7;
   const FATTR4_FSID               = 8;
   const FATTR4_UNIQUE_HANDLES     = 9;
   const FATTR4_LEASE_TIME         = 10;
   const FATTR4_RDATTR_ERROR       = 11;
   const FATTR4_FILEHANDLE         = 19;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Recommended Attributes
    */
   const FATTR4_ACL                = 12;
   const FATTR4_ACLSUPPORT         = 13;
   const FATTR4_ARCHIVE            = 14;
   const FATTR4_CANSETTIME         = 15; const FATTR4_CASE_INSENSITIVE   = 16;
   const FATTR4_CASE_PRESERVING    = 17;
   const FATTR4_CHOWN_RESTRICTED   = 18;
   const FATTR4_FILEID             = 20;
   const FATTR4_FILES_AVAIL        = 21;
   const FATTR4_FILES_FREE         = 22;
   const FATTR4_FILES_TOTAL        = 23;
   const FATTR4_FS_LOCATIONS       = 24;
   const FATTR4_HIDDEN             = 25;
   const FATTR4_HOMOGENEOUS        = 26;
   const FATTR4_MAXFILESIZE        = 27;
   const FATTR4_MAXLINK            = 28;
   const FATTR4_MAXNAME            = 29;
   const FATTR4_MAXREAD            = 30;
   const FATTR4_MAXWRITE           = 31;
   const FATTR4_MIMETYPE           = 32;
   const FATTR4_MODE               = 33;
   const FATTR4_NO_TRUNC           = 34;
   const FATTR4_NUMLINKS           = 35;
   const FATTR4_OWNER              = 36;
   const FATTR4_OWNER_GROUP        = 37;
   const FATTR4_QUOTA_AVAIL_HARD   = 38;
   const FATTR4_QUOTA_AVAIL_SOFT   = 39;
   const FATTR4_QUOTA_USED         = 40;
   const FATTR4_RAWDEV             = 41;
   const FATTR4_SPACE_AVAIL        = 42;
   const FATTR4_SPACE_FREE         = 43;
   const FATTR4_SPACE_TOTAL        = 44;
   const FATTR4_SPACE_USED         = 45;
   const FATTR4_SYSTEM             = 46;
   const FATTR4_TIME_ACCESS        = 47;
   const FATTR4_TIME_ACCESS_SET    = 48;
   const FATTR4_TIME_BACKUP        = 49;
   const FATTR4_TIME_CREATE        = 50;
   const FATTR4_TIME_DELTA         = 51;
   const FATTR4_TIME_METADATA      = 52;
   const FATTR4_TIME_MODIFY        = 53;
   const FATTR4_TIME_MODIFY_SET    = 54;
   const FATTR4_MOUNTED_ON_FILEID  = 55;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef opaque attrlist4&lt;&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明attrlist4のtypedef &lt;&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * File attribute container
    */
   struct fattr4 {
           bitmap4         attrmask;
           attrlist4       attr_vals;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Change info for the client
    */
   struct change_info4 {
           bool            atomic;
           changeid4       before;
           changeid4       after;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct clientaddr4 {
           /* see struct rpcb in RFC 1833 */
           string r_netid&lt;&gt;;               /* network id */
           string r_addr&lt;&gt;;                /* universal address */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Callback program info as provided by the client
    */
   struct cb_client4 {
           uint32_t        cb_program;
           clientaddr4     cb_location;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Stateid
    */
   struct stateid4 {
           uint32_t        seqid;
           opaque          other[12];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Client ID
    */
   struct nfs_client_id4 {
           verifier4       verifier;
           opaque          id&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_owner4 {
           clientid4       clientid;
           opaque          owner&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct lock_owner4 {
           clientid4       clientid; opaque          owner&lt;NFS4_OPAQUE_LIMIT&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum nfs_lock_type4 {
           READ_LT         = 1,
           WRITE_LT        = 2,
           READW_LT        = 3,    /* blocking read */
           WRITEW_LT       = 4     /* blocking write */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * ACCESS: Check access permission
    */
   const ACCESS4_READ      = 0x00000001;
   const ACCESS4_LOOKUP    = 0x00000002;
   const ACCESS4_MODIFY    = 0x00000004;
   const ACCESS4_EXTEND    = 0x00000008;
   const ACCESS4_DELETE    = 0x00000010;
   const ACCESS4_EXECUTE   = 0x00000020;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4args {
           /* CURRENT_FH: object */
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ACCESS4resok {
           uint32_t        supported;
           uint32_t        access;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union ACCESS4res switch (nfsstat4 status) {
    case NFS4_OK:
            ACCESS4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CLOSE: Close a file and release share reservations
    */
   struct CLOSE4args {
           /* CURRENT_FH: object */
           seqid4          seqid;
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
union CLOSE4res switch (nfsstat4 status) { case NFS4_OK:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
組合CLOSE4resは（nfsstat4状態）{ケースNFS4_OKを切り替えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            stateid4       open_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * COMMIT: Commit cached data on server to stable storage
    */
   struct COMMIT4args {
           /* CURRENT_FH: file */
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMMIT4resok {
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union COMMIT4res switch (nfsstat4 status) {
    case NFS4_OK:
            COMMIT4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CREATE: Create a non-regular file
    */
   union createtype4 switch (nfs_ftype4 type) {
    case NF4LNK:
            linktext4      linkdata;
    case NF4BLK:
    case NF4CHR:
            specdata4      devdata;
    case NF4SOCK:
    case NF4FIFO:
    case NF4DIR:
            void;
    default:
            void;          /* server should return NFS4ERR_BADTYPE */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4args {
           /* CURRENT_FH: directory for creation */
           createtype4     objtype;
           component4      objname;
           fattr4          createattrs;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CREATE4resok {
           change_info4    cinfo;
           bitmap4         attrset;        /* attributes set */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CREATE4res switch (nfsstat4 status) {
    case NFS4_OK:
            CREATE4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * DELEGPURGE: Purge Delegations Awaiting Recovery
    */
   struct DELEGPURGE4args {
           clientid4       clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGPURGE4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * DELEGRETURN: Return a delegation
    */
   struct DELEGRETURN4args {
           /* CURRENT_FH: delegated file */
           stateid4        deleg_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct DELEGRETURN4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * GETATTR: Get file attributes
    */
   struct GETATTR4args {
           /* CURRENT_FH: directory or file */
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct GETATTR4resok {
           fattr4          obj_attributes;
   }; union GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            GETATTR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * GETFH: Get current filehandle
    */
   struct GETFH4resok {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union GETFH4res switch (nfsstat4 status) {
    case NFS4_OK:
           GETFH4resok     resok4;
    default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LINK: Create link to an object
    */
   struct LINK4args {
           /* SAVED_FH: source object */
           /* CURRENT_FH: target directory */
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LINK4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, transition from open_owner to new lock_owner
    */
   struct open_to_lock_owner4 {
           seqid4          open_seqid;
           stateid4        open_stateid;
           seqid4          lock_seqid; lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * For LOCK, existing lock_owner continues to request file locks
    */
   struct exist_lock_owner4 {
           stateid4        lock_stateid;
           seqid4          lock_seqid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union locker4 switch (bool new_lock_owner) {
    case TRUE:
           open_to_lock_owner4     open_owner;
    case FALSE:
           exist_lock_owner4       lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LOCK/LOCKT/LOCKU: Record lock management
    */
   struct LOCK4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           bool            reclaim;
           offset4         offset;
           length4         length;
           locker4         locker;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4denied {
           offset4         offset;
           length4         length;
           nfs_lock_type4  locktype;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCK4resok {
           stateid4        lock_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCK4res switch (nfsstat4 status) {
    case NFS4_OK:
            LOCK4resok     resok4;
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    default:
            void;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKT4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           offset4         offset;
           length4         length;
           lock_owner4     owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKT4res switch (nfsstat4 status) {
    case NFS4ERR_DENIED:
            LOCK4denied    denied;
    case NFS4_OK:
            void;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOCKU4args {
           /* CURRENT_FH: file */
           nfs_lock_type4  locktype;
           seqid4          seqid;
           stateid4        lock_stateid;
           offset4         offset;
           length4         length;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union LOCKU4res switch (nfsstat4 status) {
    case   NFS4_OK:
            stateid4       lock_stateid;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LOOKUP: Lookup filename
    */
   struct LOOKUP4args {
           /* CURRENT_FH: directory */
           component4      objname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct LOOKUP4res {
           /* CURRENT_FH: object */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * LOOKUPP: Lookup parent directory
    */
   struct LOOKUPP4res {
           /* CURRENT_FH: directory */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * NVERIFY: Verify attributes different
    */
   struct NVERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct NVERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Various definitions for OPEN
    */
   enum createmode4 {
           UNCHECKED4      = 0,
           GUARDED4        = 1,
           EXCLUSIVE4      = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union createhow4 switch (createmode4 mode) {
    case UNCHECKED4:
    case GUARDED4:
            fattr4         createattrs;
    case EXCLUSIVE4:
            verifier4      createverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum opentype4 { OPEN4_NOCREATE = 0, OPEN4_CREATE = 1 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙opentype4 {OPEN4_NOCREATE = 0、OPEN4_CREATE = 1}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union openflag4 switch (opentype4 opentype) {
    case OPEN4_CREATE:
            createhow4     how;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Next definitions used for OPEN delegation */
   enum limit_by4 {
           NFS_LIMIT_SIZE          = 1,
           NFS_LIMIT_BLOCKS        = 2
           /* others as needed */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nfs_modified_limit4 {
           uint32_t        num_blocks;
           uint32_t        bytes_per_block;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_space_limit4 switch (limit_by4 limitby) {
    /* limit specified as file size */
    case NFS_LIMIT_SIZE:
            uint64_t               filesize;
    /* limit specified by number of blocks */
    case NFS_LIMIT_BLOCKS:
            nfs_modified_limit4    mod_blocks;
   } ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Share Access and Deny constants for open argument
    */
   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;
   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;
   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   const OPEN4_SHARE_DENY_NONE     = 0x00000000;
   const OPEN4_SHARE_DENY_READ     = 0x00000001;
   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;
   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum open_delegation_type4 { OPEN_DELEGATE_NONE = 0, OPEN_DELEGATE_READ = 1, OPEN_DELEGATE_WRITE = 2 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙open_delegation_type4 {OPEN_DELEGATE_NONE = 0、OPEN_DELEGATE_READ = 1、OPEN_DELEGATE_WRITE = 2}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum open_claim_type4 { CLAIM_NULL = 0, CLAIM_PREVIOUS = 1, CLAIM_DELEGATE_CUR = 2, CLAIM_DELEGATE_PREV = 3 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙open_claim_type4 {CLAIM_NULL = 0、CLAIM_PREVIOUS = 1、CLAIM_DELEGATE_CUR = 2、CLAIM_DELEGATE_PREV = 3}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_claim_delegate_cur4 {
           stateid4        delegate_stateid; component4      file;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_claim4 switch (open_claim_type4 claim) {
    /*
     * No special rights to file. Ordinary OPEN of the specified file.
     */
    case CLAIM_NULL:
           /* CURRENT_FH: directory */
           component4      file;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to the file established by an open previous to server
     * reboot.  File identified by filehandle obtained at that time
     * rather than by name.
     */
    case CLAIM_PREVIOUS:
           /* CURRENT_FH: file being reclaimed */
           open_delegation_type4   delegate_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /*
     * Right to file based on a delegation granted by the server.
     * File is specified by name.
     */
    case CLAIM_DELEGATE_CUR:
           /* CURRENT_FH: directory */
           open_claim_delegate_cur4        delegate_cur_info;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* Right to file based on a delegation granted to a previous boot
     * instance of the client.  File is specified by name.
     */
    case CLAIM_DELEGATE_PREV:
            /* CURRENT_FH: directory */
           component4      file_delegate_prev;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPEN: Open a file, potentially receiving an open delegation
    */
   struct OPEN4args {
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
           open_owner4     owner;
           openflag4       openhow;
           open_claim4     claim;
   }; struct open_read_delegation4 {
           stateid4        stateid;        /* Stateid for delegation*/
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfsace4         permissions;    /* Defines users who don&#39;t
                                              need an ACCESS call to
                                              open for read */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct open_write_delegation4 {
           stateid4        stateid;        /* Stateid for delegation */
           bool            recall;         /* Pre-recalled flag for
                                              delegations obtained
                                              by reclaim
                                              (CLAIM_PREVIOUS) */
           nfs_space_limit4 space_limit;   /* Defines condition that
                                              the client must check to
                                              determine whether the
                                              file needs to be flushed
                                              to the server on close.
                                              */
           nfsace4         permissions;    /* Defines users who don&#39;t
                                              need an ACCESS call as
                                              part of a delegated
                                              open. */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union open_delegation4
   switch (open_delegation_type4 delegation_type) {
           case OPEN_DELEGATE_NONE:
                   void;
           case OPEN_DELEGATE_READ:
                   open_read_delegation4 read;
           case OPEN_DELEGATE_WRITE:
                   open_write_delegation4 write;
   };
   /*
    * Result flags
    */
   /* Client must confirm open */
   const OPEN4_RESULT_CONFIRM      = 0x00000002;
   /* Type of file locking behavior at the server */
   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN4resok {
           stateid4        stateid;        /* Stateid for open */ change_info4    cinfo;          /* Directory Change Info */
           uint32_t        rflags;         /* Result flags */
           bitmap4         attrset;        /* attribute set for create*/
           open_delegation4 delegation;    /* Info on any open
                                              delegation */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN4res switch (nfsstat4 status) {
    case NFS4_OK:
           /* CURRENT_FH: opened file */
           OPEN4resok      resok4;
    default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPENATTR: open named attributes directory
    */
   struct OPENATTR4args {
           /* CURRENT_FH: object */
           bool    createdir;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPENATTR4res {
           /* CURRENT_FH: named attr directory */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPEN_CONFIRM: confirm the open
    */
   struct OPEN_CONFIRM4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_CONFIRM4resok {
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN_CONFIRM4res switch (nfsstat4 status) {
       case NFS4_OK:
               OPEN_CONFIRM4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * OPEN_DOWNGRADE: downgrade the access/deny for a file
    */
   struct OPEN_DOWNGRADE4args {
           /* CURRENT_FH: opened file */
           stateid4        open_stateid;
           seqid4          seqid;
           uint32_t        share_access;
           uint32_t        share_deny;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct OPEN_DOWNGRADE4resok {
           stateid4        open_stateid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union OPEN_DOWNGRADE4res switch(nfsstat4 status) {
    case NFS4_OK:
           OPEN_DOWNGRADE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * PUTFH: Set current filehandle
    */
   struct PUTFH4args {
           nfs_fh4         object;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct PUTFH4res {
           /* CURRENT_FH: */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * PUTPUBFH: Set public filehandle
    */
   struct PUTPUBFH4res {
           /* CURRENT_FH: public fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * PUTROOTFH: Set root filehandle
    */
   struct PUTROOTFH4res {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /* CURRENT_FH: root fh */ nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * READ: Read from file
    */
   struct READ4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           count4          count;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct READ4resok {
           bool            eof;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READ4res switch (nfsstat4 status) {
    case NFS4_OK:
            READ4resok     resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * READDIR: Read directory
    */
   struct READDIR4args {
           /* CURRENT_FH: directory */
           nfs_cookie4     cookie;
           verifier4       cookieverf;
           count4          dircount;
           count4          maxcount;
           bitmap4         attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct entry4 {
           nfs_cookie4     cookie;
           component4      name;
           fattr4          attrs;
           entry4          *nextentry;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dirlist4 {
           entry4          *entries;
           bool            eof;
   }; struct READDIR4resok {
           verifier4       cookieverf;
           dirlist4        reply;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READDIR4res switch (nfsstat4 status) {
    case NFS4_OK:
            READDIR4resok  resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * READLINK: Read symbolic link
    */
   struct READLINK4resok {
           linktext4       link;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union READLINK4res switch (nfsstat4 status) {
    case NFS4_OK:
            READLINK4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * REMOVE: Remove filesystem object
    */
   struct REMOVE4args {
           /* CURRENT_FH: directory */
           component4      target;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct REMOVE4resok {
           change_info4    cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union REMOVE4res switch (nfsstat4 status) {
    case NFS4_OK:
            REMOVE4resok   resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    * RENAME: Rename directory entry
    */
   struct RENAME4args {
           /* SAVED_FH: source directory */
           component4      oldname;
           /* CURRENT_FH: target directory */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           component4      newname;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENAME4resok {
           change_info4    source_cinfo;
           change_info4    target_cinfo;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union RENAME4res switch (nfsstat4 status) {
    case NFS4_OK:
           RENAME4resok    resok4;
    default:
           void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * RENEW: Renew a Lease
    */
   struct RENEW4args {
           clientid4       clientid;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RENEW4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * RESTOREFH: Restore saved filehandle
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RESTOREFH4res {
           /* CURRENT_FH: value of saved fh */
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * SAVEFH: Save current filehandle
    */
   struct SAVEFH4res {
           /* SAVED_FH: value of current fh */
           nfsstat4        status;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * SECINFO: Obtain Available Security Mechanisms
    */
   struct SECINFO4args {
           /* CURRENT_FH: directory */
           component4      name;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 * From RFC 2203 */ enum rpc_gss_svc_t { RPC_GSS_SVC_NONE = 1, RPC_GSS_SVC_INTEGRITY = 2, RPC_GSS_SVC_PRIVACY = 3 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* RFC 2203から* /列挙rpc_gss_svc_t {RPC_GSS_SVC_NONE = 1、RPC_GSS_SVC_INTEGRITY = 2、RPC_GSS_SVC_PRIVACY = 3}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rpcsec_gss_info {
           sec_oid4        oid;
           qop4            qop;
           rpc_gss_svc_t   service;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* RPCSEC_GSS has a value of &#39;6&#39; - See RFC 2203 */
   union secinfo4 switch (uint32_t flavor) {
    case RPCSEC_GSS:
            rpcsec_gss_info        flavor_info;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef secinfo4 SECINFO4resok&lt;&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedefのsecinfo4 SECINFO4resok &lt;&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SECINFO4res switch (nfsstat4 status) {
    case NFS4_OK:
            SECINFO4resok resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * SETATTR: Set attributes
    */
   struct SETATTR4args {
           /* CURRENT_FH: target object */ stateid4        stateid;
           fattr4          obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETATTR4res {
           nfsstat4        status;
           bitmap4         attrsset;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * SETCLIENTID
    */
   struct SETCLIENTID4args {
           nfs_client_id4  client;
           cb_client4      callback;
           uint32_t        callback_ident;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID4resok {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union SETCLIENTID4res switch (nfsstat4 status) {
    case NFS4_OK:
            SETCLIENTID4resok      resok4;
    case NFS4ERR_CLID_INUSE:
            clientaddr4    client_using;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID_CONFIRM4args {
           clientid4       clientid;
           verifier4       setclientid_confirm;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct SETCLIENTID_CONFIRM4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * VERIFY: Verify attributes same
    */
   struct VERIFY4args {
           /* CURRENT_FH: object */
           fattr4          obj_attributes;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct VERIFY4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * WRITE: Write to file
    */
   enum stable_how4 {
           UNSTABLE4       = 0,
           DATA_SYNC4      = 1,
           FILE_SYNC4      = 2
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4args {
           /* CURRENT_FH: file */
           stateid4        stateid;
           offset4         offset;
           stable_how4     stable;
           opaque          data&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct WRITE4resok {
           count4          count;
           stable_how4     committed;
           verifier4       writeverf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union WRITE4res switch (nfsstat4 status) {
    case NFS4_OK:
            WRITE4resok    resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * RELEASE_LOCKOWNER: Notify server to release lockowner
    */
   struct RELEASE_LOCKOWNER4args {
           lock_owner4     lock_owner;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct RELEASE_LOCKOWNER4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    * ILLEGAL: Response for illegal operation numbers
    */
   struct ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Operation arrays
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enum nfs_opnum4 { OP_ACCESS = 3, OP_CLOSE = 4, OP_COMMIT = 5, OP_CREATE = 6, OP_DELEGPURGE = 7, OP_DELEGRETURN = 8, OP_GETATTR = 9, OP_GETFH = 10, OP_LINK = 11, OP_LOCK = 12, OP_LOCKT = 13, OP_LOCKU = 14, OP_LOOKUP = 15, OP_LOOKUPP = 16, OP_NVERIFY = 17, OP_OPEN = 18, OP_OPENATTR = 19, OP_OPEN_CONFIRM = 20, OP_OPEN_DOWNGRADE = 21, OP_PUTFH = 22, OP_PUTPUBFH = 23, OP_PUTROOTFH = 24, OP_READ = 25, OP_READDIR = 26, OP_READLINK = 27, OP_REMOVE = 28, OP_RENAME = 29, OP_RENEW = 30, OP_RESTOREFH = 31, OP_SAVEFH = 32, OP_SECINFO = 33, OP_SETATTR = 34, OP_SETCLIENTID = 35, OP_SETCLIENTID_CONFIRM = 36, OP_VERIFY = 37, OP_WRITE = 38, OP_RELEASE_LOCKOWNER = 39,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙nfs_opnum4 {OP_ACCESS = 3、OP_CLOSE = 4、OP_COMMIT = 5、OP_CREATE = 6、OP_DELEGPURGE = 7、OP_DELEGRETURN = 8、OP_GETATTR = 9、OP_GETFH = 10、OP_LINK = 11、OP_LOCK = 12、OP_LOCKT = 13、OP_LOCKU = 14 、OP_LOOKUP = 15、OP_LOOKUPP = 16、OP_NVERIFY = 17、OP_OPEN = 18、OP_OPENATTR = 19、OP_OPEN_CONFIRM = 20、OP_OPEN_DOWNGRADE = 21、OP_PUTFH = 22、OP_PUTPUBFH = 23、OP_PUTROOTFH = 24、OP_READ = 25、OP_READDIR = 26、OP_READLINK = 27、OP_REMOVE = 28、OP_RENAME = 29、OP_RENEW = 30、OP_RESTOREFH = 31、OP_SAVEFH = 32、OP_SECINFO = 33、OP_SETATTR = 34、OP_SETCLIENTID = 35、OP_SETCLIENTID_CONFIRM = 36、OP_VERIFY = 37、OP_WRITE = 38、OP_RELEASE_LOCKOWNER = 39 、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 OP_ILLEGAL = 10044 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OP_ILLEGAL = 10044}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_argop4 switch (nfs_opnum4 argop) {
    case OP_ACCESS:        ACCESS4args opaccess;
    case OP_CLOSE:         CLOSE4args opclose;
    case OP_COMMIT:        COMMIT4args opcommit;
    case OP_CREATE:        CREATE4args opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4args opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;
    case OP_GETATTR:       GETATTR4args opgetattr;
    case OP_GETFH:         void;
    case OP_LINK:          LINK4args oplink;
    case OP_LOCK:          LOCK4args oplock;
    case OP_LOCKT:         LOCKT4args oplockt;
    case OP_LOCKU:         LOCKU4args oplocku;
    case OP_LOOKUP:        LOOKUP4args oplookup;
    case OP_LOOKUPP:       void;
    case OP_NVERIFY:       NVERIFY4args opnverify;
    case OP_OPEN:          OPEN4args opopen;
    case OP_OPENATTR:      OPENATTR4args opopenattr;
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4args opopen_confirm;
    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4args opopen_downgrade;
    case OP_PUTFH:         PUTFH4args opputfh;
    case OP_PUTPUBFH:      void;
    case OP_PUTROOTFH:     void;
    case OP_READ:          READ4args opread;
    case OP_READDIR:       READDIR4args opreaddir;
    case OP_READLINK:      void;
    case OP_REMOVE:        REMOVE4args opremove;
    case OP_RENAME:        RENAME4args oprename;
    case OP_RENEW:         RENEW4args oprenew;
    case OP_RESTOREFH:     void;
    case OP_SAVEFH:        void;
    case OP_SECINFO:       SECINFO4args opsecinfo;
    case OP_SETATTR:       SETATTR4args opsetattr;
    case OP_SETCLIENTID:   SETCLIENTID4args opsetclientid;
    case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4args
                                           opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4args opverify;
    case OP_WRITE:         WRITE4args opwrite;
    case OP_RELEASE_LOCKOWNER:     RELEASE_LOCKOWNER4args
                                       oprelease_lockowner;
    case OP_ILLEGAL:       void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_resop4 switch (nfs_opnum4 resop){
    case OP_ACCESS:        ACCESS4res opaccess; case OP_CLOSE:         CLOSE4res opclose;
    case OP_COMMIT:        COMMIT4res opcommit;
    case OP_CREATE:        CREATE4res opcreate;
    case OP_DELEGPURGE:    DELEGPURGE4res opdelegpurge;
    case OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;
    case OP_GETATTR:       GETATTR4res opgetattr;
    case OP_GETFH:         GETFH4res opgetfh;
    case OP_LINK:          LINK4res oplink;
    case OP_LOCK:          LOCK4res oplock;
    case OP_LOCKT:         LOCKT4res oplockt;
    case OP_LOCKU:         LOCKU4res oplocku;
    case OP_LOOKUP:        LOOKUP4res oplookup;
    case OP_LOOKUPP:       LOOKUPP4res oplookupp;
    case OP_NVERIFY:       NVERIFY4res opnverify;
    case OP_OPEN:          OPEN4res opopen;
    case OP_OPENATTR:      OPENATTR4res opopenattr;
    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4res opopen_confirm;
    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4res opopen_downgrade;
    case OP_PUTFH:         PUTFH4res opputfh;
    case OP_PUTPUBFH:      PUTPUBFH4res opputpubfh;
    case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;
    case OP_READ:          READ4res opread;
    case OP_READDIR:       READDIR4res opreaddir;
    case OP_READLINK:      READLINK4res opreadlink;
    case OP_REMOVE:        REMOVE4res opremove;
    case OP_RENAME:        RENAME4res oprename;
    case OP_RENEW:         RENEW4res oprenew;
    case OP_RESTOREFH:     RESTOREFH4res oprestorefh;
    case OP_SAVEFH:        SAVEFH4res opsavefh;
    case OP_SECINFO:       SECINFO4res opsecinfo;
    case OP_SETATTR:       SETATTR4res opsetattr;
    case OP_SETCLIENTID:   SETCLIENTID4res opsetclientid;
    case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4res
                                           opsetclientid_confirm;
    case OP_VERIFY:        VERIFY4res opverify;
    case OP_WRITE:         WRITE4res opwrite;
    case OP_RELEASE_LOCKOWNER:     RELEASE_LOCKOWNER4res
                                       oprelease_lockowner;
    case OP_ILLEGAL:       ILLEGAL4res opillegal;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           nfs_argop4      argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
struct COMPOUND4res {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体COMPOUND4res {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           nfsstat4 status;
           utf8str_cs      tag;
           nfs_resop4      resarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Remote file service routines
    */
   program NFS4_PROGRAM {
           version NFS_V4 {
                   void
                           NFSPROC4_NULL(void) = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   COMPOUND4res
                           NFSPROC4_COMPOUND(COMPOUND4args) = 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           } = 4;
   } = 100003;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * NFS4 Callback Procedure Definitions and Program
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CB_GETATTR: Get Current Attributes
    */
   struct CB_GETATTR4args {
           nfs_fh4 fh;
           bitmap4 attr_request;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_GETATTR4resok {
           fattr4  obj_attributes;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union CB_GETATTR4res switch (nfsstat4 status) {
    case NFS4_OK:
            CB_GETATTR4resok       resok4;
    default:
            void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CB_RECALL: Recall an Open Delegation
    */
   struct CB_RECALL4args {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           stateid4        stateid;
           bool            truncate;
           nfs_fh4         fh;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_RECALL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * CB_ILLEGAL: Response for illegal operation numbers
    */
   struct CB_ILLEGAL4res {
           nfsstat4        status;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Various definitions for CB_COMPOUND
    */
   enum nfs_cb_opnum4 {
           OP_CB_GETATTR           = 3,
           OP_CB_RECALL            = 4,
           OP_CB_ILLEGAL           = 10044
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_argop4 switch (unsigned argop) {
    case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4args  opcbrecall;
    case OP_CB_ILLEGAL:    void;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   union nfs_cb_resop4 switch (unsigned resop){
    case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;
    case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;
    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4args {
           utf8str_cs      tag;
           uint32_t        minorversion;
           uint32_t        callback_ident;
           nfs_cb_argop4   argarray&lt;&gt;;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct CB_COMPOUND4res {
           nfsstat4 status;
           utf8str_cs      tag;
           nfs_cb_resop4   resarray&lt;&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
｝；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Program number is in the transient range since the client
    * will assign the exact transient program number and provide
    * that to the server via the SETCLIENTID operation.
    */
   program NFS4_CALLBACK {
           version NFS_CB {
                   void
                           CB_NULL(void) = 0;
                   CB_COMPOUND4res
                           CB_COMPOUND(CB_COMPOUND4args) = 1;
           } = 1;
   } = 0x40000000;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors thank and acknowledge:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作者は感謝と認めます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neil Brown for his extensive review and comments of various documents. Rick Macklem at the University of Guelph, Mike Frisch, Sergey Klyushin, and Dan Trufasiu of Hummingbird Ltd., and Andy Adamson, Bruce Fields, Jim Rees, and Kendrick Smith from the CITI organization at the University of Michigan, for their implementation efforts and feedback on the protocol specification. Mike Kupfer for his review of the file locking and ACL mechanisms. Alan Yoder for his input to ACL mechanisms. Peter Astrand for his close review of the protocol specification. Ran Atkinson for his constant reminder that users do matter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼の豊富なレビューと様々な文書のコメントのためのニール・ブラウン。グエルフ、マイク・フリッシュ、セルゲイKlyushin大学のリックMacklem、及びハミングバード社のダンTrufasiu、そしてアンディ・アダムソン、ブルース・フィールズ、ジム・リース、及びその実施の努力のためのミシガン大学のCITI組織からケンドリック・スミス、およびプロトコル仕様へのフィードバック。ファイルのロックとACLのメカニズムの彼のレビューのためのマイク・クッパー。 ACLメカニズムへの彼の入力のためのアランYoderの。プロトコル仕様の彼の密接なレビューのためのピーターAstrand。ユーザーは重要ではないことを彼の一定のリマインダーのためのアトキンソンを走りました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISO10646] &#34;ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS) -- Part 1: Architecture and Basic Multilingual Plane.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISO10646]「ISO / IEC 10646-1：1993国際規格 - 情報技術 - ユニバーサルマルチオクテット符号化文字セット（UCS） - 第1部：アーキテクチャと基本多言語面」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1831] Srinivasan, R., &#34;RPC: Remote Procedure Call Protocol Specification Version 2&#34;, RFC 1831, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1831]スリニバサン、R.、 &#34;RPC：リモートプロシージャコールプロトコル仕様バージョン2&#34;、RFC 1831、1995年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1832] Srinivasan, R., &#34;XDR: External Data Representation Standard&#34;, RFC 1832, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1832]スリニバサン、R.、 &#34;XDR：外部データ表現標準&#34;、RFC 1832、1995年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2373] Hinden, R. and S. Deering, &#34;IP Version 6 Addressing Architecture&#34;, RFC 2373, July 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2373] HindenとR.とS.デアリング、 &#34;IPバージョン6アドレッシング体系&#34;、RFC 2373、1998年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1964] Linn, J., &#34;The Kerberos Version 5 GSS-API Mechanism&#34;, RFC 1964, June 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1964]リン、J.、 &#34;Kerberosバージョン5 GSS-APIメカニズム&#34;、RFC 1964、1996年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2025] Adams, C., &#34;The Simple Public-Key GSS-API Mechanism (SPKM)&#34;, RFC 2025, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2025]アダムス、C.、 &#34;単純な公開鍵GSS-APIメカニズム（SPKM）&#34;、RFC 2025、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2203] Eisler, M., Chiu, A. and L. Ling, &#34;RPCSEC_GSS Protocol Specification&#34;, RFC 2203, September 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2203]アイスラー、M.、チウ、A.及びL.リン、 &#34;RPCSEC_GSSプロトコル仕様&#34;、RFC 2203、1997年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2277] Alvestrand, H., &#34;IETF Policy on Character Sets and Languages&#34;, BCP 19, RFC 2277, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2277] Alvestrand、H.、 &#34;文字セットと言語のIETF方針&#34;、BCP 19、RFC 2277、1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2279] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, RFC 2279, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2279] Yergeau、F.、 &#34;UTF-8、ISO 10646の変換フォーマット&#34;、RFC 2279、1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2623] Eisler, M., &#34;NFS Version 2 and Version 3 Security Issues and the NFS Protocol&#39;s Use of RPCSEC_GSS and Kerberos V5&#34;, RFC 2623, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2623]アイスラー、M.、 &#34;NFSバージョン2およびバージョン3のセキュリティ問題とRPCSEC_GSSとケルベロスV5のNFSプロトコルの使用&#34;、RFC 2623、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743] Linn, J., &#34;Generic Security Service Application Program Interface, Version 2, Update 1&#34;, RFC 2743, January 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743]リン、J.、 &#34;ジェネリックセキュリティーサービス適用業務プログラムインタフェース、バージョン2、アップデート1&#34;、RFC 2743、2000年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2847] Eisler, M., &#34;LIPKEY - A Low Infrastructure Public Key Mechanism Using SPKM&#34;, RFC 2847, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2847]アイスラー、M.、 &#34;LIPKEY  -  SPKMを用いた低インフラストラクチャ公開鍵メカニズム&#34;、RFC 2847、2000年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3010] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M. and D. Noveck, &#34;NFS version 4 Protocol&#34;, RFC 3010, December 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3010] Shepler、S.、キャラハン、B.、ロビンソン、D.、Thurlow、R.、Beame、C.、アイスラー、M.とD. Noveck、 &#34;NFSバージョン4プロトコル&#34;、RFC 3010、2000年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3454] Hoffman, P. and P. Blanchet, &#34;Preparation of Internationalized Strings (&#34;stringprep&#34;)&#34;, RFC 3454, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3454]ホフマン、P.及びP.ブランシェ、 &#34;国際化された文字列の調製（&#34; 文字列準備 &#34;）&#34;、RFC 3454、2002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Unicode1] The Unicode Consortium, &#34;The Unicode Standard, Version 3.0&#34;, Addison-Wesley Developers Press, Reading, MA, 2000. ISBN 0-201-61633-5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Unicode1]はUnicodeコンソーシアム、 &#34;Unicode標準、バージョン3.0&#34;、アディソン・ウェズリー開発押し、読書、MA、2000年ISBN 0-201-61633-5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             More information available at:
                             http://www.unicode.org/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Unicode2] &#34;Unsupported Scripts&#34; Unicode, Inc., The Unicode Consortium, P.O. Box 700519, San Jose, CA 95710-0519 USA, September 1999. http://www.unicode.org/unicode/standard/ unsupported.html
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Unicode2] &#34;サポートされていないスクリプト&#34; のUnicode、Inc.の、ユニコードコンソーシアム、P。箱700519、サンノゼ、CA 95710から0519 USA、1999年9月http://www.unicode.org/unicode/standard/ unsupported.html
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Floyd] S. Floyd, V. Jacobson, &#34;The Synchronization of Periodic Routing Messages,&#34; IEEE/ACM Transactions on Networking, 2(2), pp. 122- 136, April 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[フロイド] S.フロイド、V. Jacobsonの &#34;周期的ルーティングメッセージの同期、&#34; ネットワーク上のIEEE / ACMトランザクション、2（2）、PP。122- 136、1994年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Gray] C. Gray, D. Cheriton, &#34;Leases: An Efficient Fault-Tolerant Mechanism for Distributed File Cache Consistency,&#34; Proceedings of the Twelfth Symposium on Operating Systems Principles, p. 202-210, December 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[グレー] C.グレー、D. Cheriton、「リース：分散ファイルキャッシュの一貫性のための効率的なフォールトトレラントメカニズム、」オペレーティングシステムの原理、P上の十二シンポジウム。 202〜210、1989年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Juszczak] Juszczak, Chet, &#34;Improving the Performance and Correctness of an NFS Server,&#34; USENIX Conference Proceedings, USENIX Association, Berkeley, CA, June 1990, pages 53-63. Describes reply cache implementation that avoids work in the server by handling duplicate requests. More important, though listed as a side-effect, the reply cache aids in the avoidance of destructive non-idempotent operation re-application -- improving correctness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Juszczak] Juszczak、チェット、 &#34;NFSサーバーのパフォーマンスと正確性を向上させる、&#34; USENIX会議議事録、USENIX協会、バークレー、CA、1990年6月、ページ53-63。重複した要求を処理することにより、サーバでの作業を回避し、応答キャッシュの実装は説明しています。より重要な、副作用、破壊的非冪等の操作の再塗布の回避に応答キャッシュ助剤として記載されているものの - 改善正当。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Kazar] Kazar, Michael Leon, &#34;Synchronization and Caching Issues in the Andrew File System,&#34; USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Dallas Winter 1988, pages 27-36. A description of the cache consistency scheme in AFS. Contrasted with other distributed file systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Kazar] Kazar、マイケル・レオン、「アンドリュー・ファイル・システムにおける同期とキャッシュ関連の問題、」USENIX会議議事録、USENIX協会、バークレー、CA、ダラス冬1988年、ページ27-36。 AFSでのキャッシュの整合性スキームの説明。他の分散ファイルシステムとは対照的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Macklem] Macklem, Rick, &#34;Lessons Learned Tuning the 4.3BSD Reno Implementation of the NFS Protocol,&#34; Winter USENIX Conference Proceedings, USENIX Association, Berkeley, CA, January 1991. Describes performance work in tuning the 4.3BSD Reno NFS implementation. Describes performance improvement (reduced CPU loading) through elimination of data copies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Macklem] Macklem、リック、「レッスンはチューニングにNFSプロトコルの4.3BSDリノの実装を学んだ、」冬のUSENIX会議議事録、USENIX協会、バークレー、CAは、1991年1月には、4.3BSDレノNFSの実装をチューニングしてパフォーマンスの作業について説明します。データ・コピーの除去を介してパフォーマンスの改善（減少CPU負荷）が記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Mogul] Mogul, Jeffrey C., &#34;A Recovery Protocol for Spritely NFS,&#34; USENIX File System Workshop Proceedings, Ann Arbor, MI, USENIX Association, Berkeley, CA, May 1992. Second paper on Spritely NFS proposes a lease-based scheme for recovering state of consistency protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Spritely NFS上の[モーグル]モーグル、ジェフリーC.、「Spritely NFS用のリカバリプロトコル、」USENIXファイルシステムのワークショップ議事録、ミシガン州アナーバー、USENIX協会、バークレー、CA、月1992年第二紙は、リースに基づく方式を提案しています一貫性プロトコルの状態を回復します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Nowicki] Nowicki, Bill, &#34;Transport Issues in the Network File System,&#34; ACM SIGCOMM newsletter Computer Communication Review, April 1989. A brief description of the basis for the dynamic retransmission work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Nowicki] Nowicki、ビル、「ネットワーク・ファイル・システムでの交通問題、」ACMのSIGCOMMニュースレターコンピュータコミュニケーションレビュー、1989年4月ダイナミック再送仕事の基礎の簡単な説明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pawlowski] Pawlowski, Brian, Ron Hixon, Mark Stein, Joseph Tumminaro, &#34;Network Computing in the UNIX and IBM Mainframe Environment,&#34; Uniforum `89 Conf. Proc., (1989) Description of an NFS server implementation for IBM&#39;s MVS operating system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「UNIXおよびIBMメインフレーム環境でのネットワーク・コンピューティング、」[ポロウスキー]ポロウスキー、ブライアン、ロン・ヒクソン、マーク・スタイン、ジョセフTumminaro、のUniforum `89コンファレンス。 PROC。、IBMのMVSオペレーティング・システムのためのNFSサーバの実装の（1989）説明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1094] Sun Microsystems, Inc., &#34;NFS: Network File System Protocol Specification&#34;, RFC 1094, March 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1094]サン・マイクロシステムズ社、 &#34;NFS：ネットワークシステムプロトコル仕様書ファイル&#34;、RFC 1094、1989年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1345] Simonsen, K., &#34;Character Mnemonics &amp; Character Sets&#34;, RFC 1345, June 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1345]シモンセン、K.、 &#34;文字ニーモニック＆文字セット&#34;、RFC 1345、1992年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813] Callaghan, B., Pawlowski, B. and P. Staubach, &#34;NFS Version 3 Protocol Specification&#34;, RFC 1813, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1813]キャラハン、B.、ポロウスキー、B.およびP.ストーバック、 &#34;NFSバージョン3プロトコル仕様&#34;、RFC 1813、1995年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3232] Reynolds, J., Editor, &#34;Assigned Numbers: RFC 1700 is Replaced by an On-line Database&#34;, RFC 3232, January 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3232]レイノルズ、J.、エディタは、：、RFC 3232、2002年1月 &#34;割り当て番号RFC 1700は、オンラインデータベースで置き換えられます&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1833] Srinivasan, R., &#34;Binding Protocols for ONC RPC Version 2&#34;, RFC 1833, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1833]スリニバサン、R.、 &#34;ONC RPCバージョン2のプロトコルのバインド&#34;、RFC 1833、1995年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2054] Callaghan, B., &#34;WebNFS Client Specification&#34;, RFC 2054, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2054]キャラハン、B.、 &#34;WebNFSのクライアント仕様&#34;、RFC 2054、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2055] Callaghan, B., &#34;WebNFS Server Specification&#34;, RFC 2055, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2055]キャラハン、B.、 &#34;WebNFSのサーバー仕様&#34;、RFC 2055、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2152] Goldsmith, D. and M. Davis, &#34;UTF-7 A Mail-Safe Transformation Format of Unicode&#34;, RFC 2152, May 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2152]ゴールドスミス、D.とM.デイヴィス、 &#34;ユニコードのUTF-7 Aメールセーフ変換形式&#34;、RFC 2152、1997年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2224] Callaghan, B., &#34;NFS URL Scheme&#34;, RFC 2224, October 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2224]キャラハン、B.、 &#34;NFS URLスキーム&#34;、RFC 2224、1997年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2624] Shepler, S., &#34;NFS Version 4 Design Considerations&#34;, RFC 2624, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2624] Shepler、S.、 &#34;NFSバージョン4の設計上の考慮事項&#34;、RFC 2624、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2755] Chiu, A., Eisler, M. and B. Callaghan, &#34;Security Negotiation for WebNFS&#34; , RFC 2755, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2755]チウ、A.、アイスラー、M.とB.キャラハン、 &#34;WebNFSのためのセキュリティネゴシエーション&#34;、RFC 2755、2000年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sandberg] Sandberg, R., D. Goldberg, S. Kleiman, D. Walsh, B. Lyon, &#34;Design and Implementation of the Sun Network Filesystem,&#34; USENIX Conference Proceedings, USENIX Association, Berkeley, CA, Summer 1985. The basic paper describing the SunOS implementation of the NFS version 2 protocol, and discusses the goals, protocol specification and trade-offs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[サンドバーグ]サンドバーグ、R.、D.ゴールドバーグ、S.クレイマン、D.ウォルシュ、B.リヨン、「日ネットワークファイルシステムの設計と実装、」USENIX会議議事録、USENIX協会、バークレー、CA、夏1985ザ・基本的な紙は、NFSバージョン2プロトコルのSunOSの実装を記述し、目標、プロトコル仕様とトレードオフについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Srinivasan] Srinivasan, V., Jeffrey C. Mogul, &#34;Spritely NFS: Implementation and Performance of Cache Consistency Protocols&#34;, WRL Research Report 89/5, Digital Equipment Corporation Western Research Laboratory, 100 Hamilton Ave., Palo Alto, CA, 94301, May 1989. This paper analyzes the effect of applying a Sprite-like consistency protocol applied to standard NFS. The issues of recovery in a stateful environment are covered in [Mogul].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[スリニバサン]スリニバサン、V.、ジェフリーC.モーグル、「Spritely NFS：キャッシュ一貫性プロトコルの実装と性能」、WRL研究報告5分の89、ディジタル・イクイップメント・コーポレーション西研究所、100ハミルトンアベニュー、パロアルト、CA、 94301、月1989は、本稿では、標準的なNFSに適用スプライト状の一貫性プロトコルを適用した効果を分析します。ステートフル環境の回復の問題は、[ムガール人]で覆われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XNFS] The Open Group, Protocols for Interworking: XNFS, Version 3W, The Open Group, 1010 El Camino Real Suite 380, Menlo Park, CA 94025, ISBN 1-85912-184-5, February 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XNFS]オープングループ、インターワーキングのためのプロトコル：XNFS、バージョン3W、オープングループ、1010年エル・カミノレアルスイート380、メンロパーク、CA 94025、ISBN 1-85912-184-5、1998年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             HTML version available:
                             http://www.opengroup.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. Authors&#39; Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.著者の情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1. Editor&#39;s Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1。編集者の住所
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Spencer Shepler Sun Microsystems, Inc. 7808 Moonflower Drive Austin, Texas 78750
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スペンサーSheplerサン・マイクロシステムズ株式会社7808ムーンフラワードライブオースティン、テキサス州78750
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 512-349-9376 EMail: spencer.shepler@sun.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 512-349-9376電子メール：spencer.shepler@sun.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2。著者のアドレス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carl Beame Hummingbird Ltd.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カールBeameハミングバード株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: beame@bws.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：beame@bws.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Brent Callaghan Sun Microsystems, Inc. 17 Network Circle Menlo Park, CA 94025
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブレントキャラハンサン・マイクロシステムズ株式会社17ネットワークサークルメンロパーク、CA 94025
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 650-786-5067 EMail: brent.callaghan@sun.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 650-786-5067電子メール：brent.callaghan@sun.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mike Eisler 5765 Chase Point Circle Colorado Springs, CO 80919
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイク・アイスラー5765チェイスポイントサークルコロラドスプリングス、CO 80919
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 719-599-9026 EMail: mike@eisler.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 719-599-9026電子メール：mike@eisler.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Noveck Network Appliance 375 Totten Pond Road Waltham, MA 02451
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デビッドNoveckネットワーク・アプライアンス375トッテン池道路ウォルサム、MA 02451
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 781-768-5347 EMail: dnoveck@netapp.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 781-768-5347電子メール：dnoveck@netapp.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Robinson Sun Microsystems, Inc. 5300 Riata Park Court Austin, TX 78727
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デビッド・ロビンソンサン・マイクロシステムズ株式会社5300 Riataパークコートオースティン、TX 78727
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 650-786-5088 EMail: david.robinson@sun.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 650-786-5088電子メール：david.robinson@sun.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robert Thurlow Sun Microsystems, Inc. 500 Eldorado Blvd. Broomfield, CO 80021
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロバート・Thurlowサン・マイクロシステムズ株式会社500エルドラドブールバード。ブルームフィールド、CO 80021
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 650-786-5096 EMail: robert.thurlow@sun.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 650-786-5096電子メール：robert.thurlow@sun.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23.完全な著作権声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
