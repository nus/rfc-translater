<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 6234 - US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6234</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6234 - US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc6234">
              https://tools.ietf.org/html/rfc6234
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6234 - 米国セキュアハッシュアルゴリズム（SHAとSHAベースのHMACとHKDF）</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                   D. Eastlake 3rd
Request for Comments: 6234                                        Huawei
Obsoletes: 4634                                                T. Hansen
Updates: 3174                                                  AT&amp;T Labs
Category: Informational                                         May 2011
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       US Secure Hash Algorithms
                   (SHA and SHA-based HMAC and HKDF)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The United States of America has adopted a suite of Secure Hash Algorithms (SHAs), including four beyond SHA-1, as part of a Federal Information Processing Standard (FIPS), namely SHA-224, SHA-256, SHA-384, and SHA-512. This document makes open source code performing these SHA hash functions conveniently available to the Internet community. The sample code supports input strings of arbitrary bit length. Much of the text herein was adapted by the authors from FIPS 180-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
米国では、連邦情報処理標準（FIPS）、すなわち、SHA-224、SHA-256、SHA-384、の一部として、SHA-1を超え4を含むセキュアハッシュアルゴリズム（シャス）、スイートを採用しており、 SHA-512。この文書は、インターネットコミュニティへの便利な利用できるこれらのSHAハッシュ関数を実行するオープン・ソース・コードを作成します。サンプルコードは、任意のビット長の入力文字列をサポートします。テキストの多くは、本明細書にFIPS 180-2の著者によって適応されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document replaces RFC 4634, fixing errata and adding code for an HMAC-based extract-and-expand Key Derivation Function, HKDF (RFC 5869). As with RFC 4634, code to perform SHA-based Hashed Message Authentication Codes (HMACs) is also included.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、RFC 4634を置き換えるエラッタを固定し、HMACベースの抽出物と、拡張鍵導出関数のためのコードを追加、HKDF（RFC 5869）。 RFC 4634と同様に、SHAベースのハッシュメッセージ認証コード（HMACs）を実行するためのコードも含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6234.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6234で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Overview of Contents ............................................4
   2. Notation for Bit Strings and Integers ...........................5
   3. Operations on Words .............................................6
   4. Message Padding and Parsing .....................................8
      4.1. SHA-224 and SHA-256 ........................................8
      4.2. SHA-384 and SHA-512 ........................................9
   5. Functions and Constants Used ...................................10
      5.1. SHA-224 and SHA-256 .......................................10
      5.2. SHA-384 and SHA-512 .......................................11
   6. Computing the Message Digest ...................................12
      6.1. SHA-224 and SHA-256 Initialization ........................12
      6.2. SHA-224 and SHA-256 Processing ............................13
      6.3. SHA-384 and SHA-512 Initialization ........................14
      6.4. SHA-384 and SHA-512 Processing ............................15
   7. HKDF- and SHA-Based HMACs ......................................17
      7.1. SHA-Based HMACs ...........................................17
      7.2. HKDF ......................................................17
   8. C Code for SHAs, HMAC, and HKDF ................................17
      8.1. The Header Files ..........................................21
           8.1.1. The .h file ........................................21
           8.1.2. stdint-example.h ...................................29
           8.1.3. sha-private.h ......................................29
      8.2. The SHA Code ..............................................30
           8.2.1. sha1.c .............................................30
           8.2.2. sha224-256.c .......................................39
           8.2.3. sha384-512.c .......................................51
           8.2.4. usha.c .............................................73
      8.3. The HMAC Code .............................................79
      8.4. The HKDF Code .............................................84
      8.5. The Test Driver ...........................................91
   9. Security Considerations .......................................123
   10. Acknowledgements .............................................123
   11. References ...................................................124
      11.1. Normative References ....................................124
      11.2. Informative References ..................................124
   Appendix: Changes from RFC 4634...................................126
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Overview of Contents
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
内容の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document includes specifications for the United States of America (USA) Federal Information Processing Standard (FIPS) Secure Hash Algorithms (SHAs), code to implement the SHAs, code to implement HMAC (Hashed Message Authentication Code, [RFC2104]) based on the SHAs, and code to implement HKDF (HMAC-based Key Derivation Function, [RFC5869]) based on HMAC. Specifications for HMAC and HKDF are not included as they appear elsewhere in the RFC series [RFC2104] [RFC5869].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、米国の仕様（USA）連邦情報処理標準（FIPS）セキュアハッシュアルゴリズム（シャス）、シャスを実装するコードに基づいて、HMAC（ハッシュメッセージ認証コード、[RFC2104]）を実装するためのコードが含まれていますHMACに基づくHKDF（HMACベースの鍵導出関数、[RFC5869]）を実現するシャス、およびコード。彼らはRFCシリーズ[RFC2104] [RFC5869]の他の場所で表示されるHMACとHKDFの仕様が含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NOTE: Much of the text below is taken from [SHS], and the assertions of the security of the hash algorithms described therein are made by the US Government, the author of [SHS], not by the listed authors of this document. See also [RFC6194] concerning the security of SHA-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：テキストの多くは、以下の[SHS]から取得され、かつそこに記載されているハッシュアルゴリズムのセキュリティのアサーションはありません。この文書の記載されている著者が、米国政府、[SHS]の作者によって作られています。 [RFC6194] SHA-1の安全性に関するも参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The text below specifies Secure Hash Algorithms, SHA-224 [RFC3874], SHA-256, SHA-384, and SHA-512, for computing a condensed representation of a message or a data file. (SHA-1 is specified in [RFC3174].) When a message of any length &lt; 2^64 bits (for SHA-224 and SHA-256) or &lt; 2^128 bits (for SHA-384 and SHA-512) is input to one of these algorithms, the result is an output called a message digest. The message digests range in length from 224 to 512 bits, depending on the algorithm. Secure Hash Algorithms are typically used with other cryptographic algorithms, such as digital signature algorithms and keyed-hash authentication codes, the generation of random numbers [RFC4086], or in key derivation functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のテキストは、メッセージまたはデータファイルの圧縮表現を計算するため、セキュアハッシュアルゴリズム、SHA-224 [RFC3874]、SHA-256、SHA-384を指定し、SHA-512。 （SHA-1は、[RFC3174]で指定されている。）任意の（SHA-224およびSHA-256のための）長さ&lt;2 ^ 64ビットまたは（SHA-384およびSHA-512）&lt;2 ^ 128ビットのメッセージである場合これらのアルゴリズムのいずれかへの入力は、結果は、メッセージダイジェストと呼ばれる出力です。メッセージダイジェストアルゴリズムに応じて、224から512ビット長の範囲です。セキュアハッシュアルゴリズムは、典型的には、デジタル署名アルゴリズムと鍵付きハッシュ認証コード、乱数[RFC4086]、又は鍵導出関数での発生などの他の暗号化アルゴリズムで使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The algorithms specified in this document are called secure because it is computationally infeasible to (1) find a message that corresponds to a given message digest, or (2) find two different messages that produce the same message digest. Any change to a message in transit will, with very high probability, result in a different message digest. This will result in a verification failure when the Secure Hash Algorithm is used with a digital signature algorithm or a keyed-hash message authentication algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、（1）所定のメッセージダイジェストに対応するメッセージを検索、または（2）同一のメッセージダイジェストを生成する2つの異なるメッセージを見つけることは計算上実行不可能であるため、この文書で指定されたアルゴリズムは、セキュアと呼ばれます。輸送中のメッセージに対する変更は、非常に高い確率で、異なるメッセージダイジェストになります。セキュアハッシュアルゴリズムは、デジタル署名アルゴリズム又は鍵付きハッシュメッセージ認証アルゴリズムで使用される場合、これは検証失敗をもたらすであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The code provided herein supports input strings of arbitrary bit length. SHA-1&#39;s sample code from [RFC3174] has also been updated to handle input strings of arbitrary bit length. Permission is granted for all uses, commercial and non-commercial, of this code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本明細書で提供されるコードは、任意のビット長の入力文字列をサポートします。 [RFC3174]からSHA-1のサンプル・コードはまた、任意のビット長の入力文字列を処理するために更新されています。許可は、このコードの商用、非商用のすべての使用、のために付与されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document obsoletes [RFC4634], and the changes from that RFC are summarized in the Appendix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、[RFC4634]を廃止し、そのRFCからの変更は付録にまとめられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1 OIDs (Object Identifiers) for the SHA algorithms, taken from [RFC4055], are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように[RFC4055]から取られたSHAアルゴリズムのASN.1のOID（オブジェクト識別子）は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   id-sha1  OBJECT IDENTIFIER  ::=  { iso(1)
                         identified-organization(3) oiw(14)
                         secsig(3) algorithms(2) 26 }
    id-sha224  OBJECT IDENTIFIER  ::=  {{ joint-iso-itu-t(2)
                         country(16) us(840) organization(1) gov(101)
                         csor(3) nistalgorithm(4) hashalgs(2) 4 }
    id-sha256  OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2)
                         country(16) us(840) organization(1) gov(101)
                         csor(3) nistalgorithm(4) hashalgs(2) 1 }
    id-sha384  OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2)
                         country(16) us(840) organization(1) gov(101)
                         csor(3) nistalgorithm(4) hashalgs(2) 2 }
    id-sha512  OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2)
                         country(16) us(840) organization(1) gov(101)
                         csor(3) nistalgorithm(4) hashalgs(2) 3 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 2 below defines the terminology and functions used as building blocks to form these algorithms. Section 3 describes the fundamental operations on words from which these algorithms are built. Section 4 describes how messages are padded up to an integral multiple of the required block size and then parsed into blocks. Section 5 defines the constants and the composite functions used to specify the hash algorithms. Section 6 gives the actual specification for the SHA-224, SHA-256, SHA-384, and SHA-512 functions. Section 7 provides pointers to the specification of HMAC keyed message authentication codes and to the specification of an extract-and-expand key derivation function based on HMAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のセクション2は、これらのアルゴリズムを形成するためのビルディングブロックとして使用される用語および機能を定義します。第3節では、これらのアルゴリズムが構築されているから単語の基本的な操作について説明します。第4節では、メッセージが必要なブロックサイズの整数倍にまで埋められた後、ブロックに解析される方法を説明します。セクション5は、定数とハッシュアルゴリズムを指定するために使用される複合関数を定義しています。セクション6は、SHA-224、SHA-256、SHA-384およびSHA-512関数の実際の仕様を与えます。セクション7は、HMAC鍵付きメッセージ認証コードの仕様およびHMACに基づく抽出物及びエキスパンド鍵導出関数の仕様へのポインタを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 8 gives sample code for the SHA algorithms, for SHA-based HMACs, and for HMAC-based extract-and-expand key derivation function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション8は、SHAベースHMACsため、およびHMACベースの抽出物と、拡張鍵導出関数のため、SHAアルゴリズムのためのサンプルコードを与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Notation for Bit Strings and Integers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ビット列と整数の2記法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following terminology related to bit strings and integers will be used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビット列と整数に関連する以下の用語が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. A hex digit is an element of the set {0, 1, ... , 9, A, ... , F}. A hex digit is the representation of a 4-bit string. Examples: 7 = 0111, A = 1010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 16進数は、集合の要素である{0、1、...、9、A、...、F}。 16進数は、4ビット列の表現です。例：= 0111 7、A = 1010。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. A word equals a 32-bit or 64-bit string that may be represented as a sequence of 8 or 16 hex digits, respectively. To convert a word to hex digits, each 4-bit string is converted to its hex equivalent as described in (a) above. Example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。単語は、それぞれ、8つのまたは16進数字の列として表すことができる32ビットまたは64ビット列と等しいです。上記（a）で説明したように進数字に単語を変換するために、各4ビットのビット列は、そのヘクス等価に変換されます。例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1010 0001 0000 0011 1111 1110 0010 0011 = A103FE23.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1010 0001 0000 0011 1111 1110 0010 0011 = 103 A Vaaと。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Throughout this document, the &#34;big-endian&#34; convention is used when expressing both 32-bit and 64-bit words, so that within each word the most significant bit is shown in the leftmost bit position.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ワード内の最上位ビットは最も左のビット位置に示されているように、32ビットと64ビットの両方の単語を表現する場合は、この文書全体を通じて、「ビッグエンディアン」規則が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. An integer may be represented as a word or pair of words.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。整数は、単語または単語の対として表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An integer between 0 and 2^32 - 1 inclusive may be represented as a 32-bit word. The least significant four bits of the integer are represented by the rightmost hex digit of the word representation. Example: the integer 291 = 2^8+2^5+2^1+2^0 = 256+32+2+1 is represented by the hex word 00000123.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0から2 ^ 32の間の整数 -  1包括的には、32ビットワードとして表現することができます。整数の最下位4ビットは、ワード表現の右端の16進数で表されます。例：整数291 = 2 ^ 8 + 2 ^ 5 + 2 ^ 1 + 2 ^ 0 = 256 + 32 + 2 + 1が進ワード00000123で表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The same holds true for an integer between 0 and 2^64-1 inclusive, which may be represented as a 64-bit word.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じことは、64ビット・ワードとして表現することができる0から2 ^ 64-1までの整数、のために当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If Z is an integer, 0 &lt;= z &lt; 2^64, then z = (2^32)x + y where 0 &lt;= x &lt; 2^32 and 0 &lt;= y &lt; 2^32. Since x and y can be represented as words X and Y, respectively, z can be represented as the pair of words (X,Y).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Zが整数である場合、0 &lt;= Z &lt;2 ^ 64は、Z =（2 ^ 32）X + Y 0 &lt;= xの&lt;2 ^ 32及び0 &lt;= Y &lt;2 ^ 32。 xおよびyはそれぞれワードXとY、として表現することができるので、zは単語（X、Y）の対として表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Again, the &#34;big-endian&#34; convention is used and the most significant word is in the leftmost word position for values represented by multiple-words.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでも、「ビッグエンディアン」規則が使用され、最も重要な単語は、複数の単語によって表される値のための左端のワード位置にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. block = 512-bit or 1024-bit string. A block (e.g., B) may be represented as a sequence of 32-bit or 64-bit words.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。ブロック= 512ビットまたは1024ビット列。ブロック（例えば、B）は、32ビットまたは64ビットワードのシーケンスとして表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Operations on Words
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
言葉3.操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following logical operators will be applied to words in all four hash operations specified herein. SHA-224 and SHA-256 operate on 32-bit words while SHA-384 and SHA-512 operate on 64-bit words.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の論理演算子は、本明細書で指定されたすべての4つのハッシュ操作の単語に適用されます。 SHA-384およびSHA-512は64ビットワードで動作しながら、SHA-224およびSHA-256は、32ビット・ワードで動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the operations below, x&lt;&lt;n is obtained as follows: discard the leftmost n bits of x and then pad the result with n zeroed bits on the right (the result will still be the same number of bits). Similarly, x&gt;&gt;n is obtained as follows: discard the rightmost n bits of x and then prepend the result with n zeroed bits on the left (the result will still be the same number of bits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の動作では、x &lt;&lt; nは次のように求められる：nは結果を左端のn、xのビットを破棄した後、パッド（結果は依然として同じビット数である）右側のビットをゼロ。同様に、X &gt;&gt; nは次のように得られる：Xの右端のnビットを破棄した後、nは結果を付加は、（結果は依然として同じビット数である）左側のビットをゼロ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. Bitwise logical word operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。ビット単位の論理ワード演算
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
X AND Y = bitwise logical &#34;and&#34; of X and Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
XとYは、XとYのビット単位の論理「と」=
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
X OR Y = bitwise logical &#34;inclusive-or&#34; of X and Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
X OR Yは、ビット単位の論理「を含め、または」XとYの=
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
X XOR Y = bitwise logical &#34;exclusive-or&#34; of X and Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
X XOR Y = XとYのビット単位の論理「排他的または」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NOT X = bitwise logical &#34;complement&#34; of X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
X.のNOT X =ビット単位の論理「補数」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Example:
                  01101100101110011101001001111011
            XOR   01100101110000010110100110110111
                  --------------------------------
              =   00001001011110001011101111001100
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. The operation X + Y is defined as follows: words X and Y represent w-bit integers x and y, where 0 &lt;= x &lt; 2^w and 0 &lt;= y &lt; 2^w. For positive integers n and m, let
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。次のように動作X + Yが定義される：ワードXとYはWビット整数を表し、xとy、0 &lt;= xで&lt;2 ^ wおよび0 &lt;= Y &lt;2 ^ wです。正の整数nとmについて、聞かせて
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
n mod m
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
N MOD M
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
be the remainder upon dividing n by m. Compute
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
mでnは分割時の余りです。計算
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
z = (x + y) mod 2^w.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Zは=（X + Y）W ^ 2 MOD。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Then 0 &lt;= z &lt; 2^w. Convert z to a word, Z, and define Z = X + Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次いで、0 &lt;= Z &lt;2 ^ wです。単語のZ変換、Z、およびZ = X + Yを定義します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. The right shift operation SHR^n(x), where x is a w-bit word and n is an integer with 0 &lt;= n &lt; w, is defined by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。 xは、Wビットのワードであり、nは右シフト演算SHR ^ N（x）は、0 &lt;= N &lt;wは、によって定義されると整数であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHR^n(x) = x&gt;&gt;n
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHR ^ N（X）= X N &gt;&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. The rotate right (circular right shift) operation ROTR^n(x), where x is a w-bit word and n is an integer with 0 &lt;= n &lt; w, is defined by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。 xは、Wビットのワードであり、nは右回転（循環右シフト）演算ROTR ^ N（x）は、0 &lt;= N &lt;wは、によって定義されると整数であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ROTR^n(x) = (x&gt;&gt;n) OR (x&lt;&lt;(w-n))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ROTR ^ N（X）=（X &gt;&gt; N）または（X &lt;&lt;（W-N））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
e. The rotate left (circular left shift) operation ROTL^n(x), where x is a w-bit word and n is an integer with 0 &lt;= n &lt; w, is defined by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電子。 xは、Wビットのワードであり、nは左回転（循環左シフト）操作ROTL ^ N（x）は、0 &lt;= N &lt;wは、によって定義されると整数であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ROTL^n(X) = (x&lt;&lt;n) OR (x&gt;&gt;(w-n))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ROTL ^ N（X）=（X &lt;&lt; N）または（X &gt;&gt;（W-N））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note the following equivalence relationships, where w is fixed in each relationship:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
wは各関係で固定されている次の同値関係を、注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ROTL^n(x) = ROTR^(w-n)(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ROTL ^ N（X）= ROTR ^（W-N）（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ROTR^n(x) = ROTL^(w-n)(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ROTR ^ N（X）= ROTL ^（W-N）（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Message Padding and Parsing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.メッセージパディングと解析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The hash functions specified herein are used to compute a message digest for a message or data file that is provided as input. The message or data file should be considered to be a bit string. The length of the message is the number of bits in the message (the empty message has length 0). If the number of bits in a message is a multiple of 8, for compactness we can represent the message in hex. The purpose of message padding is to make the total length of a padded message a multiple of 512 for SHA-224 and SHA-256 or a multiple of 1024 for SHA-384 and SHA-512.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本明細書で指定されたハッシュ関数は、入力として提供されるメッセージまたはデータファイルのメッセージダイジェストを計算するために使用されます。メッセージやデータファイルには、ビット列であると考えるべきです。メッセージの長さは、メッセージのビット数（空のメッセージの長さ0を有する）です。メッセージのビット数が8の倍数である場合は、コンパクトのために我々はヘクスにメッセージを表すことができます。メッセージパディングの目的は、パディングされたメッセージSHA-224およびSHA-256やSHA-384およびSHA-512 1024の複数512の複数の長さの合計を作ることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following specifies how this padding shall be performed. As a summary, a &#34;1&#34; followed by m &#34;0&#34;s followed by a 64-bit or 128-bit integer are appended to the end of the message to produce a padded message of length 512*n or 1024*n. The appended integer is the length of the original message. The padded message is then processed by the hash function as n 512-bit or 1024-bit blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下は、このパディングが行われなければならないかを指定します。要約として、64ビットまたは128ビットの整数に続くM続く「1」「0」は、長さ512×N又は1024×nのパディングされたメッセージを生成するメッセージの最後に追加されています。添付の整数が元のメッセージの長さです。パディングされたメッセージは、その後、N 512ビットまたは1024ビットのブロックとして、ハッシュ関数によって処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. SHA-224 and SHA-256
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。 SHA-224とSHA-256
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suppose a message has length L &lt; 2^64. Before it is input to the hash function, the message is padded on the right as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージが長さL &lt;2 ^ 64を有していると仮定する。それはハッシュ関数に入力する前に、以下のように、メッセージが右側にパディングされます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. &#34;1&#34; is appended. Example: if the original message is &#34;01010000&#34;, this is padded to &#34;010100001&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 「1」が付加されます。例：元のメッセージが「01010000」であれば、これは「010100001」に水増しされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. K &#34;0&#34;s are appended where K is the smallest, non-negative solution to the equation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。 Kは、式に最小、非負溶液であるK「0」が付加され
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
( L + 1 + K ) mod 512 = 448
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（L + 1 + F）= 512 V 448
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. Then append the 64-bit block that is L in binary representation. After appending this block, the length of the message will be a multiple of 512 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。次いで、バイナリ表現でLである64ビットのブロックを追加します。このブロックを追加した後に、メッセージの長さが512ビットの倍数であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example: Suppose the original message is the bit string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例：元のメッセージがビット列であると仮定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
01100001 01100010 01100011 01100100 01100101
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After step (a) this gives
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステップ（a）の後にこれを提供します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
01100001 01100010 01100011 01100100 01100101 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１ １
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since L = 40, the number of bits in the above is 41 and K = 407 &#34;0&#34;s are appended, making the total now 448. This gives the following in hex:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
L = 40は、上記のビット数は、Sが付加され41及びK = 407「0」であり、448今合計を製造するこれはヘクスに以下を与えます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
６１６２６３６４ ６５８０００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 64-bit representation of L = 40 is hex 00000000 00000028. Hence the final padded message is the following hex
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Lの64ビット表現= 40進00000000 00000028.あるそこで最終パディングメッセージは、次の六角です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
６１６２６３６４ ６５８０００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００２８
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. SHA-384 and SHA-512
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。 SHA-384およびSHA-512
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suppose a message has length L &lt; 2^128. Before it is input to the hash function, the message is padded on the right as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージが長さL &lt;2 ^ 128を有していると仮定する。それはハッシュ関数に入力する前に、以下のように、メッセージが右側にパディングされます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. &#34;1&#34; is appended. Example: if the original message is &#34;01010000&#34;, this is padded to &#34;010100001&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。 「1」が付加されます。例：元のメッセージが「01010000」であれば、これは「010100001」に水増しされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. K &#34;0&#34;s are appended where K is the smallest, non-negative solution to the equation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。 Kは、式に最小、非負溶液であるK「0」が付加され
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
( L + 1 + K ) mod 1024 = 896
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（L + 1 + F）V 1024 = 896
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. Then append the 128-bit block that is L in binary representation. After appending this block, the length of the message will be a multiple of 1024 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。次いで、バイナリ表現でLである128ビットのブロックを追加します。このブロックを追加した後に、メッセージの長さが1024ビットの倍数であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example: Suppose the original message is the bit string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例：元のメッセージがビット列であると仮定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
01100001 01100010 01100011 01100100 01100101
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After step (a) this gives
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステップ（a）の後にこれを提供します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
01100001 01100010 01100011 01100100 01100101 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１ １
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since L = 40, the number of bits in the above is 41 and K = 855 &#34;0&#34;s are appended, making the total now 896. This gives the following in hex:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
L = 40は、上記のビット数は、Sが付加され41及びK = 855「0」であり、896今合計を製造するこれはヘクスに以下を与えます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 128-bit representation of L = 40 is hex 00000000 00000000 00000000 00000028. Hence the final padded message is the following hex:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Lの128ビット表現は= 40、最終パディングメッセージは次ヘクスであるそこでヘクス00000000 00000000 00000000 00000028.あります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Functions and Constants Used
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
使用される5.関数や定数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following subsections give the six logical functions and the table of constants used in each of the hash functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のサブセクションでは、6つの論理関数およびハッシュ関数のそれぞれに使用される定数の表を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. SHA-224 and SHA-256
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。 SHA-224とSHA-256
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-224 and SHA-256 use six logical functions, where each function operates on 32-bit words, which are represented as x, y, and z. The result of each function is a new 32-bit word.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各関数は、x、yおよびzとして表される32ビットワード、上で動作する場合SHA-224およびSHA-256は6つの論理機能を使用します。各関数の結果は、新たな32ビット・ワードです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CH（X、Y、Z）=（XおよびY）XOR（（NOT X）およびZ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAJ（X、Y、Z）=（XおよびY）XOR（X及びZ）XOR（YおよびZ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
BSIG0（X）= ROTR ^ 2（x）はXOR ROTR ^ 13（X）XOR ROTR ^ 22（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
BSIG1（X）= ROTR ^ 6（X）XOR ROTR ^ 11（X）XOR ROTR ^ 25（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSIG0(x) = ROTR^7(x) XOR ROTR^18(x) XOR SHR^3(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSIG0（X）= ROTR ^ 7（x）の排他的論理和ROTR ^ 18（X）XOR SHR ^ 3（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSIG1(x) = ROTR^17(x) XOR ROTR^19(x) XOR SHR^10(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSIG1（X）= ROTR ^ 17（X）XOR ROTR ^ 19（X）XOR SHR ^ 10（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-224 and SHA-256 use the same sequence of sixty-four constant 32-bit words, K0, K1, ..., K63. These words represent the first 32 bits of the fractional parts of the cube roots of the first sixty-four prime numbers. In hex, these constant words are as follows (from left to right):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-224およびSHA-256は、64 4つの定常の32ビット・ワード、K0、K1、···、K63の同じシーケンスを使用します。これらの単語は、最初の64の素数の立方根の小数部分の最初の32ビットを表します。六角では、これらの定数の言葉は（左から右へ）次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5 d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174 e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da 983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967 27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85 a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070 19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3 748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5 d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174 e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da 983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967 27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85 a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070 19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3 748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. SHA-384 and SHA-512
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。 SHA-384およびSHA-512
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-384 and SHA-512 each use six logical functions, where each function operates on 64-bit words, which are represented as x, y, and z. The result of each function is a new 64-bit word.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-384およびSHA-512は、それぞれ、各関数は、x、yおよびzとして表される64ビットワード、上で動作する6つの論理機能を、使用します。各関数の結果は、新たな64ビット・ワードです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CH（X、Y、Z）=（XおよびY）XOR（（NOT X）およびZ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAJ（X、Y、Z）=（XおよびY）XOR（X及びZ）XOR（YおよびZ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
BSIG0(x) = ROTR^28(x) XOR ROTR^34(x) XOR ROTR^39(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
BSIG0（X）= ROTR ^ 28（X）XOR ROTR ^ 34（X）XOR ROTR ^ 39（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
BSIG1(x) = ROTR^14(x) XOR ROTR^18(x) XOR ROTR^41(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
BSIG1（X）= ROTR ^ 14（X）XOR ROTR ^ 18（X）XOR ROTR ^ 41（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSIG0(x) = ROTR^1(x) XOR ROTR^8(x) XOR SHR^7(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSIG0（X）= ROTR ^ 1（X）XOR ROTR ^ 8（X）XOR SHR ^ 7（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSIG1(x) = ROTR^19(x) XOR ROTR^61(x) XOR SHR^6(x)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSIG1（X）= ROTR ^ 19（x）の排他的論理和ROTR ^ 61（X）XOR SHR ^ 6（X）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-384 and SHA-512 use the same sequence of eighty constant 64-bit words, K0, K1, ... K79. These words represent the first 64 bits of the fractional parts of the cube roots of the first eighty prime numbers. In hex, these constant words are as follows (from left to right):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-384およびSHA-512は、80の定数の64ビット・ワード、K0、K1、... K79の同じシーケンスを使用します。これらの単語は、第80素数の立方根の小数部分の最初の64ビットを表します。六角では、これらの定数の言葉は（左から右へ）次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc 3956c25bf348b538 59f111f1b605d019 923f82a4af194f9b ab1c5ed5da6d8118 d807aa98a3030242 12835b0145706fbe 243185be4ee4b28c 550c7dc3d5ffb4e2 72be5d74f27b896f 80deb1fe3b1696b1 9bdc06a725c71235 c19bf174cf692694 e49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65 2de92c6f592b0275 4a7484aa6ea6e483 5cb0a9dcbd41fbd4 76f988da831153b5 983e5152ee66dfab a831c66d2db43210 b00327c898fb213f bf597fc7beef0ee4 c6e00bf33da88fc2 d5a79147930aa725 06ca6351e003826f 142929670a0e6e70 27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df 650a73548baf63de 766a0abb3c77b2a8 81c2c92e47edaee6 92722c851482353b a2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30 d192e819d6ef5218 d69906245565a910 f40e35855771202a 106aa07032bbd1b8 19a4c116b8d2d0c8 1e376c085141ab53 2748774cdf8eeb99 34b0bcb5e19b48a8 391c0cb3c5c95a63 4ed8aa4ae3418acb 5b9cca4f7763e373 682e6ff3d6b2b8a3 748f82ee5defb2fc 78a5636f43172f60 84c87814a1f0ab72 8cc702081a6439ec 90befffa23631e28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b ca273eceea26619c d186b8c721c0c207 eada7dd6cde0eb1e f57d4f7fee6ed178 06f067aa72176fba 0a637dc5a2c898a6 113f9804bef90dae 1b710b35131c471b 28db77f523047d84 32caab7b40c72493 3c9ebe0a15c9bebc 431d67c49c100d4c 4cc5d4becb3e42b6 597f299cfc657e2a 5fcb6fab3ad6faec 6c44198c4a475817
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc 3956c25bf348b538 59f111f1b605d019 923f82a4af194f9b ab1c5ed5da6d8118 d807aa98a3030242 12835b0145706fbe 243185be4ee4b28c 550c7dc3d5ffb4e2 72be5d74f27b896f 80deb1fe3b1696b1 9bdc06a725c71235 c19bf174cf692694 e49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5 240ca1cc77ac9c65 2de92c6f592b0275 4a7484aa6ea6e483 5cb0a9dcbd41fbd4 76f988da831153b5 983e5152ee66dfab a831c66d2db43210 b00327c898fb213f bf597fc7beef0ee4 c6e00bf33da88fc2 d5a79147930aa725 06ca6351e003826f 142929670a0e6e70 27b70a8546d22ffc 2e1b21385c26c926 4d2c6dfc5ac42aed 53380d139d95b3df 650a73548baf63de 766a0abb3c77b2a8 81c2c92e47edaee6 92722c851482353b a2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30 d192e819d6ef5218 d69906245565a910 f40e35855771202a 106aa07032bbd1b8 19a4c116b8d2d0c8 1e376c085141ab53 2748774cdf8eeb99 34b0bcb5e19b48a8 391c0cb3c5c95a63 4ed8aa4ae3418acb 5b9cca4f7763e373 682e6ff3d6b2b8a3 748f82ee5defb2fc 78a5636f43172f60 84c87814a1f0ab 72 8cc702081a6439ec 90befffa23631e28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b ca273eceea26619c d186b8c721c0c207 eada7dd6cde0eb1e f57d4f7fee6ed178 06f067aa72176fba 0a637dc5a2c898a6 113f9804bef90dae 1b710b35131c471b 28db77f523047d84 32caab7b40c72493 3c9ebe0a15c9bebc 431d67c49c100d4c 4cc5d4becb3e42b6 597f299cfc657e2a 5fcb6fab3ad6faec 6c44198c4a475817
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Computing the Message Digest
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.メッセージダイジェストを計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The output of each of the secure hash functions, after being applied to a message of N blocks, is the hash quantity H(N). For SHA-224 and SHA-256, H(i) can be considered to be eight 32-bit words, H(i)0, H(i)1, ... H(i)7. For SHA-384 and SHA-512, it can be considered to be eight 64-bit words, H(i)0, H(i)1, ..., H(i)7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュアハッシュ関数のそれぞれの出力は、N個のブロックのメッセージに適用された後、ハッシュ量H（N）です。 SHA-224およびSHA-256のために、H（i）はH（I）0、H（I）1、... H（I）7、8個の32ビットワードであると考えることができます。 SHA-384およびSHA-512の場合は、H（I）0、H（I 1）、...、H（I）7は、8つの64ビット・ワードであると考えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described below, the hash words are initialized, modified as each message block is processed, and finally concatenated after processing the last block to yield the output. For SHA-256 and SHA-512, all of the H(N) variables are concatenated while the SHA-224 and SHA-384 hashes are produced by omitting some from the final concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下に説明するように、ハッシュワードが、各メッセージブロックが処理されるように変更し、初期化され、最終的に出力を生成する最後のブロックを処理した後に連結されます。 SHA-224およびSHA-384ハッシュが最終連結の一部を省略することにより製造されながらSHA-256およびSHA-512、H（N）すべての変数のために連結されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. SHA-224 and SHA-256 Initialization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。 SHA-224とSHA-256の初期化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For SHA-224, the initial hash value, H(0), consists of the following 32-bit words in hex:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-224、初期ハッシュ値H（0）のために、六角で次の32ビットワードで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
H(0)0 = c1059ed8 H(0)1 = 367cd507 H(0)2 = 3070dd17 H(0)3 = f70e5939 H(0)4 = ffc00b31 H(0)5 = 68581511 H(0)6 = 64f98fa7 H(0)7 = befa4fa4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
H（0）= 0 c1059ed8 H（0）= 1 367cd507 H（0）2 = 3070dd17 H（0）3 = f70e5939 H（0）4 = ffc00b31 H（0）5 = 68581511 H（0）6 = 64f98fa7 H （0）7 = befa4fa4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For SHA-256, the initial hash value, H(0), consists of the following eight 32-bit words, in hex. These words were obtained by taking the first 32 bits of the fractional parts of the square roots of the first eight prime numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-256、初期ハッシュ値H（0）の場合、ヘクスに、以下の8つの32ビットワードから成ります。これらの単語は、最初の8つの素数の平方根の小数部分の最初の32ビットを取ることによって得ました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
H(0)0 = 6a09e667 H(0)1 = bb67ae85 H(0)2 = 3c6ef372 H(0)3 = a54ff53a H(0)4 = 510e527f H(0)5 = 9b05688c H(0)6 = 1f83d9ab H(0)7 = 5be0cd19
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
H（0）= 0 6a09e667 H（0）= 1 bb67ae85 H（0）2 = 3c6ef372 H（0）3 = a54ff53a H（0）4 = 510e527f H（0）5 = 9b05688c H（0）6 = 1f83d9ab H （0）7 = 5be0cd19
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. SHA-224 and SHA-256 Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。 SHA-224とSHA-256処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-224 and SHA-256 perform identical processing on message blocks and differ only in how H(0) is initialized and how they produce their final output. They may be used to hash a message, M, having a length of L bits, where 0 &lt;= L &lt; 2^64. The algorithm uses (1) a message schedule of sixty-four 32-bit words, (2) eight working variables of 32 bits each, and (3) a hash value of eight 32-bit words.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-224およびSHA-256は、メッセージブロックに対して同一の処理を実行し、H（0）が初期化され、どのように最終的な出力を生成する方法のみが異なります。これらは、Lビットの長さ、0 &lt;= L &lt;2 ^ 64を有し、メッセージMをハッシュするために使用することができます。アルゴリズムの使用（1）六十から四の32ビット・ワードのメッセージスケジュール、32ビットずつの（2）は、8つの作業変数、及び8個の32ビットワードの（3）ハッシュ値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The words of the message schedule are labeled W0, W1, ..., W63. The eight working variables are labeled a, b, c, d, e, f, g, and h. The words of the hash value are labeled H(i)0, H(i)1, ..., H(i)7, which will hold the initial hash value, H(0), replaced by each successive intermediate hash value (after each message block is processed), H(i), and ending with the final hash value, H(N), after all N blocks are processed. They also use two temporary words, T1 and T2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージスケジュールの言葉は、W0、W1、...、W63のラベルが付いています。 8つの作業変数は、B、C、D、E、F、G、及びHを標識されています。ハッシュ値のワードがH（I）0標識され、H（I 1）、...、H初期ハッシュ値を保持する（I）7、H（0）、各連続中間ハッシュ値に置き換えN個すべてのブロックが処理された後、H（I）、（各メッセージブロックが処理された後）、および最終ハッシュ値H（N）で終わります。彼らはまた、2つの一時単語、T1およびT2を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The input message is padded as described in Section 4.1 above, then parsed into 512-bit blocks that are considered to be composed of sixteen 32-bit words M(i)0, M(i)1, ..., M(i)15. The following computations are then performed for each of the N message blocks. All addition is performed modulo 2^32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力メッセージは、上記セクション4.1に記載したように、パディング次いで16 32ビットワードM（I）0、M（I）1、...、M（Iからなると考えられている512ビットのブロックに解析され）15。以下の計算は、次に、N個のメッセージブロック毎に行われます。すべての添加は2 ^ 32を法として行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For i = 1 to N
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NのI = 1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Prepare the message schedule W: For t = 0 to 15 Wt = M(i)t For t = 16 to 63 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(w(t-15)) + W(t-16)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（T = 16重量= SSIG1（W（T-2））+ W（T-7）+ SSIG0 63（WのTに対する= 0〜15重量= M（I）T：1.メッセージスケジュールWを準備T-15））+ W（T-16）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Initialize the working variables: a = H(i-1)0 b = H(i-1)1 c = H(i-1)2 d = H(i-1)3 e = H(i-1)4 f = H(i-1)5 g = H(i-1)6 h = H(i-1)7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= H（I-​​1）0のB =のH（I-1）1個のC =さH（I-1）2 D = H（I-​​1）3、E = H（I-​​1：2作業変数を初期化）4、F = H（I-​​1）5と、G = H（I-​​1）= Hの6つのH（I-1）7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Perform the main hash computation: For t = 0 to 63 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.主ハッシュ計算を実行し、T = 0〜63、T1 = H + BSIG1（E）+ CH（E、F、G）+ Ktを+重量T2 = BSIG0（A）+ MAJについて（A、B、C） H = GG = FF = EE = D + T1 D = CC = BB = AA = T1 + T2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Compute the intermediate hash value H(i) H(i)0 = a + H(i-1)0 H(i)1 = b + H(i-1)1 H(i)2 = c + H(i-1)2 H(i)3 = d + H(i-1)3 H(i)4 = e + H(i-1)4 H(i)5 = f + H(i-1)5 H(i)6 = g + H(i-1)6 H(i)7 = h + H(i-1)7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.計算の中間ハッシュ値H（I）、H（I）0 = A + H（I-​​1）0 H（I）1 = B + H（I-​​1）1 H（I）2 = C + H （I-1）2 H（I）3 = D + H（I-​​1）3 H（I）4 = E + H（I-​​1）4 H（I）5 = F + H（I-​​1） 5 H（I）6 = G + H（I-​​1）6 H（I）7 = Hの+ H（I-​​1）7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated. For SHA-256, this is the concatenation of all of H(N)0, H(N)1, through H(N)7. For SHA-224, this is the concatenation of H(N)0, H(N)1, through H(N)6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の計算は、順次、メッセージ内の全てのブロックに対して実行された後、最終的な出力を算出します。 SHA-256のために、これはH（N）0の全ての連結され、H（N）1、H（N）を介して7。 SHA-224のために、これはH（N）0の連結であり、H（N）1、H（N）を介して、6。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. SHA-384 and SHA-512 Initialization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3。 SHA-384およびSHA-512の初期化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For SHA-384, the initial hash value, H(0), consists of the following eight 64-bit words, in hex. These words were obtained by taking the first 64 bits of the fractional parts of the square roots of the ninth through sixteenth prime numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-384、初期ハッシュ値H（0）の場合、ヘクスに、以下の8つの64ビットワードから成ります。これらの単語は、第十六素数を介して第九の平方根の小数部分の最初の64ビットを取ることによって得ました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         H(0)0 = cbbb9d5dc1059ed8
         H(0)1 = 629a292a367cd507
         H(0)2 = 9159015a3070dd17
         H(0)3 = 152fecd8f70e5939
         H(0)4 = 67332667ffc00b31
         H(0)5 = 8eb44a8768581511
         H(0)6 = db0c2e0d64f98fa7
         H(0)7 = 47b5481dbefa4fa4
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For SHA-512, the initial hash value, H(0), consists of the following eight 64-bit words, in hex. These words were obtained by taking the first 64 bits of the fractional parts of the square roots of the first eight prime numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-512、初期ハッシュ値H（0）の場合、ヘクスに、以下の8つの64ビットワードから成ります。これらの単語は、最初の8つの素数の平方根の小数部分の最初の64ビットを取ることによって得ました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         H(0)0 = 6a09e667f3bcc908
         H(0)1 = bb67ae8584caa73b
         H(0)2 = 3c6ef372fe94f82b
         H(0)3 = a54ff53a5f1d36f1
         H(0)4 = 510e527fade682d1
         H(0)5 = 9b05688c2b3e6c1f
         H(0)6 = 1f83d9abfb41bd6b
         H(0)7 = 5be0cd19137e2179
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. SHA-384 and SHA-512 Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4。 SHA-384とSHA-512処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-384 and SHA-512 perform identical processing on message blocks and differ only in how H(0) is initialized and how they produce their final output. They may be used to hash a message, M, having a length of L bits, where 0 &lt;= L &lt; 2^128. The algorithm uses (1) a message schedule of eighty 64-bit words, (2) eight working variables of 64 bits each, and (3) a hash value of eight 64-bit words.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-384およびSHA-512は、メッセージブロックに対して同一の処理を実行し、H（0）が初期化され、どのように最終的な出力を生成する方法のみが異なります。これらは、Lビット、0 &lt;= L &lt;2 ^ 128の長さを有する、メッセージMをハッシュするために使用することができます。アルゴリズムの使用80 64ビット・ワード、64ビットずつの（2）は、8つの作業変数、8つの64ビットワードの（3）ハッシュ値の（1）メッセージスケジュール。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The words of the message schedule are labeled W0, W1, ..., W79. The eight working variables are labeled a, b, c, d, e, f, g, and h. The words of the hash value are labeled H(i)0, H(i)1, ..., H(i)7, which will hold the initial hash value, H(0), replaced by each successive intermediate hash value (after each message block is processed), H(i), and ending with the final hash value, H(N) after all N blocks are processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージスケジュールの言葉は、W0、W1、...、W79のラベルが付いています。 8つの作業変数は、B、C、D、E、F、G、及びHを標識されています。ハッシュ値のワードがH（I）0標識され、H（I 1）、...、H初期ハッシュ値を保持する（I）7、H（0）、各連続中間ハッシュ値に置き換えN個すべてのブロックが処理された後にH（I）、（各メッセージブロックが処理された後）、および最終ハッシュ値で終わる、H（N）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The input message is padded as described in Section 4.2 above, then parsed into 1024-bit blocks that are considered to be composed of sixteen 64-bit words M(i)0, M(i)1, ..., M(i)15. The following computations are then performed for each of the N message blocks. All addition is performed modulo 2^64.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力メッセージは、上記セクション4.2に記載したように、パディング次いで16 64ビットワードM（I）0、M（I）1、...、M（Iからなると考えられている1024ビットのブロックに解析され）15。以下の計算は、次に、N個のメッセージブロック毎に行われます。すべての添加は2 ^ 64を法として行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For i = 1 to N
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NのI = 1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Prepare the message schedule W: For t = 0 to 15 Wt = M(i)t For t = 16 to 79 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(W(t-15)) + W(t-16)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.メッセージスケジュールWを準備：T = 16〜79重量= SSIG1（W（T-2））+ W（T-7）+ SSIG0（W（のためのT = 0〜15重量= M（I）Tの場合T-15））+ W（T-16）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Initialize the working variables: a = H(i-1)0 b = H(i-1)1 c = H(i-1)2 d = H(i-1)3 e = H(i-1)4 f = H(i-1)5 g = H(i-1)6 h = H(i-1)7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= H（I-​​1）0のB =のH（I-1）1個のC =さH（I-1）2 D = H（I-​​1）3、E = H（I-​​1：2作業変数を初期化）4、F = H（I-​​1）5と、G = H（I-​​1）= Hの6つのH（I-1）7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Perform the main hash computation: For t = 0 to 79 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.主ハッシュ計算を実行し、T = 0〜79、T1 = H + BSIG1（E）+ CH（E、F、G）+ Ktを+重量T2 = BSIG0（A）+ MAJについて（A、B、C） H = GG = FF = EE = D + T1 D = CC = BB = AA = T1 + T2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Compute the intermediate hash value H(i) H(i)0 = a + H(i-1)0 H(i)1 = b + H(i-1)1 H(i)2 = c + H(i-1)2 H(i)3 = d + H(i-1)3 H(i)4 = e + H(i-1)4 H(i)5 = f + H(i-1)5 H(i)6 = g + H(i-1)6 H(i)7 = h + H(i-1)7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.計算の中間ハッシュ値H（I）、H（I）0 = A + H（I-​​1）0 H（I）1 = B + H（I-​​1）1 H（I）2 = C + H （I-1）2 H（I）3 = D + H（I-​​1）3 H（I）4 = E + H（I-​​1）4 H（I）5 = F + H（I-​​1） 5 H（I）6 = G + H（I-​​1）6 H（I）7 = Hの+ H（I-​​1）7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After the above computations have been sequentially performed for all of the blocks in the message, the final output is calculated. For SHA-512, this is the concatenation of all of H(N)0, H(N)1, through H(N)7. For SHA-384, this is the concatenation of H(N)0, H(N)1, through H(N)5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の計算は、順次、メッセージ内の全てのブロックに対して実行された後、最終的な出力を算出します。 SHA-512のために、これはH（N）0の全ての連結され、H（N）1、H（N）を介して7。 SHA-384のために、これはH（N）0の連結であり、H（N）1、H（N）を介して5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. HKDF- and SHA-Based HMACs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. HKDF-とSHAベースHMACs
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Below are brief descriptions and pointers to more complete descriptions and code for (1) SHA-based HMACs and (2) an HMAC-based extract-and-expand key derivation function. Both HKDF and HMAC were devised by Hugo Krawczyk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下に簡単な説明とポインタのより完全な説明と、（1）SHAベースHMACs及び（2）HMACベースの抽出物と、拡張鍵導出関数のためのコードです。 HKDFとHMACの両方がユーゴーKrawczykによって考案されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. SHA-Based HMACs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。 SHAベースHMACs
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HMAC is a method for computing a keyed MAC (Message Authentication Code) using a hash function as described in [RFC2104]. It uses a key to mix in with the input text to produce the final hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HMACは、[RFC2104]に記載されているように、ハッシュ関数を用いて、鍵付きMAC（メッセージ認証コード）を計算する方法です。それは、最終的なハッシュを生成するために、入力テキストで混合するためにキーを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sample code is also provided, in Section 8.3 below, to perform HMAC based on any of the SHA algorithms described herein. The sample code found in [RFC2104] was written in terms of a specified text size. Since SHA is defined in terms of an arbitrary number of bits, the sample HMAC code has been written to allow the text input to HMAC to have an arbitrary number of octets and bits. A fixed-length interface is also provided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サンプルコードは、本明細書に記載SHAアルゴリズムのいずれかに基づいてHMACを実行するために、セクション8.3以下に、設けられています。 [RFC2104]に見られるサンプルコードは、指定されたテキストサイズの観点から書かれました。 SHAは、任意のビット数で定義されているので、サンプルHMACコードは、オクテットと任意のビット数を有することHMACへのテキスト入力を可能にするために書かれています。固定長のインターフェイスも提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. HKDF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。 HKDF
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HKDF is a specific Key Derivation Function (KDF), that is, a function of initial keying material from which the KDF derives one or more cryptographically strong secret keys. HKDF, which is described in [RFC5869], is based on HMAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HKDFは、KDFは、1つまたは複数の暗号的に強い秘密鍵を導出し、そこから初期鍵素材の関数である特定の鍵導出関数（KDF）、です。 [RFC5869]に記載されてHKDFは、HMACに基づくものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sample code for HKDF is provided in Section 8.4 below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HKDFのためのサンプルコードは、以下のセクション8.4で提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. C Code for SHAs, HMAC, and HKDF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
シャス、HMAC、およびHKDF 8. Cコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Below is a demonstration implementation of these secure hash functions in C. Section 8.1 contains the header file sha.h that declares all constants, structures, and functions used by the SHA and HMAC functions. It includes conditionals based on the state of definition of USE_32BIT_ONLY that, if that symbol is defined at compile time, avoids 64-bit operations. It also contains sha-private.h that provides some declarations common to all the SHA functions. Section 8.2 contains the C code for sha1.c, sha224-256.c, sha384-512.c, and usha.c. Section 8.3 contains the C code for the HMAC functions, and Section 8.4 contains the C code for HKDF. Section 8.5 contains a test driver to exercise the code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下C.セクション8.1でこれらの安全なハッシュ関数のデモンストレーションの実装では、SHAとHMAC関数によって使用されるすべての定数、構造、および機能を宣言するヘッダファイルsha.hが含まれます。そのシンボルは、コンパイル時に定義されている場合、64ビット演算を回避し、USE_32BIT_ONLYの定義の状態に基づいて、条件文を含みます。また、すべてのSHA機能に共通するいくつかの宣言を提供し、SHA-private.hが含まれています。 8.2節はsha1.c、sha224-256.c、sha384-512.c、およびusha.c.のためのCコードが含まれていますセクション8.3は、HMAC関数のCコードが含まれており、セクション8.4 HKDF用のCコードを含みます。セクション8.5は、コードを行使するためのテストドライバーが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For each of the digest lengths $$$, there is the following set of constants, a structure, and functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ダイジェスト長$$$の各々について、定数、構造、および機能の次のセットがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Constants: SHA$$$HashSize number of octets in the hash SHA$$$HashSizeBits number of bits in the hash SHA$$$_Message_Block_Size number of octets used in the intermediate message blocks Most functions return an enum value that is one of: shaSuccess(0) on success shaNull(1) when presented with a null pointer parameter shaInputTooLong(2) when the input data is too long shaStateError(3) when SHA$$$Input is called after SHA$$$FinalBits or SHA$$$Result
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定数：ハッシュSHA $$$のオクテットのSHA $$$ HASHSIZE番号HashSizeBitsハッシュSHA $$$のビット数_ Message_Block_Sizeほとんどの機能は以下のいずれかのenum値を返す中間メッセージブロックで使用されるオクテットの数：shaSuccess （0）成功した​​shaNullヌルポインタパラメータshaInputTooLongで提示された場合（1）（2）入力データSHA $$$入力がSHA $$$ FinalBitsまたはSHA後に呼び出される長すぎるshaStateError（3）の場合$$$結果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure: typedef SHA$$$Context an opaque structure holding the complete state for producing the hash
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造：SHAのtypedef $$$コンテキスト不透明な構造ハッシュを生成するための完全な状態を保持します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Functions:
      int SHA$$$Reset(SHA$$$Context *context);
            Reset the hash context state.
      int SHA$$$Input(SHA$$$Context *context, const uint8_t *octets,
                  unsigned int bytecount);
            Incorporate bytecount octets into the hash.
      int SHA$$$FinalBits(SHA$$$Context *, const uint8_t octet,
                  unsigned int bitcount);
            Incorporate bitcount bits into the hash.  The bits are in
            the upper portion of the octet.  SHA$$$Input() cannot be
            called after this.
      int SHA$$$Result(SHA$$$Context *,
                  uint8_t Message_Digest[SHA$$$HashSize]);
            Do the final calculations on the hash and copy the value
            into Message_Digest.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, functions with the prefix USHA are provided that take a SHAversion value (SHA$$$) to select the SHA function suite. They add the following constants, structure, and functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、接頭辞USHA持つ関数は、SHA関数スイートを選択するSHAversion値（SHAを$$$）を取るが提供されます。彼らは、以下の定数、構造、および機能を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Constants: shaBadParam(4) constant returned by USHA functions when presented with a bad SHAversion (SHA$$$) parameter or other illegal parameter values USAMaxHashSize maximum of the SHA hash sizes SHA$$$ SHAversion enumeration values, used by USHA, HMAC, and HKDF functions to select the SHA function suite
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定数：shaBadParam（4）一定の悪いSHAversion（SHA $$$）で提示されたときUSHA関数によって返されたSHAハッシュのパラメータまたは他の違法なパラメータ値USAMaxHashSizeの最大USHA、HMACで使用SHA $$$ SHAversion列挙値を、サイズ、 SHA機能スイートを選択するとHKDF機能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure: typedef USHAContext an opaque structure holding the complete state for producing the hash
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造：USHAContextのtypedefハッシュを生成するための完全な状態を保持する不透明な構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Functions:
      int USHAReset(USHAContext *context, SHAversion whichSha);
            Reset the hash context state.
      int USHAInput(USHAContext context*,
                  const uint8_t *bytes, unsigned int bytecount);
            Incorporate bytecount octets into the hash.
      int USHAFinalBits(USHAContext *context,
                  const uint8_t bits, unsigned int bitcount);
            Incorporate bitcount bits into the hash.
      int USHAResult(USHAContext *context,
                  uint8_t Message_Digest[USHAMaxHashSize]);
            Do the final calculations on the hash and copy the value
            into Message_Digest.  Octets in Message_Digest beyond
            USHAHashSize(whichSha) are left untouched.
      int USHAHashSize(enum SHAversion whichSha);
            The number of octets in the given hash.
      int USHAHashSizeBits(enum SHAversion whichSha);
            The number of bits in the given hash.
      int USHABlockSize(enum SHAversion whichSha);
            The internal block size for the given hash.
      const char *USHAHashName(enum SHAversion whichSha);
            This function will return the name of the given SHA
            algorithm as a string.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HMAC functions follow the same pattern to allow any length of text input to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HMAC関数は、テキスト入力の任意の長さを使用することを可能にする同一のパターンに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure: typedef HMACContext an opaque structure holding the complete state for producing the keyed message digest (MAC)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造：キー付きメッセージダイジェストを生成するための完全な状態を保持するのtypedef HMACContext不透明構造（MAC）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Functions:
      int hmacReset(HMACContext *ctx, enum SHAversion whichSha,
                  const unsigned char *key, int key_len);
            Reset the MAC context state.
      int hmacInput(HMACContext *ctx, const unsigned char *text,
                  int text_len);
            Incorporate text_len octets into the MAC.
      int hmacFinalBits(HMACContext *ctx, const uint8_t bits,
                  unsigned int bitcount);
            Incorporate bitcount bits into the MAC.
      int hmacResult(HMACContext *ctx,
                  uint8_t Message_Digest[USHAMaxHashSize]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            Do the final calculations on the MAC and copy the value into
            Message_Digest.  Octets in Message_Digest beyond
            USHAHashSize(whichSha) are left untouched.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, a combined interface is provided, similar to that shown in [RFC2104], that allows a fixed-length text input to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
加えて、合成インターフェースは、固定長のテキスト入力を使用することを可能にする[RFC2104]に示したものと同様、提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int hmac(SHAversion whichSha, const unsigned char *text, int text_len, const unsigned char *key, int key_len, uint8_t Message_Digest[USHAMaxHashSize]); Calculate the given digest for the given text and key, and return the resulting MAC. Octets in Message_Digest beyond USHAHashSize(whichSha) are left untouched.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
INTのHMAC（SHAversion whichSha、CONSTはunsigned char *のテキスト、int型TEXT_LEN、CONSTはunsigned char *キー、INT key_lenに、uint8_t Message_Digest [USHAMaxHashSize]）。指定されたテキストとキーに指定されたダイジェストを計算し、そして得られたMACを返します。 USHAHashSizeを超えMessage_Digest（whichSha）のオクテットはそのまま残されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HKDF functions follow the same pattern to allow any length of text input to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HKDF機能は、テキスト入力の任意の長さを使用することを可能にする同一のパターンに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure: typedef HKDFContext an opaque structure holding the complete state for producing the keying material Functions: int hkdfReset(HKDFContext *context, enum SHAversion whichSha, const unsigned char *salt, int salt_len) Reset the key derivation state and initialize it with the salt_len octets of the optional salt. int hkdfInput(HKDFContext *context, const unsigned char *ikm, int ikm_len) Incorporate ikm_len octets into the entropy extractor. int hkdfFinalBits(HKDFContext *context, uint8_t ikm_bits, unsigned int ikm_bit_count) Incorporate ikm_bit_count bits into the entropy extractor. int hkdfResult(HKDFContext *context, uint8_t prk[USHAMaxHashSize], const unsigned char *info, int info_len, uint8_t okm[ ], int okm_len) Finish the HKDF extraction and perform the final HKDF expansion, storing the okm_len octets into output keying material (okm). Optionally store the pseudo-random key (prk) that is generated internally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造：鍵材料関数を生成するための完全な状態を保持するのtypedef HKDFContext不透明な構造：int型hkdfReset（HKDFContext *コンテキスト、列挙型SHAversion whichSha、constのはunsigned char *塩、INT salt_len）鍵導出状態をリセットし、salt_lenオクテットでそれを初期化しますオプションの塩の。 int型hkdfInput（HKDFContext *文脈、のconst unsigned char型* IKM、INT ikm_len）エントロピー抽出にikm_lenオクテットを組み込みます。 INT hkdfFinalBits（HKDFContext *コンテキスト、uint8_t ikm_bits、unsigned int型ikm_bit_count）エントロピー抽出にikm_bit_countビットを組み込みます。 INT hkdfResult（HKDFContext *コンテキスト、uint8_t PRK [USHAMaxHashSize]、CONSTはunsigned char *情報、INT info_len、uint8_t OKM []、INT okm_len）（HKDF抽出を終了し、最終HKDF拡張を行う、材料を合わせる出力にokm_lenオクテットを記憶しますOKM）。必要に応じて内部で生成された擬似ランダム鍵（PRK）を格納します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, combined interfaces are provided, similar to that shown in [RFC5869], that allows a fixed-length text input to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
加えて、合成インターフェースは、その固定長テキスト入力を使用することを可能にする、[RFC5869]に示したものと同様に設けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int hkdfExtract(SHAversion whichSha, const unsigned char *salt, int salt_len, const unsigned char *ikm, int ikm_len, uint8_t prk[USHAMaxHashSize])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
INT hkdfExtract（SHAversion whichSha、CONSTはunsigned char *塩、INT salt_len、CONSTはunsigned char * IKM、INT ikm_len、uint8_t PRK [USHAMaxHashSize]）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            Perform HKDF extraction, combining the salt_len octets of
            the optional salt with the ikm_len octets of the input
            keying material (ikm) to form the pseudo-random key prk.
            The output prk must be large enough to hold the octets
            appropriate for the given hash type.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int hkdfExpand(SHAversion whichSha, const uint8_t prk[ ], int prk_len, const unsigned char *info, int info_len, uint8_t okm[ ], int okm_len) Perform HKDF expansion, combining the prk_len octets of the pseudo-random key prk with the info_len octets of info to form the okm_len octets stored in okm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
INT hkdfExpand（SHAversion whichSha、CONST uint8_t PRK []、INT prk_len、CONSTはunsigned char *情報、INT info_len、uint8_t OKM []、INT okm_len）info_lenと疑似ランダムキーPRKのprk_lenオクテットを組み合わせ、HKDFの拡張を行いますOKMに保存されているokm_lenオクテットを形成するために、情報のオクテット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
int hkdf(SHAversion whichSha, const unsigned char *salt, int salt_len, const unsigned char *ikm, int ikm_len, const unsigned char *info, int info_len, uint8_t okm[ ], int okm_len) This combined interface performs both HKDF extraction and expansion. The variables are the same as in hkdfExtract() and hkdfExpand().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
hkdfをINT（SHAversion whichSha、CONSTはunsigned char *塩、INT salt_len、CONSTはunsigned char * IKM、INT ikm_len、CONSTはunsigned char *情報、INT info_len、uint8_t OKM []、INT okm_len）この結合界面はHKDF抽出および膨張の両方を行います。変数はhkdfExtract（）とhkdfExpand（）と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. The Header Files
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。ヘッダファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. The .h file
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1。 .hファイル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following sha.h file, as stated in the comments within the file, assumes that &lt;stdint.h&gt; is available on your system. If it is not, you should change to including &lt;stdint-example.h&gt;, provided in Section 8.1.2, or the like.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイル内のコメントで述べたように、sha.hファイル以下、&lt;stdint.h&gt;がシステムに利用可能であることを前提としています。そうでない場合は、セクション8.1.2、等に提供、&lt;stdint-example.h&gt;を含むに変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**************************** sha.h ****************************/
/***************** See RFC 6234 for details. *******************/
/*
   Copyright (c) 2011 IETF Trust and the persons identified as
   authors of the code.  All rights reserved.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再配布および、改変してまたは改変せずに、ソースおよびバイナリ形式で使用し、以下の条件が満たされていることを許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ソースコードの再配布は、上記の著作権表示、条件のリストおよび以下の免責事項を保持しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - バイナリ形式で再配布は、上記の著作権表示、条件のリストおよび文書および/または分布を備えた他の材料で次の免責事項を再現しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Neither the name of Internet Society, IETF or IETF Trust, nor the names of specific contributors, may be used to endorse or promote products derived from this software without specific prior written permission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - インターネット協会、IETFやIETFトラストの名称、また具体的な貢献者の名前はどちらも、特定の書面による事前の許可なしに、本ソフトウェアから派生した製品を推薦または促進するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ #ifndef _SHA_H_ #define _SHA_H_
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「現状のまま」、いかなる明示または黙示の保証、含むがこれらに限定されないが、特定目的に対する適合性の黙示の保証は放棄さ本ソフトウェアは著作権所有者によって提供されます。 NO EVENTの著作権所有者または貢献者は、以下を含むいかなる直接的、間接的、偶発的、特別、懲罰的、または間接的損害（についても責任を負いあってもよいが、代替商品またはサービスの調達、これらに限定されないものとし、使用、データ、または利益の損失; OR事業の中断）原因で生じた（そのような損害の可能性について知らされていた場合でも、一切このソフトウェアの使用の損失、データの損失）過失またはその他を含む責任、それが契約、厳格な責任、不法行為のどのような理論の上で。 * / #ifndefの_SHA_H_の#define _SHA_H_
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Description:
 *      This file implements the Secure Hash Algorithms
 *      as defined in the U.S. National Institute of Standards
 *      and Technology Federal Information Processing Standards
 *      Publication (FIPS PUB) 180-3 published in October 2008
 *      and formerly defined in its predecessors, FIPS PUB 180-1
 *      and FIP PUB 180-2.
 *
 *      A combined document showing all algorithms is available at
 *              http://csrc.nist.gov/publications/fips/
 *                     fips180-3/fips180-3_final.pdf
 *
 *      The five hashes are defined in these sizes:
 *              SHA-1           20 byte / 160 bit
 *              SHA-224         28 byte / 224 bit
 *              SHA-256         32 byte / 256 bit
 *              SHA-384         48 byte / 384 bit
 *              SHA-512         64 byte / 512 bit
 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Compilation Note: * These files may be compiled with two options: * USE_32BIT_ONLY - use 32-bit arithmetic only, for systems * without 64-bit integers * * USE_MODIFIED_MACROS - use alternate form of the SHA_Ch() * and SHA_Maj() macros that are equivalent * and potentially faster on many systems * */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*コンパイル注：*これらのファイルは、2つのオプションでコンパイルすることができる：* USE_32BIT_ONLY  -  64ビット整数* USE_MODIFIED_MACROSなし*システムのために、唯一の32ビット演算を使用 -  SHA_Ch（の代替形式を使用）*とSHA_Maj（）マクロその* * /多くのシステムに潜在的に速い*同等であり、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#include &lt;stdint.h&gt;
/*
 * If you do not have the ISO standard stdint.h header file, then you
 * must typedef the following:
 *    name              meaning
 *  uint64_t         unsigned 64-bit integer
 *  uint32_t         unsigned 32-bit integer
 *  uint8_t          unsigned 8-bit integer (i.e., unsigned char)
 *  int_least16_t    integer of &gt;= 16 bits
 *
 * See stdint-example.h
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#ifndef _SHA_enum_
#define _SHA_enum_
/*
 *  All SHA functions return one of these values.
 */
enum {
    shaSuccess = 0,
    shaNull,            /* Null pointer parameter */
    shaInputTooLong,    /* input data too long */
    shaStateError,      /* called Input after FinalBits or Result */
    shaBadParam         /* passed a bad parameter */
};
#endif /* _SHA_enum_ */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  These constants hold size information for each of the SHA
 *  hashing operations
 */
enum {
    SHA1_Message_Block_Size = 64, SHA224_Message_Block_Size = 64,
    SHA256_Message_Block_Size = 64, SHA384_Message_Block_Size = 128,
    SHA512_Message_Block_Size = 128,
    USHA_Max_Message_Block_Size = SHA512_Message_Block_Size,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    SHA1HashSize = 20, SHA224HashSize = 28, SHA256HashSize = 32,
    SHA384HashSize = 48, SHA512HashSize = 64,
    USHAMaxHashSize = SHA512HashSize,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 SHA1HashSizeBits = 160, SHA224HashSizeBits = 224, SHA256HashSizeBits = 256, SHA384HashSizeBits = 384, SHA512HashSizeBits = 512, USHAMaxHashSizeBits = SHA512HashSizeBits };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA1HashSizeBits = 160、SHA224HashSizeBits = 224、SHA256HashSizeBits = 256、SHA384HashSizeBits = 384、SHA512HashSizeBits = 512、USHAMaxHashSizeBits = SHA512HashSizeBits}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  These constants are used in the USHA (Unified SHA) functions.
 */
typedef enum SHAversion {
    SHA1, SHA224, SHA256, SHA384, SHA512
} SHAversion;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  This structure will hold context information for the SHA-1
 *  hashing operation.
 */
typedef struct SHA1Context {
    uint32_t Intermediate_Hash[SHA1HashSize/4]; /* Message Digest */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    uint32_t Length_High;               /* Message length in bits */
    uint32_t Length_Low;                /* Message length in bits */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    int_least16_t Message_Block_Index;  /* Message_Block array index */
                                        /* 512-bit message blocks */
    uint8_t Message_Block[SHA1_Message_Block_Size];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    int Computed;                   /* Is the hash computed? */
    int Corrupted;                  /* Cumulative corruption code */
} SHA1Context;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  This structure will hold context information for the SHA-256
 *  hashing operation.
 */
typedef struct SHA256Context {
    uint32_t Intermediate_Hash[SHA256HashSize/4]; /* Message Digest */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    uint32_t Length_High;               /* Message length in bits */
    uint32_t Length_Low;                /* Message length in bits */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    int_least16_t Message_Block_Index;  /* Message_Block array index */
                                        /* 512-bit message blocks */
    uint8_t Message_Block[SHA256_Message_Block_Size];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    int Computed;                   /* Is the hash computed? */
    int Corrupted;                  /* Cumulative corruption code */
} SHA256Context;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  This structure will hold context information for the SHA-512
 *  hashing operation.
 */
typedef struct SHA512Context {
#ifdef USE_32BIT_ONLY
    uint32_t Intermediate_Hash[SHA512HashSize/4]; /* Message Digest  */
    uint32_t Length[4];                 /* Message length in bits */
#else /* !USE_32BIT_ONLY */
    uint64_t Intermediate_Hash[SHA512HashSize/8]; /* Message Digest */
    uint64_t Length_High, Length_Low;   /* Message length in bits */
#endif /* USE_32BIT_ONLY */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    int_least16_t Message_Block_Index;  /* Message_Block array index */
                                        /* 1024-bit message blocks */
    uint8_t Message_Block[SHA512_Message_Block_Size];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    int Computed;                   /* Is the hash computed?*/
    int Corrupted;                  /* Cumulative corruption code */
} SHA512Context;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  This structure will hold context information for the SHA-224
 *  hashing operation.  It uses the SHA-256 structure for computation.
 */
typedef struct SHA256Context SHA224Context;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  This structure will hold context information for the SHA-384
 *  hashing operation.  It uses the SHA-512 structure for computation.
 */
typedef struct SHA512Context SHA384Context;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  This structure holds context information for all SHA
 *  hashing operations.
 */
typedef struct USHAContext {
    int whichSha;               /* which SHA is being used */
    union {
      SHA1Context sha1Context;
      SHA224Context sha224Context; SHA256Context sha256Context;
      SHA384Context sha384Context; SHA512Context sha512Context;
    } ctx;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
} USHAContext;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
} USHAContext。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  This structure will hold context information for the HMAC
 *  keyed-hashing operation.
 */
typedef struct HMACContext {
    int whichSha;               /* which SHA is being used */
    int hashSize;               /* hash size of SHA being used */
    int blockSize;              /* block size of SHA being used */
    USHAContext shaContext;     /* SHA context */
    unsigned char k_opad[USHA_Max_Message_Block_Size];
                        /* outer padding - key XORd with opad */
    int Computed;               /* Is the MAC computed? */
    int Corrupted;              /* Cumulative corruption code */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
} HMACContext;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
} HMACContext。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  This structure will hold context information for the HKDF
 *  extract-and-expand Key Derivation Functions.
 */
typedef struct HKDFContext {
    int whichSha;               /* which SHA is being used */
    HMACContext hmacContext;
    int hashSize;               /* hash size of SHA being used */
    unsigned char prk[USHAMaxHashSize];
                        /* pseudo-random key - output of hkdfInput */
    int Computed;               /* Is the key material computed? */
    int Corrupted;              /* Cumulative corruption code */
} HKDFContext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Function Prototypes
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* SHA-1 */
extern int SHA1Reset(SHA1Context *);
extern int SHA1Input(SHA1Context *, const uint8_t *bytes,
                     unsigned int bytecount);
extern int SHA1FinalBits(SHA1Context *, uint8_t bits,
                         unsigned int bit_count);
extern int SHA1Result(SHA1Context *,
                      uint8_t Message_Digest[SHA1HashSize]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* SHA-224 */
extern int SHA224Reset(SHA224Context *);
extern int SHA224Input(SHA224Context *, const uint8_t *bytes,
                       unsigned int bytecount);
extern int SHA224FinalBits(SHA224Context *, uint8_t bits,
                           unsigned int bit_count);
extern int SHA224Result(SHA224Context *,
                        uint8_t Message_Digest[SHA224HashSize]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* SHA-256 */
extern int SHA256Reset(SHA256Context *);
extern int SHA256Input(SHA256Context *, const uint8_t *bytes,
                       unsigned int bytecount);
extern int SHA256FinalBits(SHA256Context *, uint8_t bits,
                           unsigned int bit_count);
extern int SHA256Result(SHA256Context *,
                        uint8_t Message_Digest[SHA256HashSize]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* SHA-384 */
extern int SHA384Reset(SHA384Context *);
extern int SHA384Input(SHA384Context *, const uint8_t *bytes,
                       unsigned int bytecount);
extern int SHA384FinalBits(SHA384Context *, uint8_t bits,
                           unsigned int bit_count);
extern int SHA384Result(SHA384Context *,
                        uint8_t Message_Digest[SHA384HashSize]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* SHA-512 */
extern int SHA512Reset(SHA512Context *);
extern int SHA512Input(SHA512Context *, const uint8_t *bytes,
                       unsigned int bytecount);
extern int SHA512FinalBits(SHA512Context *, uint8_t bits,
                           unsigned int bit_count);
extern int SHA512Result(SHA512Context *,
                        uint8_t Message_Digest[SHA512HashSize]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Unified SHA functions, chosen by whichSha */
extern int USHAReset(USHAContext *context, SHAversion whichSha);
extern int USHAInput(USHAContext *context,
                     const uint8_t *bytes, unsigned int bytecount);
extern int USHAFinalBits(USHAContext *context,
                         uint8_t bits, unsigned int bit_count);
extern int USHAResult(USHAContext *context,
                      uint8_t Message_Digest[USHAMaxHashSize]);
extern int USHABlockSize(enum SHAversion whichSha);
extern int USHAHashSize(enum SHAversion whichSha);
extern int USHAHashSizeBits(enum SHAversion whichSha);
extern const char *USHAHashName(enum SHAversion whichSha);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * HMAC Keyed-Hashing for Message Authentication, RFC 2104,
 * for all SHAs.
 * This interface allows a fixed-length text input to be used.
 */
extern int hmac(SHAversion whichSha, /* which SHA algorithm to use */
    const unsigned char *text,     /* pointer to data stream */
    int text_len,                  /* length of data stream */
    const unsigned char *key,      /* pointer to authentication key */
    int key_len,                   /* length of authentication key */
    uint8_t digest[USHAMaxHashSize]); /* caller digest to fill in */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * HMAC Keyed-Hashing for Message Authentication, RFC 2104,
 * for all SHAs.
 * This interface allows any length of text input to be used.
 */
extern int hmacReset(HMACContext *context, enum SHAversion whichSha,
                     const unsigned char *key, int key_len);
extern int hmacInput(HMACContext *context, const unsigned char *text,
                     int text_len);
extern int hmacFinalBits(HMACContext *context, uint8_t bits,
                         unsigned int bit_count);
extern int hmacResult(HMACContext *context,
                      uint8_t digest[USHAMaxHashSize]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * HKDF HMAC-based Extract-and-Expand Key Derivation Function,
 * RFC 5869, for all SHAs.
 */
extern int hkdf(SHAversion whichSha, const unsigned char *salt,
                int salt_len, const unsigned char *ikm, int ikm_len,
                const unsigned char *info, int info_len,
                uint8_t okm[ ], int okm_len);
extern int hkdfExtract(SHAversion whichSha, const unsigned char *salt,
                       int salt_len, const unsigned char *ikm,
                       int ikm_len, uint8_t prk[USHAMaxHashSize]);
extern int hkdfExpand(SHAversion whichSha, const uint8_t prk[ ],
                      int prk_len, const unsigned char *info,
                      int info_len, uint8_t okm[ ], int okm_len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * HKDF HMAC-based Extract-and-Expand Key Derivation Function,
 * RFC 5869, for all SHAs.
 * This interface allows any length of text input to be used.
 */
extern int hkdfReset(HKDFContext *context, enum SHAversion whichSha,
                     const unsigned char *salt, int salt_len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
extern int hkdfInput(HKDFContext *context, const unsigned char *ikm,
                     int ikm_len);
extern int hkdfFinalBits(HKDFContext *context, uint8_t ikm_bits,
                         unsigned int ikm_bit_count);
extern int hkdfResult(HKDFContext *context,
                      uint8_t prk[USHAMaxHashSize],
                      const unsigned char *info, int info_len,
                      uint8_t okm[USHAMaxHashSize], int okm_len);
#endif /* _SHA_H_ */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. stdint-example.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2。 stdint-example.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If your system does not have &lt;stdint.h&gt;, the following should be adequate as a substitute for compiling the other code in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
お使いのシステムは&lt;stdint.h&gt;がない場合は、次のように、この文書内の他のコードをコンパイルするための代替として十分なはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*********************** stdint-example.h **********************/
/**** Use this file if your system does not have a stdint.h. ***/
/***************** See RFC 6234 for details. *******************/
#ifndef STDINT_H
#define STDINT_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
typedef unsigned long long uint64_t;    /* unsigned 64-bit integer */
typedef unsigned int       uint32_t;    /* unsigned 32-bit integer */
typedef unsigned char      uint8_t;     /* unsigned 8-bit integer */
                                        /* (i.e., unsigned char) */
typedef int int_least32_t;              /* integer of &gt;= 32 bits */
typedef short int_least16_t;            /* integer of &gt;= 16 bits */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#endif /* STDINT_H */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.3. sha-private.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.3。 SHA-private.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sha-private.h header file contains definitions that should only be needed internally in the other code in this document. These definitions should not be needed in application code calling the code provided in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-private.hヘッダファイルにのみ、このドキュメント内の他のコードでは、内部で必要とされなければならない定義が含まれています。これらの定義は、このドキュメントに記載されているコードを呼び出すアプリケーションコードで必要とするべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/************************ sha-private.h ************************/
/***************** See RFC 6234 for details. *******************/
#ifndef _SHA_PRIVATE__H
#define _SHA_PRIVATE__H
/*
 * These definitions are defined in FIPS 180-3, section 4.1.
 * Ch() and Maj() are defined identically in sections 4.1.1,
 * 4.1.2, and 4.1.3.
 *
 * The definitions used in FIPS 180-3 are as follows:
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#ifndef USE_MODIFIED_MACROS
#define SHA_Ch(x,y,z)        (((x) &amp; (y)) ^ ((~(x)) &amp; (z)))
#define SHA_Maj(x,y,z)       (((x) &amp; (y)) ^ ((x) &amp; (z)) ^ ((y) &amp; (z)))
#else /* USE_MODIFIED_MACROS */
/*
 * The following definitions are equivalent and potentially faster.
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define SHA_Ch(x, y, z) (((x) &amp; ((y) ^ (z))) ^ (z)) #define SHA_Maj(x, y, z) (((x) &amp; ((y) | (z))) | ((y) &amp; (z)))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define SHA_Ch（X、Y、Z）（（（X）＆（（Y）^（Z）））^（Z））の#define SHA_Maj（X、Y、Z）（（（X）＆（（Y ）|（Z）））|（（Y）および（Z）））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#endif /* USE_MODIFIED_MACROS */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define SHA_Parity(x, y, z) ((x) ^ (y) ^ (z))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define SHA_Parity（X、Y、Z）（（X）^（Y）^（Z））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#endif /* _SHA_PRIVATE__H */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. The SHA Code
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。 SHAコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This code is primarily intended as expository reference code and could be optimized further. For example, the assignment rotations through the variables a, b, ..., h could be treated as a cycle and the loop unrolled, rather than doing the explicit copying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このコードは、主に解説参照コードとして意図されており、さらに最適化することができます。例えば、変数を介して割り当て回転は、B、...、hは周期として処理することができ、ループ展開ではなく、明示的な複写を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that there are alternative representations of the Ch() and Maj() functions controlled by an ifdef.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IFDEFによって制御CH（）と少佐（）関数の代替表現があることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1. sha1.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1。 sha1.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**************************** sha1.c ***************************/
/***************** See RFC 6234 for details. *******************/
/* Copyright (c) 2011 IETF Trust and the persons identified as */
/* authors of the code.  All rights reserved.                  */
/* See sha.h for terms of use and redistribution.              */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Description:
 *      This file implements the Secure Hash Algorithm SHA-1
 *      as defined in the U.S. National Institute of Standards
 *      and Technology Federal Information Processing Standards
 *      Publication (FIPS PUB) 180-3 published in October 2008
 *      and formerly defined in its predecessors, FIPS PUB 180-1
 *      and FIP PUB 180-2.
 *
 *      A combined document showing all algorithms is available at
 *              http://csrc.nist.gov/publications/fips/
 *                     fips180-3/fips180-3_final.pdf
 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* The SHA-1 algorithm produces a 160-bit message digest for a * given data stream that can serve as a means of providing a * &#34;fingerprint&#34; for a message. * * Portability Issues: * SHA-1 is defined in terms of 32-bit &#34;words&#34;. This code * uses &lt;stdint.h&gt; (included via &#34;sha.h&#34;) to define 32- and * 8-bit unsigned integer types. If your C compiler does * not support 32-bit unsigned integers, this code is not * appropriate. * * Caveats: * SHA-1 is designed to work with messages less than 2^64 bits * long. This implementation uses SHA1Input() to hash the bits * that are a multiple of the size of an 8-bit octet, and then * optionally uses SHA1FinalBits() to hash the final few bits of * the input. */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* SHA-1アルゴリズムは、160ビットのメッセージは、メッセージのため*「指紋」を提供する手段として機能することができる*所与のデータストリームのためにダイジェストを生成します。 *移植性の問題：* SHA-1は、32ビットの &#34;ワード&#34; の用語で定義されています。これは、コード*用途&lt;stdint.h&gt; 32及び* 8ビット符号なし整数型を定義する（「sha.h」を介して含まれています）。お使いのCコンパイラが* 32ビットの符号なし整数をサポートしていない場合、このコードは*適切ではありません。 *警告：* SHA-1が長い* 2 ^ 64ビット未満メッセージで動作するように設計されています。この実装では、8ビットのオクテットのサイズの倍数であるビット*をハッシュし、その後必要に応じて*（SHA1FinalBitsを使用して）入力*の最後の数ビットをハッシュするためにSHA1Input（）を使用します。 * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34; #include &#34;sha-private.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34; の#include &#34;SHA-private.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Define the SHA1 circular left shift macro
 */
#define SHA1_ROTL(bits,word) \
                (((word) &lt;&lt; (bits)) | ((word) &gt;&gt; (32-(bits))))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Add &#34;length&#34; to the length.
 * Set Corrupted when overflow has occurred.
 */
static uint32_t addTemp;
#define SHA1AddLength(context, length)                     \
    (addTemp = (context)-&gt;Length_Low,                      \
     (context)-&gt;Corrupted =                                \
        (((context)-&gt;Length_Low += (length)) &lt; addTemp) &amp;&amp; \
        (++(context)-&gt;Length_High == 0) ? shaInputTooLong  \
                                        : (context)-&gt;Corrupted )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Local Function Prototypes */
static void SHA1ProcessMessageBlock(SHA1Context *context);
static void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte);
static void SHA1PadMessage(SHA1Context *context, uint8_t Pad_Byte);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  SHA1Reset
 *
 *  Description:
 *      This function will initialize the SHA1Context in preparation
 *      for computing a new SHA1 message digest.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to reset.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Reset(SHA1Context *context)
{
  if (!context) return shaNull;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Length_High = context-&gt;Length_Low = 0;
  context-&gt;Message_Block_Index = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Initial Hash Values: FIPS 180-3 section 5.3.1 */
  context-&gt;Intermediate_Hash[0]   = 0x67452301;
  context-&gt;Intermediate_Hash[1]   = 0xEFCDAB89;
  context-&gt;Intermediate_Hash[2]   = 0x98BADCFE;
  context-&gt;Intermediate_Hash[3]   = 0x10325476;
  context-&gt;Intermediate_Hash[4]   = 0xC3D2E1F0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Computed   = 0;
  context-&gt;Corrupted  = shaSuccess;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return shaSuccess; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
shaSuccessリターン。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  SHA1Input
 *
 *  Description:
 *      This function accepts an array of octets as the next portion
 *      of the message.
 *
 *  Parameters:
 *      context: [in/out]
 *          The SHA context to update.
 *      message_array[ ]: [in]
 *          An array of octets representing the next portion of
 *          the message.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *      length: [in]
 *          The length of the message in message_array.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Input(SHA1Context *context,
    const uint8_t *message_array, unsigned length)
{
  if (!context) return shaNull;
  if (!length) return shaSuccess;
  if (!message_array) return shaNull;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
while (length--) { context-&gt;Message_Block[context-&gt;Message_Block_Index++] = *message_array;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方、（length--）{、コンテキスト&gt; Message_Block【、コンテキスト&gt; Message_Block_Index ++] = * message_array。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if ((SHA1AddLength(context, 8) == shaSuccess) &amp;&amp; (context-&gt;Message_Block_Index == SHA1_Message_Block_Size)) SHA1ProcessMessageBlock(context);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IF（（SHA1AddLength（文脈、8）== shaSuccess）&amp;&amp;（、コンテキスト&gt; Message_Block_Index == SHA1_Message_Block_Size））SHA1ProcessMessageBlock（コンテキスト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 message_array++; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
++ message_array; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return context-&gt;Corrupted; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
破損を返し、コンテキスト&gt;。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA1FinalBits
 *
 * Description:
 *   This function will add in any final bits of the message.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   message_bits: [in]
 *     The final bits of the message, in the upper portion of the
 *     byte.  (Use 0b###00000 instead of 0b00000### to input the
 *     three bits ###.)
 *   length: [in]
 *     The number of bits in message_bits, between 1 and 7.
 *
 * Returns:
 *   sha Error Code.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 */
int SHA1FinalBits(SHA1Context *context, uint8_t message_bits,
    unsigned int length)
{
  static uint8_t masks[8] = {
      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,
      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,
      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,
      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE
  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  static uint8_t markbit[8] = {
      /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,
      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,
      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,
      /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01
  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (!context) return shaNull;
  if (!length) return shaSuccess;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  if (length &gt;= 8) return context-&gt;Corrupted = shaBadParam;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  SHA1AddLength(context, length);
  SHA1Finalize(context,
    (uint8_t) ((message_bits &amp; masks[length]) | markbit[length]));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return context-&gt;Corrupted; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
破損を返し、コンテキスト&gt;。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA1Result
 *
 * Description:
 *   This function will return the 160-bit message digest
 *   into the Message_Digest array provided by the caller.
 *   NOTE:
 *    The first octet of hash is stored in the element with index 0,
 *      the last octet of hash in the element with index 19.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to use to calculate the SHA-1 hash.
 *   Message_Digest[ ]: [out]
 *     Where the digest is returned.
 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 * Returns: * sha Error Code. * */ int SHA1Result(SHA1Context *context, uint8_t Message_Digest[SHA1HashSize]) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*戻り値：* SHAエラーコード。 * / INT SHA1Result（SHA1Context *コンテキスト、uint8_t Message_Digest [SHA1HashSize]）{I int型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (!context) return shaNull;
  if (!Message_Digest) return shaNull;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (!context-&gt;Computed) SHA1Finalize(context, 0x80);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もしSHA1Finalize（文脈、0x80の）（、コンテキスト&gt;コンピュー！）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
for (i = 0; i &lt; SHA1HashSize; ++i) Message_Digest[i] = (uint8_t) (context-&gt;Intermediate_Hash[i&gt;&gt;2] &gt;&gt; (8 * ( 3 - ( i &amp; 0x03 ) )));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
用（i = 0; I &lt;SHA1HashSize; ++ I）Message_Digest [I] =（uint8_t）（、コンテキスト&gt; Intermediate_Hash [I &gt;&gt; 2] &gt;&gt;（8 *（3  - （I＆0×03））））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return shaSuccess; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
shaSuccessリターン。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA1ProcessMessageBlock
 *
 * Description:
 *   This helper function will process the next 512 bits of the
 *   message stored in the Message_Block array.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *
 * Returns:
 *   Nothing.
 *
 * Comments:
 *   Many of the variable names in this code, especially the
 *   single character names, were used because those were the
 *   names used in the Secure Hash Standard.
 */
static void SHA1ProcessMessageBlock(SHA1Context *context)
{
  /* Constants defined in FIPS 180-3, section 4.2.1 */
  const uint32_t K[4] = {
      0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6
  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  int        t;               /* Loop counter */
  uint32_t   temp;            /* Temporary word value */
  uint32_t   W[80];           /* Word sequence */
  uint32_t   A, B, C, D, E;   /* Word buffers */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Initialize the first 16 words in the array W
   */
  for (t = 0; t &lt; 16; t++) {
    W[t]  = ((uint32_t)context-&gt;Message_Block[t * 4]) &lt;&lt; 24;
    W[t] |= ((uint32_t)context-&gt;Message_Block[t * 4 + 1]) &lt;&lt; 16;
    W[t] |= ((uint32_t)context-&gt;Message_Block[t * 4 + 2]) &lt;&lt; 8;
    W[t] |= ((uint32_t)context-&gt;Message_Block[t * 4 + 3]);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
for (t = 16; t &lt; 80; t++) W[t] = SHA1_ROTL(1, W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
用（T = 16、T &lt;80; T ++）W [T] = SHA1_ROTL（1、W [T-3] ^ W [T-8] ^ W [T-14] ^ W [T-16]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  A = context-&gt;Intermediate_Hash[0];
  B = context-&gt;Intermediate_Hash[1];
  C = context-&gt;Intermediate_Hash[2];
  D = context-&gt;Intermediate_Hash[3];
  E = context-&gt;Intermediate_Hash[4];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (t = 0; t &lt; 20; t++) {
    temp = SHA1_ROTL(5,A) + SHA_Ch(B, C, D) + E + W[t] + K[0];
    E = D;
    D = C;
    C = SHA1_ROTL(30,B);
    B = A;
    A = temp;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (t = 20; t &lt; 40; t++) {
    temp = SHA1_ROTL(5,A) + SHA_Parity(B, C, D) + E + W[t] + K[1];
    E = D;
    D = C;
    C = SHA1_ROTL(30,B);
    B = A;
    A = temp;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (t = 40; t &lt; 60; t++) {
    temp = SHA1_ROTL(5,A) + SHA_Maj(B, C, D) + E + W[t] + K[2];
    E = D;
    D = C;
    C = SHA1_ROTL(30,B);
    B = A;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 A = temp; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
=温度; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (t = 60; t &lt; 80; t++) {
    temp = SHA1_ROTL(5,A) + SHA_Parity(B, C, D) + E + W[t] + K[3];
    E = D;
    D = C;
    C = SHA1_ROTL(30,B);
    B = A;
    A = temp;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Intermediate_Hash[0] += A;
  context-&gt;Intermediate_Hash[1] += B;
  context-&gt;Intermediate_Hash[2] += C;
  context-&gt;Intermediate_Hash[3] += D;
  context-&gt;Intermediate_Hash[4] += E;
  context-&gt;Message_Block_Index = 0;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA1Finalize
 *
 * Description:
 *   This helper function finishes off the digest calculations.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   Pad_Byte: [in]
 *     The last byte to add to the message block before the 0-padding
 *     and length.  This will contain the last bits of the message
 *     followed by another single bit.  If the message was an
 *     exact multiple of 8-bits long, Pad_Byte will be 0x80.
 *
 * Returns:
 *   sha Error Code.
 *
 */
static void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte)
{
  int i;
  SHA1PadMessage(context, Pad_Byte);
  /* message may be sensitive, clear it out */
  for (i = 0; i &lt; SHA1_Message_Block_Size; ++i)
    context-&gt;Message_Block[i] = 0;
  context-&gt;Length_High = 0;     /* and clear length */
  context-&gt;Length_Low = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 context-&gt;Computed = 1; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、コンテキスト&gt;計算結果= 1。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA1PadMessage
 *
 * Description:
 *   According to the standard, the message must be padded to the next
 *   even multiple of 512 bits.  The first padding bit must be a &#39;1&#39;.
 *   The last 64 bits represent the length of the original message.
 *   All bits in between should be 0.  This helper function will pad
 *   the message according to those rules by filling the Message_Block
 *   array accordingly.  When it returns, it can be assumed that the
 *   message digest has been computed.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to pad.
 *   Pad_Byte: [in]
 *     The last byte to add to the message block before the 0-padding
 *     and length.  This will contain the last bits of the message
 *     followed by another single bit.  If the message was an
 *     exact multiple of 8-bits long, Pad_Byte will be 0x80.
 *
 * Returns:
 *   Nothing.
 */
static void SHA1PadMessage(SHA1Context *context, uint8_t Pad_Byte)
{
  /*
   * Check to see if the current message block is too small to hold
   * the initial padding bits and length.  If so, we will pad the
   * block, process it, and then continue padding into a second
   * block.
   */
  if (context-&gt;Message_Block_Index &gt;= (SHA1_Message_Block_Size - 8)) {
    context-&gt;Message_Block[context-&gt;Message_Block_Index++] = Pad_Byte;
    while (context-&gt;Message_Block_Index &lt; SHA1_Message_Block_Size)
      context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    SHA1ProcessMessageBlock(context);
  } else
    context-&gt;Message_Block[context-&gt;Message_Block_Index++] = Pad_Byte;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
while (context-&gt;Message_Block_Index &lt; (SHA1_Message_Block_Size - 8)) context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方、（、コンテキスト&gt; Message_Block_Index &lt;（SHA1_Message_Block_Size  -  8））、コンテキスト&gt; Message_Block【、コンテキスト&gt; Message_Block_Index ++] = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Store the message length as the last 8 octets
   */
  context-&gt;Message_Block[56] = (uint8_t) (context-&gt;Length_High &gt;&gt; 24);
  context-&gt;Message_Block[57] = (uint8_t) (context-&gt;Length_High &gt;&gt; 16);
  context-&gt;Message_Block[58] = (uint8_t) (context-&gt;Length_High &gt;&gt; 8);
  context-&gt;Message_Block[59] = (uint8_t) (context-&gt;Length_High);
  context-&gt;Message_Block[60] = (uint8_t) (context-&gt;Length_Low &gt;&gt; 24);
  context-&gt;Message_Block[61] = (uint8_t) (context-&gt;Length_Low &gt;&gt; 16);
  context-&gt;Message_Block[62] = (uint8_t) (context-&gt;Length_Low &gt;&gt; 8);
  context-&gt;Message_Block[63] = (uint8_t) (context-&gt;Length_Low);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 SHA1ProcessMessageBlock(context); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA1ProcessMessageBlock（コンテキスト）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2. sha224-256.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2。 sha224-256.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/************************* sha224-256.c ************************/
/***************** See RFC 6234 for details. *******************/
/* Copyright (c) 2011 IETF Trust and the persons identified as */
/* authors of the code.  All rights reserved.                  */
/* See sha.h for terms of use and redistribution.              */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Description:
 *   This file implements the Secure Hash Algorithms SHA-224 and
 *   SHA-256 as defined in the U.S. National Institute of Standards
 *   and Technology Federal Information Processing Standards
 *   Publication (FIPS PUB) 180-3 published in October 2008
 *   and formerly defined in its predecessors, FIPS PUB 180-1
 *   and FIP PUB 180-2.
 *
 *   A combined document showing all algorithms is available at
 *       http://csrc.nist.gov/publications/fips/
 *              fips180-3/fips180-3_final.pdf
 *
 *   The SHA-224 and SHA-256 algorithms produce 224-bit and 256-bit
 *   message digests for a given data stream.  It should take about
 *   2**n steps to find a message with the same digest as a given
 *   message and 2**(n/2) to find any two messages with the same
 *   digest, when n is the digest size in bits.  Therefore, this
 *   algorithm can serve as a means of providing a
 *   &#34;fingerprint&#34; for a message.
 *
 * Portability Issues:
 *   SHA-224 and SHA-256 are defined in terms of 32-bit &#34;words&#34;.
 *   This code uses &lt;stdint.h&gt; (included via &#34;sha.h&#34;) to define 32-
 *   and 8-bit unsigned integer types.  If your C compiler does not
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* support 32-bit unsigned integers, this code is not * appropriate. * * Caveats: * SHA-224 and SHA-256 are designed to work with messages less * than 2^64 bits long. This implementation uses SHA224/256Input() * to hash the bits that are a multiple of the size of an 8-bit * octet, and then optionally uses SHA224/256FinalBits() * to hash the final few bits of the input. */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*サポート32ビット符号なし整数、このコードは*適切ではありません。 *警告：* SHA-224およびSHA-256は、2 ^ 64ビット長より*少ないメッセージで動作するように設計されています。この実装では、8ビット・オクテットのサイズの倍数であるビットをハッシュするSHA224 / 256Input（）*を使用し、その後必要に応じてSHA224 / 256FinalBits（）*入力の最後の数ビットをハッシュするために使用します。 * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34; #include &#34;sha-private.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34; の#include &#34;SHA-private.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Define the SHA shift, rotate left, and rotate right macros */
#define SHA256_SHR(bits,word)      ((word) &gt;&gt; (bits))
#define SHA256_ROTL(bits,word)                         \
  (((word) &lt;&lt; (bits)) | ((word) &gt;&gt; (32-(bits))))
#define SHA256_ROTR(bits,word)                         \
  (((word) &gt;&gt; (bits)) | ((word) &lt;&lt; (32-(bits))))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Define the SHA SIGMA and sigma macros */
#define SHA256_SIGMA0(word)   \
  (SHA256_ROTR( 2,word) ^ SHA256_ROTR(13,word) ^ SHA256_ROTR(22,word))
#define SHA256_SIGMA1(word)   \
  (SHA256_ROTR( 6,word) ^ SHA256_ROTR(11,word) ^ SHA256_ROTR(25,word))
#define SHA256_sigma0(word)   \
  (SHA256_ROTR( 7,word) ^ SHA256_ROTR(18,word) ^ SHA256_SHR( 3,word))
#define SHA256_sigma1(word)   \
  (SHA256_ROTR(17,word) ^ SHA256_ROTR(19,word) ^ SHA256_SHR(10,word))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Add &#34;length&#34; to the length.
 * Set Corrupted when overflow has occurred.
 */
static uint32_t addTemp;
#define SHA224_256AddLength(context, length)               \
  (addTemp = (context)-&gt;Length_Low, (context)-&gt;Corrupted = \
    (((context)-&gt;Length_Low += (length)) &lt; addTemp) &amp;&amp;     \
    (++(context)-&gt;Length_High == 0) ? shaInputTooLong :    \
                                      (context)-&gt;Corrupted )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Local Function Prototypes */
static int SHA224_256Reset(SHA256Context *context, uint32_t *H0);
static void SHA224_256ProcessMessageBlock(SHA256Context *context);
static void SHA224_256Finalize(SHA256Context *context,
  uint8_t Pad_Byte);
static void SHA224_256PadMessage(SHA256Context *context,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  uint8_t Pad_Byte);
static int SHA224_256ResultN(SHA256Context *context,
  uint8_t Message_Digest[ ], int HashSize);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Initial Hash Values: FIPS 180-3 section 5.3.2 */
static uint32_t SHA224_H0[SHA256HashSize/4] = {
    0xC1059ED8, 0x367CD507, 0x3070DD17, 0xF70E5939,
    0xFFC00B31, 0x68581511, 0x64F98FA7, 0xBEFA4FA4
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Initial Hash Values: FIPS 180-3 section 5.3.3 */
static uint32_t SHA256_H0[SHA256HashSize/4] = {
  0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
  0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA224Reset
 *
 * Description:
 *   This function will initialize the SHA224Context in preparation
 *   for computing a new SHA224 message digest.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to reset.
 *
 * Returns:
 *   sha Error Code.
 */
int SHA224Reset(SHA224Context *context)
{
  return SHA224_256Reset(context, SHA224_H0);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA224Input
 *
 * Description:
 *   This function accepts an array of octets as the next portion
 *   of the message.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   message_array[ ]: [in]
 *     An array of octets representing the next portion of
 *     the message.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 * length: [in] * The length of the message in message_array. * * Returns: * sha Error Code. * */ int SHA224Input(SHA224Context *context, const uint8_t *message_array, unsigned int length) { return SHA256Input(context, message_array, length); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*長さ：[IN] * message_array内のメッセージの長さ。 * *戻り値：* SHAエラーコード。 * / INT SHA224Input（SHA224Context *コンテキスト、CONST uint8_t * message_array、unsigned int型の長さ）{SHA256Input（文脈、message_array、長さ）を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA224FinalBits
 *
 * Description:
 *   This function will add in any final bits of the message.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   message_bits: [in]
 *     The final bits of the message, in the upper portion of the
 *     byte.  (Use 0b###00000 instead of 0b00000### to input the
 *     three bits ###.)
 *   length: [in]
 *     The number of bits in message_bits, between 1 and 7.
 *
 * Returns:
 *   sha Error Code.
 */
int SHA224FinalBits(SHA224Context *context,
                    uint8_t message_bits, unsigned int length)
{
  return SHA256FinalBits(context, message_bits, length);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA224Result
 *
 * Description:
 *   This function will return the 224-bit message digest
 *   into the Message_Digest array provided by the caller.
 *   NOTE:
 *    The first octet of hash is stored in the element with index 0,
 *    the last octet of hash in the element with index 27.
 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 * Parameters: * context: [in/out] * The context to use to calculate the SHA hash. * Message_Digest[ ]: [out] * Where the digest is returned. * * Returns: * sha Error Code. */ int SHA224Result(SHA224Context *context, uint8_t Message_Digest[SHA224HashSize]) { return SHA224_256ResultN(context, Message_Digest, SHA224HashSize); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*パラメータ：*コンテキスト：SHAハッシュを計算するために使用する[IN / OUT] *文脈。 * Message_Digest []：[外] *ダイジェストが返される場合。 * *戻り値：* SHAエラーコード。 * / INT SHA224Result（SHA224Context *コンテキスト、Message_Digest [SHA224HashSize] uint8_t）{SHA224_256ResultN（文脈、Message_Digest、SHA224HashSize）を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA256Reset
 *
 * Description:
 *   This function will initialize the SHA256Context in preparation
 *   for computing a new SHA256 message digest.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to reset.
 *
 * Returns:
 *   sha Error Code.
 */
int SHA256Reset(SHA256Context *context)
{
  return SHA224_256Reset(context, SHA256_H0);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA256Input
 *
 * Description:
 *   This function accepts an array of octets as the next portion
 *   of the message.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   message_array[ ]: [in]
 *     An array of octets representing the next portion of
 *     the message.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *   length: [in]
 *     The length of the message in message_array.
 *
 * Returns:
 *   sha Error Code.
 */
int SHA256Input(SHA256Context *context, const uint8_t *message_array,
    unsigned int length)
{
  if (!context) return shaNull;
  if (!length) return shaSuccess;
  if (!message_array) return shaNull;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
while (length--) { context-&gt;Message_Block[context-&gt;Message_Block_Index++] = *message_array;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方、（length--）{、コンテキスト&gt; Message_Block【、コンテキスト&gt; Message_Block_Index ++] = * message_array。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if ((SHA224_256AddLength(context, 8) == shaSuccess) &amp;&amp; (context-&gt;Message_Block_Index == SHA256_Message_Block_Size)) SHA224_256ProcessMessageBlock(context);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IF（（SHA224_256AddLength（文脈、8）== shaSuccess）&amp;&amp;（、コンテキスト&gt; Message_Block_Index == SHA256_Message_Block_Size））SHA224_256ProcessMessageBlock（コンテキスト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 message_array++; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
++ message_array; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
return context-&gt;Corrupted;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
破損を返し、コンテキスト&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA256FinalBits
 *
 * Description:
 *   This function will add in any final bits of the message.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   message_bits: [in]
 *     The final bits of the message, in the upper portion of the
 *     byte.  (Use 0b###00000 instead of 0b00000### to input the
 *     three bits ###.)
 *   length: [in]
 *     The number of bits in message_bits, between 1 and 7.
 *
 * Returns:
 *   sha Error Code.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 */
int SHA256FinalBits(SHA256Context *context,
                    uint8_t message_bits, unsigned int length)
{
  static uint8_t masks[8] = {
      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,
      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,
      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,
      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE
  };
  static uint8_t markbit[8] = {
      /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,
      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,
      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,
      /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01
  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (!context) return shaNull;
  if (!length) return shaSuccess;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  if (length &gt;= 8) return context-&gt;Corrupted = shaBadParam;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  SHA224_256AddLength(context, length);
  SHA224_256Finalize(context, (uint8_t)
    ((message_bits &amp; masks[length]) | markbit[length]));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return context-&gt;Corrupted; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
破損を返し、コンテキスト&gt;。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA256Result
 *
 * Description:
 *   This function will return the 256-bit message digest
 *   into the Message_Digest array provided by the caller.
 *   NOTE:
 *    The first octet of hash is stored in the element with index 0,
 *    the last octet of hash in the element with index 31.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to use to calculate the SHA hash.
 *   Message_Digest[ ]: [out]
 *     Where the digest is returned.
 *
 * Returns:
 *   sha Error Code.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 */ int SHA256Result(SHA256Context *context, uint8_t Message_Digest[SHA256HashSize]) { return SHA224_256ResultN(context, Message_Digest, SHA256HashSize); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* / INT SHA256Result（SHA256Context *コンテキスト、Message_Digest [SHA256HashSize] uint8_t）{SHA224_256ResultN（文脈、Message_Digest、SHA256HashSize）を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA224_256Reset
 *
 * Description:
 *   This helper function will initialize the SHA256Context in
 *   preparation for computing a new SHA-224 or SHA-256 message digest.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to reset.
 *   H0[ ]: [in]
 *     The initial hash value array to use.
 *
 * Returns:
 *   sha Error Code.
 */
static int SHA224_256Reset(SHA256Context *context, uint32_t *H0)
{
  if (!context) return shaNull;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Length_High = context-&gt;Length_Low = 0;
  context-&gt;Message_Block_Index  = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Intermediate_Hash[0] = H0[0];
  context-&gt;Intermediate_Hash[1] = H0[1];
  context-&gt;Intermediate_Hash[2] = H0[2];
  context-&gt;Intermediate_Hash[3] = H0[3];
  context-&gt;Intermediate_Hash[4] = H0[4];
  context-&gt;Intermediate_Hash[5] = H0[5];
  context-&gt;Intermediate_Hash[6] = H0[6];
  context-&gt;Intermediate_Hash[7] = H0[7];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Computed  = 0;
  context-&gt;Corrupted = shaSuccess;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return shaSuccess; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
shaSuccessリターン。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA224_256ProcessMessageBlock
 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 * Description:
 *   This helper function will process the next 512 bits of the
 *   message stored in the Message_Block array.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *
 * Returns:
 *   Nothing.
 *
 * Comments:
 *   Many of the variable names in this code, especially the
 *   single character names, were used because those were the
 *   names used in the Secure Hash Standard.
 */
static void SHA224_256ProcessMessageBlock(SHA256Context *context)
{
  /* Constants defined in FIPS 180-3, section 4.2.2 */
  static const uint32_t K[64] = {
      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
      0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
      0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
      0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
      0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
      0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
      0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
      0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
      0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
      0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
      0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
      0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  };
  int        t, t4;                   /* Loop counter */
  uint32_t   temp1, temp2;            /* Temporary word value */
  uint32_t   W[64];                   /* Word sequence */
  uint32_t   A, B, C, D, E, F, G, H;  /* Word buffers */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Initialize the first 16 words in the array W
   */
  for (t = t4 = 0; t &lt; 16; t++, t4 += 4)
    W[t] = (((uint32_t)context-&gt;Message_Block[t4]) &lt;&lt; 24) |
           (((uint32_t)context-&gt;Message_Block[t4 + 1]) &lt;&lt; 16) |
           (((uint32_t)context-&gt;Message_Block[t4 + 2]) &lt;&lt; 8) |
           (((uint32_t)context-&gt;Message_Block[t4 + 3]));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
for (t = 16; t &lt; 64; t++) W[t] = SHA256_sigma1(W[t-2]) + W[t-7] + SHA256_sigma0(W[t-15]) + W[t-16];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
用（T = 16、T &lt;64; T ++）W [T] = SHA256_sigma1（W [T-2]）+ [T-7] W + SHA256_sigma0（W [T-15]）+ W [T-16] ;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  A = context-&gt;Intermediate_Hash[0];
  B = context-&gt;Intermediate_Hash[1];
  C = context-&gt;Intermediate_Hash[2];
  D = context-&gt;Intermediate_Hash[3];
  E = context-&gt;Intermediate_Hash[4];
  F = context-&gt;Intermediate_Hash[5];
  G = context-&gt;Intermediate_Hash[6];
  H = context-&gt;Intermediate_Hash[7];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (t = 0; t &lt; 64; t++) {
    temp1 = H + SHA256_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];
    temp2 = SHA256_SIGMA0(A) + SHA_Maj(A,B,C);
    H = G;
    G = F;
    F = E;
    E = D + temp1;
    D = C;
    C = B;
    B = A;
    A = temp1 + temp2;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Intermediate_Hash[0] += A;
  context-&gt;Intermediate_Hash[1] += B;
  context-&gt;Intermediate_Hash[2] += C;
  context-&gt;Intermediate_Hash[3] += D;
  context-&gt;Intermediate_Hash[4] += E;
  context-&gt;Intermediate_Hash[5] += F;
  context-&gt;Intermediate_Hash[6] += G;
  context-&gt;Intermediate_Hash[7] += H;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 context-&gt;Message_Block_Index = 0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、コンテキスト&gt; Message_Block_Index = 0; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA224_256Finalize
 *
 * Description:
 *   This helper function finishes off the digest calculations.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   Pad_Byte: [in]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *     The last byte to add to the message block before the 0-padding
 *     and length.  This will contain the last bits of the message
 *     followed by another single bit.  If the message was an
 *     exact multiple of 8-bits long, Pad_Byte will be 0x80.
 *
 * Returns:
 *   sha Error Code.
 */
static void SHA224_256Finalize(SHA256Context *context,
    uint8_t Pad_Byte)
{
  int i;
  SHA224_256PadMessage(context, Pad_Byte);
  /* message may be sensitive, so clear it out */
  for (i = 0; i &lt; SHA256_Message_Block_Size; ++i)
    context-&gt;Message_Block[i] = 0;
  context-&gt;Length_High = 0;     /* and clear length */
  context-&gt;Length_Low = 0;
  context-&gt;Computed = 1;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA224_256PadMessage
 *
 * Description:
 *   According to the standard, the message must be padded to the next
 *   even multiple of 512 bits.  The first padding bit must be a &#39;1&#39;.
 *   The last 64 bits represent the length of the original message.
 *   All bits in between should be 0.  This helper function will pad
 *   the message according to those rules by filling the
 *   Message_Block array accordingly.  When it returns, it can be
 *   assumed that the message digest has been computed.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to pad.
 *   Pad_Byte: [in]
 *     The last byte to add to the message block before the 0-padding
 *     and length.  This will contain the last bits of the message
 *     followed by another single bit.  If the message was an
 *     exact multiple of 8-bits long, Pad_Byte will be 0x80.
 *
 * Returns:
 *   Nothing.
 */
static void SHA224_256PadMessage(SHA256Context *context,
    uint8_t Pad_Byte)
{
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Check to see if the current message block is too small to hold
   * the initial padding bits and length.  If so, we will pad the
   * block, process it, and then continue padding into a second
   * block.
   */
  if (context-&gt;Message_Block_Index &gt;= (SHA256_Message_Block_Size-8)) {
    context-&gt;Message_Block[context-&gt;Message_Block_Index++] = Pad_Byte;
    while (context-&gt;Message_Block_Index &lt; SHA256_Message_Block_Size)
      context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
    SHA224_256ProcessMessageBlock(context);
  } else
    context-&gt;Message_Block[context-&gt;Message_Block_Index++] = Pad_Byte;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
while (context-&gt;Message_Block_Index &lt; (SHA256_Message_Block_Size-8)) context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方、（、コンテキスト&gt; Message_Block_Index &lt;（SHA256_Message_Block_Size-8））、コンテキスト&gt; Message_Block【、コンテキスト&gt; Message_Block_Index ++] = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Store the message length as the last 8 octets
   */
  context-&gt;Message_Block[56] = (uint8_t)(context-&gt;Length_High &gt;&gt; 24);
  context-&gt;Message_Block[57] = (uint8_t)(context-&gt;Length_High &gt;&gt; 16);
  context-&gt;Message_Block[58] = (uint8_t)(context-&gt;Length_High &gt;&gt; 8);
  context-&gt;Message_Block[59] = (uint8_t)(context-&gt;Length_High);
  context-&gt;Message_Block[60] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 24);
  context-&gt;Message_Block[61] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 16);
  context-&gt;Message_Block[62] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 8);
  context-&gt;Message_Block[63] = (uint8_t)(context-&gt;Length_Low);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 SHA224_256ProcessMessageBlock(context); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA224_256ProcessMessageBlock（コンテキスト）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA224_256ResultN
 *
 * Description:
 *   This helper function will return the 224-bit or 256-bit message
 *   digest into the Message_Digest array provided by the caller.
 *   NOTE:
 *    The first octet of hash is stored in the element with index 0,
 *    the last octet of hash in the element with index 27/31.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to use to calculate the SHA hash.
 *   Message_Digest[ ]: [out]
 *     Where the digest is returned.
 *   HashSize: [in]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 * The size of the hash, either 28 or 32. * * Returns: * sha Error Code. */ static int SHA224_256ResultN(SHA256Context *context, uint8_t Message_Digest[ ], int HashSize) { int i;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*ハッシュのサイズ、いずれか28または32 * *戻り値：* SHAエラーコード。 * /静的INT SHA224_256ResultN（SHA256Context *コンテキスト、uint8_t Message_Digest []、INT HASHSIZE）{iはint型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (!context) return shaNull;
  if (!Message_Digest) return shaNull;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (!context-&gt;Computed) SHA224_256Finalize(context, 0x80);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もしSHA224_256Finalize（文脈、0x80の）（、コンテキスト&gt;コンピュー！）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
for (i = 0; i &lt; HashSize; ++i) Message_Digest[i] = (uint8_t) (context-&gt;Intermediate_Hash[i&gt;&gt;2] &gt;&gt; 8 * ( 3 - ( i &amp; 0x03 ) ));
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
用（i = 0; I &lt;HASHSIZE; ++ I）Message_Digest [I] =（uint8_t）（、コンテキスト&gt; Intermediate_Hash [I &gt;&gt; 2] &gt;&gt; 8 *（3  - （I＆0×03）））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return shaSuccess; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
shaSuccessリターン。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.3. sha384-512.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.3。 sha384-512.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/************************* sha384-512.c ************************/
/***************** See RFC 6234 for details. *******************/
/* Copyright (c) 2011 IETF Trust and the persons identified as */
/* authors of the code.  All rights reserved.                  */
/* See sha.h for terms of use and redistribution.              */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Description:
 *   This file implements the Secure Hash Algorithms SHA-384 and
 *   SHA-512 as defined in the U.S. National Institute of Standards
 *   and Technology Federal Information Processing Standards
 *   Publication (FIPS PUB) 180-3 published in October 2008
 *   and formerly defined in its predecessors, FIPS PUB 180-1
 *   and FIP PUB 180-2.
 *
 *   A combined document showing all algorithms is available at
 *       http://csrc.nist.gov/publications/fips/
 *              fips180-3/fips180-3_final.pdf
 *
 *   The SHA-384 and SHA-512 algorithms produce 384-bit and 512-bit
 *   message digests for a given data stream.  It should take about
 *   2**n steps to find a message with the same digest as a given
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* message and 2**(n/2) to find any two messages with the same * digest, when n is the digest size in bits. Therefore, this * algorithm can serve as a means of providing a * &#34;fingerprint&#34; for a message. * * Portability Issues: * SHA-384 and SHA-512 are defined in terms of 64-bit &#34;words&#34;, * but if USE_32BIT_ONLY is #defined, this code is implemented in * terms of 32-bit &#34;words&#34;. This code uses &lt;stdint.h&gt; (included * via &#34;sha.h&#34;) to define the 64-, 32- and 8-bit unsigned integer * types. If your C compiler does not support 64-bit unsigned * integers and you do not #define USE_32BIT_ONLY, this code is * not appropriate. * * Caveats: * SHA-384 and SHA-512 are designed to work with messages less * than 2^128 bits long. This implementation uses SHA384/512Input() * to hash the bits that are a multiple of the size of an 8-bit * octet, and then optionally uses SHA384/256FinalBits() * to hash the final few bits of the input. * */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*同じで任意の2つのメッセージを検索するためのメッセージと2 **（N / 2）*ダイジェストときNビットでダイジェストサイズです。したがって、この*アルゴリズムは、メッセージのために*「指紋」を提供する手段としての役割を果たすことができます。 *移植性の問題：* SHA-384およびSHA-512は、64ビットの「ワード」、*で定義されているが、USE_32BIT_ONLYが#defineで定義されている場合、このコードは、32ビットの「ワード」の*点で実現されます。このコードは、64、32、8ビットの符号なし整数*タイプを定義する（「sha.h」を介し*含む）&lt;stdint.h&gt;を使用します。お使いのCコンパイラが64ビットの符号なし整数*をサポートしていないとあなたがUSE_32BIT_ONLYを#defineしていない場合は、このコードは*適切ではありません。 *警告：* SHA-384およびSHA-512は、長い2 ^ 128ビットより少ない*メッセージで動作するように設計されています。この実装では、8ビット・オクテットのサイズの倍数であるビットをハッシュするSHA384 / 512Input（）*を使用し、その後必要に応じてSHA384 / 256FinalBits（）*入力の最後の数ビットをハッシュするために使用します。 * * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#ifdef USE_32BIT_ONLY
/*
 * Define 64-bit arithmetic in terms of 32-bit arithmetic.
 * Each 64-bit number is represented in a 2-word array.
 * All macros are defined such that the result is the last parameter.
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Define shift, rotate left, and rotate right functions
 */
#define SHA512_SHR(bits, word, ret) (                          \
    /* (((uint64_t)((word))) &gt;&gt; (bits)) */                     \
    (ret)[0] = (((bits) &lt; 32) &amp;&amp; ((bits) &gt;= 0)) ?              \
      ((word)[0] &gt;&gt; (bits)) : 0,                               \
    (ret)[1] = ((bits) &gt; 32) ? ((word)[0] &gt;&gt; ((bits) - 32)) :  \
      ((bits) == 32) ? (word)[0] :                             \
      ((bits) &gt;= 0) ?                                          \
        (((word)[0] &lt;&lt; (32 - (bits))) |                        \
        ((word)[1] &gt;&gt; (bits))) : 0 )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define SHA512_SHL(bits, word, ret) (                          \
    /* (((uint64_t)(word)) &lt;&lt; (bits)) */                       \
    (ret)[0] = ((bits) &gt; 32) ? ((word)[1] &lt;&lt; ((bits) - 32)) :  \
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         ((bits) == 32) ? (word)[1] :                          \
         ((bits) &gt;= 0) ?                                       \
           (((word)[0] &lt;&lt; (bits)) |                            \
           ((word)[1] &gt;&gt; (32 - (bits)))) :                     \
         0,                                                    \
    (ret)[1] = (((bits) &lt; 32) &amp;&amp; ((bits) &gt;= 0)) ?              \
        ((word)[1] &lt;&lt; (bits)) : 0 )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Define 64-bit OR
 */
#define SHA512_OR(word1, word2, ret) (                         \
    (ret)[0] = (word1)[0] | (word2)[0],                        \
    (ret)[1] = (word1)[1] | (word2)[1] )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Define 64-bit XOR
 */
#define SHA512_XOR(word1, word2, ret) (                        \
    (ret)[0] = (word1)[0] ^ (word2)[0],                        \
    (ret)[1] = (word1)[1] ^ (word2)[1] )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Define 64-bit AND
 */
#define SHA512_AND(word1, word2, ret) (                        \
    (ret)[0] = (word1)[0] &amp; (word2)[0],                        \
    (ret)[1] = (word1)[1] &amp; (word2)[1] )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Define 64-bit TILDA
 */
#define SHA512_TILDA(word, ret)                                \
  ( (ret)[0] = ~(word)[0], (ret)[1] = ~(word)[1] )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Define 64-bit ADD
 */
#define SHA512_ADD(word1, word2, ret) (                        \
    (ret)[1] = (word1)[1], (ret)[1] += (word2)[1],             \
    (ret)[0] = (word1)[0] + (word2)[0] + ((ret)[1] &lt; (word1)[1]) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Add the 4word value in word2 to word1.
 */
static uint32_t ADDTO4_temp, ADDTO4_temp2;
#define SHA512_ADDTO4(word1, word2) (                          \
    ADDTO4_temp = (word1)[3],                                  \ (word1)[3] += (word2)[3],                                  \
    ADDTO4_temp2 = (word1)[2],                                 \
    (word1)[2] += (word2)[2] + ((word1)[3] &lt; ADDTO4_temp),     \
    ADDTO4_temp = (word1)[1],                                  \
    (word1)[1] += (word2)[1] + ((word1)[2] &lt; ADDTO4_temp2),    \
    (word1)[0] += (word2)[0] + ((word1)[1] &lt; ADDTO4_temp) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Add the 2word value in word2 to word1.
 */
static uint32_t ADDTO2_temp;
#define SHA512_ADDTO2(word1, word2) (                          \
    ADDTO2_temp = (word1)[1],                                  \
    (word1)[1] += (word2)[1],                                  \
    (word1)[0] += (word2)[0] + ((word1)[1] &lt; ADDTO2_temp) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA rotate   ((word &gt;&gt; bits) | (word &lt;&lt; (64-bits)))
 */
static uint32_t ROTR_temp1[2], ROTR_temp2[2];
#define SHA512_ROTR(bits, word, ret) (                         \
    SHA512_SHR((bits), (word), ROTR_temp1),                    \
    SHA512_SHL(64-(bits), (word), ROTR_temp2),                 \
    SHA512_OR(ROTR_temp1, ROTR_temp2, (ret)) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Define the SHA SIGMA and sigma macros
 *
 *  SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word)
 */
static uint32_t SIGMA0_temp1[2], SIGMA0_temp2[2],
  SIGMA0_temp3[2], SIGMA0_temp4[2];
#define SHA512_SIGMA0(word, ret) (                             \
    SHA512_ROTR(28, (word), SIGMA0_temp1),                     \
    SHA512_ROTR(34, (word), SIGMA0_temp2),                     \
    SHA512_ROTR(39, (word), SIGMA0_temp3),                     \
    SHA512_XOR(SIGMA0_temp2, SIGMA0_temp3, SIGMA0_temp4),      \
    SHA512_XOR(SIGMA0_temp1, SIGMA0_temp4, (ret)) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word) ^ SHA512_ROTR(41,word)
 */
static uint32_t SIGMA1_temp1[2], SIGMA1_temp2[2],
  SIGMA1_temp3[2], SIGMA1_temp4[2];
#define SHA512_SIGMA1(word, ret) (                             \
    SHA512_ROTR(14, (word), SIGMA1_temp1),                     \
    SHA512_ROTR(18, (word), SIGMA1_temp2),                     \
    SHA512_ROTR(41, (word), SIGMA1_temp3),                     \
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    SHA512_XOR(SIGMA1_temp2, SIGMA1_temp3, SIGMA1_temp4),      \
    SHA512_XOR(SIGMA1_temp1, SIGMA1_temp4, (ret)) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * (SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word) ^ SHA512_SHR( 7,word))
 */
static uint32_t sigma0_temp1[2], sigma0_temp2[2],
  sigma0_temp3[2], sigma0_temp4[2];
#define SHA512_sigma0(word, ret) (                             \
    SHA512_ROTR( 1, (word), sigma0_temp1),                     \
    SHA512_ROTR( 8, (word), sigma0_temp2),                     \
    SHA512_SHR( 7, (word), sigma0_temp3),                      \
    SHA512_XOR(sigma0_temp2, sigma0_temp3, sigma0_temp4),      \
    SHA512_XOR(sigma0_temp1, sigma0_temp4, (ret)) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * (SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word) ^ SHA512_SHR( 6,word))
 */
static uint32_t sigma1_temp1[2], sigma1_temp2[2],
  sigma1_temp3[2], sigma1_temp4[2];
#define SHA512_sigma1(word, ret) (                             \
    SHA512_ROTR(19, (word), sigma1_temp1),                     \
    SHA512_ROTR(61, (word), sigma1_temp2),                     \
    SHA512_SHR( 6, (word), sigma1_temp3),                      \
    SHA512_XOR(sigma1_temp2, sigma1_temp3, sigma1_temp4),      \
    SHA512_XOR(sigma1_temp1, sigma1_temp4, (ret)) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#ifndef USE_MODIFIED_MACROS
/*
 * These definitions are the ones used in FIPS 180-3, section 4.1.3
 *  Ch(x,y,z)   ((x &amp; y) ^ (~x &amp; z))
 */
static uint32_t Ch_temp1[2], Ch_temp2[2], Ch_temp3[2];
#define SHA_Ch(x, y, z, ret) (                                 \
    SHA512_AND(x, y, Ch_temp1),                                \
    SHA512_TILDA(x, Ch_temp2),                                 \
    SHA512_AND(Ch_temp2, z, Ch_temp3),                         \
    SHA512_XOR(Ch_temp1, Ch_temp3, (ret)) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Maj(x,y,z)  (((x)&amp;(y)) ^ ((x)&amp;(z)) ^ ((y)&amp;(z)))
 */
static uint32_t Maj_temp1[2], Maj_temp2[2],
  Maj_temp3[2], Maj_temp4[2];
#define SHA_Maj(x, y, z, ret) (                                \
    SHA512_AND(x, y, Maj_temp1),                               \
    SHA512_AND(x, z, Maj_temp2),                               \
    SHA512_AND(y, z, Maj_temp3),                               \
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    SHA512_XOR(Maj_temp2, Maj_temp3, Maj_temp4),               \
    SHA512_XOR(Maj_temp1, Maj_temp4, (ret)) )
#else /* !USE_MODIFIED_MACROS */
/*
 * These definitions are potentially faster equivalents for the ones
 * used in FIPS 180-3, section 4.1.3.
 *   ((x &amp; y) ^ (~x &amp; z)) becomes
 *   ((x &amp; (y ^ z)) ^ z)
 */
#define SHA_Ch(x, y, z, ret) (                                 \
   (ret)[0] = (((x)[0] &amp; ((y)[0] ^ (z)[0])) ^ (z)[0]),         \
   (ret)[1] = (((x)[1] &amp; ((y)[1] ^ (z)[1])) ^ (z)[1]) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *   ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z)) becomes
 *   ((x &amp; (y | z)) | (y &amp; z))
 */
#define SHA_Maj(x, y, z, ret) (                                 \
   ret[0] = (((x)[0] &amp; ((y)[0] | (z)[0])) | ((y)[0] &amp; (z)[0])), \
   ret[1] = (((x)[1] &amp; ((y)[1] | (z)[1])) | ((y)[1] &amp; (z)[1])) )
#endif /* USE_MODIFIED_MACROS */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Add &#34;length&#34; to the length.
 * Set Corrupted when overflow has occurred.
 */
static uint32_t addTemp[4] = { 0, 0, 0, 0 };
#define SHA384_512AddLength(context, length) (                        \
    addTemp[3] = (length), SHA512_ADDTO4((context)-&gt;Length, addTemp), \
    (context)-&gt;Corrupted = (((context)-&gt;Length[3] &lt; (length)) &amp;&amp;      \
       ((context)-&gt;Length[2] == 0) &amp;&amp; ((context)-&gt;Length[1] == 0) &amp;&amp;  \
       ((context)-&gt;Length[0] == 0)) ? shaInputTooLong :               \
                                      (context)-&gt;Corrupted )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Local Function Prototypes */
static int SHA384_512Reset(SHA512Context *context,
                           uint32_t H0[SHA512HashSize/4]);
static void SHA384_512ProcessMessageBlock(SHA512Context *context);
static void SHA384_512Finalize(SHA512Context *context,
  uint8_t Pad_Byte);
static void SHA384_512PadMessage(SHA512Context *context,
  uint8_t Pad_Byte);
static int SHA384_512ResultN( SHA512Context *context,
  uint8_t Message_Digest[ ], int HashSize);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Initial Hash Values: FIPS 180-3 sections 5.3.4 and 5.3.5 */
static uint32_t SHA384_H0[SHA512HashSize/4] = {
    0xCBBB9D5D, 0xC1059ED8, 0x629A292A, 0x367CD507, 0x9159015A,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0x3070DD17, 0x152FECD8, 0xF70E5939, 0x67332667, 0xFFC00B31,
    0x8EB44A87, 0x68581511, 0xDB0C2E0D, 0x64F98FA7, 0x47B5481D,
    0xBEFA4FA4
};
static uint32_t SHA512_H0[SHA512HashSize/4] = {
    0x6A09E667, 0xF3BCC908, 0xBB67AE85, 0x84CAA73B, 0x3C6EF372,
    0xFE94F82B, 0xA54FF53A, 0x5F1D36F1, 0x510E527F, 0xADE682D1,
    0x9B05688C, 0x2B3E6C1F, 0x1F83D9AB, 0xFB41BD6B, 0x5BE0CD19,
    0x137E2179
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#else /* !USE_32BIT_ONLY */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha-private.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;SHA-private.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Define the SHA shift, rotate left and rotate right macros */
#define SHA512_SHR(bits,word)  (((uint64_t)(word)) &gt;&gt; (bits))
#define SHA512_ROTR(bits,word) ((((uint64_t)(word)) &gt;&gt; (bits)) | \
                                (((uint64_t)(word)) &lt;&lt; (64-(bits))))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Define the SHA SIGMA and sigma macros
 *
 *  SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word)
 */
#define SHA512_SIGMA0(word)   \
 (SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word) ^ SHA512_ROTR(39,word))
#define SHA512_SIGMA1(word)   \
 (SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word) ^ SHA512_ROTR(41,word))
#define SHA512_sigma0(word)   \
 (SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word) ^ SHA512_SHR( 7,word))
#define SHA512_sigma1(word)   \
 (SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word) ^ SHA512_SHR( 6,word))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Add &#34;length&#34; to the length.
 * Set Corrupted when overflow has occurred.
 */
static uint64_t addTemp;
#define SHA384_512AddLength(context, length)                   \
   (addTemp = context-&gt;Length_Low, context-&gt;Corrupted =        \
    ((context-&gt;Length_Low += length) &lt; addTemp) &amp;&amp;             \
    (++context-&gt;Length_High == 0) ? shaInputTooLong :          \
                                    (context)-&gt;Corrupted)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Local Function Prototypes */
static int SHA384_512Reset(SHA512Context *context,
                           uint64_t H0[SHA512HashSize/8]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
static void SHA384_512ProcessMessageBlock(SHA512Context *context);
static void SHA384_512Finalize(SHA512Context *context,
  uint8_t Pad_Byte);
static void SHA384_512PadMessage(SHA512Context *context,
  uint8_t Pad_Byte);
static int SHA384_512ResultN(SHA512Context *context,
  uint8_t Message_Digest[ ], int HashSize);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Initial Hash Values: FIPS 180-3 sections 5.3.4 and 5.3.5 */
static uint64_t SHA384_H0[ ] = {
    0xCBBB9D5DC1059ED8ll, 0x629A292A367CD507ll, 0x9159015A3070DD17ll,
    0x152FECD8F70E5939ll, 0x67332667FFC00B31ll, 0x8EB44A8768581511ll,
    0xDB0C2E0D64F98FA7ll, 0x47B5481DBEFA4FA4ll
};
static uint64_t SHA512_H0[ ] = {
    0x6A09E667F3BCC908ll, 0xBB67AE8584CAA73Bll, 0x3C6EF372FE94F82Bll,
    0xA54FF53A5F1D36F1ll, 0x510E527FADE682D1ll, 0x9B05688C2B3E6C1Fll,
    0x1F83D9ABFB41BD6Bll, 0x5BE0CD19137E2179ll
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#endif /* USE_32BIT_ONLY */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA384Reset
 *
 * Description:
 *   This function will initialize the SHA384Context in preparation
 *   for computing a new SHA384 message digest.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to reset.
 *
 * Returns:
 *   sha Error Code.
 *
 */
int SHA384Reset(SHA384Context *context)
{
  return SHA384_512Reset(context, SHA384_H0);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA384Input
 *
 * Description:
 *   This function accepts an array of octets as the next portion
 *   of the message.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 * * Parameters: * context: [in/out] * The SHA context to update. * message_array[ ]: [in] * An array of octets representing the next portion of * the message. * length: [in] * The length of the message in message_array. * * Returns: * sha Error Code. * */ int SHA384Input(SHA384Context *context, const uint8_t *message_array, unsigned int length) { return SHA512Input(context, message_array, length); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* *パラメータ：*コンテキスト：[IN / OUT] * SHAコンテキスト更新します。 * [] message_array：[IN] *メッセージ*の次の部分を表すオクテットのアレイ。 *長さ：[IN] * message_array内のメッセージの長さ。 * *戻り値：* SHAエラーコード。 * / INT SHA384Input（SHA384Context *コンテキスト、CONST uint8_t * message_array、unsigned int型の長さ）{SHA512Input（文脈、message_array、長さ）を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA384FinalBits
 *
 * Description:
 *   This function will add in any final bits of the message.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   message_bits: [in]
 *     The final bits of the message, in the upper portion of the
 *     byte.  (Use 0b###00000 instead of 0b00000### to input the
 *     three bits ###.)
 *   length: [in]
 *     The number of bits in message_bits, between 1 and 7.
 *
 * Returns:
 *   sha Error Code.
 *
 */
int SHA384FinalBits(SHA384Context *context,
                    uint8_t message_bits, unsigned int length)
{
  return SHA512FinalBits(context, message_bits, length);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA384Result
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 * * Description: * This function will return the 384-bit message digest * into the Message_Digest array provided by the caller. * NOTE: * The first octet of hash is stored in the element with index 0, * the last octet of hash in the element with index 47. * * Parameters: * context: [in/out] * The context to use to calculate the SHA hash. * Message_Digest[ ]: [out] * Where the digest is returned. * * Returns: * sha Error Code. * */ int SHA384Result(SHA384Context *context, uint8_t Message_Digest[SHA384HashSize]) { return SHA384_512ResultN(context, Message_Digest, SHA384HashSize); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*説明：*この関数は、呼び出し元によって提供さMessage_Digest配列に384ビットメッセージダイジェスト*を返します。 *注：*ハッシュの最初のオクテットは、インデックス0を持つ要素に格納され、*インデックス47 *パラメータを持つ要素内のハッシュの最後のオクテット：*コンテキスト：計算に使用するコンテキスト* [/アウト] SHAハッシュ。 * Message_Digest []：[外] *ダイジェストが返される場合。 * *戻り値：* SHAエラーコード。 * / INT SHA384Result（Message_Digest [SHA384HashSize] uint8_t SHA384Context *コンテキスト）{SHA384_512ResultN（文脈、Message_Digest、SHA384HashSize）を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA512Reset
 *
 * Description:
 *   This function will initialize the SHA512Context in preparation
 *   for computing a new SHA512 message digest.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to reset.
 *
 * Returns:
 *   sha Error Code.
 *
 */
int SHA512Reset(SHA512Context *context)
{
  return SHA384_512Reset(context, SHA512_H0);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA512Input
 *
 * Description:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *   This function accepts an array of octets as the next portion
 *   of the message.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   message_array[ ]: [in]
 *     An array of octets representing the next portion of
 *     the message.
 *   length: [in]
 *     The length of the message in message_array.
 *
 * Returns:
 *   sha Error Code.
 *
 */
int SHA512Input(SHA512Context *context,
        const uint8_t *message_array,
        unsigned int length)
{
  if (!context) return shaNull;
  if (!length) return shaSuccess;
  if (!message_array) return shaNull;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
while (length--) { context-&gt;Message_Block[context-&gt;Message_Block_Index++] = *message_array;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方、（length--）{、コンテキスト&gt; Message_Block【、コンテキスト&gt; Message_Block_Index ++] = * message_array。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if ((SHA384_512AddLength(context, 8) == shaSuccess) &amp;&amp; (context-&gt;Message_Block_Index == SHA512_Message_Block_Size)) SHA384_512ProcessMessageBlock(context);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IF（（SHA384_512AddLength（文脈、8）== shaSuccess）&amp;&amp;（、コンテキスト&gt; Message_Block_Index == SHA512_Message_Block_Size））SHA384_512ProcessMessageBlock（コンテキスト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 message_array++; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
++ message_array; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return context-&gt;Corrupted; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
破損を返し、コンテキスト&gt;。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA512FinalBits
 *
 * Description:
 *   This function will add in any final bits of the message.
 *
 * Parameters:
 *   context: [in/out]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *     The SHA context to update.
 *   message_bits: [in]
 *     The final bits of the message, in the upper portion of the
 *     byte.  (Use 0b###00000 instead of 0b00000### to input the
 *     three bits ###.)
 *   length: [in]
 *     The number of bits in message_bits, between 1 and 7.
 *
 * Returns:
 *   sha Error Code.
 *
 */
int SHA512FinalBits(SHA512Context *context,
                    uint8_t message_bits, unsigned int length)
{
  static uint8_t masks[8] = {
      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */ 0x80,
      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,
      /* 4 0b11110000 */ 0xF0, /* 5 0b11111000 */ 0xF8,
      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110 */ 0xFE
  };
  static uint8_t markbit[8] = {
      /* 0 0b10000000 */ 0x80, /* 1 0b01000000 */ 0x40,
      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,
      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,
      /* 6 0b00000010 */ 0x02, /* 7 0b00000001 */ 0x01
  };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (!context) return shaNull;
  if (!length) return shaSuccess;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  if (length &gt;= 8) return context-&gt;Corrupted = shaBadParam;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  SHA384_512AddLength(context, length);
  SHA384_512Finalize(context, (uint8_t)
    ((message_bits &amp; masks[length]) | markbit[length]));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return context-&gt;Corrupted; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
破損を返し、コンテキスト&gt;。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA512Result
 *
 * Description:
 *   This function will return the 512-bit message digest
 *   into the Message_Digest array provided by the caller.
 *   NOTE:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 * The first octet of hash is stored in the element with index 0, * the last octet of hash in the element with index 63. * * Parameters: * context: [in/out] * The context to use to calculate the SHA hash. * Message_Digest[ ]: [out] * Where the digest is returned. * * Returns: * sha Error Code. * */ int SHA512Result(SHA512Context *context, uint8_t Message_Digest[SHA512HashSize]) { return SHA384_512ResultN(context, Message_Digest, SHA512HashSize); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*コンテキスト：*ハッシュの最初のオクテットは、ハッシュの最後のオクテットは、インデックス63 *パラメータを持つ要素に*、インデックス0の要素に格納されているSHAハッシュを計算するために使用するコンテキスト* [/アウト] 。 * Message_Digest []：[外] *ダイジェストが返される場合。 * *戻り値：* SHAエラーコード。 * / INT SHA512Result（Message_Digest [SHA512HashSize] uint8_t SHA512Context *コンテキスト）{SHA384_512ResultN（文脈、Message_Digest、SHA512HashSize）を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA384_512Reset
 *
 * Description:
 *   This helper function will initialize the SHA512Context in
 *   preparation for computing a new SHA384 or SHA512 message
 *   digest.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to reset.
 *   H0[ ]: [in]
 *     The initial hash value array to use.
 *
 * Returns:
 *   sha Error Code.
 *
 */
#ifdef USE_32BIT_ONLY
static int SHA384_512Reset(SHA512Context *context,
                           uint32_t H0[SHA512HashSize/4])
#else /* !USE_32BIT_ONLY */
static int SHA384_512Reset(SHA512Context *context,
                           uint64_t H0[SHA512HashSize/8])
#endif /* USE_32BIT_ONLY */
{
  int i;
  if (!context) return shaNull;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
context-&gt;Message_Block_Index = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、コンテキスト&gt; Message_Block_Index = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#ifdef USE_32BIT_ONLY context-&gt;Length[0] = context-&gt;Length[1] = context-&gt;Length[2] = context-&gt;Length[3] = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#ifdefのUSE_32BIT_ONLY、コンテキスト&gt;長さ[0] =、コンテキスト&gt;長[1] =、コンテキスト&gt;長さ[2] =、コンテキスト&gt;長さ[3] = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (i = 0; i &lt; SHA512HashSize/4; i++)
    context-&gt;Intermediate_Hash[i] = H0[i];
#else /* !USE_32BIT_ONLY */
  context-&gt;Length_High = context-&gt;Length_Low = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (i = 0; i &lt; SHA512HashSize/8; i++)
    context-&gt;Intermediate_Hash[i] = H0[i];
#endif /* USE_32BIT_ONLY */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Computed = 0;
  context-&gt;Corrupted = shaSuccess;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return shaSuccess; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
shaSuccessリターン。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA384_512ProcessMessageBlock
 *
 * Description:
 *   This helper function will process the next 1024 bits of the
 *   message stored in the Message_Block array.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *
 * Returns:
 *   Nothing.
 *
 * Comments:
 *   Many of the variable names in this code, especially the
 *   single character names, were used because those were the
 *   names used in the Secure Hash Standard.
 *
 *
 */
static void SHA384_512ProcessMessageBlock(SHA512Context *context)
{
#ifdef USE_32BIT_ONLY
  /* Constants defined in FIPS 180-3, section 4.2.3 */
  static const uint32_t K[80*2] = {
      0x428A2F98, 0xD728AE22, 0x71374491, 0x23EF65CD, 0xB5C0FBCF,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0xEC4D3B2F, 0xE9B5DBA5, 0x8189DBBC, 0x3956C25B, 0xF348B538,
      0x59F111F1, 0xB605D019, 0x923F82A4, 0xAF194F9B, 0xAB1C5ED5,
      0xDA6D8118, 0xD807AA98, 0xA3030242, 0x12835B01, 0x45706FBE,
      0x243185BE, 0x4EE4B28C, 0x550C7DC3, 0xD5FFB4E2, 0x72BE5D74,
      0xF27B896F, 0x80DEB1FE, 0x3B1696B1, 0x9BDC06A7, 0x25C71235,
      0xC19BF174, 0xCF692694, 0xE49B69C1, 0x9EF14AD2, 0xEFBE4786,
      0x384F25E3, 0x0FC19DC6, 0x8B8CD5B5, 0x240CA1CC, 0x77AC9C65,
      0x2DE92C6F, 0x592B0275, 0x4A7484AA, 0x6EA6E483, 0x5CB0A9DC,
      0xBD41FBD4, 0x76F988DA, 0x831153B5, 0x983E5152, 0xEE66DFAB,
      0xA831C66D, 0x2DB43210, 0xB00327C8, 0x98FB213F, 0xBF597FC7,
      0xBEEF0EE4, 0xC6E00BF3, 0x3DA88FC2, 0xD5A79147, 0x930AA725,
      0x06CA6351, 0xE003826F, 0x14292967, 0x0A0E6E70, 0x27B70A85,
      0x46D22FFC, 0x2E1B2138, 0x5C26C926, 0x4D2C6DFC, 0x5AC42AED,
      0x53380D13, 0x9D95B3DF, 0x650A7354, 0x8BAF63DE, 0x766A0ABB,
      0x3C77B2A8, 0x81C2C92E, 0x47EDAEE6, 0x92722C85, 0x1482353B,
      0xA2BFE8A1, 0x4CF10364, 0xA81A664B, 0xBC423001, 0xC24B8B70,
      0xD0F89791, 0xC76C51A3, 0x0654BE30, 0xD192E819, 0xD6EF5218,
      0xD6990624, 0x5565A910, 0xF40E3585, 0x5771202A, 0x106AA070,
      0x32BBD1B8, 0x19A4C116, 0xB8D2D0C8, 0x1E376C08, 0x5141AB53,
      0x2748774C, 0xDF8EEB99, 0x34B0BCB5, 0xE19B48A8, 0x391C0CB3,
      0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB, 0x5B9CCA4F, 0x7763E373,
      0x682E6FF3, 0xD6B2B8A3, 0x748F82EE, 0x5DEFB2FC, 0x78A5636F,
      0x43172F60, 0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC,
      0x90BEFFFA, 0x23631E28, 0xA4506CEB, 0xDE82BDE9, 0xBEF9A3F7,
      0xB2C67915, 0xC67178F2, 0xE372532B, 0xCA273ECE, 0xEA26619C,
      0xD186B8C7, 0x21C0C207, 0xEADA7DD6, 0xCDE0EB1E, 0xF57D4F7F,
      0xEE6ED178, 0x06F067AA, 0x72176FBA, 0x0A637DC5, 0xA2C898A6,
      0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B, 0x28DB77F5,
      0x23047D84, 0x32CAAB7B, 0x40C72493, 0x3C9EBE0A, 0x15C9BEBC,
      0x431D67C4, 0x9C100D4C, 0x4CC5D4BE, 0xCB3E42B6, 0x597F299C,
      0xFC657E2A, 0x5FCB6FAB, 0x3AD6FAEC, 0x6C44198C, 0x4A475817
  };
  int     t, t2, t8;                  /* Loop counter */
  uint32_t  temp1[2], temp2[2],       /* Temporary word values */
        temp3[2], temp4[2], temp5[2];
  uint32_t  W[2*80];                  /* Word sequence */
  uint32_t  A[2], B[2], C[2], D[2],   /* Word buffers */
        E[2], F[2], G[2], H[2];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Initialize the first 16 words in the array W */
  for (t = t2 = t8 = 0; t &lt; 16; t++, t8 += 8) {
    W[t2++] = ((((uint32_t)context-&gt;Message_Block[t8    ])) &lt;&lt; 24) |
              ((((uint32_t)context-&gt;Message_Block[t8 + 1])) &lt;&lt; 16) |
              ((((uint32_t)context-&gt;Message_Block[t8 + 2])) &lt;&lt; 8) |
              ((((uint32_t)context-&gt;Message_Block[t8 + 3])));
    W[t2++] = ((((uint32_t)context-&gt;Message_Block[t8 + 4])) &lt;&lt; 24) |
              ((((uint32_t)context-&gt;Message_Block[t8 + 5])) &lt;&lt; 16) |
              ((((uint32_t)context-&gt;Message_Block[t8 + 6])) &lt;&lt; 8) | ((((uint32_t)context-&gt;Message_Block[t8 + 7])));
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (t = 16; t &lt; 80; t++, t2 += 2) {
    /* W[t] = SHA512_sigma1(W[t-2]) + W[t-7] +
      SHA512_sigma0(W[t-15]) + W[t-16]; */
    uint32_t *Wt2 = &amp;W[t2-2*2];
    uint32_t *Wt7 = &amp;W[t2-7*2];
    uint32_t *Wt15 = &amp;W[t2-15*2];
    uint32_t *Wt16 = &amp;W[t2-16*2];
    SHA512_sigma1(Wt2, temp1);
    SHA512_ADD(temp1, Wt7, temp2);
    SHA512_sigma0(Wt15, temp1);
    SHA512_ADD(temp1, Wt16, temp3);
    SHA512_ADD(temp2, temp3, &amp;W[t2]);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  A[0] = context-&gt;Intermediate_Hash[0];
  A[1] = context-&gt;Intermediate_Hash[1];
  B[0] = context-&gt;Intermediate_Hash[2];
  B[1] = context-&gt;Intermediate_Hash[3];
  C[0] = context-&gt;Intermediate_Hash[4];
  C[1] = context-&gt;Intermediate_Hash[5];
  D[0] = context-&gt;Intermediate_Hash[6];
  D[1] = context-&gt;Intermediate_Hash[7];
  E[0] = context-&gt;Intermediate_Hash[8];
  E[1] = context-&gt;Intermediate_Hash[9];
  F[0] = context-&gt;Intermediate_Hash[10];
  F[1] = context-&gt;Intermediate_Hash[11];
  G[0] = context-&gt;Intermediate_Hash[12];
  G[1] = context-&gt;Intermediate_Hash[13];
  H[0] = context-&gt;Intermediate_Hash[14];
  H[1] = context-&gt;Intermediate_Hash[15];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (t = t2 = 0; t &lt; 80; t++, t2 += 2) {
    /*
     * temp1 = H + SHA512_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];
     */
    SHA512_SIGMA1(E,temp1);
    SHA512_ADD(H, temp1, temp2);
    SHA_Ch(E,F,G,temp3);
    SHA512_ADD(temp2, temp3, temp4);
    SHA512_ADD(&amp;K[t2], &amp;W[t2], temp5);
    SHA512_ADD(temp4, temp5, temp1);
    /*
     * temp2 = SHA512_SIGMA0(A) + SHA_Maj(A,B,C);
     */
    SHA512_SIGMA0(A,temp3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    SHA_Maj(A,B,C,temp4);
    SHA512_ADD(temp3, temp4, temp2);
    H[0] = G[0]; H[1] = G[1];
    G[0] = F[0]; G[1] = F[1];
    F[0] = E[0]; F[1] = E[1];
    SHA512_ADD(D, temp1, E);
    D[0] = C[0]; D[1] = C[1];
    C[0] = B[0]; C[1] = B[1];
    B[0] = A[0]; B[1] = A[1];
    SHA512_ADD(temp1, temp2, A);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  SHA512_ADDTO2(&amp;context-&gt;Intermediate_Hash[0], A);
  SHA512_ADDTO2(&amp;context-&gt;Intermediate_Hash[2], B);
  SHA512_ADDTO2(&amp;context-&gt;Intermediate_Hash[4], C);
  SHA512_ADDTO2(&amp;context-&gt;Intermediate_Hash[6], D);
  SHA512_ADDTO2(&amp;context-&gt;Intermediate_Hash[8], E);
  SHA512_ADDTO2(&amp;context-&gt;Intermediate_Hash[10], F);
  SHA512_ADDTO2(&amp;context-&gt;Intermediate_Hash[12], G);
  SHA512_ADDTO2(&amp;context-&gt;Intermediate_Hash[14], H);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#else /* !USE_32BIT_ONLY */
  /* Constants defined in FIPS 180-3, section 4.2.3 */
  static const uint64_t K[80] = {
      0x428A2F98D728AE22ll, 0x7137449123EF65CDll, 0xB5C0FBCFEC4D3B2Fll,
      0xE9B5DBA58189DBBCll, 0x3956C25BF348B538ll, 0x59F111F1B605D019ll,
      0x923F82A4AF194F9Bll, 0xAB1C5ED5DA6D8118ll, 0xD807AA98A3030242ll,
      0x12835B0145706FBEll, 0x243185BE4EE4B28Cll, 0x550C7DC3D5FFB4E2ll,
      0x72BE5D74F27B896Fll, 0x80DEB1FE3B1696B1ll, 0x9BDC06A725C71235ll,
      0xC19BF174CF692694ll, 0xE49B69C19EF14AD2ll, 0xEFBE4786384F25E3ll,
      0x0FC19DC68B8CD5B5ll, 0x240CA1CC77AC9C65ll, 0x2DE92C6F592B0275ll,
      0x4A7484AA6EA6E483ll, 0x5CB0A9DCBD41FBD4ll, 0x76F988DA831153B5ll,
      0x983E5152EE66DFABll, 0xA831C66D2DB43210ll, 0xB00327C898FB213Fll,
      0xBF597FC7BEEF0EE4ll, 0xC6E00BF33DA88FC2ll, 0xD5A79147930AA725ll,
      0x06CA6351E003826Fll, 0x142929670A0E6E70ll, 0x27B70A8546D22FFCll,
      0x2E1B21385C26C926ll, 0x4D2C6DFC5AC42AEDll, 0x53380D139D95B3DFll,
      0x650A73548BAF63DEll, 0x766A0ABB3C77B2A8ll, 0x81C2C92E47EDAEE6ll,
      0x92722C851482353Bll, 0xA2BFE8A14CF10364ll, 0xA81A664BBC423001ll,
      0xC24B8B70D0F89791ll, 0xC76C51A30654BE30ll, 0xD192E819D6EF5218ll,
      0xD69906245565A910ll, 0xF40E35855771202All, 0x106AA07032BBD1B8ll,
      0x19A4C116B8D2D0C8ll, 0x1E376C085141AB53ll, 0x2748774CDF8EEB99ll,
      0x34B0BCB5E19B48A8ll, 0x391C0CB3C5C95A63ll, 0x4ED8AA4AE3418ACBll,
      0x5B9CCA4F7763E373ll, 0x682E6FF3D6B2B8A3ll, 0x748F82EE5DEFB2FCll,
      0x78A5636F43172F60ll, 0x84C87814A1F0AB72ll, 0x8CC702081A6439ECll,
      0x90BEFFFA23631E28ll, 0xA4506CEBDE82BDE9ll, 0xBEF9A3F7B2C67915ll,
      0xC67178F2E372532Bll, 0xCA273ECEEA26619Cll, 0xD186B8C721C0C207ll,
      0xEADA7DD6CDE0EB1Ell, 0xF57D4F7FEE6ED178ll, 0x06F067AA72176FBAll,
      0x0A637DC5A2C898A6ll, 0x113F9804BEF90DAEll, 0x1B710B35131C471Bll,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0x28DB77F523047D84ll, 0x32CAAB7B40C72493ll, 0x3C9EBE0A15C9BEBCll,
      0x431D67C49C100D4Cll, 0x4CC5D4BECB3E42B6ll, 0x597F299CFC657E2All,
      0x5FCB6FAB3AD6FAECll, 0x6C44198C4A475817ll
  };
  int        t, t8;                   /* Loop counter */
  uint64_t   temp1, temp2;            /* Temporary word value */
  uint64_t   W[80];                   /* Word sequence */
  uint64_t   A, B, C, D, E, F, G, H;  /* Word buffers */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Initialize the first 16 words in the array W
   */
  for (t = t8 = 0; t &lt; 16; t++, t8 += 8)
    W[t] = ((uint64_t)(context-&gt;Message_Block[t8  ]) &lt;&lt; 56) |
           ((uint64_t)(context-&gt;Message_Block[t8 + 1]) &lt;&lt; 48) |
           ((uint64_t)(context-&gt;Message_Block[t8 + 2]) &lt;&lt; 40) |
           ((uint64_t)(context-&gt;Message_Block[t8 + 3]) &lt;&lt; 32) |
           ((uint64_t)(context-&gt;Message_Block[t8 + 4]) &lt;&lt; 24) |
           ((uint64_t)(context-&gt;Message_Block[t8 + 5]) &lt;&lt; 16) |
           ((uint64_t)(context-&gt;Message_Block[t8 + 6]) &lt;&lt; 8) |
           ((uint64_t)(context-&gt;Message_Block[t8 + 7]));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (t = 16; t &lt; 80; t++)
    W[t] = SHA512_sigma1(W[t-2]) + W[t-7] +
        SHA512_sigma0(W[t-15]) + W[t-16];
  A = context-&gt;Intermediate_Hash[0];
  B = context-&gt;Intermediate_Hash[1];
  C = context-&gt;Intermediate_Hash[2];
  D = context-&gt;Intermediate_Hash[3];
  E = context-&gt;Intermediate_Hash[4];
  F = context-&gt;Intermediate_Hash[5];
  G = context-&gt;Intermediate_Hash[6];
  H = context-&gt;Intermediate_Hash[7];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (t = 0; t &lt; 80; t++) {
    temp1 = H + SHA512_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];
    temp2 = SHA512_SIGMA0(A) + SHA_Maj(A,B,C);
    H = G;
    G = F;
    F = E;
    E = D + temp1;
    D = C;
    C = B;
    B = A;
    A = temp1 + temp2;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
context-&gt;Intermediate_Hash[0] += A;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、コンテキスト&gt; Intermediate_Hash [0] + = A。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Intermediate_Hash[1] += B;
  context-&gt;Intermediate_Hash[2] += C;
  context-&gt;Intermediate_Hash[3] += D;
  context-&gt;Intermediate_Hash[4] += E;
  context-&gt;Intermediate_Hash[5] += F;
  context-&gt;Intermediate_Hash[6] += G;
  context-&gt;Intermediate_Hash[7] += H;
#endif /* USE_32BIT_ONLY */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 context-&gt;Message_Block_Index = 0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、コンテキスト&gt; Message_Block_Index = 0; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA384_512Finalize
 *
 * Description:
 *   This helper function finishes off the digest calculations.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   Pad_Byte: [in]
 *     The last byte to add to the message block before the 0-padding
 *     and length.  This will contain the last bits of the message
 *     followed by another single bit.  If the message was an
 *     exact multiple of 8-bits long, Pad_Byte will be 0x80.
 *
 * Returns:
 *   sha Error Code.
 *
 */
static void SHA384_512Finalize(SHA512Context *context,
    uint8_t Pad_Byte)
{
  int_least16_t i;
  SHA384_512PadMessage(context, Pad_Byte);
  /* message may be sensitive, clear it out */
  for (i = 0; i &lt; SHA512_Message_Block_Size; ++i)
    context-&gt;Message_Block[i] = 0;
#ifdef USE_32BIT_ONLY    /* and clear length */
  context-&gt;Length[0] = context-&gt;Length[1] = 0;
  context-&gt;Length[2] = context-&gt;Length[3] = 0;
#else /* !USE_32BIT_ONLY */
  context-&gt;Length_High = context-&gt;Length_Low = 0;
#endif /* USE_32BIT_ONLY */
  context-&gt;Computed = 1;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA384_512PadMessage
 *
 * Description:
 *   According to the standard, the message must be padded to the next
 *   even multiple of 1024 bits.  The first padding bit must be a &#39;1&#39;.
 *   The last 128 bits represent the length of the original message.
 *   All bits in between should be 0.  This helper function will
 *   pad the message according to those rules by filling the
 *   Message_Block array accordingly.  When it returns, it can be
 *   assumed that the message digest has been computed.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to pad.
 *   Pad_Byte: [in]
 *     The last byte to add to the message block before the 0-padding
 *     and length.  This will contain the last bits of the message
 *     followed by another single bit.  If the message was an
 *     exact multiple of 8-bits long, Pad_Byte will be 0x80.
 *
 * Returns:
 *   Nothing.
 *
 */
static void SHA384_512PadMessage(SHA512Context *context,
    uint8_t Pad_Byte)
{
  /*
   * Check to see if the current message block is too small to hold
   * the initial padding bits and length.  If so, we will pad the
   * block, process it, and then continue padding into a second
   * block.
   */
  if (context-&gt;Message_Block_Index &gt;= (SHA512_Message_Block_Size-16)) {
    context-&gt;Message_Block[context-&gt;Message_Block_Index++] = Pad_Byte;
    while (context-&gt;Message_Block_Index &lt; SHA512_Message_Block_Size)
      context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    SHA384_512ProcessMessageBlock(context);
  } else
    context-&gt;Message_Block[context-&gt;Message_Block_Index++] = Pad_Byte;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
while (context-&gt;Message_Block_Index &lt; (SHA512_Message_Block_Size-16)) context-&gt;Message_Block[context-&gt;Message_Block_Index++] = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一方、（、コンテキスト&gt; Message_Block_Index &lt;（SHA512_Message_Block_Size-16））、コンテキスト&gt; Message_Block【、コンテキスト&gt; Message_Block_Index ++] = 0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Store the message length as the last 16 octets
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   */
#ifdef USE_32BIT_ONLY
  context-&gt;Message_Block[112] = (uint8_t)(context-&gt;Length[0] &gt;&gt; 24);
  context-&gt;Message_Block[113] = (uint8_t)(context-&gt;Length[0] &gt;&gt; 16);
  context-&gt;Message_Block[114] = (uint8_t)(context-&gt;Length[0] &gt;&gt; 8);
  context-&gt;Message_Block[115] = (uint8_t)(context-&gt;Length[0]);
  context-&gt;Message_Block[116] = (uint8_t)(context-&gt;Length[1] &gt;&gt; 24);
  context-&gt;Message_Block[117] = (uint8_t)(context-&gt;Length[1] &gt;&gt; 16);
  context-&gt;Message_Block[118] = (uint8_t)(context-&gt;Length[1] &gt;&gt; 8);
  context-&gt;Message_Block[119] = (uint8_t)(context-&gt;Length[1]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Message_Block[120] = (uint8_t)(context-&gt;Length[2] &gt;&gt; 24);
  context-&gt;Message_Block[121] = (uint8_t)(context-&gt;Length[2] &gt;&gt; 16);
  context-&gt;Message_Block[122] = (uint8_t)(context-&gt;Length[2] &gt;&gt; 8);
  context-&gt;Message_Block[123] = (uint8_t)(context-&gt;Length[2]);
  context-&gt;Message_Block[124] = (uint8_t)(context-&gt;Length[3] &gt;&gt; 24);
  context-&gt;Message_Block[125] = (uint8_t)(context-&gt;Length[3] &gt;&gt; 16);
  context-&gt;Message_Block[126] = (uint8_t)(context-&gt;Length[3] &gt;&gt; 8);
  context-&gt;Message_Block[127] = (uint8_t)(context-&gt;Length[3]);
#else /* !USE_32BIT_ONLY */
  context-&gt;Message_Block[112] = (uint8_t)(context-&gt;Length_High &gt;&gt; 56);
  context-&gt;Message_Block[113] = (uint8_t)(context-&gt;Length_High &gt;&gt; 48);
  context-&gt;Message_Block[114] = (uint8_t)(context-&gt;Length_High &gt;&gt; 40);
  context-&gt;Message_Block[115] = (uint8_t)(context-&gt;Length_High &gt;&gt; 32);
  context-&gt;Message_Block[116] = (uint8_t)(context-&gt;Length_High &gt;&gt; 24);
  context-&gt;Message_Block[117] = (uint8_t)(context-&gt;Length_High &gt;&gt; 16);
  context-&gt;Message_Block[118] = (uint8_t)(context-&gt;Length_High &gt;&gt; 8);
  context-&gt;Message_Block[119] = (uint8_t)(context-&gt;Length_High);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Message_Block[120] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 56);
  context-&gt;Message_Block[121] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 48);
  context-&gt;Message_Block[122] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 40);
  context-&gt;Message_Block[123] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 32);
  context-&gt;Message_Block[124] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 24);
  context-&gt;Message_Block[125] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 16);
  context-&gt;Message_Block[126] = (uint8_t)(context-&gt;Length_Low &gt;&gt; 8);
  context-&gt;Message_Block[127] = (uint8_t)(context-&gt;Length_Low);
#endif /* USE_32BIT_ONLY */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 SHA384_512ProcessMessageBlock(context); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA3​​84_512ProcessMessageBlock（コンテキスト）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * SHA384_512ResultN
 *
 * Description:
 *   This helper function will return the 384-bit or 512-bit message
 *   digest into the Message_Digest array provided by the caller.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *   NOTE:
 *    The first octet of hash is stored in the element with index 0,
 *    the last octet of hash in the element with index 47/63.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to use to calculate the SHA hash.
 *   Message_Digest[ ]: [out]
 *     Where the digest is returned.
 *   HashSize: [in]
 *     The size of the hash, either 48 or 64.
 *
 * Returns:
 *   sha Error Code.
 *
 */
static int SHA384_512ResultN(SHA512Context *context,
    uint8_t Message_Digest[ ], int HashSize)
{
  int i;
#ifdef USE_32BIT_ONLY
  int i2;
#endif /* USE_32BIT_ONLY */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (!context) return shaNull;
  if (!Message_Digest) return shaNull;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (!context-&gt;Computed) SHA384_512Finalize(context, 0x80);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もしSHA384_512Finalize（文脈、0x80の）（、コンテキスト&gt;コンピュー！）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#ifdef USE_32BIT_ONLY
  for (i = i2 = 0; i &lt; HashSize; ) {
    Message_Digest[i++]=(uint8_t)(context-&gt;Intermediate_Hash[i2]&gt;&gt;24);
    Message_Digest[i++]=(uint8_t)(context-&gt;Intermediate_Hash[i2]&gt;&gt;16);
    Message_Digest[i++]=(uint8_t)(context-&gt;Intermediate_Hash[i2]&gt;&gt;8);
    Message_Digest[i++]=(uint8_t)(context-&gt;Intermediate_Hash[i2++]);
    Message_Digest[i++]=(uint8_t)(context-&gt;Intermediate_Hash[i2]&gt;&gt;24);
    Message_Digest[i++]=(uint8_t)(context-&gt;Intermediate_Hash[i2]&gt;&gt;16);
    Message_Digest[i++]=(uint8_t)(context-&gt;Intermediate_Hash[i2]&gt;&gt;8);
    Message_Digest[i++]=(uint8_t)(context-&gt;Intermediate_Hash[i2++]);
  }
#else /* !USE_32BIT_ONLY */
  for (i = 0; i &lt; HashSize; ++i)
    Message_Digest[i] = (uint8_t)
      (context-&gt;Intermediate_Hash[i&gt;&gt;3] &gt;&gt; 8 * ( 7 - ( i % 8 ) ));
#endif /* USE_32BIT_ONLY */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return shaSuccess; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
shaSuccessリターン。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.4. usha.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.4。 usha.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**************************** usha.c ***************************/
/***************** See RFC 6234 for details. *******************/
/* Copyright (c) 2011 IETF Trust and the persons identified as */
/* authors of the code.  All rights reserved.                  */
/* See sha.h for terms of use and redistribution.              */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Description:
 *     This file implements a unified interface to the SHA algorithms.
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  USHAReset
 *
 *  Description:
 *      This function will initialize the SHA Context in preparation
 *      for computing a new SHA message digest.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to reset.
 *      whichSha: [in]
 *          Selects which SHA reset to call
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int USHAReset(USHAContext *context, enum SHAversion whichSha)
{
  if (!context) return shaNull;
  context-&gt;whichSha = whichSha;
  switch (whichSha) {
    case SHA1:   return SHA1Reset((SHA1Context*)&amp;context-&gt;ctx);
    case SHA224: return SHA224Reset((SHA224Context*)&amp;context-&gt;ctx);
    case SHA256: return SHA256Reset((SHA256Context*)&amp;context-&gt;ctx);
    case SHA384: return SHA384Reset((SHA384Context*)&amp;context-&gt;ctx);
    case SHA512: return SHA512Reset((SHA512Context*)&amp;context-&gt;ctx);
    default: return shaBadParam;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  USHAInput
 *
 *  Description:
 *      This function accepts an array of octets as the next portion
 *      of the message.
 *
 *  Parameters:
 *      context: [in/out]
 *          The SHA context to update.
 *      message_array: [in]
 *          An array of octets representing the next portion of
 *          the message.
 *      length: [in]
 *          The length of the message in message_array.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int USHAInput(USHAContext *context,
              const uint8_t *bytes, unsigned int bytecount)
{
  if (!context) return shaNull;
  switch (context-&gt;whichSha) {
    case SHA1:
      return SHA1Input((SHA1Context*)&amp;context-&gt;ctx, bytes,
                       bytecount);
    case SHA224:
      return SHA224Input((SHA224Context*)&amp;context-&gt;ctx, bytes,
          bytecount);
    case SHA256:
      return SHA256Input((SHA256Context*)&amp;context-&gt;ctx, bytes,
          bytecount);
    case SHA384:
      return SHA384Input((SHA384Context*)&amp;context-&gt;ctx, bytes,
          bytecount);
    case SHA512:
      return SHA512Input((SHA512Context*)&amp;context-&gt;ctx, bytes,
          bytecount);
    default: return shaBadParam;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * USHAFinalBits
 *
 * Description:
 *   This function will add in any final bits of the message.
 *
 * Parameters:
 *   context: [in/out]
 *     The SHA context to update.
 *   message_bits: [in]
 *     The final bits of the message, in the upper portion of the
 *     byte.  (Use 0b###00000 instead of 0b00000### to input the
 *     three bits ###.)
 *   length: [in]
 *     The number of bits in message_bits, between 1 and 7.
 *
 * Returns:
 *   sha Error Code.
 */
int USHAFinalBits(USHAContext *context,
                  uint8_t bits, unsigned int bit_count)
{
  if (!context) return shaNull;
  switch (context-&gt;whichSha) {
    case SHA1:
      return SHA1FinalBits((SHA1Context*)&amp;context-&gt;ctx, bits,
                           bit_count);
    case SHA224:
      return SHA224FinalBits((SHA224Context*)&amp;context-&gt;ctx, bits,
          bit_count);
    case SHA256:
      return SHA256FinalBits((SHA256Context*)&amp;context-&gt;ctx, bits,
          bit_count);
    case SHA384:
      return SHA384FinalBits((SHA384Context*)&amp;context-&gt;ctx, bits,
          bit_count);
    case SHA512:
      return SHA512FinalBits((SHA512Context*)&amp;context-&gt;ctx, bits,
          bit_count);
    default: return shaBadParam;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * USHAResult
 *
 * Description:
 *   This function will return the message digest of the appropriate
 *   bit size, as returned by USHAHashSizeBits(whichSHA) for the
 *   &#39;whichSHA&#39; value used in the preceeding call to USHAReset,
 *   into the Message_Digest array provided by the caller.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to use to calculate the SHA-1 hash.
 *   Message_Digest: [out]
 *     Where the digest is returned.
 *
 * Returns:
 *   sha Error Code.
 *
 */
int USHAResult(USHAContext *context,
               uint8_t Message_Digest[USHAMaxHashSize])
{
  if (!context) return shaNull;
  switch (context-&gt;whichSha) {
    case SHA1:
      return SHA1Result((SHA1Context*)&amp;context-&gt;ctx, Message_Digest);
    case SHA224:
      return SHA224Result((SHA224Context*)&amp;context-&gt;ctx,
                          Message_Digest);
    case SHA256:
      return SHA256Result((SHA256Context*)&amp;context-&gt;ctx,
                          Message_Digest);
    case SHA384:
      return SHA384Result((SHA384Context*)&amp;context-&gt;ctx,
                          Message_Digest);
    case SHA512:
      return SHA512Result((SHA512Context*)&amp;context-&gt;ctx,
                          Message_Digest);
    default: return shaBadParam;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * USHABlockSize
 *
 * Description:
 *   This function will return the blocksize for the given SHA
 *   algorithm.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *
 * Parameters:
 *   whichSha:
 *     which SHA algorithm to query
 *
 * Returns:
 *   block size
 *
 */
int USHABlockSize(enum SHAversion whichSha)
{
  switch (whichSha) {
    case SHA1:   return SHA1_Message_Block_Size;
    case SHA224: return SHA224_Message_Block_Size;
    case SHA256: return SHA256_Message_Block_Size;
    case SHA384: return SHA384_Message_Block_Size;
    default:
    case SHA512: return SHA512_Message_Block_Size;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * USHAHashSize
 *
 * Description:
 *   This function will return the hashsize for the given SHA
 *   algorithm.
 *
 * Parameters:
 *   whichSha:
 *     which SHA algorithm to query
 *
 * Returns:
 *   hash size
 *
 */
int USHAHashSize(enum SHAversion whichSha)
{
  switch (whichSha) {
    case SHA1:   return SHA1HashSize;
    case SHA224: return SHA224HashSize;
    case SHA256: return SHA256HashSize;
    case SHA384: return SHA384HashSize;
    default:
    case SHA512: return SHA512HashSize;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * USHAHashSizeBits
 *
 * Description:
 *   This function will return the hashsize for the given SHA
 *   algorithm, expressed in bits.
 *
 * Parameters:
 *   whichSha:
 *     which SHA algorithm to query
 *
 * Returns:
 *   hash size in bits
 *
 */
int USHAHashSizeBits(enum SHAversion whichSha)
{
  switch (whichSha) {
    case SHA1:   return SHA1HashSizeBits;
    case SHA224: return SHA224HashSizeBits;
    case SHA256: return SHA256HashSizeBits;
    case SHA384: return SHA384HashSizeBits;
    default:
    case SHA512: return SHA512HashSizeBits;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * USHAHashName
 *
 * Description:
 *   This function will return the name of the given SHA algorithm
 *   as a string.
 *
 * Parameters:
 *   whichSha:
 *     which SHA algorithm to query
 *
 * Returns:
 *   character string with the name in it
 *
 */
const char *USHAHashName(enum SHAversion whichSha)
{
  switch (whichSha) {
    case SHA1:   return &#34;SHA1&#34;;
    case SHA224: return &#34;SHA224&#34;;
    case SHA256: return &#34;SHA256&#34;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    case SHA384: return &#34;SHA384&#34;;
    default:
    case SHA512: return &#34;SHA512&#34;;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. The HMAC Code
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3。 HMACコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**************************** hmac.c ***************************/
/***************** See RFC 6234 for details. *******************/
/* Copyright (c) 2011 IETF Trust and the persons identified as */
/* authors of the code.  All rights reserved.                  */
/* See sha.h for terms of use and redistribution.              */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Description:
 *      This file implements the HMAC algorithm (Keyed-Hashing for
 *      Message Authentication, [RFC 2104]), expressed in terms of
 *      the various SHA algorithms.
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  hmac
 *
 *  Description:
 *      This function will compute an HMAC message digest.
 *
 *  Parameters:
 *      whichSha: [in]
 *          One of SHA1, SHA224, SHA256, SHA384, SHA512
 *      message_array[ ]: [in]
 *          An array of octets representing the message.
 *          Note: in RFC 2104, this parameter is known
 *          as &#39;text&#39;.
 *      length: [in]
 *          The length of the message in message_array.
 *      key[ ]: [in]
 *          The secret shared key.
 *      key_len: [in]
 *          The length of the secret shared key.
 *      digest[ ]: [out]
 *          Where the digest is to be returned.
 *          NOTE: The length of the digest is determined by
 *              the value of whichSha.
 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Returns: * sha Error Code. * */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*戻り値：* SHAエラーコード。 * * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
int hmac(SHAversion whichSha,
    const unsigned char *message_array, int length,
    const unsigned char *key, int key_len,
    uint8_t digest[USHAMaxHashSize])
{
  HMACContext context;
  return hmacReset(&amp;context, whichSha, key, key_len) ||
         hmacInput(&amp;context, message_array, length) ||
         hmacResult(&amp;context, digest);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  hmacReset
 *
 *  Description:
 *      This function will initialize the hmacContext in preparation
 *      for computing a new HMAC message digest.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to reset.
 *      whichSha: [in]
 *          One of SHA1, SHA224, SHA256, SHA384, SHA512
 *      key[ ]: [in]
 *          The secret shared key.
 *      key_len: [in]
 *          The length of the secret shared key.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int hmacReset(HMACContext *context, enum SHAversion whichSha,
    const unsigned char *key, int key_len)
{
  int i, blocksize, hashsize, ret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* inner padding - key XORd with ipad */
  unsigned char k_ipad[USHA_Max_Message_Block_Size];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* temporary buffer when keylen &gt; blocksize */
  unsigned char tempkey[USHAMaxHashSize];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (!context) return shaNull;
  context-&gt;Computed = 0;
  context-&gt;Corrupted = shaSuccess;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  blocksize = context-&gt;blockSize = USHABlockSize(whichSha);
  hashsize = context-&gt;hashSize = USHAHashSize(whichSha);
  context-&gt;whichSha = whichSha;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * If key is longer than the hash blocksize,
   * reset it to key = HASH(key).
   */
  if (key_len &gt; blocksize) {
    USHAContext tcontext;
    int err = USHAReset(&amp;tcontext, whichSha) ||
              USHAInput(&amp;tcontext, key, key_len) ||
              USHAResult(&amp;tcontext, tempkey);
    if (err != shaSuccess) return err;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    key = tempkey;
    key_len = hashsize;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * The HMAC transform looks like:
   *
   * SHA(K XOR opad, SHA(K XOR ipad, text))
   *
   * where K is an n byte key, 0-padded to a total of blocksize bytes,
   * ipad is the byte 0x36 repeated blocksize times,
   * opad is the byte 0x5c repeated blocksize times,
   * and text is the data being protected.
   */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* store key into the pads, XOR&#39;d with ipad and opad values */
  for (i = 0; i &lt; key_len; i++) {
    k_ipad[i] = key[i] ^ 0x36;
    context-&gt;k_opad[i] = key[i] ^ 0x5c;
  }
  /* remaining pad bytes are &#39;\0&#39; XOR&#39;d with ipad and opad values */
  for ( ; i &lt; blocksize; i++) {
    k_ipad[i] = 0x36;
    context-&gt;k_opad[i] = 0x5c;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* perform inner hash */
  /* init context for 1st pass */
  ret = USHAReset(&amp;context-&gt;shaContext, whichSha) ||
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /* and start with inner pad */
        USHAInput(&amp;context-&gt;shaContext, k_ipad, blocksize);
  return context-&gt;Corrupted = ret;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  hmacInput
 *
 *  Description:
 *      This function accepts an array of octets as the next portion
 *      of the message.  It may be called multiple times.
 *
 *  Parameters:
 *      context: [in/out]
 *          The HMAC context to update.
 *      text[ ]: [in]
 *          An array of octets representing the next portion of
 *          the message.
 *      text_len: [in]
 *          The length of the message in text.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int hmacInput(HMACContext *context, const unsigned char *text,
    int text_len)
{
  if (!context) return shaNull;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  /* then text of datagram */
  return context-&gt;Corrupted =
    USHAInput(&amp;context-&gt;shaContext, text, text_len);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * hmacFinalBits
 *
 * Description:
 *   This function will add in any final bits of the message.
 *
 * Parameters:
 *   context: [in/out]
 *     The HMAC context to update.
 *   message_bits: [in]
 *     The final bits of the message, in the upper portion of the
 *     byte.  (Use 0b###00000 instead of 0b00000### to input the
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *     three bits ###.)
 *   length: [in]
 *     The number of bits in message_bits, between 1 and 7.
 *
 * Returns:
 *   sha Error Code.
 */
int hmacFinalBits(HMACContext *context,
    uint8_t bits, unsigned int bit_count)
{
  if (!context) return shaNull;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  /* then final bits of datagram */
  return context-&gt;Corrupted =
    USHAFinalBits(&amp;context-&gt;shaContext, bits, bit_count);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * hmacResult
 *
 * Description:
 *   This function will return the N-byte message digest into the
 *   Message_Digest array provided by the caller.
 *
 * Parameters:
 *   context: [in/out]
 *     The context to use to calculate the HMAC hash.
 *   digest[ ]: [out]
 *     Where the digest is returned.
 *     NOTE 2: The length of the hash is determined by the value of
 *      whichSha that was passed to hmacReset().
 *
 * Returns:
 *   sha Error Code.
 *
 */
int hmacResult(HMACContext *context, uint8_t *digest)
{
  int ret;
  if (!context) return shaNull;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* finish up 1st pass */
  /* (Use digest here as a temporary buffer.) */
  ret =
    USHAResult(&amp;context-&gt;shaContext, digest) ||
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /* perform outer SHA */
         /* init context for 2nd pass */
         USHAReset(&amp;context-&gt;shaContext, context-&gt;whichSha) ||
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /* start with outer pad */
         USHAInput(&amp;context-&gt;shaContext, context-&gt;k_opad,
                   context-&gt;blockSize) ||
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /* then results of 1st hash */
         USHAInput(&amp;context-&gt;shaContext, digest, context-&gt;hashSize) ||
         /* finish up 2nd pass */
         USHAResult(&amp;context-&gt;shaContext, digest);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;Computed = 1;
  return context-&gt;Corrupted = ret;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. The HKDF Code
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4。 HKDFコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/**************************** hkdf.c ***************************/
/***************** See RFC 6234 for details. *******************/
/* Copyright (c) 2011 IETF Trust and the persons identified as */
/* authors of the code.  All rights reserved.                  */
/* See sha.h for terms of use and redistribution.              */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Description:
 *      This file implements the HKDF algorithm (HMAC-based
 *      Extract-and-Expand Key Derivation Function, RFC 5869),
 *      expressed in terms of the various SHA algorithms.
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34; #include &lt;string.h&gt; #include &lt;stdlib.h&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#include &#34;sha.h&#34; の#include &lt;string.hの&gt;する#include &lt;stdlib.h&gt;に含ま
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  hkdf
 *
 *  Description:
 *      This function will generate keying material using HKDF.
 *
 *  Parameters:
 *      whichSha: [in]
 *          One of SHA1, SHA224, SHA256, SHA384, SHA512
 *      salt[ ]: [in]
 *          The optional salt value (a non-secret random value);
 *          if not provided (salt == NULL), it is set internally
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *          to a string of HashLen(whichSha) zeros.
 *      salt_len: [in]
 *          The length of the salt value.  (Ignored if salt == NULL.)
 *      ikm[ ]: [in]
 *          Input keying material.
 *      ikm_len: [in]
 *          The length of the input keying material.
 *      info[ ]: [in]
 *          The optional context and application specific information.
 *          If info == NULL or a zero-length string, it is ignored.
 *      info_len: [in]
 *          The length of the optional context and application specific
 *          information.  (Ignored if info == NULL.)
 *      okm[ ]: [out]
 *          Where the HKDF is to be stored.
 *      okm_len: [in]
 *          The length of the buffer to hold okm.
 *          okm_len must be &lt;= 255 * USHABlockSize(whichSha)
 *
 *  Notes:
 *      Calls hkdfExtract() and hkdfExpand().
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int hkdf(SHAversion whichSha,
    const unsigned char *salt, int salt_len,
    const unsigned char *ikm, int ikm_len,
    const unsigned char *info, int info_len,
    uint8_t okm[ ], int okm_len)
{
  uint8_t prk[USHAMaxHashSize];
  return hkdfExtract(whichSha, salt, salt_len, ikm, ikm_len, prk) ||
         hkdfExpand(whichSha, prk, USHAHashSize(whichSha), info,
                    info_len, okm, okm_len);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  hkdfExtract
 *
 *  Description:
 *      This function will perform HKDF extraction.
 *
 *  Parameters:
 *      whichSha: [in]
 *          One of SHA1, SHA224, SHA256, SHA384, SHA512
 *      salt[ ]: [in]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *          The optional salt value (a non-secret random value);
 *          if not provided (salt == NULL), it is set internally
 *          to a string of HashLen(whichSha) zeros.
 *      salt_len: [in]
 *          The length of the salt value.  (Ignored if salt == NULL.)
 *      ikm[ ]: [in]
 *          Input keying material.
 *      ikm_len: [in]
 *          The length of the input keying material.
 *      prk[ ]: [out]
 *          Array where the HKDF extraction is to be stored.
 *          Must be larger than USHAHashSize(whichSha);
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int hkdfExtract(SHAversion whichSha,
    const unsigned char *salt, int salt_len,
    const unsigned char *ikm, int ikm_len,
    uint8_t prk[USHAMaxHashSize])
{
  unsigned char nullSalt[USHAMaxHashSize];
  if (salt == 0) {
    salt = nullSalt;
    salt_len = USHAHashSize(whichSha);
    memset(nullSalt, &#39;\0&#39;, salt_len);
  } else if (salt_len &lt; 0) {
    return shaBadParam;
  }
  return hmac(whichSha, ikm, ikm_len, salt, salt_len, prk);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  hkdfExpand
 *
 *  Description:
 *      This function will perform HKDF expansion.
 *
 *  Parameters:
 *      whichSha: [in]
 *          One of SHA1, SHA224, SHA256, SHA384, SHA512
 *      prk[ ]: [in]
 *          The pseudo-random key to be expanded; either obtained
 *          directly from a cryptographically strong, uniformly
 *          distributed pseudo-random number generator, or as the
 *          output from hkdfExtract().
 *      prk_len: [in]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *          The length of the pseudo-random key in prk;
 *          should at least be equal to USHAHashSize(whichSHA).
 *      info[ ]: [in]
 *          The optional context and application specific information.
 *          If info == NULL or a zero-length string, it is ignored.
 *      info_len: [in]
 *          The length of the optional context and application specific
 *          information.  (Ignored if info == NULL.)
 *      okm[ ]: [out]
 *          Where the HKDF is to be stored.
 *      okm_len: [in]
 *          The length of the buffer to hold okm.
 *          okm_len must be &lt;= 255 * USHABlockSize(whichSha)
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int hkdfExpand(SHAversion whichSha, const uint8_t prk[ ], int prk_len,
    const unsigned char *info, int info_len,
    uint8_t okm[ ], int okm_len)
{
  int hash_len, N;
  unsigned char T[USHAMaxHashSize];
  int Tlen, where, i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (info == 0) {
    info = (const unsigned char *)&#34;&#34;;
    info_len = 0;
  } else if (info_len &lt; 0) {
    return shaBadParam;
  }
  if (okm_len &lt;= 0) return shaBadParam;
  if (!okm) return shaBadParam;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  hash_len = USHAHashSize(whichSha);
  if (prk_len &lt; hash_len) return shaBadParam;
  N = okm_len / hash_len;
  if ((okm_len % hash_len) != 0) N++;
  if (N &gt; 255) return shaBadParam;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  Tlen = 0;
  where = 0;
  for (i = 1; i &lt;= N; i++) {
    HMACContext context;
    unsigned char c = i;
    int ret = hmacReset(&amp;context, whichSha, prk, prk_len) ||
              hmacInput(&amp;context, T, Tlen) || hmacInput(&amp;context, info, info_len) ||
              hmacInput(&amp;context, &amp;c, 1) ||
              hmacResult(&amp;context, T);
    if (ret != shaSuccess) return ret;
    memcpy(okm + where, T,
           (i != N) ? hash_len : (okm_len - where));
    where += hash_len;
    Tlen = hash_len;
  }
  return shaSuccess;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  hkdfReset
 *
 *  Description:
 *      This function will initialize the hkdfContext in preparation
 *      for key derivation using the modular HKDF interface for
 *      arbitrary length inputs.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to reset.
 *      whichSha: [in]
 *          One of SHA1, SHA224, SHA256, SHA384, SHA512
 *      salt[ ]: [in]
 *          The optional salt value (a non-secret random value);
 *          if not provided (salt == NULL), it is set internally
 *          to a string of HashLen(whichSha) zeros.
 *      salt_len: [in]
 *          The length of the salt value.  (Ignored if salt == NULL.)
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int hkdfReset(HKDFContext *context, enum SHAversion whichSha,
              const unsigned char *salt, int salt_len)
{
  unsigned char nullSalt[USHAMaxHashSize];
  if (!context) return shaNull;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  context-&gt;whichSha = whichSha;
  context-&gt;hashSize = USHAHashSize(whichSha);
  if (salt == 0) {
    salt = nullSalt;
    salt_len = context-&gt;hashSize;
    memset(nullSalt, &#39;\0&#39;, salt_len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return hmacReset(&amp;context-&gt;hmacContext, whichSha, salt, salt_len); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
hmacReset（＆、コンテキスト&gt; hmacContext、whichSha、塩、salt_len）を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  hkdfInput
 *
 *  Description:
 *      This function accepts an array of octets as the next portion
 *      of the input keying material.  It may be called multiple times.
 *
 *  Parameters:
 *      context: [in/out]
 *          The HKDF context to update.
 *      ikm[ ]: [in]
 *          An array of octets representing the next portion of
 *          the input keying material.
 *      ikm_len: [in]
 *          The length of ikm.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int hkdfInput(HKDFContext *context, const unsigned char *ikm,
              int ikm_len)
{
  if (!context) return shaNull;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  return hmacInput(&amp;context-&gt;hmacContext, ikm, ikm_len);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * hkdfFinalBits
 *
 * Description:
 *   This function will add in any final bits of the
 *   input keying material.
 *
 * Parameters:
 *   context: [in/out]
 *     The HKDF context to update
 *   ikm_bits: [in]
 *     The final bits of the input keying material, in the upper
 *     portion of the byte.  (Use 0b###00000 instead of 0b00000###
 *     to input the three bits ###.)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 *   ikm_bit_count: [in]
 *     The number of bits in message_bits, between 1 and 7.
 *
 * Returns:
 *   sha Error Code.
 */
int hkdfFinalBits(HKDFContext *context, uint8_t ikm_bits,
                  unsigned int ikm_bit_count)
{
  if (!context) return shaNull;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  return hmacFinalBits(&amp;context-&gt;hmacContext, ikm_bits, ikm_bit_count);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * hkdfResult
 *
 * Description:
 *   This function will finish the HKDF extraction and perform the
 *   final HKDF expansion.
 *
 * Parameters:
 *   context: [in/out]
 *     The HKDF context to use to calculate the HKDF hash.
 *   prk[ ]: [out]
 *     An optional location to store the HKDF extraction.
 *     Either NULL, or pointer to a buffer that must be
 *     larger than USHAHashSize(whichSha);
 *   info[ ]: [in]
 *     The optional context and application specific information.
 *     If info == NULL or a zero-length string, it is ignored.
 *   info_len: [in]
 *     The length of the optional context and application specific
 *     information.  (Ignored if info == NULL.)
 *   okm[ ]: [out]
 *     Where the HKDF is to be stored.
 *   okm_len: [in]
 *     The length of the buffer to hold okm.
 *     okm_len must be &lt;= 255 * USHABlockSize(whichSha)
 *
 * Returns:
 *   sha Error Code.
 *
 */
int hkdfResult(HKDFContext *context,
               uint8_t prk[USHAMaxHashSize],
               const unsigned char *info, int info_len, uint8_t okm[ ], int okm_len)
{
  uint8_t prkbuf[USHAMaxHashSize];
  int ret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (!context) return shaNull;
  if (context-&gt;Corrupted) return context-&gt;Corrupted;
  if (context-&gt;Computed) return context-&gt;Corrupted = shaStateError;
  if (!okm) return context-&gt;Corrupted = shaBadParam;
  if (!prk) prk = prkbuf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  ret = hmacResult(&amp;context-&gt;hmacContext, prk) ||
        hkdfExpand(context-&gt;whichSha, prk, context-&gt;hashSize, info,
                   info_len, okm, okm_len);
  context-&gt;Computed = 1;
  return context-&gt;Corrupted = ret;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. The Test Driver
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5。テストドライバ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following code is a main program test driver to exercise the code in sha1.c, sha224-256.c, sha384-512.c, hmac.c, and hkdf.c. The test driver can also be used as a standalone program for generating the hashes. Note that the tests assume that character values are as in [US-ASCII] and a run time check warns if the code appears to have been compiled with some other character system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のコードsha1.c、sha224-256.c、sha384-512.c、hmac.c、及びhkdf.c.のコードを行使するためのメインプログラムのテストドライバーでありますテストドライバーはまた、ハッシュを生成するためのスタンドアロンのプログラムとして使用することができます。テストは文字値は[US-ASCII]のようであり、コードはいくつかの他の文字システムでコンパイルされているように見える場合は、実行時のチェックが警告していることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See also [SHAVS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHAVS]も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/************************** shatest.c **************************/
/***************** See RFC 6234 for details. *******************/
/* Copyright (c) 2011 IETF Trust and the persons identified as */
/* authors of the code.  All rights reserved.                  */
/* See sha.h for terms of use and redistribution.              */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Description:
 *    This file will exercise the SHA code performing
 *      the three tests documented in FIPS PUB 180-3
 *        (http://csrc.nist.gov/publications/fips/
 *         fips180-2/fips180-2withchangenotice.pdf)
 *      one that calls SHAInput with an exact multiple of 512 bits
 *      the seven tests documented for each algorithm in
 *        &#34;The Secure Hash Algorithm Validation System (SHAVS)&#34;
 *        (http://csrc.nist.gov/cryptval/shs/SHAVS.pdf),
 *        three of which are bit-level tests
 *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* These tests have subsequently been moved to pages linked from * http://csrc.nist.gov/groups/ST/toolkit/examples.html * * This file will exercise the HMAC SHA1 code performing * the seven tests documented in RFCs [RFC 2202] and [RFC 4231]. * * This file will exercise the HKDF code performing * the seven tests documented in RFC 4869. * * To run the tests and just see PASSED/FAILED, use the -p option. * * Other options exercise: * hashing an arbitrary string * hashing a file&#39;s contents * a few error test checks * printing the results in raw format * * Portability Issues: * None. * */
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*これらのテストは、その後* http://csrc.nist.gov/groups/ST/toolkit/examples.htmlからリンクされているページに移動されました* *このファイルには、[* RFCで文書化さ7つのテストを行ってHMAC SHA1コードを行使するRFC 2202]と[RFC 4231]。 * *このファイルは、* RFC 4869.に記載さ7つのテストは* *テストを実行するには、ちょうどFAILED / PASSED参照、-pオプションを使用して実行するHKDFコードを行使します。 * *その他のオプションの行使：*いくつかのエラー・テスト・チェックはそのままの形式で結果を印刷する* *ファイルの内容をハッシュ任意の文字列*をハッシュ* *移植性の問題：*なし。 * * /
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;unistd.h&gt;     /* defines getopt() and optarg */
#include &#34;sha.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
static int scasecmp(const char *s1, const char *s2);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
静的int型scasecmp（のconst char型* s1を、CONSTするchar * S2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 *  Define patterns for testing
 */
#define TEST1    &#34;abc&#34;
#define TEST2_1  \
        &#34;abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq&#34;
#define TEST2_2a \
        &#34;abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn&#34;
#define TEST2_2b \
        &#34;hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu&#34;
#define TEST2_2  TEST2_2a TEST2_2b
#define TEST3    &#34;a&#34;                            /* times 1000000 */
#define TEST4a   &#34;01234567012345670123456701234567&#34;
#define TEST4b   &#34;01234567012345670123456701234567&#34;
    /* an exact multiple of 512 bits */
#define TEST4   TEST4a TEST4b                   /* times 10 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define TEST7_1 \ &#34;\x49\xb2\xae\xc2\x59\x4b\xbe\x3a\x3b\x11\x75\x42\xd9\x4a\xc8&#34; #define TEST8_1 \ &#34;\x9a\x7d\xfd\xf1\xec\xea\xd0\x6e\xd6\x46\xaa\x55\xfe\x75\x71\x46&#34; #define TEST9_1 \ &#34;\x65\xf9\x32\x99\x5b\xa4\xce\x2c\xb1\xb4\xa2\xe7\x1a\xe7\x02\x20&#34; \ &#34;\xaa\xce\xc8\x96\x2d\xd4\x49\x9c\xbd\x7c\x88\x7a\x94\xea\xaa\x10&#34; \ &#34;\x1e\xa5\xaa\xbc\x52\x9b\x4e\x7e\x43\x66\x5a\x5a\xf2\xcd\x03\xfe&#34; \ &#34;\x67\x8e\xa6\xa5\x00\x5b\xba\x3b\x08\x22\x04\xc2\x8b\x91\x09\xf4&#34; \ &#34;\x69\xda\xc9\x2a\xaa\xb3\xaa\x7c\x11\xa1\xb3\x2a&#34; #define TEST10_1 \ &#34;\xf7\x8f\x92\x14\x1b\xcd\x17\x0a\xe8\x9b\x4f\xba\x15\xa1\xd5\x9f&#34; \ &#34;\x3f\xd8\x4d\x22\x3c\x92\x51\xbd\xac\xbb\xae\x61\xd0\x5e\xd1\x15&#34; \ &#34;\xa0\x6a\x7c\xe1\x17\xb7\xbe\xea\xd2\x44\x21\xde\xd9\xc3\x25\x92&#34; \ &#34;\xbd\x57\xed\xea\xe3\x9c\x39\xfa\x1f\xe8\x94\x6a\x84\xd0\xcf\x1f&#34; \ &#34;\x7b\xee\xad\x17\x13\xe2\xe0\x95\x98\x97\x34\x7f\x67\xc8\x0b\x04&#34; \ &#34;\x00\xc2\x09\x81\x5d\x6b\x10\xa6\x83\x83\x6f\xd5\x56\x2a\x56\xca&#34; \ &#34;\xb1\xa2\x8e\x81\xb6\x57\x66\x54\x63\x1c\xf1\x65\x66\xb8\x6e\x3b&#34; \ &#34;\x33\xa1\x08\xb0\x53\x07\xc0\x0a\xff\x14\xa7\x68\xed\x73\x50\x60&#34; \ &#34;\x6a\x0f\x85\xe6\xa9\x1d\x39\x6f\x5b\x5c\xbe\x57\x7f\x9b\x38\x80&#34; \ &#34;\x7c\x7d\x52\x3d\x6d\x79\x2f\x6e\xbc\x24\xa4\xec\xf2\xb3\xa4\x27&#34; \ &#34;\xcd\xbb\xfb&#34; #define TEST7_224 \ &#34;\xf0\x70\x06\xf2\x5a\x0b\xea\x68\xcd\x76\xa2\x95\x87\xc2\x8d&#34; #define TEST8_224 \ &#34;\x18\x80\x40\x05\xdd\x4f\xbd\x15\x56\x29\x9d\x6f\x9d\x93\xdf\x62&#34; #define TEST9_224 \ &#34;\xa2\xbe\x6e\x46\x32\x81\x09\x02\x94\xd9\xce\x94\x82\x65\x69\x42&#34; \ &#34;\x3a\x3a\x30\x5e\xd5\xe2\x11\x6c\xd4\xa4\xc9\x87\xfc\x06\x57\x00&#34; \ &#34;\x64\x91\xb1\x49\xcc\xd4\xb5\x11\x30\xac\x62\xb1\x9d\xc2\x48\xc7&#34; \ &#34;\x44\x54\x3d\x20\xcd\x39\x52\xdc\xed\x1f\x06\xcc\x3b\x18\xb9\x1f&#34; \ &#34;\x3f\x55\x63\x3e\xcc\x30\x85\xf4\x90\x70\x60\xd2&#34; #define TEST10_224 \ &#34;\x55\xb2\x10\x07\x9c\x61\xb5\x3a\xdd\x52\x06\x22\xd1\xac\x97\xd5&#34; \ &#34;\xcd\xbe\x8c\xb3\x3a\xa0\xae\x34\x45\x17\xbe\xe4\xd7\xba\x09\xab&#34; \ &#34;\xc8\x53\x3c\x52\x50\x88\x7a\x43\xbe\xbb\xac\x90\x6c\x2e\x18\x37&#34; \ &#34;\xf2\x6b\x36\xa5\x9a\xe3\xbe\x78\x14\xd5\x06\x89\x6b\x71\x8b\x2a&#34; \ &#34;\x38\x3e\xcd\xac\x16\xb9\x61\x25\x55\x3f\x41\x6f\xf3\x2c\x66\x74&#34; \ &#34;\xc7\x45\x99\xa9\x00\x53\x86\xd9\xce\x11\x12\x24\x5f\x48\xee\x47&#34; \ &#34;\x0d\x39\x6c\x1e\xd6\x3b\x92\x67\x0c\xa5\x6e\xc8\x4d\xee\xa8\x14&#34; \ &#34;\xb6\x13\x5e\xca\x54\x39\x2b\xde\xdb\x94\x89\xbc\x9b\x87\x5a\x8b&#34; \ &#34;\xaf\x0d\xc1\xae\x78\x57\x36\x91\x4a\xb7\xda\xa2\x64\xbc\x07\x9d&#34; \ &#34;\x26\x9f\x2c\x0d\x7e\xdd\xd8\x10\xa4\x26\x14\x5a\x07\x76\xf6\x7c&#34; \ &#34;\x87\x82\x73&#34; #define TEST7_256 \ &#34;\xbe\x27\x46\xc6\xdb\x52\x76\x5f\xdb\x2f\x88\x70\x0f\x9a\x73&#34; #define TEST8_256 \ &#34;\xe3\xd7\x25\x70\xdc\xdd\x78\x7c\xe3\x88\x7a\xb2\xcd\x68\x46\x52&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define TEST7_1 \ &#34;\ X49 \ XB2 \ XAE \ XC2 \ X59 \ x4b \ xbe \ X3A \ X3B \ x11の\ X75 \ X42 \ XD9 \ X4A \ xc8&#34; の#define TEST8_1 \「\ x9a \ x7d \ XFD \ XF1 \ XEC \ XEA \ XD0 \ x6e \ XD6 \ X46 \お送り\ X55 \ XFE \ X75 \ X71 \ X46 &#34;の#define TEST9_1 \&#34; \ X65 \ xf9 \ x32の\ X99 \ X5B \ XA4 \ XCE \ X2C \ XB1 \ XB4 \ XA2 \ XE7 \ X1A \ XE7 \ X02 \ X20 &#34;\&#34; \お送り\ XCE \ xc8 \ X96 \ x2d \ XD4 \ X49 \ x9c \ XBD \ x7c \ X88 \ X7A \ X94 \ XEA \ \のX10を送信 &#34;\&#34; \ X1E \ xa5 \お送り\ XBC \ X52 \ x9b \ x4e \ x7e \ X43 \ X66 \ X5A \ X5A \ XF2 \ XCD \ X03 \ XFE &#34;\&#34; \ X67 \ X8E \ xa6 \ xa5 \ X00 \ X5B \ XBA \ X3B \ X08 \ X22 \ X04 \ XC2 \ x8b \ X91 \ x09の\ XF4 &#34;\&#34; \ X69 \ XDA \ xc9 \ X2A \お送り\ XB3 \お送り\ x7c \ x11の\ XA1 \ XB3 \ X2A &#34;の#define TEST10_1 \&#34; \ XF7 \ x8f \ X92 \ X14 \ X1B \ XCD \ X17 \ X0A \ xe8 \ x9b \ x4f \ XBA \ X15 \ XA1 \ XD5 \ x9f &#34;\&#34; \ X3F \ xd8 \ x4d \ X22 \ X3C \ X92 \ X51 \ XBD \ XAC \ XBB \ XAE \ X61 \ XD0 \ x5e \ XD1 \ X15 &#34;\&#34; \ XA0 \ X6A \ x7c \ XE1 \ X17 \ xb7 \ xbe \ XEA \ XD2 \ X44 \ X21 \ XDE \ XD9 \ XC3 \ X25 \ X92 &#34;\&#34; \ XBD \ X57 \ XED \ XEA \ XE3 \ x9c \ X39 \ XFA \ X1F \ xe8 \ X94 \ X6A \ X84 \ XD0 \ XCF \ X1F &#34;\&#34; \ x7b \ニッケル\ XAD \ X17 \ X13 \ XE2 \ xe0 \ X95 \ x98 \ X97 \ X34 \ x7f \ X67 \ xc8 \ X0B \ X04 &#34;\&#34; \ X00 \ XC2 \ x09の\ X81 \ x5d \ X6B \ X10 \ xa6 \ X83 \ X83 \ x6f \ XD5 \ X56 \ X2A \ X56 \ XCA &#34;\&#34; \ XB1 \ XA2 \ X8E \ X81 \ XB6 \ X57 \ X66 \ X54 \ X63 \ X1C \ XF1 \ X65 \ X66 \ XB 8 \ x6eの\のX3B &#34;\&#34; \ X33 \ XA1 \ X08 \ XB0 \ X53 \ X07 \ XC0 \ X0A \ XFF \ X14 \ xa7 \ X68 \ XED \ X73 \ X50 \ X60 &#34;\&#34; \ X6A \ x0f \ X85 \ XE6 \ xa9 \ X1D \ X39 \ x6f \ X5B \ x5c \ xbe \ X57 \ x7f \ x9b \ X38 \ X80 &#34;\&#34; \ x7c \ x7d \ X52 \ X3D \ x6dは\ X79 \ x2f \ x6e \ XBC \ X24 \ XA4 \ XEC \ XF2 \ XB3 \ XA4 \ X27 &#34;\&#34; \ XCD \ XBB \ XFB &#34;の#define TEST7_224 \&#34; \ XF0 \ X70 \ X06 \ XF2 \ X5A \ X0B \ XEA \ X68 \ XCD \ X76 \ XA2 \ X95 \ x87 \ XC2 \ x8d &#34;の#define TEST8_224 \&#34; \ X18 \ X80 \ X40 \ X05 \ XDD \ x4f \ XBD \ X15 \ X56 \ X29 \ x9d \ x6f \ x9d \ X93 \ XDF \ X62 &#34;の#define TEST9_224 \&#34; \ XA2 \ xbe \ x6e \ X46 \ x32の\ X81 \ x09の\ X02 \ X94 \ XD9 \ XCE \ X94 \ X82 \ X65 \ X69 \ X42 &#34;\&#34; \ X3A \ X3A \ X30 \ x5e \ XD5 \ XE2 \ x11の\ x6c \ XD4 \ XA4 \ xc9 \のx87 \ XFC \ X06 \ X57 \ X00 &#34;\&#34; \ x64の\ X91 \ XB1 \ X49 \ XCC \ XD4 \ XB5 \ x11の\ X30 \ XAC \ X62 \ XB1 \ x9d \ XC2 \ X48 \ xc7 &#34;\&#34; \ X44 \ X54 \ X3D \ X20 \ XCD \ X39 \ X52 \ XDC \ XED \ X1F \ X06 \ XCC \ X3B \ X18 \ xb9 \ X1F &#34;\&#34; \ X3F \ X55 \ X63 \ Spark Proの\ XCC \ X30 \ X85 \ XF4 \ X90 \ X70 \ X60 \ XD2 &#34;の#define TEST10_224 \&#34; \ X55 \ XB2 \ X10 \ X07 \ x9c \ X61 \ XB5 \ X3A \ XDD \ X52 \ X06 \ X22 \ XD1 \ XAC \ X97 \ XD5 &#34;\&#34; \ XCD \ xbe \ x8c \ XB3 \ X3A \ XA0 \ XAE \ X34 \ X45 \ X17 \ xbe \ xe4 \ XD7 \ XBA \ x09の\測定 &#34;\&#34; \ xc8 \ X53 \ X3C \ X52 \ X50 \ X88 \ X7A \ X43 \ xbe \ XBB \ XAC \ X90 \ x6c \ x2e \ X18 \ X37 &#34;\&#34; \ XF2 \ X6B \ x36の\ xa5 \ X9 A \ XE3 \ xbe \ x78 \ X14 \ XD5 \ X06 \ x89 \ X6B \ X71 \ x8b \ X2A &#34;\&#34; \ X38 \ Spark Proの\ XCD \ XAC \ X16 \ xb9 \ X61 \ X25 \ X55 \ X3F \ X41 \ x6f \ XF3 \ X2C \ X66 \ X74 &#34;\&#34; \ xc7 \ X45 \ X99 \ xa9 \ X00 \ X53 \ X86 \ XD9 \ XCE \ x11の\ X12 \ X24 \ x5f \ X48 \ニッケルの\ X47 &#34;\&#34; \ x0d \ X39 \ x6c \ X1E \ XD6 \ X3B \ X92 \ X67 \ x0c \ xa5 \ x6e \ xc8 \ x4d \ニッケル\ xa8の\のX14 &#34;\&#34; \ XB6 \ X13 \ x5e \ XCA \ X54 \ X39 \ X2B \ XDE \ XDB \ X94 \ x89 \ XBC \ x9b \のx87 \ X5A \ x8b &#34;\&#34; \ XAF \ x0d \ XC1 \ XAE \ x78 \ X57 \ x36の\ X91 \ X4A \ xb7 \ XDA \ XA2 \ x64の\ XBC \ X07 \ x9d「\ &#34;\ X26 \ x9f \ X2C \ x0d \ x7e \ XDD \ xd8 \ X10 \ XA4 \ X26 \ X14 \ X5A \ X07 \ X76 \ XF6 \ x7c&#34; \ &#34;\のx87 \ X82 \ X73&#34; の#define TEST7_256 \「\ xbe \ X27 \ X46 \ xc6 \ XDB \ X52 \ X76 \ x5f \ XDB \ x2f \ X88 \ X70 \ x0f \ x9a \ X73 &#34;の#define TEST8_256 \&#34; \ XE3 \ XD7 \ X25 \ X70 \ XDC \ XDD \ x78用の\ x7c \ XE3 \ X88 \ X7A \ XB2 \ XCD \ X68 \ X46 \ X52」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define TEST9_256 \ &#34;\x3e\x74\x03\x71\xc8\x10\xc2\xb9\x9f\xc0\x4e\x80\x49\x07\xef\x7c&#34; \ &#34;\xf2\x6b\xe2\x8b\x57\xcb\x58\xa3\xe2\xf3\xc0\x07\x16\x6e\x49\xc1&#34; \ &#34;\x2e\x9b\xa3\x4c\x01\x04\x06\x91\x29\xea\x76\x15\x64\x25\x45\x70&#34; \ &#34;\x3a\x2b\xd9\x01\xe1\x6e\xb0\xe0\x5d\xeb\xa0\x14\xeb\xff\x64\x06&#34; \ &#34;\xa0\x7d\x54\x36\x4e\xff\x74\x2d\xa7\x79\xb0\xb3&#34; #define TEST10_256 \ &#34;\x83\x26\x75\x4e\x22\x77\x37\x2f\x4f\xc1\x2b\x20\x52\x7a\xfe\xf0&#34; \ &#34;\x4d\x8a\x05\x69\x71\xb1\x1a\xd5\x71\x23\xa7\xc1\x37\x76\x00\x00&#34; \ &#34;\xd7\xbe\xf6\xf3\xc1\xf7\xa9\x08\x3a\xa3\x9d\x81\x0d\xb3\x10\x77&#34; \ &#34;\x7d\xab\x8b\x1e\x7f\x02\xb8\x4a\x26\xc7\x73\x32\x5f\x8b\x23\x74&#34; \ &#34;\xde\x7a\x4b\x5a\x58\xcb\x5c\x5c\xf3\x5b\xce\xe6\xfb\x94\x6e\x5b&#34; \ &#34;\xd6\x94\xfa\x59\x3a\x8b\xeb\x3f\x9d\x65\x92\xec\xed\xaa\x66\xca&#34; \ &#34;\x82\xa2\x9d\x0c\x51\xbc\xf9\x33\x62\x30\xe5\xd7\x84\xe4\xc0\xa4&#34; \ &#34;\x3f\x8d\x79\xa3\x0a\x16\x5c\xba\xbe\x45\x2b\x77\x4b\x9c\x71\x09&#34; \ &#34;\xa9\x7d\x13\x8f\x12\x92\x28\x96\x6f\x6c\x0a\xdc\x10\x6a\xad\x5a&#34; \ &#34;\x9f\xdd\x30\x82\x57\x69\xb2\xc6\x71\xaf\x67\x59\xdf\x28\xeb\x39&#34; \ &#34;\x3d\x54\xd6&#34; #define TEST7_384 \ &#34;\x8b\xc5\x00\xc7\x7c\xee\xd9\x87\x9d\xa9\x89\x10\x7c\xe0\xaa&#34; #define TEST8_384 \ &#34;\xa4\x1c\x49\x77\x79\xc0\x37\x5f\xf1\x0a\x7f\x4e\x08\x59\x17\x39&#34; #define TEST9_384 \ &#34;\x68\xf5\x01\x79\x2d\xea\x97\x96\x76\x70\x22\xd9\x3d\xa7\x16\x79&#34; \ &#34;\x30\x99\x20\xfa\x10\x12\xae\xa3\x57\xb2\xb1\x33\x1d\x40\xa1\xd0&#34; \ &#34;\x3c\x41\xc2\x40\xb3\xc9\xa7\x5b\x48\x92\xf4\xc0\x72\x4b\x68\xc8&#34; \ &#34;\x75\x32\x1a\xb8\xcf\xe5\x02\x3b\xd3\x75\xbc\x0f\x94\xbd\x89\xfe&#34; \ &#34;\x04\xf2\x97\x10\x5d\x7b\x82\xff\xc0\x02\x1a\xeb\x1c\xcb\x67\x4f&#34; \ &#34;\x52\x44\xea\x34\x97\xde\x26\xa4\x19\x1c\x5f\x62\xe5\xe9\xa2\xd8&#34; \ &#34;\x08\x2f\x05\x51\xf4\xa5\x30\x68\x26\xe9\x1c\xc0\x06\xce\x1b\xf6&#34; \ &#34;\x0f\xf7\x19\xd4\x2f\xa5\x21\xc8\x71\xcd\x23\x94\xd9\x6e\xf4\x46&#34; \ &#34;\x8f\x21\x96\x6b\x41\xf2\xba\x80\xc2\x6e\x83\xa9&#34; #define TEST10_384 \ &#34;\x39\x96\x69\xe2\x8f\x6b\x9c\x6d\xbc\xbb\x69\x12\xec\x10\xff\xcf&#34; \ &#34;\x74\x79\x03\x49\xb7\xdc\x8f\xbe\x4a\x8e\x7b\x3b\x56\x21\xdb\x0f&#34; \ &#34;\x3e\x7d\xc8\x7f\x82\x32\x64\xbb\xe4\x0d\x18\x11\xc9\xea\x20\x61&#34; \ &#34;\xe1\xc8\x4a\xd1\x0a\x23\xfa\xc1\x72\x7e\x72\x02\xfc\x3f\x50\x42&#34; \ &#34;\xe6\xbf\x58\xcb\xa8\xa2\x74\x6e\x1f\x64\xf9\xb9\xea\x35\x2c\x71&#34; \ &#34;\x15\x07\x05\x3c\xf4\xe5\x33\x9d\x52\x86\x5f\x25\xcc\x22\xb5\xe8&#34; \ &#34;\x77\x84\xa1\x2f\xc9\x61\xd6\x6c\xb6\xe8\x95\x73\x19\x9a\x2c\xe6&#34; \ &#34;\x56\x5c\xbd\xf1\x3d\xca\x40\x38\x32\xcf\xcb\x0e\x8b\x72\x11\xe8&#34; \ &#34;\x3a\xf3\x2a\x11\xac\x17\x92\x9f\xf1\xc0\x73\xa5\x1c\xc0\x27\xaa&#34; \ &#34;\xed\xef\xf8\x5a\xad\x7c\x2b\x7c\x5a\x80\x3e\x24\x04\xd9\x6d\x2a&#34; \ &#34;\x77\x35\x7b\xda\x1a\x6d\xae\xed\x17\x15\x1c\xb9\xbc\x51\x25\xa4&#34; \ &#34;\x22\xe9\x41\xde\x0c\xa0\xfc\x50\x11\xc2\x3e\xcf\xfe\xfd\xd0\x96&#34; \ &#34;\x76\x71\x1c\xf3\xdb\x0a\x34\x40\x72\x0e\x16\x15\xc1\xf2\x2f\xbc&#34; \ &#34;\x3c\x72\x1d\xe5\x21\xe1\xb9\x9b\xa1\xbd\x55\x77\x40\x86\x42\x14&#34; \ &#34;\x7e\xd0\x96&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define TEST9_256 \ &#34;\ Spark Proの\ X74 \ X03 \ X71 \ xc8 \ X10 \ XC2 \ xb9 \ x9f \ XC0 \ x4e \ X80 \ X49 \ X07 \のXeF \ x7c&#34; \「\ XF2 \ X6B \ XE2 \ x8b \ X57 \ XCB \ X58 \ XA3 \ XE2 \ XF3 \ XC0 \ X07 \ X16 \ x6e \ X49 \ XC1 &#34;\&#34; \ x2e \ x9b \ XA3 \ x4c \ X01 \ X04 \ X06 \ X91 \ X29 \ XEA \ X76 \ X15 \ x64の\ X25 \ X45 \ X70 &#34;\&#34; \ X3A \ X2B \ XD9 \ X01 \ XE1 \ x6e \ XB0 \ xe0 \ x5d錆\ \ XA0 \ X14 \腐食\ XFF \ x64の\ X06 &#34;\&#34; \ XA0 \ x7d \ X54 \ X36 \ x4e \ XFF \ X74 \ x2d \ xa7 \ X79 \ XB0 \ XB3 &#34;の#define TEST10_256 \&#34; \ X83 \ X26 \ X75 \ x4e \ X22 \ X77 \ X37 \ x2f \ x4f \ XC1 \ X2B \ X20 \ X52 \ X7A \ XFE \ XF0 &#34;\&#34; \ x4d \ x8a \ X05 \ X69 \ X71 \ XB1 \ X1A \ XD5 \ X71 \ X23 \ xa7 \ XC1 \ X37 \ X76 \ X00 \ X00 &#34;\&#34; \ XD7 \ xbe \ XF6 \ XF3 \ XC1 \ XF7 \ xa9 \ X08 \ X3A \ XA3 \ x9d \ X81 \ x0d \ XB3 \ X10 \ X77 &#34;\&#34; \ x7dの\測定\ x8b \ X1E \ x7f \ X02 \ xb8 \ X4A \ X26 \ xc7 \ X73 \ x32の\ x5f \ x8b \ X23 \ X74 &#34;\&#34; \ XDE \ X7A \ x4b \ X5A \ X58 \ XCB \ x5c \ x5c \ XF3 \ X5B \ XCE \ XE6 \ XFB \ X94 \ x6e \ X5B &#34;\&#34; \ XD6 \ X94 \ XFA \ X59 \ X3A \ x8b錆\ \ X3F \ x9d \ X65 \ X92 \ XEC \ XED \お送り\ X66 \ XCA &#34;\&#34; \ X82 \ XA2 \ x9d \ x0c \ X51 \ XBC \ xf9 \ X33 \ X62 \ X30 \ xe5 \ XD7 \ X84 \ xe4 \ XC0 \ XA4 &#34;\&#34; \ X3F \ x8d \ X79 \ XA3 \ X0A \ X16 \ x5c \ XBA \ xbe \ X45 \ X2B \ X77 \ x4b \ x9c \ X71 \ x09の &#34;\&#34; \ xa9 \ x7d \ X13 \ x8f \ X12 \ X92 \ X28 \ X96 \ x6f \ x6c \ X0A \ XDC \ X10 \ X6A \ XAD \ X5A &#34;\&#34; \ x9f \ XDD \ X 30 \ X82 \ X57 \ X69 \ XB2 \ xc6 \ X71 \ XAF \ X67 \ X59 \ XDF \ X28 \腐食の\ X39 &#34;\&#34; \ X3D \ X54 \ XD6 &#34;の#define TEST7_384 \&#34; \ x8b \ XC5 \ X00 \ xc7 \ x7cの\ニッケル\ XD9 \のx87 \ x9d \ xa9 \ x89 \ X10 \ x7c \ xe0 \郵送 &#34;の#define TEST8_384 \&#34; \ XA4 \ X1C \ X49 \ X77 \ X79 \ XC0 \ X37 \ x5f \ XF1 \ X0A \ x7f \ x4e \ X08 \ X59 \ X17 \ X39 &#34;の#define TEST9_384 \&#34; \ X68 \ XF5 \ X01 \ X79 \ x2d \ XEA \ X97 \ X96 \ X76 \ X70 \ X22 \ XD9 \ X3D \ xa7 \ X16 \ X79「\ &#34;\ X30 \ X99 \ X20 \ XFA \ X10 \ X12 \ XAE \ XA3 \ X57 \ XB2 \ XB1 \ X33 \ X1D \ X40 \ XA1 \ XD0&#34; \「\ X3C \ X41 \ XC2 \ X40 \ XB3 \ xc9 \ xa7 \ X5B \ X48 \ X92 \ XF4 \ XC0 \ X72 \ x4b \ X68 \ xc8 &#34;\&#34; \ X75 \ x32の\ X1A \ xb8 \ XCF \ xe5 \ X02 \ X3B \ XD3 \ X75 \ XBC \ x0f \ X94 \ XBD \ x89 \のXFE &#34;\&#34; \ X04 \ XF2 \ X97 \ X10 \ x5d \ x7b \ X82 \ XFF \ XC0 \ X02 \ X1A錆\ \ X1C \ XCB \ X67 \ x4f &#34;\&#34; \ X52 \ X44 \ XEA \ X34 \ X97 \ XDE \ X26 \ XA4 \ X19 \ X1C \ x5f \ X62 \ xe5 \ XE9 \ XA2 \ xd8 &#34;\&#34; \ X08 \ x2f \ X05 \ X51 \ XF4 \ xa5 \ X30 \ X68 \ X26 \ XE9 \ X1C \ XC0 \ X06 \ XCE \ X1B \ &#34;\&#34; XF6 \ x0f \ XF7 \ X19 \ XD4 \ x2f \ xa5 \ X21 \ xc8 \ X71 \ XCD \ X23 \ X94 \ XD9 \ x6e \ XF4 \ X46 &#34;\&#34; \ x8f \ X21 \ X96 \ X6B \ X41 \ XF2 \ XBA \ X80 \ XC2 \ x6e \ X83 \ xa9 &#34;の#define TEST10_384 \&#34; \ X39 \ X96 \ X69 \ XE2 \ x8f \ X6B \ x9c \ x6dは\ XBC \ XBB \ X69 \ X12 \ XEC \ X10 \ XFF \ XCF &#34;\&#34; \ X74 \ X79 \ X03 \ X49 \ xb7 \ XDC \ x8f \ xbe \ X4A \ X8E \ X7 B \ X3B \ X56 \ X21 \ XDB \ x0f &#34;\&#34; \ Spark Proの\ x7d \ xc8 \ x7f \ X82 \ x32の\ x64の\ XBB \ xe4 \ x0d \ X18 \ x11の\ xc9 \ XEA \ X20 \ X61 &#34;\&#34; \ XE1 \ xc8 \ X4A \ XD1 \ X0A \ X23 \ XFA \ XC1 \ X72 \ x7e \ X72 \ X02 \ XFC \ X3F \ X50 \ X42 &#34;\&#34; \ XE6 \ XBF \ X58 \ XCB \ xa8 \ XA2 \ X74 \ x6e \ X1F \ x64の\ xf9 \ xb9 \ XEA \ X35 \ X2C \ X71 &#34;\&#34; \ X15 \ X07 \ X05 \ X3C \ XF4 \ xe5 \ X33 \ x9d \ X52 \ X86 \ x5f \ X25 \ XCC \ X22 \ XB5 \ xe8 &#34;\&#34; \ X77 \ X84 \ XA1 \ x2f \ xc9 \ X61 \ XD6 \ x6c \ XB6 \ xe8 \ X95 \ X73 \ X19 \ x9a \ X2C \ XE6 &#34;\&#34; \ X56 \ x5c \ XBD \ XF1 \ X3D \ XCA \ X40 \ X38 \ x32の\ XCF \ XCB \ x0e \ x8b \ X72 \ x11の\ xe8 &#34;\&#34; \ X3A \ XF3 \ X2A \ x11の\ XAC \ X17 \ X92 \ x9f \ XF1 \ XC0 \ X73 \ xa5 \ X1C \ XC0 \ X27 \リターン &#34;\&#34; \ XED \のXeF \ XF8 \ X5A \ XAD \ x7c \ X2B \ x7c \ X5A \ X80 \ Spark Proの\ X24 \ X04 \ XD9 \ x6dは\ X2A &#34;\&#34; \ X77 \ X35 \ x7b \ XDA \ X1A \ x6dは\ XAE \ XED \ X17 \ X15 \ X1C \ xb9 \ XBC \ X51 \ X25 \ XA4 &#34;\&#34; \ X22 \ XE9 \ X41 \ XDE \ x0c \ XA0 \ XFC \ X50 \ x11の\ XC2 \ Spark Proの\ XCF \ XFE \ XFD \ XD0 \ X96 &#34;\&#34; \ X76 \ X71 \ X1C \ XF3 \ XDB \ X0A \ X34 \ X40 \ X72 \ x0e \ X16 \ X15 \ XC1 \ XF2 \ x2f \ XBC &#34;\&#34; \ X3C \ X72 \ X1D \ xe5 \ X21 \ XE1 \ xb9 \ x9b \ XA1 \ XBD \ X55 \ X77 \ X40 \ X86 \ X42 \ X14 &#34;\&#34; \ x7e \ XD0 \ X96」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define TEST7_512 \ &#34;\x08\xec\xb5\x2e\xba\xe1\xf7\x42\x2d\xb6\x2b\xcd\x54\x26\x70&#34; #define TEST8_512 \ &#34;\x8d\x4e\x3c\x0e\x38\x89\x19\x14\x91\x81\x6e\x9d\x98\xbf\xf0\xa0&#34; #define TEST9_512 \ &#34;\x3a\xdd\xec\x85\x59\x32\x16\xd1\x61\x9a\xa0\x2d\x97\x56\x97\x0b&#34; \ &#34;\xfc\x70\xac\xe2\x74\x4f\x7c\x6b\x27\x88\x15\x10\x28\xf7\xb6\xa2&#34; \ &#34;\x55\x0f\xd7\x4a\x7e\x6e\x69\xc2\xc9\xb4\x5f\xc4\x54\x96\x6d\xc3&#34; \ &#34;\x1d\x2e\x10\xda\x1f\x95\xce\x02\xbe\xb4\xbf\x87\x65\x57\x4c\xbd&#34; \ &#34;\x6e\x83\x37\xef\x42\x0a\xdc\x98\xc1\x5c\xb6\xd5\xe4\xa0\x24\x1b&#34; \ &#34;\xa0\x04\x6d\x25\x0e\x51\x02\x31\xca\xc2\x04\x6c\x99\x16\x06\xab&#34; \ &#34;\x4e\xe4\x14\x5b\xee\x2f\xf4\xbb\x12\x3a\xab\x49\x8d\x9d\x44\x79&#34; \ &#34;\x4f\x99\xcc\xad\x89\xa9\xa1\x62\x12\x59\xed\xa7\x0a\x5b\x6d\xd4&#34; \ &#34;\xbd\xd8\x77\x78\xc9\x04\x3b\x93\x84\xf5\x49\x06&#34; #define TEST10_512 \ &#34;\xa5\x5f\x20\xc4\x11\xaa\xd1\x32\x80\x7a\x50\x2d\x65\x82\x4e\x31&#34; \ &#34;\xa2\x30\x54\x32\xaa\x3d\x06\xd3\xe2\x82\xa8\xd8\x4e\x0d\xe1\xde&#34; \ &#34;\x69\x74\xbf\x49\x54\x69\xfc\x7f\x33\x8f\x80\x54\xd5\x8c\x26\xc4&#34; \ &#34;\x93\x60\xc3\xe8\x7a\xf5\x65\x23\xac\xf6\xd8\x9d\x03\xe5\x6f\xf2&#34; \ &#34;\xf8\x68\x00\x2b\xc3\xe4\x31\xed\xc4\x4d\xf2\xf0\x22\x3d\x4b\xb3&#34; \ &#34;\xb2\x43\x58\x6e\x1a\x7d\x92\x49\x36\x69\x4f\xcb\xba\xf8\x8d\x95&#34; \ &#34;\x19\xe4\xeb\x50\xa6\x44\xf8\xe4\xf9\x5e\xb0\xea\x95\xbc\x44\x65&#34; \ &#34;\xc8\x82\x1a\xac\xd2\xfe\x15\xab\x49\x81\x16\x4b\xbb\x6d\xc3\x2f&#34; \ &#34;\x96\x90\x87\xa1\x45\xb0\xd9\xcc\x9c\x67\xc2\x2b\x76\x32\x99\x41&#34; \ &#34;\x9c\xc4\x12\x8b\xe9\xa0\x77\xb3\xac\xe6\x34\x06\x4e\x6d\x99\x28&#34; \ &#34;\x35\x13\xdc\x06\xe7\x51\x5d\x0d\x73\x13\x2e\x9a\x0d\xc6\xd3\xb1&#34; \ &#34;\xf8\xb2\x46\xf1\xa9\x8a\x3f\xc7\x29\x41\xb1\xe3\xbb\x20\x98\xe8&#34; \ &#34;\xbf\x16\xf2\x68\xd6\x4f\x0b\x0f\x47\x07\xfe\x1e\xa1\xa1\x79\x1b&#34; \ &#34;\xa2\xf3\xc0\xc7\x58\xe5\xf5\x51\x86\x3a\x96\xc9\x49\xad\x47\xd7&#34; \ &#34;\xfb\x40\xd2&#34; #define SHA1_SEED &#34;\xd0\x56\x9c\xb3\x66\x5a\x8a\x43\xeb\x6e\xa2\x3d&#34; \ &#34;\x75\xa3\xc4\xd2\x05\x4a\x0d\x7d&#34; #define SHA224_SEED &#34;\xd0\x56\x9c\xb3\x66\x5a\x8a\x43\xeb\x6e\xa2&#34; \ &#34;\x3d\x75\xa3\xc4\xd2\x05\x4a\x0d\x7d\x66\xa9\xca\x99\xc9\xce\xb0&#34; \ &#34;\x27&#34; #define SHA256_SEED &#34;\xf4\x1e\xce\x26\x13\xe4\x57\x39\x15\x69\x6b&#34; \ &#34;\x5a\xdc\xd5\x1c\xa3\x28\xbe\x3b\xf5\x66\xa9\xca\x99\xc9\xce\xb0&#34; \ &#34;\x27\x9c\x1c\xb0\xa7&#34; #define SHA384_SEED &#34;\x82\x40\xbc\x51\xe4\xec\x7e\xf7\x6d\x18\xe3&#34; \ &#34;\x52\x04\xa1\x9f\x51\xa5\x21\x3a\x73\xa8\x1d\x6f\x94\x46\x80\xd3&#34; \ &#34;\x07\x59\x48\xb7\xe4\x63\x80\x4e\xa3\xd2\x6e\x13\xea\x82\x0d\x65&#34; \ &#34;\xa4\x84\xbe\x74\x53&#34; #define SHA512_SEED &#34;\x47\x3f\xf1\xb9\xb3\xff\xdf\xa1\x26\x69\x9a&#34; \ &#34;\xc7\xef\x9e\x8e\x78\x77\x73\x09\x58\x24\xc6\x42\x55\x7c\x13\x99&#34; \ &#34;\xd9\x8e\x42\x20\x44\x8d\xc3\x5b\x99\xbf\xdd\x44\x77\x95\x43\x92&#34; \ &#34;\x4c\x1c\xe9\x3b\xc5\x94\x15\x38\x89\x5d\xb9\x88\x26\x1b\x00\x77&#34; \ &#34;\x4b\x12\x27\x20\x39&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define TEST7_512 \ &#34;\ X08 \ XEC \ XB5 \ x2e \ XBA \ XE1 \ XF7 \ X42 \ x2d \ XB6 \ X2B \ XCD \ X54 \ X26 \ X70&#34; の#define TEST8_512 \「\ x8d \ x4e \ X3C \ \ x0e X38 \ x89 \ X19 \ X14 \ X91 \ X81 \ x6e \ x9d \ x98 \ XBF \ XF0 \ XA0 &#34;の#define TEST9_512 \&#34; \ X3A \ XDD \ XEC \ X85 \ X59 \ x32の\ x16の\ XD1 \ X61 \ x9a \ XA0 \ x2d \ X97 \ X56 \ X97 \ X0B &#34;\&#34; \ XFC \ X70 \ XAC \ XE2 \ X74 \ x4f \ x7c \ X6B \ X27 \ X88 \ X15 \ X10 \ X28 \ XF7 \ XB6 \ XA2 &#34;\&#34; \ X55 \ x0f \ XD7 \ X4A \ x7e \ x6e \ X69 \ XC2 \ xc9 \ XB4 \ x5f \ XC4 \ X54 \ X96 \ x6dは\ XC3 &#34;\&#34; \ X1D \ x2e \ X10 \ XDA \ X1F \ X95 \ XCE \ X02 \ xbe \ XB4 \ XBF \のx87 \ X65 \ X57 \ x4c \ XBD &#34;\&#34; \ x6e \ X83 \ X37 \のXeF \ X42 \ X0A \ XDC \ x98 \ XC1 \ x5c \ XB6 \ XD5 \ xe4 \ XA0 \ X24 \ X1B &#34;\&#34; \ XA0 \ X04 \ x6dは\ X25 \ x0e \ X51 \ X02 \ X31 \ XCA \ XC2 \ X04 \ x6c \ X99 \ X16 \ X06 \測定 &#34;\&#34; \ x4e \ xe4 \ X14 \ X5Bニッケル\ \ x2f \ XF4 \ XBB \ X12 \ X3A \測定\ X49 \ x8d \ x9d \ X44 \ X79 &#34;\&#34; \ x4f \ X99 \ XCC \ XAD \ x89 \ xa9 \ XA1 \ X62 \ X12 \ X59 \ XED \ xa7 \ X0A \ X5B \ x6dは\ XD4 &#34;\&#34; \ XBD \ xd8 \ X77 \ x78 \ xc9 \ X04 \ X3B \ X93 \ X84 \ XF5 \ X49 \ X06 &#34;の#define TEST10_512 \&#34; \ xa5 \ x5f \ X20 \ XC4 \ x11の\ \ XD1 \ x32の\ X80 \ X7A \ X50 \ x2d \ X65 \ X82 \ x4e \ X31 &#34;\&#34; \ XA2 \ X30 \ X54 \ x32の\お送り\ X3D \ X06 \ XD3 \ XE2 \ X82 \ xa8 \ xd8 \ x4e送ります\ x0d \ XE1 XDE \ &#34;\&#34; \ X69 \ X74 \ XBF \ X49 \ X54 \ X69 \ XFC \ x7f \ X33 \ x8f \ X80 \ X5 4 \ XD5 \ x8c \ X26 \ XC4 &#34;\&#34; \ X93 \ X60 \ XC3 \ xe8 \ X7A \ XF5 \ X65 \ X23 \ XAC \ XF6 \ xd8 \ x9d \ X03 \ xe5 \ x6f \ XF2 &#34;\&#34; \ XF8 \ X68 \ X00 \ X2B \ XC3 \ xe4 \ X31 \ XED \ XC4 \ x4d \ XF2 \ XF0 \ X22 \ X3D \ x4b \ XB3 &#34;\&#34; \ XB2 \ X43 \ X58 \ x6e \ X1A \ x7d \ X92 \ X49 \ x36の\ X69 \ x4f \ XCB \ XBA \ XF8 \ x8d \ X95 &#34;\&#34; \ X19 \錆xe4 \ \ X50 \ xa6 \ X44 \ XF8 \ xe4 \ xf9 \ x5e \ XB0 \ XEA \ X95 \ XBC \ X44 \ X65」 \ &#34;\ xc8 \ X82 \ X1A \ XAC \ XD2 \ XFE \ X15 \測定\ X49 \ X81 \ X16 \ x4b \ XBB \ x6dは\ XC3 \ x2f&#34; \「\ X96 \ X90 \のx87 \ XA1 \ X45 \ XB0 \ XD9 \ XCC \ x9c \ X67 \ XC2 \ X2B \ X76 \ x32の\ X99 \ X41 &#34;\&#34; \ x9c \ XC4 \ X12 \ x8b \ XE9 \ XA0 \ X77 \ XB3 \ XAC \ XE6 \ X34 \ X06 \ x4e \ x6dは\ X99 \ X28 &#34;\&#34; \ X35 \ X13 \ XDC \ X06 \ XE7 \ X51 \ x5d \ x0d \ X73 \ X13 \ x2e \ x9a \ x0d \ xc6 \ XD3 \ XB1 &#34;\&#34; \ XF8 \ XB2 \ X46 \ XF1 \ xa9 \ x8a \ X3F \ xc7 \ X29 \ X41 \ XB1 \ XE3 \ XBB \ X20 \ x98 \ xe8 &#34;\&#34; \ XBF \ X16 \ XF2 \ X68 \ XD6 \ x4f \ X0B \ x0f \ X47 \ X07 \ XFE \ X1E \ XA1 \ XA1 \ X79 \ X1B &#34;\&#34; \ XA2 \ XF3 \ XC0 \ xc7 \ X58 \ xe5 \ XF5 \ X51 \ X86 \ X3A \ X96 \ xc9 \ X49 \ XAD \ X47 \ XD7 &#34;\&#34; \ XFB \ X40 \ XD2 &#34;の#define SHA1_SEED&#34; \ XD0 \ X56 \ x9c \ XB3 \ X66 \ X5A \ x8a \ X43 \腐食\ x6e \ XA2 \ X3D &#34;\&#34; \ X75 \ XA3 \ XC4 \ XD2 \ X05 \ X4A \ x0d \ x7d &#34;の#define SHA224_SEED&#34; \ XD0 \ X56 \ x9c \ XB3 \ X66 \ X5A \ x8a \ X43 \腐食\ x6eの\のXA2 &#34;\&#34; \ X3D \ X75 \ XA3 \ XC4 \ XD2 \ X05 \ X4A \ x0d \ x7d \ X66 \ xa9 \ XCA \ X99 \ xc9 \ XCE \ XB0 &#34;\&#34; \のX27 &#34;の#define SHA256_SEED&#34; \ XF4 \ X1E \ XCE \ X26 \ X13 \ xe4 \ X57 \ X39 \ X15 \ X69 \ X6B &#34; \ &#34;\ X5A \ XDC \ XD5 \ X1C \ XA3 \ X28 \ xbe \ X3B \ XF5 \ X66 \ xa9 \ XCA \ X99 \ xc9 \ XCE \ XB0&#34; \ &#34;\ X27 \ x9c \ X1C \ XB0 xa7 \&#34; の#define SHA3​​84_SEED &#34;\ X82 \ X40 \ XBC \ X51 \ xe4 \ XEC \ x7e \ XF7 \ x6dは\ X18 \ XE3&#34; \「\ X52 \ X04 \ XA1 \ x9f \ X51 \ xa5 \ X21 \ X3A \ X73 \ xa8 \ X1D \ x6f \ X94 \ X46 \ X80 \ XD3 &#34;\&#34; \ X07 \ X59 \ X48 \ xb7 \ xe4 \ X63 \ X80 \ x4e \ XA3 \ XD2 \ x6e \ X13 \ XEA \ X82 \ x0d \ X65 &#34;\&#34; \ XA4 \ X84 \ xbe \ X74 \ X53 &#34;の#define SHA512_SEED&#34; \ X47 \ X3F \ XF1 \ xb9 \ XB3 \ XFF \ XDF \ XA1 \ X26 \ X69 \ x9a &#34;\&#34; \ xc7 \のXeF \ x9e \ X8E \ x78 \ X77 \ X73 \ x09の\ X58 \ X24 \ xc6 \ X42 \ X55 \ x7c \ X13 \ X99 &#34;\&#34; \ XD9 \ X8E \ X42 \ X20 \ X44 \ x8d \ XC3 \ X5B \ X99 \ XBF \ XDD \ X44 \ X77 \ X95 \ X43 \ X92 &#34;\&#34; \ x4c \ X1C \ XE9 \ X3B \ XC5 \ X94 \ X15 \ X38 \ x89 \ x5d \ xb9 \ X88 \ X26 \ X1B \ X00 \ X77 &#34;\&#34; \ x4b X12 \ \ X27 \ X20 \ X39 &#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define TESTCOUNT 10 #define HASHCOUNT 5 #define RANDOMCOUNT 4 #define HMACTESTCOUNT 7 #define HKDFTESTCOUNT 7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define TESTCOUNT 10の#define HASHCOUNT 5の#define RANDOMCOUNT 4の#define HMACTESTCOUNT 7の#define HKDFTESTCOUNT 7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define PRINTNONE 0 #define PRINTTEXT 1 #define PRINTRAW 2 #define PRINTHEX 3 #define PRINTBASE64 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PRINTNONE 0の#defineの#defineの#define PRINTRAW PRINTTEXT 1 2 3の#defineの#define PRINTBASE64 PRINTHEX 4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define PRINTPASSFAIL 1 #define PRINTFAIL 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define PRINTPASSFAIL 1の#define PRINTFAIL 2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define length(x) (sizeof(x)-1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define長さ（X）（はsizeof（x）-1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Test arrays for hashes. */
struct hash {
    const char *name;
    SHAversion whichSha;
    int hashsize;
    struct {
        const char *testarray;
        int length;
        long repeatcount;
        int extrabits;
        int numberExtrabits;
        const char *resultarray;
    } tests[TESTCOUNT];
    const char *randomtest;
    const char *randomresults[RANDOMCOUNT];
} hashes[HASHCOUNT] = {
  { &#34;SHA1&#34;, SHA1, SHA1HashSize,
    {
      /* 1 */ { TEST1, length(TEST1), 1, 0, 0,
        &#34;A9993E364706816ABA3E25717850C26C9CD0D89D&#34; },
      /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0,
        &#34;84983E441C3BD26EBAAE4AA1F95129E5E54670F1&#34; },
      /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,
        &#34;34AA973CD4C4DAA4F61EEB2BDBAD27316534016F&#34; },
      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,
        &#34;DEA356A2CDDD90C7A7ECEDC5EBB563934F460452&#34; },
      /* 5 */ { &#34;&#34;, 0, 0, 0x98, 5,
        &#34;29826B003B906E660EFF4027CE98AF3531AC75BA&#34; },
      /* 6 */ { &#34;\x5e&#34;, 1, 1, 0, 0,
        &#34;5E6F80A34A9798CAFC6A5DB96CC57BA4C4DB59C2&#34; },
      /* 7 */ { TEST7_1, length(TEST7_1), 1, 0x80, 3,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        &#34;6239781E03729919C01955B3FFA8ACB60B988340&#34; },
      /* 8 */ { TEST8_1, length(TEST8_1), 1, 0, 0,
        &#34;82ABFF6605DBE1C17DEF12A394FA22A82B544A35&#34; },
      /* 9 */ { TEST9_1, length(TEST9_1), 1, 0xE0, 3,
        &#34;8C5B2A5DDAE5A97FC7F9D85661C672ADBF7933D4&#34; },
      /* 10 */ { TEST10_1, length(TEST10_1), 1, 0, 0,
        &#34;CB0082C8F197D260991BA6A460E76E202BAD27B3&#34; }
    }, SHA1_SEED, { &#34;E216836819477C7F78E0D843FE4FF1B6D6C14CD4&#34;,
        &#34;A2DBC7A5B1C6C0A8BCB7AAA41252A6A7D0690DBC&#34;,
        &#34;DB1F9050BB863DFEF4CE37186044E2EEB17EE013&#34;,
        &#34;127FDEDF43D372A51D5747C48FBFFE38EF6CDF7B&#34;
     } },
  { &#34;SHA224&#34;, SHA224, SHA224HashSize,
    {
      /* 1 */ { TEST1, length(TEST1), 1, 0, 0,
        &#34;23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7&#34; },
      /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0,
        &#34;75388B16512776CC5DBA5DA1FD890150B0C6455CB4F58B1952522525&#34; },
      /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,
        &#34;20794655980C91D8BBB4C1EA97618A4BF03F42581948B2EE4EE7AD67&#34; },
      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,
        &#34;567F69F168CD7844E65259CE658FE7AADFA25216E68ECA0EB7AB8262&#34; },
      /* 5 */ { &#34;&#34;, 0, 0, 0x68, 5,
        &#34;E3B048552C3C387BCAB37F6EB06BB79B96A4AEE5FF27F51531A9551C&#34; },
      /* 6 */ { &#34;\x07&#34;, 1, 1, 0, 0,
        &#34;00ECD5F138422B8AD74C9799FD826C531BAD2FCABC7450BEE2AA8C2A&#34; },
      /* 7 */ { TEST7_224, length(TEST7_224), 1, 0xA0, 3,
        &#34;1B01DB6CB4A9E43DED1516BEB3DB0B87B6D1EA43187462C608137150&#34; },
      /* 8 */ { TEST8_224, length(TEST8_224), 1, 0, 0,
        &#34;DF90D78AA78821C99B40BA4C966921ACCD8FFB1E98AC388E56191DB1&#34; },
      /* 9 */ { TEST9_224, length(TEST9_224), 1, 0xE0, 3,
        &#34;54BEA6EAB8195A2EB0A7906A4B4A876666300EEFBD1F3B8474F9CD57&#34; },
      /* 10 */ { TEST10_224, length(TEST10_224), 1, 0, 0,
        &#34;0B31894EC8937AD9B91BDFBCBA294D9ADEFAA18E09305E9F20D5C3A4&#34; }
    }, SHA224_SEED, { &#34;100966A5B4FDE0B42E2A6C5953D4D7F41BA7CF79FD&#34;
        &#34;2DF431416734BE&#34;, &#34;1DCA396B0C417715DEFAAE9641E10A2E99D55A&#34;
        &#34;BCB8A00061EB3BE8BD&#34;, &#34;1864E627BDB2319973CD5ED7D68DA71D8B&#34;
        &#34;F0F983D8D9AB32C34ADB34&#34;, &#34;A2406481FC1BCAF24DD08E6752E844&#34;
        &#34;709563FB916227FED598EB621F&#34;
     } },
  { &#34;SHA256&#34;, SHA256, SHA256HashSize,
  {
      /* 1 */ { TEST1, length(TEST1), 1, 0, 0, &#34;BA7816BF8F01CFEA4141&#34;
        &#34;40DE5DAE2223B00361A396177A9CB410FF61F20015AD&#34; },
      /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0, &#34;248D6A61D20638B8&#34;
        &#34;E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1&#34; },
      /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0, &#34;CDC76E5C9914FB92&#34;
        &#34;81A1C7E284D73E67F1809A48A497200E046D39CCC7112CD0&#34; },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* 4 */ { TEST4, length(TEST4), 10, 0, 0, &#34;594847328451BDFA&#34;
        &#34;85056225462CC1D867D877FB388DF0CE35F25AB5562BFBB5&#34; },
      /* 5 */ { &#34;&#34;, 0, 0, 0x68, 5, &#34;D6D3E02A31A84A8CAA9718ED6C2057BE&#34;
        &#34;09DB45E7823EB5079CE7A573A3760F95&#34; },
      /* 6 */ { &#34;\x19&#34;, 1, 1, 0, 0, &#34;68AA2E2EE5DFF96E3355E6C7EE373E3D&#34;
        &#34;6A4E17F75F9518D843709C0C9BC3E3D4&#34; },
      /* 7 */ { TEST7_256, length(TEST7_256), 1, 0x60, 3, &#34;77EC1DC8&#34;
        &#34;9C821FF2A1279089FA091B35B8CD960BCAF7DE01C6A7680756BEB972&#34; },
      /* 8 */ { TEST8_256, length(TEST8_256), 1, 0, 0, &#34;175EE69B02BA&#34;
        &#34;9B58E2B0A5FD13819CEA573F3940A94F825128CF4209BEABB4E8&#34; },
      /* 9 */ { TEST9_256, length(TEST9_256), 1, 0xA0, 3, &#34;3E9AD646&#34;
        &#34;8BBBAD2AC3C2CDC292E018BA5FD70B960CF1679777FCE708FDB066E9&#34; },
      /* 10 */ { TEST10_256, length(TEST10_256), 1, 0, 0, &#34;97DBCA7D&#34;
        &#34;F46D62C8A422C941DD7E835B8AD3361763F7E9B2D95F4F0DA6E1CCBC&#34; },
    }, SHA256_SEED, { &#34;83D28614D49C3ADC1D6FC05DB5F48037C056F8D2A4CE44&#34;
        &#34;EC6457DEA5DD797CD1&#34;, &#34;99DBE3127EF2E93DD9322D6A07909EB33B6399&#34;
        &#34;5E529B3F954B8581621BB74D39&#34;, &#34;8D4BE295BB64661CA3C7EFD129A2F7&#34;
        &#34;25B33072DBDDE32385B9A87B9AF88EA76F&#34;, &#34;40AF5D3F9716B040DF9408&#34;
        &#34;E31536B70FF906EC51B00447CA97D7DD97C12411F4&#34;
    } },
  { &#34;SHA384&#34;, SHA384, SHA384HashSize,
    {
      /* 1 */ { TEST1, length(TEST1), 1, 0, 0,
        &#34;CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED163&#34;
        &#34;1A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7&#34; },
      /* 2 */ { TEST2_2, length(TEST2_2), 1, 0, 0,
        &#34;09330C33F71147E83D192FC782CD1B4753111B173B3B05D2&#34;
        &#34;2FA08086E3B0F712FCC7C71A557E2DB966C3E9FA91746039&#34; },
      /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,
        &#34;9D0E1809716474CB086E834E310A4A1CED149E9C00F24852&#34;
        &#34;7972CEC5704C2A5B07B8B3DC38ECC4EBAE97DDD87F3D8985&#34; },
      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,
        &#34;2FC64A4F500DDB6828F6A3430B8DD72A368EB7F3A8322A70&#34;
        &#34;BC84275B9C0B3AB00D27A5CC3C2D224AA6B61A0D79FB4596&#34; },
      /* 5 */ { &#34;&#34;, 0, 0, 0x10, 5,
        &#34;8D17BE79E32B6718E07D8A603EB84BA0478F7FCFD1BB9399&#34;
        &#34;5F7D1149E09143AC1FFCFC56820E469F3878D957A15A3FE4&#34; },
      /* 6 */ { &#34;\xb9&#34;, 1, 1, 0, 0,
        &#34;BC8089A19007C0B14195F4ECC74094FEC64F01F90929282C&#34;
        &#34;2FB392881578208AD466828B1C6C283D2722CF0AD1AB6938&#34; },
      /* 7 */ { TEST7_384, length(TEST7_384), 1, 0xA0, 3,
        &#34;D8C43B38E12E7C42A7C9B810299FD6A770BEF30920F17532&#34;
        &#34;A898DE62C7A07E4293449C0B5FA70109F0783211CFC4BCE3&#34; },
      /* 8 */ { TEST8_384, length(TEST8_384), 1, 0, 0,
        &#34;C9A68443A005812256B8EC76B00516F0DBB74FAB26D66591&#34;
        &#34;3F194B6FFB0E91EA9967566B58109CBC675CC208E4C823F7&#34; },
      /* 9 */ { TEST9_384, length(TEST9_384), 1, 0xE0, 3,
        &#34;5860E8DE91C21578BB4174D227898A98E0B45C4C760F0095&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        &#34;49495614DAEDC0775D92D11D9F8CE9B064EEAC8DAFC3A297&#34; },
      /* 10 */ { TEST10_384, length(TEST10_384), 1, 0, 0,
        &#34;4F440DB1E6EDD2899FA335F09515AA025EE177A79F4B4AAF&#34;
        &#34;38E42B5C4DE660F5DE8FB2A5B2FBD2A3CBFFD20CFF1288C0&#34; }
    }, SHA384_SEED, { &#34;CE44D7D63AE0C91482998CF662A51EC80BF6FC68661A3C&#34;
        &#34;57F87566112BD635A743EA904DEB7D7A42AC808CABE697F38F&#34;, &#34;F9C6D2&#34;
        &#34;61881FEE41ACD39E67AA8D0BAD507C7363EB67E2B81F45759F9C0FD7B503&#34;
        &#34;DF1A0B9E80BDE7BC333D75B804197D&#34;, &#34;D96512D8C9F4A7A4967A366C01&#34;
        &#34;C6FD97384225B58343A88264847C18E4EF8AB7AEE4765FFBC3E30BD485D3&#34;
        &#34;638A01418F&#34;, &#34;0CA76BD0813AF1509E170907A96005938BC985628290B2&#34;
        &#34;5FEF73CF6FAD68DDBA0AC8920C94E0541607B0915A7B4457F7&#34;
    } },
  { &#34;SHA512&#34;, SHA512, SHA512HashSize,
    {
      /* 1 */ { TEST1, length(TEST1), 1, 0, 0,
        &#34;DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA2&#34;
        &#34;0A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD&#34;
        &#34;454D4423643CE80E2A9AC94FA54CA49F&#34; },
      /* 2 */ { TEST2_2, length(TEST2_2), 1, 0, 0,
        &#34;8E959B75DAE313DA8CF4F72814FC143F8F7779C6EB9F7FA1&#34;
        &#34;7299AEADB6889018501D289E4900F7E4331B99DEC4B5433A&#34;
        &#34;C7D329EEB6DD26545E96E55B874BE909&#34; },
       /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,
        &#34;E718483D0CE769644E2E42C7BC15B4638E1F98B13B204428&#34;
        &#34;5632A803AFA973EBDE0FF244877EA60A4CB0432CE577C31B&#34;
        &#34;EB009C5C2C49AA2E4EADB217AD8CC09B&#34; },
      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,
        &#34;89D05BA632C699C31231DED4FFC127D5A894DAD412C0E024&#34;
        &#34;DB872D1ABD2BA8141A0F85072A9BE1E2AA04CF33C765CB51&#34;
        &#34;0813A39CD5A84C4ACAA64D3F3FB7BAE9&#34; },
      /* 5 */ { &#34;&#34;, 0, 0, 0xB0, 5,
        &#34;D4EE29A9E90985446B913CF1D1376C836F4BE2C1CF3CADA0&#34;
        &#34;720A6BF4857D886A7ECB3C4E4C0FA8C7F95214E41DC1B0D2&#34;
        &#34;1B22A84CC03BF8CE4845F34DD5BDBAD4&#34; },
      /* 6 */ { &#34;\xD0&#34;, 1, 1, 0, 0,
        &#34;9992202938E882E73E20F6B69E68A0A7149090423D93C81B&#34;
        &#34;AB3F21678D4ACEEEE50E4E8CAFADA4C85A54EA8306826C4A&#34;
        &#34;D6E74CECE9631BFA8A549B4AB3FBBA15&#34; },
      /* 7 */ { TEST7_512, length(TEST7_512), 1, 0x80, 3,
        &#34;ED8DC78E8B01B69750053DBB7A0A9EDA0FB9E9D292B1ED71&#34;
        &#34;5E80A7FE290A4E16664FD913E85854400C5AF05E6DAD316B&#34;
        &#34;7359B43E64F8BEC3C1F237119986BBB6&#34; },
      /* 8 */ { TEST8_512, length(TEST8_512), 1, 0, 0,
        &#34;CB0B67A4B8712CD73C9AABC0B199E9269B20844AFB75ACBD&#34;
        &#34;D1C153C9828924C3DDEDAAFE669C5FDD0BC66F630F677398&#34;
        &#34;8213EB1B16F517AD0DE4B2F0C95C90F8&#34; },
      /* 9 */ { TEST9_512, length(TEST9_512), 1, 0x80, 3,
        &#34;32BA76FC30EAA0208AEB50FFB5AF1864FDBF17902A4DC0A6&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        &#34;82C61FCEA6D92B783267B21080301837F59DE79C6B337DB2&#34;
        &#34;526F8A0A510E5E53CAFED4355FE7C2F1&#34; },
      /* 10 */ { TEST10_512, length(TEST10_512), 1, 0, 0,
        &#34;C665BEFB36DA189D78822D10528CBF3B12B3EEF726039909&#34;
        &#34;C1A16A270D48719377966B957A878E720584779A62825C18&#34;
        &#34;DA26415E49A7176A894E7510FD1451F5&#34; }
    }, SHA512_SEED, { &#34;2FBB1E7E00F746BA514FBC8C421F36792EC0E11FF5EFC3&#34;
        &#34;78E1AB0C079AA5F0F66A1E3EDBAEB4F9984BE14437123038A452004A5576&#34;
        &#34;8C1FD8EED49E4A21BEDCD0&#34;, &#34;25CBE5A4F2C7B1D7EF07011705D50C62C5&#34;
        &#34;000594243EAFD1241FC9F3D22B58184AE2FEE38E171CF8129E29459C9BC2&#34;
        &#34;EF461AF5708887315F15419D8D17FE7949&#34;, &#34;5B8B1F2687555CE2D7182B&#34;
        &#34;92E5C3F6C36547DA1C13DBB9EA4F73EA4CBBAF89411527906D35B1B06C1B&#34;
        &#34;6A8007D05EC66DF0A406066829EAB618BDE3976515AAFC&#34;, &#34;46E36B007D&#34;
        &#34;19876CDB0B29AD074FE3C08CDD174D42169D6ABE5A1414B6E79707DF5877&#34;
        &#34;6A98091CF431854147BB6D3C66D43BFBC108FD715BDE6AA127C2B0E79F&#34;
    }
  }
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Test arrays for HMAC. */
struct hmachash {
    const char *keyarray[5];
    int keylength[5];
    const char *dataarray[5];
    int datalength[5];
    const char *resultarray[5];
    int resultlength[5];
} hmachashes[HMACTESTCOUNT] = {
  { /* 1 */ {
      &#34;\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#34;
      &#34;\x0b\x0b\x0b\x0b\x0b&#34;
    }, { 20 }, {
      &#34;\x48\x69\x20\x54\x68\x65\x72\x65&#34; /* &#34;Hi There&#34; */
    }, { 8 }, {
      /* HMAC-SHA-1 */
      &#34;B617318655057264E28BC0B6FB378C8EF146BE00&#34;,
      /* HMAC-SHA-224 */
      &#34;896FB1128ABBDF196832107CD49DF33F47B4B1169912BA4F53684B22&#34;,
      /* HMAC-SHA-256 */
      &#34;B0344C61D8DB38535CA8AFCEAF0BF12B881DC200C9833DA726E9376C2E32&#34;
      &#34;CFF7&#34;,
      /* HMAC-SHA-384 */
      &#34;AFD03944D84895626B0825F4AB46907F15F9DADBE4101EC682AA034C7CEB&#34;
      &#34;C59CFAEA9EA9076EDE7F4AF152E8B2FA9CB6&#34;,
      /* HMAC-SHA-512 */
      &#34;87AA7CDEA5EF619D4FF0B4241A1D6CB02379F4E2CE4EC2787AD0B30545E1&#34;
      &#34;7CDEDAA833B7D6B8A702038B274EAEA3F4E4BE9D914EEB61F1702E696C20&#34;
      &#34;3A126854&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,
      SHA384HashSize, SHA512HashSize }
  },
  { /* 2 */ {
      &#34;\x4a\x65\x66\x65&#34; /* &#34;Jefe&#34; */
    }, { 4 }, {
      &#34;\x77\x68\x61\x74\x20\x64\x6f\x20\x79\x61\x20\x77\x61\x6e\x74&#34;
      &#34;\x20\x66\x6f\x72\x20\x6e\x6f\x74\x68\x69\x6e\x67\x3f&#34;
      /* &#34;what do ya want for nothing?&#34; */
    }, { 28 }, {
      /* HMAC-SHA-1 */
      &#34;EFFCDF6AE5EB2FA2D27416D5F184DF9C259A7C79&#34;,
      /* HMAC-SHA-224 */
      &#34;A30E01098BC6DBBF45690F3A7E9E6D0F8BBEA2A39E6148008FD05E44&#34;,
      /* HMAC-SHA-256 */
      &#34;5BDCC146BF60754E6A042426089575C75A003F089D2739839DEC58B964EC&#34;
      &#34;3843&#34;,
      /* HMAC-SHA-384 */
      &#34;AF45D2E376484031617F78D2B58A6B1B9C7EF464F5A01B47E42EC3736322&#34;
      &#34;445E8E2240CA5E69E2C78B3239ECFAB21649&#34;,
      /* HMAC-SHA-512 */
      &#34;164B7A7BFCF819E2E395FBE73B56E0A387BD64222E831FD610270CD7EA25&#34;
      &#34;05549758BF75C05A994A6D034F65F8F0E6FDCAEAB1A34D4A6B4B636E070A&#34;
      &#34;38BCE737&#34;
    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,
      SHA384HashSize, SHA512HashSize }
  },
  { /* 3 */
    {
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa&#34;
    }, { 20 }, {
      &#34;\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd&#34;
      &#34;\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd&#34;
      &#34;\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd&#34;
      &#34;\xdd\xdd\xdd\xdd\xdd&#34;
    }, { 50 }, {
      /* HMAC-SHA-1 */
      &#34;125D7342B9AC11CD91A39AF48AA17B4F63F175D3&#34;,
      /* HMAC-SHA-224 */
      &#34;7FB3CB3588C6C1F6FFA9694D7D6AD2649365B0C1F65D69D1EC8333EA&#34;,
      /* HMAC-SHA-256 */
      &#34;773EA91E36800E46854DB8EBD09181A72959098B3EF8C122D9635514CED5&#34;
      &#34;65FE&#34;,
      /* HMAC-SHA-384 */
      &#34;88062608D3E6AD8A0AA2ACE014C8A86F0AA635D947AC9FEBE83EF4E55966&#34;
      &#34;144B2A5AB39DC13814B94E3AB6E101A34F27&#34;,
      /* HMAC-SHA-512 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &#34;FA73B0089D56A284EFB0F0756C890BE9B1B5DBDD8EE81A3655F83E33B227&#34;
      &#34;9D39BF3E848279A722C806B485A47E67C807B946A337BEE8942674278859&#34;
      &#34;E13292FB&#34;
    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,
      SHA384HashSize, SHA512HashSize }
  },
  { /* 4 */ {
      &#34;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f&#34;
      &#34;\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19&#34;
    }, { 25 }, {
      &#34;\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd&#34;
      &#34;\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd&#34;
      &#34;\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd\xcd&#34;
      &#34;\xcd\xcd\xcd\xcd\xcd&#34;
    }, { 50 }, {
      /* HMAC-SHA-1 */
      &#34;4C9007F4026250C6BC8414F9BF50C86C2D7235DA&#34;,
      /* HMAC-SHA-224 */
      &#34;6C11506874013CAC6A2ABC1BB382627CEC6A90D86EFC012DE7AFEC5A&#34;,
      /* HMAC-SHA-256 */
      &#34;82558A389A443C0EA4CC819899F2083A85F0FAA3E578F8077A2E3FF46729&#34;
      &#34;665B&#34;,
      /* HMAC-SHA-384 */
      &#34;3E8A69B7783C25851933AB6290AF6CA77A9981480850009CC5577C6E1F57&#34;
      &#34;3B4E6801DD23C4A7D679CCF8A386C674CFFB&#34;,
      /* HMAC-SHA-512 */
      &#34;B0BA465637458C6990E5A8C5F61D4AF7E576D97FF94B872DE76F8050361E&#34;
      &#34;E3DBA91CA5C11AA25EB4D679275CC5788063A5F19741120C4F2DE2ADEBEB&#34;
      &#34;10A298DD&#34;
    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,
      SHA384HashSize, SHA512HashSize }
  },
  { /* 5 */ {
      &#34;\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c&#34;
      &#34;\x0c\x0c\x0c\x0c\x0c&#34;
    }, { 20 }, {
      &#34;Test With Truncation&#34;
    }, { 20 }, {
      /* HMAC-SHA-1 */
      &#34;4C1A03424B55E07FE7F27BE1&#34;,
      /* HMAC-SHA-224 */
      &#34;0E2AEA68A90C8D37C988BCDB9FCA6FA8&#34;,
      /* HMAC-SHA-256 */
      &#34;A3B6167473100EE06E0C796C2955552B&#34;,
      /* HMAC-SHA-384 */
      &#34;3ABF34C3503B2A23A46EFC619BAEF897&#34;,
      /* HMAC-SHA-512 */
      &#34;415FAD6271580A531D4179BC891D87A6&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    }, { 12, 16, 16, 16, 16 }
  },
  { /* 6 */ {
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
    }, { 80, 131 }, {
      &#34;Test Using Larger Than Block-Size Key - Hash Key First&#34;
    }, { 54 }, {
      /* HMAC-SHA-1 */
      &#34;AA4AE5E15272D00E95705637CE8A3B55ED402112&#34;,
      /* HMAC-SHA-224 */
      &#34;95E9A0DB962095ADAEBE9B2D6F0DBCE2D499F112F2D2B7273FA6870E&#34;,
      /* HMAC-SHA-256 */
      &#34;60E431591EE0B67F0D8A26AACBF5B77F8E0BC6213728C5140546040F0EE3&#34;
      &#34;7F54&#34;,
      /* HMAC-SHA-384 */
      &#34;4ECE084485813E9088D2C63A041BC5B44F9EF1012A2B588F3CD11F05033A&#34;
      &#34;C4C60C2EF6AB4030FE8296248DF163F44952&#34;,
      /* HMAC-SHA-512 */
      &#34;80B24263C7C1A3EBB71493C1DD7BE8B49B46D1F41B4AEEC1121B013783F8&#34;
      &#34;F3526B56D037E05F2598BD0FD2215D6A1E5295E64F73F63F0AEC8B915A98&#34;
      &#34;5D786598&#34;
    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,
      SHA384HashSize, SHA512HashSize }
  },
  { /* 7 */ {
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
      &#34;\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa&#34;
    }, { 80, 131 }, {
      &#34;Test Using Larger Than Block-Size Key and &#34;
      &#34;Larger Than One Block-Size Data&#34;,
      &#34;\x54\x68\x69\x73\x20\x69\x73\x20\x61\x20\x74\x65\x73\x74\x20&#34;
      &#34;\x75\x73\x69\x6e\x67\x20\x61\x20\x6c\x61\x72\x67\x65\x72\x20&#34;
      &#34;\x74\x68\x61\x6e\x20\x62\x6c\x6f\x63\x6b\x2d\x73\x69\x7a\x65&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      &#34;\x20\x6b\x65\x79\x20\x61\x6e\x64\x20\x61\x20\x6c\x61\x72\x67&#34;
      &#34;\x65\x72\x20\x74\x68\x61\x6e\x20\x62\x6c\x6f\x63\x6b\x2d\x73&#34;
      &#34;\x69\x7a\x65\x20\x64\x61\x74\x61\x2e\x20\x54\x68\x65\x20\x6b&#34;
      &#34;\x65\x79\x20\x6e\x65\x65\x64\x73\x20\x74\x6f\x20\x62\x65\x20&#34;
      &#34;\x68\x61\x73\x68\x65\x64\x20\x62\x65\x66\x6f\x72\x65\x20\x62&#34;
      &#34;\x65\x69\x6e\x67\x20\x75\x73\x65\x64\x20\x62\x79\x20\x74\x68&#34;
      &#34;\x65\x20\x48\x4d\x41\x43\x20\x61\x6c\x67\x6f\x72\x69\x74\x68&#34;
      &#34;\x6d\x2e&#34;
      /* &#34;This is a test using a larger than block-size key and a &#34;
          &#34;larger than block-size data.  The key needs to be hashed &#34;
          &#34;before being used by the HMAC algorithm.&#34; */
    }, { 73, 152 }, {
      /* HMAC-SHA-1 */
      &#34;E8E99D0F45237D786D6BBAA7965C7808BBFF1A91&#34;,
      /* HMAC-SHA-224 */
      &#34;3A854166AC5D9F023F54D517D0B39DBD946770DB9C2B95C9F6F565D1&#34;,
      /* HMAC-SHA-256 */
      &#34;9B09FFA71B942FCB27635FBCD5B0E944BFDC63644F0713938A7F51535C3A&#34;
      &#34;35E2&#34;,
      /* HMAC-SHA-384 */
      &#34;6617178E941F020D351E2F254E8FD32C602420FEB0B8FB9ADCCEBB82461E&#34;
      &#34;99C5A678CC31E799176D3860E6110C46523E&#34;,
      /* HMAC-SHA-512 */
      &#34;E37B6A775DC87DBAA4DFA9F96E5E3FFDDEBD71F8867289865DF5A32D20CD&#34;
      &#34;C944B6022CAC3C4982B10D5EEB55C3E4DE15134676FB6DE0446065C97440&#34;
      &#34;FA8C6A58&#34;
    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,
      SHA384HashSize, SHA512HashSize }
  }
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* Test arrays for HKDF. */
struct hkdfhash {
    SHAversion whichSha;
    int ikmlength;
    const char *ikmarray;
    int saltlength;
    const char *saltarray;
    int infolength;
    const char *infoarray;
    int prklength;
    const char *prkarray;
    int okmlength;
    const char *okmarray;
} hkdfhashes[HKDFTESTCOUNT] = {
    {   /* RFC 5869 A.1. Test Case 1 */
        SHA256,
        22, &#34;\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            &#34;\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#34;,
        13, &#34;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c&#34;,
        10, &#34;\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9&#34;,
        32, &#34;077709362C2E32DF0DDC3F0DC47BBA6390B6C73BB50F9C3122EC844A&#34;
            &#34;D7C2B3E5&#34;,
        42, &#34;3CB25F25FAACD57A90434F64D0362F2A2D2D0A90CF1A5A4C5DB02D56&#34;
            &#34;ECC4C5BF34007208D5B887185865&#34;
    },
    {   /* RFC 5869 A.2. Test Case 2 */
        SHA256,
        80, &#34;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d&#34;
            &#34;\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b&#34;
            &#34;\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29&#34;
            &#34;\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37&#34;
            &#34;\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45&#34;
            &#34;\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f&#34;,
        80, &#34;\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d&#34;
            &#34;\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b&#34;
            &#34;\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89&#34;
            &#34;\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97&#34;
            &#34;\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5&#34;
            &#34;\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf&#34;,
        80, &#34;\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd&#34;
            &#34;\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb&#34;
            &#34;\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9&#34;
            &#34;\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7&#34;
            &#34;\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5&#34;
            &#34;\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&#34;,
        32, &#34;06A6B88C5853361A06104C9CEB35B45C&#34;
            &#34;EF760014904671014A193F40C15FC244&#34;,
        82, &#34;B11E398DC80327A1C8E7F78C596A4934&#34;
            &#34;4F012EDA2D4EFAD8A050CC4C19AFA97C&#34;
            &#34;59045A99CAC7827271CB41C65E590E09&#34;
            &#34;DA3275600C2F09B8367793A9ACA3DB71&#34;
            &#34;CC30C58179EC3E87C14C01D5C1F3434F&#34;
            &#34;1D87&#34;
    },
    {   /* RFC 5869 A.3. Test Case 3 */
        SHA256,
        22, &#34;\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#34;
            &#34;\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#34;,
        0, &#34;&#34;,
        0, &#34;&#34;,
        32, &#34;19EF24A32C717B167F33A91D6F648BDF&#34;
            &#34;96596776AFDB6377AC434C1C293CCB04&#34;,
        42, &#34;8DA4E775A563C18F715F802A063C5A31&#34;
            &#34;B8A11F5C5EE1879EC3454E5F3C738D2D&#34;
            &#34;9D201395FAA4B61A96C8&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    },
    {   /* RFC 5869 A.4. Test Case 4 */
        SHA1,
        11, &#34;\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#34;,
        13, &#34;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c&#34;,
        10, &#34;\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9&#34;,
        20, &#34;9B6C18C432A7BF8F0E71C8EB88F4B30BAA2BA243&#34;,
        42, &#34;085A01EA1B10F36933068B56EFA5AD81&#34;
            &#34;A4F14B822F5B091568A9CDD4F155FDA2&#34;
            &#34;C22E422478D305F3F896&#34;
    },
    {   /* RFC 5869 A.5. Test Case 5 */
        SHA1,
        80, &#34;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d&#34;
            &#34;\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b&#34;
            &#34;\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29&#34;
            &#34;\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37&#34;
            &#34;\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45&#34;
            &#34;\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f&#34;,
        80, &#34;\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D&#34;
            &#34;\x6E\x6F\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x7B&#34;
            &#34;\x7C\x7D\x7E\x7F\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89&#34;
            &#34;\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97&#34;
            &#34;\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5&#34;
            &#34;\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF&#34;,
        80, &#34;\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD&#34;
            &#34;\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB&#34;
            &#34;\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9&#34;
            &#34;\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7&#34;
            &#34;\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5&#34;
            &#34;\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF&#34;,
        20, &#34;8ADAE09A2A307059478D309B26C4115A224CFAF6&#34;,
        82, &#34;0BD770A74D1160F7C9F12CD5912A06EB&#34;
            &#34;FF6ADCAE899D92191FE4305673BA2FFE&#34;
            &#34;8FA3F1A4E5AD79F3F334B3B202B2173C&#34;
            &#34;486EA37CE3D397ED034C7F9DFEB15C5E&#34;
            &#34;927336D0441F4C4300E2CFF0D0900B52&#34;
            &#34;D3B4&#34;
    },
    {   /* RFC 5869 A.6. Test Case 6 */
        SHA1,
        22, &#34;\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#34;
            &#34;\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#34;,
        0, &#34;&#34;,
        0, &#34;&#34;,
        20, &#34;DA8C8A73C7FA77288EC6F5E7C297786AA0D32D01&#34;,
        42, &#34;0AC1AF7002B3D761D1E55298DA9D0506&#34;
            &#34;B9AE52057220A306E07B6B87E8DF21D0&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            &#34;EA00033DE03984D34918&#34;
    },
    {   /* RFC 5869 A.7. Test Case 7. */
        SHA1,
        22, &#34;\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c&#34;
            &#34;\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c&#34;,
        0, 0,
        0, &#34;&#34;,
        20, &#34;2ADCCADA18779E7C2077AD2EB19D3F3E731385DD&#34;,
        42, &#34;2C91117204D745F3500D636A62F64F0A&#34;
            &#34;B3BAE548AA53D423B0D1F27EBBA6F5E5&#34;
            &#34;673A081D70CCE7ACFC48&#34;
    }
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Check the hash value against the expected string, expressed in hex
 */
static const char hexdigits[ ] = &#34;0123456789ABCDEF&#34;;
int checkmatch(const unsigned char *hashvalue,
  const char *hexstr, int hashsize)
{
  int i;
  for (i = 0; i &lt; hashsize; ++i) {
    if (*hexstr++ != hexdigits[(hashvalue[i] &gt;&gt; 4) &amp; 0xF])
      return 0;
    if (*hexstr++ != hexdigits[hashvalue[i] &amp; 0xF]) return 0;
  }
  return 1;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Print the string, converting non-printable characters to &#34;.&#34;
 */
void printstr(const char *str, int len)
{
  for ( ; len-- &gt; 0; str++)
    putchar(isprint((unsigned char)*str) ? *str : &#39;.&#39;);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Print the string, converting all characters to hex &#34;## &#34;.
 */
void printxstr(const char *str, int len)
{
  char *sep = &#34;&#34;;
  for ( ; len-- &gt; 0; str++) {
    printf(&#34;%s%c%c&#34;, sep, hexdigits[(*str &gt;&gt; 4) &amp; 0xF],
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      hexdigits[*str &amp; 0xF]);
    sep = &#34; &#34;;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Print a usage message.
 */
void usage(const char *argv0)
{
  fprintf(stderr,
    &#34;Usage:\n&#34;
    &#34;Common options: [-h hash] [-w|-x|-6] [-H]\n&#34;
    &#34;Hash a string:\n&#34;
      &#34;\t%s [-S expectedresult] -s hashstr [-k key] &#34;
           &#34;[-i info -L okm-len]\n&#34;
    &#34;Hash a file:\n&#34;
      &#34;\t%s [-S expectedresult] -f file [-k key] &#34;
           &#34;[-i info -L okm-len]\n&#34;
    &#34;Hash a file, ignoring whitespace:\n&#34;
      &#34;\t%s [-S expectedresult] -F file [-k key] &#34;
           &#34;[-i info -L okm-len]\n&#34;
    &#34;Additional bits to add in: [-B bitcount -b bits]\n&#34;
    &#34;(If -k,-i&amp;-L are used, run HKDF-SHA###.\n&#34;
    &#34; If -k is used, but not -i&amp;-L, run HMAC-SHA###.\n&#34;
    &#34; Otherwise, run SHA###.)\n&#34;
    &#34;Standard tests:\n&#34;
      &#34;\t%s [-m | -d] [-l loopcount] [-t test#] [-e]\n&#34;
      &#34;\t\t[-r randomseed] [-R randomloop-count] &#34;
        &#34;[-p] [-P|-X]\n&#34;
    &#34;-h\thash to test: &#34;
      &#34;0|SHA1, 1|SHA224, 2|SHA256, 3|SHA384, 4|SHA512\n&#34;
    &#34;-m\tperform hmac standard tests\n&#34;
    &#34;-k\tkey for hmac test\n&#34;
    &#34;-d\tperform hkdf standard tests\n&#34;
    &#34;-t\ttest case to run, 1-10\n&#34;
    &#34;-l\thow many times to run the test\n&#34;
    &#34;-e\ttest error returns\n&#34;
    &#34;-p\tdo not print results\n&#34;
    &#34;-P\tdo not print PASSED/FAILED\n&#34;
    &#34;-X\tprint FAILED, but not PASSED\n&#34;
    &#34;-r\tseed for random test\n&#34;
    &#34;-R\thow many times to run random test\n&#34;
    &#34;-s\tstring to hash\n&#34;
    &#34;-S\texpected result of hashed string, in hex\n&#34;
    &#34;-w\toutput hash in raw format\n&#34;
    &#34;-x\toutput hash in hex format\n&#34;
    &#34;-6\toutput hash in base64 format\n&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    &#34;-B\t# extra bits to add in after string or file input\n&#34;
    &#34;-b\textra bits to add (high order bits of #, 0# or 0x#)\n&#34;
    &#34;-H\tinput hashstr or randomseed is in hex\n&#34;
    , argv0, argv0, argv0, argv0);
  exit(1);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Print the results and PASS/FAIL.
 */
void printResult(uint8_t *Message_Digest, int hashsize,
    const char *hashname, const char *testtype, const char *testname,
    const char *resultarray, int printResults, int printPassFail)
{
  int i, k;
  if (printResults == PRINTTEXT) {
    printf(&#34;\nhashsize=%d\n&#34;, hashsize);
    putchar(&#39;\t&#39;);
    for (i = 0; i &lt; hashsize; ++i) {
      putchar(hexdigits[(Message_Digest[i] &gt;&gt; 4) &amp; 0xF]);
      putchar(hexdigits[Message_Digest[i] &amp; 0xF]);
      putchar(&#39; &#39;);
    }
    putchar(&#39;\n&#39;);
  } else if (printResults == PRINTRAW) {
    fwrite(Message_Digest, 1, hashsize, stdout);
  } else if (printResults == PRINTHEX) {
    for (i = 0; i &lt; hashsize; ++i) {
      putchar(hexdigits[(Message_Digest[i] &gt;&gt; 4) &amp; 0xF]);
      putchar(hexdigits[Message_Digest[i] &amp; 0xF]);
    }
    putchar(&#39;\n&#39;);
  } else if (printResults == PRINTBASE64) {
    unsigned char b;
    char *sm = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#34;
               &#34;0123456789+/&#34;;
    for (i = 0; i &lt; hashsize; i += 3) {
      putchar(sm[Message_Digest[i] &gt;&gt; 2]);
      b = (Message_Digest[i] &amp; 0x03) &lt;&lt; 4;
      if (i+1 &lt; hashsize) b |= Message_Digest[i+1] &gt;&gt; 4;
      putchar(sm[b]);
      if (i+1 &lt; hashsize) {
        b = (Message_Digest[i+1] &amp; 0x0f) &lt;&lt; 2;
        if (i+2 &lt; hashsize) b |= Message_Digest[i+2] &gt;&gt; 6;
        putchar(sm[b]);
      } else putchar(&#39;=&#39;);
      if (i+2 &lt; hashsize) putchar(sm[Message_Digest[i+2] &amp; 0x3f]);
      else putchar(&#39;=&#39;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 } putchar(&#39;\n&#39;); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
}のputchar（ &#39;の\ n&#39;）; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (printResults &amp;&amp; resultarray) {
    printf(&#34;    Should match:\n\t&#34;);
    for (i = 0, k = 0; i &lt; hashsize; i++, k += 2) {
      putchar(resultarray[k]);
      putchar(resultarray[k+1]);
      putchar(&#39; &#39;);
    }
    putchar(&#39;\n&#39;);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (printPassFail &amp;&amp; resultarray) {
    int ret = checkmatch(Message_Digest, resultarray, hashsize);
    if ((printPassFail == PRINTPASSFAIL) || !ret)
      printf(&#34;%s %s %s: %s\n&#34;, hashname, testtype, testname,
        ret ? &#34;PASSED&#34; : &#34;FAILED&#34;);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Exercise a hash series of functions.  The input is the testarray,
 * repeated repeatcount times, followed by the extrabits.  If the
 * result is known, it is in resultarray in uppercase hex.
 */
int hash(int testno, int loopno, int hashno,
  const char *testarray, int length, long repeatcount,
  int numberExtrabits, int extrabits, const unsigned char *keyarray,
  int keylen, const unsigned char *info, int infolen, int okmlen,
  const char *resultarray, int hashsize, int printResults,
  int printPassFail)
{
  USHAContext sha;
  HMACContext hmac;
  HKDFContext hkdf;
  int err, i;
  uint8_t Message_Digest_Buf[USHAMaxHashSize];
  uint8_t *Message_Digest = Message_Digest_Buf;
  char buf[20];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (printResults == PRINTTEXT) {
    printf(&#34;\nTest %d: Iteration %d, Repeat %ld\n\t&#39;&#34;, testno+1,
      loopno, repeatcount);
    printstr(testarray, length);
    printf(&#34;&#39;\n\t&#39;&#34;);
    printxstr(testarray, length);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    printf(&#34;&#39;\n&#34;);
    printf(&#34;    Length=%d bytes (%d bits), &#34;, length, length * 8);
    printf(&#34;ExtraBits %d: %2.2x\n&#34;, numberExtrabits, extrabits);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (info) Message_Digest = malloc(okmlen);
  memset(&amp;sha, &#39;\343&#39;, sizeof(sha)); /* force bad data into struct */
  memset(&amp;hmac, &#39;\343&#39;, sizeof(hmac));
  memset(&amp;hkdf, &#39;\343&#39;, sizeof(hkdf));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  err = info ? hkdfReset(&amp;hkdf, hashes[hashno].whichSha,
                             keyarray, keylen) :
        keyarray ? hmacReset(&amp;hmac, hashes[hashno].whichSha,
                             keyarray, keylen) :
                   USHAReset(&amp;sha, hashes[hashno].whichSha);
  if (err != shaSuccess) {
    fprintf(stderr, &#34;hash(): %sReset Error %d.\n&#34;,
            info ? &#34;hkdf&#34; : keyarray ? &#34;hmac&#34; : &#34;sha&#34;, err);
    return err;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (i = 0; i &lt; repeatcount; ++i) {
    err = info ? hkdfInput(&amp;hkdf, (const uint8_t *)testarray, length) :
          keyarray ? hmacInput(&amp;hmac, (const uint8_t *) testarray,
                               length) :
                     USHAInput(&amp;sha, (const uint8_t *) testarray,
                               length);
    if (err != shaSuccess) {
      fprintf(stderr, &#34;hash(): %sInput Error %d.\n&#34;,
              info ? &#34;hkdf&#34; : keyarray ? &#34;hmac&#34; : &#34;sha&#34;, err);
      return err;
    }
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (numberExtrabits &gt; 0) {
    err = info ? hkdfFinalBits(&amp;hkdf, extrabits, numberExtrabits) :
          keyarray ? hmacFinalBits(&amp;hmac, (uint8_t) extrabits,
                                   numberExtrabits) :
                     USHAFinalBits(&amp;sha, (uint8_t) extrabits,
                                   numberExtrabits);
    if (err != shaSuccess) {
      fprintf(stderr, &#34;hash(): %sFinalBits Error %d.\n&#34;,
              info ? &#34;hkdf&#34; : keyarray ? &#34;hmac&#34; : &#34;sha&#34;, err);
      return err;
    }
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
err = info ? hkdfResult(&amp;hkdf, 0, info, infolen,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ERR =情報？ hkdfResult（hkdf、0、情報、infolen、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                          Message_Digest, okmlen) :
        keyarray ? hmacResult(&amp;hmac, Message_Digest) :
                   USHAResult(&amp;sha, Message_Digest);
  if (err != shaSuccess) {
    fprintf(stderr, &#34;hash(): %s Result Error %d, could not compute &#34;
      &#34;message digest.\n&#34;,
      info ? &#34;hkdf&#34; : keyarray ? &#34;hmac&#34; : &#34;sha&#34;, err);
    return err;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  sprintf(buf, &#34;%d&#34;, testno+1);
  printResult(Message_Digest, info ? okmlen : hashsize,
    hashes[hashno].name, info ? &#34;hkdf standard test&#34; :
    keyarray ? &#34;hmac standard test&#34; : &#34;sha standard test&#34;, buf,
    resultarray, printResults, printPassFail);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return err; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ERRを返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Exercise an HKDF series.  The input is the testarray,
 * repeated repeatcount times, followed by the extrabits.  If the
 * result is known, it is in resultarray in uppercase hex.
 */
int hashHkdf(int testno, int loopno, int hashno,
  int printResults, int printPassFail)
{
  int err;
  unsigned char prk[USHAMaxHashSize+1];
  uint8_t okm[255 * USHAMaxHashSize+1];
  char buf[20];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (printResults == PRINTTEXT) {
    printf(&#34;\nTest %d: Iteration %d\n\tSALT\t&#39;&#34;, testno+1, loopno);
    printxstr(hkdfhashes[testno].saltarray,
      hkdfhashes[testno].saltlength);
    printf(&#34;&#39;\n\tIKM\t&#39;&#34;);
    printxstr(hkdfhashes[testno].ikmarray,
      hkdfhashes[testno].ikmlength);
    printf(&#34;&#39;\n\tINFO\t&#39;&#34;);
    printxstr(hkdfhashes[testno].infoarray,
      hkdfhashes[testno].infolength);
    printf(&#34;&#39;\n&#34;);
    printf(&#34;    L=%d bytes\n&#34;, hkdfhashes[testno].okmlength);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Run hkdf() against the test vectors */
  err = hkdf(hkdfhashes[testno].whichSha,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             (const uint8_t *) hkdfhashes[testno].saltarray,
             hkdfhashes[testno].saltlength,
             (const uint8_t *) hkdfhashes[testno].ikmarray,
             hkdfhashes[testno].ikmlength,
             (const uint8_t *) hkdfhashes[testno].infoarray,
             hkdfhashes[testno].infolength, okm,
             hkdfhashes[testno].okmlength);
  if (err != shaSuccess) {
    fprintf(stderr, &#34;hashHkdf(): hkdf Error %d.\n&#34;, err);
    return err;
  }
  sprintf(buf, &#34;hkdf %d&#34;, testno+1);
  printResult(okm, hkdfhashes[testno].okmlength,
    USHAHashName(hkdfhashes[testno].whichSha), &#34;hkdf standard test&#34;,
    buf, hkdfhashes[testno].okmarray, printResults, printPassFail);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Now run hkdfExtract() by itself against the test vectors */
  /* to verify the intermediate results. */
  err = hkdfExtract(hkdfhashes[testno].whichSha,
                    (const uint8_t *) hkdfhashes[testno].saltarray,
                    hkdfhashes[testno].saltlength,
                    (const uint8_t *) hkdfhashes[testno].ikmarray,
                    hkdfhashes[testno].ikmlength, prk);
  if (err != shaSuccess) {
    fprintf(stderr, &#34;hashHkdf(): hkdfExtract Error %d.\n&#34;, err);
    return err;
  }
  sprintf(buf, &#34;hkdfExtract %d&#34;, testno+1);
  printResult(prk, USHAHashSize(hkdfhashes[testno].whichSha),
    USHAHashName(hkdfhashes[testno].whichSha), &#34;hkdf standard test&#34;,
    buf, hkdfhashes[testno].prkarray, printResults, printPassFail);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Now run hkdfExpand() by itself against the test vectors */
  /* using the intermediate results from hkdfExtract. */
  err = hkdfExpand(hkdfhashes[testno].whichSha, prk,
    USHAHashSize(hkdfhashes[testno].whichSha),
    (const uint8_t *)hkdfhashes[testno].infoarray,
    hkdfhashes[testno].infolength, okm, hkdfhashes[testno].okmlength);
  if (err != shaSuccess) {
    fprintf(stderr, &#34;hashHkdf(): hkdfExpand Error %d.\n&#34;, err);
    return err;
  }
  sprintf(buf, &#34;hkdfExpand %d&#34;, testno+1);
  printResult(okm, hkdfhashes[testno].okmlength,
    USHAHashName(hkdfhashes[testno].whichSha), &#34;hkdf standard test&#34;,
    buf, hkdfhashes[testno].okmarray, printResults, printPassFail);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
return err;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ERRを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
｝
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Exercise a hash series of functions.  The input is a filename.
 * If the result is known, it is in resultarray in uppercase hex.
 */
int hashfile(int hashno, const char *hashfilename, int bits,
  int bitcount, int skipSpaces, const unsigned char *keyarray,
  int keylen, const unsigned char *info, int infolen, int okmlen,
  const char *resultarray, int hashsize,
  int printResults, int printPassFail)
{
  USHAContext sha;
  HMACContext hmac;
  HKDFContext hkdf;
  int err, nread, c;
  unsigned char buf[4096];
  uint8_t Message_Digest_Buf[USHAMaxHashSize];
  uint8_t *Message_Digest = Message_Digest_Buf;
  unsigned char cc;
  FILE *hashfp = (strcmp(hashfilename, &#34;-&#34;) == 0) ? stdin :
    fopen(hashfilename, &#34;r&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (!hashfp) {
    fprintf(stderr, &#34;cannot open file &#39;%s&#39;\n&#34;, hashfilename);
    return shaStateError;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (info) Message_Digest = malloc(okmlen);
  memset(&amp;sha, &#39;\343&#39;, sizeof(sha)); /* force bad data into struct */
  memset(&amp;hmac, &#39;\343&#39;, sizeof(hmac));
  memset(&amp;hkdf, &#39;\343&#39;, sizeof(hkdf));
  err = info ? hkdfReset(&amp;hkdf, hashes[hashno].whichSha,
                             keyarray, keylen) :
        keyarray ? hmacReset(&amp;hmac, hashes[hashno].whichSha,
                             keyarray, keylen) :
                   USHAReset(&amp;sha, hashes[hashno].whichSha);
  if (err != shaSuccess) {
    fprintf(stderr, &#34;hashfile(): %sReset Error %d.\n&#34;,
            info ? &#34;hkdf&#34; : keyarray ? &#34;hmac&#34; : &#34;sha&#34;, err);
    return err;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (skipSpaces) while ((c = getc(hashfp)) != EOF) { if (!isspace(c)) { cc = (unsigned char)c; err = info ? hkdfInput(&amp;hkdf, &amp;cc, 1) :
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（！（C = GETC（hashfp））= EOF）{IF（！isspace（c）参照）{CC =（unsigned char型）Cながら（skipSpaces）であれば、 ERR =情報？ hkdfInput（＆hkdf、＆CC、1）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              keyarray ? hmacInput(&amp;hmac, &amp;cc, 1) :
                         USHAInput(&amp;sha, &amp;cc, 1);
        if (err != shaSuccess) {
          fprintf(stderr, &#34;hashfile(): %sInput Error %d.\n&#34;,
                  info ? &#34;hkdf&#34; : keyarray ? &#34;hmac&#34; : &#34;sha&#34;, err);
          if (hashfp != stdin) fclose(hashfp);
          return err;
        }
      }
    }
  else
    while ((nread = fread(buf, 1, sizeof(buf), hashfp)) &gt; 0) {
      err = info ? hkdfInput(&amp;hkdf, buf, nread) :
            keyarray ? hmacInput(&amp;hmac, buf, nread) :
                       USHAInput(&amp;sha, buf, nread);
      if (err != shaSuccess) {
        fprintf(stderr, &#34;hashfile(): %s Error %d.\n&#34;,
                info ? &#34;hkdf&#34; : keyarray ? &#34;hmacInput&#34; :
                &#34;shaInput&#34;, err);
        if (hashfp != stdin) fclose(hashfp);
        return err;
      }
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (bitcount &gt; 0)
    err = info ? hkdfFinalBits(&amp;hkdf, bits, bitcount) :
          keyarray ? hmacFinalBits(&amp;hmac, bits, bitcount) :
                   USHAFinalBits(&amp;sha, bits, bitcount);
  if (err != shaSuccess) {
    fprintf(stderr, &#34;hashfile(): %s Error %d.\n&#34;,
            info ? &#34;hkdf&#34; : keyarray ? &#34;hmacFinalBits&#34; :
            &#34;shaFinalBits&#34;, err);
    if (hashfp != stdin) fclose(hashfp);
    return err;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  err = info ? hkdfResult(&amp;hkdf, 0, info, infolen,
                          Message_Digest, okmlen) :
        keyarray ? hmacResult(&amp;hmac, Message_Digest) :
                   USHAResult(&amp;sha, Message_Digest);
  if (err != shaSuccess) {
    fprintf(stderr, &#34;hashfile(): %s Error %d.\n&#34;,
            info ? &#34;hkdf&#34; : keyarray ? &#34;hmacResult&#34; :
            &#34;shaResult&#34;, err);
    if (hashfp != stdin) fclose(hashfp);
    return err;
  } printResult(Message_Digest, info ? okmlen : hashsize,
    hashes[hashno].name, &#34;file&#34;, hashfilename, resultarray,
    printResults, printPassFail);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (hashfp != stdin) fclose(hashfp);
  if (info) free(Message_Digest);
  return err;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Exercise a hash series of functions through multiple permutations.
 * The input is an initial seed.  That seed is replicated 3 times.
 * For 1000 rounds, the previous three results are used as the input.
 * This result is then checked, and used to seed the next cycle.
 * If the result is known, it is in resultarrays in uppercase hex.
 */
void randomtest(int hashno, const char *seed, int hashsize,
    const char **resultarrays, int randomcount,
    int printResults, int printPassFail)
{
  int i, j; char buf[20];
  unsigned char SEED[USHAMaxHashSize], MD[1003][USHAMaxHashSize];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* INPUT: Seed - A random seed n bits long */
  memcpy(SEED, seed, hashsize);
  if (printResults == PRINTTEXT) {
    printf(&#34;%s random test seed= &#39;&#34;, hashes[hashno].name);
    printxstr(seed, hashsize);
    printf(&#34;&#39;\n&#34;);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (j = 0; j &lt; randomcount; j++) {
    /* MD0 = MD1 = MD2 = Seed; */
    memcpy(MD[0], SEED, hashsize);
    memcpy(MD[1], SEED, hashsize);
    memcpy(MD[2], SEED, hashsize);
    for (i=3; i&lt;1003; i++) {
      /* Mi = MDi-3 || MDi-2 || MDi-1; */
      USHAContext Mi;
      memset(&amp;Mi, &#39;\343&#39;, sizeof(Mi)); /* force bad data into struct */
      USHAReset(&amp;Mi, hashes[hashno].whichSha);
      USHAInput(&amp;Mi, MD[i-3], hashsize);
      USHAInput(&amp;Mi, MD[i-2], hashsize);
      USHAInput(&amp;Mi, MD[i-1], hashsize);
      /* MDi = SHA(Mi); */
      USHAResult(&amp;Mi, MD[i]);
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* MDj = Seed = MDi; */
    memcpy(SEED, MD[i-1], hashsize);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    /* OUTPUT: MDj */
    sprintf(buf, &#34;%d&#34;, j);
    printResult(SEED, hashsize, hashes[hashno].name, &#34;random test&#34;,
      buf, resultarrays ? resultarrays[j] : 0, printResults,
      (j &lt; RANDOMCOUNT) ? printPassFail : 0);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Look up a hash name.
 */
int findhash(const char *argv0, const char *opt)
{
  int i;
  const char *names[HASHCOUNT][2] = {
    { &#34;0&#34;, &#34;sha1&#34; }, { &#34;1&#34;, &#34;sha224&#34; }, { &#34;2&#34;, &#34;sha256&#34; },
    { &#34;3&#34;, &#34;sha384&#34; }, { &#34;4&#34;, &#34;sha512&#34; }
  };
  for (i = 0; i &lt; HASHCOUNT; i++)
    if ((strcmp(opt, names[i][0]) == 0) ||
        (scasecmp(opt, names[i][1]) == 0))
      return i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  fprintf(stderr, &#34;%s: Unknown hash name: &#39;%s&#39;\n&#34;, argv0, opt);
  usage(argv0);
  return 0;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Run some tests that should invoke errors.
 */
void testErrors(int hashnolow, int hashnohigh, int printResults,
    int printPassFail)
{
  USHAContext usha;
  uint8_t Message_Digest[USHAMaxHashSize];
  int hashno, err;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  for (hashno = hashnolow; hashno &lt;= hashnohigh; hashno++) {
    memset(&amp;usha, &#39;\343&#39;, sizeof(usha)); /* force bad data */
    USHAReset(&amp;usha, hashno);
    USHAResult(&amp;usha, Message_Digest);
    err = USHAInput(&amp;usha, (const unsigned char *)&#34;foo&#34;, 3);
    if (printResults == PRINTTEXT)
      printf (&#34;\nError %d. Should be %d.\n&#34;, err, shaStateError);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if ((printPassFail == PRINTPASSFAIL) || ((printPassFail == PRINTFAIL) &amp;&amp; (err != shaStateError))) printf(&#34;%s se: %s\n&#34;, hashes[hashno].name, (err == shaStateError) ? &#34;PASSED&#34; : &#34;FAILED&#34;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし（（printPassFail == PRINTPASSFAIL）||（（printPassFail == PRINTFAIL）&amp;&amp;（ERR = shaStateError））！）のprintf（ &#34;％sのSE：％sの\ nは&#34;、[hashno] .nameのを、（ハッシュERR == ？shaStateError）は、 &#34;PASSED&#34;： &#34;FAILED&#34;）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    err = USHAFinalBits(&amp;usha, 0x80, 3);
    if (printResults == PRINTTEXT)
      printf (&#34;\nError %d. Should be %d.\n&#34;, err, shaStateError);
    if ((printPassFail == PRINTPASSFAIL) ||
        ((printPassFail == PRINTFAIL) &amp;&amp; (err != shaStateError)))
      printf(&#34;%s se: %s\n&#34;, hashes[hashno].name,
        (err == shaStateError) ? &#34;PASSED&#34; : &#34;FAILED&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    err = USHAReset(0, hashes[hashno].whichSha);
    if (printResults == PRINTTEXT)
       printf(&#34;\nError %d. Should be %d.\n&#34;, err, shaNull);
    if ((printPassFail == PRINTPASSFAIL) ||
        ((printPassFail == PRINTFAIL) &amp;&amp; (err != shaNull)))
       printf(&#34;%s usha null: %s\n&#34;, hashes[hashno].name,
        (err == shaNull) ? &#34;PASSED&#34; : &#34;FAILED&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    switch (hashno) {
      case SHA1: err = SHA1Reset(0); break;
      case SHA224: err = SHA224Reset(0); break;
      case SHA256: err = SHA256Reset(0); break;
      case SHA384: err = SHA384Reset(0); break;
      case SHA512: err = SHA512Reset(0); break;
    }
    if (printResults == PRINTTEXT)
       printf(&#34;\nError %d. Should be %d.\n&#34;, err, shaNull);
    if ((printPassFail == PRINTPASSFAIL) ||
        ((printPassFail == PRINTFAIL) &amp;&amp; (err != shaNull)))
       printf(&#34;%s sha null: %s\n&#34;, hashes[hashno].name,
        (err == shaNull) ? &#34;PASSED&#34; : &#34;FAILED&#34;);
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/* replace a hex string in place with its value */
int unhexStr(char *hexstr)
{
  char *o = hexstr;
  int len = 0, nibble1 = 0, nibble2 = 0;
  if (!hexstr) return 0;
  for ( ; *hexstr; hexstr++) {
    if (isalpha((int)(unsigned char)(*hexstr))) {
      nibble1 = tolower((int)(unsigned char)(*hexstr)) - &#39;a&#39; + 10;
    } else if (isdigit((int)(unsigned char)(*hexstr))) {
      nibble1 = *hexstr - &#39;0&#39;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    } else {
      printf(&#34;\nError: bad hex character &#39;%c&#39;\n&#34;, *hexstr);
    }
    if (!*++hexstr) break;
    if (isalpha((int)(unsigned char)(*hexstr))) {
      nibble2 = tolower((int)(unsigned char)(*hexstr)) - &#39;a&#39; + 10;
    } else if (isdigit((int)(unsigned char)(*hexstr))) {
      nibble2 = *hexstr - &#39;0&#39;;
    } else {
      printf(&#34;\nError: bad hex character &#39;%c&#39;\n&#34;, *hexstr);
    }
    *o++ = (char)((nibble1 &lt;&lt; 4) | nibble2);
    len++;
  }
  return len;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
int main(int argc, char **argv)
{
  int i, err;
  int loopno, loopnohigh = 1;
  int hashno, hashnolow = 0, hashnohigh = HASHCOUNT - 1;
  int testno, testnolow = 0, testnohigh;
  int ntestnohigh = 0;
  int printResults = PRINTTEXT;
  int printPassFail = 1;
  int checkErrors = 0;
  char *hashstr = 0;
  int hashlen = 0;
  const char *resultstr = 0;
  char *randomseedstr = 0;
  int runHmacTests = 0;
  int runHkdfTests = 0;
  char *hmacKey = 0;
  int hmaclen = 0;
  char *info = 0;
  int infolen = 0, okmlen = 0;
  int randomcount = RANDOMCOUNT;
  const char *hashfilename = 0;
  const char *hashFilename = 0;
  int extrabits = 0, numberExtrabits = 0;
  int strIsHex = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (&#39;A&#39; != 0x41) { fprintf(stderr, &#34;%s: these tests require ASCII\n&#34;, argv[0]); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IF（ &#39;A&#39; = 0×41！）{関数fprintf（stderrに、 &#34;％S：これらの試験は、ASCII \ nを必要とする&#34;、ARGV [0]）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
while ((i = getopt(argc, argv,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しばらく（（I =のgetopt（のargc、argvの、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      &#34;6b:B:def:F:h:i:Hk:l:L:mpPr:R:s:S:t:wxX&#34;)) != -1)
    switch (i) {
      case &#39;b&#39;: extrabits = strtol(optarg, 0, 0); break;
      case &#39;B&#39;: numberExtrabits = atoi(optarg); break;
      case &#39;d&#39;: runHkdfTests = 1; break;
      case &#39;e&#39;: checkErrors = 1; break;
      case &#39;f&#39;: hashfilename = optarg; break;
      case &#39;F&#39;: hashFilename = optarg; break;
      case &#39;h&#39;: hashnolow = hashnohigh = findhash(argv[0], optarg);
        break;
      case &#39;H&#39;: strIsHex = 1; break;
      case &#39;i&#39;: info = optarg; infolen = strlen(optarg); break;
      case &#39;k&#39;: hmacKey = optarg; hmaclen = strlen(optarg); break;
      case &#39;l&#39;: loopnohigh = atoi(optarg); break;
      case &#39;L&#39;: okmlen = strtol(optarg, 0, 0); break;
      case &#39;m&#39;: runHmacTests = 1; break;
      case &#39;P&#39;: printPassFail = 0; break;
      case &#39;p&#39;: printResults = PRINTNONE; break;
      case &#39;R&#39;: randomcount = atoi(optarg); break;
      case &#39;r&#39;: randomseedstr = optarg; break;
      case &#39;s&#39;: hashstr = optarg; hashlen = strlen(hashstr); break;
      case &#39;S&#39;: resultstr = optarg; break;
      case &#39;t&#39;: testnolow = ntestnohigh = atoi(optarg) - 1; break;
      case &#39;w&#39;: printResults = PRINTRAW; break;
      case &#39;x&#39;: printResults = PRINTHEX; break;
      case &#39;X&#39;: printPassFail = 2; break;
      case &#39;6&#39;: printResults = PRINTBASE64; break;
      default: usage(argv[0]);
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  if (strIsHex) {
    hashlen = unhexStr(hashstr);
    unhexStr(randomseedstr);
    hmaclen = unhexStr(hmacKey);
    infolen = unhexStr(info);
  }
  testnohigh = (ntestnohigh != 0) ? ntestnohigh:
               runHmacTests ? (HMACTESTCOUNT-1) :
               runHkdfTests ? (HKDFTESTCOUNT-1) :
               (TESTCOUNT-1);
  if ((testnolow &lt; 0) ||
      (testnohigh &gt;= (runHmacTests ? HMACTESTCOUNT : TESTCOUNT)) ||
      (hashnolow &lt; 0) || (hashnohigh &gt;= HASHCOUNT) ||
      (hashstr &amp;&amp; (testnolow == testnohigh)) ||
      (randomcount &lt; 0) ||
      (resultstr &amp;&amp; (!hashstr &amp;&amp; !hashfilename &amp;&amp; !hashFilename)) ||
      ((runHmacTests || hmacKey) &amp;&amp; randomseedstr) ||
      (hashfilename &amp;&amp; hashFilename) || (info &amp;&amp; ((infolen &lt;= 0) || (okmlen &lt;= 0))) ||
      (info &amp;&amp; !hmacKey))
    usage(argv[0]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   *  Perform SHA/HMAC tests
   */
  for (hashno = hashnolow; hashno &lt;= hashnohigh; ++hashno) {
    if (printResults == PRINTTEXT)
      printf(&#34;Hash %s\n&#34;, hashes[hashno].name);
    err = shaSuccess;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    for (loopno = 1; (loopno &lt;= loopnohigh) &amp;&amp; (err == shaSuccess);
         ++loopno) {
      if (hashstr)
        err = hash(0, loopno, hashno, hashstr, hashlen, 1,
          numberExtrabits, extrabits, (const unsigned char *)hmacKey,
          hmaclen, (const uint8_t *) info, infolen, okmlen, resultstr,
          hashes[hashno].hashsize, printResults, printPassFail);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
else if (randomseedstr) randomtest(hashno, randomseedstr, hashes[hashno].hashsize, 0, randomcount, printResults, printPassFail);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（randomseedstr）randomtest他の場合（hashno、randomseedstrは、ハッシュ[hashno] .hashsize、0、randomcount、printResults、printPassFail）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
else if (hashfilename) err = hashfile(hashno, hashfilename, extrabits, numberExtrabits, 0, (const unsigned char *)hmacKey, hmaclen, (const uint8_t *) info, infolen, okmlen, resultstr, hashes[hashno].hashsize, printResults, printPassFail);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうであれば（hashfilename）ERR = hashfile（hashno、hashfilename、extrabits、numberExtrabits、0、（CONSTはunsigned char *）hmacKey、hmaclen、（CONST uint8_t *）情報、infolen、okmlen、resultstr、.hashsize [hashno] printResultsをハッシュ、printPassFail）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
else if (hashFilename) err = hashfile(hashno, hashFilename, extrabits, numberExtrabits, 1, (const unsigned char *)hmacKey, hmaclen, (const uint8_t *) info, infolen, okmlen, resultstr, hashes[hashno].hashsize, printResults, printPassFail);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうであれば（hashFilename）ERR = hashfile（hashno、hashFilename、extrabits、numberExtrabits、1、（CONSTはunsigned char *）hmacKey、hmaclen、（CONST uint8_t *）情報、infolen、okmlen、resultstr、.hashsize [hashno] printResultsをハッシュ、printPassFail）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      else /* standard tests */ {
        for (testno = testnolow;
             (testno &lt;= testnohigh) &amp;&amp; (err == shaSuccess); ++testno) {
          if (runHmacTests) {
            err = hash(testno, loopno, hashno,
                       hmachashes[testno].dataarray[hashno] ?
                       hmachashes[testno].dataarray[hashno] :
                       hmachashes[testno].dataarray[1] ? hmachashes[testno].dataarray[1] :
                       hmachashes[testno].dataarray[0],
                       hmachashes[testno].datalength[hashno] ?
                       hmachashes[testno].datalength[hashno] :
                       hmachashes[testno].datalength[1] ?
                       hmachashes[testno].datalength[1] :
                       hmachashes[testno].datalength[0],
                       1, 0, 0,
                       (const unsigned char *)(
                        hmachashes[testno].keyarray[hashno] ?
                        hmachashes[testno].keyarray[hashno] :
                        hmachashes[testno].keyarray[1] ?
                        hmachashes[testno].keyarray[1] :
                        hmachashes[testno].keyarray[0]),
                       hmachashes[testno].keylength[hashno] ?
                       hmachashes[testno].keylength[hashno] :
                       hmachashes[testno].keylength[1] ?
                       hmachashes[testno].keylength[1] :
                       hmachashes[testno].keylength[0],
                       0, 0, 0,
                       hmachashes[testno].resultarray[hashno],
                       hmachashes[testno].resultlength[hashno],
                       printResults, printPassFail);
          } else if (runHkdfTests) {
            err = hashHkdf(testno, loopno, hashno,
                       printResults, printPassFail);
          } else { /* sha tests */
            err = hash(testno, loopno, hashno,
                       hashes[hashno].tests[testno].testarray,
                       hashes[hashno].tests[testno].length,
                       hashes[hashno].tests[testno].repeatcount,
                       hashes[hashno].tests[testno].numberExtrabits,
                       hashes[hashno].tests[testno].extrabits,
                       0, 0, 0, 0, 0,
                       hashes[hashno].tests[testno].resultarray,
                       hashes[hashno].hashsize,
                       printResults, printPassFail);
          }
        }
        if (!runHmacTests &amp;&amp; !runHkdfTests) {
          randomtest(hashno, hashes[hashno].randomtest,
            hashes[hashno].hashsize, hashes[hashno].randomresults,
            RANDOMCOUNT, printResults, printPassFail);
        }
      }
    }
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /* Test some error returns */
  if (checkErrors) {
    testErrors(hashnolow, hashnohigh, printResults, printPassFail);
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return 0; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Compare two strings, case independently.
 * Equivalent to strcasecmp() found on some systems.
 */
int scasecmp(const char *s1, const char *s2)
{
  for (;;) {
    char u1 = tolower((int)(unsigned char)(*s1++));
    char u2 = tolower((int)(unsigned char)(*s2++));
    if (u1 != u2)
      return u1 - u2;
    if (u1 == &#39;\0&#39;)
      return 0;
   }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is intended to provide convenient open source access by the Internet community to the United States of America Federal Information Processing Standard Secure Hash Algorithms (SHAs) [FIPS 180-2], HMACs based thereon, and HKDF. No independent assertion of the security of these functions by the authors for any particular use is intended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、ハッシュアルゴリズム（シャス）[FIPS 180-2]、HMACsそれに基づいて、およびHKDFセキュアアメリカ連邦情報処理標準の米国へのインターネットコミュニティによって、便利なオープンソースへのアクセスを提供することを意図しています。任意の特定の使用のための著者によってこれらの機能のセキュリティの独立したアサーションは意図していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See [RFC6194] for a discussion of SHA-1 Security Considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHA-1セキュリティの考慮事項の議論のための[RFC6194]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thanks for the corrections to [RFC4634] that were provided by Alfred Hoenes and Jan Andres and to Alfred&#39;s comments on the document hereof.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本契約のアルフレッドHoenesとJanアンドレスにより、ドキュメント上のアルフレッドのコメントに提供された[RFC4634]に修正してくれてありがとう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Also to the following in alphabetic order, whose comments lead to improvements in the document: James Carlson, Russ Housley, Tero Kivinen, Juergen Quittek, and Sean Turner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、そのコメントは、文書の改善につながるアルファベット順に次のように：ジェームズ・カールソン、ラスHousley、TERO Kivinen、ユルゲンQuittek、そしてショーン・ターナー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 &#34;HMAC：メッセージ認証のための鍵付きハッシュ化&#34;、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5869] Krawczyk, H. and P. Eronen, &#34;HMAC-based Extract-and-Expand Key Derivation Function (HKDF)&#34;, RFC 5869, May 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5869] Krawczyk、H.、およびP. Eronen、 &#34;HMACベースの抽出物と、拡大鍵導出関数（HKDF）&#34;、RFC 5869、2010年5月を。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHS] &#34;Secure Hash Standard&#34;, United States of American, National Institute of Science and Technology, Federal Information Processing Standard (FIPS) 180-3, http://csrc.nist.gov/publications/fips/fips180-3/ fips180-3_final.pdf.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHS]「セキュアハッシュ標準」、アメリカの米国、技術総合研究所、連邦情報処理標準（FIPS）180-3、http://csrc.nist.gov/publications/fips/fips180-3/ fips180-3_final.pdf。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[US-ASCII] ANSI, &#34;USA Standard Code for Information Interchange&#34;, X3.4, American National Standards Institute: New York, 1968.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[US-ASCII] ANSI、 &#34;情報交換用米国標準コード&#34;、X3.4、米国規格協会：ニューヨーク、1968年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3174] Eastlake 3rd, D. and P. Jones, &#34;US Secure Hash Algorithm 1 (SHA1)&#34;, RFC 3174, September 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3174]イーストレーク第3、D.とP.ジョーンズ、 &#34;米国はハッシュアルゴリズム1（SHA1）を確保&#34;、RFC 3174、2001年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              [RFC3874]  Housley, R., &#34;A 224-bit One-way Hash Function:
              SHA-224&#34;, RFC 3874, September 2004.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4055] Schaad, J., Kaliski, B., and R. Housley, &#34;Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 4055, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4055] Schaad、J.、Kaliski、B.、およびR. Housley氏、 &#34;インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィールで使用するRSA暗号のための追加のアルゴリズムと識別子&#34;、RFC 4055 、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4086]イーストレーク3、D.、シラー、J.、およびS.クロッカー、 &#34;セキュリティのためのランダム要件&#34;、BCP 106、RFC 4086、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4634] Eastlake 3rd, D. and T. Hansen, &#34;US Secure Hash Algorithms (SHA and HMAC-SHA)&#34;, RFC 4634, July 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4634]イーストレーク第3、D.とT.ハンセン、 &#34;米国のセキュアハッシュアルゴリズム（SHAとHMAC-SHA）&#34;、RFC 4634、2006年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6194] Polk, T., Chen, L., Turner, S., and P. Hoffman, &#34;Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms&#34;, RFC 6194, March 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6194]ポーク、T.、陳、L.、ターナー、S.、およびP.ホフマン、 &#34;SHA-0およびSHA-1メッセージダイジェストアルゴリズムのためのセキュリティの考慮事項&#34;、RFC 6194、2011年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHAVS] &#34;The Secure Hash Algorithm Validation System (SHAVS)&#34;, http://csrc.nist.gov/groups/STM/cavp/documents/shs/ SHAVS.pdf, July 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHAVS] &#34;セキュアハッシュアルゴリズム検証システム（SHAVS）&#34;、http://csrc.nist.gov/groups/STM/cavp/documents/shs/ SHAVS.pdf、2004年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix: Changes from RFC 4634
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録：RFC 4634からの変更点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following changes were made to RFC 4634 to produce this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の変更は、この文書を生成するためにRFC 4634に行われました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Add code for HKDF and brief text about HKDF with pointer to [RFC5869].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. [RFC5869]へのポインタでHKDFについてHKDFと簡単なテキストのためのコードを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Fix numerous errata filed against [RFC4634] as included below. Note that in no case did the old code return an incorrect hash value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下含まれる[RFC4634]に対して提出2.修正多数エラッタ。いかなる場合にも、古いコードが間違ってハッシュ値を返したことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.a. Correct some of the error return values which has erroneously been &#34;shaNull&#34; to the correct &#34;shaInputTooLong&#34; error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.a.節誤って正しい「shaInputTooLong」エラーに「shaNull」となっているエラーの戻り値の一部を修正してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.b. Update comments and variable names within the code for consistency and clarity and other editorial changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.B.一貫性と明快さと他の編集上の変更のためのコード内のコメントや変数名を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.c. The previous code for SHA-384 and SHA-512 would stop after 2^93 bytes (2^96 bits). The fixed code handles up to 2^125 bytes (2^128 bits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.C. SHA-384およびSHA-512のための前のコードは、2 ^ 93バイト（2 ^ 96ビット）の後に停止します。固定されたコードは、2 ^ 125バイト（2 ^ 128ビット）までを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.d. Add additional error checking including a run time check in the test driver to detect attempts to run the test driver after compilation using some other character set instead of [US-ASCII].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.d.節代わりの設定いくつかの他の文字を使用してコンパイルした後にテストドライバーを実行しようとする試みを検出するためのテストドライバーでの実行時間チェック[US-ASCII]を含む追加のエラーチェックを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Update boilerplate, remove special license in [RFC4634] as new boilerplate mandates simplified BSD license.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.更新定型、BSDライセンスを簡略化し、新たな定型的義務として、[RFC4634]で特別なライセンスを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Replace MIT version of getopt with new code to satisfy IETF incoming and outgoing license restrictions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. IETF着信と発信のライセンス制限を満たすために新しいコードでのgetoptのMIT版を交換してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Add references to [RFC6194].
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. [RFC6194]への参照を追加します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Other assorted editorial improvements.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.その他各種社説改善。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Donald Eastlake Huawei 155 Beaver Street Milford, MA 01757 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドナルドイーストレイクHuawei社155ビーバー通りミルフォード、MA 01757 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Telephone: +1-508-333-2270 EMail: d3e3e3@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+ 1-508-333-2270 Eメール：d3e3e3@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tony Hansen AT&amp;T Laboratories 200 Laurel Ave. Middletown, NJ 07748 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トニー・ハンセンAT＆T研究所200ローレルアベニュー。ミドルタウン、NJ 07748 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Telephone: +1-732-420-8934 EMail: tony+shs@maillennium.att.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+ 1-732-420-8934 Eメール：tony+shs@maillennium.att.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
