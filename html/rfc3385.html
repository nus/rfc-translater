<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 3385 - Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3385</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc3385">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 3385 - Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc3385">
              https://tools.ietf.org/html/rfc3385
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 3385 - インターネット・プロトコル小型コンピュータシステムインタフェース（iSCSIの）巡回冗長検査（CRC）/チェックサムの考慮事項</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                       D. Sheinwald
Request for Comments: 3385                                     J. Satran
Category: Informational                                              IBM
                                                               P. Thaler
                                                              V. Cavanna
                                                                 Agilent
                                                          September 2002
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Internet Protocol Small Computer System Interface (iSCSI)
         Cyclic Redundancy Check (CRC)/Checksum Considerations
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2002). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2002）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this memo, we attempt to give some estimates for the probability of undetected errors to facilitate the selection of an error detection code for the Internet Protocol Small Computer System Interface (iSCSI).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモでは、私たちは、インターネット・プロトコル小型コンピュータシステムインタフェース（iSCSIの）のためのエラー検出コードの選択を容易にするために検出されないエラーの確率のためのいくつかの推定値を与えることを試みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will also attempt to compare Cyclic Redundancy Checks (CRCs) with other checksum forms (e.g., Fletcher, Adler, weighted checksums), as permitted by available data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々はまた、利用可能なデータによって許容されるように、他のチェックサムの形式（例えば、フレッチャー、アドラー、重み付けされたチェックサム）と巡回冗長検査（CRCを）を比較しようとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cyclic Redundancy Check (CRC) codes [Peterson] are shortened cyclic codes used for error detection. A number of CRC codes have been adopted in standards: ATM, IEC, IEEE, CCITT, IBM-SDLC, and more [Baicheva]. The most important expectation from this kind of code is a very low probability for undetected errors. The probability of undetected errors in such codes has been, and still is, subject to extensive studies that have included both analytical models and simulations. Those codes have been used extensively in communications and magnetic recording as they demonstrate good &#34;burst error&#34; detection capabilities, but are also good at detecting several independent bit errors. Hardware implementations are very simple and well known; their simplicity has made them popular with hardware developers for many years. However, algorithms and software for effective implementations of CRC are now also widely available [Williams].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
巡回冗長検査（CRC）符号[ピーターソン]は、エラー検出に使用される巡回符号を短縮しています。より【Baicheva] ATM、IEC、IEEE、CCITT、IBM-SDLC、および：CRCコードの数は、規格で採用されています。この種のコードから、最も重要な期待が検出されないエラーのための非常に低い確率です。そのようなコードで検出されないエラーの確率は、解析モデルとシミュレーションの両方が含まれている広範な研究の対象となって、まだあるしました。それらは、良好な「バーストエラー」検出能力を実証するだけでなく、いくつかの独立したビットエラーの検出に優れているとして、これらのコードは、通信及び磁気記録に広く使用されてきました。ハードウェアの実装は非常にシンプルでよく知られています。そのシンプルさは、長年のハードウェア開発者と彼らが人気になりました。しかしながら、CRCの効果的な実装のためのアルゴリズムおよびソフトウェアは、今[ウィリアムズ]広く入手可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probability of undetected errors depends on the polynomial selected to generate the code, the error distribution (error model), and the data length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未検出誤り確率は、コード、エラー分布（エラーモデル）、及びデータ長を生成するために選択された多項式に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Error Models and Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.エラーモデルと目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will analyze the code behavior under two conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は2つの条件の下で、コードの振る舞いを分析します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- noisy channel - burst errors with an average length of n bits - low noise channel - independent single bit errors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - 騒々しいチャネル -  nビットの平均長を有するバーストエラー - 低雑音チャネル - 独立したシングルビットエラー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Burst errors are the prevalent natural phenomenon on communication lines and recording media. The numbers quoted for them revolve around the BER (bit error rate). However, those numbers are frequently nothing more than a reflection of the Burst Error Rate multiplied by the average burst length. In field engineering tests, three numbers are usually quoted together -- BER, error-free-seconds and severely-error-seconds; this illustrates our point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バーストエラーは、通信回線や記録メディアに蔓延自然現象です。彼らのために引用された数字は、BER（ビット誤り率）を中心に展開します。しかし、これらの数字は、しばしば平均バースト長を乗じたバーストエラー率の反射以外の何物でもありません。フィールドエンジニアリングのテストでは、3つの数字は、通常は一緒に引用されている -  BER、エラーのない-秒と厳しく誤り秒。これは私たちのポイントを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even beyond communication and recording media, the effects of errors will be bursty. An example of this is a memory error that will affect more than a single bit and the total effect will not be very different from the communication error, or software errors that occur while manipulating packets will have a burst effect. Software errors also result in burst errors. In addition, serial internal interconnects will make this type of error the most common within machines as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
でも、コミュニケーションや記録メディアを超えて、誤差の影響がバースト的になります。この例は、単一のビットよりも多くの影響を与えるメモリ・エラーであり、合計の効果は、通信エラーとは非常に異なることはないであろう、またはパケットを操作するときに発生するソフトエラーがバースト効果を有するであろう。ソフトウェアのエラーもバーストエラーになります。また、シリアル内部の配線も同様にマシン内で最も一般的なこのタイプのエラーを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We also analyze the effects of single independent bit errors, since these may be caused by certain defects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらは、特定の欠陥に起因することができるので、我々はまた、単一の独立したビット・エラーの影響を分析します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On burst, we assume an average burst error duration of bd, which at a given transmission rate s, will result in an average burst of a = bd*s bits. (E.g., an average burst duration of 3 ns at 1Gbs gives an average burst of 3 bits.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バーストに、我々は、与えられた伝送速度Sで、BD = * Sビットの平均バーストをもたらすBDの平均バーストエラー期間を、仮定しています。 （例えば、1Gbsで3ナノ秒の平均バースト期間は、3ビットの平均バーストを与えます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the burst error rate, we will take 10^-10. The numbers quoted for BER on wired communication channels are between 10^-10 to 10^-12 and we consider the BER as burst-error-rate*average-burst-length. Nevertheless, please keep in mind that if the channel includes wireless links, the error rates may be substantially higher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バーストエラー率のために、我々は10 ^ -10かかります。有線通信チャネル上のBERのために引用された数字は、10 ^ 10 ^ -10の間で-12、我々は、バースト誤り率*平均バースト長としてBERを考えます。それにも関わらず、チャネルは、無線リンクが含まれている場合、エラー率が実質的に高くなる可能性がありますのでご注意ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For independent single bit errors, we assume a 10^-11 error rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
独立したシングルビットエラーのために、我々は10 ^ -11のエラーレートを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the error detection mechanisms will have to transport large amounts of data (petabytes=10^16 bits) without errors, we will target very low probabilities for undetected errors for all block lengths (at 10Gb/s that much data can be sent in less than 2 weeks on a single link).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー検出メカニズムがエラーなしで大量のデータ（ペタバイト= 10 ^ 16ビット）を搬送しなければならないので、我々は多くのデータが少ないで送信することができることの10Gb / sで（全ブロック長のために検出されないエラーの非常に低い確率を標的とします）単一のリンク上の2週間以上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternatively, as iSCSI has to perform efficiently, we will require that the error detection capability of a selected protection mechanism be very good, at least up to block lengths of 8k bytes (64kbits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iSCSIは効率的に実行しなければ別法として、我々は、選択された保護機構のエラー検出能力は8Kバイト（ある64k）の長さをブロックするために、少なくともまで、非常に良好であることを必要とするであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The error detection capability should keep the probability of undetected errors at values that would be &#34;next-to-impossible&#34;. We recognize, however, that such attributes are hard to quantify and we resorted to physics. The value 10^23 is the Avogadro number while 10^45 is the number of atoms in the known Universe (or it was many years ago when we read about it) and those are the bounds of incertitude we could live with. (10^-23 at worst and 10^-45 if we can afford it.) For 8k blocks, the per/bit equivalent would be (10^-28 to 10^-50).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー検出機能は、「次のツー不可能」だろう値で検出されないエラーの確率を維持する必要があります。我々は認識し、しかし、そのような属性は、定量化が困難であり、私たちは物理学に頼っ。 10 ^ 45は、既知の宇宙の原子の数（または我々はそれについて読んだとき、それは何年も前だった）で、それらは私たちが一緒に暮らすことができ不確実の境界している間値10 ^ 23はアボガドロ数です。 （10 ^ -23我々はそれを余裕がある場合。最悪の場合、10 ^ -45）8kのブロックについては、あたり/ビット相当するものは（10 ^ -50〜10 ^ -28）になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Background and Literature Survey
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.背景と文学調査
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each codeword of a binary (n,k) CRC code C consists of n = k+r bits. The block of r parity bits is computed from the block of k information bits. The code has a degree r generator polynomial g(x).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイナリの各コードワードは、（n、k）はCRC符号Cは、N = K + Rビットからなります。 r個のパリティビットのブロックは、k個の情報ビットのブロックから計算されます。コードは、次数rの生成多項式G（X）を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The code is linear in the sense that the bitwise addition of any two codewords yields a codeword.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードは、任意の2つのコードワードのビット単位の添加は、符号語を生成するという意味で線形です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the minimal m such that g(x) divides (x^m)-1, either n=m, and the code C comprises the set D of all the multiplications of g(x) modulo (x^m)-1, or n&lt;m, and C is obtained from D by shortening each word in the latter in m-n specific positions. (This also reduces the number of words since all zero words are then discarded and duplicates are not maintained.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小MのためのそのようなG（x）の除算（X ^ M）-1、M、コードCのいずれかで、nは= Gの全ての乗算のセットD（x）はモジュロ（X ^ M）-1を含むこと、又はN &lt;M、及びCは、MN特定の位置における後者の各単語を短くしてDから得られます。 （全てゼロの単語は、その後廃棄され、重複が維持されないので、これはまた、単語の数を減少させます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error detection at the receiving end is made by computing the parity bits from the received information block, and comparing them with the received parity bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信側で誤り検出は、受信した情報ブロックからパリティビットを計算し、受信したパリティビットと比較することによって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An undetected error occurs when the received word c&#39; is a codeword, but is different from the c that is transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未検出誤りは受信語C」が符号語である場合に生じるが、送信され、Cとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is only possible when the error pattern e=c&#39;-c is a codeword by itself (because of the linearity of the code). The performance of a CRC code is measured by the probability Pud of undetected channel errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、誤りパターンE = C&#39;-Cは（理由コードの直線の）自身が符号語である場合にのみ可能です。 CRCコードの性能は未検出チャンネルエラーの確率PUDによって測定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let Ai denote the number of codewords of weight i, (i.e., with i 1- bits). For a binary symmetric channel (BSC), with sporadic, independent bit error ratio of probability 0&lt;=epsilon&lt;=0.5, the probability of undetected errors for the code C is thus given by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Aiは重量の符号語iの数を示すものと、（すなわち、I 1-ビットで）。バイナリ対称チャネル（BSC）のために、確率0の散発的な、独立したビット誤り率&lt;=イプシロン&lt;= 0.5で、コードCの未検出誤り確率は、従って次式で与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Pud(C,epsilon) = Sigma[for i=d to n] (Ai*(epsilon^i)*(1-epsilon)^(n-i))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
[iに対する= NにD] PUD（C、ε）=シグマ（AI *（イプシロン^ I）*（1-イプシロン）^（I N-））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where d is the distance of the code: the minimal weight difference between two codewords in C which, by the linearity of the code, is also the minimal weight of any codeword in the code. Pud can also be expressed by the weight distribution of the dual code: the set of words each of which is orthogonal (bitwise AND yields an even number of 1-bits) to every word of C. The fact that Pud can be computed using the dual code is extremely important; while the number of codewords in the code is 2^k, the number of codewords in the dual code is 2^r. k is in the orders of thousands, and r in the order of 16 or 24 or 32. If we use Bi to denote the number of codewords in the dual code which are of weight i, then ([LinCostello]):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
符号の線形性によって、また、コード内の任意の符号語の最小重量であり、Cで2つの符号語間の最小重量差：Dはコードの距離です。 C.のすべての単語と直交する方向（ビット単位のAND 1ビットの偶数を生じる）でそれぞれが単語のセットPUDを用いて計算することができるという事実を：PUDは、デュアルコードの重量分布によって表すことができます。デュアルコードは非常に重要です。コード内のコードワードの数が2 ^ Kである、デュアルコードにおけるコードワードの数は2 ^ Rです。 kは数千のオーダーであり、16または24または32の順にR、我々は重量であるデュアルコードにおけるコードワードの数を示すためのBiを使用する場合、Iは、（[LinCostello]）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Pud (C,epsilon) = 2^-r Sigma [for i=0 to n] Bi*(1-2*epsilon)^i - (1-epsilon)^n
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
PUD（C、ε）= 2 ^ -rシグマ[用I = 0からn]ビ*（1-2 *イプシロン）^ I  - （1-イプシロン）^ n個
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf [Wolf94o] introduced an efficient algorithm for enumerating all the codewords of a code and finding their weight distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウルフ[Wolf94o]はコードのすべてのコードワードを列挙し、その重量分布を求めるための効率的なアルゴリズムを導入しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf [Wolf82] found that, counter to what was assumed, (1) there exist codes for which Pud(C,epsilon)&gt;Pud(C,0.5) for some epsilon not=0.5 and (2) Pud is not always increasing for 0&lt;=epsilon&lt;=0.5. The value of what was assumed to be the worst Pud is Pud(C,0.5)=(2^- r) - (2^-n). This stems from the fact that with epsilon=0.5, all 2^n received words are equally likely and out of them 2^(n-r)-1 will be accepted as codewords of no errors, although they are different from the codeword transmitted. Previously Pud had been assumed to equal [2^(n-r)-1]/(2^n-1) or the ratio of the number of non-zero multiples of the polynomial of degree less than n (each such multiple is undetected) and the number of possible error polynomials. With either formula Pud approaches 1/2^r as n approaches infinity, but Wolf&#39;s formula is more accurate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウルフ[Wolf82]と仮定したものにカウンタが、（1）PUD（C、イプシロン）&gt; PUD（C、0.5）をコード= 0.5一部イプシロンためない存在と（2）PUDは常にために増加されていないことがわかっ0 &lt;=イプシロン&lt;= 0.5。 （2 ^ -n） - 最悪PUDであると仮定されたものの値は、PUD（C、0.5）=（ -  R 2 ^）です。それらが送信された符号語は異なるが、これは、ε= 0.5で、すべての2 ^ N個の受信ワードが等しく可能性があり、それらのうちの2 ^（N-R）という事実から生じる-1、エラーなしのコードワードとして受け入れられるであろう。以前PUDが等しいと仮定していた[2 ^（NR）-1] /（2 N-1 ^）n以下の多項式のゼロ以外の倍数の数の比（それぞれ、複数が未検出です）そして、考えられるエラー多項式の数。 nが無限大に近づくが、ウルフの式はより正確であるようにいずれかの式でPUDは、1/2 ^ Rに近づきます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf [Wolf94j] investigated the CCITT code of r=16 parity bits. This code is a member of the family of (shortened codes of) BCH codes of length 2^(r-1) -1 (r=16 in the CCITT 16-bit case) generated by a polynomial of the form g(x) =(x+1)p(x) with p(x) being a primitive polynomial of degree r-1 (=15 in this case). These codes have a BCH design distance of 4. That is, the minimal distance between any two codewords in the code is at least 4 bits (which is earned by the fact that the sequence of powers of alpha, the root of p(x), which are roots of g(x), includes three consecutive powers -- alpha^0, alpha^1, alpha^2). Hence, every 3 single bit errors are detectable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウルフ[Wolf94j] R = 16パリティビットのCCITTコードを調べました。このコードは、長さが2 ^（R-1）のBCH符号（の短縮コード）のファミリーのメンバーである-1（CCITT 16ビットの場合にはR = 16）形態G（X）の多項式によって生成します= Pと（X + 1）、P（x）は（x）の次数R-1（ここで= 15）の原始多項式です。これらのコードが4のBCH設計距離を有し、コード内の任意の2つの符号語間の最小距離は、αの累乗の配列という事実によって獲得された少なくとも4ビット（Pのルート（x）はアルファ^ 0、アルファ^ 1、アルファ^ 2） - 、G（X）の根であるが三つの連続パワーを含んでいます。したがって、すべての3つのビットエラーが検出可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf found that different shortened versions of a given code, of the same codeword length, perform the same (independent of which specific indexes are omitted from the original code). He also found that for the unshortened codes, all primitive polynomials yield codes of the same performance. But for the shortened versions, the choice of the primitive polynomial does make a difference. Wolf [Wolf94j] found a primitive polynomial which (when multiplied by x+1) yields a generating polynomial that outperforms the CCITT one by an order of magnitude. For 32-bit redundancy bits, he found an example of two polynomials that differ in their probability of undetected burst of length 33 by 4 orders of magnitude.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
狼は、与えられたコードの異なる短縮バージョンは、同一の符号語長の、同じ（特定のインデックスが元のコードから省略されているとは無関係に）を実行することを見出しました。彼はまた、unshortenedコードのために、すべての原始多項式は、同じ性能のコードが得られることがわかりました。しかし、短縮バージョンについては、原始多項式の選択は違いを生むん。ウルフ[Wolf94j]（X + 1を掛けた）原始多項式を発見した桁CCITTいずれかよりも優れ生成多項式が得られます。 32ビットの冗長ビットのために、彼は4桁によって長さ33の未検出バーストのそれらの確率が異なる2つの多項式の例を発見しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It so happens, that for some shortened codes, the minimum distance, or the distribution of the weights, is better than for others derived from different unshortened codes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのように、いくつかの短縮コード、最小距離、または重みの分布のために、異なるunshortenedコードに由来する他のものよりも優れていることが、発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Baicheva, et. al. [Baicheva] made a comprehensive comparison of different generating polynomials of degree 16 of the form g(x) = (x+1)p(x), and of other forms. They computed their Pud for code lengths up to 1024 bits. They measured their &#34;goodness&#34; -- if Pud(C,epsilon) &lt;= Pud(C,0.5) and being &#34;well-behaved&#34; -- if Pud(C,epsilon) increases with epsilon in the range (0,0.5). The paper gives a comprehensive table that lists which of the polynomials is good and which is well-behaved for different length ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Baicheva、ら。アル。 【Baicheva】フォームG（X）=（X + 1）P（X）、及び他の形態の度合い16の異なる生成多項式の包括的比較を行いました。コードは、1024ビットまでの長さのために、彼らは彼らのPUDを計算しました。彼らは &#34;良&#34; を測定 -  PUD（C、ε）&lt;= PUD（C、0.5）とは、 &#34;行儀の良い&#34; された場合 -  PUD（C、イプシロン）は範囲（0,0.5）でイプシロンと共に増加する場合。紙は良好であり、これは、異なる長さの範囲については行儀さ多項式のどの示しています包括的なテーブルを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a single burst error, Wolf [Wolf94J] suggested the model of (b:p) burst -- the errors only occur within a span of b bits, and within that span, the errors occur randomly, with a bit error probability 0 &lt;= p &lt;= 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラーはBビットのスパン内でのみ起こり、そのスパン内で、エラーがランダムに発生し、ビット誤り確率0 &lt;とともに - バースト：単一バーストエラーのため、ウルフ[Wolf94J]（P B）のモデルが提案しました= p &lt;= 1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For p=0.5, which used to be considered the worst case, it is well known [Wolf94J] that the probability of undetected one burst error of length b &lt;= r is 0, of length b=r+1 is 2^-(r-1), and of b &gt; r+1, is 2^-r, independently of the choice of the primitive polynomial.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P = 0.5、最悪の場合を考慮しなければ使用されるため、それはよく知られている[Wolf94J]長さbの未検出1つのバースト誤りの確率が&lt;= rは長さbの、0であること= R + 1は2 ^  - （ R-1）、及びBの&gt; R + 1は、独立して原始多項式の選択の、2 ^ -rです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With Wolf&#39;s definition, where p can be different from 0.5, indeed it was found that for a given b there are values of p, different from 0.5 which maximize the probability of undetected (b:p) burst error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バーストエラー：pは0.5と異なっていてもよいウルフの定義と、実際には、所与のために検出されない（P B）の確率を最大0.5異なるPの値は、あるbのことがわかりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf proved that for a given code, for all b in the range r &lt; b &lt; n, the conditional probability of undetected error for the (n, n-r) code, given that a (b:p) burst occurred, is equal to the probability of undetected errors for the same code (the same generating polynomial), shortened to block length b, when this shortened code is used with a binary symmetric channel with channel (sporadic, independent) bit error probability p.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バースト発生に等しい：狼は、与えられたコードに対して、範囲Rにおける全てのBの&lt;bが&lt;N、（N、NR）符号の未検出誤りの条件付き確率は、（P B）は、その与えられたことを証明しましたこの短縮コードはチャネルとバイナリ対称チャネル（散発、独立）のビット誤り確率pで使用される長さbをブロックするために短縮同じコード（同じ生成多項式）、のための未検出誤り確率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the IEEE-802.3 used CRC32, Fujiwara et al. [Fujiwara89] measured the weights of all words of all shortened versions of the IEEE 802.3 code of 32 check bits. This code is generated by a primitive polynomial of degree 32:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IEEE-802.3使用CRC32ため、藤原ら。 【Fujiwara89] 32チェックビットのIEEE 802.3コードのすべての短縮バージョンのすべての単語の重量を測定しました。このコードは32度の原始多項式により生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
g(x) = x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1 and hence the designed distance of it is only 3. This distance holds for codes as long as 2^32-1. However, the frame format of the MAC (Media Access Control) of the data link layer in IEEE 802.3, as well as that of the data link layer for the Ethernet (1980) forbid lengths exceeding 12,144 bits. Thus, only such bounded lengths are investigated in [Fujiwara89]. For shortened versions, the minimum distance was found to be 4 for lengths 4096 to 12,144; 5 for lengths 512 to 2048; and even 15 for lengths 33 through 42. A chart of results of calculations of Pud is presented in [Fujiwara89] from which we can see that for codes of length 12,144 and BSC of epsilon = 10^-5 - 10^-4, Pud(12,144,epsilon)= 10^-14 - 10^-13 and for epsilon = 10^-4 - 10^-3, Pud(512,epsilon) = 10^-15, Pud(1024,epsilon) = 10^-14, Pud(2048,epsilon) = 10^-13, Pud(4096,epsilon) = 10^-12 - 10^-11, and Pud(8192,epsilon) = 10^-10 which is rather close to 2^-32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
G（X）= X ^ 32 + X ^ 26 + X ^ 23 + X ^ 22 + X ^ 16 + X ^ 12 + X ^ 11 + X ^ 10 + X ^ 8 + X ^ 7 + X ^ 5 + X ^ 4 + X ^ 2 + X + 1、従ってそれの設計距離だけ3.この距離は32-1 ^ 2限りコードを保持します。しかし、フレームのIEEE 802.3におけるデータリンク層のMAC（Media Access Control）のフォーマット、ならびにイーサネット（登録商標）のためのデータリンク層の（1980）12144ビットを超える長さを禁じます。したがって、唯一のそのような境界長は[Fujiwara89]で検討されています。短縮バージョンについて、最小距離は、長さ12144の4096のために4であることが見出されました。長さが2048から512 5。さらには15我々は長さ12144及びイプシロンのBSCのコードのためにそれを見ることができるから、PUDの計算の結果のグラフが[Fujiwara89]に提示されている33 42を介して長さ= 10 ^ -5のための -  ^ -4 10、PUD （12144、イプシロン）= 10 ^ -14  -  10 ^ -13及びイプシロンのため= 10 ^ -4  -  10 ^ -3、PUD（512、ε）= 10 ^ -15、PUD（1024、ε）= 10 ^ -14、PUD（2048、イプシロン）= 10 ^ -13、PUD（4096、イプシロン）= 10 ^ -12  -  10 ^ -11、およびPUD（8192、イプシロン）= 2にかなり近いです10 ^ -10 ^ -32。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Castagnoli, et. al. [Castagnoli93] extended Fujiwara&#39;s technique for efficiently calculating the minimum distance through the weight distribution of the dual code and explored a large number of CRC codes with 24 and 32 redundancy bit. They explored several codes built as a multiplication of several lower degree irreducible polynomials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Castagnoli、ら。アル。 【Castagnoli93】効率的にデュアルコードの重量配分を介して最小距離を計算するための藤原の技術を拡張し、24及び32冗長ビットとCRCコードの多数を探求。彼らは、いくつかの低い程度の既約多項式の乗算として構築されたいくつかのコードを検討しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the popular class of (x+1)*deg31-irreducible-polynomial they explored 47000 polynomials (not all the possible ones). The best they found has d=6 up to block lengths of 5275 and d=4 up to 2^31-1 (bits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（X + 1）* deg31-既約多項式の人気のクラスでは、彼らは47000個の多項式（すべてではない可能性のもの）を検討しました。それらが発見された最良の5275の長さ、およびd = 4 31-1 ^ 2まで（ビット）をブロックするまで= 6日間ました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The investigation was done in 1993 with a special purpose processor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
調査は特別な目的のプロセッサで、1993年に行われました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By comparison, the IEEE-802 code has d=4 up to at least 64,000 bits (Fujikura stopped looking at 12,144) and d=3 up to 2^32-1 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
比較により、IEEE-802コードは、D = 4いる少なくとも64,000ビット（フジクラは、12144を見て停止）およびd = 3まで2 ^ 32-1ビットまで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CRC32/4 (we will refer to it as CRC32C for the remainder of this memo) is 11EDC6F41; IEEE-802 CRC is 104C11DB7, denoting the coefficients as a bit vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CRC32 / 4（このメモの残りのCRC32Cとしてそれを参照する）11EDC6F41あります。 IEEE-802 CRCビットベクトルとして係数を示す、104C11DB7あります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Stone98] evaluated the performance of CRC (the AAL5 CRC that is the same as IEEE802) and the TCP and Fletcher checksums on large amounts of data. The results of this experiment indicate a serious weakness of the checksums on real-data that stems from the fact that checksums do not spread the &#34;hot spots&#34; in input data. However, the results show that Fletcher behaves by a factor of 2 better than the regular TCP checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Stone98】大量のデータにCRCの性能（IEEE802と同じであるAAL5 CRC）とTCPとフレッチャーチェックサムを評価しました。この実験の結果は、チェックサムは、入力データの「ホットスポット」を普及していないという事実から生じる実データのチェックサムの重大な弱点を示しています。しかし、結果はフレッチャーは、通常のTCPチェックサムよりも2よりよい倍に振る舞うことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Probability of Undetected Errors - Burst Error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.未検出エラーの確率 - バーストエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 CRC32C (Derivations from [Wolf94j])
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 CRC32C（[Wolf94j]から派生の）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf [Wolf94j] found a 32-bit polynomial of the form g(x) = (1+x)p(x) for which the conditional probability of undetected error, given that a burst of length 33 occurred, is at most (i.e., maximized over all possible channel bit error probabilities within the burst) 4 * 10^- 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウルフ[Wolf94j】長さ33のバーストが発生したことを所定の未検出誤りの条件付き確率は、最大であるため、フォームG（X）=（1 + x）をP（X）（すなわち、32ビット多項式を発見しました10  - 、4 * 10 ^）バースト内のすべての可能なチャネルのビット誤り確率を超える最大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will now figure the probability of undetected error, given that a burst of length 34 occurred, using the result derived in this paper, namely that for a given code, for all b in the range 32 &lt; b &lt; n, the conditional probability of undetected error for the (n, n-32) code, given that a (b:p) burst occurred, is equal to the probability of undetected errors for the same code (the same generating polynomial), shortened to block length b, when this shortened code is used with a binary symmetric channel with channel (sporadic, independent) bit error probability p.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、範囲32 &lt;B &lt;N、の条件付き確率で全てのBのために、すなわち、所与のコードについて、長さ34のバーストが、この論文で導出結果を使用して、発生したことを考えると、未検出誤り確率を把握します（N、N-32）コードの未検出誤りは、（B：P）は、所与のバーストが発生したときに、長さbをブロックするために短縮同じコード（同じ生成多項式）のための未検出誤り確率に等しいですこの短縮コードは、チャネル（散発、独立）のビット誤り確率pを持つ2元対称通信路で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The approximation formula for Pud of sporadic errors, if the weights Ai are distributed binomially, is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重みAiは二項分布している場合は散発エラーのPUDのための近似式は、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pud(C, epsilon) =~= Sigma[for i=d to n] ((n choose i) / 2^r )*(1- epsilon)^(n-i) * epsilon^i .
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PUD（C、ε）=〜=シグマ[NへのI =日間]（（n iは選択）/ 2 ^ R）*（1-イプシロン）^（N-I）*イプシロン^ I。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming a very small epsilon, this expression is dominated by i=d. From [Fujiwara89] we know that for 32-bit CRC, for such small n, d=15. Thus, when n grows from 33 to 34, we find that the approximation of Pud grows by (34 choose 15) / (33 choose 15) = 34/19; when n grows further to 35, Pud grows by another 35/20.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非常に小さなイプシロンと仮定すると、この式は、I = Dによって支配されています。 【Fujiwara89]から、我々は32ビットのCRCのための、そのような小さいnについて、D = 15ということを知っています。このように、nは33から34まで成長、我々は、PUDの近似が（34 15を選択）/（33 15を選択）によって成長= 19分の34が見付かります。 nが35にさらに成長したときに、PUDは、別の35/20によって成長します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taking, from Wolf [Wolf94j], the most generous conditional probability, computed with the bit error probability p* that maximizes Pub(p|b), we derive: Pud(p*|33) = 4 x 10^{-10}, yielding Pud(p*|34) = 7.15 x 10^{-10} and Pud(p*|35) = 1.25 x 10^{-9}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウルフ[Wolf94j]、ビット誤り確率P *を用いて計算最も寛大な条件付き確率は、パブが最大化とは、服用（P | B）、我々は派生：PUD（P * | 33）= 4×10 ^ { -  10} = 1.25×10 ^ { -  10} |  -  {10}とPUD（35 P *）= 7.15×10 ^ |、PUD（34 P *）を得ました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the density function of the burst length, we assume the Rayleigh density function (the discretization thereof to integers), which is the density of the absolute values of complex numbers of Gauss distribution:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バースト長の密度関数のために、我々は、ガウス分布の複素数の絶対値の密度であるレイリー密度関数（その整数に離散化）を前提としています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
f(x) = x / a^2 exp {-x^2 / 2a^2 } , x&gt;0 .
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
F（X）= X / A ^ 2 EXP {-x ^ 2/2（A）^ 2}、X&gt; 0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This density function has a peak at the parameter a and it decreases smoothly as x increases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この密度関数は、パラメータaのピークを有しており、それは、xが増加するにつれて滑らかに減少します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We take three consecutive bits as the most common burst event once an error does occur, and thus a=3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そこで我々は、最も一般的なバーストエラーが発生した後、イベント、および= 3のように三つの連続ビットを取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, the probability that a burst of length b occurs in a specific position is the burst error rate, which we estimate as 10^{-10}, times f(b). Calculating for b=33 we find f(33) = 1.94 x 10^{-26}. Together, we found that the probability that a burst of length 33 occurred, starting at a specific position, is 1.94 x 10^{-36}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ -  10}今、長さbのバーストが特定の位置で起こる確率は我々が10 ^として推定バースト誤り率を、ある時間F（B）。 { -  26}、B = 33のために計算我々は、F×10 ^（33）= 1.94を見つけます。 { -  36}一緒に、我々は、長さ33のバーストが特定の位置から始まる、発生確率は、1.94×10 ^であることを見出しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiplying this by the generous upper bound on the probability that this burst error is not detected, Pud(p*|33), we get that the probability that a burst occurred at a specific position, and is not detected, is 7.79 x 10 ^{-46}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このバーストエラーが検出されない確率、PUD（P * | 33）上に結合した寛大な上部のことで、これを掛ける、我々は、バーストが特定の位置で発生し、検出されない確率は、7.79×10 ^であることを取得します{-46}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Going again along this path of calculations, this time for b=34 we find that f(34) = 4.85*10^{-28}. Multiplying by 10^{-10} and by Pud(p*|34) = 7.15*10^{-10} we find that the probability that a burst of length 34 occurred at a specific position, and is not detected, is 3.46*10^{-47}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
計算のこの経路に沿って再び行き、B = 34の​​ためのこの時間は、我々は見つけることはf（34）= 4.85×10 ^ { -  28}。 { -  10}およびPUD（P * | 34）で10 ^掛ける= 7.15 * 10 ^ { -  10}我々は長さ34のバーストが特定の位置で発生し、検出されない確率は、3.46であることがわかり* 10 ^ { -  47}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Last, computing for b=35, we get 1*10^{-29} * 10^{-10} * 1.25*10^{-9} = 1.25*10^{-48}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、B = 35のためのコンピューティングは、我々は、^ 1 * 10を取得{ -  29} * 10 ^ { -  10} * 1.25 * 10 ^ { -  10} = 1.25 * 10 ^ { -  48}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It looks like the total can be approximated at 10^-45 which is within the bounds of what we are looking for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
合計は、我々が探しているものの範囲内である10 ^ -45で近似することができるように見えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When we multiply this by the length of the code (because thus far we calculated for a specific position) we have 10^-45 * 6.5*10^4 = 6.5*10^-41 as an upper bound on the probability of undetected burst error for a code of length 8K Bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（これまで、我々は、特定の位置のために計算されるため）、我々は、コードの長さによって、これを乗算するとき、我々は未検出バーストの確率の上限として^ -45 * 6.5 * 10 ^ 4 = 6.5×10 ^ -41 10を有しています長8Kバイトコードのエラー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can also apply this overestimation for IEEE 802.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、IEEE 802.3のために、この過大評価を適用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comment: 2^{-32} = 2.33*10^{-10}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コメント：2 ^ { -  32} = 2.33 * 10 ^ { -  10}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Probability of Undetected Errors - Independent Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
未検出エラーの確率5  - 独立したエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 CRC (Derivations from [])
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 CRC（[]から派生の）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is reported in [Castagnoli93] that for BER = epsilon=10^-6, Pud for a single bit error, for a code of length 8KB, for both cases, IEEE-802.3 and CRC32C is 10^{-20}. They also report that CRC32C has distance 4, and IEEE either 3 or 4 for this code length. From this, and the minimum distance of the code of this length, we conclude that with our estimation of epsilon, namely 10^{-11}, we should multiply the reported result by {10^{-5}}^4 = 10^{-20} for CRC32C, and either 10^{-15} or 10^{-20} for IEEE802.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
{ -  20} BER =イプシロン= 10 ^ -6ため、単一ビットエラーのPUDは、長さ8キロバイトのコードのため、両方の場合のために、IEEE-802.3とCRC32C 10 ^であること[Castagnoli93]に報告されています。彼らはまた、CRC32C距離4を有することを報告し、この符号長のIEEEは、3又は4のいずれか。 { -  11}、我々はによって報告された結果を乗算する必要があり、この、およびこの長さの符号の最小距離から、我々は、イプシロンの推計で、すなわち10 ^と結論{10 ^ { -  5}} ^ 4 = 10 ^ { -  20} CRC32Cため、及び10のいずれか^ { -  15}または10 ^ { -  20} IEEE802.3ため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Checksums
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2チェックサム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For independent bit errors, Pud of CRC is approximately 12,000 better than Fletcher, and 22,000 better than Adler. For burst errors, by the simple examples that exist for three consecutive values that can produce an undetected burst, we take the factor to be at least the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
独立したビットエラーの場合は、CRCのPUDは、約12,000フレッチャーよりも良い、とアドラーより22,000優れています。バーストエラーのために、未検出のバーストを生成することができる3つの連続した値のために存在する単純な例により、我々は、少なくとも同じになるように係数を取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If in three consecutive bytes, the error values are x, -2x, x then the error is undetected. Even for this error pattern alone, the conditional probability of undetected error, assuming a uniform distribution of data, is 2^-16 = 1.5 * 10^-5. The probability that a burst of length 3 bytes occurs, is f(24) = 3*10^-14. Together: 4.5*10^-19. Multiplying this by the length of the code, we get close to 4.5*10^-16, way worse than the vicinity of 10^-40.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
三つの連続バイトに、エラー値がXであれば、-2X、エラーが検出されないxは。偶数データの均一な分布を仮定すると、単独でこのエラーパターン、未検出誤りの条件付き確率のために、2 ^ -16 = 1.5×10 ^ -5です。長さ3バイトのバーストが発生する確率は、F（24）= 3×10 ^ -14です。一緒：4.5 * 10 ^ -19。コードの長さによって、これを掛ける、我々は10 ^ -40付近より道悪化し、4.5 * 10 ^ -16に近づきます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The numbers in the table in Section 7 below reflect a more &#34;tolerant&#34; difference (10*4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第7の表中の数字は、以下でより「寛容」の差（10 * 4）を反映します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Incremental CRC Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.インクリメンタルCRCアップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some protocols the packet header changes frequently. If the CRC includes the changing part, the CRC will have to be recomputed. This raises two issues:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのプロトコルでは、パケットヘッダが頻繁に変化します。 CRCが変化する部分が含まれている場合、CRCが再計算する必要があります。これには二つの問題が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- the complete computation is expensive - the packet is not protected against unwanted changes between the last check and the recomputation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 - 完全な計算は高価です - パケットが最後のチェックと再計算の間に不要な変更から保護されていません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fortunately, changes in the header do not imply a need for completed CRC computation. The reason is the linearity of the CRC function. Namely, with I1 and I2 denoting two equal-length blocks of information bits, CRC(I) denoting the CRC check bits calculated for I, and + denoting bitwise modulo-2 addition, we have CRC(I1+I2) = CRC(I1)+CRC(I2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
幸いなことに、ヘッダの変更が完了したCRC計算の必要性を意味するものではありません。その理由は、CRC関数の直線性です。すなわち、情報ビットの2つの等しい長さのブロックを表すI1とI2と、CRC（I）Iのために計算されたCRCチェックビットを表す、および+示すビット単位のモジュロ2加算、我々はCRC（I1 + I2）= CRC（I1 ）+ CRC（I2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hence, for an IP packet, made of a header h followed by data d followed by CRC bits c = CRC(h d), arriving at a node, which updates header h to become h&#39;, the implied update of c is an addition of CRC(h&#39;-h 0), where 0 is an all 0 block of the length of the data block d, and addition and subtraction are bitwise modulo 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データが続くヘッダHからなるIPパケットは、CRCビットC = CRC（HD）、続い日間したがって、H」になるためにヘッダHを更新ノードに到着、Cの暗黙の更新は、添加され0は、すべて0のデータブロックDの長さのブロック、及び加減算であるCRC（H&#39;-H 0）は、ビット単位のモジュロ2です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We know that a predetermined permutation of bits does not change distance and weight statistics of the codewords. It follows that such a transformation does not change the probability of undetected errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、所定のビット順列が、コードワードの距離と重量の統計情報を変更しないことを知っています。このような変換が検出されないエラーの確率を変更しないことになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can then conceive the packet as if it was built from data d followed by header h, compute the CRC accordingly, c=CRC(d h), and update at the node with an addition of CRC(0 h&#39;-h)=CRC(h&#39;-h), but on transmission, send the header part before the data and the CRC bits. This will allow a faster computation of the CRC, while still letting the header part lead (no change to the protocol).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、それがデータから構築されたかのように、ヘッダHに続くdのパケットを考える従ってCRCを計算し、C = CRC（DH）、及びCRC（0 H&#39;-H）= CRCを付加したノードで更新することができ（H&#39;-H）が、送信に、データとCRCビットの前にヘッダ部分を送信します。依然としてヘッダ部リード（プロトコルの変更なしに）させながら、これは、CRCの高速計算を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error detection, i.e., computing the CRC bits by the data and header parts that arrive, and comparing them with the CRC part that arrives together with them, can be done at the final, end-target node only, and the detected errors will include unwanted changes introduced by the intermediate nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エラー検出は、すなわち、到着するデータとヘッダ部分によってCRCビットを計算し、それらと一緒に到着するCRC部と比較する、唯一の最終エンドターゲットノードで行うことができ、検出されたエラーが含まれます中間ノードによって導入不要な変更。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The analysis of the undetected error probability remains valid according to the following rationale:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未検出誤り確率の分析は、以下の根拠に基づいて、有効なままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet started its way as a codeword. On its way, several codewords were added to it (any information followed by the corresponding CRC is a codeword). Let e denote the totality of errors added to the packet, on its long, multi-hop journey. Because the code is linear (i.e., the sum of two codewords is also a codeword) the packet arriving to the end-target node is some codeword + e, and hence, as in our preceding analysis, e is undetected if and only if it is a codeword by itself. This fact is the basis of our above analysis, and hence that analysis applies here too. (See a detailed discussion at [braun01].)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットは、符号語としての道を開始しました。その途中で、いくつかのコードワードは、（対応するCRCに続く任意の情報が符号語である）をそれに加えました。 eはその長い、マルチホップ旅に、パケットに付加エラーの全体を示すものとします。コードは線形であるため、エンドターゲットノードに到着するパケットは、いくつかのコードワード+ E、したがって、我々の前の分析のように、eは場合のみなら未検出である（すなわち、2つの符号語の和は符号語でもある）はそれ自体でコードワードです。この事実は、私たちの上記の分析の基礎であるので、その分析はここにも適用されます。 （[braun01]に詳細な議論を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Complexity of Hardware Implementation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ハードウェア実装の複雑さ7。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comparing the cost of various CRC polynomials, we used a tool available at http://www.easics.com/webtools/crctool to implement CRC generators/checkers for various CRC polynomials. The program gives either Verilog or VHDL code after specifying a polynomial, as well as the number of data bits, k, to be handled in one clock cycle. For a serial implementation, k would be one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
様々なCRC多項式のコストを比較すると、我々は様々なCRC多項式のためのCRCジェネレータ/チェッカーを実装するためにhttp://www.easics.com/webtools/crctoolで利用可能なツールを使用していました。プログラムは、多項式、ならびに1回のクロックサイクルで処理すべきデータビット、K、の数を指定した後VerilogまたはVHDLコードのいずれかを与えます。シリアル実装では、kは1になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cost for either one generator or checker is shown in the following table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つの発電機またはチェッカのいずれかのためのコストは、以下の表に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The number of 2-input XOR gates, for an un-optimized implementation, required for various values of k:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kの各値のために必要な非最適化された実装用の2入力XORゲートの数：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +----------------------------------------------+
   | Polynomial  | k=32     | k=64     | k=128    |
   +----------------------------------------------+
   | CCITT-CRC32 | 488      | 740      | 1430     |
   +----------------------------------------------+
   | IEEE-802    | 872      | 1390     | 2518     |
   +----------------------------------------------+
   | CRC32Q(Wolf)| 944      | 1444     | 2534     |
   +----------------------------------------------+
   | CRC32C      | 1036     | 1470     | 2490     |
   +----------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After optimizing (sharing terms) and in terms of Cells (4 cells per 2 input AND, 7 cells per 2 input XOR, 3 cells per inverter) the cost for two candidate polynomials is shown in the following table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（共有用語）を最適化した後、および細胞（2入力当たり4個の細胞及び、2入力XOR当たり7個の細胞、インバータあたり3個の細胞）の観点から2つの候補多項式のためのコストを以下の表に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------------------------+
   | Polynomial  | k=32     | k=64     |
   +-----------------------------------+
   | CCITT-CRC32 | 1855     | 3572     |
   +-----------------------------------+
   | CRC32C      | 4784     | 7111     |
   +-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For 32-bit datapath, CCITT-CRC32 requires 40% of the number of cells required by the CRC32C. For a 64-bit datapath, CCITT-CRC32 requires 50% of the number of cells.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
32ビットのデータパスのために、CCITT-CRC32はCRC32Cによって必要とされる細胞の数の40％を必要とします。 64ビットデータパスのために、CCITT-CRC32は、細胞の数の50％を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The total size of one of our smaller chips is roughly 1 million cells. The fraction represented by the CRC circuit is less than 1%.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちの小さなチップの1つの合計サイズは、およそ100万個の細胞です。 CRC回路で表される画分が1％未満です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Implementation of CRC32C
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
CRC32Cの8.実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 A Serial Implementation in Hardware
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1ハードウェアで実装シリアル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A serial implementation that processes one data bit at a time and performs simultaneous multiplication of the data polynomial by x^32 and division by the CRC32C polynomial is described in the following Verilog [ieee1364] code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一度に1つのデータビットを処理し、CRC32C多項式でX ^ 32と分割することにより、データ多項式の同時乗算を行うシリアル実装は、以下のVerilog [ieee1364]コードに記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /////////////////////////////////////////////////////////////////////
   //File: CRC32_D1.v
   //Date: Tue Feb 26 02:47:05 2002
   //
   //Copyright (C) 1999 Easics NV.
   //This source file may be used and distributed without restriction
   //provided that this copyright statement is not removed from the file
   //and that any derivative work contains the original copyright notice
   //and the associated disclaimer.
   //
   //THIS SOURCE FILE IS PROVIDED &#34;AS IS&#34; AND WITHOUT ANY EXPRESS
   //OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   //WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   //
   //Purpose: Verilog module containing a synthesizable CRC function
   //* polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)
   //* data width: 1
   //
   //Info: jand@easics.be (Jan Decaluwe)
   //http://www.easics.com
   /////////////////////////////////////////////////////////////////////
   module CRC32_D1;
   // polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)
   // data width: 1
   function [31:0] nextCRC32_D1;
   input Data;
   input [31:0] CRC;
   reg [0:0] D;
   reg [31:0] C;
   reg [31:0] NewCRC;
   begin
   D[0] = Data;
   C = CRC;
   NewCRC[0] = D[0] ^ C[31];
   NewCRC[1] = D[0] ^ C[0] ^ C[31];
   NewCRC[2] = D[0] ^ C[1] ^ C[31];
   NewCRC[3] = C[2];
   NewCRC[4] = D[0] ^ C[3] ^ C[31];
   NewCRC[5] = D[0] ^ C[4] ^ C[31];
   NewCRC[6] = C[5];
   NewCRC[7] = D[0] ^ C[6] ^ C[31];
   NewCRC[8] = D[0] ^ C[7] ^ C[31];
   NewCRC[9] = C[8];
   NewCRC[10] = D[0] ^ C[9] ^ C[31];
   NewCRC[11] = D[0] ^ C[10] ^ C[31];
   NewCRC[12] = D[0] ^ C[11] ^ C[31];
   NewCRC[13] = C[12];
   NewCRC[14] = C[13];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   NewCRC[15] = C[14];
   NewCRC[16] = D[0] ^ C[15] ^ C[31];
   NewCRC[17] = C[16];
   NewCRC[18] = C[17];
   NewCRC[19] = C[18];
   NewCRC[20] = C[19];
   NewCRC[21] = C[20];
   NewCRC[22] = D[0] ^ C[21] ^ C[31];
   NewCRC[23] = D[0] ^ C[22] ^ C[31];
   NewCRC[24] = C[23];
   NewCRC[25] = C[24];
   NewCRC[26] = D[0] ^ C[25] ^ C[31];
   NewCRC[27] = C[26];
   NewCRC[28] = C[27];
   NewCRC[29] = C[28];
   NewCRC[30] = C[29];
   NewCRC[31] = C[30];
   nextCRC32_D1 = NewCRC;
   end
   endfunction
   endmodule
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 A Parallel Implementation in Hardware
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2ハードウェアでの並列化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A parallel implementation that processes 32 data bits at a time is described in the following Verilog [ieee1364] code. In software implementations, the next state logic is typically implemented by means of tables indexed by the input and the current state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一度に32個のデータビットを処理する並列実装は、次のVerilog [ieee1364]コードに記載されています。ソフトウェア実装では、次の状態ロジックは、典型的には、入力及び現在状態によってインデックス付けテーブルを用いて実現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /////////////////////////////////////////////////////////////////////
   //File: CRC32_D32.v
   //Date: Tue Feb 26 02:50:08 2002
   //
   //Copyright (C) 1999 Easics NV.
   //This source file may be used and distributed without restriction
   //provided that this copyright statement is not removed from the file
   //and that any derivative work contains the original copyright notice
   //and the associated disclaimer.
   //
   //THIS SOURCE FILE IS PROVIDED &#34;AS IS&#34; AND WITHOUT ANY EXPRESS
   //OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   //WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   //
   //Purpose: Verilog module containing a synthesizable CRC function
   //* polynomial: p(0 to 32) := &#34;100000101111011000111011011110001&#34;
   //* data width: 32
   //
   //Info: jand@easics.be (Jan Decaluwe)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   //http://www.easics.com
   /////////////////////////////////////////////////////////////////////
   module CRC32_D32;
   // polynomial: p(0 to 32) := &#34;100000101111011000111011011110001&#34;
   // data width: 32
   // convention: the first serial data bit is D[31]
   function [31:0] nextCRC32_D32;
   input [31:0] Data;
   input [31:0] CRC;
   reg [31:0] D;
   reg [31:0] C;
   reg [31:0] NewCRC;
   begin
   D = Data;
   C = CRC;
   NewCRC[0] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^ D[23]
   ^
   D[21] ^ D[18] ^ D[17] ^ D[16] ^ D[12] ^ D[9] ^ D[8] ^
   D[7] ^ D[6] ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^ C[4] ^ C[5] ^
   C[6] ^ C[7] ^ C[8] ^ C[9] ^ C[12] ^ C[16] ^ C[17] ^
   C[18] ^ C[21] ^ C[23] ^ C[25] ^ C[26] ^ C[27] ^ C[28] ^
   C[30] ^ C[31];
   NewCRC[1] = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[26] ^ D[24] ^ D[22]
   ^
   D[19] ^ D[18] ^ D[17] ^ D[13] ^ D[10] ^ D[9] ^ D[8] ^
   D[7] ^ D[6] ^ D[5] ^ D[1] ^ C[1] ^ C[5] ^ C[6] ^ C[7] ^
   C[8] ^ C[9] ^ C[10] ^ C[13] ^ C[17] ^ C[18] ^ C[19] ^
   C[22] ^ C[24] ^ C[26] ^ C[27] ^ C[28] ^ C[29] ^ C[31];
   NewCRC[2] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[23] ^ D[20]
   ^
   D[19] ^ D[18] ^ D[14] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^
   D[7] ^ D[6] ^ D[2] ^ C[2] ^ C[6] ^ C[7] ^ C[8] ^ C[9] ^
   C[10] ^ C[11] ^ C[14] ^ C[18] ^ C[19] ^ C[20] ^ C[23] ^
   C[25] ^ C[27] ^ C[28] ^ C[29] ^ C[30];
   NewCRC[3] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[24] ^ D[21]
   ^
   D[20] ^ D[19] ^ D[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^
   D[8] ^ D[7] ^ D[3] ^ C[3] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^
   C[11] ^ C[12] ^ C[15] ^ C[19] ^ C[20] ^ C[21] ^ C[24] ^
   C[26] ^ C[28] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[4] = D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[25] ^ D[22] ^ D[21]
   ^
   D[20] ^ D[16] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^
   D[8] ^ D[4] ^ C[4] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^
   C[12] ^ C[13] ^ C[16] ^ C[20] ^ C[21] ^ C[22] ^ C[25] ^
   C[27] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[5] = D[31] ^ D[30] ^ D[28] ^ D[26] ^ D[23] ^ D[22] ^ D[21]
   ^
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^
   D[5] ^ C[5] ^ C[9] ^ C[10] ^ C[11] ^ C[12] ^ C[13] ^
   C[14] ^ C[17] ^ C[21] ^ C[22] ^ C[23] ^ C[26] ^ C[28] ^
   C[30] ^ C[31];
   NewCRC[6] = D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[22]
   ^
   D[21] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[13] ^ D[11] ^
   D[10] ^ D[9] ^ D[8] ^ D[7] ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^
   C[4] ^ C[5] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^
   C[13] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[21] ^ C[22] ^
   C[24] ^ C[25] ^ C[26] ^ C[28] ^ C[29] ^ C[30];
   NewCRC[7] = D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[23]
   ^
   D[22] ^ D[18] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[12] ^
   D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^ D[5] ^ D[1] ^
   C[1] ^ C[5] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^
   C[12] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[18] ^ C[22] ^
   C[23] ^ C[25] ^ C[26] ^ C[27] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[8] = D[25] ^ D[24] ^ D[21] ^ D[19] ^ D[15] ^ D[13] ^ D[11]
   ^
   D[10] ^ D[8] ^ D[5] ^ D[4] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^
   C[4] ^ C[5] ^ C[8] ^ C[10] ^ C[11] ^ C[13] ^ C[15] ^
   C[19] ^ C[21] ^ C[24] ^ C[25];
   NewCRC[9] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[23] ^ D[22] ^ D[21]
   ^
   D[20] ^ D[18] ^ D[17] ^ D[14] ^ D[11] ^ D[8] ^ D[7] ^
   D[4] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[4] ^
   C[7] ^ C[8] ^ C[11] ^ C[14] ^ C[17] ^ C[18] ^ C[20] ^
   C[21] ^ C[22] ^ C[23] ^ C[27] ^ C[28] ^ C[30] ^ C[31];
   NewCRC[10] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[24] ^
   D[22] ^
   D[19] ^ D[17] ^ D[16] ^ D[15] ^ D[7] ^ D[6] ^ D[2] ^
   D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[6] ^ C[7] ^ C[15] ^
   C[16] ^ C[17] ^ C[19] ^ C[22] ^ C[24] ^ C[25] ^ C[26] ^
   C[27] ^ C[29] ^ C[30];
   NewCRC[11] = D[21] ^ D[20] ^ D[12] ^ D[9] ^ D[6] ^ D[5] ^ D[4] ^
   D[3] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[3] ^
   C[4] ^ C[5] ^ C[6] ^ C[9] ^ C[12] ^ C[20] ^ C[21];
   NewCRC[12] = D[22] ^ D[21] ^ D[13] ^ D[10] ^ D[7] ^ D[6] ^ D[5] ^
   D[4] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^
   C[5] ^ C[6] ^ C[7] ^ C[10] ^ C[13] ^ C[21] ^ C[22];
   NewCRC[13] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^
   D[22] ^
   D[21] ^ D[18] ^ D[17] ^ D[16] ^ D[14] ^ D[12] ^ D[11] ^
   D[9] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[9] ^
   C[11] ^ C[12] ^ C[14] ^ C[16] ^ C[17] ^ C[18] ^ C[21] ^
   C[22] ^ C[25] ^ C[26] ^ C[27] ^ C[28] ^ C[30] ^ C[31];
   NewCRC[14] = D[30] ^ D[29] ^ D[25] ^ D[22] ^ D[21] ^ D[19] ^
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   D[16] ^
   D[15] ^ D[13] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^ D[6] ^
   D[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[5] ^
   C[6] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[13] ^ C[15] ^
   C[16] ^ C[19] ^ C[21] ^ C[22] ^ C[25] ^ C[29] ^ C[30];
   NewCRC[15] = D[31] ^ D[30] ^ D[26] ^ D[23] ^ D[22] ^ D[20] ^
   D[17] ^
   D[16] ^ D[14] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^
   D[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^
   C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^ C[14] ^ C[16] ^
   C[17] ^ C[20] ^ C[22] ^ C[23] ^ C[26] ^ C[30] ^ C[31];
   NewCRC[16] = D[31] ^ D[27] ^ D[24] ^ D[23] ^ D[21] ^ D[18] ^
   D[17] ^
   D[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^
   D[5] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[5] ^ C[7] ^ C[8] ^
   C[9] ^ C[10] ^ C[11] ^ C[12] ^ C[15] ^ C[17] ^ C[18] ^
   C[21] ^ C[23] ^ C[24] ^ C[27] ^ C[31];
   NewCRC[17] = D[28] ^ D[25] ^ D[24] ^ D[22] ^ D[19] ^ D[18] ^
   D[16] ^
   D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^
   D[4] ^ D[3] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^
   C[11] ^ C[12] ^ C[13] ^ C[16] ^ C[18] ^ C[19] ^ C[22] ^
   C[24] ^ C[25] ^ C[28];
   NewCRC[18] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[21] ^
   D[20] ^
   D[19] ^ D[18] ^ D[16] ^ D[14] ^ D[13] ^ D[11] ^ D[10] ^
   D[8] ^ D[6] ^ D[0] ^ C[0] ^ C[6] ^ C[8] ^ C[10] ^ C[11] ^
   C[13] ^ C[14] ^ C[16] ^ C[18] ^ C[19] ^ C[20] ^ C[21] ^
   C[27] ^ C[28] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[19] = D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[23] ^ D[22] ^
   D[20] ^
   D[19] ^ D[18] ^ D[16] ^ D[15] ^ D[14] ^ D[11] ^ D[8] ^
   D[6] ^ D[5] ^ D[4] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[4] ^
   C[5] ^ C[6] ^ C[8] ^ C[11] ^ C[14] ^ C[15] ^ C[16] ^
   C[18] ^ C[19] ^ C[20] ^ C[22] ^ C[23] ^ C[25] ^ C[26] ^
   C[27] ^ C[29];
   NewCRC[20] = D[31] ^ D[25] ^ D[24] ^ D[20] ^ D[19] ^ D[18] ^
   D[15] ^
   D[8] ^ D[4] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^
   C[4] ^ C[8] ^ C[15] ^ C[18] ^ C[19] ^ C[20] ^ C[24] ^
   C[25] ^ C[31];
   NewCRC[21] = D[26] ^ D[25] ^ D[21] ^ D[20] ^ D[19] ^ D[16] ^ D[9]
   ^
   D[5] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[5] ^
   C[9] ^ C[16] ^ C[19] ^ C[20] ^ C[21] ^ C[25] ^ C[26];
   NewCRC[22] = D[31] ^ D[30] ^ D[28] ^ D[25] ^ D[23] ^ D[22] ^
   D[20] ^
   D[18] ^ D[16] ^ D[12] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   D[5] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[5] ^
   C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[12] ^ C[16] ^ C[18] ^
   C[20] ^ C[22] ^ C[23] ^ C[25] ^ C[28] ^ C[30] ^ C[31];
   NewCRC[23] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[24] ^
   D[19] ^
   D[18] ^ D[16] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[7] ^
   D[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[5] ^
   C[7] ^ C[10] ^ C[11] ^ C[12] ^ C[13] ^ C[16] ^ C[18] ^
   C[19] ^ C[24] ^ C[25] ^ C[27] ^ C[28] ^ C[29] ^ C[30];
   NewCRC[24] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^
   D[20] ^
   D[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[8] ^
   D[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^
   C[8] ^ C[11] ^ C[12] ^ C[13] ^ C[14] ^ C[17] ^ C[19] ^
   C[20] ^ C[25] ^ C[26] ^ C[28] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[25] = D[29] ^ D[28] ^ D[25] ^ D[23] ^ D[20] ^ D[17] ^
   D[16] ^
   D[15] ^ D[14] ^ D[13] ^ D[8] ^ D[6] ^ D[4] ^ D[3] ^
   D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^
   C[13] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^ C[23] ^
   C[25] ^ C[28] ^ C[29];
   NewCRC[26] = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[24] ^
   D[23] ^
   D[15] ^ D[14] ^ D[12] ^ D[8] ^ D[6] ^ D[3] ^ D[1] ^
   D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[6] ^ C[8] ^ C[12] ^ C[14] ^
   C[15] ^ C[23] ^ C[24] ^ C[25] ^ C[27] ^ C[28] ^ C[29] ^
   C[31];
   NewCRC[27] = D[31] ^ D[29] ^ D[27] ^ D[24] ^ D[23] ^ D[21] ^
   D[18] ^
   D[17] ^ D[15] ^ D[13] ^ D[12] ^ D[8] ^ D[6] ^ D[5] ^
   D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[5] ^ C[6] ^
   C[8] ^ C[12] ^ C[13] ^ C[15] ^ C[17] ^ C[18] ^ C[21] ^
   C[23] ^ C[24] ^ C[27] ^ C[29] ^ C[31];
   NewCRC[28] = D[31] ^ D[27] ^ D[26] ^ D[24] ^ D[23] ^ D[22] ^
   D[21] ^
   D[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[8] ^ D[5] ^
   D[4] ^ D[3] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^
   C[3] ^ C[4] ^ C[5] ^ C[8] ^ C[12] ^ C[13] ^ C[14] ^
   C[17] ^ C[19] ^ C[21] ^ C[22] ^ C[23] ^ C[24] ^ C[26] ^
   C[27] ^ C[31];
   NewCRC[29] = D[28] ^ D[27] ^ D[25] ^ D[24] ^ D[23] ^ D[22] ^
   D[20] ^
   D[18] ^ D[15] ^ D[14] ^ D[13] ^ D[9] ^ D[6] ^ D[5] ^
   D[4] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^
   C[5] ^ C[6] ^ C[9] ^ C[13] ^ C[14] ^ C[15] ^ C[18] ^
   C[20] ^ C[22] ^ C[23] ^ C[24] ^ C[25] ^ C[27] ^ C[28];
   NewCRC[30] = D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[23] ^
   D[21] ^
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   D[19] ^ D[16] ^ D[15] ^ D[14] ^ D[10] ^ D[7] ^ D[6] ^
   D[5] ^ D[4] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[4] ^ C[5] ^
   C[6] ^ C[7] ^ C[10] ^ C[14] ^ C[15] ^ C[16] ^ C[19] ^
   C[21] ^ C[23] ^ C[24] ^ C[25] ^ C[26] ^ C[28] ^ C[29];
   NewCRC[31] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[24] ^
   D[22] ^
   D[20] ^ D[17] ^ D[16] ^ D[15] ^ D[11] ^ D[8] ^ D[7] ^
   D[6] ^ D[5] ^ D[4] ^ D[3] ^ C[3] ^ C[4] ^ C[5] ^ C[6] ^
   C[7] ^ C[8] ^ C[11] ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^
   C[22] ^ C[24] ^ C[25] ^ C[26] ^ C[27] ^ C[29] ^ C[30];
   nextCRC32_D32 = NewCRC;
   end
   endfunction
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3 Some Hardware Implementation Comments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3いくつかのハードウェア実装のコメント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The iSCSI spec specifies that the most significant 32 bits of the data be complemented prior to performing the CRC computation. For most implementations of the CRC algorithm, such as the ones described here, which perform simultaneous multiplication by x^32 and division by the CRC polynomial, this is equivalent to initializing the CRC register to ones regardless of the CRC polynomial. For other implementations, in particular one that only performs division by the CRC polynomial (and for which the prescribed multiplication by x^32 is performed externally) initializing the CRC register to ones does not have the same effect as complementing the most significant 32 bits of the message. With such implementations, for the CRC32c polynomial, initializing the CRC register to 0x2a26f826 has the same effect as complementing the most significant 32 bits of the data. See reference [Tuikov&amp;Cavanna] for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iSCSIの仕様は、データの上位32ビットがCRC演算を実行する前に補完するように指定します。このようなCRC多項式でX ^ 32及び分割により同時乗算を実行ここで説明されたもののようなCRCアルゴリズムのほとんどの実装については、これはCRCに関係なくCRC多項式のものに登録する初期化に相当します。のみCRC多項式で除算を行う特定の一つに他の実装のための最も重要な32ビットを補完するようにCRCが同じ効果を有していないものに登録する初期化（及びそのためのX ^ 32により所定の乗算が外部で実行されます）メッセージ。 0x2a26f826にCRCレジスタを初期化CRC32C多項式のためのそのような実装、とデータの最上位32ビットを補完するのと同じ効果を有します。詳細は、リファレンス[Tuikov＆Cavanna]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4 Fast Hardware Implementation References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4高速ハードウェア実装参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fast hardware implementations start from a canonic scheme (as the one presented in 7.2) and optimize it based on different criteria. Two classic papers on this subject are [Albertengo1990] and [Glaise1997]. A more modern (and systematic) approach can be found in [Shie2001] and [Sprachman2001].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速ハードウェア実装は（7.2に提示された1つのような）カノンスキームから開始し、異なる基準に基づいて最適化します。この主題上の2本の古典的な論文が[Albertengo1990]で、[Glaise1997]。より現代的な（かつ体系）アプローチは、[Sprachman2001] [Shie2001]に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Summary and Conclusions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.まとめと結論
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following table is a summary of the error detection capabilities of the different codes analyzed. In the table, d is the minimal distance at block length block (in bits), i/byte - software instructions/byte, Table size (if table lookup needed), T-look number of lookups/byte, Pudb - Pud burst and Puds - Pud sporadic:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の表は、分析異なるコードのエラー検出機能の概要です。検索/バイトのTルック番号、Pudb、ソフトウェア命令/バイト、テーブルサイズ（テーブルルックアップが必要な場合） -   - 表において、Dは、ブロック長ブロック（ビットで）、I /バイトに最小距離でPUDバーストとたPUD  -  PUDは散発：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------------------------------------------------+
   | Code      |d| Block |i/Byte|Tsize|T-look| Pudb   | Puds   |
   +-----------------------------------------------------------+
   | Fletcher32|3| 2^19  | 2    |  -  | -    | 10^-37 | 10^-36 |
   +-----------------------------------------------------------+
   | Adler32   |3| 2^19  | 3    |  -  | -    | 10^-36 | 10^-35 |
   +-----------------------------------------------------------+
   | IEEE-802  |3| 2^16  | 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |
   +-----------------------------------------------------------+
   | CRC32C    |3| 2^31-1| 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |
   +-----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probabilities for undetected errors in the above table are computed assuming uniformly distributed data. For real data - that can be biased - [Stone98], checksums behave substantially worse than CRCs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記表中の未検出のエラーの確率は一様に分布データを仮定して計算されます。バイアスをかけることができます -   - 実際のデータについて[Stone98]、チェックサムは、CRCのよりも実質的に悪化振る舞います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering the protection level it offers, the lack of sensitivity for biased data and the large block it can protect, we think that CRC32C is a good choice as a basic error detection mechanism for iSCSI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが提供する保護レベルを考慮すると、バイアスされたデータと、それが保護することができ、大きなブロックの感度の欠如は、我々はCRC32Cは、iSCSIの基本的なエラー検出メカニズムとしては良い選択だと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Please observe also that burst errors characterized by a fixed average time will have a higher impact on error detection capability as the speed of the channels (machines and networks) increases. The only way to keep the Pud within bounds for the long-term is to reduce the BER by using better coding of lower levels of the channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャネル（マシンとネットワーク）の速度が増加するように固定された平均時間によって特徴付けそのバーストエラーは、エラー検出能力に高い影響を与えるも遵守してください。長期の境界内PUDを維持する唯一の方法は、チャネルのより低いレベルのより良好な符号化を用いてBERを低減することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These codes detect unintentional changes to data such as those caused by noise. In an environment where an attacker can change the data, it can also change the error-detection code to match the new data. Therefore, the error-detection codes overviewed here do not provide protection against attacks. Indeed, these codes are not intended for security purposes; they are meant to be used within some application, and the application&#39;s threat model and security design control the security considerations for the use of the CRC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのコードは、このようなノイズに起因するもののようなデータへの意図しない変更を検出します。攻撃者がデータを変更することができる環境では、それはまた、新しいデータを一致させるために、エラー検出コードを変更することができます。したがって、ここで概観エラー検出コードは、攻撃に対する保護を提供していません。確かに、これらのコードは、セキュリティ目的のために意図されていません。彼らはいくつかのアプリケーション内で使用されることを意味し、そしてアプリケーションの脅威モデルとセキュリティ設計は、CRCを使用するためのセキュリティの考慮事項を制御しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. References and Bibliography
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.参考文献と文献目録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Albertengo1990] G. Albertengo, R. Sisto, &#34;Parallel CRC Generation IEEE Micro&#34;, Vol. 10, No. 5, October 1990, pp. 63- 71.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Albertengo1990] G. Albertengo、R.シスト、 &#34;パラレルCRCジェネレーションIEEEマイクロ&#34;、巻。 10、第5号、1990年10月、頁。63- 71。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Arazi] B Arazi, &#34;A commonsense Approach to the Theory of Error Correcting codes&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Arazi] B Arazi、「誤り訂正符号の理論に常識的なアプローチ」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Baicheva] T Baicheva, S Dodunekov and P Kazakov, &#34;Undetected error probability performance of cyclic redundancy-check codes of 16-bit redundancy&#34;, IEEE Proceedings on Communications, 147:253-256, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Baicheva] T Baicheva、S Dodunekov及びP Kazakov、「16ビットの冗長性の巡回冗長検査符号の未検出誤り確率性能」、通信に関するIEEE会報、147：253-256、2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Black] &#34;Fast CRC32 in Software&#34; by Richard Black, 1994, at www.cl.cam.ac.uk/Research/SRG/bluebook/21/crc/crc. html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
www.cl.cam.ac.uk/Research/SRG/bluebook/21/crc/crcでリチャード・ブラック、1994による「ソフトウェアにおける高速CRC32」[ブラック]、。 HTML。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Castagnoli93] Guy Castagnoli, Stefan Braeuer and Martin Herrman &#34;Optimization of Cyclic Redundancy-Check Codes with 24 and 32 Parity Bits&#34;, IEEE Transact. on Communications, Vol. 41, No. 6, June 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Castagnoli93]ガイCastagnoli、ステファンBraeuerとマーティンHerrman「24と32パリティビットと巡回冗長検査符号の最適化」、IEEEのTransact。コミュニケーション、巻上。 41、第6号、1993年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[braun01] Florian Braun and Marcel Waldvogel, &#34;Fast Incremental CRC Updates for IP over ATM Networks&#34;, IEEE, High Performance Switching and Routing, 2001, pp. 48-52.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[braun01]フロリアン・ブラウンとマルセルWaldvogel、 &#34;ATMネットワーク上のIPのための高速増分CRC更新&#34;、IEEE、高性能スイッチングおよびルーティング、2001年、頁48-52。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FITS] &#34;NASA FITS documents&#34; at http://heasarc.gsfc.nasa. gov/docs/heasarc/ofwg/docs/general/checksum/node26. html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FITS]のhttpで &#34;NASAは、文書をFITS&#34;：//heasarc.gsfc.nasaを。 GOV /ドキュメント/ heasarc / ofwg /ドキュメント/一般/サム/ node26。 HTML。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Fujiwara89] Toru Fujiwara, Tadao Kasami, and Shu Lin, &#34;Error detecting capabilities of the shortened hamming codes adopted forerror detection in IEEE standard 802.3&#34;, IEEE Transactions on Communications, COM-37:986989, September 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Fujiwara89]徹藤原、嵩忠雄、及びシュウリン、「IEEEで検出forerror採用短縮ハミング符号の誤り検出能力標準802.3」、コミュニケーションズ、COM-37上のIEEEトランザクション：986989、1989年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Glaise1997] Glaise, R. J., &#34;A two-step computation of cyclic redundancy code CRC-32 for ATM networks&#34;, IBM Journal of Research and Development, Volume 41, Number 6, 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Glaise1997] Glaise、R. J.、 &#34;ATMネットワークのための巡回冗長コードCRC-32の二段階の計算&#34;、研究開発のIBMジャーナル、41巻、第6号、1997。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ieee1364] IEEE Standard Hardware Description Language Based on the Verilog Hardware Description Language, IEEE Standard 1364-1995, December 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Verilogのハードウェア記述言語に基づいて、[ieee1364] IEEE標準のハードウェア記述言語、IEEE規格1364年から1995年、1995年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LinCostello] S. Lin and D.J. Costello, Jr., &#34;Error Control Coding: Fundamentals and Applications&#34;, Englewood Cliffs, NJ: Prentice Hall, 1983.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【LinCostello] S.リンおよびD.J.コステロ、ジュニア、「エラー制御コーディング：基礎と応用」、イングルウッドクリフス、ニュージャージー州：プレンティスホール、1983。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Peterson] W Wesley Peterson &amp; E J Weldon - Error Correcting Codes - First Edition 1961/Second Edition 1972.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ピーターソン] Wウェズリー・ピーターソン＆E Jウェルドン - 誤り訂正符号 -  1972初版1961年/第二版。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2026] Bradner, S., &#34;The Internet Standards Process -- Revision 3&#34;, BCP 9, RFC 2026, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2026]ブラドナーの、S.、 &#34;インターネット標準化プロセス - リビジョン3&#34;、BCP 9、RFC 2026、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ritter] Ritter, T. 1986. The Great CRC Mystery. Dr. Dobb&#39;s Journal of Software Tools. February. 11(2): 26-34, 76-83.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[リッター]リッター、T. 1986年グレートCRCミステリー。ソフトウェアツールの博士ドッブのジャーナル。 2月。 11（2）：26-34、76-83。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Polynomials] &#34;Information on Primitive and Irreducible Polynomials&#34; at http://www.theory.csc.uvic.ca/~cos/ inf/neck/PolyInfo.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[多項式] http://www.theory.csc.uvic.ca/~cos/ INF /首/ PolyInfo.htmlで「原始及び既約多項式に関する情報」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1146] Zweig, J. and C. Partridge, &#34;TCP Alternate Checksum Options&#34;, RFC 1146, March 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1146]ツヴァイク、J.とC.ヤマウズラ、 &#34;TCP代替チェックサムオプション&#34;、RFC 1146、1990年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1950] Deutsch, P. and J. Gailly, &#34;ZLIB Compressed Data Format Specification version 3.3&#34;, RFC 1950, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1950]ドイツ、P.およびJ. Gailly氏、 &#34;ZLIB圧縮データフォーマット仕様バージョン3.3&#34;、RFC 1950、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Shie2001] Ming-Der Shieh, et. al, &#34;A Systematic Approach for Parallel CRC Computations&#34;, Journal of Information Science and Engineering, Vol.17 No.3, pp.445-461.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Shie2001]明デアShiehら。ら、「並列CRC計算のための体系的なアプローチ」、情報科学や工学ジャーナル、Vol.17 3号、pp.445-461。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sprachman2001] Michael Sprachman, &#34;Automatic Generation of Parallel CRC Circuits&#34;, IEEE Design &amp; Test May-June 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sprachman2001]マイケルSprachman、「並列CRC回路の自動生成、」IEEEデザイン＆テスト月 -  6月の第二千一
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Stone98] J. Stone et. al., &#34;Performance of Checksums and CRC&#39;s over Real Data&#34;, IEEE/ACM Transactions on Networking, Vol. 6, No. 5, October 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Stone98] J.ストーンら。ら、「実データオーバーチェックサムとCRCののパフォーマンス」、ネットワーキング、巻上のIEEE / ACM取引。 6、第5号、1998年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Williams] Ross Williams - A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS widely available on the net - (e.g., ftp.adelaide.edu.au/pub/rocksoft/crc_v3.txt)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【ウィリアムズ】ロス・ウィリアムズ - （例えば、ftp.adelaide.edu.au/pub/rocksoft/crc_v3.txt） - ネット上で広く利用可能なCRCエラー検出アルゴリズム無痛GUIDE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf82] J.K. Wolf, Arnold Michelson and Allen Levesque, &#34;On the probability of undetected error for linear block codes&#34;, IEEE Transactions on Communications, COM-30: 317-324, 1982.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Wolf82] J.K.ウルフ、アーノルド・マイケルソンとアレンレベスク、「線形ブロック符号の見逃し誤り確率について」、通信に関するIEEEトランザクション、COM-30：317-324、1982。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf88] J.K. Wolf, R.D. Blackeney, &#34;An Exact Evaluation of the Probability of Undetected Error for Certain Shortened Binary CRC Codes&#34;, Proc. MILCOM - IEEE 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Wolf88] J.K.ウルフ、R.D. Blackeney、「特定の短縮バイナリCRCコードのための見逃し誤り確率の正確な評価」、PROC。 MILCOM  -  IEEE 1988。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf94J] J.K. Wolf and Dexter Chun, &#34;The single burst error detection performance of binary cyclic codes&#34;, IEEE Transactions on Communications COM-42:11-13, January 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Wolf94J] J.K.通信COM-42に狼とデクスターチョン、「二進巡回符号の単一バースト誤り検出性能」、IEEEトランザクション：11-13、1994年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf94O] Dexter Chun and J.K. Wolf, &#34;Special Hardware for computing the probability of undetected error for certain binary crc codes and test results&#34;, IEEE Transactions on Communications, COM-42:2769-2772.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Wolf94O]デクスターチュンとJ.K.オオカミ、「特定のバイナリCRCコードとテスト結果の未検出誤り確率を計算するための特別なハードウェア」、通信に関するIEEEトランザクション、COM-42：2769から2772。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Tuikov&amp;Cavanna] Luben Tuikov and Vicente Cavanna, &#34;The iSCSI CRC32C Digest and the Simultaneous Multiply and Divide Algorithm&#34;, January 30, 2002. White paper distributed to the IETF ips iSCSI reflector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Tuikov＆Cavanna] Luben TuikovとビセンテCavanna、「iSCSIのCRC32Cダイジェストと同時乗アルゴリズムを分割」、1月30日IETF IPSのiSCSIリフレクタに配布2002ホワイトペーパー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We would like to thank Matt Wakeley for providing us with the motivation to co-author this paper and for helpful discussions on the subject matter, during his employment with Agilent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、アジレントとの彼の雇用の間に、共著者にモチベーションでこの論文を私たちに提供するための主題に有用な議論のためのマットWakeleyに感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.著者のアドレス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Julian Satran IBM, Haifa Research Lab MATAM - Advanced Technology Center Haifa 31905, Israel EMail: julian_satran@il.ibm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジュリアンSatran IBM、ハイファ研究所マタム - アドバンスト・テクノロジー・センターハイファ31905、イスラエルメール：julian_satran@il.ibm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dafna Sheinwald IBM, Haifa Research Lab MATAM - Advanced Technology Center Haifa 31905, Israel EMail: Dafna_Sheinwald@il.ibm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DAFNA Sheinwald IBM、ハイファ研究所マタム - アドバンスト・テクノロジー・センターハイファ31905、イスラエルメール：Dafna_Sheinwald@il.ibm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pat Thaler Agilent Technologies 1101 Creekside Ridge Drive Suite 100, M/S RH21 Roseville, CA 95661 EMail: pat_thaler@agilent.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パットターラーアジレント・テクノロジー1101クリークサイドリッジドライブスイート100、M / S RH21ローズ、CA 95661 Eメール：pat_thaler@agilent.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vicente Cavanna Agilent Technologies 1101 Creekside Ridge Drive Suite 100, M/S RH21 Roseville, CA 95661 EMail: vince_cavanna@agilent.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビセンテCavannaアジレント・テクノロジー1101クリークサイドリッジドライブスイート100、M / S RH21ローズ、CA 95661 Eメール：vince_cavanna@agilent.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.完全な著作権声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2002). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2002）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
