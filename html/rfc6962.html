<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 6962 - Certificate Transparency 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6962 - Certificate Transparency 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc6962">
              https://tools.ietf.org/html/rfc6962
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6962 - 証明書の透明性</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         B. Laurie
Request for Comments: 6962                                    A. Langley
Category: Experimental                                         E. Kasper
ISSN: 2070-1721                                                   Google
                                                               June 2013
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        Certificate Transparency
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes an experimental protocol for publicly logging the existence of Transport Layer Security (TLS) certificates as they are issued or observed, in a manner that allows anyone to audit certificate authority (CA) activity and notice the issuance of suspect certificates as well as to audit the certificate logs themselves. The intent is that eventually clients would refuse to honor certificates that do not appear in a log, effectively forcing CAs to add all issued certificates to the logs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、彼らはだけでなく、誰もが容疑者証明書の発行を認証局（CA）の活動を監査し、気づくことを可能にする方法で、発行または観察されるような公にトランスポート層セキュリティ（TLS）証明書の存在を記録するための実験プロトコルを記述します証明書のログそのものを監査します。その意図は、最終的にはクライアントが効果的にログにすべて発行された証明書を追加するCAを強制的に、ログに表示されていない証明書を尊重することを拒否だろうということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Logs are network services that implement the protocol operations for submissions and queries that are defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログは、この文書で定義されている提出し、クエリのためのプロトコル動作を実現するネットワークサービスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6962.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6962で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Informal Introduction ...........................................3
      1.1. Requirements Language ......................................4
      1.2. Data Structures ............................................4
   2. Cryptographic Components ........................................4
      2.1. Merkle Hash Trees ..........................................4
           2.1.1. Merkle Audit Paths ..................................5
           2.1.2. Merkle Consistency Proofs ...........................6
           2.1.3. Example .............................................7
           2.1.4. Signatures ..........................................8
   3. Log Format and Operation ........................................9
      3.1. Log Entries ................................................9
      3.2. Structure of the Signed Certificate Timestamp .............12
      3.3. Including the Signed Certificate Timestamp in the
           TLS Handshake .............................................13
           3.3.1. TLS Extension ......................................15
      3.4. Merkle Tree ...............................................15
      3.5. Signed Tree Head ..........................................16
   4. Log Client Messages ............................................17
      4.1. Add Chain to Log ..........................................17
      4.2. Add PreCertChain to Log ...................................18
      4.3. Retrieve Latest Signed Tree Head ..........................18
      4.4. Retrieve Merkle Consistency Proof between Two
           Signed Tree Heads .........................................19
      4.5. Retrieve Merkle Audit Proof from Log by Leaf Hash .........19
      4.6. Retrieve Entries from Log .................................20
      4.7. Retrieve Accepted Root Certificates .......................21
      4.8. Retrieve Entry+Merkle Audit Proof from Log ................21
   5. Clients ........................................................21
      5.1. Submitters ................................................22
      5.2. TLS Client ................................................22
      5.3. Monitor ...................................................22
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      5.4. Auditor ...................................................23
   6. IANA Considerations ............................................23
   7. Security Considerations ........................................23
      7.1. Misissued Certificates ....................................24
      7.2. Detection of Misissue .....................................24
      7.3. Misbehaving Logs ..........................................24
   8. Efficiency Considerations ......................................25
   9. Future Changes .................................................25
   10. Acknowledgements ..............................................25
   11. References ....................................................25
      11.1. Normative Reference ......................................25
      11.2. Informative References ...................................26
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Informal Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.非公式はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Certificate transparency aims to mitigate the problem of misissued certificates by providing publicly auditable, append-only, untrusted logs of all issued certificates. The logs are publicly auditable so that it is possible for anyone to verify the correctness of each log and to monitor when new certificates are added to it. The logs do not themselves prevent misissue, but they ensure that interested parties (particularly those named in certificates) can detect such misissuance. Note that this is a general mechanism, but in this document, we only describe its use for public TLS server certificates issued by public certificate authorities (CAs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明書の透明性は、公的監査提供することで、すべての発行された証明書の追加のみ、信頼されていないログをmisissued証明書の問題を軽減することを目指しています。誰もがそれぞれのログの正しさを検証するために、新たな証明書がそれに追加されたときに監視することが可能であるようにログが公に監査可能です。ログ自体はmisissueを防ぐことはできませんが、利害関係者（証明書で指定された特に）は、このようなmisissuanceを検出することができることを確認してください。これは一般的なメカニズムですが、この文書では、我々は唯一の公共証明機関（CA）が発行した公開TLSサーバ証明書のためのその使用を記載していることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each log consists of certificate chains, which can be submitted by anyone. It is expected that public CAs will contribute all their newly issued certificates to one or more logs; it is also expected that certificate holders will contribute their own certificate chains. In order to avoid logs being spammed into uselessness, it is required that each chain is rooted in a known CA certificate. When a chain is submitted to a log, a signed timestamp is returned, which can later be used to provide evidence to clients that the chain has been submitted. TLS clients can thus require that all certificates they see have been logged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ログは誰でも提出することができる証明書チェーン、から構成されています。パブリックCAが1つ以上のログにすべての彼らの新たに発行された証明書を貢献することが期待されます。また、証明書の所有者が自分自身の証明書チェーンに貢献することが期待されます。無駄にスパムされているログを回避するために、それぞれの鎖は、既知のCA証明書に根ざしていることが必要です。チェーンがログに提出された場合、署名のタイムスタンプは、後にチェーンが送信されたクライアントに証拠を提供するために使用することができ、返されます。 TLSクライアントは、このように、彼らが見たすべての証明書が記録されていることを要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Those who are concerned about misissue can monitor the logs, asking them regularly for all new entries, and can thus check whether domains they are responsible for have had certificates issued that they did not expect. What they do with this information, particularly when they find that a misissuance has happened, is beyond the scope of this document, but broadly speaking, they can invoke existing business mechanisms for dealing with misissued certificates. Of course, anyone who wants can monitor the logs and, if they believe a certificate is incorrectly issued, take action as they see fit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
misissue心配している人は、すべての新しいエントリのために定期的にそれらを求めて、ログを監視することができ、したがって、彼らは、彼らが期待していなかったことに発行された証明書を持っていたために責任があるドメインかどうかを確認することができます。彼らはmisissuanceが起こっていることを見つける場合は特に、彼らは、この情報をどう、このドキュメントの範囲を超えていますが、大まかに言えば、彼らはmisissued証明書に対処するための既存のビジネスの仕組みを呼び出すことができます。彼らは、彼らが合うように行動を取る、証明書が不正に発行されたと考えている場合はもちろん、したい人には、ログを監視することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Similarly, those who have seen signed timestamps from a particular log can later demand a proof of inclusion from that log. If the log is unable to provide this (or, indeed, if the corresponding certificate is absent from monitors&#39; copies of that log), that is evidence of the incorrect operation of the log. The checking operation is asynchronous to allow TLS connections to proceed without delay, despite network connectivity issues and the vagaries of firewalls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、特定のログから署名されたタイムスタンプを見た人は、後にそのログから介在物の証拠を要求することができます。ログは、（対応する証明書は、そのログのモニターのコピーに存在しない場合に、実際に、または）これを提供できない場合、そのログの誤操作の証拠です。動作確認は、ネットワーク接続の問題やファイアウォールの気まぐれにもかかわらず、TLS接続が遅延なく進行させるために非同期です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The append-only property of each log is technically achieved using Merkle Trees, which can be used to show that any particular version of the log is a superset of any particular previous version. Likewise, Merkle Trees avoid the need to blindly trust logs: if a log attempts to show different things to different people, this can be efficiently detected by comparing tree roots and consistency proofs. Similarly, other misbehaviors of any log (e.g., issuing signed timestamps for certificates they then don&#39;t log) can be efficiently detected and proved to the world at large.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ログの追加のみプロパティは、技術ログの任意の特定のバージョンは、任意の特定の旧バージョンのスーパーセットであることを示すために使用することができるハッシュ木を用いて達成されます。同様に、ハッシュ木は盲目的に信頼ログへの必要性を回避：ログが、これは効率的に樹木の根と一貫性の証明を比較することによって検出することができ、さまざまな人々に異なった事を示してしようとした場合。同様に、任意のログの他の誤作動（例えば、それらは次にログインしない証明書の署名されたタイムスタンプを発行する）を効率的に検出し、広く世界に証明することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますRFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Data Structures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。データ構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Data structures are defined according to the conventions laid out in Section 4 of [RFC5246].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データ構造は[RFC5246]のセクション4にレイアウト規則に従って定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Cryptographic Components
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.暗号化コンポーネント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Merkle Hash Trees
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。マークル・ハッシュ木
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Logs use a binary Merkle Hash Tree for efficient auditing. The hashing algorithm is SHA-256 [FIPS.180-4] (note that this is fixed for this experiment, but it is anticipated that each log would be able to specify a hash algorithm). The input to the Merkle Tree Hash is a list of data entries; these entries will be hashed to form the leaves of the Merkle Hash Tree. The output is a single 32-byte Merkle Tree Hash. Given an ordered list of n inputs, D[n] = {d(0), d(1), ..., d(n-1)}, the Merkle Tree Hash (MTH) is thus defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログは、効率的な監査のためのバイナリマークル・ハッシュ木を使用しています。ハッシュアルゴリズムは、SHA-256 [FIPS.180-4]（これは、この実験のために固定されているが、各ログは、ハッシュアルゴリズムを指定することができるであろうことが予想されることに留意されたい）です。マークル木ハッシュへの入力は、データエントリのリストです。これらのエントリは、マークルハッシュツリーの葉を形成するためにハッシュされます。出力は、単一の32バイトのマークル木のハッシュです。 N個の入力の順序付けられたリストが与えられると、D [N] = {D（0）、D（1）、...、D（N-1）}次のように、マークル木ハッシュ（MTH）がこのように定義されます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The hash of an empty list is the hash of an empty string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
空のリストのハッシュは、空の文字列のハッシュです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MTH({}) = SHA-256().
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MTH（{}））SHA-256（=
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The hash of a list with one entry (also known as a leaf hash) is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（また、リーフハッシュとして知られている）一つのエントリを有するリストのハッシュです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MTH({d(0)}) = SHA-256(0x00 || d(0)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MTH（{D（0）}）SHA-256（0x00の|| D（0））=。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For n &gt; 1, let k be the largest power of two smaller than n (i.e., k &lt; n &lt;= 2k). The Merkle Tree Hash of an n-element list D[n] is then defined recursively as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
N&gt; 1の場合、kはnよりも小さい2の最大電力であるものとする（すなわち、K &lt;N &lt;=は2K）。 n要素のリストD [N]のマークル木ハッシュは次のように再帰的に定義されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MTH(D[n]) = SHA-256(0x01 || MTH(D[0:k]) || MTH(D[k:n])),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MTH（D [N]）がSHA-256 =（0×01を|| MTH（D [0：K]）|| MTH（D [K：N]））、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where || is concatenation and D[k1:k2] denotes the list {d(k1), d(k1+1),..., d(k2-1)} of length (k2 - k1). (Note that the hash calculations for leaves and nodes differ. This domain separation is required to give second preimage resistance.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どこ||連結およびD [K1：K2]はリスト{D（K1）、D（K1 + 1）、...、D（K2-1）}長さの（ -  K1、K2）です。 （このドメイン分離が第二プレイメージ抵抗を与えるために必要とされる。リーフノードのハッシュ計算が異なることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that we do not require the length of the input list to be a power of two. The resulting Merkle Tree may thus not be balanced; however, its shape is uniquely determined by the number of leaves. (Note: This Merkle Tree is essentially the same as the history tree [CrosbyWallach] proposal, except our definition handles non-full trees differently.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
我々は2の累乗であることを入力リストの長さを必要としないことに注意してください。得マークル木は、このようにバランスされなくてもよいです。しかし、その形状は、一意の葉の数によって決定されます。 （注：このマークル木は、基本的に歴史の木[CrosbyWallach]の提案と同じであり、私たちの定義が異なっ非フルの木を扱う点が異なります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1. Merkle Audit Paths
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1。マークル監査パス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Merkle audit path for a leaf in a Merkle Hash Tree is the shortest list of additional nodes in the Merkle Tree required to compute the Merkle Tree Hash for that tree. Each node in the tree is either a leaf node or is computed from the two nodes immediately below it (i.e., towards the leaves). At each step up the tree (towards the root), a node from the audit path is combined with the node computed so far. In other words, the audit path consists of the list of missing nodes required to compute the nodes leading from a leaf to the root of the tree. If the root computed from the audit path matches the true root, then the audit path is proof that the leaf exists in the tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マークル・ハッシュツリー内のリーフのためのマークル監査経路は、そのツリーのためマークル木ハッシュを計算するために必要なマークル木における追加ノードの最短のリストです。ツリー内の各ノードはリーフノードであるか、またはすぐに（即ち、葉に向かって）下の2つのノードから計算されます。各（ルートに向かって）ツリーをステップアップで、監査の経路からのノードは、これまで計算ノードと結合されます。換言すれば、監査の経路は、ツリーのルートにリーフから先頭ノードを計算するのに必要な欠けているノードのリストから成ります。監査パスから計算ルートが真のルートと一致した場合、監査パスは葉が木に存在することを証明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle audit path PATH(m, D[n]) for the (m+1)th input d(m), 0 &lt;= m &lt; n, is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ツリーにn個の入力の順序付きリストを与え、D [N] = {D（0）、...、D（N-1）}、マークル監査パスPATH（M、D [N]）のための（次のように入力d（m）を第m + 1）は、0 &lt;= M &lt;N、定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The path for the single leaf in a tree with a one-element input list D[1] = {d(0)} is empty:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1要素の入力リストDとツリー内の単一のリーフのための経路[1] = {D（0）}空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PATH(0, {d(0)}) = {}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PATH（0、{D（0）}）= {}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For n &gt; 1, let k be the largest power of two smaller than n. The path for the (m+1)th element d(m) in a list of n &gt; m elements is then defined recursively as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
N&gt; 1の場合、kはnよりも小さい2の最大電力とします。 n個のリストに（M + 1）番目の要素d（M）&gt; M元素のパスは次のように再帰的に定義されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PATH(m, D[n]) = PATH(m, D[0:k]) : MTH(D[k:n]) for m &lt; k; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PATH（M、D [N]）= PATH（M、D [0：K]）：MTH（D [K：N]）M &lt;Kのため、そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PATH(m, D[n]) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for m &gt;= k,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PATH（M、D [N]）= PATH（M  -  K、D [K：N]）：MTH（D [0：K]）M&gt; = kについて、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
{D（K1）、D（K1 + 1）、...、D（K2-1）}リストとして前 -  [K2、K1]長さ（K1、K2）である：ここでリストとDの連結です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2. Merkle Consistency Proofs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2。マークル一貫性証明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Merkle consistency proofs prove the append-only property of the tree. A Merkle consistency proof for a Merkle Tree Hash MTH(D[n]) and a previously advertised hash MTH(D[0:m]) of the first m leaves, m &lt;= n, is the list of nodes in the Merkle Tree required to verify that the first m inputs D[0:m] are equal in both trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e., commitments to inputs) sufficient to verify MTH(D[n]), such that (a subset of) the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that outputs the (unique) minimal consistency proof.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マークル一貫性の証明は、ツリーの追加専用プロパティを証明します。マークル木ハッシュMTH（D [N]）のためのマークル一貫証明以前アドバタイズハッシュMTH（D [0：M]）最初のm個の葉、M &lt;= Nは、マークル木におけるノードのリストであります最初のMがD [0：M]を入力することを確認するために必要な両方のツリーに等しいです。したがって、一貫性の証明は、MTHを確認するのに十分な中間ノード（すなわち、コミットメントの入力に）（D [N]）のセットを含んでいなければならない（のサブセット）は、同じノードがMTH（D [0を検証するために使用することができるよう：M]）。我々は（ユニーク）最小限の一貫性の証明を出力するアルゴリズムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle consistency proof PROOF(m, D[n]) for a previous Merkle Tree Hash MTH(D[0:m]), 0 &lt; m &lt; n, is defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前のツリー、D [N] = {D（0）、...、D（N-1）}、マークル一貫プルーフPROOF（M、D [N]）にN個の入力の順序付きリストを与えマークル木ハッシュMTH（D [0：M]）は、0 &lt;M &lt;N、次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PROOF(m, D[n]) = SUBPROOF(m, D[n], true)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PROOF（M、D [N]）= SUBPROOF（M、D [n]は、TRUE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The subproof for m = n is empty if m is the value for which PROOF was originally requested (meaning that the subtree Merkle Tree Hash MTH(D[0:m]) is known):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
mに対するsubproof = N mは最初に要求された証明のための値である場合（：）が知られているサブツリーマークル木ハッシュMTH（D [M 0]ことを意味する）空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SUBPROOF(m, D[m], true) = {}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SUBPROOF（M、D [M]、TRUE）= {}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The subproof for m = n is the Merkle Tree Hash committing inputs D[0:m]; otherwise:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
mに対するsubproof = nがマークル木ハッシュコミット入力D [0：M]です。そうでなければ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SUBPROOF(m, D[m], false) = {MTH(D[m])}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SUBPROOF（M、D [M]、偽）= {MTH（D [M]）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For m &lt; n, let k be the largest power of two smaller than n. The subproof is then defined recursively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
mについて&lt;N、kはnよりも小さい2の最大電力とします。 subproofは、その後再帰的に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If m &lt;= k, the right subtree entries D[k:n] only exist in the current tree. We prove that the left subtree entries D[0:k] are consistent and add a commitment to D[k:n]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
M &lt;= kの場合、右サブツリーエントリD [K：n]は、現在のツリーに存在します。一貫性があり、D [K：n]はへのコミットメントを追加します。私たちは、左のサブツリーのエントリD [K 0]があることを証明します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SUBPROOF(m, D[n], b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SUBPROOF（M、D [n]は、B）= SUBPROOF（M、D [0：K]、B）：MTH（D [K：N]）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If m &gt; k, the left subtree entries D[0:k] are identical in both trees. We prove that the right subtree entries D[k:n] are consistent and add a commitment to D[0:k].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もしM&gt; K、左サブツリー項目D [0：k]は、両方の木において同一です。一貫性があり、D [0：K]へのコミットメントを追加します。私たちは、右のサブツリーのエントリD [N k]があることを証明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SUBPROOF(m, D[n], b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SUBPROOF（M、D [n]は、B）= SUBPROOF（M  -  K、D [K：n]は、偽）：MTH（D [0：K]）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here, : is a concatenation of lists, and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、：リストの連結であり、D [K1：K2]は長さ（K2  -  K1）を示すリスト{D（K1）を、D（K1 + 1）、...、D（K2-1）}として前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The number of nodes in the resulting proof is bounded above by ceil(log2(n)) + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
得られた証拠内のノードの数は、CEIL（LOG2（N））+ 1によって上記制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.3. Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.3。例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The binary Merkle Tree with 7 leaves:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7葉バイナリマークルツリー：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 hash / \ / \ / \ / \ / \ k l / \ / \ / \ / \ / \ / \ g h i j / \ / \ / \ | a b c d e f d6 | | | | | | d0 d1 d2 d3 d4 d5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハッシュ/ \ / \ / \ / \ / \ K 1 / \ / \ / \ / \ / \ / \ G、H、I、J / \ / \ / \ | BのC D EがFのD6 | | | | | | D0 D1 D2 D3 D4 D5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The audit path for d0 is [b, h, l].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D0の監査経路は[B、H、L]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The audit path for d3 is [c, g, l].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D3の監査経路は[C、G、L]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The audit path for d4 is [f, j, k].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D4の監査経路は[F、J、K]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The audit path for d6 is [i, k].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D6の監査経路は[I、K]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The same tree, built incrementally in four steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4つのステップで漸増的に構築された同じツリー、：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 hash0 hash1=k / \ / \ / \ / \ / \ / \ g c g h / \ | / \ / \ a b d2 a b c d | | | | | | d0 d1 d0 d1 d2 d3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
hash0 HASH1 = K / \ / \ / \ / \ / \ / \ G C GはH / \ | / \ / \ BはD = D2 B | | | | | | D0 D1 D0 D1 D2 D3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 hash2 hash / \ / \ / \ / \ / \ / \ / \ / \ / \ / \ k i k l / \ / \ / \ / \ / \ e f / \ / \ / \ | | / \ / \ g h d4 d5 g h i j / \ / \ / \ / \ / \ | a b c d a b c d e f d6 | | | | | | | | | | d0 d1 d2 d3 d0 d1 d2 d3 d4 d5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HASH2ハッシュ/ \ / \ / \ / \ / \ / \ / \ / \ / \ / \ K Iのk個のL / \ / \ / \ / \ / \ EのF / \ / \ / \ | | / \ / \グラム時間のD4 D5 gはH I J / \ / \ / \ / \ / \ | BはD = BのC D EがFのD6 | | | | | | | | | | D0、D1、D2、D3 D0 D1 D2 D3 D4 D5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The consistency proof between hash0 and hash is PROOF(3, D[7]) = [c, d, g, l]. c, g are used to verify hash0, and d, l are additionally used to show hash is consistent with hash0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
hash0とハッシュとの整合性の証明は、プルーフ（3、D [7]）= [C、D、G、L]です。 C、Gはhash0を検証するために使用され、そしてD、Lがさらにハッシュがhash0と一致して表示するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The consistency proof between hash1 and hash is PROOF(4, D[7]) = [l]. hash can be verified using hash1=k and l.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HASH1とハッシュとの整合性の証明は、プルーフ（4、D [7]）= [L]です。ハッシュは、HASH1 = KおよびLを用いて検証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The consistency proof between hash2 and hash is PROOF(6, D[7]) = [i, j, k]. k, i are used to verify hash2, and j is additionally used to show hash is consistent with hash2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HASH2とハッシュとの整合性の証明は、プルーフ（6、D [7]）= [I、J、K]です。 Kは、iがHASH2を検証するために使用され、そしてjがさらにハッシュがHASH2と一致して表示するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.4. Signatures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.4。署名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Various data structures are signed. A log MUST use either elliptic curve signatures using the NIST P-256 curve (Section D.1.2.3 of the Digital Signature Standard [DSS]) or RSA signatures (RSASSA-PKCS1- V1_5 with SHA-256, Section 8.2 of [RFC3447]) using a key of at least 2048 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
様々なデータ構造が署名されています。ログまたはRSA署名（SHA-256とRSASSA-PKCS1- v1_5の、[RFC3447のセクション8.2 NIST P-256曲線（デジタル署名標準[DSS]のセクションD.1.2.3）を使用して楕円曲線署名のいずれかを使用しなければなりません]）は、少なくとも2048ビットのキーを使用して。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Log Format and Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.ログの形式と操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Anyone can submit certificates to certificate logs for public auditing; however, since certificates will not be accepted by TLS clients unless logged, it is expected that certificate owners or their CAs will usually submit them. A log is a single, ever-growing, append-only Merkle Tree of such certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
誰もが公共の監査のための証明書のログに証明書を提出することができます。ログインしていない限り、証明書は、TLSクライアントによって受け付けられませんので、しかし、証明書の所有者またはそのCAは通常、それらを提出することが期待されます。ログには、証明書のシングル、成長を続ける、追加のみのマークル木です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a valid certificate is submitted to a log, the log MUST immediately return a Signed Certificate Timestamp (SCT). The SCT is the log&#39;s promise to incorporate the certificate in the Merkle Tree within a fixed amount of time known as the Maximum Merge Delay (MMD). If the log has previously seen the certificate, it MAY return the same SCT as it returned before. TLS servers MUST present an SCT from one or more logs to the TLS client together with the certificate. TLS clients MUST reject certificates that do not have a valid SCT for the end-entity certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有効な証明書がログに送信されると、ログがすぐに署名証明書のタイムスタンプ（SCT）を返さなければなりません。 SCTは、最大マージ遅延（MMD）として知られている一定時間内マークルツリーで証明書を組み込むために、ログの約束です。ログは、以前に証明書を見ている場合、それは前に戻ったように、それは同じSCTを返す場合があります。 TLSサーバは、証明書と一緒にTLSクライアントへの1つ以上のログからSCTを提示しなければなりません。 TLSクライアントは、エンドエンティティ証明書の有効なSCTを持っていない証明書を拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Periodically, each log appends all its new entries to the Merkle Tree and signs the root of the tree. Auditors can thus verify that each certificate for which an SCT has been issued indeed appears in the log. The log MUST incorporate a certificate in its Merkle Tree within the Maximum Merge Delay period after the issuance of the SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定期的に、各ログは、マークル木にそのすべての新しいエントリを追加し、ツリーのルートに署名します。監査人は、このようにSCTが実際に発行された各証明書がログに表示されていることを確認することができます。ログには、SCTの発行後最大マージ遅延期間内にそのマークルツリーで証明書を組み込まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Log operators MUST NOT impose any conditions on retrieving or sharing data from the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
事業者は、ログからデータを取得するか、共有上の任意の条件を課してはならないログインしてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Log Entries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。ログエントリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Anyone can submit a certificate to any log. In order to enable attribution of each logged certificate to its issuer, the log SHALL publish a list of acceptable root certificates (this list might usefully be the union of root certificates trusted by major browser vendors). Each submitted certificate MUST be accompanied by all additional certificates required to verify the certificate chain up to an accepted root certificate. The root certificate itself MAY be omitted from the chain submitted to the log server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
誰もが任意のログに証明書を提出することができます。その発行者に証明書を記録し、それぞれの帰属を可能にするために、ログが許容できるルート証明書（このリストは有効主要ブラウザベンダーによって信頼されたルート証明書の労働組合であるかもしれない）のリストを公表しなければなりません。各提出した証明書は受け入れられたルート証明書までの証明書チェーンを検証するために必要なすべての追加の証明書を添付しなければなりません。ルート証明書自体は、ログサーバに送信チェーンから省略されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alternatively, (root as well as intermediate) certificate authorities may submit a certificate to logs prior to issuance. To do so, the CA submits a Precertificate that the log can use to create an entry that will be valid against the issued certificate. The Precertificate is constructed from the certificate to be issued by adding a special critical poison extension (OID 1.3.6.1.4.1.11129.2.4.3, whose extnValue OCTET STRING contains ASN.1 NULL data (0x05 0x00)) to the end-entity TBSCertificate (this extension is to ensure that the Precertificate cannot be validated by a standard X.509v3 client) and signing the resulting TBSCertificate [RFC5280] with either
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代替的に、（根ならびに中間体）認証局が発行する前に、ログへの証明書を提出することができます。そうするために、CAは、ログが発行された証明書に対して有効になりますエントリを作成するために使用できることをPrecertificate提出します。 PrecertificateはエンドエンティティたtbsCertificateに（そのextnValue OCTET STRING ASN.1のNULLデータを含む（0x05を0x00で）OID 1.3.6.1.4.1.11129.2.4.3）特別な臨界毒拡張を追加することにより発行される証明書から構成されています（この拡張はPrecertificateは、標準のX.509v3クライアントによって検証できないことを保証することである）のいずれかを用いて得られたtbsCertificate [RFC5280]を署名します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o a special-purpose (CA:true, Extended Key Usage: Certificate Transparency, OID 1.3.6.1.4.1.11129.2.4.4) Precertificate Signing Certificate. The Precertificate Signing Certificate MUST be directly certified by the (root or intermediate) CA certificate that will ultimately sign the end-entity TBSCertificate yielding the end-entity certificate (note that the log may relax standard validation rules to allow this, so long as the issued certificate will be valid),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O特殊用途（CA：真、拡張キー使用法：証明書の透明性、OID 1.3.6.1.4.1.11129.2.4.4）Precertificate署名証明書。署名証明書Precertificateが直接最終たtbsCertificateは、エンドエンティティ証明書を得たエンドエンティティに署名する（ルートまたは中間）CA証明書によって認証されなければならない（ログ限り、これを可能にする標準的な検証ルールを緩和することができることに注意してください発行された証明書）が有効になり、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o or, the CA certificate that will sign the final certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oや、最後の証明書に署名するCA証明書。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As above, the Precertificate submission MUST be accompanied by the Precertificate Signing Certificate, if used, and all additional certificates required to verify the chain up to an accepted root certificate. The signature on the TBSCertificate indicates the certificate authority&#39;s intent to issue a certificate. This intent is considered binding (i.e., misissuance of the Precertificate is considered equal to misissuance of the final certificate). Each log verifies the Precertificate signature chain and issues a Signed Certificate Timestamp on the corresponding TBSCertificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記のように、Precertificateの提出はPrecertificateが使用されている場合、署名証明書、および受け入れられたルート証明書にチェーンを検証するために必要なすべての追加の証明書を添付しなければなりません。たtbsCertificateの署名は、証明書を発行する認証局の意図を示しています。このインテント（すなわち、Precertificateのmisissuance最終証明書のmisissuanceに等しいと考えられる）結合であると考えられます。各ログはPrecertificate署名チェーンを検証し、対応するたtbsCertificateに署名証明書のタイムスタンプを発行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Logs MUST verify that the submitted end-entity certificate or Precertificate has a valid signature chain leading back to a trusted root CA certificate, using the chain of intermediate CA certificates provided by the submitter. Logs MAY accept certificates that have expired, are not yet valid, have been revoked, or are otherwise not fully valid according to X.509 verification rules in order to accommodate quirks of CA certificate-issuing software. However, logs MUST refuse to publish certificates without a valid chain to a known root CA. If a certificate is accepted and an SCT issued, the accepting log MUST store the entire chain used for verification, including the certificate or Precertificate itself and including the root certificate used to verify the chain (even if it was omitted from the submission), and MUST present this chain for auditing upon request. This chain is required to prevent a CA from avoiding blame by logging a partial or empty chain. (Note: This effectively excludes self-signed and DANE-based certificates until some mechanism to control spam for those certificates is found. The authors welcome suggestions.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログは提出者によって設けられた中間CA証明書のチェーンを使用して、送信したエンドエンティティ証明書またはPrecertificateが戻って信頼されたルートCA証明書につながる有効な署名チェーンを持っていることを確かめなければなりません。ログは、有効期限が切れた証明書を受け入れ、まだ有効でないかもしれない、取り消され、またはCA証明書発行ソフトウェアの癖に対応するために、X.509検証ルールに従って、そうでない場合は完全には有効ではありませんされています。しかし、ログが知られているルートCAへの有効なチェーンのない証明書を発行することを拒否しなければなりません証明書が受け入れられ、SCTが発行された場合、受付ログは、証明書またはPrecertificate自体とチェーンを検証するために使用されるルート証明書などを含む検証に使用チェーン全体を、記憶しなければならない（それが提出から省略された場合でも）、および要求に応じて、監査のためにこのチェーンを提示しなければなりません。このチェーンは、部分的または空のチェーンをログインすることで、責任を回避からCAを防止するために必要とされます。 （注：これらの証明書のスパムを制御するために、いくつかのメカニズムが発見されるまで、これが効果的に自己署名とDANEベースの証明書を除く著者歓迎の提案。。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each certificate entry in a log MUST include the following components:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログ内の各証明書のエントリは、次のコンポーネントを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { x509_entry(0), precert_entry(1), (65535) } LogEntryType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           LogEntryType entry_type;
           select (entry_type) {
               case x509_entry: X509ChainEntry;
               case precert_entry: PrecertChainEntry;
           } entry;
       } LogEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque ASN.1Cert&lt;1..2^24-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明ASN.1Cert &lt;1..2 ^ 24-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ASN.1Cert leaf_certificate;
           ASN.1Cert certificate_chain&lt;0..2^24-1&gt;;
       } X509ChainEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ASN.1Cert pre_certificate;
           ASN.1Cert precertificate_chain&lt;0..2^24-1&gt;;
       } PrecertChainEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Logs MAY limit the length of chain they will accept.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログは、彼らが受け入れるの鎖の長さを制限する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;entry_type&#34; is the type of this entry. Future revisions of this protocol version may add new LogEntryType values. Section 4 explains how clients should handle unknown entry types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「entry_typeは」このエントリのタイプです。このプロトコルバージョンの将来の改訂は、新しいLogEntryType値を追加することができます。第4節では、クライアントが未知のエントリ・タイプを処理する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;leaf_certificate&#34; is the end-entity certificate submitted for auditing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「leaf_certificateは、」監査のために提出エンドエンティティ証明書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;certificate_chain&#34; is a chain of additional certificates required to verify the end-entity certificate. The first certificate MUST certify the end-entity certificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a root certificate accepted by the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「certificate_chainは」エンドエンティティ証明書を検証するために必要な追加の証明書のチェーンです。最初の証明書は、エンドエンティティ証明書を証明しなければなりません。それぞれの次の証明書は直接それに先行するものを証明する必要があります。最後の証明書は、ログに受け入れられたルート証明書でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;pre_certificate&#34; is the Precertificate submitted for auditing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「pre_certificateは」Precertificateは、監査のために提出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;precertificate_chain&#34; is a chain of additional certificates required to verify the Precertificate submission. The first certificate MAY be a valid Precertificate Signing Certificate and MUST certify the first certificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a root certificate accepted by the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「precertificate_chainは」Precertificateの提出を検証するために必要な追加の証明書のチェーンです。最初の証明書は、有効なPrecertificate署名証明書とすることができ、最初の証明書を証明しなければなりません。それぞれの次の証明書は直接それに先行するものを証明する必要があります。最後の証明書は、ログに受け入れられたルート証明書でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Structure of the Signed Certificate Timestamp
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。署名証明書のタイムスタンプの構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { certificate_timestamp(0), tree_hash(1), (255) }
         SignatureType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { v1(0), (255) }
         Version;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
             opaque key_id[32];
         } LogID;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque TBSCertificate&lt;1..2^24-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明たtbsCertificate &lt;1..2 ^ 24-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           opaque issuer_key_hash[32];
           TBSCertificate tbs_certificate;
         } PreCert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque CtExtensions&lt;0..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明CtExtensions &lt;0..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;key_id&#34; is the SHA-256 hash of the log&#39;s public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「のkey_idは」SubjectPublicKeyInfoでのように表さキーのDERエンコーディングに渡って計算ログの公開鍵のSHA-256ハッシュです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;issuer_key_hash&#34; is the SHA-256 hash of the certificate issuer&#39;s public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo. This is needed to bind the issuer to the final certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「issuer_key_hashは」SubjectPublicKeyInfoでのように表さキーのDERエンコーディングに渡って計算証明書発行者の公開鍵のSHA-256ハッシュです。これは、最後の証明書を発行者をバインドするために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;tbs_certificate&#34; is the DER-encoded TBSCertificate (see [RFC5280]) component of the Precertificate -- that is, without the signature and the poison extension. If the Precertificate is not signed with the CA certificate that will issue the final certificate, then the TBSCertificate also has its issuer changed to that of the CA that will issue the final certificate. Note that it is also possible to reconstruct this TBSCertificate from the final certificate by extracting the TBSCertificate from it and deleting the SCT extension. Also note that since the TBSCertificate contains an AlgorithmIdentifier that must match both the Precertificate signature algorithm and final certificate signature algorithm, they must be signed with the same algorithm and parameters. If the Precertificate is issued using a Precertificate Signing Certificate and an Authority Key Identifier extension is present in the TBSCertificate, the corresponding extension must also be present in the Precertificate Signing Certificate -- in this case, the TBSCertificate also has its Authority Key Identifier changed to match the final issuer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
署名及び毒拡張することなく、ある - 「tbs_certificate」はPrecertificateのDER符号化されたtbsCertificate（[RFC5280]を参照のこと）の成分です。 Precertificateが、最終的な証明書を発行するCA証明書で署名されていない場合は、たtbsCertificateはまた、発行者は、最終的な証明書を発行するCAのものに変更されました。それからたtbsCertificateを抽出し、SCT拡張子を削除することによって、最終的な証明書から本たtbsCertificateを再構成することも可能であることに留意されたいです。又たtbsCertificateはPrecertificate署名アルゴリズムおよび最終証明書の署名アルゴリズムの両方に一致しなければならないのAlgorithmIdentifierが含まれているので、それらは同じアルゴリズムおよびパラメータを使用して署名されなければならないことに注意してください。 Precertificateを使用して発行された場合Precertificate署名証明書と認証局キー識別子の拡張子がたtbsCertificateに存在する、対応する拡張機能もPrecertificate署名証明書に存在している必要があります - この場合には、たtbsCertificateもその権限キー識別子は、に変更されました最終発行者と一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           Version sct_version;
           LogID id;
           uint64 timestamp;
           CtExtensions extensions;
           digitally-signed struct {
               Version sct_version;
               SignatureType signature_type = certificate_timestamp;
               uint64 timestamp;
               LogEntryType entry_type;
               select(entry_type) {
                   case x509_entry: ASN.1Cert;
                   case precert_entry: PreCert;
               } signed_entry;
              CtExtensions extensions;
           };
       } SignedCertificateTimestamp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The encoding of the digitally-signed element is defined in [RFC5246].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デジタル署名された要素の符号化は[RFC5246]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;sct_version&#34; is the version of the protocol to which the SCT conforms. This version is v1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「sct_version」はSCTが準拠れるプロトコルのバージョンです。このバージョンはv1のです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;timestamp&#34; is the current NTP Time [RFC5905], measured since the epoch (January 1, 1970, 00:00), ignoring leap seconds, in milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「タイムスタンプ」は、ミリ秒単位で、うるう秒を無視して、エポック（1970年1月1日00:00）以来、測定された現在のNTPタイム[RFC5905]、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;entry_type&#34; may be implicit from the context in which the SCT is presented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「entry_typeは、」SCTが提示される文脈から暗黙的であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;signed_entry&#34; is the &#34;leaf_certificate&#34; (in the case of an X509ChainEntry) or is the PreCert (in the case of a PrecertChainEntry), as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記のように「signed_entry」は、（X509ChainEntryの場合）「leaf_certificate」であるか、または（PrecertChainEntryの場合）PreCertあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;extensions&#34; are future extensions to this protocol version (v1). Currently, no extensions are specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「拡張子が」このプロトコルバージョン（V1）への将来の拡張です。現在、拡張子が指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Including the Signed Certificate Timestamp in the TLS Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。 TLSハンドシェイクでの署名付き証明書のタイムスタンプを含みます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SCT data corresponding to the end-entity certificate from at least one log must be included in the TLS handshake, either by using an X509v3 certificate extension as described below, by using a TLS extension (Section 7.4.1.4 of [RFC5246]) with type &#34;signed_certificate_timestamp&#34;, or by using Online Certificate Status Protocol (OCSP) Stapling (also known as the &#34;Certificate Status
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
少なくとも一つのログからエンドエンティティ証明書に対応するSCTデータを用いてTLS拡張子（[RFC5246]のセクション7.4.1.4）を用いて、以下に説明するように書X509v3証明書拡張を使用することによってのいずれかで、TLSハンドシェイク中に含まれなければなりませんタイプ「signed_certificate_timestamp」、あるいはまた、「証明書ステータスとして知られているオンライン証明書状態プロトコル（OCSP）ステープルを（使用して
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Request&#34; TLS extension; see [RFC6066]), where the response includes an OCSP extension with OID 1.3.6.1.4.1.11129.2.4.5 (see [RFC2560]) and body:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求」TLS拡張子、応答がOID 1.3.6.1.4.1.11129.2.4.5（[RFC2560]を参照）と本体とOCSP拡張を含む場合、[RFC6066]）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       SignedCertificateTimestampList ::= OCTET STRING
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At least one SCT MUST be included. Server operators MAY include more than one SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
少なくとも一つのSCTを含まなければなりません。サーバーオペレータは、複数のSCTを含むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Similarly, a certificate authority MAY submit a Precertificate to more than one log, and all obtained SCTs can be directly embedded in the final certificate, by encoding the SignedCertificateTimestampList structure as an ASN.1 OCTET STRING and inserting the resulting data in the TBSCertificate as an X.509v3 certificate extension (OID 1.3.6.1.4.1.11129.2.4.2). Upon receiving the certificate, clients can reconstruct the original TBSCertificate to verify the SCT signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、認証局は、複数のログにPrecertificateを提出することができる、すべての得られたSCTが直接ASN.1のOCTET STRINGとしてSignedCertificateTimestampList構造をコードとしてたtbsCertificateで得られたデータを挿入することにより、最終的な証明書に埋め込むことができますX.509v3証明書の拡張機能（OID 1.3.6.1.4.1.11129.2.4.2）。証明書を受信すると、クライアントは、SCT署名を検証するために、元たtbsCertificateを再構成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The contents of the ASN.1 OCTET STRING embedded in an OCSP extension or X509v3 certificate extension are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにOCSP拡張または書X509v3証明書拡張に埋め込まれたASN.1オクテット文字列の内容は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque SerializedSCT&lt;1..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明SerializedSCT &lt;1..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
            SerializedSCT sct_list &lt;1..2^16-1&gt;;
        } SignedCertificateTimestampList;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here, &#34;SerializedSCT&#34; is an opaque byte string that contains the serialized TLS structure. This encoding ensures that TLS clients can decode each SCT individually (i.e., if there is a version upgrade, out-of-date clients can still parse old SCTs while skipping over new SCTs whose versions they don&#39;t understand).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、「SerializedSCTは、」シリアル化されたTLSの構造を含む不透明なバイト列です。このエンコーディングは、TLSクライアントが個別に各SCTをデコードすることができます（バージョンアップがある場合は、そのバージョン、彼らは理解していない新しいのSCTを飛ばしながら、すなわち、期限切れのクライアントがまだ古いのSCTを解析できる）ことを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Likewise, SCTs can be embedded in a TLS extension. See below for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、SCTがTLS拡張に埋め込むことができます。詳細については、以下を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS clients MUST implement all three mechanisms. Servers MUST implement at least one of the three mechanisms. Note that existing TLS servers can generally use the certificate extension mechanism without modification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSクライアントは、すべての3つのメカニズムを実装しなければなりません。サーバーは、次の3つのメカニズムのうちの少なくとも一つを実装しなければなりません。既存のTLSサーバは、一般的に変更せずに、証明書の拡張メカニズムを使用できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS servers should send SCTs from multiple logs in case one or more logs are not acceptable to the client (for example, if a log has been struck off for misbehavior or has had a key compromise).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSサーバは、一件の以上のログがクライアントに受け入れられない場合には、複数のログからのSCTを送信する必要があります（例えば、ログが不正行為のためにオフに打たれたかのキー妥協があった場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. TLS Extension
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1。 TLS拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SCT can be sent during the TLS handshake using a TLS extension with type &#34;signed_certificate_timestamp&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCTは、タイプ「signed_certificate_timestamp」とTLSの拡張機能を使用して、TLSハンドシェイク中に送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients that support the extension SHOULD send a ClientHello extension with the appropriate type and empty &#34;extension_data&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張をサポートするクライアントは、適切な型と空の「拡大」とのClientHello拡張を送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers MUST only send SCTs to clients who have indicated support for the extension in the ClientHello, in which case the SCTs are sent by setting the &#34;extension_data&#34; to a &#34;SignedCertificateTimestampList&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーのみのSCTが「SignedCertificateTimestampList」を「拡大」に設定することで送信される場合にはのClientHelloでの拡張のための支持を表明しているクライアントへのSCTを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Session resumption uses the original session information: clients SHOULD include the extension type in the ClientHello, but if the session is resumed, the server is not expected to process it or include the extension in the ServerHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはのClientHelloでの拡張タイプを含める必要がありますが、セッションが再開された場合、サーバーはそれを処理するかのServerHelloで拡張子を含めることが予想されていない：セッションの再開は、元のセッション情報を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Merkle Tree
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4。マークル木
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The hashing algorithm for the Merkle Tree Hash is SHA-256.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マークル木ハッシュのためのハッシュアルゴリズムはSHA-256です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of the Merkle Tree input:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マークル木入力の構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       enum { timestamped_entry(0), (255) }
         MerkleLeafType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           uint64 timestamp;
           LogEntryType entry_type;
           select(entry_type) {
               case x509_entry: ASN.1Cert;
               case precert_entry: PreCert;
           } signed_entry;
           CtExtensions extensions;
       } TimestampedEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           Version version;
           MerkleLeafType leaf_type;
           select (leaf_type) {
               case timestamped_entry: TimestampedEntry;
           }
       } MerkleTreeLeaf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here, &#34;version&#34; is the version of the protocol to which the MerkleTreeLeaf corresponds. This version is v1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、「バージョン」はMerkleTreeLeafが対応するプロトコルのバージョンです。このバージョンはv1のです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;leaf_type&#34; is the type of the leaf input. Currently, only &#34;timestamped_entry&#34; (corresponding to an SCT) is defined. Future revisions of this protocol version may add new MerkleLeafType types. Section 4 explains how clients should handle unknown leaf types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「leaf_typeは」葉入力のタイプです。現在、唯一の「timestamped_entry」（SCTに相当）が定義されます。このプロトコルバージョンの将来の改訂は、新しいMerkleLeafTypeタイプを追加することがあります。第4節では、クライアントが不明な葉の種類を処理する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;timestamp&#34; is the timestamp of the corresponding SCT issued for this certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「タイムスタンプ」は、この証明書を発行し、対応するSCTのタイムスタンプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;signed_entry&#34; is the &#34;signed_entry&#34; of the corresponding SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「signed_entry」は、対応するSCTの「signed_entry」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;extensions&#34; are &#34;extensions&#34; of the corresponding SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「拡張子」は、対応するSCTの「拡張」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The leaves of the Merkle Tree are the leaf hashes of the corresponding &#34;MerkleTreeLeaf&#34; structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マークル木の葉が対応する「MerkleTreeLeaf」構造の葉のハッシュです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Signed Tree Head
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5。署名されたツリーの頭
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Every time a log appends new entries to the tree, the log SHOULD sign the corresponding tree hash and tree information (see the corresponding Signed Tree Head client message in Section 4.3). The signature for that data is structured as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログがツリーに新しいエントリを追加するたびに、ログには、対応するツリーハッシュやツリー情報を（セクション4.3で、対応する署名ツリー頭クライアントメッセージを参照）に署名すべきです。次のようにそのデータの署名が構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       digitally-signed struct {
           Version version;
           SignatureType signature_type = tree_hash;
           uint64 timestamp;
           uint64 tree_size;
           opaque sha256_root_hash[32];
       } TreeHeadSignature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;version&#34; is the version of the protocol to which the TreeHeadSignature conforms. This version is v1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「バージョン」はTreeHeadSignatureが準拠れるプロトコルのバージョンです。このバージョンはv1のです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;timestamp&#34; is the current time. The timestamp MUST be at least as recent as the most recent SCT timestamp in the tree. Each subsequent timestamp MUST be more recent than the timestamp of the previous update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「タイムスタンプは、」現在の時刻です。タイムスタンプは、少なくとも、ツリー内の最新のSCTのタイムスタンプとして、最近のようでなければなりません。後続の各タイムスタンプは、前回の更新のタイムスタンプより新しいなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;tree_size&#34; equals the number of entries in the new tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「tree_sizeは、」新しいツリー内のエントリの数に等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;sha256_root_hash&#34; is the root of the Merkle Hash Tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「sha256_root_hashは」マークルハッシュツリーのルートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each log MUST produce on demand a Signed Tree Head that is no older than the Maximum Merge Delay. In the unlikely event that it receives no new submissions during an MMD period, the log SHALL sign the same Merkle Tree Hash with a fresh timestamp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ログには、要求に応じて、最大マージ遅延よりも古くない署名ツリーヘッドを生産しなければなりません。それはMMD期間中に新たな提出物を受信しない万一、ログは、新鮮なタイムスタンプと同じマークル木ハッシュに署名しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Log Client Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.ログクライアントメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Messages are sent as HTTPS GET or POST requests. Parameters for POSTs and all responses are encoded as JavaScript Object Notation (JSON) objects [RFC4627]. Parameters for GETs are encoded as order-independent key/value URL parameters, using the &#34;application/ x-www-form-urlencoded&#34; format described in the &#34;HTML 4.01 Specification&#34; [HTML401]. Binary data is base64 encoded [RFC4648] as specified in the individual messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージはHTTPS GETやPOSTリクエストとして送信されます。ポストおよびすべての応答のパラメータは、JavaScript Object Notation（JSON）オブジェクト[RFC4627]として符号化されます。パラメータは、[HTML401]「HTML 4.01仕様書」に記載された「アプリケーション/ x-www-form-urlencodedで」形式を使用して、順序非依存のキー/値のURLパラメータとして符号化される取得します。バイナリデータは、個々のメッセージで指定されるようにbase64で符号化された[RFC4648]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that JSON objects and URL parameters may contain fields not specified here. These extra fields should be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
JSONオブジェクトとURLのパラメータは、ここで指定されていないフィールドが含まれていてもよいことに注意してください。これらの追加のフィールドは無視されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &lt;log server&gt; prefix can include a path as well as a server name and a port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;ログサーバー&gt;プレフィックスは、パスだけでなく、サーバー名とポートを含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, where needed, the &#34;version&#34; is v1 and the &#34;id&#34; is the log id for the log server queried.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必要な場合、一般的には、「バージョンは」V1で、「idが」照会ログサーバのログIDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any errors will be returned as HTTP 4xx or 5xx responses, with human-readable error messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのエラーは、人間が読めるエラーメッセージで、HTTPの4xxまたは5xxの応答として返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Add Chain to Log
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。ログにチェーンを追加します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
POST https://&lt;log server&gt;/ct/v1/add-chain
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
POSTのhttps：//では/ CT / V1 /アドオンチェーン&lt;サーバーログ&gt;を
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
chain: An array of base64-encoded certificates. The first element is the end-entity certificate; the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鎖：base64エンコード証明書の配列。最初の要素は、エンドエンティティ証明書です。ルート証明書または既知のルート証明書にチェーン証明書のいずれかである、最後のように第一および第二のチェーン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
sct_version: The version of the SignedCertificateTimestamp structure, in decimal. A compliant v1 implementation MUST NOT expect this to be 0 (i.e., v1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
sct_version：SignedCertificateTimestamp構造のバージョン、小数インチコンプライアントV1の実装では、これは0（即ち、V1）であることを期待してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
id: The log ID, base64 encoded. Since log clients who request an SCT for inclusion in TLS handshakes are not required to verify it, we do not assume they know the ID of the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ID：ログID、BASE64でエンコードされました。 TLSハンドシェイクに含めるためSCTを要求ログクライアントは、それを検証するために必要とされていないので、我々は、彼らが、ログのIDを知っていると仮定しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
timestamp: The SCT timestamp, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプ：SCTのタイムスタンプ、小数インチ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extensions: An opaque type for future expansion. It is likely that not all participants will need to understand data in this field. Logs should set this to the empty string. Clients should decode the base64-encoded data and include it in the SCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張子：将来の拡張のために不透明タイプ。すべての参加者は、このフィールド内のデータを理解する必要がありますない可能性が高いです。ログは空の文字列に設定する必要があります。クライアントは、base64でエンコードされたデータをデコードし、SCTでそれを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
signature: The SCT signature, base64 encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
署名：SCT署名、BASE64でエンコードされました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the &#34;sct_version&#34; is not v1, then a v1 client may be unable to verify the signature. It MUST NOT construe this as an error. (Note: Log clients don&#39;t need to be able to verify this structure; only TLS clients do. If we were to serve the structure as a binary blob, then we could completely change it without requiring an upgrade to v1 clients.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「sct_versionは」V1されていない場合、v1のクライアントは、署名を検証できないことがあります。それはこれをエラーとして解釈してはなりません。 （注：クライアントは、この構造を確認することができるようにする必要はありませんログインし、クライアントのみが行うTLS我々はバイナリブロブのような構造を提供することであったならば、我々は完全にv1のクライアントへのアップグレードを必要とせずに、それを変更することができます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Add PreCertChain to Log
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。ログにPreCertChainを追加
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
POST https://&lt;log server&gt;/ct/v1/add-pre-chain
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
POSTします。https：// &lt;ログオンサーバー&gt; / CT / V1 /アドオン事前チェーン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
chain: An array of base64-encoded Precertificates. The first element is the end-entity certificate; the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鎖：base64エンコードPrecertificatesのアレイ。最初の要素は、エンドエンティティ証明書です。ルート証明書または既知のルート証明書にチェーン証明書のいずれかである、最後のように第一および第二のチェーン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outputs are the same as in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力は4.1節と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Retrieve Latest Signed Tree Head
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。最新の署名ツリー頭を取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET https://&lt;log server&gt;/ct/v1/get-sth
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETのhttps：// / CT / V1 /取得-STH &lt;サーバーログ&gt;を
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
No inputs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力なしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
tree_size: The size of the tree, in entries, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
tree_size：小数のエントリのツリーのサイズ、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
timestamp: The timestamp, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプ：タイムスタンプ、小数インチ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
sha256_root_hash: The Merkle Tree Hash of the tree, in base64.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
sha256_root_hash：木のマークル木ハッシュ、BASE64インチ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
tree_head_signature: A TreeHeadSignature for the above data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
tree_head_signature：上記データのTreeHeadSignature。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Retrieve Merkle Consistency Proof between Two Signed Tree Heads
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4。二つの署名ツリーヘッド間マークル整合性証明を取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET https://&lt;log server&gt;/ct/v1/get-sth-consistency
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETのhttps：// &lt;ログオンサーバー&gt; / CT / V1 /取得-STH-一貫性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
first: The tree_size of the first tree, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の10進の最初の木のtree_size、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
second: The tree_size of the second tree, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第二：小数第二の木、のtree_size。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Both tree sizes must be from existing v1 STHs (Signed Tree Heads).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どちらの木の大きさは、既存のV1 STHS（署名ツリーヘッド）からでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
consistency: An array of Merkle Tree nodes, base64 encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一貫性：マークル木ノードのアレイ、BASE64でエンコードされました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that no signature is required on this data, as it is used to verify an STH, which is signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
署名されてSTHを検証するために使用されるいかなる署名は、このデータに必要とされないことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Retrieve Merkle Audit Proof from Log by Leaf Hash
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5。リーフハッシュによってログからマークル監査証明を取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET https://&lt;log server&gt;/ct/v1/get-proof-by-hash
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETのhttps：// &lt;ログオンサーバー&gt; / CT / V1 /取得プルーフ・バイ・ハッシュ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
hash: A base64-encoded v1 leaf hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハッシュ：base64エンコードv1のリーフハッシュ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
tree_size: The tree_size of the tree on which to base the proof, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
tree_size：小数で、証拠の基に木のtree_size。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;hash&#34; must be calculated as defined in Section 3.4. The &#34;tree_size&#34; must designate an existing v1 STH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.4節で定義された「ハッシュ」を計算しなければなりません。 「tree_sizeは、」既存のV1 STHを指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
leaf_index: The 0-based index of the end entity corresponding to the &#34;hash&#34; parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
leaf_index：「ハッシュ」パラメータに対応するエンドエンティティの0から始まるインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
audit_path: An array of base64-encoded Merkle Tree nodes proving the inclusion of the chosen certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
audit_path：選択した証明書を含めることを証明base64エンコードマークル木ノードのアレイ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Retrieve Entries from Log
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6。ログからエントリを取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET https://&lt;log server&gt;/ct/v1/get-entries
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETのhttps：// &lt;サーバーをログ&gt; / CT / V1 / GET-エントリ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
start: 0-based index of first entry to retrieve, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
開始：取得するための最初のエントリの0から始まるインデックスを10進数で。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
end: 0-based index of last entry to retrieve, in decimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後：小数で、取得するための最後のエントリの0から始まるインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
entries: An array of objects, each consisting of
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エントリ：オブジェクトの配列、それぞれから成ります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
leaf_input: The base64-encoded MerkleTreeLeaf structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
leaf_input：base64エンコードMerkleTreeLeaf構造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extra_data: The base64-encoded unsigned data pertaining to the log entry. In the case of an X509ChainEntry, this is the &#34;certificate_chain&#34;. In the case of a PrecertChainEntry, this is the whole &#34;PrecertChainEntry&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
extra_data：ログエントリに関連するbase64エンコード符号なしデータ。 X509ChainEntryの場合、これは「certificate_chain」です。 PrecertChainEntryの場合、これは全体の「PrecertChainEntry」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that this message is not signed -- the retrieved data can be verified by constructing the Merkle Tree Hash corresponding to a retrieved STH. All leaves MUST be v1. However, a compliant v1 client MUST NOT construe an unrecognized MerkleLeafType or LogEntryType value as an error. This means it may be unable to parse some entries, but note that each client can inspect the entries it does recognize as well as verify the integrity of the data by treating unrecognized leaves as opaque input to the tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージが署名されていないことに注意してください - 検索されたデータが検索STHに対応マークル木ハッシュを構築することによって確認することができます。すべての葉がV1でなければなりません。しかし、対応V1クライアントはエラーとして認識されていないMerkleLeafTypeまたはLogEntryType値を解釈してはなりません。いくつかのエントリを解析することができないが、各クライアントは、それが認識しないエントリを検査だけでなく、木に不透明な入力として認識されていない葉を処理することにより、データの整合性を検証することに注意して意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;start&#34; and &#34;end&#34; parameters SHOULD be within the range 0 &lt;= x &lt; &#34;tree_size&#34; as returned by &#34;get-sth&#34; in Section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「開始」および「終了」パラメータが範囲0 &lt;= xで&lt;4.3節には、「get-STHを」によって返される「tree_size」内にあるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Logs MAY honor requests where 0 &lt;= &#34;start&#34; &lt; &#34;tree_size&#34; and &#34;end&#34; &gt;= &#34;tree_size&#34; by returning a partial response covering only the valid entries in the specified range. Note that the following restriction may also apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログは、0 &lt;=指定された範囲でのみ有効なエントリをカバーする部分的な応答を返すことで、&lt;「tree_size」と「終わり」&gt; =「tree_size」を「開始」の要求を尊重するかもしれません。以下の制限が適用される場合もありことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Logs MAY restrict the number of entries that can be retrieved per &#34;get-entries&#34; request. If a client requests more than the permitted number of entries, the log SHALL return the maximum number of entries permissible. These entries SHALL be sequential beginning with the entry specified by &#34;start&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログは、「-エントリを取得する」リクエストごとに取得できるエントリの数を制限することができます。クライアントは、エントリの許容数よりも多くを要求した場合、ログは許容最大エントリ数を返します。これらのエントリは、「スタート」で指定されたエントリで、シーケンシャル初めものでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. Retrieve Accepted Root Certificates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7。承認済みルート証明書を取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET https://&lt;log server&gt;/ct/v1/get-roots
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETのhttps：// &lt;サーバーをログ&gt; / CT / V1 / GET-ルーツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
No inputs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力なしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificates: An array of base64-encoded root certificates that are acceptable to the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明：ログに許容されるbase64エンコードされたルート証明書の配列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. Retrieve Entry+Merkle Audit Proof from Log
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8。ログからのエントリ+マークル監査証明を取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET https://&lt;log server&gt;/ct/v1/get-entry-and-proof
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETのhttps：// &lt;ログオンサーバー&gt; / CT / V1 /取得-エントリーとプルーフ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
leaf_index: The index of the desired entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
leaf_index：目的のエントリのインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
tree_size: The tree_size of the tree for which the proof is desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
tree_size：証拠が望まれる木のtree_size。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The tree size must designate an existing STH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
木の大きさは、既存のSTHを指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
leaf_input: The base64-encoded MerkleTreeLeaf structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
leaf_input：base64エンコードMerkleTreeLeaf構造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extra_data: The base64-encoded unsigned data, same as in Section 4.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
extra_data：4.6節と同様のBase64でエンコードされた符号なしデータ、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
audit_path: An array of base64-encoded Merkle Tree nodes proving the inclusion of the chosen certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
audit_path：選択した証明書を含めることを証明base64エンコードマークル木ノードのアレイ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This API is probably only useful for debugging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このAPIは、おそらく、デバッグのためにのみ有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.クライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are various different functions clients of logs might perform. We describe here some typical clients and how they could function. Any inconsistency may be used as evidence that a log has not behaved correctly, and the signatures on the data structures prevent the log from denying that misbehavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログのクライアントが実行する可能性のあるさまざまな異なる機能があります。ここではいくつかの典型的なクライアントを記述し、それらがどのように機能することができます。任意の矛盾は、ログが正しく振る舞っていないことの証拠として使用することができ、データ構造上の署名は、その不正行為を否定するからログを防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All clients should gossip with each other, exchanging STHs at least; this is all that is required to ensure that they all have a consistent view. The exact mechanism for gossip will be described in a separate document, but it is expected there will be a variety.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのクライアントは、少なくともSTHSを交換し、お互いにゴシップ必要があります。これは、彼らはすべての一貫したビューを持っていることを保証するために必要とされるすべてです。ゴシップのための正確な機構は、別の文書に記載され、種々が存在するであろうと予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Submitters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。提出者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Submitters submit certificates or Precertificates to the log as described above. They may go on to use the returned SCT to construct a certificate or use it directly in a TLS handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記のように提出者は、ログに証明書やPrecertificatesを提出します。彼らは、証明書を作成するか、TLSハンドシェイクで直接それを使用するために返されたSCTを使用するために行くことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. TLS Client
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。 TLSクライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS clients are not directly clients of the log, but they receive SCTs alongside or in server certificates. In addition to normal validation of the certificate and its chain, they should validate the SCT by computing the signature input from the SCT data as well as the certificate and verifying the signature, using the corresponding log&#39;s public key. Note that this document does not describe how clients obtain the logs&#39; public keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSクライアントは直接ログのクライアントではありませんが、サーバ証明書と一緒やでのSCTを受けます。証明書とそのチェーンの通常の検証に加えて、それらは、対応するログの公開鍵を使用して、SCTデータから署名入力ならびに証明書を計算し、署名を検証することによってSCTを検証しなければなりません。この文書は、クライアントがログの公開鍵を取得する方法について説明していないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS clients MUST reject SCTs whose timestamp is in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSクライアントは、そのタイムスタンプが未来にあるのSCTを拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Monitor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。モニター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Monitors watch logs and check that they behave correctly. They also watch for certificates of interest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モニターは、ログを見て、彼らが正しく動作することを確認してください。彼らはまた、目的の証明書を監視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A monitor needs to, at least, inspect every new entry in each log it watches. It may also want to keep copies of entire logs. In order to do this, it should follow these steps for each log:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モニターは、少なくとも、各それは時計ログ内のすべての新しいエントリを検査する必要があります。また、全体のログのコピーを保存することができます。これを実行するためには、各ログの手順に従ってください：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Fetch the current STH (Section 4.3).
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.現在のSTH（4.3節）を取得します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Verify the STH signature.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. STH署名を確認します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Fetch all the entries in the tree corresponding to the STH (Section 4.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. STH（セクション4.6）に対応するツリー内のすべてのエントリをフェッチ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Confirm that the tree made from the fetched entries produces the same hash as that in the STH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前記フェッチされたエントリから作られたツリーは、STHと同様のハッシュを生成することを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. Fetch the current STH (Section 4.3). Repeat until the STH changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.現在のSTH（4.3節）を取得します。 STH変化するまで繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Verify the STH signature.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. STH署名を確認します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. Fetch all the new entries in the tree corresponding to the STH (Section 4.6). If they remain unavailable for an extended period, then this should be viewed as misbehavior on the part of the log.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. STH（4.6節）に対応するツリー内のすべての新しいエントリを取得します。彼らは長期間使用できなく残っている場合、これは、ログの一部に不正行為としてみなされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Either:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.次のいずれか
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       1.  Verify that the updated list of all entries generates a tree
           with the same hash as the new STH.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Or, if it is not keeping all log entries:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それとも、それはすべてのログエントリを保持していない場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Fetch a consistency proof for the new STH with the previous STH (Section 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.前STH（セクション4.4）を使用して新しいSTHのための一貫性の証明を取得。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Verify the consistency proof.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.一貫性の証明を確認してください。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Verify that the new entries generate the corresponding elements in the consistency proof.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.新しいエントリは、一貫性の証明の対応する要素を生成していることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Go to Step 5.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.ゴーステップ5に。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Auditor
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。監査役
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Auditors take partial information about a log as input and verify that this information is consistent with other partial information they have. An auditor might be an integral component of a TLS client; it might be a standalone service; or it might be a secondary function of a monitor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
監査役は、入力として、ログに関する部分的な情報を取得し、この情報は、彼らが持っている他の部分的な情報と一致していることを確認してください。監査人は、TLSクライアントの不可欠な構成要素であるかもしれません。それは、スタンドアロンのサービスかもしれません。またはそれは、モニターの二次関数であるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any pair of STHs from the same log can be verified by requesting a consistency proof (Section 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じログからSTHSの任意の対は、一貫性証明（セクション4.4）を要求することによって検証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A certificate accompanied by an SCT can be verified against any STH dated after the SCT timestamp + the Maximum Merge Delay by requesting a Merkle audit proof (Section 4.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCTを伴う証明書は、SCTのタイムスタンプ+マークル監査証拠（4.5節）を要求することによって最大マージ遅延の後付けの任意のSTHと照合することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Auditors can fetch STHs from time to time of their own accord, of course (Section 4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
監査役は、自分のアコード、もちろん（4.3節）の時からSTHSを取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA has allocated an RFC 5246 ExtensionType value (18) for the SCT TLS extension. The extension name is &#34;signed_certificate_timestamp&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、SCT TLS拡張のためにRFC 5246 ExtensionType値（18）を割り当てています。拡張子名は「signed_certificate_timestamp」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With CAs, logs, and servers performing the actions described here, TLS clients can use logs and signed timestamps to reduce the likelihood that they will accept misissued certificates. If a server presents a valid signed timestamp for a certificate, then the client knows that the certificate has been published in a log. From this, the client knows that the subject of the certificate has had some time to notice the misissue and take some action, such as asking a CA to revoke a misissued certificate. A signed timestamp is not a guarantee that the certificate is not misissued, since the subject of the certificate might not have checked the logs or the CA might have refused to revoke the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CAは、ログ、ここで説明するアクションを実行するサーバーでは、TLSクライアントは、彼らがmisissued証明書を受け入れる可能性を減らすために、ログおよび署名タイムスタンプを使用することができます。サーバー証明書の有効な署名タイムスタンプを提示した場合、クライアントは、証明書がログに掲載されていることを知っています。このことから、クライアントは、証明書のサブジェクトは、このようなmisissued証明書を失効させるCAを尋ねると、misissueに気づくと、いくつかの行動を取るためにいくつかの時間があったことを知っています。署名タイムスタンプは、証明書のサブジェクトは、ログをチェックしていない可能性がありますか、CAが証明書を失効することを拒否している場合がありますので、証明書は、misissuedされていないことを保証するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, if TLS clients will not accept unlogged certificates, then site owners will have a greater incentive to submit certificates to logs, possibly with the assistance of their CA, increasing the overall transparency of the system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSクライアントがログに記録されない証明書を受け入れない場合は加えて、そのサイトの所有者は、システムの全体的な透明性を高め、おそらく彼らのCAの支援を受けて、ログに証明書を提出する大きなインセンティブを持つことになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Misissued Certificates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。 Misissued証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Misissued certificates that have not been publicly logged, and thus do not have a valid SCT, will be rejected by TLS clients. Misissued certificates that do have an SCT from a log will appear in that public log within the Maximum Merge Delay, assuming the log is operating correctly. Thus, the maximum period of time during which a misissued certificate can be used without being available for audit is the MMD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
公に記録されていないため、有効なSCTを持っていないMisissued証明書は、TLSクライアントによって拒否されます。ログからSCTを持っていますMisissued証明書は、ログが正常に動作していると仮定すると、遅延をマージ最大以内にその公共のログに表示されます。したがって、misissued証明書は、監査のために利用可能でなく使用することができる時間の最大期間は、MMDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Detection of Misissue
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。 Misissueの検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The logs do not themselves detect misissued certificates; they rely instead on interested parties, such as domain owners, to monitor them and take corrective action when a misissue is detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ログ自体はmisissued証明書を検出しません。彼らはそれらを監視し、misissueが検出されたときに是正措置をとるために、そのようなドメインの所有者などの利害関係者、上の代わりに頼っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Misbehaving Logs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。ふらちなログ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A log can misbehave in two ways: (1) by failing to incorporate a certificate with an SCT in the Merkle Tree within the MMD and (2) by violating its append-only property by presenting two different, conflicting views of the Merkle Tree at different times and/or to different parties. Both forms of violation will be promptly and publicly detectable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でマークル木の二つの異なる、相反する見解を提示することによって、その追加専用プロパティに違反することによりMMD及び（2）内のマークル木におけるSCTと証明書を組み込むために失敗することにより（1）：ログは、2つの方法で誤動作することができ異なる時間および/または異なる政党へ。違反の両方の形式は、迅速かつ公に検出可能となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Violation of the MMD contract is detected by log clients requesting a Merkle audit proof for each observed SCT. These checks can be asynchronous and need only be done once per each certificate. In order to protect the clients&#39; privacy, these checks need not reveal the exact certificate to the log. Clients can instead request the proof from a trusted auditor (since anyone can compute the audit proofs from the log) or request Merkle proofs for a batch of certificates around the SCT timestamp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MMD契約の違反は、各観測SCT用マークル監査の証拠を要求するログクライアントによって検出されます。これらのチェックは非同期にすることができ、唯一の各証明書ごとに一度行われる必要があります。お客様のプライバシーを保護するためには、これらのチェックは、ログへの正確な証明書を明らかにする必要はありません。 （誰でもログから監査証明を計算することができるので）、またはSCTタイムスタンプの周りの証明書のバッチのマークル証明を要求するクライアントは、代わりに信頼され、監査人からの証明を要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Violation of the append-only property is detected by global gossiping, i.e., everyone auditing logs comparing their versions of the latest Signed Tree Heads. As soon as two conflicting Signed Tree
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
追加専用プロパティの違反は、グローバル噂、最新の署名ツリーヘッドの彼らのバージョンを比較する、すなわち、誰も監査ログによって検出されます。すぐに2としては、ツリー署名相反する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Heads for the same log are detected, this is cryptographic proof of that log&#39;s misbehavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じログのヘッドが検出され、これはそのログの不正行為の暗号化証明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Efficiency Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.効率の検討
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Merkle Tree design serves the purpose of keeping communication overhead low.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マークル木のデザインは、オーバーヘッドの低い通信を維持する目的を果たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Auditing logs for integrity does not require third parties to maintain a copy of each entire log. The Signed Tree Heads can be updated as new entries become available, without recomputing entire trees. Third-party auditors need only fetch the Merkle consistency proofs against a log&#39;s existing STH to efficiently verify the append-only property of updates to their Merkle Trees, without auditing the entire tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
整合性のための監査ログは、各ログ全体のコピーを維持するために第三者を必要としません。新しいエントリが利用可能になったとして署名ツリーヘッドは、ツリー全体を再計算せずに、更新することができます。サードパーティの監査役は、効率的にツリー全体を監査することなく、彼らのハッシュ木への更新の追加専用プロパティを検証するために、ログの既存のSTHに対してマークル一貫性の証明を取得するだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Future Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.将来の変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section lists things we might address in a Standards Track version of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、我々は、この文書の標準化過程のバージョンに対処する可能性がある事を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Rather than forcing a log operator to create a new log in order to change the log signing key, we may allow some key roll mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oむしろログ署名キーを変更するために新しいログを作成するには、ログ演算子を強制するよりも、我々はいくつかのキーロールメカニズムを可能にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o We may add hash and signing algorithm agility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O私たちは、ハッシュと署名アルゴリズムの俊敏性を追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o We may describe some gossip protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O我々はいくつかのゴシッププロトコルを記述することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The authors would like to thank Erwann Abelea, Robin Alden, Al Cutter, Francis Dupont, Stephen Farrell, Brad Hill, Jeff Hodges, Paul Hoffman, Jeffrey Hutzelman, SM, Alexey Melnikov, Chris Palmer, Trevor Perrin, Ryan Sleevi, Rob Stradling, and Carl Wallace for their valuable contributions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者は、Erwann Abelea、ロビン・オールデン、アルカッター、フランシスデュポン、スティーブン・ファレル、ブラッド・ヒル、ジェフ・ホッジス、ポール・ホフマン、ジェフリーHutzelman、SM、アレクセイ・メルニコフ、クリス・パーマー、トレバー・ペラン、ライアンSleevi、ロブStradlingに感謝したいと思いますそして彼らの貴重な貢献のためのカール・ウォレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Normative Reference
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CrosbyWallach] Crosby, S. and D. Wallach, &#34;Efficient Data Structures for Tamper-Evident Logging&#34;, Proceedings of the 18th USENIX Security Symposium, Montreal, August 2009, &lt;http://static.usenix.org/event/sec09/ tech/full_papers/crosby.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CrosbyWallach]はクロスビー、S.およびD.ウォラック、「改ざん防止用のロギングのための効率的なデータ構造」、第18回USENIXセキュリティシンポジウム、モントリオール、2009年8月の議事録、&lt;http://static.usenix.org/event/sec09 /ハイテク/ full_papers / crosby.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS] National Institute of Standards and Technology, &#34;Digital Signature Standard (DSS)&#34;, FIPS 186-3, June 2009, &lt;http://csrc.nist.gov/publications/fips/ fips186-3/fips_186-3.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS]米国国立標準技術研究所は、 &#34;デジタル署名標準（DSS）&#34;、186-3、2009年6月、&lt;http://csrc.nist.gov/publications/fips/ FIPS186-3 / fips_186-3 FIPS。 PDF&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FIPS.180-4] National Institute of Standards and Technology, &#34;Secure Hash Standard&#34;, FIPS PUB 180-4, March 2012, &lt;http://csrc.nist.gov/publications/fips/fips180-4/ fips-180-4.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FIPS.180-4]アメリカ国立標準技術研究所、 &#34;セキュアハッシュ標準&#34;、FIPS PUB 180-4の、2012年3月、&lt;http://csrc.nist.gov/publications/fips/fips180-4/ fips- 180-4.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HTML401] Raggett, D., Le Hors, A., and I. Jacobs, &#34;HTML 4.01 Specification&#34;, World Wide Web Consortium Recommendation REC-html401-19991224, December 1999, &lt;http://www.w3.org/TR/1999/REC-html401-19991224&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HTML401] Raggett、D.、ル・オードブル、A.、およびI.ジェイコブス、 &#34;HTML 4.01仕様書&#34;、World Wide Web Consortium（W3C）の勧告REC-html401-19991224、1999年12月、&lt;http://www.w3.org/ TR / 1999 / REC-html401-19991224&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2560] Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, &#34;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&#34;, RFC 2560, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2560]マイヤーズ、M.、Ankney、R.、Malpani、A.、Galperin、S.、およびC.アダムス、 &#34;X.509のインターネット公開鍵暗号基盤のオンライン証明書状態プロトコル -  OCSP&#34;、RFC 2560、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3447] Jonsson, J. and B. Kaliski, &#34;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1&#34;, RFC 3447, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3447]ジョンソン、J.とB. Kaliski、 &#34;公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1&#34;、RFC 3447、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4627] Crockford, D., &#34;The application/json Media Type for JavaScript Object Notation (JSON)&#34;, RFC 4627, July 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4627]クロックフォード、D.、RFC 4627、2006年7月 &#34;JavaScriptのObject Notation（JSON）形式のためのアプリケーション/ JSONのメディアタイプ&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4648] Josefsson, S., &#34;The Base16, Base32, and Base64 Data Encodings&#34;, RFC 4648, October 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4648] Josefsson氏、S.、 &#34;Base16、Base32、およびBase64でデータエンコーディング&#34;、RFC 4648、2006年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, August 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5246]ダークス、T.およびE.レスコラ、 &#34;トランスポート層セキュリティ（TLS）プロトコルバージョン1.2&#34;、RFC 5246、2008年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 5280, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5905] Mills, D., Martin, J., Burbank, J., and W. Kasch, &#34;Network Time Protocol Version 4: Protocol and Algorithms Specification&#34;, RFC 5905, June 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5905]ミルズ、D.、マーティン、J.、バーバンク、J.、およびW. Kasch、 &#34;ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様&#34;、RFC 5905、2010年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6066] Eastlake, D., &#34;Transport Layer Security (TLS) Extensions: Extension Definitions&#34;, RFC 6066, January 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6066]イーストレイク、D.、 &#34;トランスポート層セキュリティ（TLS）拡張機能：拡張定義&#34;、RFC 6066、2011年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ben Laurie Google UK Ltd.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ベン・ローリーグーグルUK社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: benl@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：benl@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Adam Langley Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アダム・ラングレーグーグル株式会社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: agl@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：agl@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Emilia Kasper Google Switzerland GmbH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エミリア・カスパーGoogleのスイス社
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: ekasper@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：ekasper@google.com
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
