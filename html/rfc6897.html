<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 6897 - Multipath TCP (MPTCP) Application Interface Considerations 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6897</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6897 - Multipath TCP (MPTCP) Application Interface Considerations 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc6897">
              https://tools.ietf.org/html/rfc6897
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6897 - マルチTCP（MPTCP）アプリケーションインタフェースの考慮事項</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         M. Scharf
Request for Comments: 6897                      Alcatel-Lucent Bell Labs
Category: Informational                                          A. Ford
ISSN: 2070-1721                                                    Cisco
                                                              March 2013
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Multipath TCP (MPTCP) Application Interface Considerations
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multipath TCP (MPTCP) adds the capability of using multiple paths to a regular TCP session. Even though it is designed to be totally backward compatible to applications, the data transport differs compared to regular TCP, and there are several additional degrees of freedom that applications may wish to exploit. This document summarizes the impact that MPTCP may have on applications, such as changes in performance. Furthermore, it discusses compatibility issues of MPTCP in combination with non-MPTCP-aware applications. Finally, the document describes a basic application interface that is a simple extension of TCP&#39;s interface for MPTCP-aware applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチTCP（MPTCP）は、通常のTCPセッションに複数のパスを使用しての機能を追加します。アプリケーションに互換性を完全に後方になるように設計されていても、データ転送が異なるが、通常のTCPと比較すると、アプリケーションが利用することを望むかもしれないいくつかの自由度の追加があります。この文書では、MPTCPは、このような性能の変化などのアプリケーション、に与える影響をまとめたものです。さらに、それは非MPTCP対応アプリケーションとの組み合わせでMPTCPの互換性の問題について説明します。最後に、文書がMPTCP対応アプリケーションのためのTCPのインターフェースの単純な拡張である基本的なアプリケーションインタフェースを記述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6897.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6897で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................3
   2. Terminology .....................................................4
   3. Comparison of MPTCP and Regular TCP .............................5
      3.1. Effect on Performance ......................................5
           3.1.1. Throughput ..........................................5
           3.1.2. Delay ...............................................6
           3.1.3. Resilience ..........................................7
      3.2. Potential Problems .........................................8
           3.2.1. Impact of Middleboxes ...............................8
           3.2.2. Dealing with Multiple Addresses inside
                  Applications ........................................9
           3.2.3. Security Implications ..............................10
   4. Operation of MPTCP with Legacy Applications ....................10
      4.1. Overview of the MPTCP Network Stack .......................10
      4.2. Address Issues ............................................11
           4.2.1. Specification of Addresses by Applications .........11
           4.2.2. Querying of Addresses by Applications ..............12
      4.3. MPTCP Connection Management ...............................13
           4.3.1. Reaction to Close Call by Application ..............13
           4.3.2. Other Connection Management Functions ..............13
      4.4. Socket Option Issues ......................................13
           4.4.1. General Guideline ..................................13
           4.4.2. Disabling of the Nagle Algorithm ...................13
           4.4.3. Buffer Sizing ......................................14
           4.4.4. Other Socket Options ...............................14
      4.5. Default Enabling of MPTCP .................................14
      4.6. Summary of Advice to Application Developers ...............15
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   5. Basic API for MPTCP-Aware Applications .........................15
      5.1. Design Considerations .....................................15
      5.2. Requirements on the Basic MPTCP API .......................16
      5.3. Sockets Interface Extensions by the Basic MPTCP API .......17
           5.3.1. Overview ...........................................17
           5.3.2. Enabling and Disabling of MPTCP ....................19
           5.3.3. Binding MPTCP to Specified Addresses ...............19
           5.3.4. Querying the MPTCP Subflow Addresses ...............20
           5.3.5. Getting a Unique Connection Identifier .............20
   6. Other Compatibility Issues .....................................21
      6.1. Usage of TLS over MPTCP ...................................21
      6.2. Usage of the SCTP Sockets API .............................21
      6.3. Incompatibilities with Other Multihoming Solutions ........21
      6.4. Interactions with DNS .....................................22
   7. Security Considerations ........................................22
   8. Conclusion .....................................................23
   9. Acknowledgments ................................................23
   10. References ....................................................24
      10.1. Normative References .....................................24
      10.2. Informative References ...................................24
   Appendix A. Requirements on a Future Advanced MPTCP API ...........26
     A.1. Design Considerations ......................................26
     A.2. MPTCP Usage Scenarios and Application Requirements .........27
     A.3. Potential Requirements on an Advanced MPTCP API ............29
     A.4. Integration with the SCTP Sockets API ......................30
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multipath TCP adds the capability of using multiple paths to a regular TCP session [1]. The motivations for this extension include increasing throughput, overall resource utilization, and resilience to network failure, and these motivations are discussed, along with high-level design decisions, as part of the multipath TCP architecture [4]. MPTCP [5] offers the same reliable, in-order, byte-stream transport as TCP and is designed to be backward compatible with both applications and the network layer. It requires support inside the network stack of both endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチパスTCPは、通常のTCPセッションを[1]に複数のパスを使用する機能を追加します。この拡張のための動機は、ネットワーク障害の増加、スループット、全体的なリソース使用率、および弾性を含む、これらの動機は、高レベルの設計の決定と一緒に、議論されているマルチパスTCPアーキテクチャの一部として、[4]。 MPTCP [5] TCPと同じ信頼性、インオーダー、バイトストリームトランスポートを提供し、アプリケーションとネットワーク層の両方との下位互換性があるように設計されています。これは、両方のエンドポイントのネットワークスタック内のサポートが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document first presents the effects that MPTCP may have on applications, such as performance changes compared to regular TCP. Second, it defines the interoperation of MPTCP and applications that are unaware of the multipath transport. MPTCP is designed to be usable without any application changes, but some compatibility issues have to be taken into account. Third, this memo specifies a basic Application Programming Interface (API) for MPTCP-aware applications. The API presented here is an extension to the regular TCP API to allow an MPTCP-aware application the equivalent level of control and access to information of an MPTCP connection that would be possible with the standard TCP API on a regular TCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、最初のMPTCPは、通常のTCPに比べて、このようなパフォーマンスの変化などのアプリケーション上で持っていることの影響を示しています。第二に、それはマルチパスの輸送を知らないMPTCPとアプリケーションの相互運用を定義します。 MPTCPは、任意のアプリケーションを変更せずに使用できるように設計されていますが、いくつかの互換性の問題を考慮しなければなりませんさ。第三に、このメモはMPTCP対応アプリケーションのための基本的なアプリケーション・プログラミング・インタフェース（API）を指定します。ここで紹介するAPIはMPTCP対応アプリケーションを制御し、通常のTCPコネクション上の標準TCPのAPIで可能なMPTCP接続の情報へのアクセスと同等のレベルを可能にするために、通常のTCP APIの拡張機能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The de facto standard API for TCP/IP applications is the &#34;sockets&#34; interface [8]. This document provides an abstract definition of MPTCP-specific extensions to this interface. These are operations that can be used by an application to get or set additional MPTCP-specific information on a socket, in order to provide an equivalent level of information and control over MPTCP as exists for an application using regular TCP. It is up to the applications, high-level programming languages, or libraries to decide whether to use these optional extensions. For instance, an application may want to turn on or off the MPTCP mechanism for certain data transfers or limit its use to certain interfaces. The abstract specification is in line with the Portable Operating System Interface (POSIX) standard [8] as much as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP / IPアプリケーションのための事実上の標準APIは、「ソケット」インターフェースである[8]。この文書では、このインターフェイスにMPTCP固有の拡張機能の抽象定義を提供します。これらは、取得または定期的なTCPを用いたアプリケーションのために存在するようにMPTCPを介して情報や制御と同等のレベルを提供するために、ソケットに追加MPTCP固有の情報を設定するためにアプリケーションが使用できる操作です。これは、これらのオプションの拡張機能を使用するかどうかを決定するためのアプリケーション、高レベルのプログラミング言語、または図書館までです。例えば、アプリケーションは、特定のデータ転送のためMPTCP機構またはオフにしたり、特定のインターフェイスにその使用を制限することができます。抽象仕様は、ポータブルオペレーティングシステムインタフェース（POSIX）に沿ったものである標準[8]できるだけ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An advanced API for MPTCP is outside the scope of this document. Such an advanced API could offer a more fine-grained control over multipath transport functions and policies. The appendix includes a brief, non-compulsory list of potential features of such an advanced API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPのための高度なAPIは、この文書の範囲外です。このような高度なAPIは、マルチパストランスポート機能とポリシーをよりきめ細かく制御を提供することができます。付録には、このような高度なAPIの潜在的な機能の簡単な、非強制的なリストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There can be interactions or incompatibilities of MPTCP with other APIs or sockets interface extensions, which are discussed later in this document. Some network stack implementations, especially on mobile devices, have centralized connection managers or other higher-level APIs to solve multi-interface issues, as surveyed in [15]. Their interaction with MPTCP is outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文書で後述される他のAPIまたはソケットインタフェースの拡張とMPTCPの相互作用または非互換性が存在することができます。特にモバイルデバイス上のいくつかのネットワークスタックの実装は、[15]に調査されるように、マルチインタフェースの問題を解決するために集中接続マネージャまたは他の高レベルAPIを有します。 MPTCPとの相互作用は、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The target readers of this document are application developers whose software may benefit significantly from MPTCP. This document also provides the necessary information for developers of MPTCP to implement the API in a TCP/IP network stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの対象読者は、そのソフトウェアMPTCPから大幅に利益を得ることができるアプリケーションの開発者です。この文書はまた、TCP / IPネットワークスタックのAPIを実装するMPTCPの開発者に必要な情報を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります[3]で説明されるように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses the MPTCP terminology introduced in [5].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、[5]で導入MPTCP用語を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Concerning the API towards applications, the following terms are distinguished:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションへのAPIについては、次の用語は区別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Legacy API: The interface towards TCP that is currently used by applications. This document explains the effect of MPTCP for such applications, as well as resulting issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OレガシーAPI：現在のアプリケーションで使用されるTCPへのインタフェース。この文書では、このようなアプリケーションのためのMPTCPの効果を説明し、同様の問題が生じました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Basic API: A simple extension of TCP&#39;s interface for applications that are aware of MPTCP. This document abstractly describes this interface, which provides access to multipath address information and a level of control equivalent to regular TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O基本API：MPTCPを認識しているアプリケーションのためのTCPのインターフェイスを単純に拡張。この文書では、抽象的に、マルチパスのアドレス情報と、通常のTCPと同等の制御のレベルへのアクセスを提供し、このインタフェースを記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Advanced API: An API that offers more fine-grained control over the behavior of MPTCP. Its specification is outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O拡張API：MPTCPの行動をよりきめ細かく制御を提供していますAPI。その仕様は、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Comparison of MPTCP and Regular TCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. MPTCPの比較と正規TCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section discusses the effect of MPTCP on performance as seen by an application, in comparison to what may be expected from the use of regular TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、通常のTCPの使用から予想されるものに比較して、アプリケーションから見たパフォーマンスにMPTCPの影響を論じています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Effect on Performance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. パフォーマンスへの影響
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the key goals of adding multipath capability to TCP is to improve the performance of a transport connection by load distribution over separate subflows across potentially disjoint paths. Furthermore, it is an explicit goal of MPTCP that it provides a connection that performs at least as well as one using single-path TCP. A corresponding congestion control algorithm is described in [7]. The following sections summarize the performance effect of MPTCP as seen by an application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPへのマルチパス機能を追加することの重要な目標の一つは、潜在的にばらばらのパス間で別のサブフローを超える負荷分散により、トランスポート接続のパフォーマンスを向上させることです。さらに、それは、少なくとも、ならびに単一パスTCPを使用して実行する接続を提供することがMPTCPの明確な目標です。対応する輻輳制御アルゴリズムは、[7]に記載されています。アプリケーションによって見られるように、以下のセクションでは、MPTCPのパフォーマンスへの影響をまとめたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Throughput
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. スループット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most obvious performance improvement that can be expected from the use of MPTCP is an increase in throughput, since MPTCP will pool more than one path (where available) between two endpoints. This will usually provide as great or greater bandwidth for an application, even though exceptions may exist, e.g., due to differences in the congestion control dynamics. For instance, if a new subflow is started, the short-term throughput can be smaller than the theoretical optimum. If there are shared bottlenecks between the flows, then the congestion control algorithms will in most cases ensure that load is evenly spread amongst regular and multipath TCP sessions, so that no end user receives worse performance than if all were using single-path TCP. There are some known corner cases in which an upgrade to MPTCP can affect other users [21].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPが2つのエンドポイント間の複数のパス（使用可能）をプールするのでMPTCPの使用から期待できる最も明白な性能向上は、スループットの増加です。例外が存在する可能性があるにもかかわらず、これは通常、輻輳制御のダイナミクスの違いに、例えば、アプリケーションのように偉大以上の帯域幅を提供します。新しいサブフローが開始された場合例えば、短期スループットは理論上の最適よりも小さくすることができます。フロー間で共有ボトルネックが存在する場合、輻輳制御アルゴリズムは、ほとんどの場合、何のエンドユーザーは、すべてのシングルパスTCPを使用していた場合よりも悪いパフォーマンスを受信しないように、その負荷が均等に、定期的なマルチパスTCPセッションの間で広がっていることを確認します。 MPTCPへのアップグレードは、他のユーザー[21]影響を与える可能性があるいくつかの既知のコーナーケースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This performance increase additionally means that an MPTCP session could achieve throughput that is greater than the capacity of a single interface on the device. If any applications make assumptions about interfaces due to throughput, they must take this into account (although an MPTCP implementation must always respect an application&#39;s request for a particular interface).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このパフォーマンスの向上は、さらにMPTCPセッションは、デバイス上の単一のインターフェースの容量よりも大きいスループットを達成できることを意味します。任意のアプリケーションがスループットのためにインターフェイスに関する仮定を行う場合（MPTCPの実装は、常に特定のインターフェイスのためのアプリケーションの要求を尊重しなければならないが）、彼らはこれを考慮に入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, the flexibility of MPTCP to add and remove subflows as paths change availability could lead to a greater variation, and more frequent change, in connection bandwidth. Applications that adapt to available bandwidth (such as video and audio streaming) may need to adjust some of their assumptions to most effectively take this into account.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、パス状況を変更するようにサブフローを追加および削除するMPTCPの柔軟性は、接続帯域幅で、より大きな変化をもたらし、より頻繁に変化する可能性があります。 （ビデオやオーディオのストリーミングなど）、利用可能な帯域幅に対応するアプリケーションは、最も効果的にこれを考慮に入れるために彼らの仮定の一部を調整する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transport of MPTCP signaling information results in a small overhead. The use of MPTCP instead of a single TCP connection therefore results in a smaller goodput. Also, if multiple subflows share a same bottleneck, this overhead slightly reduces the capacity that is available for data transport. Yet, this potential reduction of throughput will be negligible in many usage scenarios, and the protocol contains optimizations in its design so that this overhead is minimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPシグナリング情報の転送は小さなオーバーヘッドをもたらします。 MPTCPの代わりに、単一のTCP接続の使用は、したがって、より小さなグッドプットをもたらします。複数のサブフローが同じボトルネックを共有している場合も、このオーバーヘッドはわずかデータ転送のために利用可能な容量を低減します。しかし、スループットのこの潜在的な減少は、多くの利用シナリオに無視することができるであろう、そしてこのオーバーヘッドが最小限になるように、プロトコルは、そのデザインの最適化が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. Delay
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. ディレイ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The benefits of MPTCP regarding throughput and resilience may come at some cost regarding data delivery delay and delay jitter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スループットと回復力に関するMPTCPのメリットは、データ配信遅延と遅延ジッタに関するいくつかのコストで来るかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the delays on the constituent subflows of an MPTCP connection differ, the jitter perceivable to an application may appear higher as the data are spread across the subflows. Although MPTCP will ensure in-order delivery to the application, the data delivery could be more bursty than may be usual with single-path TCP, in particular on highly asymmetric paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCP接続の構成サブフローに遅延が異なる場合、データがサブフローに分散されているように、アプリケーションにジッタ知覚が高く表示されることがあります。 MPTCPは、アプリケーションへのインオーダー配信を保証するが、データの配信は非常に非対称の経路上特に、シングルパスTCPと通常かもしれよりバースト的とすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications with high real-time requirements might be affected by such a scenario. One possible remedy is to disable MPTCP for such jitter-sensitive applications, either by using the basic API defined in this document, or by other means, such as system policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高いリアルタイム要件を持つアプリケーションでは、このようなシナリオの影響を受ける可能性があります。一つの可能​​な救済策は、この文書で定義された基本的なAPIを使用することによって、または、そのようなシステムポリシーのような他の手段のいずれかによって、そのようなジッタに敏感なアプリケーションのためのMPTCPを無効にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, the actual delay and jitter of data transport over MPTCP depend on the scheduling and congestion control algorithms used for sending data, as well as the heuristics to establish and shut down subflows. A sender can implement strategies to minimize the delay jitter seen by applications, but this requires an accurate estimation of the path characteristics. If the scheduling decisions are suboptimal or if assumptions about the path characteristics turn out to be wrong, delay jitter may be increased and affect delay-sensitive applications. In general, for a delay-sensitive application, it would be desirable to select an appropriate congestion control algorithm for its traffic needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、MPTCP上のデータ伝送の実際の遅延とジッタがサブフローを確立し、シャットダウンするデータを送信するために使用されるスケジューリングと輻輳制御アルゴリズム、ならびにヒューリスティックに依存します。送信者は、アプリケーションから見た遅延ジッタを最小化するための戦略を実装することができますが、これはパス特性の正確な推定が必要となります。スケジューリングの決定が最適ではない場合、またはパス特性に関する仮定が間違っていることが判明する場合、遅延ジッタが増加し、遅延に敏感なアプリケーションに影響を与えることができます。一般に、遅延に敏感なアプリケーションのために、そのトラフィックのニーズに適した輻輳制御アルゴリズムを選択することが望ましいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternatively, MPTCP could be used in high-reliability, rather than high-throughput, modes of operation, such as by mirroring traffic on subflows, or by only using additional subflows for hot standby. These methods of traffic scheduling would not cause delay variation in the same way. These additional modes, and the selection of alternative scheduling algorithms, would need to be indicated by an advanced API, the specification of which requires further analysis and is outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あるいは、MPTCPは、高信頼性ではなく、高スループット、例えばサブフローに、または唯一のホットスタンバイのための追加のサブフローを使用してトラフィックをミラーリングするなどの動作モードで使用することができます。トラフィックスケジューリングのこれらのメソッドは、同じように遅延変動を引き起こすことはありません。これらの追加のモード、および代替のスケジューリング・アルゴリズムの選択は、の仕様はさらなる分析が必要であり、この文書の範囲外であり、高度なAPIによって示される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If data transport on one subflow fails, the retransmissions inside MPTCP could affect the delivery delay to the application. Yet, without MPTCP that data or the whole connection might have been lost, and other reliability mechanisms (e.g., application-level recovery) would likely have an even larger delay impact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つのサブフロー上のデータ転送が失敗した場合、MPTCP内部の再送信は、アプリケーションへの配信遅延に影響を与える可能性があります。まだ、データまたは全体の接続が失われた可能性があることMPTCP、および他の信頼性メカニズム（例えば、アプリケーションレベルの回復）することなく、可能性も大きな遅延の影響を有するであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, applications that make round-trip time (RTT) estimates at the application level may have some issues. Whilst the average delay calculated will be accurate, whether this is useful for an application will depend on what it requires this information for. If a new application wishes to derive such information, it should consider how multiple subflows may affect its measurements and thus how it may wish to respond. In such a case, an application may wish to express its scheduling preferences, as described later in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、ラウンドトリップ時間（RTT）は、アプリケーションレベルで推定するアプリケーションは、いくつかの問題を有することができます。これは、それがために、この情報を必要とするものに依存するアプリケーションのために有用であるかどうかを、正確になり、算出した平均遅延しながら。新しいアプリケーションは、このような情報を導出することを希望する場合は、複数のサブフローは、その測定結果に影響を与える可能性がどのようにので、それが応答することを望むかもしれない方法を検討する必要があります。このような場合、アプリケーションは、本書で後述するように、そのスケジューリング・プリファレンスを表現することを望むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. Resilience
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. 回復力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another performance improvement through the use of MPTCP is better resilience. The use of multiple subflows simultaneously means that if one should fail, all traffic will move to the remaining subflow(s), and additionally any lost packets can be retransmitted on these subflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPを使用して別のパフォーマンスの向上は、より良い回復力です。複数のサブフローの使用は同時に1に障害が発生した場合、すべてのトラフィックは残りのサブフロー（複数可）に移動し、さらに任意の失われたパケットは、これらのサブフローで再送信することができることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As one special case, MPTCP can be used with only one active subflow at a given point in time. In that case, resilience compared to single-path TCP is improved. MPTCP also supports make-before-break and break-before-make handovers between subflows. In both cases, the MPTCP connection can survive an unavailability or change of an IP address (e.g., due to shutdown of an interface or handover). MPTCP closes or resets the MPTCP connection separately from the individual subflows, as described in [5].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1特殊なケースとして、MPTCPは、ある時点でのみアクティブサブフローで使用することができます。その場合には、シングルパスTCPに比べて反発性が向上します。 MPTCPも・ビフォア・ブレークを作成し、ブレーク・ビフォア・メークのサブフロー間のハンドオーバをサポートしています。両方の場合において、MPTCP接続は、IPアドレス（例えば、原因インタフェース又はハンドオーバのシャットダウン）が利用できない又は変化に耐えることができます。 [5]で説明されるようMPTCPは、個々のサブフローは別にMPTCP接続を終了またはリセットします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subflow failure may be caused by issues within the network, which an application would be unaware of, or interface failure on the node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブフロー障害は、アプリケーションがノード上、またはインタフェースの故障に気付かないであろうネットワーク内の問題によって引き起こされる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application may, under certain circumstances, be in a position to be aware of such failure (e.g., by radio signal strength, or simply an interface enabled flag), and so must not make assumptions of an MPTCP flow&#39;s stability based on this. An MPTCP implementation must never override an application&#39;s request for a given interface, however, so the cases where this issue may be applicable are limited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、特定の状況下で、そのような故障（例えば、無線信号強度、または単にインターフェイス有効フラグによる）を認識するために、およびそうこれに基づいてMPTCPフローの安定性の仮定をしてはならない位置にあってもよいです。 MPTCPの実装では、しかし、特定のインターフェイスのためのアプリケーションの要求を上書きしてはなりませんので、この問題は、適用可能な例は限られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Potential Problems
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 潜在的な問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. Impact of Middleboxes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1.  Middleboxesの影響
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCP has been designed to pass through the majority of middleboxes. Empirical evidence suggests that new TCP options can successfully be used on most paths in the Internet [22]. Nevertheless, some middleboxes may still refuse to pass MPTCP messages due to the presence of TCP options, or they may strip TCP options. If this is the case, MPTCP falls back to regular TCP. Although this will not create a problem for the application (its communication will be set up either way), there may be additional (and indeed, user-perceivable) delay while the first handshake fails. Therefore, an alternative approach could be to try both MPTCP and regular TCP connection attempts at the same time and respond to whichever replies first, in a fashion similar to the &#34;Happy Eyeballs&#34; mechanism for IPv6 [16]. One could also apply a shorter timeout on the MPTCP attempt and thus reduce the setup delay if fallback to regular TCP is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPは、ミドルボックスの大半を通過するように設計されています。実証的証拠は、新たなTCPオプションが正常にインターネット[22]の中で最もパス上で使用することができることを示唆しています。それにもかかわらず、一部のミドルボックスは、まだ原因TCPオプションの存在にMPTCPメッセージを渡すことを拒否することがあり、あるいは、それらはTCPオプションを取り除くことがあります。この場合は、MPTCPは戻って、通常のTCPに落ちます。これは（その通信は、いずれかの方法で設定されます）アプリケーションのための問題を作成しませんが、追加的な（実際と、ユーザが知覚）があるかもしれない最初のハンドシェイクが失敗しながら遅らせます。したがって、別のアプローチを同時にMPTCPと通常のTCP接続試行の両方を試みるとIPv6 [16]のための「ハッピー眼球」機構と同様の方法で、最初の返信いずれかに応答するかもしれません。一つは、またMPTCPの試みに短いタイムアウトを適用するため、通常のTCPへのフォールバックが必要な場合は、セットアップ遅延を減らすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An MPTCP implementation can learn the rate of MPTCP connection attempt successes or failures to particular hosts or networks, and on particular interfaces, and could therefore learn heuristics of when and when not to use MPTCP. A detailed discussion of the various fallback mechanisms, for failures occurring at different points in the connection, is presented in [5]. It must be emphasized that all such heuristics could also fail, and learning can be difficult in certain environments, e.g., if the host is mobile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCP実装は、特定のホストまたはネットワークにMPTCP接続試行の成功または失敗の割合を学び、特定のインターフェイス上で、従ってときMPTCPを使用しないのヒューリスティックを学ぶことができることができます。様々な代替の機構の詳細な議論は、接続中の異なる点で発生する障害のために、[5]に提示されています。ホストがモバイルの場合、例えば、そのようなすべての経験則も失敗する可能性があり、学習は、特定の環境では困難な場合がありますことを強調しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There may also be middleboxes that transparently change the length of content. If such middleboxes are present, MPTCP&#39;s reassembly of the byte stream in the receiver is difficult. Still, MPTCP can detect such middleboxes and then fall back to regular TCP. An overview of the impact of middleboxes is presented in [4], and MPTCP&#39;s mechanisms to work around these issues are presented and discussed in [5].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、透過的にコンテンツの長さを変更する中間ボックスがあるかもしれません。そのようなミドルボックスが存在する場合、受信機でのバイトストリームのMPTCPの再構築は困難です。それでも、MPTCPは、このようなミドルボックスを検出することができ、その後、通常のTCPにフォールバック。中間装置の影響の概要は、[4]に提示され、そしてこれらの問題を回避するMPTCPのメカニズムは、[5]に提示し、議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCP can also have other unexpected implications. For instance, intrusion detection systems could be triggered. A full analysis of MPTCP&#39;s impact on such middleboxes is for further study after deployment experiments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPまた、その他の予期しない影響を与える可能性があります。例えば、侵入検知システムが起動することができます。そのようなミドルボックスにMPTCPの影響の完全な分析は、展開実験の後、今後の検討課題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. Dealing with Multiple Addresses inside Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. アプリケーション内の複数アドレスへの対処
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In regular TCP, there is a one-to-one mapping of the sockets interface to a flow through a network. Since MPTCP can make use of multiple subflows, applications cannot implicitly rely on this one-to-one mapping any more.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規TCPでは、ネットワークを通って流れるようにソケットインタフェースの1対1のマッピングがあります。 MPTCPは、複数のサブフローを利用することができるので、アプリケーションは暗黙的にこれ以上、この1対1のマッピングに依存することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whilst this doesn&#39;t matter for most applications, some applications may need to adapt to the presence of multiple addresses, because implicit assumptions are outdated. In this section, selected examples for resulting issues are discussed. The question of whether such implicit assumptions matter is an application-level decision, and this document only provides general guidance and a basic API to retrieve relevant information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはほとんどのアプリケーションのために重要ではありませんしながら、暗黙の前提が古くなっているので、いくつかのアプリケーションは、複数のアドレスの存在に適応する必要があるかもしれません。このセクションでは、得られた問題のために選択された例が論じられています。そのような暗黙の仮定は問題かどうかの問題は、アプリケーションレベルの意思決定であり、このドキュメントでは、一般的なガイダンスおよび関連する情報を取得するための基本的なAPIを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A few applications require the transport to be along a single path; they can disable the use of MPTCP as described later in this document. Examples include monitoring tools that want to measure the available bandwidth on a path, or routing protocols such as BGP that require the use of a specific link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのアプリケーションは、単一の経路に沿うように搬送を必要とします。このドキュメントで後述するように、彼らはMPTCPの使用を無効にすることができます。例としては、パスで利用可能な帯域幅を測定する監視ツール、あるいは、そのような特定のリンクを使用する必要がBGPなどのルーティングプロトコルが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain applications store the IP addresses of TCP connections, e.g., by logging mechanisms. Such logging mechanisms will continue to work with MPTCP, but two important aspects have to be mentioned: First, if the application is not aware of MPTCP, it will use the existing interface to the network stack. This implies that an MPTCP-unaware application will track the IP addresses of the first subflow only. IP addresses used by follow-up subflows will be ignored. Second, an MPTCP-aware application can use the basic API described in this document to monitor the IP addresses of all subflows, e.g., for logging mechanisms. If an MPTCP connection uses several subflows, this will possibly imply that data structures have to be adapted and that the amount of data that has to be logged and stored per connection will increase.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションでは、メカニズムをロギングすることで、例えば、TCP接続のIPアドレスを格納します。このようなログメカニズムがMPTCPと協力していきますが、二つの重要な側面が言及する必要がある。まず、アプリケーションはMPTCPを認識していない場合、それは、ネットワークスタックに既存のインターフェースを使用します。これはMPTCP非対応アプリケーションのみ、最初のサブフローのIPアドレスを追跡することを意味します。フォローアップのサブフローが使用するIPアドレスは無視されます。第二に、MPTCP対応アプリケーションは、ロギングメカニズムのために、例えば、すべてのサブフローのIPアドレスを監視するには、この文書で説明した基本的なAPIを使用することができます。 MPTCP接続は、いくつかのサブフローを使用している場合、これはおそらくそのデータ構造は適応し、接続ごとに記録して保存する必要があるデータの量が増加することをする必要が意味するものではあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An MPTCP implementation may choose to maintain an MPTCP connection even if the IP address of the original subflow is no longer allocated to a host, depending on the policy concerning the first subflow (fate-sharing; see Section 4.2.2). In this case, the IP address exposed to an MPTCP-unaware application can differ from the addresses actually being used by MPTCP. It is even possible that the IP address gets assigned to another host during the lifetime of an MPTCP connection. As further discussed below, this could be an issue if the IP addresses are exchanged by applications, e.g., inside the application protocol. This issue can be addressed by enabling fate-sharing, at the cost of resilience, because the MPTCP connection then cannot close the initial subflow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCP実装は、元のサブフローのIPアドレスがもはや最初サブフロー（;参照4.2.2運命共有）に関するポリシーに応じて、ホストに割り当てられてもMPTCP接続を維持することを選択することができます。この場合、MPTCP非対応アプリケーションに露出IPアドレスは、実際にMPTCPによって使用されているアドレスと異なることができます。 IPアドレスがMPTCP接続の存続期間中に別のホストに割り当てられますことも可能です。さらに後述IPアドレスは、アプリケーションプロトコルの内側に、例えば、アプリケーションによって交換される場合、これは問題であり得ます。 MPTCP接続は、初期サブフローを閉じることができないため、この問題が、回復力のコストで、運命共有を有効にすることで対処することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. Security Implications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. セキュリティへの影響
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The support for multiple IP addresses within one MPTCP connection can result in additional security vulnerabilities, such as possibilities for attackers to hijack connections. The protocol design of MPTCP minimizes this risk. An attacker on one of the paths can cause harm, but this is hardly an additional security risk compared to single-path TCP, which is vulnerable to man-in-the-middle attacks as well. A detailed threat analysis of MPTCP is published in [6].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つのMPTCP接続内の複数のIPアドレスのサポートは、このような接続をハイジャックする攻撃の可能性などの追加のセキュリティ上の脆弱性をもたらすことができます。 MPTCPのプロトコルの設計は、このリスクを最小限に抑えることができます。パスのいずれかに攻撃者が害を引き起こす可能性がありますが、これは、同様man-in-the-middle攻撃に対して脆弱であるシングルパスTCPに比べてほとんど追加のセキュリティリスクです。 MPTCPの詳細な脅威分析は、[6]で公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Impact on Transport Layer Security (TLS) is discussed in Section 6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート層セキュリティ（TLS）への影響は、セクション6.1で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Operation of MPTCP with Legacy Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
レガシーアプリケーションとMPTCPの4.操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Overview of the MPTCP Network Stack
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.  MPTCPネットワークスタックの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCP is an extension of TCP, but it is designed to be backward compatible for legacy (MPTCP-unaware) applications. TCP interacts with other parts of the network stack via different interfaces. The de facto standard API between TCP and applications is the sockets interface. The position of MPTCP in the protocol stack is illustrated in Figure 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPは、TCPの拡張であるが、レガシー（MPTCP非対応）アプリケーションのための後方互換性があるように設計されています。 TCPは、異なるインターフェースを介して、ネットワークスタックの他の部分と相互作用します。 TCPとアプリケーション間の事実上の標準APIは、ソケットインタフェースです。プロトコルスタックにおけるMPTCPの位置は、図1に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     +-------------------------------+
                     |           Application         |
                     +-------------------------------+
                            ^                  |
                  ~~~~~~~~~~|~Sockets Interface|~~~~~~~~~
                            |                  v
                     +-------------------------------+
                     |             MPTCP             |
                     + - - - - - - - + - - - - - - - +
                     | Subflow (TCP) | Subflow (TCP) |
                     +-------------------------------+
                     |       IP      |      IP       |
                     +-------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Figure 1: MPTCP Protocol Stack
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
図1：MPTCPプロトコルスタック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, MPTCP can affect all interfaces that make assumptions about the coupling of a TCP connection to a single IP address and TCP port pair, to one socket endpoint, to one network interface, or to a given path through the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、MPTCP 1つのネットワークインタフェースに、またはネットワークを介して指定されたパスに、1つのソケットのエンドポイントに、単一のIPアドレスとTCPポートのペアへのTCP接続の結合について仮定を行うすべてのインターフェイスに影響を与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This means that there are two classes of applications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、アプリケーションの2つのクラスがあることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Legacy applications: These applications are unaware of MPTCP and use the existing API towards TCP without any changes. This is the default case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oレガシーアプリケーション：これらのアプリケーションはMPTCPを知らないと何も変更せずにTCPに向けた既存のAPIを使用します。これはデフォルトの場合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MPTCP-aware applications: These applications indicate support for an enhanced MPTCP interface. This document specifies a minimum set of API extensions for such applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O MPTCP対応アプリケーション：これらのアプリケーションは、拡張MPTCPインターフェイスのサポートを示します。この文書では、このようなアプリケーションのためのAPIの拡張機能の最小セットを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following sections, it is discussed to what extent MPTCP affects legacy applications using the existing sockets API. The existing sockets API implies that applications deal with data structures that store, amongst others, the IP addresses and TCP port numbers of a TCP connection. A design objective of MPTCP is that legacy applications can continue to use the established sockets API without any changes. However, in MPTCP there is a one-to-many mapping between the socket endpoint and the subflows. This has several subtle implications for legacy applications using sockets API functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、MPTCPは、既存のソケットAPIを使用して、レガシーアプリケーションに影響を与えるどの程度まで議論されています。既存のソケットAPIは、アプリケーションが保存するデータ構造を扱うことを意味し、とりわけ、IPアドレスやTCP接続のTCPポート番号。 MPTCPの設計目標は、レガシーアプリケーションを変更せずに確立ソケットAPIを使用し続けることができるということです。しかし、MPTCPにソケットエンドポイントとサブフローの間に1対多のマッピングがあります。これは、ソケットAPI関数を使用して、レガシーアプリケーションのためのいくつかの微妙な意味合いを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Address Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. アドレスの問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Specification of Addresses by Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. 用途別のアドレスの仕様
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During binding, an application can either select a specific address or bind to INADDR_ANY. Furthermore, on some systems other socket options (e.g., SO_BINDTODEVICE) can be used to bind to a specific interface. If an application uses a specific address or binds to a specific interface, then MPTCP MUST respect this and not interfere in the application&#39;s choices. The binding to a specific address or interface implies that the application is not aware of MPTCP and will disable the use of MPTCP on this connection. An application that wishes to bind to a specific set of addresses with MPTCP must use multipath-aware calls to achieve this (as described in Section 5.3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結合時には、アプリケーションは、INADDR_ANYに特定のアドレスまたはバインドを選択することができます。さらに、いくつかのシステム上の他のソケットオプション（例えば、SO_BINDTODEVICE）は、特定のインターフェイスにバインドするために使用することができます。アプリケーションが特定のアドレスを使用するか、または特定のインターフェイスにバインドする場合は、MPTCPはこれを尊重して、アプリケーションの選択肢に干渉してはなりません。特定のアドレスに結合またはインタフェースは、アプリケーションがMPTCPを認識していないと、この接続でMPTCPの使用を無効にすることを意味します。 （セクション5.3.3で説明したように）MPTCPとアドレスの特定のセットにバインドしたいアプリケーションは、これを達成するために、マルチパス対応の呼び出しを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application binds to INADDR_ANY, it is assumed that the application does not care which addresses are used locally. In this case, a local policy MAY allow MPTCP to automatically set up multiple subflows on such a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、INADDR_ANYに結合する場合は、アプリケーションをローカルで使用されているアドレスを気にしないことが想定されます。この場合、ローカルポリシーはMPTCPは自動的に、このような接続で複数のサブフローを設定できるようにしてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic sockets API of MPTCP-aware applications allows the expression of further preferences in an MPTCP-compatible way (e.g., binding to a subset of interfaces only).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCP対応アプリケーションの基本的なソケットAPIは、（インターフェースのみのサブセットに結合する、例えば）MPTCP互換の方法でさらに好みの発現を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Querying of Addresses by Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. アプリケーションによってアドレスの照会
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications can use the getpeername() or getsockname() functions in order to retrieve the IP address of the peer or of the local socket. These functions can be used for various purposes, including security mechanisms, geo-location, or interface checks. The sockets API was designed with an assumption that a socket is using just one address, and since this address is visible to the application, the application may assume that the information provided by the functions is the same during the lifetime of a connection. However, in MPTCP, unlike in TCP, there is a one-to-many mapping of a connection to subflows, and subflows can be added and removed while the connection continues to exist. Since the subflow addresses can change, MPTCP cannot expose addresses by getpeername() or getsockname() that are both valid and constant during the connection&#39;s lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、ピアのまたはローカルソケットのIPアドレスを取得するために、getpeername（）またはのgetsockname（）関数を使用することができます。これらの機能は、セキュリティメカニズム、ジオロケーション、またはインターフェイスチェックを含む様々な目的に使用することができます。ソケットAPIは、ソケットは、単に1つのアドレスを使用していることを前提に設計された、このアドレスがアプリケーションに表示されるので、アプリケーションは機能によって提供される情報は、接続の存続期間中に同じであると仮定することができます。しかし、MPTCPに、TCPとは異なり、そこサブフローへの接続の1対多マッピングであり、接続が存在し続けている間サブフローを添加して除去することができます。サブフローアドレスは変更することができますので、MPTCPは、接続の存続期間中有効と定数の両方であるgetpeername（）またはのgetsockname（によってアドレス）を露出することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This problem is addressed as follows: If used by a legacy application, the MPTCP stack MUST always return the addresses and port numbers of the first subflow of an MPTCP connection, in all circumstances, even if that particular subflow is no longer in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のように、この問題は解決された：レガシー・アプリケーションで使用される場合は、MPTCPスタックは常にその特定のサブフローが使用されなくなった場合でも、すべての状況で、MPTCP接続の最初のサブフローのアドレスとポート番号を返してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the addresses may not be valid any more if the first subflow is closed, the MPTCP stack MAY close the whole MPTCP connection if the first subflow is closed (i.e., fate-sharing between the initial subflow and the MPTCP connection as a whole). This fate-sharing avoids the reuse of the pair of IP addresses and ports while an MPTCP connection is still in progress, but at the cost of reducing the utility of MPTCP if IP addresses of the first subflow are not available any more (e.g., mobility events). Whether to close the whole MPTCP connection by default SHOULD be controlled by a local policy. Further experiments are needed to investigate its implications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のサブフローが閉じている場合アドレスがもはや有効ではないかもしれないように、第1のサブフローが閉じている場合、MPTCPスタック全体MPTCP接続を閉じる（すなわち、初期サブフロー全体としてMPTCP接続との間の運命共有）。 MPTCP接続がまだ進行中である間、この運命共有は、IPアドレスとポートのペアの再利用を避けたが、MPTCPの有用性を低下させるコストで最初のサブフローのIPアドレスは、任意のより多くの（例えば、モビリティ利用できない場合イベント）。デフォルトでは、全体MPTCP接続をクローズするかどうかは、ローカルポリシーによって制御されなければなりません。さらなる実験は、その含意を調査するために必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The functions getpeername() and getsockname() SHOULD also always return the addresses of the first subflow if the socket is used by an MPTCP-aware application, in order to be consistent with MPTCP-unaware applications, and, e.g., also with the Stream Control Transmission Protocol (SCTP). Instead of getpeername() or getsockname(), MPTCP-aware applications can use new API calls, described in Section 5.3, in order to retrieve the full list of address pairs for the subflows in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数getpeername（）とのgetsockname（）は常にストリームでも、例えば、ソケットがMPTCP対応のアプリケーションで使用されている場合MPTCP非対応のアプリケーションとの整合性にするために、最初のサブフローのアドレスを返す、とすべきです制御伝送プロトコル（SCTP）。 （getpeernameの）またはのgetsockname（）の代わりに、MPTCP対応アプリケーションは、使用中のサブフローのためのアドレスペアの完全なリストを取得するためには、5.3節で説明した新しいAPI呼び出しを、使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. MPTCP Connection Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.  MPTCP接続管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. Reaction to Close Call by Application
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. アプリケーションによってコールを閉じるように反応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in [5], MPTCP distinguishes between the closing of subflows (by TCP FIN) and closing the whole MPTCP connection (by Data FIN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5]で説明したように、MPTCPは（TCP FINによって）サブフローの閉鎖（データFINによって）全体MPTCP接続を閉じる区別する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an application closes a socket, e.g., by calling the close() function, this indicates that the application has no more data to send, like for single-path TCP. MPTCP will then close the MPTCP connection via Data FIN messages. This is completely transparent for an application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションがソケットを閉じたときに、例えば、クローズ（）関数を呼び出すことによって、これは、アプリケーションが単一パスTCPのためのように、送信すべきより多くのデータを有していないことを示しています。 MPTCPは、[データFINメッセージを経由してMPTCP接続を閉じます。これは、アプリケーションのための完全に透過的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, the semantics of the close() interface for applications are not changed compared to TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すれば、アプリケーションのためのclose（）インターフェースのセマンティクスはTCPと比較して変化していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. Other Connection Management Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. 他の接続管理機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, an MPTCP connection is maintained separately from individual subflows. MPTCP therefore has internal mechanisms to establish, close, or reset the MPTCP connection [5]. These mechanisms provide equivalent functions like single-path TCP and can be mapped accordingly. Therefore, these MPTCP internals do not affect the application interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、MPTCP接続は、個々のサブフローとは別個に維持されます。 MPTCPしたがって、確立近い、又はMPTCP接続をリセットするための内部機構を有している[5]。これらのメカニズムは、シングルパスTCPのような同等の機能を提供し、それに応じてマッピングすることができます。したがって、これらのMPTCPの内部には、アプリケーション・インターフェースには影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Socket Option Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. ソケットオプションの問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. General Guideline
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. 一般的ガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The existing sockets API includes options that modify the behavior of sockets and their underlying communications protocols. Various socket options exist on the socket, TCP, and IP level. The value of an option can usually be set by the setsockopt() system function. The getsockopt() function gets information. In general, the existing sockets interface functions cannot configure each MPTCP subflow individually. In order to be backward compatible, existing APIs therefore SHOULD apply to all subflows within one connection, as far as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
既存のソケットAPIは、ソケットとその基礎となる通信プロトコルの動作を変更するオプションが含まれています。様々なソケットオプションはソケット、TCP、およびIPレベルで存在します。オプションの値は、通常のsetsockopt（）システム関数によって設定することができます。 getsockopt（）関数は、情報を取得します。一般的に、既存のソケット・インタフェース機能は、個別MPTCPのサブフローを設定することはできません。下位互換性があるために、既存のAPIは、従って、可能な限り、一つの接続内のすべてのサブフローに適用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2. Disabling of the Nagle Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.  Nagleアルゴリズムの無効化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One commonly used TCP socket option (TCP_NODELAY) disables the Nagle algorithm as described in [2]. This option is also specified in the POSIX standard [8]. Applications can use this option in combination with MPTCP in exactly the same way. It then SHOULD disable the Nagle algorithm for the MPTCP connection, i.e., all subflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つの一般的に使用されるTCPソケットオプション（TCP_NODELAY）[2]に記載のようにNagleアルゴリズムを無効にします。このオプションは、POSIX標準で指定された[8]。アプリケーションは、まったく同じようにMPTCPとの組み合わせでは、このオプションを使用することができます。その後MPTCP接続、すなわち、すべてのサブフローのためのNagleアルゴリズムを無効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the MPTCP protocol instance MAY use a different path scheduler algorithm if TCP_NODELAY is present. For instance, it could use an algorithm that is optimized for latency-sensitive traffic (for instance, only transmitting on one path). Specific algorithms are outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP_NODELAYが存在する場合に加えて、MPTCPプロトコルインスタンスは、異なる経路スケジューラアルゴリズムを使用することができます。例えば、それは（例えば、唯一の経路で伝達）遅延の影響を受けやすいトラフィック用に最適化されたアルゴリズムを使用することができます。特定のアルゴリズムは、この文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.3. Buffer Sizing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.3. バッファのサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications can explicitly configure send and receive buffer sizes via the sockets API (SO_SNDBUF, SO_RCVBUF). These socket options can also be used in combination with MPTCP and then affect the buffer size of the MPTCP connection. However, when defining buffer sizes, application programmers should take into account that the transport over several subflows requires a certain amount of buffer for resequencing in the receiver. MPTCP may also require more storage space in the sender, in particular, if retransmissions are sent over more than one path. In addition, very small send buffers may prevent MPTCP from efficiently scheduling data over different subflows. Therefore, it does not make sense to use MPTCP in combination with small send or receive buffers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、明示的に送信を設定し、ソケットAPI（SO_SNDBUF、SO_RCVBUF）を介してバッファサイズを受け取ることができます。これらのソケットオプションもMPTCPと組み合わせて使用​​し、その後MPTCP接続のバッファサイズに影響を与えることができます。バッファサイズを定義するときただし、アプリケーションプログラマは、いくつかのサブフローを超える輸送は、受信機に再配列するためのバッファの一定量を必要とすることを考慮に入れる必要があります。再送が複数のパスを介して送信される場合MPTCPも、特に、送信側でより多くのストレージスペースを必要とするかもしれません。また、非常に小さな送信バッファは、効率的に異なるサブフローを介してデータをスケジュールからMPTCPを防ぐことができます。したがって、それは小さな送信と組み合わせてMPTCPを使用するか、または受信バッファをしても意味がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An MPTCP implementation MAY set a lower bound for send and receive buffers and treat a small buffer size request as an implicit request not to use MPTCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPの実装では、送信のために下限を設定し、受信バッファとMPTCPを使用しない暗黙の要求として、小さなバッファサイズ要求を扱うかもしれ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.4. Other Socket Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.4. その他のソケットオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP features the ability to send &#34;Urgent&#34; data, but its use is not recommended in general, and specifically not with MPTCP [4].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPは、[4] MPTCPで「緊急」のデータを送信する機能を備えていますが、その使用は一般的に推奨されていない、特にありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some network stacks may provide additional implementation-specific socket options or interfaces that affect TCP&#39;s behavior. In such cases, implementers must ensure that these options do not interfere with the MPTCP interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のネットワークスタックは、TCPの動作に影響を与える追加の実装固有のソケットオプションやインターフェースを提供することができます。このような場合には、実装者は、これらのオプションはMPTCPインターフェースと干渉しないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Default Enabling of MPTCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.  MPTCPの有効デフォルト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is up to a local policy at the end system whether a network stack should automatically enable MPTCP for sockets even if there is no explicit sign of MPTCP awareness of the corresponding application. Such a choice may be under the control of the user through system preferences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、ネットワークスタックが自動的に対応するアプリケーションのMPTCP意識の明示的な兆候がなくてもソケットにMPTCPを有効にする必要があるかどうかエンドシステムでローカルポリシー次第です。このような選択は、システム環境設定を介してユーザの制御下に置くことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The enabling of MPTCP, either by application or by system defaults, does not necessarily mean that MPTCP will always be used. Both endpoints must support MPTCP, and there must be multiple addresses at at least one endpoint, for MPTCP to be used. Even if those requirements are met, however, MPTCP may not be immediately used on a connection. It may make sense for multiple paths to be brought into operation only after a given period of time, or if the connection is saturated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションまたはシステムのデフォルトのいずれかによって、MPTCPの有効化、必ずしもMPTCPが常に使用されることを意味するものではありません。両方のエンドポイントはMPTCPをサポートしなければならない、とMPTCPを使用するために、少なくとも1つのエンドポイントで、複数のアドレスが存在しなければなりません。これらの要件が満たされている場合でも、しかし、MPTCPは、直ちに接続で使用することはできません。複数のパスのみ接続が飽和する時間の場合、または所定の期間後に動作させることがすることが意味をなすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Summary of Advice to Application Developers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. アプリケーション開発者へのアドバイスの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Using the default MPTCP configuration: Like TCP, MPTCP is designed to be efficient and robust in the default configuration. Application developers should not explicitly configure TCP (or MPTCP) features unless this is really needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルトのMPTCP設定使用○：同様にTCPを、MPTCPは、デフォルトの設定では、効率的かつ堅牢に設計されています。アプリケーション開発者は、明示的にTCPを設定するべきではない（またはMPTCP）は、これが本当に必要とされている場合を除きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Socket buffer dimensioning: Multipath transport requires larger buffers in the receiver for resequencing, as already explained. Applications should use reasonable buffer sizes (such as the operating system default values) in order to fully benefit from MPTCP. A full discussion of buffer sizing issues is given in [5].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oソケットバッファ寸法：既に説明したようにマルチパストランスポートは、再配列決定のために受信機に大きなバッファを必要とします。アプリケーションは、完全MPTCPから利益を得るために（例えば、オペレーティングシステムのデフォルト値など）妥当バッファ・サイズを使用すべきです。バッファサイズの問題の完全な議論は、[5]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Facilitating stack-internal heuristics: The path management and data scheduling by MPTCP is realized by stack-internal algorithms that may implicitly try to self-optimize their behavior according to assumed application needs. For instance, an MPTCP implementation may use heuristics to determine whether an application requires delay-sensitive or bulk data transport, using, for instance, port numbers, the TCP_NODELAY socket options, or the application&#39;s read/write patterns as input parameters. An application developer can facilitate the operation of such heuristics by avoiding atypical interface use cases. For instance, for long bulk data transfers, it does not make sense to enable the TCP_NODELAY socket option, nor is it reasonable to use many small socket send() calls each with small amounts of data only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スタック内部ヒューリスティックを促進○：MPTCPによるパス管理及びデータ・スケジューリングは暗黙的に試みることができるスタック内部アルゴリズムによって実現されると想定アプリケーションのニーズに応じてその動作を自己最適化します。アプリケーションは、例えば、ポート番号、TCP_NODELAYソケットオプション、または入力パラメータとしてアプリケーションの読み取り/書き込みパターンを使用して、遅延に敏感な又はバルクデータ転送が必要かどうか、例えば、MPTCP実装が決定するヒューリスティックを使用してもよいです。アプリケーション開発者は、非定型インタフェースユースケースを回避することによって、このようなヒューリスティックの操作を容易にすることができます。例えば、長いバルク・データ転送のために、それはTCP_NODELAYソケットオプションを有効にしても意味がありません。また、多くの小さなソケットの送信を（使用するのが妥当である）だけ少量のデータと各を呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Basic API for MPTCP-Aware Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
MPTCP対応アプリケーションのための5基本API
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Design Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 設計上の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While applications can use MPTCP with the unmodified sockets API, multipath transport results in many degrees of freedom. MPTCP manages the data transport over different subflows automatically. By default, this is transparent to the application, but an application could use an additional API to interface with the MPTCP layer and to control important aspects of the MPTCP implementation&#39;s behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、多くの自由度で、未修正のソケットAPIでマルチパストランスポート結果をMPTCPを使用することができますが。 MPTCPは、自動的に別のサブフローを介したデータ転送を管理します。デフォルトでは、これはアプリケーションに対して透過的ですが、アプリケーションはMPTCP層との界面にするとMPTCP実装の行動の重要な側面を制御するために、追加のAPIを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes a basic MPTCP API. The API contains a minimum set of functions that provide an equivalent level of control and information as exists for regular TCP. It maintains backward compatibility with legacy applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、基本的なMPTCP APIについて説明します。 APIは、通常のTCPのために存在するように、制御情報の等価なレベルを提供する機能の最小セットを含みます。これは、従来のアプリケーションとの下位互換性を維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An advanced MPTCP API is outside the scope of this document. The basic API does not allow a sender or a receiver to express preferences about the management of paths or the scheduling of data, even if this can have a significant performance impact and if an MPTCP implementation could benefit from additional guidance by applications. A list of potential further API extensions is provided in the appendix. The specification of such an advanced API is for further study and may partly be implementation-specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高度なMPTCPのAPIは、この文書の範囲外です。基本的なAPIは、送信者や受信機がMPTCP実装はアプリケーションによって追加のガイダンスから利益を得ることができるならば、これは重大なパフォーマンスへの影響を持つことができたとしても、パスの管理やデータのスケジューリングについての好みを表現することはできません。可能性はさらにAPIの拡張機能のリストは、付録に提供されています。高度なAPIの仕様は、今後の検討課題であると、部分的に実装固有のかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCP mainly affects the sending of data. But a receiver may also have preferences about data transfer choices, and it may have performance requirements as well. Yet, the configuration of such preferences is outside of the scope of the basic API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPは、主にデータの送信に影響を与えます。しかし、受信機は、データ転送の選択肢についての好みを持っていること、そしてそれは同様に性能要件を有することができます。しかし、そのような環境設定の構成は、基本的なAPIの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Requirements on the Basic MPTCP API
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 基本MPTCP APIの要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because of the importance of the sockets interface there are several fundamental design objectives for the basic interface between MPTCP and applications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのため、ソケット・インターフェースの重要性MPTCPとアプリケーションの間の基本的なインターフェイスのためのいくつかの基本的な設計目標があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Consistency with existing sockets APIs must be maintained as far as possible. In order to support the large base of applications using the original API, a legacy application must be able to continue to use standard sockets interface functions when run on a system supporting MPTCP. Also, MPTCP-aware applications should be able to access the socket without any major changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O既存のソケットAPIと一貫性は、可能な限り維持しなければなりません。元のAPIを使用するアプリケーションの大きなベースをサポートするために、レガシーアプリケーションがMPTCPをサポートするシステム上で実行すると、標準的なソケットインタフェース機能を使用し続けることができなければなりません。また、MPTCP対応アプリケーションは、大きな変更なしでソケットにアクセスすることができるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Sockets API extensions must be minimized and independent of an implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OソケットAPIの拡張を最小化し、実装に依存しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The interface should handle both IPv4 and IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oインタフェースは、IPv4とIPv6の両方を処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following is a list of the core requirements for the basic API:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は基本的なAPIのためのコア要件のリストです：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ1: Turn on/off MPTCP: An application should be able to request to turn on or turn off the usage of MPTCP. This means that an application should be able to explicitly request the use of MPTCP if this is possible. Applications should also be able to request not to enable MPTCP and to use regular TCP transport instead. This can be implicit in many cases, since MPTCP must be disabled by the use of binding to a specific address. MPTCP may also be enabled if an application uses a dedicated multipath address family (such as AF_MULTIPATH [20]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ1は：/オフMPTCPをオンにします。アプリケーションは、オンまたはMPTCPの使用をオフにすることを要求することができるはずです。これは、アプリケーションがこれが可能である場合、明示的にMPTCPの使用を要求することができなければならないことを意味します。また、アプリケーションはMPTCPを有効にするために、代わりに通常のTCPトランスポートを使用しないように要請することができるはずです。 MPTCPは、特定のアドレスへの結合を使用することにより無効にする必要がありますので、これは、多くの場合、暗黙的にすることができます。アプリケーションは、（例えばAF_MULTIPATH [20]のような）専用マルチアドレスファミリを使用する場合MPTCPも有効にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ2: An application should be able to restrict MPTCP to binding to a given set of addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ2：アプリケーションは、アドレスの特定のセットに結合するMPTCPを制限することができるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ3: An application should be able to obtain information on the pairs of addresses used by the MPTCP subflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ3：アプリケーションがMPTCPのサブフローで使用されるアドレスのペアの情報を取得することができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ4: An application should be able to extract a unique identifier for the connection (per endpoint).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ4：アプリケーションは、（エンドポイントごとに）接続のための一意の識別子を抽出することができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first requirement is the most important one, since some applications could benefit a lot from MPTCP, but there are also cases in which it hardly makes sense. The existing sockets API provides similar mechanisms to enable or disable advanced TCP features. The second requirement corresponds to the binding of addresses with the bind() socket call, or, e.g., explicit device bindings with a SO_BINDTODEVICE option. The third requirement ensures that there is an equivalent to getpeername() or getsockname() that is able to deal with more than one subflow. Finally, it should be possible for the application to retrieve a unique connection identifier (local to the endpoint on which it is running) for the MPTCP connection. This replaces the (address, port) pair for a connection identifier in single-path TCP, which is no longer static in MPTCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初の要件は、いくつかのアプリケーションはMPTCPから多くの利益をもたらす可能性があるため、最も重要なものですが、それはほとんど意味がありませんする場合もあります。既存のソケットAPIは、高度なTCP機能を有効または無効にするには、同様のメカニズムを提供します。第二の要件はSO_BINDTODEVICEオプションと結合（）ソケット呼び出し、または、例えば、明示的なデバイスバインディングとアドレスの結合に相当します。第3の要件は、（getpeernameと等価であることを確実にする）またはのgetsockname（）複数のサブフローに対処することが可能です。アプリケーションがMPTCP接続のため（それが実行されているエンドポイントへのローカル）のユニークな接続識別子を取得するために最後に、それは可能なはずです。これはMPTCPにもはや静的であるシングルパスTCPに接続識別子のために（アドレス、ポート）対を置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application can continue to use getpeername() or getsockname() in addition to the basic MPTCP API. Both functions return the corresponding addresses of the first subflow, as already explained.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、基本的なMPTCPのAPIに加えて、getpeername（）またはのgetsockname（）を使用し続けることができます。既に説明したように、両方の機能は、第一サブフローの対応するアドレスを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Sockets Interface Extensions by the Basic MPTCP API
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 基本MPTCP APIによってソケットインタフェース拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1. 概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The abstract, basic MPTCP API consists of a set of new values that are associated with an MPTCP socket. Such values may be used for changing properties of an MPTCP connection or retrieving information. These values could be accessed by new symbols on existing calls such as setsockopt() and getsockopt() or could be implemented as entirely new function calls. This implementation decision is out of scope for this document. The following list presents symbolic names for these MPTCP socket settings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
抽象的、基本的なMPTCP APIはMPTCPソケットに関連付けられている新しい値のセットで構成されています。このような値はMPTCP接続のプロパティを変更したり、情報を検索するために使用することができます。これらの値は、（例えばのsetsockoptなどの既存の呼に新しいシンボルによってアクセス）とのgetsockopt（）または完全に新しい関数呼び出しとして実現することができることができます。この実装の決定はこの文書の範囲外です。以下のリストは、これらのMPTCPソケット設定のシンボル名を提示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_ENABLE: Enable/disable MPTCP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TCP_MULTIPATH_ENABLE：有効/無効にしますMPTCP
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_ADD: Bind MPTCP to a set of given local addresses, or add a set of new local addresses to an existing MPTCP connection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TCP_MULTIPATH_ADD：指定されたローカルアドレスのセットにバインドMPTCP、または既存のMPTCP接続に新しいローカルアドレスのセットを追加
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_REMOVE: Remove a local address from an MPTCP connection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP_MULTIPATH_REMOVE○：MPTCP接続からローカルアドレスを削除します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_SUBFLOWS: Get the pairs of addresses currently used by the MPTCP subflows
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TCP_MULTIPATH_SUBFLOWS：アドレスのペアは現在MPTCPのサブフローで慣れます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_CONNID: Get the local connection identifier for this MPTCP connection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TCP_MULTIPATH_CONNID：このMPTCP接続用のローカル接続識別子を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 1 shows a list of the abstract socket operations for the basic configuration of MPTCP. The first column gives the symbolic name of the operation. The second and third columns indicate whether the operation provides values to be read (&#34;Get&#34;) or takes values to configure (&#34;Set&#34;). The fourth column lists the type of data associated with this operation. The data types are listed for information only. In addition to IP addresses, an application MAY also indicate TCP port numbers, as further detailed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表1は、MPTCPの基本構成の抽象ソケット操作のリストを示しています。最初の列は、操作のシンボル名を与えます。第二及び第三の列は、操作が読み取られる値を提供する（「GET」）または（「設定」）を設定する値をとるかどうかを示します。第4列は、この操作に関連付けられているデータのタイプを示しています。データ型は情報だけのために記載されています。 IPアドレスに加えて、アプリケーションは、以下にさらに詳細として、TCPポート番号を示している可能性があり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------+-----+-----+------------------------------+
   | Name                   | Get | Set |           Data type          |
   +------------------------+-----+-----+------------------------------+
   | TCP_MULTIPATH_ENABLE   |  o  |  o  |           boolean            |
   | TCP_MULTIPATH_ADD      |     |  o  |      list of addresses       |
   |                        |     |     |         (and ports)          |
   | TCP_MULTIPATH_REMOVE   |     |  o  |      list of addresses       |
   |                        |     |     |         (and ports)          |
   | TCP_MULTIPATH_SUBFLOWS |  o  |     |  list of pairs of addresses  |
   |                        |     |     |         (and ports)          |
   | TCP_MULTIPATH_CONNID   |  o  |     |           integer            |
   +------------------------+-----+-----+------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Table 1: MPTCP Socket Operations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
表1：MPTCPソケット操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are restrictions on when these new socket operations can be used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの新しいソケット操作を使用することができたときには制限があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_ENABLE: This value should only be set before the establishment of a TCP connection. Its value should only be read after the establishment of a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP_MULTIPATH_ENABLE○：この値は、TCP接続の確立前に設定する必要があります。この値は、接続の確立後に読まれるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_ADD: This operation can be applied both before connection setup and during a connection. If used before, it controls the local addresses that an MPTCP connection can use. In the latter case, it allows MPTCP to use an additional local address, if there has been a restriction before connection setup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TCP_MULTIPATH_ADD：この操作は、接続設定の前に、接続中の両方に適用することができます。前に使用している場合、それはMPTCP接続を使用することができますローカルアドレスを制御します。後者の場合には、接続のセットアップの前に制限があった場合MPTCPは、追加のローカルアドレスを使用することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_REMOVE: This operation can be applied both before connection setup and during a connection. In both cases, it removes an address from the list of local addresses that may be used by subflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TCP_MULTIPATH_REMOVE：この操作は、接続設定の前に、接続中の両方に適用することができます。両方の場合において、それはサブフローで使用することができるローカルアドレスのリストからアドレスを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_SUBFLOWS: This value is read-only and can only be used after connection setup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TCP_MULTIPATH_SUBFLOWS：この値は読み取り専用であるとのみ接続セットアップ後に使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP_MULTIPATH_CONNID: This value is read-only and should only be used after connection setup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TCP_MULTIPATH_CONNID：この値は読み取り専用であるとのみ接続セットアップ後に使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2. Enabling and Disabling of MPTCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2. 有効化とMPTCPの無効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application can explicitly indicate multipath capability by setting TCP_MULTIPATH_ENABLE to the value &#34;true&#34;. In this case, the MPTCP implementation SHOULD try to negotiate MPTCP for that connection. Note that multipath transport will not necessarily be enabled, as it requires support at both end systems, no middleboxes on the path that would prevent any additional signaling, and at least one endpoint with multiple addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、明示的に「真」の値にTCP_MULTIPATH_ENABLEを設定することにより、マルチパス能力を示すことができます。この場合、MPTCPの実装は、その接続のためのMPTCPを交渉してみてください。それは、両方のエンドシステムにサポートを必要とする、そのマルチパス輸送が必ずしも有効になりません注意、任意の付加的なシグナリングを防止し、複数のアドレスを有する少なくとも一つのエンドポイントになる経路には中間装置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Building on the backward compatibility specified in Section 4.2.1, if an application enables MPTCP but binds to a specific address or interface, MPTCP MUST be enabled, but MPTCP MUST respect the application&#39;s choice and only use addresses that are explicitly provided by the application. Note that it would be possible for an application to use the legacy bindings and then expand on them by using TCP_MULTIPATH_ADD. Note also that it is possible for more than one local address to be initially available to MPTCP in this case, if an application has bound to a specific interface with multiple addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションがMPTCPを可能にしますが、特定のアドレスまたはインタフェースに結合する場合、セクション4.2.1で指定され、下位互換性を踏まえ、MPTCPを有効にする必要がありますが、MPTCPは、アプリケーションの選択を尊重し、明示的にのみ、アプリケーションによって提供されているアドレスを使用する必要があります。アプリケーションは、従来のバインディングを使用して、TCP_MULTIPATH_ADDを使用してそれらを拡張することが可能であることに注意してください。複数のローカルアドレスは、この場合MPTCP最初に利用可能にするためのアプリケーションが複数のアドレスを持つ特定のインターフェイスにバインドされている場合、それは、可能であることにも留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application can disable MPTCP by setting TCP_MULTIPATH_ENABLE to a value of &#34;false&#34;. In that case, MPTCP MUST NOT be used on that connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、「偽」の値にTCP_MULTIPATH_ENABLEを設定することにより、MPTCPを無効にすることができます。その場合には、MPTCPは、その接続に使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After connection establishment, an application can get the value of TCP_MULTIPATH_ENABLE. A value of &#34;false&#34; then means lack of MPTCP support. A value of &#34;true&#34; means that MPTCP is supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続確立後、アプリケーションはTCP_MULTIPATH_ENABLEの値を取得することができます。 「偽」の値は、MPTCPのサポートの欠如を意味しています。 「真」の値は、MPTCPがサポートされていることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.3. Binding MPTCP to Specified Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.3. 指定されたアドレスに対してMPTCPのバインド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before connection establishment, an application can use the TCP_MULTIPATH_ADD function to indicate a set of local IP addresses that MPTCP may bind to. The parameter of the function is a list of addresses in a corresponding data structure. By extension, this operation will also control the list of addresses that can be advertised to the peer via MPTCP signaling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続確立する前に、アプリケーションはMPTCPがに結合することができるローカルIPアドレスのセットを示すために、TCP_MULTIPATH_ADD機能を使用することができます。関数のパラメータは、対応するデータ構造内のアドレスのリストです。拡張によって、この動作もMPTCPシグナリングを介してピアにアドバタイズすることができるアドレスのリストを制御します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application binds to a specific address or interface, it is not required to use the TCP_MULTIPATH_ADD operation for that address. As explained in Section 5.3.2, MPTCP MUST only use the explicitly specified addresses in that case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションが特定のアドレスまたはインターフェイスにバインドした場合、そのアドレスのためTCP_MULTIPATH_ADD操作を使用する必要はありません。 5.3.2項で説明したように、MPTCPは、その場合には、明示的に指定されたアドレスを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application MAY also indicate a TCP port number that, if specified, MPTCP MUST attempt to bind to. The port number MAY be different than the one used by existing subflows. If no port number is provided by the application, the port number is automatically selected by the MPTCP implementation, and it is RECOMMENDED that it is the same across all subflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、アプリケーションは、指定された場合、MPTCPがバインドしようとしなければならないTCPポート番号を示している可能性があり。ポート番号は、既存のサブフローが使用しているものとは異なる場合があります。ポート番号は、アプリケーションによって提供されていない場合、ポート番号は自動的にMPTCP実装によって選択され、そしてすべてのサブフローで同じであることが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This operation can also be used to modify the address list in use during the lifetime of an MPTCP connection. In this case, it is used to indicate a set of additional local addresses that the MPTCP connection can make use of and that can be signaled to the peer. It should be noted that this signal is only a hint, and an MPTCP implementation MAY select only a subset of the addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この操作は、MPTCP接続の存続期間中に使用されているアドレスリストを変更するために使用することができます。この場合、MPTCP接続が利用することができ、そのピアに通知することができる追加のローカルアドレスのセットを示すために使用されます。この信号は単なるヒントであることに留意すべきである、とMPTCPの実装は、アドレスのサブセットのみを選択することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TCP_MULTIPATH_REMOVE operation can be used to remove a local address, or a set of local addresses, from an MPTCP connection. MPTCP MUST close any corresponding subflows (i.e., those using the local address that is no longer present) and signal the removal of the address to the peer. If alternative paths are available using the supplied address list but MPTCP is not currently using them, an MPTCP implementation SHOULD establish alternative subflows before undertaking the address removal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP_MULTIPATH_REMOVE動作はMPTCP接続から、ローカルアドレス、またはローカルアドレスのセットを削除するために使用することができます。 MPTCPは、任意の対応するサブフロー（もはや存在しないローカルアドレスを用いて、すなわち、それら）を閉じて、ピアにアドレスの除去を通知しなければなりません。代替パスが供給されたアドレスリストを使用して利用可能ですが、MPTCPは現在、それらを使用していない場合は、MPTCP実装は、アドレスの除去に着手する前に、代替のサブフローを確立すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be remembered that these operations SHOULD support both IPv4 and IPv6 addresses, potentially in the same call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの操作は、潜在的に同じ呼び出しで、IPv4とIPv6の両方のアドレスをサポートすべきであることを忘れてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.4. Querying the MPTCP Subflow Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.4.  MPTCPサブフローアドレスの照会
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application can get a list of the addresses used by the currently established subflows in an MPTCP connection by means of the read-only TCP_MULTIPATH_SUBFLOWS operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、読み取り専用TCP_MULTIPATH_SUBFLOWS操作によってMPTCP接続で現在確立サブフローが使用するアドレスのリストを取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The return value is a list of pairs of tuples of IP address and TCP port number. In one pair, the first tuple refers to the local IP address and the local TCP port, and the second one to the remote IP address and remote TCP port used by the subflow. The list MUST only include established subflows. Both addresses in each pair MUST be either IPv4 or IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
戻り値は、IPアドレスとTCPポート番号の組のペアのリストです。一方の対では、第一の組は、ローカルIPアドレスとローカルTCPポート、およびサブフローによって使用されるリモートIPアドレスとリモートのTCPポートへの第2のものをいいます。リストには、確立されたサブフローをのみを含まなければなりません。各ペアの両方のアドレスはIPv4またはIPv6のいずれかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.5. Getting a Unique Connection Identifier
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.5. ユニークな接続識別子を取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application that wants a unique identifier for the connection, analogous to an (address, port) pair in regular TCP, can query the TCP_MULTIPATH_CONNID value to get a local connection identifier for the MPTCP connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常のTCPで（アドレス、ポート）のペアに類似の接続のためのユニークな識別子を、望んでいるアプリケーションは、MPTCP接続用のローカル接続識別子を取得するためにTCP_MULTIPATH_CONNID値を照会することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This SHOULD be an integer number and SHOULD be locally unique (e.g., the MPTCP token).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、整数でなければならず、（例えば、MPTCPトークン）局所的に一意である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Other Compatibility Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.その他の互換性の問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Usage of TLS over MPTCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.  MPTCPオーバーTLSの使い方
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport Layer Security (TLS) [17] may be used over MPTCP&#39;s basic API. When TLS compares any addresses used by MPTCP against names or addresses present in X.509 certificates [18] [19], it MUST only compare them with the address that MPTCP used to start the initial subflow as presented to TLS. The addresses used for subsequent subflows need not to be compared against any TLS certificate information. Finer-grained control would require an advanced API or proactive subflow management via the basic API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート層セキュリティ（TLS）[17]はMPTCPの基本的なAPIを介して使用することができます。 TLSは、名前やX.509証明書[18] [19]に存在するアドレスに対してMPTCPで使用される任意のアドレスを比較すると、それだけでTLSに提示されるMPTCPが初期サブフローを起動するために使用されるアドレスとそれらを比較する必要があります。後続のサブフローのために使用されるアドレスは、任意のTLS証明書情報と比較する必要はありません。より細かい制御は、基本的なAPIを介した高度なAPIや積極的なサブフロー管理が必要となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Usage of the SCTP Sockets API
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.  SCTPソケットAPIの使い方
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For dealing with multihoming, several sockets API extensions have been defined for SCTP [13]. As MPTCP realizes multipath transport from and to multihomed end systems, some of these interface function calls are actually applicable to MPTCP in a similar way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチホーミングを扱うために、いくつかのソケットAPIの拡張機能は、SCTP [13]のために定義されています。 MPTCPからマルチパス転送を実現し、エンドシステムをマルチホームするように、これらのインタフェースの関数呼び出しの一部は、同様の方法で、実際にMPTCPに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
API developers may wish to integrate SCTP and MPTCP calls to provide a consistent interface to the application. Yet, it must be emphasized that the transport service provided by MPTCP is different than that of SCTP, and this is why not all SCTP API functions can be mapped directly to MPTCP. Furthermore, a network stack implementing MPTCP does not necessarily support SCTP and its specific sockets interface extensions. This is why the basic API of MPTCP defines additional socket options only, which are a backward-compatible extension of TCP&#39;s application interface. Integration with the SCTP API is outside the scope of the basic API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
APIの開発者は、SCTPを統合することを望むかもしれないとMPTCPは、アプリケーションへの一貫したインターフェイスを提供するために呼び出します。しかし、MPTCPが提供するトランスポート・サービスはSCTPのものとは異なる、そしてないすべてのSCTP API関数がMPTCPに直接マッピングすることができ、なぜこれがあることを強調しなければなりません。また、MPTCPを実装するネットワークスタックは必ずしもSCTP、その特定のソケットインターフェイス拡張機能をサポートしていません。 MPTCPの基本的なAPIは、TCPのアプリケーションインタフェースの下位互換性が拡張されているのみで、追加のソケットオプションを定義する理由はここにあります。 SCTPのAPIとの統合は、基本的なAPIの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Incompatibilities with Other Multihoming Solutions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 他のマルチホーミングソリューションとの非互換性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of MPTCP can interact with various related sockets API extensions. The use of a multihoming shim layer conflicts with multipath transport such as MPTCP or SCTP [11]. Care should be taken that the use of MPTCP not conflict with the overlapping features of other APIs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCPの使用は、様々な関連ソケットAPIの拡張と対話することができます。例えばMPTCP又はSCTP [11]のようにマルチパス輸送とマルチホーミングシム層の競合の使用。ケアはMPTCPの使用は他のAPIの重複機能と競合しないように注意しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHIM API [11]: This API specifies sockets API extensions for the multihoming shim layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OシムAPI [11]：このAPIは、マルチホーミングシム層のためのソケットAPIの拡張を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o HIP API [12]: The Host Identity Protocol (HIP) also results in a new API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O HIPのAPI [12]：ホスト識別プロトコル（HIP）も、新しいAPIになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o API for Mobile IPv6 [10]: For Mobile IPv6, a significantly extended sockets API exists as well (in addition to API extensions for IPv6 [9]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モバイルIPv6 [10]のための入出力API：モバイルIPv6の場合、大幅に延長ソケットAPIは同様に存在する（IPv6のためのAPIの拡張機能に加えて、[9]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid any conflict, multiaddressed MPTCP SHOULD NOT be enabled if a network stack uses SHIM6, HIP, or Mobile IPv6. Furthermore, applications should not try to use both the MPTCP API and another multihoming or mobility layer API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークスタックはSHIM6、HIP、またはモバイルIPv6を使用する場合は、任意の競合を避けるために、同報MPTCPを有効にしないでください。さらに、アプリケーションはMPTCPのAPIおよび他のマルチホーミングや移動度層のAPIの両方を使用しようとはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible, however, that some of the MPTCP functionality, such as congestion control, could be used in a SHIM6 or HIP environment. Such operation is for further study.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはMPTCP機能のいくつかは、そのような輻輳制御として、SHIM6またはHIP環境で使用することができること、しかし、可能です。このような動作は、今後の検討課題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Interactions with DNS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.  DNSとの相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In multihomed or multiaddressed environments, there are various issues that are not specific to MPTCP but have to be considered as well. These problems are summarized in [14].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチホームや同報環境では、MPTCPに固有のものではありませんが、同様に考慮しなければならない様々な問題があります。これらの問題は、[14]にまとめられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifically, there can be interactions with DNS. Whilst it is expected that an application will iterate over the list of addresses returned from a call such as getaddrinfo(), MPTCP itself MUST NOT make any assumptions about multiple A or AAAA records from the same DNS query referring to the same host, as it is possible that multiple addresses refer to multiple servers for load-balancing purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、DNSとの相互作用があることができます。それはアドレスのリストを反復処理するアプリケーションは、このようなのgetaddrinfo（）として呼び出しから返さことが期待される一方で、MPTCP自体はそれとして、同じホストを参照する同じDNSクエリから複数のAまたはAAAAレコードに関する何らかの仮定をしてはなりません複数のアドレスは、負荷分散のために複数のサーバーを参照することも可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document first defines the behavior of the standard TCP/IP API for MPTCP-unaware applications. In general, enabling MPTCP has some security implications for applications, which are introduced in Section 5.3.3, and these threats are further detailed in [6]. The protocol specification of MPTCP [5] defines several mechanisms to protect MPTCP against those attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、最初のMPTCP非対応アプリケーションのための標準的なTCP / IPのAPIの動作を定義します。一般に、可能MPTCPはセクション5.3.3に導入されているアプリケーションのためのいくつかのセキュリティ上の影響を有し、そしてこれらの脅威は、[6]にさらに詳述されています。 [5] MPTCPのプロトコル仕様は、これらの攻撃からMPTCPを保護するためにいくつかのメカニズムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The syntax and semantics of the API for MPTCP-unaware applications does not change. However, assumptions that non-MPTCP-aware applications may make on the data retrieved by the backward-compatible API are discussed in Section 4.2.2. System administrators may wish to disable MPTCP for certain applications that signal addresses, or make security decisions (e.g., opening firewall holes), based on responses to such queries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構文とMPTCP非対応のアプリケーションのためのAPIのセマンティクスは変更されません。しかし、非MPTCP対応アプリケーションは、下位互換性APIで取得したデータに作ることが仮定は、セクション4.2.2で説明されています。システム管理者は、そのようなクエリへの応答に基づいて、（例えば、ファイアウォールのホールを開く）アドレスを知らせる特定の用途MPTCPを無効にする、またはセキュリティ上の決定を行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the basic MPTCP API for MPTCP-aware applications defines functions that provide an equivalent level of control and information as exists for regular TCP. This document does not mandate a specific implementation of the basic MPTCP API. The implementation should be designed not to affect memory management assumptions in existing code. Implementors should take into account that data structures will be more complex than for standard TCP, e.g., when multiple subflow addresses have to be stored. When dealing with such data structures, care is needed not to add security vulnerabilities to applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、MPTCP対応アプリケーションのための基本的なMPTCPのAPIは、通常のTCPのために存在するように、制御情報の等価なレベルを提供する関数を定義します。このドキュメントでは、基本的なMPTCPのAPIの具体的な実装を強制しません。実装は、既存のコード内のメモリ管理の前提条件には影響しないように設計されなければなりません。実装者は、複数のサブフローのアドレスが格納する必要がある場合、データ構造は、例えば、標準のTCPよりもより複雑になることを考慮に入れる必要があります。そのようなデータ構造を扱う場合、注意がアプリケーションにセキュリティの脆弱性を追加しないように必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New functions enable adding and removing local addresses from an MPTCP connection (TCP_MULTIPATH_ADD and TCP_MULTIPATH_REMOVE). These functions don&#39;t add security threats if the MPTCP stack verifies that the addresses provided by the application are indeed available as source addresses for subflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい機能はMPTCP接続（TCP_MULTIPATH_ADDとTCP_MULTIPATH_REMOVE）からローカルアドレスを追加および削除できます。 MPTCPスタックは、アプリケーションが提供するアドレスはサブフローのための送信元アドレスとして実際に利用可能であることを確認した場合、これらの機能は、セキュリティ上の脅威を追加しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, applications should use the TCP_MULTIPATH_ADD function with care, as new subflows might get established to those addresses. Furthermore, it could result in some form of information leakage since MPTCP might advertise those addresses to the other connection endpoint, which could learn IP addresses of interfaces that are not visible otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいサブフローは、これらのアドレスに設立される可能性がありますただし、アプリケーションは、注意してTCP_MULTIPATH_ADD機能を使用する必要があります。 MPTCPがそうでなければ表示されていないインタフェースのIPアドレスを学ぶことができる他の接続エンドポイントにこれらのアドレスを宣伝するかもしれないので、それは情報漏洩のいくつかのフォームにつながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of different addresses should not be assumed to lead to use of different paths, especially for security purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるアドレスの使用は、特にセキュリティ目的のために、異なるパスを使用することにつながると想定すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPTCP-aware applications should also take care when querying and using information about the addresses used by subflows (TCP_MULTIPATH_SUBFLOWS). As MPTCP can dynamically open and close subflows, a list of addresses queried once can get outdated during the lifetime of an MPTCP connection. Then, the list may contain invalid entries, i.e., addresses that are not used any more or that might not even be assigned to that host any more. Applications that want to ensure that MPTCP only uses a certain set of addresses should explicitly bind to those addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブフロー（TCP_MULTIPATH_SUBFLOWS）で使用されているアドレスに関する情報を照会し、使用している場合MPTCP対応のアプリケーションにも世話をする必要があります。 MPTCPが動的に開閉サブフローができるように、一度に照会アドレスのリストは、MPTCP接続の寿命の間に時代遅れ得ることができます。次に、リストはすなわち、任意のより多くのまたはそれを使用されていないアドレスでも、それ以上そのホストに割り当てられていない可能性があります、無効なエントリが含まれていてもよいです。 MPTCPだけアドレスの特定のセットを使用することを確実にしたいアプリケーションは、明示的にそれらのアドレスにバインドする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One specific example is the use TLS on top of MPTCP. Corresponding guidance can be found in Section 6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つの具体的な例はMPTCPの上に使用TLSです。対応するガイダンスは、セクション6.1に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Conclusion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.おわり
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document discusses MPTCP&#39;s implications and its performance impact on applications. In addition, it specifies a basic MPTCP API. For legacy applications, it is ensured that the existing sockets API continues to work. MPTCP-aware applications can use the basic MPTCP API that provides some control over the transport layer equivalent to regular TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、MPTCPの影響やアプリケーションへのパフォーマンスへの影響について説明します。また、基本的なMPTCPのAPIを指定します。レガシーアプリケーションの場合は、既存のソケットAPIが動作し続けることが保証されます。 MPTCP対応のアプリケーションは、通常のTCPと同等のトランスポート層の上にいくつかのコントロールを提供し、基本的なMPTCPのAPIを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors sincerely thank the following people for their helpful comments and reviews of the document: Philip Eardley, Lavkesh Lahngir, John Leslie, Costin Raiciu, Michael Tuexen, and Javier Ubillos.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィリップEardley、Lavkesh Lahngir、ジョン・レスリー、コスティンRaiciu、マイケルTuexen、そしてハビエルUbillos：著者は心から彼らの有益なコメントや文書のレビューのために以下の方々に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Michael Scharf is supported by the German-Lab project (http://www.german-lab.de/) funded by the German Federal Ministry of Education and Research (BMBF). Alan Ford was previously supported by Roke Manor Research and by Trilogy (http://www.trilogy-project.org/), a research project (ICT-216372) partially funded by the European Community under its Seventh Framework Program.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイケル・シャーフは、ドイツ連邦教育研究省（BMBF）が資金提供ドイツ・ラボプロジェクト（http://www.german-lab.de/）によってサポートされています。アラン・フォードは、以前Rokeマナー研究によっておよびトリロジー（http://www.trilogy-project.org/）、部分的にその第七次フレームワーク・プログラムの下で欧州共同体資金による研究プロジェクト（ICT-216372）によってサポートされていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Braden, R., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, October 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2]ブレーデン、R.、 &#34;インターネットホストのための要件 - 通信層&#34;、STD 3、RFC 1122、1989年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の &#34;RFCsにおける使用のためのレベルを示すために&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Ford, A., Raiciu, C., Handley, M., Barre, S., and J. Iyengar, &#34;Architectural Guidelines for Multipath TCP Development&#34;, RFC 6182, March 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4]フォード、A.、Raiciu、C.、ハンドレー、M.、バール、S.、およびJ.アイアンガー、 &#34;マルチパスTCP開発のための建築ガイドライン&#34;、RFC 6182、2011年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Ford, A., Raiciu, C., Handley, M., and O. Bonaventure, &#34;TCP Extensions for Multipath Operation with Multiple Addresses&#34;, RFC 6824, January 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5]フォード、A.、Raiciu、C.、ハンドレー、M.、およびO.ボナヴェントゥラ、 &#34;複数のアドレスを持つマルチパス動作時のTCP拡張&#34;、RFC 6824、2013年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Bagnulo, M., &#34;Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses&#34;, RFC 6181, March 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Bagnulo、M.、 &#34;複数のアドレスを持つマルチパス操作のためのTCP拡張のための脅威分析&#34;、RFC 6181、2011年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Raiciu, C., Handley, M., and D. Wischik, &#34;Coupled Congestion Control for Multipath Transport Protocols&#34;, RFC 6356, October 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Raiciu、C.、ハンドレー、M.、およびD. Wischik、 &#34;マルチパストランスポートプロトコルのための結合輻輳制御&#34;、RFC 6356、2011年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] &#34;IEEE Standard for Information Technology -- Portable Operating System Interface (POSIX) Base Specifications, Issue 7&#34;, IEEE Std. 1003.1-2008, 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] &#34;情報技術のためのIEEE規格 - ポータブルオペレーティングシステムインタフェース（POSIX）基本仕様、発行7&#34;、IEEE STD。 1003.1から2008、2008。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei, &#34;Advanced Sockets Application Program Interface (API) for IPv6&#34;, RFC 3542, May 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9]スティーブンス、W.、トーマス、M.、Nordmarkと、E.、およびT.神明、 &#34;拡張ソケットアプリケーション・プログラム・インターフェース（API）は、IPv6のため&#34;、RFC 3542、2003年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Chakrabarti, S. and E. Nordmark, &#34;Extension to Sockets API for Mobile IPv6&#34;, RFC 4584, July 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Chakrabarti、S。およびE. Nordmarkと、 &#34;モバイルIPv6のためのソケットAPIへの拡張&#34;、RFC 4584、2006年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &#34;Sockets Application Program Interface (API) for Multihoming Shim&#34;, RFC 6316, July 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11]こむ、M.、Bagnulo、M.、Slavov、K.、およびS.杉本、 &#34;マルチホーミングシム用ソケットアプリケーション・プログラム・インターフェース（API）&#34;、RFC 6316、2011年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Komu, M. and T. Henderson, &#34;Basic Socket Interface Extensions for the Host Identity Protocol (HIP)&#34;, RFC 6317, July 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12]こむ、M.とT.ヘンダーソン、RFC 6317 &#34;ホスト識別プロトコル（HIP）のための基本的なソケットインタフェース拡張&#34;、2011年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Stewart, R., Tuexen, M., Poon, K., Lei, P., and V. Yasevich, &#34;Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)&#34;, RFC 6458, December 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13]スチュワート、R.、Tuexen、M.、プーン、K.、レイ、P.、およびV. Yasevich、RFC 6458、2011年12月 &#34;ストリーム制御伝送プロトコル（SCTP）のためのソケットAPI拡張&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] Blanchet, M. and P. Seite, &#34;Multiple Interfaces and Provisioning Domains Problem Statement&#34;, RFC 6418, November 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14]ブランシェ、M.およびP. Seite、 &#34;複数のインタフェースおよびプロビジョニングドメイン問題文&#34;、RFC 6418、2011年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Wasserman, M. and P. Seite, &#34;Current Practices for Multiple-Interface Hosts&#34;, RFC 6419, November 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15]ワッサーマン、M.とP. Seite、 &#34;複数のインタフェースのホストの現在のプラクティス&#34;、RFC 6419、2011年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Wing, D. and A. Yourtchenko, &#34;Happy Eyeballs: Success with Dual-Stack Hosts&#34;, RFC 6555, April 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16]翼、D.とA. Yourtchenko、 &#34;ハッピー眼球：デュアルスタックホストと成功&#34;、RFC 6555、2012年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, August 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17]ダークス、T.およびE.レスコラ、 &#34;トランスポート層セキュリティ（TLS）プロトコルバージョン1.2&#34;、RFC 5246、2008年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 5280, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[19] Saint-Andre, P. and J. Hodges, &#34;Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)&#34;, RFC 6125, March 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[19]サンアンドレ、P.およびJ.ホッジス、「インターネット公開鍵インフラストラクチャ内の表現とドメインベースのアプリケーションサービスのアイデンティティの検証は、トランスポート層セキュリティ（TLS）のコンテキストでX.​​509（PKIX）証明書を使用します」、 RFC 6125、2011年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[20] Sarolahti, P., &#34;Multi-address Interface in the Socket API&#34;, Work in Progress, March 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[20] Sarolahti、P.、 &#34;ソケットAPIでマルチアドレスインタフェース&#34;、進歩、2010年3月に作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[21] Khalili, R., Gast, N., Popovic, M., and J. Le Boudec, &#34;Performance Issues with MPTCP&#34;, Work in Progress, February 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[21]カリリ、R.、ガスト、N.、ポポヴィッチ、M.、およびJ.ルBoudec、 &#34;MPTCPとパフォーマンスの問題&#34;、進歩、2013年2月での作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[22] Honda, M., Nishida, Y., Raiciu, C., Greenhalgh, A., Handley, M., and H. Tokuda, &#34;Is it Still Possible to Extend TCP?&#34;, Proc. ACM Internet Measurement Conference (IMC), November 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[22]ホンダ、M.、西田、Y.、Raiciu、C.、グリーンハル、A.、ハンドリー、M.、およびH.徳田は、 &#34;TCPを拡張することは可能ですか？&#34;、PROC。 ACMインターネット測定コンファレンス（IMC）、2011年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Requirements on a Future Advanced MPTCP API
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
今後の高度なMPTCP APIの付録A.要件
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1. Design Considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1。設計上の考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multipath transport results in many degrees of freedom. The basic MPTCP API only defines a minimum set of the API extensions for the interface between the MPTCP layer and applications, which does not offer much control of the MPTCP implementation&#39;s behavior. A future, advanced API could address further features of MPTCP and provide more control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの自由度におけるマルチパストランスポート結果。基本的なMPTCPのAPIはMPTCP実装の行動の多くの制御を提供していませんMPTCP層とアプリケーション間のインタフェースのためのAPIの拡張機能の最小セットを定義します。将来的には、高度なAPIはMPTCPのさらなる特徴に対処し、より多くの制御を提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that use TCP may have different requirements on the transport layer. While developers have become used to the characteristics of regular TCP, new opportunities created by MPTCP could allow the service provided to be optimized further. An advanced API could enable MPTCP-aware applications to specify preferences and control certain aspects of the behavior, in addition to the simple control provided by the basic interface. An advanced API could also address aspects that are completely out of scope of the basic API, for example, the question of whether a receiving application could influence the sending policy. A better integration with TLS could be another relevant objective (cf. Section 6.1) that requires further work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPを使用するアプリケーションは、トランスポート層の上に異なる要件を有することができます。開発者は、通常のTCPの特性に慣れてきたが、MPTCPによって作成された新しい機会を提供するサービスをさらに最適化することができる可能性があります。高度なAPIは基本的なインタフェースによって提供される単純な制御に加えて、設定を指定し、行動の特定の側面を制御するためにMPTCPに対応したアプリケーションを可能にすることができます。高度なAPIはまた、例えば、基本的なAPIの範囲外で完全にされている側面に対処でき、受信側アプリケーションが送信政策に影響を与えることができるかどうかの質問です。 TLSとの統合は、さらなる作業が必要で、他の関連する目的（節参照6.1）である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, an advanced MPTCP API could be part of a new overall interface between the network stack and applications that addresses other issues as well, such as the split between identifiers and locators. An API that does not use IP addresses (but instead uses, e.g., the connectbyname() function) would be useful for numerous purposes, independent of MPTCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、高度なMPTCP APIは、このような識別子とロケータの間の分割として、同様に他の問題に対処するネットワークスタックとアプリケーションの間の新しい総合的なインターフェイスの一部である可能性があります。 IPアドレスを使用しないAPI（代わりに使用していますが、例えば、connectbyname（）関数は）MPTCPの独立した数多くの目的のために有用であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It has also been suggested that a separate address family called AF_MULTIPATH [20] be used. This separate address family could be used to exchange multiple addresses between an application and the standard sockets API, but it would be a more fundamental change compared to the basic API described in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、AF_MULTIPATH [20]と呼ばれる別のアドレスファミリを使用することが示唆されています。この別のアドレスファミリは、アプリケーションと標準ソケットAPIとの間に複数のアドレスを交換するために使用することができますが、それは、この文書で説明した基本的なAPIと比べて、より根本的な変化だろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix documents a list of potential usage scenarios and requirements for the advanced API. The specification and implementation of a corresponding API are outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録では、潜在的な利用シナリオと高度なAPIのための要件のリストが記載されています。明細書および対応するAPIの実装はこの文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2. MPTCP Usage Scenarios and Application Requirements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2。 MPTCPの使用シナリオとアプリケーション要件
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are different MPTCP usage scenarios. An application that wishes to transmit bulk data will want MPTCP to provide a high-throughput service immediately, through creating and maximizing utilization of all available subflows. This is the default MPTCP use case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるMPTCP使用シナリオがあります。バルクデータを送信したいアプリケーションがMPTCPを作成し、利用可能なすべてのサブフローの利用率を最大化を通じて、すぐに高スループットのサービスを提供したいと思うでしょう。これはデフォルトのMPTCPのユースケースです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But at the other extreme, there are applications that are highly interactive but require only a small amount of throughput, and these are optimally served by low latency and jitter stability. In such a situation, it would be preferable for the traffic to use only the lowest-latency subflow (assuming it has sufficient capacity), maybe with one or two additional subflows for resilience and recovery purposes. The key challenge for such a strategy is that the delay on a path may fluctuate significantly and that just always selecting the path with the smallest delay might result in instability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、それとは正反対で、非常にインタラクティブですが、スループットのわずかな量を必要とするアプリケーションが存在し、これらは最適な低遅延とジッタの安定性によって提供されています。トラフィックは、弾力性と回復の目的のために1つのまたは2つの追加のサブフローで多分、（それが十分な容量を有すると仮定して）だけ最小レイテンシサブフローを使用するような状況では、それは好ましいであろう。このような戦略のための重要な課題は、パス上の遅延が大きく変動し、ちょうど常に最小の遅延でパスを選択すると、不安定になるかもしれないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The choice between bulk data transport and latency-sensitive transport affects the scheduler in terms of whether traffic should be, by default, sent on one subflow or across several subflows. Even if the total bandwidth required is less than that available on an individual path, it is desirable to spread this load to reduce stress on potential bottlenecks, and this is why this method should be the default for bulk data transport. However, that may not be optimal for applications that require latency/jitter stability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バルクデータ転送および遅延の影響を受けやすい輸送の間の選択は、トラフィックが1つのサブフロー上または複数のサブフローを介して送信される、デフォルトで、あるべきかどうかという点で、スケジューラに影響を与えます。必要な合計帯域幅は、個々のパスで利用可能なものよりも小さい場合であっても、潜在的なボトルネックへのストレスを軽減するために、この負荷を分散することが望ましいが、この方法は、バルクデータ転送のデフォルトであるべき理由です。しかし、それは、待ち時間/ジッタの安定性を必要とするアプリケーションに最適ではないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of the latter option, a further question arises: Should additional subflows be used whenever the primary subflow is overloaded, or only when the primary path fails (hot standby)? In other words, is latency stability or bandwidth more important to the application? This results in two different options: Firstly, there is the single path that can overflow into an additional subflow; and secondly, there is the single path with hot standby, whereby an application may want an alternative backup subflow in order to improve resilience. In case data delivery on the first subflow fails, the data transport could immediately be continued on the second subflow, which is idle otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プライマリサブフローがオーバーロードされるたびに、追加のサブフローを使用する必要があり、または一次パスが（ホットスタンバイ）が失敗した場合にのみ、後者のオプションの場合、さらに問題が発生しますか？言い換えれば、待ち時間の安定性や帯域幅は、アプリケーションに、より重要なのですか？これは、二つの異なるオプションになる：まず、追加のサブフローにオーバーフローすることができる単一の経路があります。そして第二に、アプリケーションが回復力を向上させるために、代替バックアップサブフローをしたいおそれがホットスタンバイ、を備えた単一のパスがあります。最初のサブフロー失敗のケースデータ配信では、データ転送は直ちにアイドル状態の第二のサブフロー、上で継続することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yet another complication is introduced with the potential that MPTCP introduces for changes in available bandwidth as the number of available subflows changes. Such jitter in bandwidth may prove confusing for some applications, such as video or audio streaming, that dynamically adapt codecs based on available bandwidth. Such applications may prefer MPTCP to attempt to provide a consistent bandwidth as far as is possible and avoid maximizing the use of all subflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに別の合併症はMPTCPが利用可能サブフロー変化の数として利用可能な帯域幅の変化を導入する可能性が導入されます。帯域幅におけるこのようなジッタは動的に利用可能な帯域幅に基づいてコーデックを適応させるように、ビデオやオーディオのストリーミングなどの一部のアプリケーションでは、のために混乱を証明することがあります。このような応用が可能である限り一貫性のある帯域幅を提供し、すべてのサブフローの使用を最大限避けるために試みることMPTCPを好むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A further, mostly orthogonal question is whether data should be duplicated over the different subflows, in particular if there is spare capacity. This could improve both the timeliness and reliability of data delivery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、主に直交質問は空き容量がある場合、データは、特に、異なるサブフローを介して複製する必要があるかどうかです。これは、データ配信の適時性と信頼性の両方を向上させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, there are at least three possible performance objectives for multipath transport:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、マルチパスの輸送のための少なくとも三つの可能なパフォーマンス目標があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. High bandwidth
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.高帯域幅
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Low latency and jitter stability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.低遅延とジッタの安定性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. High reliability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.高い信頼性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are not necessarily disjoint, since there are also broadband interactive applications that require both high-speed bulk data traffic and a low latency and jitter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、高速バルク・データ・トラフィックおよび低遅延とジッタの両方を必要とするブロードバンドインタラクティブなアプリケーションがあるので、これらは、必ずしも互いに素ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In an advanced API, applications could provide high-level guidance to the MPTCP implementation concerning these performance requirements, for instance, which requirement is considered to be the most important. The MPTCP stack would then use internal mechanisms to fulfill this abstract indication of a desired service, as far as possible. This would affect the assignment of data (including retransmissions) to existing subflows (e.g., &#39;use all in parallel&#39;, &#39;use as overflow&#39;, &#39;hot standby&#39;, &#39;duplicate traffic&#39;) as well as the decisions regarding when to set up additional subflows to which addresses. In both cases, different policies can exist, which can be expected to be implementation-specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高度なAPIでは、アプリケーションは、要件が最も重要であると考えられているインスタンスのこれらの性能要件に関するMPTCP実装、高レベルのガイダンスを提供することができます。 MPTCPスタックは、次に、可能な限り、所望のサービスのこの抽象指示を満たすために内部メカニズムを使用します。これは、（例えば、「並行して、すべてを使用する」、「ホットスタンバイ」、「重複トラフィック」「オーバーフローとして使用する」）既存のサブフローにだけでなく、セットアップするに関する決定を（再送信を含む）データの割り当てに影響を与えますどのアドレスに追加サブフロー。両方の場合において、異なるポリシーは、実装に固有であることが期待されることができる、存在することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, an advanced API could provide a mechanism for how applications can specify their high-level requirements in an implementation-independent way. One possibility would be to select one &#34;application profile&#34; out of a number of choices that characterize typical applications. Yet, as applications today do not have to inform TCP about their communication requirements, it requires further studies as to whether such an approach would be realistic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのため、高度なAPIは、アプリケーションが実装に依存しない方法で、その高レベルの要件を指定することができますどのようにするためのメカニズムを提供することができます。一つの可能​​性は、典型的なアプリケーションを特徴づける選択肢の数のうちの一つの「アプリケーションプロファイル」を選択することであろう。アプリケーション今日は彼らの通信要件についてTCPに通知する必要がありませんまだ、そのようなアプローチが現実的だろうかどうかについてのさらなる研究が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Of course, independent of an advanced API, such functionality could also partly be achieved by MPTCP-internal heuristics that infer some application preferences, e.g., from existing socket options, such as TCP_NODELAY. Whether this would be reliable, and indeed appropriate, is for further study.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もちろん、高度なAPIとは独立して、このような機能はまた、部分的なTCP_NODELAYなどの既存のソケットオプションから、例えば、いくつかのアプリケーションの環境を推測MPTCP内部の経験則によって達成することができました。これは信頼性が高く、実際には適切であるかどうか、今後の検討課題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.3. Potential Requirements on an Advanced MPTCP API
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.3。高度なMPTCP APIの潜在的な要件
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following is a list of potential requirements for an advanced MPTCP API beyond the features of the basic API. It is included here for information only:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、基本的なAPIの機能を超えた高度なMPTCPのAPIのための潜在的な要件のリストです。また、情報提供を唯一のためにここに含まれています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ5: An application should be able to establish MPTCP connections without using IP addresses as locators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ5：アプリケーションはロケータとしてIPアドレスを使用せずにMPTCP接続を確立することができるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ6: An application should be able to obtain usage information and statistics about all subflows (e.g., ratio of traffic sent via this subflow).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ6：アプリケーションがすべてのサブフロー（例えば、トラフィックの比率が、このサブフローを介して送信される）についての使用情報と統計情報を取得することができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ7: An application should be able to request a change in the number of subflows in use, thus triggering removal or addition of subflows. An even finer control granularity would be a request for the establishment of a specific subflow to a provided destination or a request for the termination of a specified, existing subflow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ7：アプリケーションは、このようにサブフローの除去または付加をトリガー、使用中のサブフローの数の変更を要求することができなければなりません。より微細な制御の粒度は、提供先または指定された、既存のサブフローの終了要求に対する特定サブフロー確立要求であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ8: An application should be able to inform the MPTCP implementation about its high-level performance requirements, e.g., in the form of a profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ8：アプリケーションプロファイルの形で、例えば、その高いレベルの性能要件についてMPTCP実装を通知することができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ9: An application should be able to indicate communication characteristics, e.g., the expected amount of data to be sent, the expected duration of the connection, or the expected rate at which data is provided. Applications may in some cases be able to forecast such properties. If so, such information could be an additional input parameter for heuristics inside the MPTCP implementation, which could be useful, for example, to decide when to set up additional subflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ9：アプリケーションは、例えば、送信されるデータの予想される量、接続の予想継続時間、またはデータが提供される予想レートを通信特性を示すことができなければなりません。アプリケーションは、いくつかのケースでは、このような性質を予測できる可能性があります。もしそうであれば、そのような情報は、例えば、有用であり得る追加のサブフローを設定するときに決定するMPTCP実装内部ヒューリスティック、のための追加の入力パラメータとすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ10: An application should be able to control the automatic establishment/termination of subflows. This would imply a selection among different heuristics of the path manager, e.g., &#39;try as soon as possible&#39;, &#39;wait until there is a bunch of data&#39;, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ10：アプリケーションがサブフローの自動確立/終了を制御することができるべきです。これは、例えば、など、「できるだけ早くしてみてください」「データの束があるまで待つ」パスマネージャの異なるヒューリスティックの間で選択を暗示します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ11: An application should be able to set preferred subflows or subflow usage policies. This would result in a selection among different configurations of the multipath scheduler. For instance, an application might want to use certain subflows as backup only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ11：アプリケーションが優先サブフローまたはサブフロー使用ポリシーを設定することができるはずです。これは、マルチスケジューラの異なる構成の間で選択することにもなるでしょう。たとえば、アプリケーションが唯一のバックアップとして、特定のサブフローを使用する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ12: An application should be able to control the level of redundancy by telling whether segments should be sent on more than one path in parallel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ12：アプリケーションは、セグメントが、並列に複数のパス上で送信されるべきかどうかを伝えることで、冗長性のレベルを制御することができるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ13: An application should be able to control the use of fate-sharing of the MPTCP connection and the initial subflow, e.g., to overwrite system policies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ13：アプリケーションがシステムポリシーを上書きするために、例えば、MPTCP接続と初期サブフローの運命共有の使用を制御することができるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ14: An application should be able to register for callbacks to be informed of changes to subflows on an MPTCP connection. This &#34;push&#34; interface would allow the application to make timely logging and configuration changes, if required, and would avoid frequent polling of information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REQ14：アプリケーションがMPTCP接続上のサブフローへの変更が通知されるコールバックを登録することができるはずです。この「プッシュ」インターフェースが必要な場合は、アプリケーションが、タイムリーな伐採や構成変更を行うことができるようになる、との情報の頻繁なポーリングを避けるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An advanced API fulfilling these requirements would allow application developers to more specifically configure MPTCP. It could avoid suboptimal decisions of internal, implicit heuristics. However, it is unclear whether all of these requirements would have a significant benefit to applications, since they are going above and beyond what the existing API to regular TCP provides.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの要件を満たす高度なAPIは、アプリケーション開発者は、より具体的にMPTCPを設定できるようになります。それは内部、暗黙のヒューリスティックの次善の意思決定を避けることができます。しかし、彼らが上記行くと、通常のTCPへの既存のAPIが提供するものを超えているため、これらの要件のすべてが、アプリケーションに大きな利点を持っているかどうかは不明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A subset of these functions might also be implemented system-wide or by other configuration mechanisms. These implementation details are left for further study.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの機能のサブセットは、システム全体または他のコンフィギュレーションメカニズムによって実現されるかもしれません。これらの実装の詳細は、さらなる研究のために残されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4. Integration with the SCTP Sockets API
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4。 SCTPソケットAPIとの統合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The advanced API may also integrate or use the SCTP sockets API. The following functions that are defined for SCTP have functionality similar to the basic MPTCP API:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高度なAPIも統合したり、SCTPソケットAPIを使用することができます。 SCTPのために定義されている以下の機能は、基本的なMPTCPのAPIと同様の機能を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sctp_bindx()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oと、sctp_bindx（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sctp_connectx()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O sctp_connectx（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sctp_getladdrs()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（のsctp_getladdrs O）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sctp_getpaddrs()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（のsctp_getpaddrs O）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sctp_freeladdrs()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（sctp_freeladdrs O）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sctp_freepaddrs()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（sctp_freepaddrs O）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The syntax and semantics of these functions are described in [13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの関数の構文およびセマンティクスは、[13]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A potential objective for the advanced API is to provide a consistent MPTCP and SCTP interface to the application. This is left for further study.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高度なAPIのための潜在的な目的は、アプリケーションへの一貫したMPTCPとSCTPインタフェースを提供することです。これは、さらなる研究のために残されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Michael Scharf Alcatel-Lucent Bell Labs Lorenzstrasse 10 70435 Stuttgart Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイケル・シャーフアルカテル・ルーセントのベル研究所ローレンツシュトラーセ10 70435シュトゥットガルトドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: michael.scharf@alcatel-lucent.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：michael.scharf@alcatel-lucent.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alan Ford Cisco Ruscombe Business Park Ruscombe, Berkshire RG10 9NN UK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アラン・フォードシスコRuscombeビジネスパークRuscombe、バークシャーRG10 9NN英国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: alanford@cisco.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：alanford@cisco.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
