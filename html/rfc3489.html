<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 3489 - STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3489</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc3489">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 3489 - STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc3489">
              https://tools.ietf.org/html/rfc3489
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 3489 - STUN  - ネットワークを介して、ユーザーデータグラムプロトコル（UDP）の簡単なトラバーサルは、翻訳者（NATを）に対処します</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                       J. Rosenberg
Request for Comments: 3489                                 J. Weinberger
Category: Standards Track                                    dynamicsoft
                                                              C. Huitema
                                                               Microsoft
                                                                 R. Mahy
                                                                   Cisco
                                                              March 2003
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        STUN - Simple Traversal of User Datagram Protocol (UDP)
               Through Network Address Translators (NATs)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs) (STUN) is a lightweight protocol that allows applications to discover the presence and types of NATs and firewalls between them and the public Internet. It also provides the ability for applications to determine the public Internet Protocol (IP) addresses allocated to them by the NAT. STUN works with many existing NATs, and does not require any special behavior from them. As a result, it allows a wide variety of applications to work through existing NAT infrastructure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークを介して、ユーザーデータグラムプロトコル（UDP）の簡単なトラバーサル翻訳者（NATのを）アドレス（STUN）は、アプリケーションがそれらと公共のインターネット間のNATやファイアウォールの有無と種類を発見することを可能にする軽量なプロトコルです。また、NATによってそれらに割り当てられた公共のインターネットプロトコル（IP）アドレスを決定するアプリケーションのための機能を提供します。 STUNは多くの既存のNATで動作し、それらからの特別な動作を必要としません。その結果、既存のNATのインフラストラクチャを介して動作するため、多種多様なアプリケーションを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.   Applicability Statement ...................................    3
   2.   Introduction ..............................................    3
   3.   Terminology ...............................................    4
   4.   Definitions ...............................................    5
   5.   NAT Variations ............................................    5
   6.   Overview of Operation .....................................    6
   7.   Message Overview ..........................................    8
   8.   Server Behavior ...........................................   10
        8.1   Binding Requests ....................................   10
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        8.2   Shared Secret Requests ..............................   13
   9.   Client Behavior ...........................................   14
        9.1   Discovery ...........................................   15
        9.2   Obtaining a Shared Secret ...........................   15
        9.3   Formulating the Binding Request .....................   17
        9.4   Processing Binding Responses ........................   17
   10.  Use Cases .................................................   19
        10.1  Discovery Process ...................................   19
        10.2  Binding Lifetime Discovery ..........................   21
        10.3  Binding Acquisition .................................   23
   11.  Protocol Details ..........................................   24
        11.1  Message Header ......................................   25
        11.2  Message Attributes ..................................   26
              11.2.1  MAPPED-ADDRESS ..............................   27
              11.2.2  RESPONSE-ADDRESS ............................   27
              11.2.3  CHANGED-ADDRESS .............................   28
              11.2.4  CHANGE-REQUEST ..............................   28
              11.2.5  SOURCE-ADDRESS ..............................   28
              11.2.6  USERNAME ....................................   28
              11.2.7  PASSWORD ....................................   29
              11.2.8  MESSAGE-INTEGRITY ...........................   29
              11.2.9  ERROR-CODE ..................................   29
              11.2.10 UNKNOWN-ATTRIBUTES ..........................   31
              11.2.11 REFLECTED-FROM ..............................   31
   12.  Security Considerations ...................................   31
        12.1  Attacks on STUN .....................................   31
              12.1.1  Attack I: DDOS Against a Target .............   32
              12.1.2  Attack II: Silencing a Client ...............   32
              12.1.3  Attack III: Assuming the Identity of a Client   32
              12.1.4  Attack IV: Eavesdropping ....................   33
        12.2  Launching the Attacks ...............................   33
              12.2.1  Approach I: Compromise a Legitimate
                      STUN Server .................................   33
              12.2.2  Approach II: DNS Attacks ....................   34
              12.2.3  Approach III: Rogue Router or NAT ...........   34
              12.2.4  Approach IV: MITM ...........................   35
              12.2.5  Approach V: Response Injection Plus DoS .....   35
              12.2.6  Approach VI: Duplication ....................   35
        12.3  Countermeasures .....................................   36
        12.4  Residual Threats ....................................   37
   13.  IANA Considerations .......................................   38
   14.  IAB Considerations ........................................   38
        14.1  Problem Definition ..................................   38
        14.2  Exit Strategy .......................................   39
        14.3  Brittleness Introduced by STUN ......................   40
        14.4  Requirements for a Long Term Solution ...............   42
        14.5  Issues with Existing NAPT Boxes .....................   43
        14.6  In Closing ..........................................   43
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   15.  Acknowledgments ...........................................   44
   16.  Normative References ......................................   44
   17.  Informative References ....................................   44
   18.  Authors&#39; Addresses ........................................   46
   19.  Full Copyright Statement...................................   47
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Applicability Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.適用性に関する声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protocol is not a cure-all for the problems associated with NAT. It does not enable incoming TCP connections through NAT. It allows incoming UDP packets through NAT, but only through a subset of existing NAT types. In particular, STUN does not enable incoming UDP packets through symmetric NATs (defined below), which are common in large enterprises. STUN&#39;s discovery procedures are based on assumptions on NAT treatment of UDP; such assumptions may prove invalid down the road as new NAT devices are deployed. STUN does not work when it is used to obtain an address to communicate with a peer which happens to be behind the same NAT. STUN does not work when the STUN server is not in a common shared address realm. For a more complete discussion of the limitations of STUN, see Section 14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルは、NATに関連する問題のための万能薬ではありません。それは、NAT経由の着信TCP接続を有効にしません。それはしかし、既存のNATタイプのサブセットを通じて、NAT経由の着信UDPパケットを許可します。具体的には、STUNは、大企業で一般的な対称のNAT（以下に定義）を介して受信UDPパケットを有効にしません。 STUNの発見手順は、UDPのNAT治療上の仮定に基づいています。新しいNATデバイスが展開されているような仮定は道の下の無効を証明することがあります。同じNATの背後にあることを起こるピアと通信するためのアドレスを取得するために使用される場合STUNは動作しません。 STUNサーバーは、共通の共有アドレスレルムでないときにSTUNは動作しません。 STUNの制限のより完全な議論については、第14章を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Network Address Translators (NATs), while providing many benefits, also come with many drawbacks. The most troublesome of those drawbacks is the fact that they break many existing IP applications, and make it difficult to deploy new ones. Guidelines have been developed [8] that describe how to build &#34;NAT friendly&#34; protocols, but many protocols simply cannot be constructed according to those guidelines. Examples of such protocols include almost all peer-to-peer protocols, such as multimedia communications, file sharing and games.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークアドレス変換器（NAT）、多くの欠点が付属しても、多くの利点を提供しながら。これらの欠点の最も厄介は、彼らは多くの既存のIPアプリケーションを破壊し、それが困難な新しいものを導入するために作るという事実です。ガイドラインは、[8]「NATに優しい」プロトコルを構築する方法について説明しますが、多くのプロトコルは、単にこれらのガイドラインに従って構築することはできませんが開発されています。そのようなプロトコルの例としては、マルチメディア通信、ファイル共有やゲームなど、ほぼすべてのピア・ツー・ピア・プロトコルが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To combat this problem, Application Layer Gateways (ALGs) have been embedded in NATs. ALGs perform the application layer functions required for a particular protocol to traverse a NAT. Typically, this involves rewriting application layer messages to contain translated addresses, rather than the ones inserted by the sender of the message. ALGs have serious limitations, including scalability, reliability, and speed of deploying new applications. To resolve these problems, the Middlebox Communications (MIDCOM) protocol is being developed [9]. MIDCOM allows an application entity, such as an end client or network server of some sort (like a Session Initiation Protocol (SIP) proxy [10]) to control a NAT (or firewall), in order to obtain NAT bindings and open or close pinholes. In this way, NATs and applications can be separated once more, eliminating the need for embedding ALGs in NATs, and resolving the limitations imposed by current architectures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題に対処するために、アプリケーションレイヤゲートウェイ（ALG）は、NATの中に埋め込まれています。 ALGは、NATを横断する特定のプロトコルのために必要なアプリケーション層の機能を実行します。典型的には、これは、どれがメッセージの送信者によって挿入されたのではなく、変換されたアドレスを含むようにアプリケーション層メッセージを書き換えることを含みます。 ALGは、スケーラビリティ、信頼性、および新しいアプリケーションの展開の速さなど、重大な制限を、持っています。これらの問題を解決するために、ミドル・コミュニケーションズ（MIDCOM）プロトコルが開発されている[9]。 MIDCOMはNATバインディングと開閉を得るためには、NAT（またはファイアウォール）を制御する（セッション開始プロトコル（SIP）プロキシ[10]のように）そのようなある種のエンドクライアントまたはネットワークサーバーとして、アプリケーション・エンティティを可能にしますピンホール。このように、NATのアプリケーションはNATの内のALGを埋め込み、そして現在のアーキテクチャによって課される制限を解決するための必要性を排除し、再び分離することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unfortunately, MIDCOM requires upgrades to existing NAT and firewalls, in addition to application components. Complete upgrades of these NAT and firewall products will take a long time, potentially years. This is due, in part, to the fact that the deployers of NAT and firewalls are not the same people who are deploying and using applications. As a result, the incentive to upgrade these devices will be low in many cases. Consider, for example, an airport Internet lounge that provides access with a NAT. A user connecting to the NATed network may wish to use a peer-to-peer service, but cannot, because the NAT doesn&#39;t support it. Since the administrators of the lounge are not the ones providing the service, they are not motivated to upgrade their NAT equipment to support it, using either an ALG, or MIDCOM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残念ながら、MIDCOMはアプリケーションコンポーネントに加えて、既存のNATやファイアウォールへのアップグレードが必要です。これらのNATやファイアウォール製品の完全なアップグレードは、潜在的に年、長い時間がかかります。これは、NATやファイアウォールのデプロイヤを展開し、アプリケーションを使用している同じ人ではないという事実のために、部分的に起因します。その結果、これらのデバイスをアップグレードする動機は、多くの場合に低くなります。例えば、NATとのアクセスを提供し、空港インターネットラウンジを考えてみましょう。 NATがそれをサポートしていないため、NAT変換ネットワークに接続しているユーザーは、ピア・ツー・ピアのサービスを利用したいが、できないことがあります。ラウンジの管理者がサービスを提供するものではありませんので、彼らはALG、またはMIDCOMのいずれかを使用して、それをサポートするために、彼らのNAT機器をアップグレードする動機づけではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another problem is that the MIDCOM protocol requires that the agent controlling the middleboxes know the identity of those middleboxes, and have a relationship with them which permits control. In many configurations, this will not be possible. For example, many cable access providers use NAT in front of their entire access network. This NAT could be in addition to a residential NAT purchased and operated by the end user. The end user will probably not have a control relationship with the NAT in the cable access network, and may not even know of its existence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう一つの問題はMIDCOMプロトコルがミドルボックスを制御するエージェントは、これらのミドルボックスの正体を知っている、と制御を可能にする彼らと関係を持っていることを必要とすることです。多くの構成では、これはできません。例えば、多くのケーブルアクセスプロバイダーは、全体のアクセス網の目の前でNATを使用しています。このNATは、エンドユーザが購入し、運営の住宅NATに加えて、可能性があります。エンドユーザーは、おそらくケーブルのアクセスネットワーク内のNATとの制御関係を持っていない、とさえその存在を知らないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many existing proprietary protocols, such as those for online games (such as the games described in RFC 3027 [11]) and Voice over IP, have developed tricks that allow them to operate through NATs without changing those NATs. This document is an attempt to take some of those ideas, and codify them into an interoperable protocol that can meet the needs of many applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、多くのこのような（例えばRFC 3027で説明ゲームのような[11]）は、オンラインゲームのためのものと、既存の専用プロトコル、およびボイスオーバーIPは、彼らがそれらのNATを変更することなく、NATを介して動作することを可能にするトリックを開発しました。この文書では、これらのアイデアのいくつかを取り、多くのアプリケーションのニーズを満たすことができる、相互運用可能なプロトコルにそれらを体系化しようとする試みです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol described here, Simple Traversal of UDP Through NAT (STUN), allows entities behind a NAT to first discover the presence of a NAT and the type of NAT, and then to learn the addresses bindings allocated by the NAT. STUN requires no changes to NATs, and works with an arbitrary number of NATs in tandem between the application entity and the public Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルは、ここでNATを通じUDPのシンプルトラバーサル（STUN）を説明し、NATの背後にある実体は、最初のNATの存在とNATの種類を発見し、その後、NATによって割り当てられたアドレスのバインディングを学習することができます。 STUNは、NATを変更する必要はありませんし、アプリケーション実体と公共のインターネット間のタンデムでのNATの任意の数で動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this document, the key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; are to be interpreted as described in BCP 14, RFC 2119 [1] and indicate requirement levels for compliant STUN implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、キーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、 &#34;NOT SHALL&#34;、 &#34;推奨&#34;、 &#34;すべきではない&#34; &#34;べきである&#34; &#34;ないものと&#34;、 &#34;MAY&#34;、および &#34;オプション&#34; BCP 14、RFC 2119に記載されているように、[1]に解釈されるべきであり、対応STUNの実装に対する要求レベルを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN Client: A STUN client (also just referred to as a client) is an entity that generates STUN requests. A STUN client can execute on an end system, such as a user&#39;s PC, or can run in a network element, such as a conferencing server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNクライアント：STUNクライアントは、（また、単にクライアントとも呼ばれる）STUN要求を生成するエンティティです。 STUNクライアントは、ユーザのPCとして、エンド・システム上で実行することができ、あるいは、そのような会議サーバとして、ネットワーク要素で実行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN Server: A STUN Server (also just referred to as a server) is an entity that receives STUN requests, and sends STUN responses. STUN servers are generally attached to the public Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNサーバ：STUNサーバーは、（また、単にサーバーとも呼ばれる）STUN要求を受信エンティティであり、そしてSTUN応答を送信します。 STUNサーバは、一般的に、公共のインターネットに接続されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. NAT Variations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. NATバリエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that the reader is familiar with NATs. It has been observed that NAT treatment of UDP varies among implementations. The four treatments observed in implementations are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
読者がNATを精通しているものとします。 UDPのNAT処理が実装ごとに異なることが観察されています。実装において観察された4つの処理は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Full Cone: A full cone NAT is one where all requests from the same internal IP address and port are mapped to the same external IP address and port. Furthermore, any external host can send a packet to the internal host, by sending a packet to the mapped external address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フルコーン：フルコーンNATは、同じ内部IPアドレスとポートからのすべての要求が同じ外部IPアドレスとポートにマッピングされているものです。また、外部のホストは、マップされた外部アドレスにパケットを送信することにより、内部ホストにパケットを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Restricted Cone: A restricted cone NAT is one where all requests from the same internal IP address and port are mapped to the same external IP address and port. Unlike a full cone NAT, an external host (with IP address X) can send a packet to the internal host only if the internal host had previously sent a packet to IP address X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制限付きコーン：制限コーンNATは、同じ内部IPアドレスとポートからのすべての要求が同じ外部IPアドレスとポートにマッピングされているものです。内部ホストが以前にIPアドレスXにパケットを送信した場合にのみ、内部ホストにパケットを送信することができます（IPアドレスXを持つ）フルコーンNAT、外部ホストとは異なり、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Port Restricted Cone: A port restricted cone NAT is like a restricted cone NAT, but the restriction includes port numbers. Specifically, an external host can send a packet, with source IP address X and source port P, to the internal host only if the internal host had previously sent a packet to IP address X and port P.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポート制限コーン：ポート制限付きコーンNATは制限コーンNATに似ているが、制限はポート番号が含まれています。具体的には、外部ホストは内部ホストが以前にIPアドレスX、ポートPにパケットを送信した場合にのみ、内部ホストに、送信元IPアドレスXおよびソースポートPと、パケットを送信することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Symmetric: A symmetric NAT is one where all requests from the same internal IP address and port, to a specific destination IP address and port, are mapped to the same external IP address and port. If the same host sends a packet with the same source address and port, but to a different destination, a different mapping is used. Furthermore, only the external host that receives a packet can send a UDP packet back to the internal host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称型：対称型NATは、特定の宛先IPアドレスおよびポートに同じ内部IPアドレスおよびポートからのすべてのリクエストは、同じ外部IPアドレスおよびポートにマップされるものです。同じホストが同じ送信元アドレスとポートを持つパケットを送信すると、しかし、別の宛先に、異なるマッピングが使用されています。さらに、パケットを受信した場合にのみ、外部のホストは、バック内部ホストにUDPパケットを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Determining the type of NAT is important in many cases. Depending on what the application wants to do, it may need to take the particular behavior into account.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NATの種類を決定することは、多くの場合に重要です。アプリケーションが何をしたいのかに応じて、それは考慮に特定の行動を取る必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Overview of Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
操作の概要6。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section is descriptive only. Normative behavior is described in Sections 8 and 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、唯一の記述です。規範的な動作は、セクション8および9に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            /-----\
                          // STUN  \\
                         |   Server  |
                          \\       //
                            \-----/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       +--------------+             Public Internet
       ................|     NAT 2    |.......................
                       +--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       +--------------+             Private NET 2
       ................|     NAT 1    |.......................
                       +--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            /-----\
                          // STUN  \\
                         |   Client  |
                          \\       //               Private NET 1
                            \-----/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Figure 1: STUN Configuration
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
図1：STUN設定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The typical STUN configuration is shown in Figure 1. A STUN client is connected to private network 1. This network connects to private network 2 through NAT 1. Private network 2 connects to the public Internet through NAT 2. The STUN server resides on the public Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的なSTUN構成はA STUNクライアントがこのネットワークはNAT 1.プライベートネットワーク2を介してプライベートネットワーク2に接続するプライベートネットワーク1に接続されている。図1に示されているSTUNサーバーは、パブリックに常駐NAT 2を介して公衆インターネットに接続しますインターネット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN is a simple client-server protocol. A client sends a request to a server, and the server returns a response. There are two types of requests - Binding Requests, sent over UDP, and Shared Secret Requests, sent over TLS [2] over TCP. Shared Secret Requests ask the server to return a temporary username and password. This username and password are used in a subsequent Binding Request and Binding Response, for the purposes of authentication and message integrity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNは、単純なクライアント・サーバ・プロトコルです。クライアントがサーバに要求を送信し、サーバは応答を返します。 UDP経由で送信されるバインディング要求、およびTLSを介して送信される共有シークレット要求、TCPの上に[2]  -  2つの要求の種類があります。共有シークレット要求は、一時的なユーザ名とパスワードを返すようにサーバーを頼みます。このユーザ名とパスワードは、認証とメッセージの完全性のために、その後のバインディング要求とバインディングレスポンスに使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Binding requests are used to determine the bindings allocated by NATs. The client sends a Binding Request to the server, over UDP. The server examines the source IP address and port of the request, and copies them into a response that is sent back to the client. There are some parameters in the request that allow the client to ask that the response be sent elsewhere, or that the server send the response from a different address and port. There are attributes for providing message integrity and authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結合要求は、NATをによって割り当てられたバインディングを決定するために使用されます。クライアントがUDP上で、サーバーへのバインディング要求を送信します。サーバーは、送信元IPアドレスとポートリクエストの、およびクライアントに返送される応答にコピーし、それらを調べます。クライアントは応答が別の場所に送信されていること、またはサーバが別のアドレスとポートからの応答を送信することを依頼することができリクエストでいくつかのパラメータがあります。メッセージの整合性と認証を提供するための属性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The trick is using STUN to discover the presence of NAT, and to learn and use the bindings they allocate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トリックはNATの存在を発見するためにSTUNを使用している、と彼らは割り当てるバインディングを学習し、使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The STUN client is typically embedded in an application which needs to obtain a public IP address and port that can be used to receive data. For example, it might need to obtain an IP address and port to receive Real Time Transport Protocol (RTP) [12] traffic. When the application starts, the STUN client within the application sends a STUN Shared Secret Request to its server, obtains a username and password, and then sends it a Binding Request. STUN servers can be discovered through DNS SRV records [3], and it is generally assumed that the client is configured with the domain to use to find the STUN server. Generally, this will be the domain of the provider of the service the application is using (such a provider is incented to deploy STUN servers in order to allow its customers to use its application through NAT). Of course, a client can determine the address or domain name of a STUN server through other means. A STUN server can even be embedded within an end system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNクライアントは、典型的には、データを受信するために使用することができるパブリックIPアドレスとポートを取得する必要があるアプリケーションに埋め込まれています。例えば、それはリアルタイムトランスポートプロトコル（RTP）[12]トラフィックを受信するためにIPアドレスとポートを取得する必要があります。アプリケーションが起動すると、アプリケーション内のSTUNクライアントは、そのサーバへのSTUN共有秘密リクエストを送信し、ユーザー名とパスワードを取得し、それをバインディング要求を送信します。 STUNサーバーは、DNS SRVレコード[3]で発見することができ、一般的に、クライアントがSTUNサーバーを見つけるために使用するドメインで構成されているものとします。一般的に、これは、アプリケーションが使用しているサービスのプロバイダのドメインになります（例えば、プロバイダは、その顧客がNATを通じてアプリケーションを使用することを可能にするためにSTUNサーバーを展開するincentedされます）。もちろん、クライアントは、他の手段を通じてSTUNサーバーのアドレスまたはドメイン名を決定することができます。 STUNサーバもエンドシステム内に埋め込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The STUN Binding Request is used to discover the presence of a NAT, and to discover the public IP address and port mappings generated by the NAT. Binding Requests are sent to the STUN server using UDP. When a Binding Request arrives at the STUN server, it may have passed through one or more NATs between the STUN client and the STUN server. As a result, the source address of the request received by the server will be the mapped address created by the NAT closest to the server. The STUN server copies that source IP address and port into a STUN Binding Response, and sends it back to the source IP address and port of the STUN request. For all of the NAT types above, this response will arrive at the STUN client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNバインディング要求はNATの存在を発見するために使用され、NATによって生成されたパブリックIPアドレスとポートマッピングを発見します。バインド要求は、UDPを使用して、STUNサーバに送信されます。バインディング要求がSTUNサーバに到着すると、それはSTUNクライアントとSTUNサーバー間の1つの以上のNATを通過している可能性があります。その結果、サーバーが受信したリクエストの送信元アドレスは、サーバーに最も近いNATによって作成されたマップされたアドレスになります。 STUNサーバーのコピー元IPアドレスとポートSTUNバインディングレスポンスに、バックSTUN要求の送信元IPアドレスとポートに送信します。上記のNATタイプのすべてのために、この応答は、STUNクライアントに到着します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the STUN client receives the STUN Binding Response, it compares the IP address and port in the packet with the local IP address and port it bound to when the request was sent. If these do not match, the STUN client is behind one or more NATs. In the case of a full-cone NAT, the IP address and port in the body of the STUN response are public, and can be used by any host on the public Internet to send packets to the application that sent the STUN request. An application need only listen on the IP address and port from which the STUN request was sent. Any packets sent by a host on the public Internet to the public address and port learned by STUN will be received by the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNクライアントはSTUNバインディングレスポンスを受信すると、それは、要求が送信されたときにバインドされたローカルIPアドレスとポートを持つパケットにIPアドレスとポートを比較します。これらが一致しない場合は、STUNクライアントは、一つ以上のNATの背後にあります。フルコーンNATの場合は、STUNレスポンスのボディにIPアドレスとポートが公開され、そしてSTUN要求を送信したアプリケーションにパケットを送信するために公共のインターネット上の任意のホストで使用することができます。アプリケーションは、STUNリクエストを送信したIPアドレスとポートをリッスンにのみ必要です。 STUNによって学習されたパブリックアドレスとポートに公共のインターネット上のホストによって送信されたパケットは、アプリケーションによって受信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Of course, the host may not be behind a full-cone NAT. Indeed, it doesn&#39;t yet know what type of NAT it is behind. To determine that, the client uses additional STUN Binding Requests. The exact procedure is flexible, but would generally work as follows. The client would send a second STUN Binding Request, this time to a different IP address, but from the same source IP address and port. If the IP address and port in the response are different from those in the first response, the client knows it is behind a symmetric NAT. To determine if it&#39;s behind a full-cone NAT, the client can send a STUN Binding Request with flags that tell the STUN server to send a response from a different IP address and port than the request was received on. In other words, if the client sent a Binding Request to IP address/port A/B using a source IP address/port of X/Y, the STUN server would send the Binding Response to X/Y using source IP address/port C/D. If the client receives this response, it knows it is behind a full cone NAT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もちろん、ホストは、フルコーンNATの背後ではないかもしれません。確かに、それはまだそれが背後にあるNATの種類を知りません。それを判断するには、クライアントが追加STUNバインディング要求を使用しています。正確な手順は、柔軟であるが、次のように一般的に働くだろう。クライアントは、別のIPアドレスに、同じ送信元IPアドレスとポートから、この時間を要求するバインディング二STUNを送信します。応答内のIPアドレスとポートは、最初の応答とは異なっている場合、クライアントは、それは対称NATの背後にあることを知っています。それはフルコーンNATの背後にあるかどうかを判断するには、クライアントは、要求が受信されたものとは異なるIPアドレスとポートからの応答を送信するためにSTUNサーバーを伝えるフラグでSTUNバインディング要求を送信することができます。クライアントは、X / Yの送信元IPアドレス/ポートを使用してIPアドレス/ポートA / Bとの結合要求を送信した言い換えれば、STUNサーバは、送信元IPアドレス/ポートCを使用して、X / Yへの結合応答を送信することになります/ D。クライアントは、この応答を受信した場合、それはフルコーンNATの背後にあることを知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN also allows the client to ask the server to send the Binding Response from the same IP address the request was received on, but with a different port. This can be used to detect whether the client is behind a port restricted cone NAT or just a restricted cone NAT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNはまた、要求が受信されたクライアントが同じIPアドレスからのBindingレスポンスを送信するためにサーバーを依頼することができますが、別のポートを持ちます。これは、クライアントがポート制限付きコーンNATまたは単に制限されたコーンNATの背後にあるかどうかを検出するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that the configuration in Figure 1 is not the only permissible configuration. The STUN server can be located anywhere, including within another client. The only requirement is that the STUN server is reachable by the client, and if the client is trying to obtain a publicly routable address, that the server reside on the public Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図1の構成にのみ許容構成ではないことに留意すべきです。 STUNサーバは別のクライアントの中に含めて、任意の場所に配置することができます。サーバーがパブリックインターネット上に存在することを、唯一の要件は、STUNサーバーがクライアントから到達可能であるということです、そしてクライアントがパブリックにルーティング可能なアドレスを取得しようとしている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Message Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.メッセージの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN messages are TLV (type-length-value) encoded using big endian (network ordered) binary. All STUN messages start with a STUN header, followed by a STUN payload. The payload is a series of STUN attributes, the set of which depends on the message type. The STUN header contains a STUN message type, transaction ID, and length. The message type can be Binding Request, Binding Response, Binding Error Response, Shared Secret Request, Shared Secret Response, or Shared Secret Error Response. The transaction ID is used to correlate requests and responses. The length indicates the total length of the STUN payload, not including the header. This allows STUN to run over TCP. Shared Secret Requests are always sent over TCP (indeed, using TLS over TCP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNメッセージは、TLV（タイプ - 長さ - 値）がビッグエンディアン（ネットワークは、順序付けられた）バイナリを使用して符号化されます。すべてのSTUNメッセージは、STUNペイロードが続く、STUNヘッダで始まります。ペイロードは、STUN属性一連のメッセージタイプに依存するのセットです。 STUNヘッダーはSTUNメッセージタイプ、トランザクションID、および長さを含みます。メッセージタイプは、エラー応答、共有シークレット要求、共有秘密応答、または共有秘密エラー応答をバインディングレスポンスを、バインディング、バインディング要求することができます。トランザクションIDは、要求と応答を相関させるために使用されています。長さは、ヘッダを含まない、STUNペイロードの全長を示します。これは、STUNはTCP上で実行することができます。共有シークレット要求は常に（TCP上のTLSを使用して、実際に）TCPを介して送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several STUN attributes are defined. The first is a MAPPED-ADDRESS attribute, which is an IP address and port. It is always placed in the Binding Response, and it indicates the source IP address and port the server saw in the Binding Request. There is also a RESPONSE-ADDRESS attribute, which contains an IP address and port. The RESPONSE-ADDRESS attribute can be present in the Binding Request, and indicates where the Binding Response is to be sent. It&#39;s optional, and when not present, the Binding Response is sent to the source IP address and port of the Binding Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのSTUN属性が定義されています。最初は、IPアドレスとポートですMAPPED-ADDRESS属性、です。これは常にバインディングレスポンスに配置し、それが元のIPアドレスとポートバインディング要求でサーバーソーを示しています。 IPアドレスとポートを含む応答-ADDRESS属性もあります。 RESPONSE-ADDRESS属性は、バインディング要求中に存在すること、および結合応答が送信される場所を示すことができます。これはオプションだし、存在する場合ではない、バインディングレスポンスは、バインディング要求の送信元のIPアドレスとポートに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third attribute is the CHANGE-REQUEST attribute, and it contains two flags to control the IP address and port used to send the response. These flags are called &#34;change IP&#34; and &#34;change port&#34; flags. The CHANGE-REQUEST attribute is allowed only in the Binding Request. The &#34;change IP&#34; and &#34;change port&#34; flags are useful for determining whether the client is behind a restricted cone NAT or restricted port cone NAT. They instruct the server to send the Binding Responses from a different source IP address and port. The CHANGE-REQUEST attribute is optional in the Binding Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第三属性は、CHANGE-REQUEST属性であり、それは、応答を送信するために使用されるIPアドレスとポートを制御するために2つのフラグが含まれています。これらのフラグは、「IPを変更する」とフラグ「ポートを変更」と呼ばれています。 CHANGE-REQUEST属性は唯一のバインディング要求で許可されています。 「変更IP」と「ポート変更」フラグは、クライアントが制限付きコーンNATまたは制限付きポートコーンNATの背後にあるかどうかを決定するために有用です。彼らは、異なる送信元IPアドレスとポートからのBindingレスポンスを送信するために、サーバーに指示します。 CHANGE-REQUEST属性は、バインディング要求ではオプションです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fourth attribute is the CHANGED-ADDRESS attribute. It is present in Binding Responses. It informs the client of the source IP address and port that would be used if the client requested the &#34;change IP&#34; and &#34;change port&#34; behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第四属性はCHANGED-ADDRESS属性です。これは、バインディングレスポンスに存在しています。これは、クライアントが「変更IP」と「ポート変更」動作を要求した場合に使用される送信元IPアドレスとポートのクライアントに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fifth attribute is the SOURCE-ADDRESS attribute. It is only present in Binding Responses. It indicates the source IP address and port where the response was sent from. It is useful for detecting twice NAT configurations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第五属性は、SOURCE-ADDRESS属性です。これは、バインディングの回答にのみ存在します。これは、応答がから送信された送信元IPアドレスとポートを示します。それは二度NATの設定を検出するために有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sixth attribute is the USERNAME attribute. It is present in a Shared Secret Response, which provides the client with a temporary username and password (encoded in the PASSWORD attribute). The USERNAME is also present in Binding Requests, serving as an index to the shared secret used for the integrity protection of the Binding Request. The seventh attribute, PASSWORD, is only found in Shared Secret Response messages. The eight attribute is the MESSAGE-INTEGRITY attribute, which contains a message integrity check over the Binding Request or Binding Response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第六属性はUSERNAME属性です。これは、（PASSWORD属性でエンコードされた）一時的なユーザ名とパスワードをクライアントに提供し共有秘密レスポンス、中に存在しています。 USERNAMEは、バインディング要求の完全性保護のために使用する共有秘密の指標となる、また、バインド要求に存在しています。第七属性、PASSWORDは、唯一の共有秘密応答メッセージに含まれています。 8つの属性は、バインディング要求またはバインディングレスポンスを介したメッセージの整合性チェックが含まれているMESSAGE-INTEGRITY属性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ninth attribute is the ERROR-CODE attribute. This is present in the Binding Error Response and Shared Secret Error Response. It indicates the error that has occurred. The tenth attribute is the UNKNOWN-ATTRIBUTES attribute, which is present in either the Binding Error Response or Shared Secret Error Response. It indicates the mandatory attributes from the request which were unknown. The eleventh attribute is the REFLECTED-FROM attribute, which is present in Binding Responses. It indicates the IP address and port of the sender of a Binding Request, used for traceability purposes to prevent certain denial-of-service attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第九の属性は、ERROR-CODE属性です。これは、結合エラーレスポンスと共有シークレットエラー応答で存在しています。これは、発生したエラーを示します。第十属性はUNKNOWN-ATTRIBUTESが結合エラーレスポンスまたは共有秘密エラー応答のいずれかに存在している、属性です。それは知られていなかった要求から必須属性を示します。第十一の属性は、反射からのバインディングレスポンス内に存在する属性。これは、特定のサービス拒否攻撃を防ぐために、トレーサビリティの目的で使用されるバインディング要求の送信元のIPアドレスとポートを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Server Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.サーバーの動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server behavior depends on whether the request is a Binding Request or a Shared Secret Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの動作は、要求がバインディング要求または共有シークレット要求であるかどうかに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 Binding Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1バインド要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A STUN server MUST be prepared to receive Binding Requests on four address/port combinations - (A1, P1), (A2, P1), (A1, P2), and (A2, P2). (A1, P1) represent the primary address and port, and these are the ones obtained through the client discovery procedures below. Typically, P1 will be port 3478, the default STUN port. A2 and P2 are arbitrary. A2 and P2 are advertised by the server through the CHANGED-ADDRESS attribute, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（A1、P1）、（A2、P1）、（A1、P2）及び（A2、P2） -  STUNサーバーは、4つのアドレス/ポートの組み合わせのバインディング要求を受信するように準備しなければなりません。 （A1、P1）プライマリアドレスとポートを表し、これらは以下のクライアント発見手順を経て得られたものです。一般的に、P1は、デフォルトのSTUNポート3478ポートになります。 A2及びP2は任意です。後述のようにA2及びP2は、CHANGED-ADDRESS属性を介してサーバによってアドバタイズされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that the server check the Binding Request for a MESSAGE-INTEGRITY attribute. If not present, and the server requires integrity checks on the request, it generates a Binding Error Response with an ERROR-CODE attribute with response code 401. If the MESSAGE-INTEGRITY attribute was present, the server computes the HMAC over the request as described in Section 11.2.8. The key to use depends on the shared secret mechanism. If the STUN Shared Secret Request was used, the key MUST be the one associated with the USERNAME attribute present in the request. If the USERNAME attribute was not present, the server MUST generate a Binding Error Response. The Binding Error Response MUST include an ERROR-CODE attribute with response code 432. If the USERNAME is present, but the server doesn&#39;t remember the shared secret for that USERNAME (because it timed out, for example), the server MUST generate a Binding Error Response. The Binding Error Response MUST include an ERROR-CODE attribute with response code 430. If the server does know the shared secret, but the computed HMAC differs from the one in the request, the server MUST generate a Binding Error Response with an ERROR-CODE attribute with response code 431. The Binding Error Response is sent to the IP address and port the Binding Request came from, and sent from the IP address and port the Binding Request was sent to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバがMESSAGE-INTEGRITY属性のバインディング要求を確認することをお勧めします。現在、そしてサーバーではありませんが、リクエストに応じて整合性チェックを必要とする場合、それが説明するように、サーバがリクエストを介してHMACを計算し、MESSAGE-INTEGRITY属性が存在した場合はERROR-CODEとの結合エラーレスポンスがレスポンスコード401で属性を生成しセクション11.2.8インチ使用する鍵は、共有秘密メカニズムに依存します。 STUN共有シークレット要求を使用した場合、キーは要求に存在USERNAMEに関連した一つの属性でなければなりません。 USERNAME属性が存在しない場合は、サーバーはバインドエラー応答を生成しなければなりません。 USERNAMEが存在するが、（それは例えば、タイムアウトしたため）、サーバーはそのUSERNAMEの共有秘密を覚えていない場合は、サーバが生成しなければならない結合エラー応答は応答コード432とERROR-CODE属性を含まなければなりませんエラー応答を結合。サーバが共有秘密を知っているんが、計算されたHMACが要求におけるものと異なる場合ERROR-CODEは応答コード430で属性を含まなければならないバインディングエラー応答は、サーバはERROR-CODEとの結合エラーレスポンスを生成しなければなりません結合エラーレスポンスがバインディング要求がどこから来たIPアドレスとポートに送信され、そしてバインディング要求が送られたIPアドレスとポートから送信された応答コード431で属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the message integrity check passed, processing continues. The server MUST check for any attributes in the request with values less than or equal to 0x7fff which it does not understand. If it encounters any, the server MUST generate a Binding Error Response, and it MUST include an ERROR-CODE attribute with a 420 response code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
渡されたメッセージの整合性チェックを仮定すると、処理が続行されます。サーバーは、値未満か、それは分かりません0x7FFFのに等しいと要求の中の任意の属性にチェックしなければなりません。それがどんなに遭遇した場合、サーバーは、結合エラーレスポンスを生成しなければならない、そしてそれは420応答コードとERROR-CODE属性を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That response MUST contain an UNKNOWN-ATTRIBUTES attribute listing the attributes with values less than or equal to 0x7fff which were not understood. The Binding Error Response is sent to the IP address and port the Binding Request came from, and sent from the IP address and port the Binding Request was sent to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その応答はUNKNOWN-属性が値未満又は理解されていなかったは0x7FFFに等しくして属性をリスト属性含まなければなりません。結合エラー応答がバインディング要求から来て、バインディング要求が送られたIPアドレスとポートから送信されたIPアドレスとポートに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the request was correctly formed, the server MUST generate a single Binding Response. The Binding Response MUST contain the same transaction ID contained in the Binding Request. The length in the message header MUST contain the total length of the message in bytes, excluding the header. The Binding Response MUST have a message type of &#34;Binding Response&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求が正しく形成されたと仮定すると、サーバーは、単一の結合レスポンスを生成しなければなりません。バインディングレスポンスがバインディング要求に含まれている同じトランザクションIDを含まなければなりません。メッセージヘッダーの長さは、ヘッダを除いた、バイト単位でのメッセージの全長を含まなければなりません。バインディングレスポンスは、「結合応答」のメッセージタイプを持たなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST add a MAPPED-ADDRESS attribute to the Binding Response. The IP address component of this attribute MUST be set to the source IP address observed in the Binding Request. The port component of this attribute MUST be set to the source port observed in the Binding Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、バインディングレスポンスにマッピングされた-ADDRESS属性を追加しなければなりません。この属性のIPアドレスコンポーネントは、バインディング要求で観察された送信元IPアドレスに設定しなければなりません。この属性のポートコンポーネントは、バインディング要求で観察された送信元ポートに設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the RESPONSE-ADDRESS attribute was absent from the Binding Request, the destination address and port of the Binding Response MUST be the same as the source address and port of the Binding Request. Otherwise, the destination address and port of the Binding Response MUST be the value of the IP address and port in the RESPONSE-ADDRESS attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESPONSE-ADDRESS属性は、バインディング要求を欠席した場合、バインディングレスポンスの送信先アドレスとポートバインディング要求のソースアドレスとポートと同じでなければなりません。それ以外の場合は、バインディングレスポンスの送信先アドレスとポートは、応答-ADDRESS属性にIPアドレスとポートの値でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The source address and port of the Binding Response depend on the value of the CHANGE-REQUEST attribute and on the address and port the Binding Request was received on, and are summarized in Table 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信元アドレスおよび結合応答のポートは、CHANGE-REQUEST属性の値とバインディング要求が受信されたアドレスとポートに依存し、表1にまとめます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let Da represent the destination IP address of the Binding Request (which will be either A1 or A2), and Dp represent the destination port of the Binding Request (which will be either P1 or P2). Let Ca represent the other address, so that if Da is A1, Ca is A2. If Da is A2, Ca is A1. Similarly, let Cp represent the other port, so that if Dp is P1, Cp is P2. If Dp is P2, Cp is P1. If the &#34;change port&#34; flag was set in CHANGE-REQUEST attribute of the Binding Request, and the &#34;change IP&#34; flag was not set, the source IP address of the Binding Response MUST be Da and the source port of the Binding Response MUST be Cp. If the &#34;change IP&#34; flag was set in the Binding Request, and the &#34;change port&#34; flag was not set, the source IP address of the Binding Response MUST be Ca and the source port of the Binding Response MUST be Dp. When both flags are set, the source IP address of the Binding Response MUST be Ca and the source port of the Binding Response MUST be Cp. If neither flag is set, or if the CHANGE-REQUEST attribute is absent entirely, the source IP address of the Binding Response MUST be Da and the source port of the Binding Response MUST be Dp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Daは（A1またはA2のいずれかであろう）バインディング要求の宛先IPアドレスを表し、Dpは（P1又はP2のいずれかであろう）バインディング要求の送信先ポートを表してみましょう。ダがある場合A1、CaはA2となるように、Caが、他のアドレスを表してみましょう。 DaはA2であれば、CaがA1です。同様に、DpがP1である場合、CpはP2になるようにCpは、他のポートを表してみましょう。 DpがP2である場合、CpはP1です。 「ポートの変更」フラグがバインディング要求のCHANGE-REQUEST属性にセットし、「変更IP」フラグが設定されていない場合は、バインディングレスポンスの送信元IPアドレスは、ダとバインディングレスポンスMUSTの送信元ポートでなければなりませんCpとなります。 「変更IP」フラグがバインディング要求にセットし、「変更ポート」フラグが設定されていない場合、バインディングレスポンスの送信元IPアドレスは、Caなければならず、バインディングレスポンスの送信元ポートがdpなければなりません。両方のフラグが設定されている場合、バインディングレスポンスの送信元IPアドレスは、Caなければならず、バインディングレスポンスの送信元ポートはCpとでなければなりません。どちらのフラグが設定されている場合、または変更要求属性が全く存在しない場合、バインディングレスポンスの送信元IPアドレスは、ダなければならず、バインディングレスポンスの送信元ポートがdpなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Flags Source Address Source Port CHANGED-ADDRESS none Da Dp Ca:Cp Change IP Ca Dp Ca:Cp Change port Da Cp Ca:Cp Change IP and Change port Ca Cp Ca:Cp
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
国旗ソースアドレスソースポートCHANGED-ADDRESSなしダDpのカルシウム：Cpの変更IPカルシウムDpはカルシウム：Cpを変更したポートダのCpカルシウム：Cpの変更IPおよび変更ポートカルシウムのCpカルシウム：Cpは
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 1: Impact of Flags on Packet Source and CHANGED-ADDRESS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表1：パケット送信元とCHANGED-ADDRESS上のフラグの影響
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST add a SOURCE-ADDRESS attribute to the Binding Response, containing the source address and port used to send the Binding Response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、アドレスとポートバインディングレスポンスを送信するために使用されるソースを含む、バインディングレスポンスにSOURCE-ADDRESS属性を追加しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST add a CHANGED-ADDRESS attribute to the Binding Response. This contains the source IP address and port that would be used if the client had set the &#34;change IP&#34; and &#34;change port&#34; flags in the Binding Request. As summarized in Table 1, these are Ca and Cp, respectively, regardless of the value of the CHANGE-REQUEST flags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、バインディングレスポンスに変更-ADDRESS属性を追加しなければなりません。これは、クライアントがバインディング要求で「変更IP」と「ポート変更」フラグを設定していた場合に使用される送信元IPアドレスとポートが含まれています。表1にまとめたように、これらは関係なく、変更要求フラグの値を、それぞれ、Ca及びCpとです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Binding Request contained both the USERNAME and MESSAGE-INTEGRITY attributes, the server MUST add a MESSAGE-INTEGRITY attribute to the Binding Response. The attribute contains an HMAC [13] over the response, as described in Section 11.2.8. The key to use depends on the shared secret mechanism. If the STUN Shared Secret Request was used, the key MUST be the one associated with the USERNAME attribute present in the Binding Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バインディング要求がUSERNAMEとMESSAGE-INTEGRITY属性の両方が含まれていた場合、サーバーは、バインディングレスポンスにMESSAGE-INTEGRITY属性を追加しなければなりません。セクション11.2.8に記載されているように属性が、対応上HMAC [13]を含んでいます。使用する鍵は、共有秘密メカニズムに依存します。 STUN共有シークレット要求を使用した場合、キーはUSERNAMEに関連する一つのバインディング要求に存在する属性である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Binding Request contained a RESPONSE-ADDRESS attribute, the server MUST add a REFLECTED-FROM attribute to the response. If the Binding Request was authenticated using a username obtained from a Shared Secret Request, the REFLECTED-FROM attribute MUST contain the source IP address and port where that Shared Secret Request came from. If the username present in the request was not allocated using a Shared Secret Request, the REFLECTED-FROM attribute MUST contain the source address and port of the entity which obtained the username, as best can be verified with the mechanism used to allocate the username. If the username was not present in the request, and the server was willing to process the request, the REFLECTED-FROM attribute SHOULD contain the source IP address and port where the request came from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バインディング要求応答-ADDRESS属性が含まれていた場合、サーバーは、反射から属性応答にを加えなければなりません。バインディング要求が共有秘密のリクエストから取得したユーザー名を使用して認証された場合は、反射から属性は、その共有シークレット要求が来たソースIPアドレスとポートを含まなければなりません。リクエストに存在するユーザ名が共有シークレット要求を使用して割り当てられていなかった場合は、反射から属性は、最高のユーザー名を割り当てるために使用されるメカニズムを検証することができるよう、ユーザ名を取得したエンティティの送信元アドレスとポートを含まなければなりません。ユーザ名が要求に存在していなかったし、サーバーが要求を処理するために喜んでいた場合は、反射からのリクエストが来たソースIPアドレスとポートを含むべきである属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server SHOULD NOT retransmit the response. Reliability is achieved by having the client periodically resend the request, each of which triggers a response from the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは応答を再送すべきではありません。信頼性は、クライアントが定期的にサーバからの応答をトリガそれぞれが要求を再送有することによって達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 Shared Secret Requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2共有シークレット要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Shared Secret Requests are always received on TLS connections. When the server receives a request from the client to establish a TLS connection, it MUST proceed with TLS, and SHOULD present a site certificate. The TLS ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA [4] SHOULD be used. Client TLS authentication MUST NOT be done, since the server is not allocating any resources to clients, and the computational burden can be a source of attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有シークレット要求は常にTLS接続上で受信されています。サーバはTLS接続を確立するために、クライアントからのリクエストを受信すると、TLSを続行しなければならない、とサイト証明書を提示しなければなりません。 TLS暗号スイートTLS_RSA_WITH_AES_128_CBC_SHA [4]使用されてください。サーバーがクライアントにすべてのリソースを割り当てていないので、クライアントのTLS認証は、してはいけない、と計算負荷は、攻撃のソースにすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server receives a Shared Secret Request, it MUST verify that the request arrived on a TLS connection. If it did not receive the request over TLS, it MUST generate a Shared Secret Error Response, and it MUST include an ERROR-CODE attribute with a 433 response code. The destination for the error response depends on the transport on which the request was received. If the Shared Secret Request was received over TCP, the Shared Secret Error Response is sent over the same connection the request was received on. If the Shared Secret Request was receive over UDP, the Shared Secret Error Response is sent to the source IP address and port that the request came from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが共有秘密のリクエストを受信した場合、その要求はTLS接続に到着したことを確かめなければなりません。それはTLSオーバー要求を受信しなかった場合は、共有秘密エラー応答を生成しなければならない、そしてそれは433応答コードとERROR-CODE属性を含まなければなりません。エラー応答の宛先は要求を受信したトランスポートに依存します。共有シークレット要求がTCPを介して受信された場合は、共有秘密エラー応答は、要求が受信された同じ接続を介して送信されます。共有シークレット要求がUDPを上に受信した場合、共有秘密エラー応答が要求から来たソースIPアドレスとポートに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server MUST check for any attributes in the request with values less than or equal to 0x7fff which it does not understand. If it encounters any, the server MUST generate a Shared Secret Error Response, and it MUST include an ERROR-CODE attribute with a 420 response code. That response MUST contain an UNKNOWN-ATTRIBUTES attribute listing the attributes with values less than or equal to 0x7fff which were not understood. The Shared Secret Error Response is sent over the TLS connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、値未満か、それは分かりません0x7FFFのに等しいと要求の中の任意の属性にチェックしなければなりません。それがどんなに遭遇した場合、サーバーは、共有秘密エラー応答を生成しなければならない、そしてそれは420応答コードとERROR-CODE属性を含まなければなりません。その応答はUNKNOWN-属性が値未満又は理解されていなかったは0x7FFFに等しくして属性をリスト属性含まなければなりません。共有秘密エラー応答は、TLS接続を介して送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All Shared Secret Error Responses MUST contain the same transaction ID contained in the Shared Secret Request. The length in the message header MUST contain the total length of the message in bytes, excluding the header. The Shared Secret Error Response MUST have a message type of &#34;Shared Secret Error Response&#34; (0x0112).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての共有秘密エラー応答は、共有シークレット要求に含まれている同じトランザクションIDを含まなければなりません。メッセージヘッダーの長さは、ヘッダを除いた、バイト単位でのメッセージの全長を含まなければなりません。共有秘密エラー応答は、「共有秘密エラー応答」（0x0112）のメッセージタイプを持たなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the request was properly constructed, the server creates a Shared Secret Response. The Shared Secret Response MUST contain the same transaction ID contained in the Shared Secret Request. The length in the message header MUST contain the total length of the message in bytes, excluding the header. The Shared Secret Response MUST have a message type of &#34;Shared Secret Response&#34;. The Shared Secret Response MUST contain a USERNAME attribute and a PASSWORD attribute. The USERNAME attribute serves as an index to the password, which is contained in the PASSWORD attribute. The server can use any mechanism it chooses to generate the username. However, the username MUST be valid for a period of at least 10 minutes. Validity means that the server can compute the password for that username. There MUST be a single password for each username. In other words, the server cannot, 10 minutes later, assign a different password to the same username. The server MUST hand out a different username for each distinct Shared Secret Request. Distinct, in this case, implies a different transaction ID. It is RECOMMENDED that the server explicitly invalidate the username after ten minutes. It MUST invalidate the username after 30 minutes. The PASSWORD contains the password bound to that username. The password MUST have at least 128 bits. The likelihood that the server assigns the same password for two different usernames MUST be vanishingly small, and the passwords MUST be unguessable. In other words, they MUST be a cryptographically random function of the username.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストが適切に構築したと仮定すると、サーバーは、共有秘密レスポンスを作成します。共有秘密レスポンスは共有シークレット要求に含まれている同じトランザクションIDを含まなければなりません。メッセージヘッダーの長さは、ヘッダを除いた、バイト単位でのメッセージの全長を含まなければなりません。共有シークレットレスポンスは、「共有シークレットレスポンス」のメッセージタイプを持たなければなりません。共有秘密レスポンスはUSERNAME属性とパスワード属性を含まなければなりません。 userName属性は、パスワード属性に含まれているパスワードの指標となります。サーバは、ユーザ名を生成することを選択した任意のメカニズムを使用することができます。しかし、ユーザ名は少なくとも10分の期間に対して有効でなければなりません。有効期間は、サーバがそのユーザ名のパスワードを計算することができます。各ユーザ名のための単一のパスワードがあるに違いありません。言い換えれば、サーバは、10分後に、同じユーザー名に別のパスワードを割り当てることはできません。サーバは、各個別の共有秘密要求のための別のユーザー名を配る必要があります。個別では、このような場合には、異なるトランザクションIDを意味します。サーバーが明示的に10分後にユーザ名を無効にすることを推奨されます。これは、30分後にユーザ名を無効にしなければなりません。 PASSWORDは、そのユーザ名にバインドされたパスワードが含まれています。パスワードは少なくとも128ビットを持たなければなりません。サーバーが2つの異なるユーザ名に同じパスワードを割り当て可能性は無視できるほど小さくなければならない、とパスワードが推測できないでなければなりません。言い換えれば、彼らは、ユーザー名の暗号的にランダム関数でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These requirements can still be met using a stateless server, by intelligently computing the USERNAME and PASSWORD. One approach is to construct the USERNAME as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの要件は、まだインテリジェントUSERNAMEとPASSWORDを計算することによって、ステートレスなサーバを使用して満たすことができます。一つのアプローチは、としてUSERNAMEを構築することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
USERNAME = &lt;prefix,rounded-time,clientIP,hmac&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
USERNAME = &lt;接頭辞、丸みを帯びた時、クライアントIP、HMAC&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where prefix is some random text string (different for each shared secret request), rounded-time is the current time modulo 20 minutes, clientIP is the source IP address where the Shared Secret Request came from, and hmac is an HMAC [13] over the prefix, rounded-time, and client IP, using a server private key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プレフィックスは（各共有シークレット要求ごとに異なる）いくつかのランダムなテキスト文字列で、丸い時刻が現在時刻モジュロ20分である場合には、クライアントIPは、共有秘密の要求がどこから来た、とHMACはHMAC [13]である以上、送信元IPアドレスでありますサーバーの秘密鍵を使用して接頭辞、丸い時間、およびクライアントIP、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The password is then computed as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パスワードは次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
password = &lt;hmac(USERNAME,anotherprivatekey)&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
パスワード= &lt;HMAC（USERNAME、anotherprivatekey）&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With this structure, the username itself, which will be present in the Binding Request, contains the source IP address where the Shared Secret Request came from. That allows the server to meet the requirements specified in Section 8.1 for constructing the REFLECTED-FROM attribute. The server can verify that the username was not tampered with, using the hmac present in the username.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造により、バインディング要求内に存在するユーザ名自体は、共有シークレット要求が来たソースIPアドレスが含まれています。これは、サーバーが反射から属性を構築するためのセクション8.1で指定された要件を満たすことができます。サーバは、ユーザ名は、ユーザ名に存在HMACを使用して、改ざんされていないことを確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Shared Secret Response is sent over the same TLS connection the request was received on. The server SHOULD keep the connection open, and let the client close it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有秘密応答は要求が受信された同じTLS接続を介して送信されます。サーバが接続を開いたまま、クライアントはそれを閉じるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Client Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.クライアントの動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The behavior of the client is very straightforward. Its task is to discover the STUN server, obtain a shared secret, formulate the Binding Request, handle request reliability, and process the Binding Responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの動作は非常に簡単です。そのタスクは、STUNサーバを発見し、共有秘密を取得し、バインディング要求を策定し、要求の信頼性を処理し、バインディング応答を処理することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1 Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1ディスカバリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generally, the client will be configured with a domain name of the provider of the STUN servers. This domain name is resolved to an IP address and port using the SRV procedures specified in RFC 2782 [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的に、クライアントはSTUNサーバのプロバイダーのドメイン名で構成されます。このドメイン名は、RFC 2782で指定されたSRV手順を使用してIPアドレスとポートに解決される[3]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifically, the service name is &#34;stun&#34;. The protocol is &#34;udp&#34; for sending Binding Requests, or &#34;tcp&#34; for sending Shared Secret Requests. The procedures of RFC 2782 are followed to determine the server to contact. RFC 2782 spells out the details of how a set of SRV records are sorted and then tried. However, it only states that the client should &#34;try to connect to the (protocol, address, service)&#34; without giving any details on what happens in the event of failure. Those details are described here for STUN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、サービス名は、「スタン」です​​。プロトコルは、共有シークレット要求を送信するためのバインディング要求を送信するための「UDP」、または「TCP」です。 RFC 2782の手順は連絡するサーバーを決定するために続いています。 RFC 2782は、SRVレコードのセットをソートし、次に試される方法の詳細を綴ります。しかし、それだけで、クライアントは、障害が発生した場合に何が起こるか上の任意の詳細を与えることなく「（プロトコル、アドレス、サービス）に接続しよう」すべきであると述べています。これらの詳細はSTUNのためにここで説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For STUN requests, failure occurs if there is a transport failure of some sort (generally, due to fatal ICMP errors in UDP or connection failures in TCP). Failure also occurs if the transaction fails due to timeout. This occurs 9.5 seconds after the first request is sent, for both Shared Secret Requests and Binding Requests. See Section 9.3 for details on transaction timeouts for Binding Requests. If a failure occurs, the client SHOULD create a new request, which is identical to the previous, but has a different transaction ID and MESSAGE INTEGRITY attribute (the HMAC will change because the transaction ID has changed). That request is sent to the next element in the list as specified by RFC 2782.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（TCPでのUDPまたは接続不良で致命的なICMPエラーに起因する一般的に、）ある種の輸送障害が発生した場合はSTUN要求のために、障害が発生しました。トランザクションがタイムアウトのために失敗した場合、障害が発生します。最初の要求が共有される秘密の要求とバインド要求の両方のために、送信された後、これが9.5秒を発生します。取引の詳細については、セクション9.3を参照してください。要求を結合するためのタイムアウト。障害が発生した場合、クライアントは以前と同じですが、（トランザクションIDが変更されたため、HMACが変更されます）異なるトランザクションIDとメッセージの完全性属性を持つ新しいリクエストを作成する必要があります。その要求は、RFC 2782で指定されたリスト内の次の要素に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The default port for STUN requests is 3478, for both TCP and UDP. Administrators SHOULD use this port in their SRV records, but MAY use others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN要求のデフォルトポートはTCPとUDPの両方のために、3478です。管理者は、SRVレコードでこのポートを使用する必要がありますが、他の人を使用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If no SRV records were found, the client performs an A record lookup of the domain name. The result will be a list of IP addresses, each of which can be contacted at the default port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何のSRVレコードが見つからなかった場合、クライアントは、ドメイン名のAレコード検索を実行します。結果は、デフォルトポートで接触させることができるそれぞれのIPアドレスのリストになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This would allow a firewall admin to open the STUN port, so hosts within the enterprise could access new applications. Whether they will or won&#39;t do this is a good question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、企業内のホストが新しいアプリケーションにアクセスできるようにファイアウォール管理者は、STUNポートを開くことができるようになります。彼らはまたはこれを行うことはありませんかどうかは良い質問です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2 Obtaining a Shared Secret
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2共有シークレットの取得
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in Section 12, there are several attacks possible on STUN systems. Many of these are prevented through integrity of requests and responses. To provide that integrity, STUN makes use of a shared secret between client and server, used as the keying material for an HMAC used in both the Binding Request and Binding Response. STUN allows for the shared secret to be obtained in any way (for example, Kerberos [14]). However, it MUST have at least 128
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション12で説明したように、STUNシステム上で可能ないくつかの攻撃があります。これらの多くは、要求と応答の整合性によって阻止されます。その整合性を提供するために、STUNは、バインディング要求と応答のバインディングの両方で使用されるHMACのためのキーイング材料として使用されるクライアントとサーバ間の共有秘密を利用します。 STUNは、任意の方法（例えば、ケルベロス[14]）で得られる共有秘密を可能にします。しかし、それは、少なくとも128を持っていなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bits of randomness. In order to ensure interoperability, this specification describes a TLS-based mechanism. This mechanism, described in this section, MUST be implemented by clients and servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
乱数のビット。相互運用性を確保するために、この仕様はTLSベースのメカニズムを説明しています。このセクションで説明するこのメカニズムは、クライアントとサーバによって実装されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, the client determines the IP address and port that it will open a TCP connection to. This is done using the discovery procedures in Section 9.1. The client opens up the connection to that address and port, and immediately begins TLS negotiation [2]. The client MUST verify the identity of the server. To do that, it follows the identification procedures defined in Section 3.1 of RFC 2818 [5]. Those procedures assume the client is dereferencing a URI. For purposes of usage with this specification, the client treats the domain name or IP address used in Section 9.1 as the host portion of the URI that has been dereferenced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、クライアントは、それがへのTCP接続をオープンしますIPアドレスとポートを決定します。これは、9.1節で発見手順を使用して行われます。クライアントは、そのアドレスとポートへの接続を開き、すぐにTLSネゴシエーションを開始します[2]。クライアントはサーバーの身元を確かめなければなりません。これを行うためには、[5] RFC 2818のセクション3.1で定義された識別手順に従います。これらの手順は、クライアントがURIを逆参照されているとします。この仕様と使用法の目的のために、クライアントは、逆参照されたURIのホスト部分としてセクション9.1で使用されるドメイン名やIPアドレスを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the connection is opened, the client sends a Shared Secret request. This request has no attributes, just the header. The transaction ID in the header MUST meet the requirements outlined for the transaction ID in a binding request, described in Section 9.3 below. The server generates a response, which can either be a Shared Secret Response or a Shared Secret Error Response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続が開かれると、クライアントは共有シークレット要求を送信します。この要求には属性、単にヘッダを持っていません。ヘッダ内のトランザクションIDは、以下のセクション9.3に記載した結合要求のトランザクションIDについて概説要件を満たさなければなりません。サーバーは、いずれかの共有秘密レスポンスまたは共有秘密エラー応答することができ、応答を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the response was a Shared Secret Error Response, the client checks the response code in the ERROR-CODE attribute. Interpretation of those response codes is identical to the processing of Section 9.4 for the Binding Error Response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答は、共有秘密エラー応答した場合、クライアントはERROR-CODEアトリビュートにおけるレスポンスコードをチェックします。これらのレスポンスコードの解釈は、結合エラー応答については、セクション9.4の処理と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client receives a Shared Secret Response with an attribute whose type is greater than 0x7fff, the attribute MUST be ignored. If the client receives a Shared Secret Response with an attribute whose type is less than or equal to 0x7fff, the response is ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがタイプ0x7FFFをより大きい属性を持つ共有秘密レスポンスを受信した場合、属性は無視しなければなりません。クライアントがそのタイプ以下は0x7FFFに等しい属性を持つ共有秘密レスポンスを受信した場合、応答は無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the response was a Shared Secret Response, it will contain a short lived username and password, encoded in the USERNAME and PASSWORD attributes, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答が共有秘密の対応だった場合、それはそれぞれ、USERNAMEとPASSWORD属性でエンコードされた短命のユーザ名とパスワードを、含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MAY generate multiple Shared Secret Requests on the connection, and it MAY do so before receiving Shared Secret Responses to previous Shared Secret Requests. The client SHOULD close the connection as soon as it has finished obtaining usernames and passwords.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが接続で複数の共有シークレット要求を生成することができ、それが以前の共有秘密要求に共有秘密の応答を受信する前にそれを行うことができます。クライアントはすぐに、それはユーザ名とパスワードを取得し終えたとの接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 9.3 describes how these passwords are used to provide integrity protection over Binding Requests, and Section 8.1 describes how it is used in Binding Responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション9.3は、これらのパスワードは、バインディング要求を介して完全性保護を提供するために使用されている方法について説明し、8.1節は、それがバインド応答で使用されている方法を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3 Formulating the Binding Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3バインディング要求を策定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Binding Request formulated by the client follows the syntax rules defined in Section 11. Any two requests that are not bit-wise identical, and not sent to the same server from the same IP address and port, MUST carry different transaction IDs. The transaction ID MUST be uniformly and randomly distributed between 0 and 2**128 - 1. The large range is needed because the transaction ID serves as a form of randomization, helping to prevent replays of previously signed responses from the server. The message type of the request MUST be &#34;Binding Request&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントによって策定バインディング要求が構文規則セクション11に、同一のビット単位ではありません任意の2つの要求を定義し、同じIPアドレスとポートから同じサーバに送信されないが、以下、異なるトランザクションIDを運ばなければなりません。トランザクションIDは、均一かつランダムに0と2の間で分配されなければならない** 128  -  1.トランザクションIDがサーバーから以前に署名された応答のリプレイを防止するのに役立つ、ランダムの形となるため、大きな範囲が必要とされます。要求のメッセージタイプは、「バインディング要求」でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RESPONSE-ADDRESS attribute is optional in the Binding Request. It is used if the client wishes the response to be sent to a different IP address and port than the one the request was sent from. This is useful for determining whether the client is behind a firewall, and for applications that have separated control and data components. See Section 10.3 for more details. The CHANGE-REQUEST attribute is also optional. Whether it is present depends on what the application is trying to accomplish. See Section 10 for some example uses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESPONSE-ADDRESS属性は、バインディング要求ではオプションです。クライアントは要求がから送信されたものとは異なるIPアドレスとポートに送信する応答を希望する場合は使用されています。これは、クライアントがファイアウォールの内側にあるかどうかを決定するため、制御およびデータコンポーネントを分離している用途に有用です。詳細については、セクション10.3を参照してください。 CHANGE-REQUEST属性も任意です。それが存在するかどうかは、アプリケーションが達成しようとしているものに依存します。いくつかの例では、使用については、セクション10を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client SHOULD add a MESSAGE-INTEGRITY and USERNAME attribute to the Binding Request. This MESSAGE-INTEGRITY attribute contains an HMAC [13]. The value of the username, and the key to use in the MESSAGE-INTEGRITY attribute depend on the shared secret mechanism. If the STUN Shared Secret Request was used, the USERNAME must be a valid username obtained from a Shared Secret Response within the last nine minutes. The shared secret for the HMAC is the value of the PASSWORD attribute obtained from the same Shared Secret Response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、バインディング要求にMESSAGE-INTEGRITYとUSERNAME属性を追加する必要があります。このMESSAGE-INTEGRITY属性は、HMAC [13]を含んでいます。ユーザ名の値、およびMESSAGE-INTEGRITY属性で使用するための鍵は、共有秘密メカニズムに依存します。 STUN共有シークレット要求を使用した場合、USERNAMEは、最後の9分以内に共有秘密レスポンスから取得した有効なユーザ名でなければなりません。 HMACの共有秘密は、同じ共有秘密レスポンスから取得したパスワード属性の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once formulated, the client sends the Binding Request. Reliability is accomplished through client retransmissions. Clients SHOULD retransmit the request starting with an interval of 100ms, doubling every retransmit until the interval reaches 1.6s. Retransmissions continue with intervals of 1.6s until a response is received, or a total of 9 requests have been sent. If no response is received by 1.6 seconds after the last request has been sent, the client SHOULD consider the transaction to have failed. In other words, requests would be sent at times 0ms, 100ms, 300ms, 700ms, 1500ms, 3100ms, 4700ms, 6300ms, and 7900ms. At 9500ms, the client considers the transaction to have failed if no response has been received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
策定後は、クライアントは、バインディング要求を送信します。信頼性は、クライアントの再送信を介して行われます。クライアントは、間隔は1.6秒に達するまで、すべての再送信を倍増、100ミリ秒の間隔で始まる要求を再送信すべきです。再送は、応答が受信されるまで、1.6秒の間隔で継続、または9つの要求の合計が送られてきました。最後の要求が送信された後も応答が1.6秒で受信されない場合、クライアントは、トランザクションが失敗したと考えるべきです。言い換えれば、要求は、時刻0msと、100ミリ秒、300ミリ秒、700ms、1500ms、3100ms、4700ms、6300ms、および7900msで送信されます。 9500msで、クライアントは応答が受信されない場合、トランザクションが失敗したと見なします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4 Processing Binding Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4バインディングレスポンスの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response can either be a Binding Response or Binding Error Response. Binding Error Responses are always received on the source address and port the request was sent from. A Binding Response will be received on the address and port placed in the RESPONSE-ADDRESS attribute of the request. If none was present, the Binding Responses will be received on the source address and port the request was sent from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答は、いずれかのBindingレスポンスやバインディングエラー応答することができます。バインディングエラー応答は常に要求がから送信された送信元アドレスとポートで受信されています。バインディングレスポンスはリクエストの応答ADDRESS属性に配置されたアドレスとポートで受信されます。いずれも存在しない場合、結合応答は要求がから送信された送信元アドレスとポートで受信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the response is a Binding Error Response, the client checks the response code from the ERROR-CODE attribute of the response. For a 400 response code, the client SHOULD display the reason phrase to the user. For a 420 response code, the client SHOULD retry the request, this time omitting any attributes listed in the UNKNOWN-ATTRIBUTES attribute of the response. For a 430 response code, the client SHOULD obtain a new shared secret, and retry the Binding Request with a new transaction. For 401 and 432 response codes, if the client had omitted the USERNAME or MESSAGE-INTEGRITY attribute as indicated by the error, it SHOULD try again with those attributes. For a 431 response code, the client SHOULD alert the user, and MAY try the request again after obtaining a new username and password. For a 500 response code, the client MAY wait several seconds and then retry the request. For a 600 response code, the client MUST NOT retry the request, and SHOULD display the reason phrase to the user. Unknown attributes between 400 and 499 are treated like a 400, unknown attributes between 500 and 599 are treated like a 500, and unknown attributes between 600 and 699 are treated like a 600. Any response between 100 and 399 MUST result in the cessation of request retransmissions, but otherwise is discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答が結合エラー応答である場合、クライアントはレスポンスのERROR-CODE属性からの応答コードをチェックします。 400応答コードの場合、クライアントはユーザーに理由フレーズが表示されます。 420応答コードの場合、クライアントはリクエスト、レスポンスのUNKNOWN-ATTRIBUTES属性に記載されているすべての属性を省略し、この時間を再試行する必要があります。 430応答コードの場合、クライアントは新しい共有秘密を取得し、新たな取引にバインディング要求を再試行する必要があります。エラーによって示されるように、クライアントはUSERNAMEまたはMESSAGE-INTEGRITY属性を省略した場合は401と432応答コードについては、それはそれらの属性をもう一度試してみてください。 431応答コードの場合、クライアントはユーザーに警告すべきである、と新しいユーザー名とパスワードを取得した後、要求を再試行してくださいかもしれません。 500応答コードの場合、クライアントは数秒待ってから、要求を再試行してもよい（MAY）。 600応答コードの場合、クライアントは要求を再試行してはならない、とユーザーに理由フレーズが表示されます。 400と499の間の未知の属性は400のように扱われ、500と599の間の未知の属性は500のように扱われ、600と699の間の未知の属性は100と399との間の応答は、要求の停止をもたらさなければなりません600のように扱われます再送信は、それ以外は破棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client receives a response with an attribute whose type is greater than 0x7fff, the attribute MUST be ignored. If the client receives a response with an attribute whose type is less than or equal to 0x7fff, request retransmissions MUST cease, but the entire response is otherwise ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがタイプ0x7FFFをより大きい属性を持つレスポンスを受信した場合、属性は無視しなければなりません。クライアントがタイプ以下は0x7FFFに等しい属性を持つレスポンスを受信した場合、要求の再送信は停止する必要がありますが、全体の応答がそうでない場合は無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the response is a Binding Response, the client SHOULD check the response for a MESSAGE-INTEGRITY attribute. If not present, and the client placed a MESSAGE-INTEGRITY attribute into the request, it MUST discard the response. If present, the client computes the HMAC over the response as described in Section 11.2.8. The key to use depends on the shared secret mechanism. If the STUN Shared Secret Request was used, the key MUST be same as used to compute the MESSAGE-INTEGRITY attribute in the request. If the computed HMAC differs from the one in the response, the client MUST discard the response, and SHOULD alert the user about a possible attack. If the computed HMAC matches the one from the response, processing continues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答がバインディング応答である場合、クライアントはMESSAGE-INTEGRITY属性の応答をチェックする必要があります。現在、クライアントではないが、要求の中にMESSAGE-INTEGRITYアトリビュートを配置した場合、それは応答を捨てなければなりません。存在する場合は、セクション11.2.8で説明したように、クライアントは応答を介してHMACを計算します。使用する鍵は、共有秘密メカニズムに依存します。 STUN共有シークレット要求を使用した場合は、要求におけるMESSAGE-INTEGRITYアトリビュートを計算するために使用されるように、キーは同じでなければなりません。計算されたHMACが応答したものと異なる場合、クライアントは応答を捨てなければなりませんし、攻撃の可能性についてユーザーに警告すべきです。計算されたHMACが応答からの1つに一致する場合、処理は継続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reception of a response (either Binding Error Response or Binding Response) to a Binding Request will terminate retransmissions of that request. However, clients MUST continue to listen for responses to a Binding Request for 10 seconds after the first response. If it receives any responses in this interval with different message types (Binding Responses and Binding Error Responses, for example) or different MAPPED-ADDRESSes, it is an indication of a possible attack. The client MUST NOT use the MAPPED-ADDRESS from any of the responses it received (either the first or the additional ones), and SHOULD alert the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バインディング要求への応答（バインディングエラー応答または結合応答のいずれか）の受信は、その要求の再送信を終了します。ただし、クライアントは最初の応答の後に10秒間、バインディング要求に対する応答を聞き続けなければなりません。それは、異なるメッセージタイプ（例えば、レスポンスを結合およびエラー応答を結合）、または異なるMAPPED-アドレスを持つこの間隔内の任意の応答を受信した場合、それは可能な攻撃の指標です。クライアントは、それが受信した応答（最初のまたは追加のもののいずれか）のいずれかからMAPPED-ADDRESSを使用してはならない、とユーザーに警告すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, if a client receives more than twice as many Binding Responses as the number of Binding Requests it sent, it MUST NOT use the MAPPED-ADDRESS from any of those responses, and SHOULD alert the user about a potential attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、それが送られたバインディング要求の数の2倍の数のバインディング応答以上のものを受信した場合また、それは、それらの応答のいずれかからMAPPED-ADDRESSを使用してはならない、そして潜在的な攻撃についてユーザーに警告すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Binding Response is authenticated, and the MAPPED-ADDRESS was not discarded because of a potential attack, the CLIENT MAY use the MAPPED-ADDRESS and SOURCE-ADDRESS attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バインディングレスポンスが認証され、マッピングされた-ADDRESSがあるため潜在的な攻撃を捨てていなかった場合、クライアントは、マップされた-ADDRESSとSOURCE-ADDRESS属性を使用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Use Cases
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.ユースケース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules of Sections 8 and 9 describe exactly how a client and server interact to send requests and get responses. However, they do not dictate how the STUN protocol is used to accomplish useful tasks. That is at the discretion of the client. Here, we provide some useful scenarios for applying STUN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション8と9のルールは、クライアントとサーバがリクエストを送信し、応答を取得するために相互作用正確にどのように説明します。しかし、彼らはSTUNプロトコルが有用なタスクを達成するために使用される方法を規定していません。それは、クライアントの裁量です。ここでは、STUNを適用するためのいくつかの有用なシナリオを提供しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1 Discovery Process
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1ディスカバリー・プロセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this scenario, a user is running a multimedia application which needs to determine which of the following scenarios applies to it:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このシナリオでは、ユーザーがそれに適用される次のシナリオのどれかを決定する必要があるマルチメディアアプリケーションを実行しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On the open Internet
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オープンなインターネット上でO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Firewall that blocks UDP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OブロックUDPというファイアウォール
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Firewall that allows UDP out, and responses have to come back to the source of the request (like a symmetric NAT, but no translation. We call this a symmetric UDP Firewall)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アウトUDPを可能にし、応答が要求元に戻って来ている（対称型NATのような、ない訳が。我々は、この対称UDPファイアウォールを呼び出していない）Oファイアウォール
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Full-cone NAT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OフルコーンNAT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Symmetric NAT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称型NAT O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Restricted cone or restricted port cone NAT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O制限付きコーンまたは制限付きポートコーンNAT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Which of the six scenarios applies can be determined through the flow chart described in Figure 2. The chart refers only to the sequence of Binding Requests; Shared Secret Requests will, of course, be needed to authenticate each Binding Request used in the sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6つのシナリオのどのチャート2図で説明したフローチャートにより決定することができるのみ適用バインディング要求の配列を指します。共有シークレット要求は、当然のことながら、シーケンスで使用される各バインディング要求を認証するために必要とされるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow makes use of three tests. In test I, the client sends a STUN Binding Request to a server, without any flags set in the CHANGE-REQUEST attribute, and without the RESPONSE-ADDRESS attribute. This causes the server to send the response back to the address and port that the request came from. In test II, the client sends a Binding Request with both the &#34;change IP&#34; and &#34;change port&#34; flags from the CHANGE-REQUEST attribute set. In test III, the client sends a Binding Request with only the &#34;change port&#34; flag set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、3つのテストを使用しています。テストIでは、クライアントはサーバに、CHANGE-REQUEST属性に設定されているすべてのフラグなしに、応答-ADDRESS属性なしSTUNバインディング要求を送信します。これは、サーバーがバック要求から来たアドレスとポートに応答を送信する原因となります。テストIIでは、クライアントは、「変更IP」と設定CHANGE-REQUEST属性から「ポート変更」フラグの両方にバインディング要求を送信します。試験IIIにおいて、クライアントは、「変更ポート」フラグが設定されたバインディング要求を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client begins by initiating test I. If this test yields no response, the client knows right away that it is not capable of UDP connectivity. If the test produces a response, the client examines the MAPPED-ADDRESS attribute. If this address and port are the same as the local IP address and port of the socket used to send the request, the client knows that it is not natted. It executes test II.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このテストは何も応答が得られない場合、クライアントは、クライアントがUDP接続できないことをすぐに知っている、テストIを開始することによって始まります。テストは、応答を生成する場合、クライアントは、マップされ-ADDRESS属性を調べます。このアドレスとポートが要求を送信するために使用されるソケットのローカルIPアドレスとポートと同じである場合、クライアントは、それがnattedされていないことを知っています。これはテストIIを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a response is received, the client knows that it has open access to the Internet (or, at least, its behind a firewall that behaves like a full-cone NAT, but without the translation). If no response is received, the client knows its behind a symmetric UDP firewall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答が受信された場合、クライアントは、それが（少なくとも、そのフルコーンNATと同じように動作し、ファイアウォールの背後にあるが、翻訳せずに、または）インターネットへのオープンアクセスを持っていることを知っています。応答がない場合、クライアントはその対称UDPファイアウォールの背後を知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that the IP address and port of the socket did not match the MAPPED-ADDRESS attribute in the response to test I, the client knows that it is behind a NAT. It performs test II. If a response is received, the client knows that it is behind a full-cone NAT. If no response is received, it performs test I again, but this time, does so to the address and port from the CHANGED-ADDRESS attribute from the response to test I. If the IP address and port returned in the MAPPED-ADDRESS attribute are not the same as the ones from the first test I, the client knows its behind a symmetric NAT. If the address and port are the same, the client is either behind a restricted or port restricted NAT. To make a determination about which one it is behind, the client initiates test III. If a response is received, its behind a restricted NAT, and if no response is received, its behind a port restricted NAT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソケットのIPアドレスとポートはIをテストするための応答にマッピング-ADDRESS属性と一致しなかったことをイベントでは、クライアントがNATの背後にあることを知っています。これは、試験IIを実行します。応答が受信された場合、クライアントは、フルコーンNATの背後にあることを知っています。応答がない場合、それは私再度テストを実行しますが、この時間は、IPアドレスとポートをマッピング-ADDRESS属性で返された場合ですI.をテストするために、応答から変更-ADDRESS属性からアドレスとポートにそう最初のテストIからのものは、クライアントがその対称NATの背後に知っているのと同じではありません。アドレスとポートが同じである場合、クライアントはNATを制限し、制限またはポートの後ろのどちらかです。それは背後にある1について決意を行うために、クライアントはテストIIIを開始します。応答を受信した場合に応答がない場合は、その制限付きNATの背後に、そして、そのポートの背後には、NATを制限しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This procedure yields substantial information about the operating condition of the client application. In the event of multiple NATs between the client and the Internet, the type that is discovered will be the type of the most restrictive NAT between the client and the Internet. The types of NAT, in order of restrictiveness, from most to least, are symmetric, port restricted cone, restricted cone, and full cone.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この手順は、クライアント・アプリケーションの動作状態に関するかなりの情報が得られます。クライアントとインターネットとの間に複数のNATの場合には、発見されたタイプは、クライアントとインターネットの間で最も制限のNATのタイプになります。ほとんどの少なくともに限定度の順にNATの種類は、、、対称である、ポート制限コーン制限コーン、およびフルコーン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typically, a client will re-do this discovery process periodically to detect changes, or look for inconsistent results. It is important to note that when the discovery process is redone, it should not generally be done from the same local address and port used in the previous discovery process. If the same local address and port are reused, bindings from the previous test may still be in existence, and these will invalidate the results of the test. Using a different local address and port for subsequent tests resolves this problem. An alternative is to wait sufficiently long to be confident that the old bindings have expired (half an hour should more than suffice).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的に、クライアントが変更を検出するために、定期的にこの発見プロセスを再実行する、または矛盾した結果を探します。発見プロセスがやり直されるとき、それは一般的に、以前の発見プロセスで使用したのと同じローカルアドレスとポートから実行すべきではないことに注意することが重要です。同じローカルアドレスとポートが再利用されている場合は、前回のテストからの束縛は、まだ存在していてもよく、これらはテストの結果を無効にします。次の試験のために異なるローカルアドレスとポートを使用することで、この問題を解決します。代替は（時間半べき水準以上のもの）古いバインディングが期限切れになっていることを確信するために十分に長く待つことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2 Binding Lifetime Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2バインディング生涯発見
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN can also be used to discover the lifetimes of the bindings created by the NAT. In many cases, the client will need to refresh the binding, either through a new STUN request, or an application packet, in order for the application to continue to use the binding. By discovering the binding lifetime, the client can determine how frequently it needs to refresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNはまた、NATによって作成されたバインディングの寿命を発見するために使用することができます。アプリケーションは、バインディングを使用し続けるために多くの場合、クライアントは順番に、新しいSTUN要求、またはアプリケーションパケットのいずれかを介して、結合をリフレッシュする必要があります。結合寿命を発見することで、クライアントはそれをリフレッシュする必要がある頻度を決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        +--------+
                        |  Test  |
                        |   I    |
                        +--------+
                             |
                             |
                             V
                            /\              /\
                         N /  \ Y          /  \ Y             +--------+
          UDP     &lt;-------/Resp\---------&gt;/ IP \-------------&gt;|  Test  |
          Blocked         \ ?  /          \Same/              |   II   |
                           \  /            \? /               +--------+
                            \/              \/                    |
                                             | N                  |
                                             |                    V
                                             V                    /\
                                         +--------+  Sym.      N /  \
                                         |  Test  |  UDP    &lt;---/Resp\
                                         |   II   |  Firewall   \ ?  /
                                         +--------+              \  /
                                             |                    \/
                                             V                     |Y
                  /\                         /\                    |
   Symmetric  N  /  \       +--------+   N  /  \                   V
      NAT  &lt;--- / IP \&lt;-----|  Test  |&lt;--- /Resp\               Open
                \Same/      |   I    |     \ ?  /               Internet
                 \? /       +--------+      \  /
                  \/                         \/
                  |                           |Y
                  |                           |
                  |                           V
                  |                           Full
                  |                           Cone
                  V              /\
              +--------+        /  \ Y
              |  Test  |------&gt;/Resp\----&gt;Restricted
              |   III  |       \ ?  /
              +--------+        \  /
                                 \/
                                  |N
                                  |       Port
                                  +------&gt;Restricted
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Figure 2: Flow for type discovery process
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
図2：タイプの発見プロセスのためのフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine the binding lifetime, the client first sends a Binding Request to the server from a particular socket, X. This creates a binding in the NAT. The response from the server contains a MAPPED-ADDRESS attribute, providing the public address and port on the NAT. Call this Pa and Pp, respectively. The client then starts a timer with a value of T seconds. When this timer fires, the client sends another Binding Request to the server, using the same destination address and port, but from a different socket, Y. This request contains a RESPONSE-ADDRESS address attribute, set to (Pa,Pp). This will create a new binding on the NAT, and cause the STUN server to send a Binding Response that would match the old binding, if it still exists. If the client receives the Binding Response on socket X, it knows that the binding has not expired. If the client receives the Binding Response on socket Y (which is possible if the old binding expired, and the NAT allocated the same public address and port to the new binding), or receives no response at all, it knows that the binding has expired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結合寿命を決定するために、クライアントはまず、特定のソケットからのサーバーへのバインディング要求を送信し、X.これはNATにバインディングを作成します。サーバーからの応答はNATのパブリックアドレスとポートを提供し、MAPPED-ADDRESS属性が含まれています。それぞれ、このPaとPpのを呼び出します。次に、クライアントは、T秒の値を持つタイマーを開始します。ときにこのタイマーが起動、クライアントが同じ宛先アドレスとポートを使用して、サーバーに別のバインディング要求を送信しますが、異なるソケットから、Y.この要求は、（PA、PP）に設定し、RESPONSE-ADDRESSアドレス属性が含まれています。これはNATに新しいバインディングを作成し、それがまだ存在する場合は、古いバインディングに一致しバインディングレスポンスを送信するためにSTUNサーバーの原因となります。クライアントがソケットX上の結合応答を受信した場合、それは結合の期限が切れていないことを知っています。クライアントは（古いバインディングが期限切れになった場合に可能であり、NATバインディング新に同じパブリックアドレスとポートを割り当てられる）、またはまったく応答がない、それは結合の期限が切れていることを知っているソケットY上の結合応答を受信した場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client can find the value of the binding lifetime by doing a binary search through T, arriving eventually at the value where the response is not received for any timer greater than T, but is received for any timer less than T.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、応答がどのタイマーTよりも大きいために受信されない値で最終的に到着し、Tを通じてバイナリ検索を行うことによって結合寿命の値を見つけることができますが、すべてのタイマーのために受信されたT.未満
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This discovery process takes quite a bit of time, and is something that will typically be run in the background on a device once it boots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この発見プロセスは、かなりの時間を要し、それが起動すると、通常、デバイスのバックグラウンドで実行されるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that the client can get inconsistent results each time this process is run. For example, if the NAT should reboot, or be reset for some reason, the process may discover a lifetime than is shorter than the actual one. For this reason, implementations are encouraged to run the test numerous times, and be prepared to get inconsistent results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが一貫性のない結果にこのプロセスが実行されるたびに得ることができることも可能です。 NATは、再起動する必要がある、または何らかの理由でリセットされた場合、プロセスは、実際のものよりも短くなっているよりも、寿命を発見することがあります。このため、実装はテストを何度も実行することが奨励され、かつ一貫性のない結果を得るために準備すること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3 Binding Acquisition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3バインディング買収
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider once more the case of a VoIP phone. It used the discovery process above when it started up, to discover its environment. Now, it wants to make a call. As part of the discovery process, it determined that it was behind a full-cone NAT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もう一度VoIP電話のケースを考えてみましょう。それが起動したときには、その環境を発見するために、上記の検出プロセスを使用していました。さて、それは電話をしたいと考えています。検出プロセスの一環として、それはフルコーンNATの背後にあったと判断しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider further that this phone consists of two logically separated components - a control component that handles signaling, and a media component that handles the audio, video, and RTP [12]. Both are behind the same NAT. Because of this separation of control and media, we wish to minimize the communication required between them. In fact, they may not even run on the same host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シグナリングを処理する制御コンポーネント、オーディオ、ビデオを処理するメディアコンポーネント、およびRTP [12]  - この携帯電話は、2つの論理的に分離された成分からなることをさらに考えます。どちらも、同じNATの背後にあります。そのため制御とメディアのこの分離のため、我々は彼らの間で必要な通信を最小限にしたいです。実際に、彼らも同じホスト上で実行されないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to make a voice call, the phone needs to obtain an IP address and port that it can place in the call setup message as the destination for receiving audio.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
音声通話を行うために、携帯電話は、それがオーディオを受信するための宛先として呼設定メッセージに置くことができるIPアドレスとポートを取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To obtain an address, the control component sends a Shared Secret Request to the server, obtains a shared secret, and then sends a Binding Request to the server. No CHANGE-REQUEST attribute is present in the Binding Request, and neither is the RESPONSE-ADDRESS attribute. The Binding Response contains a mapped address. The control component then formulates a second Binding Request. This request contains a RESPONSE-ADDRESS, which is set to the mapped address learned from the previous Binding Response. This Binding Request is passed to the media component, along with the IP address and port of the STUN server. The media component sends the Binding Request. The request goes to the STUN server, which sends the Binding Response back to the control component. The control component receives this, and now has learned an IP address and port that will be routed back to the media component that sent the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アドレスを取得するには、コントロールコンポーネントは、サーバーに共有シークレット要求を送信し、共有秘密を取得し、サーバーへのバインディング要求を送信します。いいえCHANGE-REQUEST属性は、バインディング要求に存在しない、とどちらもRESPONSE-ADDRESS属性です。バインディングレスポンスがマッピングされたアドレスが含まれています。制御コンポーネントは、第2のバインディング要求を定式化します。この要求は、マッピングされたアドレスに設定されているRESPONSE-ADDRESSは、以前のバインディングレスポンスから学んだ含まれています。このバインディング要求は、STUNサーバーのIPアドレスとポートとともに、メディアコンポーネントに渡されます。メディアコンポーネントは、バインディング要求を送信します。リクエストは、バック制御コンポーネントへの結合応答を送信STUNサーバー、に行きます。制御コンポーネントは、これを受けて、すぐに戻って、要求を送信したメディアコンポーネントにルーティングされますIPアドレスとポートを学習しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client will be able to receive media from anywhere on this mapped address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、このマッピングされたアドレス上の任意の場所からメディアを受け取ることができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of silence suppression, there may be periods where the client receives no media. In this case, the UDP bindings could timeout (UDP bindings in NATs are typically short; 30 seconds is common). To deal with this, the application can periodically retransmit the query in order to keep the binding fresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無音圧縮の場合には、クライアントが何メディアを受信しない期間があってもよいです。この場合、UDPバインディングはタイムアウト可能性（のNATでUDPバインディングは、典型的には短い、30秒が一般的です）。これに対処するには、アプリケーションは定期的に結合新鮮に保つために、クエリを再送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that both participants in the multimedia session are behind the same NAT. In that case, both will repeat this procedure above, and both will obtain public address bindings. When one sends media to the other, the media is routed to the NAT, and then turns right back around to come back into the enterprise, where it is translated to the private address of the recipient. This is not particularly efficient, and unfortunately, does not work in many commercial NATs. In such cases, the clients may need to retry using private addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチメディアセッションの両方の参加者が同じNATの背後にあることも可能です。その場合、両方とも上記この手順を繰り返すであろう、との両方がパブリックアドレスバインディングを取得します。一方が他方にメディアを送信すると、メディアはNATにルーティングされ、その後、戻ってそれが受信者のプライベートアドレスに変換され、企業、に来て周りの右折り返しています。これは特に効率的ではありません、残念ながら、多くの商用のNATでは動作しません。このような場合には、クライアントがプライベートアドレスを使用して再試行する必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Protocol Details
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.プロトコルの詳細
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section presents the detailed encoding of a STUN message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、STUNメッセージの詳細なエンコーディングを提示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN is a request-response protocol. Clients send a request, and the server sends a response. There are two requests, Binding Request, and Shared Secret Request. The response to a Binding Request can either be the Binding Response or Binding Error Response. The response to a Shared Secret Request can either be a Shared Secret Response or a Shared Secret Error Response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNは、要求 - 応答プロトコルです。クライアントがリクエストを送信し、サーバが応答を送信します。 2つの要求、バインディング要求、および共有シークレット要求があります。バインディング要求への応答は、バインディングレスポンスやバインディングエラー応答のいずれかとすることができます。共有シークレット要求に対する応答は、いずれかの共有秘密レスポンスまたは共有秘密エラー応答することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN messages are encoded using binary fields. All integer fields are carried in network byte order, that is, most significant byte (octet) first. This byte order is commonly known as big-endian. The transmission order is described in detail in Appendix B of RFC 791 [6]. Unless otherwise noted, numeric constants are in decimal (base 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNメッセージは、バイナリフィールドを使用してエンコードされています。すべての整数フィールドは、最上位バイト（オクテット）最初、つまり、ネットワークバイト順に搬送されます。このバイト順は、一般的にビッグエンディアンとして知られています。送信順序は、RFC 791の付録Bに詳細に記載されている[6]。特に断りのない限り、数値定数は、小数点（基数10）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1 Message Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1メッセージのヘッダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All STUN messages consist of a 20 byte header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのSTUNメッセージは、20バイトのヘッダーで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      STUN Message Type        |         Message Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                            Transaction ID
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                                                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Message Types can take on the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージタイプは、以下の値を取ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x0001 : Binding Request 0x0101 : Binding Response 0x0111 : Binding Error Response 0x0002 : Shared Secret Request 0x0102 : Shared Secret Response 0x0112 : Shared Secret Error Response
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x0001：バインディング要求0x0101：バインディングレスポンス0x0111：バインディングエラー応答0×0002：共有シークレット要求0x0102：共有シークレット応答0x0112：共有シークレットエラー応答
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The message length is the count, in bytes, of the size of the message, not including the 20 byte header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ長は、20バイトのヘッダーを含まないメッセージのサイズのバイト単位の数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transaction ID is a 128 bit identifier. It also serves as salt to randomize the request and the response. All responses carry the same identifier as the request they correspond to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランザクションIDは、128ビットの識別子です。それはまた、要求と応答をランダム化する塩として働きます。すべての応答は、それらが対応要求と同じ識別子を運びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2 Message Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2メッセージ属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the header are 0 or more attributes. Each attribute is TLV encoded, with a 16 bit type, 16 bit length, and variable value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダの後に0以上の属性です。各属性は、TLVは、16ビットのタイプ、16ビット長、及び変数値と、符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Type                  |            Length             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Value                             ....
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following types are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のタイプが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0001: MAPPED-ADDRESS 0x0002: RESPONSE-ADDRESS 0x0003: CHANGE-REQUEST 0x0004: SOURCE-ADDRESS 0x0005: CHANGED-ADDRESS 0x0006: USERNAME 0x0007: PASSWORD 0x0008: MESSAGE-INTEGRITY 0x0009: ERROR-CODE 0x000a: UNKNOWN-ATTRIBUTES 0x000b: REFLECTED-FROM
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0001に：MAPPED-ADDRESSの0×0002：RESPONSE-ADDRESSの0x0003：CHANGE-REQUEST 0x0004は：SOURCEアドレス0x0005：CHANGED-ADDRESSの0x0006：USERNAME 0x0007：PASSWORD 0x0008で：MESSAGE-INTEGRITY 0x0009：ERROR-CODE 0x000a：UNKNOWN-ATTRIBUTES 0x000b：REFLECTED-から
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To allow future revisions of this specification to add new attributes if needed, the attribute space is divided into optional and mandatory ones. Attributes with values greater than 0x7fff are optional, which means that the message can be processed by the client or server even though the attribute is not understood. Attributes with values less than or equal to 0x7fff are mandatory to understand, which means that the client or server cannot process the message unless it understands the attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要であれば、この仕様の将来の改訂は、新しい属性を追加できるようにするには、属性空間は、オプションと必須のものに分かれています。メッセージは属性が理解されていないにもかかわらず、クライアントまたはサーバで処理できることを意味し、0x7FFFのがオプションであるよりも大きな値を持つ属性。未満の値を持つ属性や0x7FFFのに等しいが、それは属性を理解しない限り、クライアントまたはサーバがメッセージを処理できないことを意味し、理解することが必須です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MESSAGE-INTEGRITY attribute MUST be the last attribute within a message. Any attributes that are known, but are not supposed to be present in a message (MAPPED-ADDRESS in a request, for example) MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MESSAGE-INTEGRITY属性は、メッセージ内の最後の属性であるに違いありません。知られているが、（例えば、要求にマッピング-ADDRESS）メッセージに存在することが想定されていない属性は無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 2 indicates which attributes are present in which messages. An M indicates that inclusion of the attribute in the message is mandatory, O means its optional, C means it&#39;s conditional based on some other aspect of the message, and N/A means that the attribute is not applicable to that message type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表2は、そのメッセージに存在している属性を示します。 Mは、メッセージ内の属性を含めることが必須であり、Oは、そのオプションを意味していることを示し、Cは、メッセージのいくつかの他の態様に基づいて、条件付きだし、N / Aは、属性はそのメッセージ・タイプに適用されないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                         Binding  Shared  Shared  Shared
                       Binding  Binding  Error    Secret  Secret  Secret
   Att.                Req.     Resp.    Resp.    Req.    Resp.   Error
                                                                  Resp.
   _____________________________________________________________________
   MAPPED-ADDRESS      N/A      M        N/A      N/A     N/A     N/A
   RESPONSE-ADDRESS    O        N/A      N/A      N/A     N/A     N/A
   CHANGE-REQUEST      O        N/A      N/A      N/A     N/A     N/A
   SOURCE-ADDRESS      N/A      M        N/A      N/A     N/A     N/A
   CHANGED-ADDRESS     N/A      M        N/A      N/A     N/A     N/A
   USERNAME            O        N/A      N/A      N/A     M       N/A
   PASSWORD            N/A      N/A      N/A      N/A     M       N/A
   MESSAGE-INTEGRITY   O        O        N/A      N/A     N/A     N/A
   ERROR-CODE          N/A      N/A      M        N/A     N/A     M
   UNKNOWN-ATTRIBUTES  N/A      N/A      C        N/A     N/A     C
   REFLECTED-FROM      N/A      C        N/A      N/A     N/A     N/A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 2: Summary of Attributes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表2：属性の概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The length refers to the length of the value element, expressed as an unsigned integral number of bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さはバイトの符号なし整数として表さ、value要素の長さを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.1 MAPPED-ADDRESS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.1 MAPPED-ADDRESS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MAPPED-ADDRESS attribute indicates the mapped IP address and port. It consists of an eight bit address family, and a sixteen bit port, followed by a fixed length value representing the IP address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAPPED-ADDRESS属性は、マッピングされたIPアドレスとポートを示します。これは、IPアドレスを表す固定長値が続く8ビット・アドレス・ファミリ、および16ビットポートからなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |x x x x x x x x|    Family     |           Port                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Address                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The port is a network byte ordered representation of the mapped port. The address family is always 0x01, corresponding to IPv4. The first 8 bits of the MAPPED-ADDRESS are ignored, for the purposes of aligning parameters on natural boundaries. The IPv4 address is 32 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポートは、マッピングされたポートのネットワークバイト注文した表現です。アドレスファミリは、IPv4に対応し、常に0x01です。 MAPPED-ADDRESSの最初の8ビットは、自然界にパラメータを配向させる目的のために、無視されます。 IPv4アドレスは32ビットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.2 RESPONSE-ADDRESS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.2 RESPONSE-ADDRESS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RESPONSE-ADDRESS attribute indicates where the response to a Binding Request should be sent. Its syntax is identical to MAPPED-ADDRESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESPONSE-ADDRESS属性は、バインディング要求に対する応答が送信されるべき場所を示します。その構文はMAPPED-ADDRESSと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.3 CHANGED-ADDRESS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.3 CHANGED-ADDRESS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CHANGED-ADDRESS attribute indicates the IP address and port where responses would have been sent from if the &#34;change IP&#34; and &#34;change port&#34; flags had been set in the CHANGE-REQUEST attribute of the Binding Request. The attribute is always present in a Binding Response, independent of the value of the flags. Its syntax is identical to MAPPED-ADDRESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CHANGED-ADDRESS属性は、応答は「変更IP」と「ポート変更」フラグがバインディング要求のCHANGE-REQUEST属性に設定されていた場合から送信されたであろうIPアドレスとポートを示します。属性は常にフラグの値の独立した結合応答、中に存在しています。その構文はMAPPED-ADDRESSと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.4 CHANGE-REQUEST
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.4 CHANGE-REQUEST
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CHANGE-REQUEST attribute is used by the client to request that the server use a different address and/or port when sending the response. The attribute is 32 bits long, although only two bits (A and B) are used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CHANGE-REQUEST属性は、応答を送信するときに、サーバーが別のアドレスおよび/またはポートを使用することを要求するためにクライアントによって使用されます。唯一の2ビット（AとB）が使用されるが、属性は、32ビット長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 A B 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of the flags is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグの意味は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A: This is the &#34;change IP&#34; flag. If true, it requests the server to send the Binding Response with a different IP address than the one the Binding Request was received on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
：これは、「変更IP」フラグです。 trueの場合、それは、バインディング要求が受信されたものとは異なるIPアドレスを持つバインディングレスポンスを送信するようにサーバに要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B: This is the &#34;change port&#34; flag. If true, it requests the server to send the Binding Response with a different port than the one the Binding Request was received on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B：これは、「ポート変更」フラグです。 trueの場合、それは、バインディング要求が受信されたものとは異なるポートとバインディングレスポンスを送信するようにサーバに要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.5 SOURCE-ADDRESS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.5 SOURCE-ADDRESS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SOURCE-ADDRESS attribute is present in Binding Responses. It indicates the source IP address and port that the server is sending the response from. Its syntax is identical to that of MAPPED-ADDRESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SOURCE-ADDRESS属性は、バインディングレスポンスに存在しています。これは、サーバーからの応答を送信している送信元IPアドレスとポートを示します。その構文はMAPPED-ADDRESSのものと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.6 USERNAME
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.6 USERNAME
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The USERNAME attribute is used for message integrity. It serves as a means to identify the shared secret used in the message integrity check. The USERNAME is always present in a Shared Secret Response, along with the PASSWORD. It is optionally present in a Binding Request when message integrity is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
USERNAME属性は、メッセージの完全性のために使用されています。これは、メッセージの整合性チェックに使用される共有秘密を識別するための手段として機能します。 USERNAMEは、パスワードとともに、常に共有秘密応答中に存在しています。これは、メッセージの完全性が使用されるバインディング要求に任意に存在しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of USERNAME is a variable length opaque value. Its length MUST be a multiple of 4 (measured in bytes) in order to guarantee alignment of attributes on word boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
USERNAMEの値は可変長の不透明な値です。その長さはワード境界上の属性の整列を保証するために（バイト単位）4の倍数でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.7 PASSWORD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.7 PASSWORD
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PASSWORD attribute is used in Shared Secret Responses. It is always present in a Shared Secret Response, along with the USERNAME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PASSWORD属性は、共有秘密応答で使用されています。これは、USERNAMEと一緒に、共有秘密応答に常に存在しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of PASSWORD is a variable length value that is to be used as a shared secret. Its length MUST be a multiple of 4 (measured in bytes) in order to guarantee alignment of attributes on word boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PASSWORDの値は、共有秘密として使用される可変長値です。その長さはワード境界上の属性の整列を保証するために（バイト単位）4の倍数でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.8 MESSAGE-INTEGRITY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.8 MESSAGE-INTEGRITY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MESSAGE-INTEGRITY attribute contains an HMAC-SHA1 [13] of the STUN message. It can be present in Binding Requests or Binding Responses. Since it uses the SHA1 hash, the HMAC will be 20 bytes. The text used as input to HMAC is the STUN message, including the header, up to and including the attribute preceding the MESSAGE-INTEGRITY attribute. That text is then padded with zeroes so as to be a multiple of 64 bytes. As a result, the MESSAGE-INTEGRITY attribute MUST be the last attribute in any STUN message. The key used as input to HMAC depends on the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MESSAGE-INTEGRITY属性は、STUNメッセージのHMAC-SHA1 [13]を含んでいます。これは、バインディングの要求または結合応答の中に存在することができます。それはSHA1ハッシュを使用しているので、HMACは20バイトになります。 HMACへの入力として使用されるテキストはまで、ヘッダを含み、MESSAGE-INTEGRITYアトリビュートを先行属性を含む、STUNメッセージです。 64バイトの倍数になるようにそのテキストは、ゼロで埋められます。その結果、MESSAGE-INTEGRITY属性は、任意のSTUNメッセージの最後の属性であるに違いありません。 HMACへの入力として使用されるキーは、文脈に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.9 ERROR-CODE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.9 ERROR-CODE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ERROR-CODE attribute is present in the Binding Error Response and Shared Secret Error Response. It is a numeric value in the range of 100 to 699 plus a textual reason phrase encoded in UTF-8, and is consistent in its code assignments and semantics with SIP [10] and HTTP [15]. The reason phrase is meant for user consumption, and can be anything appropriate for the response code. The lengths of the reason phrases MUST be a multiple of 4 (measured in bytes). This can be accomplished by added spaces to the end of the text, if necessary. Recommended reason phrases for the defined response codes are presented below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERROR-CODE属性は、バインディングエラー応答と共有シークレットエラー応答に存在しています。これは、699から100までの範囲に加えてUTF-8でエンコードされたテキストの理由句の数値であり、SIPとのコード割り当ておよびセマンティクスに一致している[10]とHTTP [15]。理由フレーズは、ユーザーの消費のために意図されており、応答コードのための適切な何もすることができます。理由フレーズの長さ（バイト単位）、4の倍数でなければなりません。必要な場合、これは、テキストの末尾に追加スペースで達成することができます。定義された応答コードの推奨理由フレーズを以下に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To facilitate processing, the class of the error code (the hundreds digit) is encoded separately from the rest of the code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
処理を容易にするために、エラーコード（数百の桁）のクラスは、コードの残りの部分とは別個に符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                   0                     |Class|     Number    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Reason Phrase (variable)                                ..
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The class represents the hundreds digit of the response code. The value MUST be between 1 and 6. The number represents the response code modulo 100, and its value MUST be between 0 and 99.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラスは、応答コードの数百の位を表します。値は1と6の間でなければなりません数が応答コードモジュロ100を示し、その値は0と99の間でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following response codes, along with their recommended reason phrases (in brackets) are defined at this time:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（カッコ内）は、推奨理由のフレーズと一緒に以下のレスポンスコードは、この時点で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
400 (Bad Request): The request was malformed. The client should not retry the request without modification from the previous attempt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
400（不正な要求）：要求が不正な形式でした。クライアントは、以前の試みから変更なしで要求を再試行するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
401 (Unauthorized): The Binding Request did not contain a MESSAGE-INTEGRITY attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
401（無許可）：バインディング要求は、MESSAGE-INTEGRITY属性が含まれていませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
420 (Unknown Attribute): The server did not understand a mandatory attribute in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
420（未知のアトリビュート）：サーバーは要求で必須の属性を理解していませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
430 (Stale Credentials): The Binding Request did contain a MESSAGE-INTEGRITY attribute, but it used a shared secret that has expired. The client should obtain a new shared secret and try again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
430（古い資格情報）：バインディング要求は、MESSAGE-INTEGRITYアトリビュートを含んでいたが、それは有効期限が切れた共有秘密鍵を使用していました。クライアントは、新しい共有秘密を取得して、もう一度試してみてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
431 (Integrity Check Failure): The Binding Request contained a MESSAGE-INTEGRITY attribute, but the HMAC failed verification. This could be a sign of a potential attack, or client implementation error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
431（整合性チェックの失敗）：バインディング要求は、MESSAGE-INTEGRITYアトリビュートを含んでいますが、HMACは、検証に失敗しました。これは潜在的な攻撃、またはクライアントの実装エラーの兆候かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
432 (Missing Username): The Binding Request contained a MESSAGE-INTEGRITY attribute, but not a USERNAME attribute. Both must be present for integrity checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
432は、（ユーザ名がありません）：バインディング要求はUSERNAME属性MESSAGE-INTEGRITYアトリビュートを含んでいますが、ありません。どちらも、整合性チェックのために存在している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
433 (Use TLS): The Shared Secret request has to be sent over TLS, but was not received over TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
433（使用TLS）：共有シークレット要求がTLS上で送信される必要がありますが、TLSを介して受信されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
500 (Server Error): The server has suffered a temporary error. The client should try again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
500（サーバーエラー）：サーバーは、一時的なエラーを受けました。クライアントは、もう一度試してみてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
600 (Global Failure:) The server is refusing to fulfill the request. The client should not retry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
600（グローバル失敗:)サーバーが要求を満たすために拒否しています。クライアントが再試行するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.10 UNKNOWN-ATTRIBUTES
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.10 UNKNOWN-ATTRIBUTES
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UNKNOWN-ATTRIBUTES attribute is present only in a Binding Error Response or Shared Secret Error Response when the response code in the ERROR-CODE attribute is 420.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNKNOWN-ATTRIBUTESはERROR-CODEアトリビュートにおけるレスポンスコードが420である場合にのみ結合エラーレスポンスまたは共有秘密エラーレスポンスに存在している属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attribute contains a list of 16 bit values, each of which represents an attribute type that was not understood by the server. If the number of unknown attributes is an odd number, one of the attributes MUST be repeated in the list, so that the total length of the list is a multiple of 4 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性は、サーバによって理解されなかった属性タイプを表し各々が16ビット値のリストを含みます。未知の属性の数が奇数である場合は、リストの合計の長さが4バイトの倍数になるように、属性の1つは、リスト内で繰り返されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Attribute 1 Type           |     Attribute 2 Type        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      Attribute 3 Type           |     Attribute 4 Type    ...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.11 REFLECTED-FROM
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.11は反射FROM
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REFLECTED-FROM attribute is present only in Binding Responses, when the Binding Request contained a RESPONSE-ADDRESS attribute. The attribute contains the identity (in terms of IP address) of the source where the request came from. Its purpose is to provide traceability, so that a STUN server cannot be used as a reflector for denial-of-service attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
反射から属性バインディング要求がRESPONSE-ADDRESS属性を含む場合、のみバインド応答に存在しています。属性は、要求が来たから元の（IPアドレスの観点で）アイデンティティが含まれています。その目的は、STUNサーバーは、サービス拒否攻撃のための反射板として使用することはできませんように、トレーサビリティを提供することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Its syntax is identical to the MAPPED-ADDRESS attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その構文はMAPPED-ADDRESS属性と同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1 Attacks on STUN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
STUNの12.1攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generally speaking, attacks on STUN can be classified into denial of service attacks and eavesdropping attacks. Denial of service attacks can be launched against a STUN server itself, or against other elements using the STUN protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的に言って、STUNへの攻撃は、サービス拒否攻撃や盗聴攻撃の拒否に分類することができます。サービス妨害攻撃は、STUNサーバー自体に対して、またはSTUNプロトコルを使用して他の要素に対して実行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN servers create state through the Shared Secret Request mechanism. To prevent being swamped with traffic, a STUN server SHOULD limit the number of simultaneous TLS connections it will hold open by dropping an existing connection when a new connection request arrives (based on an Least Recently Used (LRU) policy, for example). Similarly, it SHOULD limit the number of shared secrets it will store, in the event that the server is storing the shared secrets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNサーバは、共有シークレット要求機構を介して状態を作成します。トラフィックが殺到するのを防ぐために、STUNサーバーが新しい接続要求が到着したときに既存の接続をドロップすることによって、オープン開催する同時TLS接続の数を制限する必要があります（例えば、最低使用頻度（LRU）ポリシーに基づいて）。同様に、サーバは共有秘密を記憶している場合には、それが記憶する共有秘密キーの数を制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attacks of greater interest are those in which the STUN server and client are used to launch DOS attacks against other entities, including the client itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大きな関心の攻撃は、STUNサーバとクライアントは、クライアント自体を含む他のエンティティに対するDOS攻撃を起動するために使用されているものがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many of the attacks require the attacker to generate a response to a legitimate STUN request, in order to provide the client with a faked MAPPED-ADDRESS. The attacks that can be launched using such a technique include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃の多くは、偽造MAPPED-ADDRESSをクライアントに提供するために、正当なSTUN要求に対する応答を生成するために、攻撃者が必要です。このような技術を使用して起動することができます攻撃は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.1 Attack I: DDOS Against a Target
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.1攻撃I：標的に対してDDOS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, the attacker provides a large number of clients with the same faked MAPPED-ADDRESS that points to the intended target. This will trick all the STUN clients into thinking that their addresses are equal to that of the target. The clients then hand out that address in order to receive traffic on it (for example, in SIP or H.323 messages). However, all of that traffic becomes focused at the intended target. The attack can provide substantial amplification, especially when used with clients that are using STUN to enable multimedia applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、攻撃者は、意図した標的を指す同じ偽装MAPPED-ADDRESSと多数のクライアントを提供します。これは、それらのアドレスはターゲットと同等であることを考えることに、すべてのSTUNクライアントをだまします。クライアントは、（例えば、SIPやH.323メッセージ内で）その上でトラフィックを受信するために、そのアドレスを配ります。しかし、そのトラフィックのすべてが意図した目標に焦点を当てた状態になります。攻撃は、マルチメディア・アプリケーションを可能にするために、STUNを使用しているクライアントで使用し、特にかなりの増幅を、提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.2 Attack II: Silencing a Client
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.2攻撃II：クライアントを消します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this attack, the attacker seeks to deny a client access to services enabled by STUN (for example, a client using STUN to enable SIP-based multimedia traffic). To do that, the attacker provides that client with a faked MAPPED-ADDRESS. The MAPPED-ADDRESS it provides is an IP address that routes to nowhere. As a result, the client won&#39;t receive any of the packets it expects to receive when it hands out the MAPPED-ADDRESS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この攻撃では、攻撃者が（例えば、SIPベースのマルチメディアトラフィックを有効にするには、STUNを使用するクライアント）STUNによって対応サービスへのクライアントアクセスを拒否することを目指しています。そのためには、攻撃者が偽造MAPPED-ADDRESSとそのクライアントを提供します。それが提供するMAPPED-ADDRESSは、ルートがどこにIPアドレスです。その結果、クライアントは、それがMAPPED-ADDRESSを渡したときに受信することを期待するパケットのいずれかを受け取ることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This exploitation is not very interesting for the attacker. It impacts a single client, which is frequently not the desired target. Moreover, any attacker that can mount the attack could also deny service to the client by other means, such as preventing the client from receiving any response from the STUN server, or even a DHCP server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この開発は、攻撃者にとって非常に興味深いものではありません。それに影響を与える頻繁に所望のターゲットではない単一のクライアント、。また、攻撃を仕掛けることができます任意の攻撃者は、このようなSTUNサーバー、あるいはDHCPサーバからの応答を受信からクライアントを防ぐなど、他の手段によって、クライアントへのサービスを拒否することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.3 Attack III: Assuming the Identity of a Client
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.3攻撃III：クライアントのアイデンティティを仮定すると、
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This attack is similar to attack II. However, the faked MAPPED-ADDRESS points to the attacker themself. This allows the attacker to receive traffic which was destined for the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この攻撃は、攻撃IIに似ています。しかし、攻撃者はその人自身にマッピングされた-ADDRESSポイントを偽造。これにより、攻撃者は、クライアント宛てたトラフィックを受信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.4 Attack IV: Eavesdropping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1.4攻撃IV：盗み聞き
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this attack, the attacker forces the client to use a MAPPED-ADDRESS that routes to itself. It then forwards any packets it receives to the client. This attack would allow the attacker to observe all packets sent to the client. However, in order to launch the attack, the attacker must have already been able to observe packets from the client to the STUN server. In most cases (such as when the attack is launched from an access network), this means that the attacker could already observe packets sent to the client. This attack is, as a result, only useful for observing traffic by attackers on the path from the client to the STUN server, but not generally on the path of packets being routed towards the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この攻撃では、攻撃者は、自分自身にマッピングされた-ADDRESSルートを使用するようにクライアントを強制します。それは、それがクライアントに受け取るすべてのパケットを転送します。この攻撃では、攻撃者がクライアントに送信されたすべてのパケットを観察することができるようになります。しかし、攻撃を開始するためには、攻撃者は、すでにSTUNサーバーへのクライアントからのパケットを観察することができたに違いありません。 （このような攻撃は、アクセスネットワークから起動された場合など）、ほとんどの場合、これは、攻撃者は、すでにクライアントに送信されたパケットを観察することができたことを意味します。この攻撃ではなく、一般的にクライアントに向けてルーティングされたパケットのパス上に、クライアントからSTUNサーバーへのパス上の攻撃者がトラフィックを観察するだけで便利、結果として、あります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2 Launching the Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2攻撃を
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that attacks of this nature (injecting responses with fake MAPPED-ADDRESSes) require that the attacker be capable of eavesdropping requests sent from the client to the server (or to act as a MITM for such attacks). This is because STUN requests contain a transaction identifier, selected by the client, which is random with 128 bits of entropy. The server echoes this value in the response, and the client ignores any responses that don&#39;t have a matching transaction ID. Therefore, in order for an attacker to provide a faked response that is accepted by the client, the attacker needs to know what the transaction ID in the request was. The large amount of randomness, combined with the need to know when the client sends a request, precludes attacks that involve guessing the transaction ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（偽のMAPPED-アドレスで応答を注入する）この種の攻撃は、攻撃者がクライアントからサーバに送信された盗聴要求できること（または、そのような攻撃のMITMとして機能する）ことを必要とすることに注意することが重要です。 STUN要求がエントロピーの128ビットのランダムでクライアントによって選択されたトランザクション識別子を含むためです。サーバが応答して、この値をエコー、およびクライアントは、一致するトランザクションIDをお持ちでない任意の応答を無視します。そのため、クライアントによって受け入れられている偽造応答を提供するために、攻撃者のためのためには、攻撃者が要求におけるトランザクションIDが何であったかを知る必要があります。クライアントが要求を送信するときに知る必要と組み合わせてランダ​​ムに大量のは、トランザクションIDを推測伴う攻撃を排除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since all of the above attacks rely on this one primitive - injecting a response with a faked MAPPED-ADDRESS - preventing the attacks is accomplished by preventing this one operation. To prevent it, we need to consider the various ways in which it can be accomplished. There are several:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
偽造MAPPED-ADDRESSと応答を注入 -   - 上記の攻撃のすべてはこのプリミティブに依存しているので、攻撃を防ぐこのいずれかの操作を防止することによって達成されます。それを防ぐために、我々はそれを達成することができるさまざまな方法を検討する必要があります。いくつかあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.1 Approach I: Compromise a Legitimate STUN Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.1アプローチI：正当なSTUNサーバーを危険にさらします
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this attack, the attacker compromises a legitimate STUN server through a virus or Trojan horse. Presumably, this would allow the attacker to take over the STUN server, and control the types of responses it generates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この攻撃では、攻撃者は、ウイルスやトロイの木馬によって合法的なSTUNサーバーを損ないます。おそらく、これは、攻撃者がSTUNサーバーを引き継ぎ、そしてそれが生成する反応の種類を制御することができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compromise of a STUN server can also lead to discovery of open ports. Knowledge of an open port creates an opportunity for DoS attacks on those ports (or DDoS attacks if the traversed NAT is a full cone NAT). Discovering open ports is already fairly trivial using port probing, so this does not represent a major threat.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNサーバーの妥協も開いているポートの発見につながることができます。 （トラバースNATがフルコーンNATがある場合やDDoS攻撃）開いているポートの知識は、これらのポート上のDoS攻撃の機会を作成します。開いているポートを発見するプロービングポートを使用して、すでにかなり簡単ですので、これは大きな脅威を表すものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.2 Approach II: DNS Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.2アプローチII：DNS攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN servers are discovered using DNS SRV records. If an attacker can compromise the DNS, it can inject fake records which map a domain name to the IP address of a STUN server run by the attacker. This will allow it to inject fake responses to launch any of the attacks above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNサーバーは、DNS SRVレコードを使用して発見されます。攻撃者がDNSを損なうことができれば、それは攻撃者によって実行さSTUNサーバーのドメイン名をIPアドレスにマッピングし、偽のレコードを注入することができます。これは、上記の攻撃のいずれかを起動するために偽の応答を注入することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.3 Approach III: Rogue Router or NAT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.3アプローチIII：ローグルータまたはNAT
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rather than compromise the STUN server, an attacker can cause a STUN server to generate responses with the wrong MAPPED-ADDRESS by compromising a router or NAT on the path from the client to the STUN server. When the STUN request passes through the rogue router or NAT, it rewrites the source address of the packet to be that of the desired MAPPED-ADDRESS. This address cannot be arbitrary. If the attacker is on the public Internet (that is, there are no NATs between it and the STUN server), and the attacker doesn&#39;t modify the STUN request, the address has to have the property that packets sent from the STUN server to that address would route through the compromised router. This is because the STUN server will send the responses back to the source address of the request. With a modified source address, the only way they can reach the client is if the compromised router directs them there. If the attacker is on the public Internet, but they can modify the STUN request, they can insert a RESPONSE-ADDRESS attribute into the request, containing the actual source address of the STUN request. This will cause the server to send the response to the client, independent of the source address the STUN server sees. This gives the attacker the ability to forge an arbitrary source address when it forwards the STUN request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNサーバーを危険にさらすのではなく、攻撃者がSTUNサーバはSTUNサーバーへのクライアントからのパス上のルータやNATを妥協することにより、間違ったMAPPED-ADDRESSとの応答を生成することがあります。 STUN要求が不正ルータまたはNATを通過するとき、それは所望のMAPPED-ADDRESSとするパケットの送信元アドレスを書き換えます。このアドレスは任意にすることはできません。攻撃者は、公共のインターネット上にある場合（つまり、それとSTUNサーバーの間にNATが存在しない）、およびSTUN要求を変更しない攻撃者が、アドレスがにSTUNサーバから送信されたパケットの特性を持たなければなりませんそのアドレスが損なわルータ経由のルートでしょう。 STUNサーバは、要求の送信元アドレスに応答を送り返すためです。妥協ルータがあり、それらを指示した場合に変更されたソースアドレスを使用すると、彼らはクライアントに到達することができます唯一の方法です。攻撃者は、公共のインターネット上にあるが、彼らはSTUN要求を変更することができれば、彼らはSTUN要求の実際の送信元アドレスを含む、リクエストに応答ADDRESS属性を挿入することができます。これは、サーバーがSTUNサーバが見る元アドレスの独立したクライアントへの応答を送信します。これにより、攻撃者にそれがSTUN要求を転送し、任意の送信元アドレスを偽造することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the attacker is on a private network (that is, there are NATs between it and the STUN server), the attacker will not be able to force the server to generate arbitrary MAPPED-ADRESSes in responses. They will only be able force the STUN server to generate MAPPED-ADDRESSes which route to the private network. This is because the NAT between the attacker and the STUN server will rewrite the source address of the STUN request, mapping it to a public address that routes to the private network. Because of this, the attacker can only force the server to generate faked mapped addresses that route to the private network. Unfortunately, it is possible that a low quality NAT would be willing to map an allocated public address to another public address (as opposed to an internal private address), in which case the attacker could forge the source address in a STUN request to be an arbitrary public address. This kind of behavior from NATs does appear to be rare.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は（つまり、それとSTUNサーバの間のNATがある）は、プライベートネットワーク上にある場合、攻撃者が回答に任意のMAPPED-住所がを生成するために、サーバーを強制することはできません。彼らはどのルートプライベートネットワークにマッピングされ、アドレスを生成するために、STUNサーバことが力になります。攻撃者とSTUNサーバー間のNATは、そのプライベートネットワークへのルートパブリックアドレスにマッピング、STUN要求の送信元アドレスを書き換えるためです。このため、攻撃者はそのプライベートネットワークへのルート偽造マッピングされたアドレスを生成するために、サーバーを強制することができます。残念ながら、低品質のNATは、攻撃者がSTUN要求のソースアドレスがあることを偽造可能性がある場合には、別のパブリックアドレス（内部プライベートアドレスではなく）、に割り当てられたパブリックアドレスをマッピングすることをいとわないことがあります任意のパブリックアドレス。 NATの行動から、この種の希少なように見えるん。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.4 Approach IV: MITM
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.4アプローチIV：MITM
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an alternative to approach III, if the attacker can place an element on the path from the client to the server, the element can act as a man-in-the-middle. In that case, it can intercept a STUN request, and generate a STUN response directly with any desired value of the MAPPED-ADDRESS field. Alternatively, it can forward the STUN request to the server (after potential modification), receive the response, and forward it to the client. When forwarding the request and response, this attack is subject to the same limitations on the MAPPED-ADDRESS described in Section 12.2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者がクライアントからサーバーへのパス上の要素を配置することができれば、IIIにアプローチする別の方法として、要素はのman-in-the-middleとして機能することができます。その場合には、STUN要求をインターセプトすることができ、マッピングされたアドレスフィールドの任意の所望の値を直接STUN応答を生成します。また、それは、（潜在的な改変後）サーバへのSTUN要求を転送し、応答を受け取り、それをクライアントに転送することができます。要求と応答を転送する場合、この攻撃は、セクション12.2.3に記載MAPPED-ADDRESSに同じ制限を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.5 Approach V: Response Injection Plus DoS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.5アプローチV：レスポンスインジェクションプラスのDoS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this approach, the attacker does not need to be a MITM (as in approaches III and IV). Rather, it only needs to be able to eavesdrop onto a network segment that carries STUN requests. This is easily done in multiple access networks such as ethernet or unprotected 802.11. To inject the fake response, the attacker listens on the network for a STUN request. When it sees one, it simultaneously launches a DoS attack on the STUN server, and generates its own STUN response with the desired MAPPED-ADDRESS value. The STUN response generated by the attacker will reach the client, and the DoS attack against the server is aimed at preventing the legitimate response from the server from reaching the client. Arguably, the attacker can do without the DoS attack on the server, so long as the faked response beats the real response back to the client, and the client uses the first response, and ignores the second (even though it&#39;s different).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（III及びIVに近づくように）このアプローチでは、攻撃者がMITMである必要はありません。むしろ、それだけSTUN要求を搬送するネットワークセグメント上に盗聴することができる必要があります。これは、簡単なイーサネットまたは保護されていない802.11など複数のアクセスネットワークで行われます。偽の応答を注入するために、攻撃者がSTUN要求のためのネットワーク上でリッスンします。それが1を見たとき、それは同時にSTUNサーバー上のDoS攻撃を開始し、希望MAPPED-ADDRESS値を持つ独自のSTUN応答を生成します。攻撃者によって生成されたSTUN応答がクライアントに到達し、サーバに対するDoS攻撃は、クライアントに達することから、サーバから正当な応答を防止することを目的としています。間違いなく、攻撃者は、そう長く偽造応答は、クライアントに実際の応答を打つと、クライアントは最初の応答を使用し、（それは違うにもかかわらず）は、第2のを無視して、サーバー上のDoS攻撃せずに行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.6 Approach VI: Duplication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2.6アプローチVI：複製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This approach is similar to approach V. The attacker listens on the network for a STUN request. When it sees it, it generates its own STUN request towards the server. This STUN request is identical to the one it saw, but with a spoofed source IP address. The spoofed address is equal to the one that the attacker desires to have placed in the MAPPED-ADDRESS of the STUN response. In fact, the attacker generates a flood of such packets. The STUN server will receive the one original request, plus a flood of duplicate fake ones. It generates responses to all of them. If the flood is sufficiently large for the responses to congest routers or some other equipment, there is a reasonable probability that the one real response is lost (along with many of the faked ones), but the net result is that only the faked responses are received by the STUN client. These responses are all identical and all contain the MAPPED-ADDRESS that the attacker wanted the client to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアプローチアプローチに似てV.攻撃者がSTUN要求のためのネットワークをリッスン。それを見ているときは、サーバーへの独自のSTUN要求を生成します。このSTUN要求は、それが見たものと同じですが、偽装された送信元のIPアドレスを持ちます。スプーフィングされたアドレスは、攻撃者がSTUN応答のマッピングされた-ADDRESSに配置されていることを望む1に等しいです。実際には、攻撃者がこのようなパケットの洪水を発生させます。 STUNサーバは、1つのオリジナルの要求に加え、重複した偽のものの洪水を受け取ることになります。これは、それらのすべてに対する応答を生成します。洪水がルーターを輻輳する応答またはいくつかの他の機器のために十分に大きい場合、そこに（偽造のものの多くと一緒に）1つの実応答が失われたことを合理的な可能性があるが、最終結果は唯一の偽造応答があるということですSTUNクライアントが受信しました。これらの応答はすべて同一であり、すべては、攻撃者がクライアントを使用していたMAPPED-ADDRESSが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flood of duplicate packets is not needed (that is, only one faked request is sent), so long as the faked response beats the real response back to the client, and the client uses the first response, and ignores the second (even though it&#39;s different).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重複パケットの洪水が必要とされていない限り偽造応答は、クライアントに実際の応答を打つと、クライアントは最初の応答を使用し、たとえ（第2を無視して、（それが唯一の要求が送られる偽造、です）違います）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that, in this approach, launching a DoS attack against the STUN server or the IP network, to prevent the valid response from being sent or received, is problematic. The attacker needs the STUN server to be available to handle its own request. Due to the periodic retransmissions of the request from the client, this leaves a very tiny window of opportunity. The attacker must start the DoS attack immediately after the actual request from the client, causing the correct response to be discarded, and then cease the DoS attack in order to send its own request, all before the next retransmission from the client. Due to the close spacing of the retransmits (100ms to a few seconds), this is very difficult to do.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信または受信されてからの有効な応答を防ぐために、STUNサーバやIPネットワークに対するDoS攻撃を開始、このアプローチでは、なお、問題があります。攻撃者は、独自のリクエストを処理するために利用できるようにSTUNサーバーを必要とします。クライアントからの要求の定期的な再送信には、これは機会の非常に小さなウィンドウを残します。攻撃者は、正しい応答を廃棄する原因と、クライアントからの実際の要求の直後にDoS攻撃を開始し、その後、すべてのクライアントからの次の再送信する前に、独自の要求を送信するために、DoS攻撃を停止する必要があります。再送（数秒に100ミリ秒）の近い間隔に、これを行うのは非常に困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Besides DoS attacks, there may be other ways to prevent the actual request from the client from reaching the server. Layer 2 manipulations, for example, might be able to accomplish it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DoS攻撃のほかに、サーバーに達することから、クライアントからの実際の要求を防ぐために、他の方法があるかもしれません。レイヤ2つの操作は、例えば、それを達成することができるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fortunately, Approach IV is subject to the same limitations documented in Section 12.2.3, which limit the range of MAPPED-ADDRESSes the attacker can cause the STUN server to generate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
幸いなことに、アプローチIVは、攻撃者がSTUNサーバが生成する可能性がありますMAPPED-アドレスの範囲を制限12.2.3項に記載と同じ制限に従うものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3 Countermeasures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3対策
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN provides mechanisms to counter the approaches described above, and additional, non-STUN techniques can be used as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNは、上述のアプローチに対抗するためのメカニズムを提供し、付加的な、非STUN技術も同様に使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First off, it is RECOMMENDED that networks with STUN clients implement ingress source filtering (RFC 2827 [7]). This is particularly important for the NATs themselves. As Section 12.2.3 explains, NATs which do not perform this check can be used as &#34;reflectors&#34; in DDoS attacks. Most NATs do perform this check as a default mode of operation. We strongly advise people that purchase NATs to ensure that this capability is present and enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のオフ、（[7] RFC 2827）STUNクライアントとネットワークが入力ソースフィルタリングを実装することが推奨されます。これは、NATを自分自身のために特に重要です。 12.2.3項が説明するように、このチェックを実行していないNATは、DDoS攻撃では「反射」として使用することができます。ほとんどのNATはデフォルトの動作モードとしては、このチェックを実行しません。私たちは強く、この機能が存在し、有効であることを確認するために、NATのを購入する人に助言します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Secondly, it is RECOMMENDED that STUN servers be run on hosts dedicated to STUN, with all UDP and TCP ports disabled except for the STUN ports. This is to prevent viruses and Trojan horses from infecting STUN servers, in order to prevent their compromise. This helps mitigate Approach I (Section 12.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二に、STUNサーバは、STUNポートを除くすべて無効にUDPとTCPポートと、STUNに専用ホスト上で実行することをお勧めします。これは彼らの妥協を防ぐために、STUNサーバに感染するウイルスやトロイの木馬を防ぐためです。これは、I（12.2.1）のアプローチを軽減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thirdly, to prevent the DNS attack of Section 12.2.2, Section 9.2 recommends that the client verify the credentials provided by the server with the name used in the DNS lookup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第三に、12.2.2のDNS攻撃を防ぐために、9.2節では、クライアントがDNSルックアップで使用された名前のサーバが提供する資格情報を確認することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, all of the attacks above rely on the client taking the mapped address it learned from STUN, and using it in application layer protocols. If encryption and message integrity are provided within those protocols, the eavesdropping and identity assumption attacks can be prevented. As such, applications that make use of STUN addresses in application protocols SHOULD use integrity and encryption, even if a SHOULD level strength is not specified for that protocol. For example, multimedia applications using STUN addresses to receive RTP traffic would use secure RTP [16].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、攻撃のすべては、上記のそれはSTUNから学んだマップされたアドレスを取得し、アプリケーション層プロトコルでそれを使用して、クライアントに依存しています。暗号化とメッセージの整合性が、これらのプロトコル内に設けられている場合は、盗聴やアイデンティティ仮定攻撃を防止することができます。そのため、アプリケーションプロトコルでSTUNアドレスを使用するアプリケーションは、SHOULDレベルの強さはそのプロトコル用に指定されていない場合でも、整合性と暗号化を使用すべきです。例えば、RTPトラフィックを受信するためにSTUNアドレスを使用してマルチメディアアプリケーションは、安全なRTP [16]を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above three techniques are non-STUN mechanisms. STUN itself provides several countermeasures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記3つの技術は、非STUNメカニズムです。 STUN自体は、いくつかの対策を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Approaches IV (Section 12.2.4), when generating the response locally, and V (Section 12.2.5) require an attacker to generate a faked response. This attack is prevented using the message integrity mechanism provided in STUN, described in Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IV（セクション12.2.4）、局所的応答を生成し、V（セクション12.2.5）は偽造応答を生成するために、攻撃者が必要に近づきます。この攻撃は、8.1節で説明STUNに設けられたメッセージ完全性機構を使用して防止することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Approaches III (Section 12.2.3) IV (Section 12.2.4), when using the relaying technique, and VI (12.2.6), however, are not preventable through server signatures. Both approaches are most potent when the attacker can modify the request, inserting a RESPONSE-ADDRESS that routes to the client. Fortunately, such modifications are preventable using the message integrity techniques described in Section 9.3. However, these three approaches are still functional when the attacker modifies nothing but the source address of the STUN request. Sadly, this is the one thing that cannot be protected through cryptographic means, as this is the change that STUN itself is seeking to detect and report. It is therefore an inherent weakness in NAT, and not fixable in STUN. To help mitigate these attacks, Section 9.4 provides several heuristics for the client to follow. The client looks for inconsistent or extra responses, both of which are signs of the attacks described above. However, these heuristics are just that - heuristics, and cannot be guaranteed to prevent attacks. The heuristics appear to prevent the attacks as we know how to launch them today. Implementors should stay posted for information on new heuristics that might be required in the future. Such information will be distributed on the IETF MIDCOM mailing list, midcom@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中継方式を使用する場合、III（セクション12.2.3）IV（セクション12.2.4）に近づく、及びVI（12.2.6）、しかし、サーバ署名を通じて予防ありません。攻撃者がそのクライアントへのルート応答アドレスを挿入し、要求を変更することができたときに両方のアプローチは、最も強力です。幸いなことに、そのような改変は、セクション9.3で説明したメッセージの完全性技術を用いて予防可能です。攻撃者がSTUN要求の送信元アドレスだけを変更していない場合しかし、これらの3つのアプローチがまだ機能しています。これはSTUN自身が検出してレポートしようとしている変更であるよう悲しいことに、これは、暗号化の手段で保護することができない一つのことです。したがって、本来のNATでの弱さ、そしてSTUNで修正可能ではありません。これらの攻撃を軽減するために、9.4節では、クライアントが追従するためのいくつかのヒューリスティックを提供します。クライアントは、上記の攻撃の兆候ですどちらも矛盾や余分な応答を探します。ヒューリスティック、および攻撃を防ぐために保証することはできません - しかし、これらの経験則はまさにそれです。ヒューリスティックは、私たちが今日、それらを起動する方法を知っているような攻撃を防ぐように見えます。実装者は、将来的に必要になる場合があります新しいヒューリスティックについては、掲載滞在する必要があります。このような情報は、IETF MIDCOMメーリングリスト、midcom@ietf.orgに配布されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4 Residual Threats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4残留脅威
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
None of the countermeasures listed above can prevent the attacks described in Section 12.2.3 if the attacker is in the appropriate network paths. Specifically, consider the case in which the attacker wishes to convince client C that it has address V. The attacker needs to have a network element on the path between A and the server (in order to modify the request) and on the path between the server and V so that it can forward the response to C. Furthermore, if there is a NAT between the attacker and the server, V must also be behind the same NAT. In such a situation, the attacker can either gain access to all the application-layer traffic or mount the DDOS attack described in Section 12.1.1. Note that any host which exists in the correct topological relationship can be DDOSed. It need not be using STUN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、適切なネットワーク・パスにある場合、上記の対策のいずれも、セクション12.2.3に記載の攻撃を防ぐことはできません。具体的には、攻撃者は、それが攻撃者が（リクエストを修正するために）Aとサーバーとの間の経路上のネットワーク要素を持つ必要アドレスVを有するクライアントCを説得したい場合を考えるとの間の経路に攻撃者とサーバ間のNATがある場合、それは、さらにC.への応答を転送できるように、サーバーおよびVは、Vは、同じNATの背後でなければなりません。このような状況では、攻撃者は、すべてのアプリケーション層のトラフィックへのアクセスを得るか、12.1.1項で説明したDDOS攻撃を仕掛けることができます。正しい位相関係に存在するすべてのホストがDDOSedことができることに注意してください。これは、STUNを使用する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN cannot be extended. Changes to the protocol are made through a standards track revision of this specification. As a result, no IANA registries are needed. Any future extensions will establish any needed registries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNを拡張することはできません。プロトコルへの変更は、この仕様の標準化トラック改正を介して行われます。その結果、IANAレジストリは必要ありません。任意の将来の拡張には、必要なレジストリを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. IAB Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. IABの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IAB has studied the problem of &#34;Unilateral Self Address Fixing&#34;, which is the general process by which a client attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol reflection mechanism (RFC 3424 [17]). STUN is an example of a protocol that performs this type of function. The IAB has mandated that any protocols developed for this purpose document a specific set of considerations. This section meets those requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IABは、クライアントが協調プロトコル反射機構を介してNATの反対側に別の領域にそのアドレスを決定しようとすることによって一般的な方法は「一方的な自己アドレス固定」の問題を研究した（RFC 3424 [17] ）。 STUNは、関数のこのタイプを行うプロトコルの一例です。 IABは、任意のプロトコルは、この目的の文書の検討事項の特定のセットを開発することを義務付けています。ここでは、これらの要件を満たしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1 Problem Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1問題定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From RFC 3424 [17], any UNSAF proposal must provide:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 3424 [17]から、任意のUNSAF提案を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Precise definition of a specific, limited-scope problem that is to be solved with the UNSAF proposal. A short term fix should not be generalized to solve other problems; this is why &#34;short term fixes usually aren&#39;t&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
UNSAF提案で解決されるべき特定の、限定されたスコープの問題の正確な定義。短期的な修正は、他の問題を解決するために一般化すべきではありません。 「短期の修正は通常はない」理由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specific problems being solved by STUN are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNによって解決されている具体的な問題は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Provide a means for a client to detect the presence of one or more NATs between it and a server run by a service provider on the public Internet. The purpose of such detection is to determine additional steps that might be necessary in order to receive service from that particular provider.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは、公共のインターネット上のサービスプロバイダによって運営サーバーとの間の1つのまたは複数のNATの存在を検出するためのクライアントのための手段を提供します。そのような検出の目的は、特定のプロバイダからサービスを受信するために必要かもしれない追加のステップを決定することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Provide a means for a client to detect the presence of one or more NATs between it and another client, where the second client is reachable from the first, but it is not known whether the second client resides on the public Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれと第2のクライアントが最初から到達可能であるが、第2のクライアントは、パブリックインターネット上に存在するかどうかは知られていない別のクライアントとの間の1つのまたは複数のNATの存在を検出するためのクライアントのための手段を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Provide a means for a client to obtain an address on the public Internet from a non-symmetric NAT, for the express purpose of receiving incoming UDP traffic from another host, targeted to that address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクライアントがそのアドレスをターゲットに別のホストからの着信UDPトラフィックを受信する明確な目的のために、非対称NATから公共のインターネット上のアドレスを取得するための手段を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN does not address TCP, either incoming or outgoing, and does not address outgoing UDP communications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNは、着信または発信のいずれか、TCPには対応していません、および発信UDP通信に対応していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2 Exit Strategy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2出口戦略
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From [17], any UNSAF proposal must provide:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17]から、任意のUNSAF提案を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Description of an exit strategy/transition plan. The better short term fixes are the ones that will naturally see less and less use as the appropriate technology is deployed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
出口戦略/移行計画の説明。より良い短期間フィックスは、適切な技術が展開されると自然に減って使用が表示されますものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN comes with its own built in exit strategy. This strategy is the detection operation that is performed as a precursor to the actual UNSAF address-fixing operation. This discovery operation, documented in Section 10.1, attempts to discover the existence of, and type of, any NATS between the client and the service provider network. Whilst the detection of the specific type of NAT may be brittle, the discovery of the existence of NAT is itself quite robust. As NATs are phased out through the deployment of IPv6, the discovery operation will return immediately with the result that there is no NAT, and no further operations are required. Indeed, the discovery operation itself can be used to help motivate deployment of IPv6; if a user detects a NAT between themselves and the public Internet, they can call up their access provider and complain about it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNは出口戦略に組み込まれた独自の付属しています。この戦略は、実際のUNSAFアドレス定着動作の前駆体として実行される検出動作です。 10.1節に記載この発見操作は、クライアントとサービスプロバイダネットワークの間のいずれかのNATSの存在を発見しようとする、との種類。 NATの特定のタイプの検出が脆くなるかもしれないが、NATの存在の発見は、それ自体は非常に堅牢です。 NATのは、IPv6の展開を通じて段階的に廃止されると、検出操作は、そこにはNATでなく、それ以上の操作は必要ありません、その結果、すぐに戻ります。実際に、検出操作自体は、IPv6の意欲を高める展開を支援するために使用することができます。ユーザーが自分自身と公共のインターネット間のNATを検出した場合、彼らは彼らのアクセスプロバイダを呼び出し、それについて文句を言うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN can also help facilitate the introduction of midcom. As midcom-capable NATs are deployed, applications will, instead of using STUN (which also resides at the application layer), first allocate an address binding using midcom. However, it is a well-known limitation of midcom that it only works when the agent knows the middleboxes through which its traffic will flow. Once bindings have been allocated from those middleboxes, a STUN detection procedure can validate that there are no additional middleboxes on the path from the public Internet to the client. If this is the case, the application can continue operation using the address bindings allocated from midcom. If it is not the case, STUN provides a mechanism for self-address fixing through the remaining midcom-unaware middleboxes. Thus, STUN provides a way to help transition to full midcom-aware networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNはまた、MIDCOMの導入を促進することができます。 MIDCOM対応のNATが展開されるように、アプリケーションは、代わりに（また、アプリケーション層に常駐）STUNを使用する、最初のMIDCOMを使用してバインディングアドレスを割り当てます。しかし、それはエージェントがそのトラフィックが流れるミドルボックスを知っているときにのみ動作MIDCOMのよく知られた制限です。バインディングは、これらのミドルボックスから割り当てられた後は、STUN検出手順は、クライアントへのパブリックインターネットからのパスには、追加のミドルボックスが存在しないことを確認することができます。この場合、アプリケーションはMIDCOMから割り当てられたアドレス・バインディングを使用して動作を継続することができます。それがない場合、STUN残りMIDCOM-気付か中間装置を介して定着自己アドレスのためのメカニズムを提供します。このように、STUNはフルMIDCOM対応のネットワークへの移行を支援するための方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3 Brittleness Introduced by STUN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
STUNによって導入さ14.3脆性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From [17], any UNSAF proposal must provide:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17]から、任意のUNSAF提案を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion of specific issues that may render systems more &#34;brittle&#34;. For example, approaches that involve using data at multiple network layers create more dependencies, increase debugging challenges, and make it harder to transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
システムより「脆い」レンダリングすることがあり、特定の問題の議論。たとえば、複数のネットワーク層でデータを使用することを含むアプローチは、デバッグの課題を高め、移行することが難しく、より多くの依存関係を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN introduces brittleness into the system in several ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNは、いくつかの方法でシステムにもろさが導入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The discovery process assumes a certain classification of devices based on their treatment of UDP. There could be other types of NATs that are deployed that would not fit into one of these molds. Therefore, future NATs may not be properly detected by STUN. STUN clients (but not servers) would need to change to accommodate that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O発見プロセスは、UDPの彼らの治療に基づいてデバイスの特定の分類を前提としています。これらの金型のいずれかに収まらない展開されているNATの他のタイプがあるかもしれません。したがって、将来のNATは正しくSTUNによって検出されなくてもよいです。 STUNクライアント（ただし、サーバは）そのに適応するように変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The binding acquisition usage of STUN does not work for all NAT types. It will work for any application for full cone NATs only. For restricted cone and port restricted cone NAT, it will work for some applications depending on the application. Application specific processing will generally be needed. For symmetric NATs, the binding acquisition will not yield a usable address. The tight dependency on the specific type of NAT makes the protocol brittle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O STUNの結合を取得使用量は、すべてのNATタイプでは動作しません。それは唯一のフルコーンNATのための任意のアプリケーションのために動作します。制限付きコーン、ポート制限付きコーンNATの場合は、アプリケーションに応じて、いくつかの用途のために動作します。アプリケーション固有の処理は、一般的に必要とされるであろう。対称型NATのために、結合の取得は、利用可能なアドレスを得られません。 NATの特定のタイプのタイトな依存性は、プロトコルが脆くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STUN assumes that the server exists on the public Internet. If the server is located in another private address realm, the user may or may not be able to use its discovered address to communicate with other users. There is no way to detect such a condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O STUNサーバは公共のインターネット上に存在することを前提としています。サーバが別のプライベートアドレスレルムに配置されている場合、ユーザーは、他のユーザと通信するために、その発見されたアドレスを使用することができない場合があります。このような状態を検出する方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The bindings allocated from the NAT need to be continuously refreshed. Since the timeouts for these bindings is very implementation specific, the refresh interval cannot easily be determined. When the binding is not being actively used to receive traffic, but to wait for an incoming message, the binding refresh will needlessly consume network bandwidth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NATから割り当てられたバインディングoを継続的にリフレッシュする必要があります。これらのバインディングのためのタイムアウトは非常に実装固有のものですので、リフレッシュ間隔を容易に判断することはできません。バインディングがアクティブにトラフィックを受信することが、着信メッセージを待つために使用されていない場合は、バインディングリフレッシュが不必要なネットワーク帯域幅を消費します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of the STUN server as an additional network element introduces another point of potential security attack. These attacks are largely prevented by the security measures provided by STUN, but not entirely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加のネットワーク要素としてSTUNサーバーの使用oを潜在的なセキュリティ攻撃の別のポイントを紹介します。これらの攻撃は、主にではなく、完全に、STUNが提供するセキュリティ対策によって阻止されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of the STUN server as an additional network element introduces another point of failure. If the client cannot locate a STUN server, or if the server should be unavailable due to failure, the application cannot function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加のネットワーク要素としてSTUNサーバの使用oを故障の別のポイントを導入します。クライアントは、STUNサーバーが見つからない場合、またはサーバーが障害により使用できなくする必要がある場合は、アプリケーションが機能することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of STUN to discover address bindings will result in an increase in latency for applications. For example, a Voice over IP application will see an increase of call setup delays equal to at least one RTT to the STUN server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oアドレスバインディングを発見するSTUNの使用は、アプリケーションのための待ち時間の増加をもたらすでしょう。例えば、ボイスオーバーIPアプリケーションは、STUNサーバに少なくとも1 RTTに等しい呼設定遅延の増加が表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The discovery of binding lifetimes is prone to error. It assumes that the same lifetime will exist for all bindings. This may not be true if the NAT uses dynamic binding lifetimes to handle overload, or if the NAT itself reboots during the discovery process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O結合寿命の発見は、エラーを起こしやすいです。これは、同じ寿命はすべてのバインディングのために存在することを前提としています。 NATは、過負荷を処理するために動的結合ライフタイムを使用する場合、またはNAT自体が発見プロセス中に再起動されます場合、これは本当ではないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STUN imposes some restrictions on the network topologies for proper operation. If client A obtains an address from STUN server X, and sends it to client B, B may not be able to send to A using that IP address. The address will not work if any of the following is true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O STUNは、適切な動作のためのネットワーク・トポロジにはいくつかの制限を課しています。クライアントAは、STUNサーバXからアドレスを取得し、クライアントBに送信した場合、Bは、そのIPアドレスを使用して送信することができない場合があります。以下のいずれかに該当する場合のアドレスは動作しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The STUN server is not in an address realm that is a common ancestor (topologically) of both clients A and B. For example, consider client A and B, both of which have residential NAT devices. Both devices connect them to their cable operators, but both clients have different providers. Each provider has a NAT in front of their entire network, connecting it to the public Internet. If the STUN server used by A is in A&#39;s cable operator&#39;s network, an address obtained by it will not be usable by B. The STUN server must be in the network which is a common ancestor to both - in this case, the public Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  STUNサーバは、たとえば、両方のクライアントAとBの共通の祖先（位相幾何学）であるアドレス領域で、住宅のNATデバイスを持っているどちらも、クライアントAとBを考慮されていません。両デバイスは、彼らのケーブル事業者に接続しますが、両方のクライアントは異なるプロバイダを持っています。各プロバイダは、公衆インターネットに接続し、そのネットワーク全体の前でNATを持っています。この場合、公衆インターネットで -  Aが使用するSTUNサーバがAのケーブルオペレータのネットワーク内にある場合、それによって得られたアドレスは、両方に共通の祖先であるネットワーク内にある必要がありB.ザSTUNサーバによって使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- The STUN server is in an address realm that is a common ancestor to both clients, but both clients are behind the same NAT connecting to that address realm. For example, if the two clients in the previous example had the same cable operator, that cable operator had a single NAT connecting their network to the public Internet, and the STUN server was on the public Internet, the address obtained by A would not be usable by B. That is because some NATs will not accept an internal packet sent to a public IP address which is mapped back to an internal address. To deal with this, additional protocol mechanisms or configuration parameters need to be introduced which detect this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 -  STUNサーバーは、両方のクライアントに共通の祖先であるアドレス領域であるが、両方のクライアントは、そのアドレスレルムに接続し、同じNATの背後にあります。例えば、前の例では2つのクライアントが同じケーブルオペレータを持っていた場合は、そのケーブルオペレータは、公共のインターネットに自分のネットワークを接続する単一のNATを持っていた、とSTUNサーバは公共のインターネット上にあった、Aで得られたアドレスはないだろういくつかのNATは、内部アドレスに戻ってマッピングされているパブリックIPアドレスに送信された内部パケットを受け付けませんので、B.によって使用可能であること。これに対処するために、追加のプロトコル機構又は構成パラメータは、この場合の検出が導入される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Most significantly, STUN introduces potential security threats which cannot be eliminated. This specification describes heuristics that can be used to mitigate the problem, but it is provably unsolvable given what STUN is trying to accomplish. These security problems are described fully in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O最も重要なのは、STUNを排除することができない潜在的なセキュリティ上の脅威を紹介します。この仕様は、問題を軽減するために使用することができヒューリスティックを説明し、それが達成しようとしているものSTUN与えられた証明可能解決不可能です。これらのセキュリティ問題はセクション12で完全に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4 Requirements for a Long Term Solution
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
長期的な解決策のための14.4要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From [17], any UNSAF proposal must provide:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17]から、任意のUNSAF提案を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Identify requirements for longer term, sound technical solutions -- contribute to the process of finding the right longer term solution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
技術的な解決策を鳴らし、長期の要件を特定する - 右の長期的な解決策を見つけるプロセスに貢献します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Our experience with STUN has led to the following requirements for a long term solution to the NAT problem:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNでの経験は、NAT問題への長期的な解決策のために、次の要件につながっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Requests for bindings and control of other resources in a NAT need to be explicit. Much of the brittleness in STUN derives from its guessing at the parameters of the NAT, rather than telling the NAT what parameters to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バインディングやNAT内の他のリソースの制御のための要求は、明示的にする必要があります。 STUNにおける脆性の多くは、そのは、NATのパラメータを推測ではなく、使用するかをパラメータNATを伝えるに由来します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Control needs to be &#34;in-band&#34;. There are far too many scenarios in which the client will not know about the location of middleboxes ahead of time. Instead, control of such boxes needs to occur in-band, traveling along the same path as the data will itself travel. This guarantees that the right set of middleboxes are controlled. This is only true for first-party controls; third-party controls are best handled using the midcom framework.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コントロールは、「インバンド」である必要があります。クライアントは、事前にミドルボックスの場所を知っていないであろうに、あまりにも多くのシナリオがあります。代わりに、このようなボックスの制御は、それ自体が移動するデータと同じ経路に沿って移動する、インバンド発生する必要があります。これは、ミドルボックスの右のセットが制御されていることを保証します。これは、ファーストパーティのコントロールのための唯一の真実です。サードパーティ製のコントロールは、最高のMIDCOMフレームワークを使用して処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Control needs to be limited. Users will need to communicate through NATs which are outside of their administrative control. In order for providers to be willing to deploy NATs which can be controlled by users in different domains, the scope of such controls needs to be extremely limited - typically, allocating a binding to reach the address where the control packets are coming from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コントロールは制限する必要があります。ユーザーは、管理制御の外にあるNATを介して通信する必要があります。典型的には、制御パケットから来ているアドレスに到達するために結合を割り当てる - プロバイダが異なるドメイン内のユーザによって制御することができるのNATを展開することをいとわないようにするために、そのようなコントロールの範囲は極めて限定される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Simplicity is Paramount. The control protocol will need to be implement in very simple clients. The servers will need to support extremely high loads. The protocol will need to be extremely robust, being the precursor to a host of application protocols. As such, simplicity is key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンプルさが最も重要です。制御プロトコルは、非常に単純なクライアントに実装する必要があります。サーバーは、非常に高い負荷をサポートする必要があります。プロトコルは、アプリケーションプロトコルのホストへの前駆体である、非常に堅牢である必要があります。そのように、シンプルさが鍵となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5 Issues with Existing NAPT Boxes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
既存のNAPT箱と14.5の問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From [17], any UNSAF proposal must provide:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17]から、任意のUNSAF提案を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Discussion of the impact of the noted practical issues with existing, deployed NA[P]Ts and experience reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
既存と述べた実用的な問題の影響の議論は、NA [P] Tsと体験レポートを展開しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several of the practical issues with STUN involve future proofing - breaking the protocol when new NAT types get deployed. Fortunately, this is not an issue at the current time, since most of the deployed NATs are of the types assumed by STUN. The primary usage STUN has found is in the area of VoIP, to facilitate allocation of addresses for receiving RTP [12] traffic. In that application, the periodic keepalives are provided by the RTP traffic itself. However, several practical problems arise for RTP. First, RTP assumes that RTCP traffic is on a port one higher than the RTP traffic. This pairing property cannot be guaranteed through NATs that are not directly controllable. As a result, RTCP traffic may not be properly received. Protocol extensions to SDP have been proposed which mitigate this by allowing the client to signal a different port for RTCP [18]. However, there will be interoperability problems for some time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNと実用的な問題のいくつかは、今後の校正を必要とする - 新しいNATタイプが展開され得るときのプロトコルを破ります。展開のNATのほとんどはSTUNが想定しているタイプがあるので、幸いなことに、これは、現在の時点での問題ではありません。発見した一次利用STUNはRTP [12]トラフィックを受信するためのアドレスの割り当てを容易にするために、VoIPの領域です。そのアプリケーションでは、定期的なキープアライブはRTPトラフィック自体によって提供されています。しかし、いくつかの実際的な問題は、RTPのために発生します。まず、RTPはRTCPトラフィックはRTPトラフィックよりも高いポート1であることを前提としています。このペアリングプロパティは直接制御できませんNATを経由保証することはできません。その結果、RTCPトラフィックが正常に受信できない場合があります。 SDPのプロトコル拡張は、クライアントは、RTCP [18]のために別のポートをシグナリングすることを可能にすることによってこれを緩和が提案されています。しかし、いくつかの時間のための相互運用性の問題があるでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For VoIP, silence suppression can cause a gap in the transmission of RTP packets. This could result in the loss of a binding in the middle of a call, if that silence period exceeds the binding timeout. This can be mitigated by sending occasional silence packets to keep the binding alive. However, the result is additional brittleness; proper operation depends on the silence suppression algorithm in use, the usage of a comfort noise codec, the duration of the silence period, and the binding lifetime in the NAT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VoIPのために、無音圧縮はRTPパケットの送信のギャップを引き起こす可能性があります。その沈黙期間が結合タイムアウトを超えた場合、これは、コールの途中で結合の損失につながる可能性があります。これは、結合生きを保つために時折無音パケットを送信することにより緩和することができます。しかし、結果は、追加の脆性です。適切な動作は、使用中の無音抑制アルゴリズム、快適雑音コーデック、沈黙期間の継続時間、およびNATに結合ライフタイムの使用に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.6 In Closing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
最後に14.6
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The problems with STUN are not design flaws in STUN. The problems in STUN have to do with the lack of standardized behaviors and controls in NATs. The result of this lack of standardization has been a proliferation of devices whose behavior is highly unpredictable, extremely variable, and uncontrollable. STUN does the best it can in such a hostile environment. Ultimately, the solution is to make the environment less hostile, and to introduce controls and standardized behaviors into NAT. However, until such time as that happens, STUN provides a good short term solution given the terrible conditions under which it is forced to operate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNの問題点は、STUNの欠陥を設計されていません。 STUNの問題点は、NATの中に標準化された行動とコントロールの欠如としなければなりません。標準化の欠如の結果は、行動、非常に予測不可能な非常に変数、および制御不能であるデバイスの急増となっています。 STUNは、このような過酷な環境でそれができる最善を尽くします。最終的に、解決策は、環境があまり敵対的にするために、およびNATにコントロールし、標準化された行動を導入することです。しかし、それが起こるような時間まで、STUNは、動作するように強制されたの下でひどい状況与えられた良い短期的ソリューションを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Cedric Aoun, Pete Cordell, Cullen Jennings, Bob Penfield and Chris Sullivan for their comments, and Baruch Sterman and Alan Hawrylyshen for initial implementations. Thanks for Leslie Daigle, Allison Mankin, Eric Rescorla, and Henning Schulzrinne for IESG and IAB input on this work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者は、初期の実装のためのセドリックアウン、ピートコーデル、カレン・ジェニングス、ボブペンフィールドとクリス・サリバン彼らのコメントのために、とバルークStermanとアランHawrylyshenに感謝したいと思います。レスリーDaigle氏、アリソンマンキン、エリックレスコラ、およびIESGのためのヘニングSchulzrinneとし、この作品のIAB入力いただきありがとうございます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Bradner, S., &#34;Key words for use in RFCs to indicate requirement levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1]ブラドナーの、S.、 &#34;要件レベルを示すRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月を。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Dierks, T. and C. Allen, &#34;The TLS protocol Version 1.0&#34;, RFC 2246, January 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2]ダークス、T.及びC.アレン、 &#34;TLSプロトコルバージョン1.0&#34;、RFC 2246、1999年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Gulbrandsen, A., Vixie, P. and L. Esibov, &#34;A DNS RR for specifying the location of services (DNS SRV)&#34;, RFC 2782, February 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Gulbrandsenの、A.、いるVixie、P.及びL. Esibov、 &#34;（DNSのSRV）サービスの位置を特定するためのDNS RR&#34;、RFC 2782、2000年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Chown, P., &#34;Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)&#34;, RFC 3268, June 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4]、RFC 3268、2002年6月のchown、P.、 &#34;トランスポート層セキュリティ（TLS）用のAdvanced Encryption Standard（AES）暗号の組み合わせを&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Rescorla, E., &#34;HTTP over TLS&#34;, RFC 2818, May 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5]レスコラ、E.、 &#34;TLSオーバーHTTP&#34;、RFC 2818、2000年5月を。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Postel, J., &#34;Internet Protocol&#34;, STD 5, RFC 791, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6]ポステル、J.、 &#34;インターネットプロトコル&#34;、STD 5、RFC 791、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Ferguson, P. and D. Senie, &#34;Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing&#34;, BCP 38, RFC 2827, May 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7]ファーガソン、P.およびD. Senie、 &#34;ネットワーク入力フィルタリング：IP Source Address Spoofingを使うサービス拒否攻撃を破り&#34;、BCP 38、RFC 2827、2000年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Senie, D., &#34;Network Address Translator (NAT)-Friendly Application Design Guidelines&#34;, RFC 3235, January 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Senie、D.、 &#34;ネットワークアドレス変換（NAT）フレンドリアプリケーションの設計ガイドライン&#34;、RFC 3235、2002年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A. and A. Rayhan, &#34;Middlebox Communication Architecture and Framework&#34;, RFC 3303, August 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Srisuresh、P.、Kuthan、J.、ローゼンバーグ、J.、モリター、A.とA. Rayhan、 &#34;ミドル通信アーキテクチャとフレームワーク&#34;、RFC 3303、2002年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M. and E. Schooler, &#34;SIP: Session Initiation Protocol&#34;, RFC 3261, June 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 &#34;SIP：セッション開始プロトコル&#34;、 RFC 3261、2002年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Holdrege, M. and P. Srisuresh, &#34;Protocol Complications with the IP Network Address Translator&#34;, RFC 3027, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11]ホールドレッジ、M.とP. Srisuresh、 &#34;IPネットワークアドレス変換とプロトコルの合併症&#34;、RFC 3027、2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, RFC 1889, January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Schulzrinneと、H.、Casner、S.、フレデリック、R.とV. Jacobson氏、 &#34;RTP：リアルタイムアプリケーションのためのトランスポートプロトコル&#34;、RFC 1889、1996年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Krawczyk, H., Bellare, M. and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Krawczyk、H.、ベラー、M。およびR.カネッティ、 &#34;HMAC：メッセージ認証のための鍵付きハッシュ化&#34;、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] Kohl, J. and C. Neuman, &#34;The kerberos Network Authentication Service (V5)&#34;, RFC 1510, September 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14]コールズ、J.及びC.ノイマン、 &#34;ケルベロスネットワーク認証サービス（V5）&#34;、RFC 1510、1993年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. and T. Berners-Lee, &#34;Hypertext Transfer Protocol -- HTTP/1.1&#34;, RFC 2616, June 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 &#34;ハイパーテキスト転送プロトコル -  HTTP / 1.1&#34;、 RFC 2616、1999年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Baugher M., et al., &#34;The secure real-time transport protocol&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Baugher M.、ら、 &#34;セキュアリアルタイムトランスポートプロトコル&#34;、ProgressのWork。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Daigle, L., Editor, &#34;IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation&#34;, RFC 3424, November 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Daigle氏、L.、エディタ、 &#34;一方的な自己アドレス固定するためのIABの考慮事項（UNSAF）ネットワークアドレス変換アクロス&#34;、RFC 3424、2002年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] Huitema, C., &#34;RTCP attribute in SDP&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18]のHuitema、C.、 &#34;SDPにおけるRTCP属性&#34;、ProgressのWork。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.著者のアドレス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jonathan Rosenberg dynamicsoft 72 Eagle Rock Avenue First Floor East Hanover, NJ 07936
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
72イーグルロックアベニューまず階イーストハノーバー、NJ 07936 dynamicsoftジョナサン・ローゼンバーグ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: jdrosen@dynamicsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：jdrosen@dynamicsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joel Weinberger dynamicsoft 72 Eagle Rock Avenue First Floor East Hanover, NJ 07936
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
72イーグルロックアベニューまず階イーストハノーバー、NJ 07936 dynamicsoftジョエル・ワインバーガー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: jweinberger@dynamicsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：jweinberger@dynamicsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Christian Huitema Microsoft Corporation One Microsoft Way Redmond, WA 98052-6399
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クリスチャンのHuitemaマイクロソフト社1つのマイクロソフト道、レドモンド、WA 98052-6399
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: huitema@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：huitema@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rohan Mahy Cisco Systems 101 Cooper St Santa Cruz, CA 95060
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロハンマーイシスコシステムズ101クーパーセントサンタクルス、CA 95060
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: rohan@cisco.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：rohan@cisco.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.完全な著作権声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2003). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）インターネット協会（2003）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
